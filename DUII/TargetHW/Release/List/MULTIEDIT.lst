###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:16:25 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\MULTIEDIT.c                         #
#    Command line =  C:\DUII\TargetHW\GUI\MULTIEDIT.c -D DEBUG=1 -D           #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\MULTIEDIT.lst              #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\MULTIEDIT.o                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\MULTIEDIT.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : MULTIEDIT.c
     19          Purpose     : Implementation of MULTIEDIT widget
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stdlib.h>
     24          #include <string.h>
     25          #include "MULTIEDIT.h"
     26          #include "WIDGET.h"
     27          #include "WM_Intern.h"
     28          
     29          #if GUI_WINSUPPORT
     30          
     31          /*********************************************************************
     32          *
     33          *       Private config defaults
     34          *
     35          **********************************************************************
     36          */
     37          
     38          /* Define default fonts */
     39          #ifndef MULTIEDIT_FONT_DEFAULT
     40            #if   WIDGET_USE_SCHEME_SMALL
     41              #define MULTIEDIT_FONT_DEFAULT &GUI_Font13_1
     42            #elif WIDGET_USE_SCHEME_MEDIUM
     43              #define MULTIEDIT_FONT_DEFAULT &GUI_Font16_1
     44            #elif WIDGET_USE_SCHEME_LARGE
     45              #define MULTIEDIT_FONT_DEFAULT &GUI_Font24_1
     46            #endif
     47          #endif
     48          
     49          /* Define colors */
     50          #ifndef MULTIEDIT_BKCOLOR0_DEFAULT
     51            #define MULTIEDIT_BKCOLOR0_DEFAULT   GUI_WHITE
     52          #endif
     53          
     54          #ifndef MULTIEDIT_BKCOLOR1_DEFAULT
     55            #define MULTIEDIT_BKCOLOR1_DEFAULT   0xC0C0C0
     56          #endif
     57          
     58          #ifndef MULTIEDIT_TEXTCOLOR0_DEFAULT
     59            #define MULTIEDIT_TEXTCOLOR0_DEFAULT GUI_BLACK
     60          #endif
     61          
     62          #ifndef MULTIEDIT_TEXTCOLOR1_DEFAULT
     63            #define MULTIEDIT_TEXTCOLOR1_DEFAULT GUI_BLACK
     64          #endif
     65          
     66          /* Define character for password mode */
     67          #define MULTIEDIT_PASSWORD_CHAR   '*'
     68          
     69          #define MULTIEDIT_REALLOC_SIZE  16
     70          
     71          /*********************************************************************
     72          *
     73          *       Object definition
     74          *
     75          **********************************************************************
     76          */
     77          
     78          #define NUM_DISP_MODES 2
     79          
     80          #define INVALID_NUMCHARS (1 << 0)
     81          #define INVALID_NUMLINES (1 << 1)
     82          #define INVALID_TEXTSIZE (1 << 2)
     83          #define INVALID_CURSORXY (1 << 3)
     84          #define INVALID_LINEPOSB (1 << 4)
     85          
     86          typedef struct {
     87            WIDGET Widget;
     88            GUI_COLOR aBkColor[NUM_DISP_MODES];
     89            GUI_COLOR aColor[NUM_DISP_MODES];
     90            WM_HMEM hText;
     91            U16 MaxNumChars;         /* Maximum number of characters including the prompt */
     92            U16 NumChars;            /* Number of characters (text and prompt) in object */
     93            U16 NumCharsPrompt;      /* Number of prompt characters */
     94            U16 NumLines;            /* Number of text lines needed to show all data */
     95            U16 TextSizeX;           /* Size in X of text depending of wrapping mode */
     96            U16 BufferSize;
     97            U16 CursorLine;          /* Number of current cursor line */
     98            U16 CursorPosChar;       /* Character offset number of cursor */
     99            U16 CursorPosByte;       /* Byte offset number of cursor */
    100            I16 CursorPosX;          /* Cursor position in X */
    101            U16 CursorPosY;          /* Cursor position in Y */
    102            U16 CacheLinePosByte;    /*  */
    103            U16 CacheLineNumber;     /*  */
    104            U16 CacheFirstVisibleLine;
    105            U16 CacheFirstVisibleByte;
    106            U16 Align;
    107            WM_SCROLL_STATE ScrollStateV;
    108            WM_SCROLL_STATE ScrollStateH;
    109            const GUI_FONT GUI_UNI_PTR * pFont;
    110            U8 Flags;
    111            U8 InvalidFlags;         /* Flags to save validation status */
    112            U8 EditMode;
    113            U8 HBorder;
    114            WM_HTIMER hTimer;
    115            GUI_WRAPMODE WrapMode;
    116            #if GUI_DEBUG_LEVEL >1
    117              int DebugId;
    118            #endif
    119          } MULTIEDIT_OBJ;
    120          
    121          /*********************************************************************
    122          *
    123          *       Static data
    124          *
    125          **********************************************************************
    126          */
    127          

   \                                 In section .data, align 4
    128          static GUI_COLOR _aDefaultBkColor[2] = {
   \                     _aDefaultBkColor:
   \   00000000   FFFFFF00C0C0       DC32 16777215, 12632256
   \              C000        
   \   00000008   000000000000       DC32 0, 0
   \              0000        
    129            MULTIEDIT_BKCOLOR0_DEFAULT,
    130            MULTIEDIT_BKCOLOR1_DEFAULT,
    131          };
    132          
    133          static GUI_COLOR _aDefaultColor[2] = {
    134            MULTIEDIT_TEXTCOLOR0_DEFAULT,
    135            MULTIEDIT_TEXTCOLOR1_DEFAULT,
    136          };
    137          

   \                                 In section .data, align 4
   \   00000000   ........           DC32 GUI_Font13_1
    138          static const GUI_FONT GUI_UNI_PTR * _pDefaultFont = MULTIEDIT_FONT_DEFAULT;
    139          
    140          /*********************************************************************
    141          *
    142          *       Macros for internal use
    143          *
    144          **********************************************************************
    145          */
    146          #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
    147            #define MULTIEDIT_INIT_ID(p) p->DebugId = MULTIEDIT_ID
    148          #else
    149            #define MULTIEDIT_INIT_ID(p)
    150          #endif
    151          
    152          #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
    153            MULTIEDIT_OBJ * MULTIEDIT_LockH(MULTIEDIT_HANDLE h);
    154            #define MULTIEDIT_LOCK_H(h)   MULTIEDIT_LockH(h)
    155          #else
    156            #define MULTIEDIT_LOCK_H(h)   (MULTIEDIT_OBJ *)GUI_LOCK_H(h)
    157          #endif
    158          
    159          /*********************************************************************
    160          *
    161          *       static code, helper functions
    162          *
    163          **********************************************************************
    164          */
    165          
    166          /*********************************************************************
    167          *
    168          *       _InvalidateNumChars
    169          *
    170          * Invalidates the number of characters including the prompt
    171          */
    172          static void _InvalidateNumChars(MULTIEDIT_OBJ * pObj) {
    173            pObj->InvalidFlags |= INVALID_NUMCHARS;
    174          }
    175          
    176          /*********************************************************************
    177          *
    178          *       _GetNumChars
    179          *
    180          * Calculates (if needed) and returns the number of characters including the prompt
    181          */
    182          static int _GetNumChars(MULTIEDIT_OBJ * pObj) {
    183            if (pObj->InvalidFlags & INVALID_NUMCHARS) {
    184              char * pText;
    185              pText = (char *)GUI_LOCK_H(pObj->hText);
    186              pObj->NumChars = GUI__GetNumChars(pText);
    187              GUI_UNLOCK_H(pText);
    188              pObj->InvalidFlags &= ~INVALID_NUMCHARS;
    189            }
    190            return pObj->NumChars;
    191          }
    192          
    193          /*********************************************************************
    194          *
    195          *       _GetXSize
    196          *
    197          * Returns the x size for displaying text.
    198          */
    199          static int _GetXSize(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ * pObj) {
    200            GUI_RECT Rect;
    201            WM_GetInsideRectExScrollbar(hObj, &Rect);
    202            return Rect.x1 - Rect.x0 - (pObj->HBorder * 2) - 1;
    203          }
    204          
    205          /*********************************************************************
    206          *
    207          *       _GetNumCharsInPrompt
    208          */
    209          static int _GetNumCharsInPrompt(const MULTIEDIT_OBJ * pObj, const char GUI_UNI_PTR * pText) {
    210            char *pString, *pEndPrompt;
    211            int r = 0;
    212            pString = (char *)GUI_LOCK_H(pObj->hText);
    213            pEndPrompt = pString + GUI_UC__NumChars2NumBytes(pString, pObj->NumCharsPrompt);
    214            if (pText < pEndPrompt) {
    215              r = GUI_UC__NumBytes2NumChars(pText, pEndPrompt - pText);
    216            }
    217            GUI_UNLOCK_H(pString);
    218            return r;
    219          }
    220          
    221          /*********************************************************************
    222          *
    223          *       _WrapGetNumCharsDisp
    224          */

   \                                 In section .text, align 4, keep-with-next
    225          static int _WrapGetNumCharsDisp(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ * pObj, const char GUI_UNI_PTR * pText) {
   \                     _WrapGetNumCharsDisp:
   \   00000000   F4412DE9           PUSH     {R2,R4-R8,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0150A0E1           MOV      R5,R1
    226            int xSize, r;
    227            xSize = _GetXSize(hObj, pObj);
   \   0000000C   0D10A0E1           MOV      R1,SP
   \   00000010   ........           BL       WM_GetInsideRectExScrollbar
   \   00000014   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000018   F010DDE1           LDRSH    R1,[SP, #+0]
   \   0000001C   010040E0           SUB      R0,R0,R1
   \   00000020   8710D5E5           LDRB     R1,[R5, #+135]
   \   00000024   810040E0           SUB      R0,R0,R1, LSL #+1
   \   00000028   014040E2           SUB      R4,R0,#+1
    228            if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
   \   0000002C   8400D5E5           LDRB     R0,[R5, #+132]
   \   00000030   200010E3           TST      R0,#0x20
   \   00000034   3300000A           BEQ      ??_WrapGetNumCharsDisp_0
    229              int NumCharsPrompt;
    230              NumCharsPrompt = _GetNumCharsInPrompt(pObj, pText);
   \   00000038   0C709DE5           LDR      R7,[SP, #+12]
   \   0000003C   0060A0E3           MOV      R6,#+0
   \   00000040   440095E5           LDR      R0,[R5, #+68]
   \   00000044   ........           BL       GUI_ALLOC_LockH
   \   00000048   0080A0E1           MOV      R8,R0
   \   0000004C   BC14D5E1           LDRH     R1,[R5, #+76]
   \   00000050   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000054   080080E0           ADD      R0,R0,R8
   \   00000058   000057E1           CMP      R7,R0
   \   0000005C   0300002A           BCS      ??_WrapGetNumCharsDisp_1
   \   00000060   071040E0           SUB      R1,R0,R7
   \   00000064   0700A0E1           MOV      R0,R7
   \   00000068   ........           BL       GUI_UC__NumBytes2NumChars
   \   0000006C   0060A0E1           MOV      R6,R0
   \                     ??_WrapGetNumCharsDisp_1:
   \   00000070   ........           BL       GUI_ALLOC_UnlockH
    231              r = GUI__WrapGetNumCharsDisp(pText, xSize, pObj->WrapMode);
   \   00000074   8C20D5E5           LDRB     R2,[R5, #+140]
   \   00000078   0410A0E1           MOV      R1,R4
   \   0000007C   0C009DE5           LDR      R0,[SP, #+12]
   \   00000080   ........           BL       GUI__WrapGetNumCharsDisp
   \   00000084   0070A0E1           MOV      R7,R0
    232              if (r >= NumCharsPrompt) {
   \   00000088   060057E1           CMP      R7,R6
   \   0000008C   220000BA           BLT      ??_WrapGetNumCharsDisp_2
    233                int x;
    234                switch (pObj->WrapMode) {
   \   00000090   8C00D5E5           LDRB     R0,[R5, #+140]
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   0200001A           BNE      ??_WrapGetNumCharsDisp_3
    235                case GUI_WRAPMODE_NONE:
    236                  r = GUI__GetNumChars(pText);
   \   0000009C   0C009DE5           LDR      R0,[SP, #+12]
   \   000000A0   ........           BL       GUI__GetNumChars
   \   000000A4   1B0000EA           B        ??_WrapGetNumCharsDisp_4
    237                  break;
    238                default:
    239                  r = NumCharsPrompt;
   \                     ??_WrapGetNumCharsDisp_3:
   \   000000A8   0670A0E1           MOV      R7,R6
    240                  x = GUI__GetLineDistX(pText, NumCharsPrompt);
   \   000000AC   0610A0E1           MOV      R1,R6
   \   000000B0   0C009DE5           LDR      R0,[SP, #+12]
   \   000000B4   ........           BL       GUI__GetLineDistX
   \   000000B8   0050A0E1           MOV      R5,R0
    241                  pText += GUI_UC__NumChars2NumBytes(pText, NumCharsPrompt);
   \   000000BC   0610A0E1           MOV      R1,R6
   \   000000C0   0C009DE5           LDR      R0,[SP, #+12]
   \   000000C4   ........           BL       GUI_UC__NumChars2NumBytes
   \   000000C8   0C109DE5           LDR      R1,[SP, #+12]
   \   000000CC   010080E0           ADD      R0,R0,R1
   \   000000D0   0C008DE5           STR      R0,[SP, #+12]
    242                  while (GUI_UC__GetCharCodeInc(&pText) != 0) {
   \                     ??_WrapGetNumCharsDisp_5:
   \   000000D4   0C008DE2           ADD      R0,SP,#+12
   \   000000D8   ........           BL       GUI_UC__GetCharCodeInc
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   0D00000A           BEQ      ??_WrapGetNumCharsDisp_2
    243                    x += GUI_GetCharDistX(MULTIEDIT_PASSWORD_CHAR);
   \   000000E4   2A00A0E3           MOV      R0,#+42
   \   000000E8   ........           BL       GUI_GetCharDistX
   \   000000EC   055080E0           ADD      R5,R0,R5
    244                    if (r && (x > xSize)) {
   \   000000F0   000057E3           CMP      R7,#+0
   \   000000F4   0100000A           BEQ      ??_WrapGetNumCharsDisp_6
   \   000000F8   050054E1           CMP      R4,R5
   \   000000FC   060000BA           BLT      ??_WrapGetNumCharsDisp_2
    245                      break;
    246                    }
    247                    r++;
   \                     ??_WrapGetNumCharsDisp_6:
   \   00000100   017087E2           ADD      R7,R7,#+1
   \   00000104   F2FFFFEA           B        ??_WrapGetNumCharsDisp_5
    248                  }
    249                  break;
    250                }
    251              }
    252            } else {
    253              r = GUI__WrapGetNumCharsDisp(pText, xSize, pObj->WrapMode);
   \                     ??_WrapGetNumCharsDisp_0:
   \   00000108   8C20D5E5           LDRB     R2,[R5, #+140]
   \   0000010C   0410A0E1           MOV      R1,R4
   \   00000110   0C009DE5           LDR      R0,[SP, #+12]
   \   00000114   ........           BL       GUI__WrapGetNumCharsDisp
   \                     ??_WrapGetNumCharsDisp_4:
   \   00000118   0070A0E1           MOV      R7,R0
    254            }
    255            return r;
   \                     ??_WrapGetNumCharsDisp_2:
   \   0000011C   0700A0E1           MOV      R0,R7
   \   00000120   10D08DE2           ADD      SP,SP,#+16
   \   00000124   F081BDE8           POP      {R4-R8,PC}       ;; return
    256          }
    257          
    258          /*********************************************************************
    259          *
    260          *       _WrapGetNumBytesToNextLine
    261          */

   \                                 In section .text, align 4, keep-with-next
    262          static int _WrapGetNumBytesToNextLine(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ * pObj, const char * pText) {
   \                     _WrapGetNumBytesToNextLine:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0060A0E1           MOV      R6,R0
   \   00000010   0240A0E1           MOV      R4,R2
    263            int xSize, r;
    264            xSize = _GetXSize(hObj, pObj);
   \   00000014   0D10A0E1           MOV      R1,SP
   \   00000018   ........           BL       WM_GetInsideRectExScrollbar
    265            if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
   \   0000001C   8400D5E5           LDRB     R0,[R5, #+132]
   \   00000020   200010E3           TST      R0,#0x20
   \   00000024   1C00000A           BEQ      ??_WrapGetNumBytesToNextLine_0
    266              int NumChars, NumCharsPrompt;
    267              NumCharsPrompt = _GetNumCharsInPrompt(pObj, pText);
   \   00000028   0070A0E3           MOV      R7,#+0
   \   0000002C   440095E5           LDR      R0,[R5, #+68]
   \   00000030   ........           BL       GUI_ALLOC_LockH
   \   00000034   0080A0E1           MOV      R8,R0
   \   00000038   BC14D5E1           LDRH     R1,[R5, #+76]
   \   0000003C   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000040   080080E0           ADD      R0,R0,R8
   \   00000044   000054E1           CMP      R4,R0
   \   00000048   0300002A           BCS      ??_WrapGetNumBytesToNextLine_1
   \   0000004C   041040E0           SUB      R1,R0,R4
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           BL       GUI_UC__NumBytes2NumChars
   \   00000058   0070A0E1           MOV      R7,R0
   \                     ??_WrapGetNumBytesToNextLine_1:
   \   0000005C   ........           BL       GUI_ALLOC_UnlockH
    268              NumChars = _WrapGetNumCharsDisp(hObj, pObj, pText);
   \   00000060   0420A0E1           MOV      R2,R4
   \   00000064   0510A0E1           MOV      R1,R5
   \   00000068   0600A0E1           MOV      R0,R6
   \   0000006C   ........           BL       _WrapGetNumCharsDisp
   \   00000070   0050A0E1           MOV      R5,R0
    269              r        = GUI_UC__NumChars2NumBytes(pText, NumChars);
   \   00000074   0510A0E1           MOV      R1,R5
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   ........           BL       GUI_UC__NumChars2NumBytes
    270              if (NumChars < NumCharsPrompt) {
   \   00000080   070055E1           CMP      R5,R7
   \   00000084   0D0000AA           BGE      ??_WrapGetNumBytesToNextLine_2
    271                if (*(pText + r) == '\n') {
   \   00000088   0410D0E7           LDRB     R1,[R0, +R4]
   \   0000008C   0A0051E3           CMP      R1,#+10
   \   00000090   0A00001A           BNE      ??_WrapGetNumBytesToNextLine_2
    272                  r++;
   \   00000094   010080E2           ADD      R0,R0,#+1
   \   00000098   080000EA           B        ??_WrapGetNumBytesToNextLine_2
    273                }
    274              }
    275            } else {
    276              r = GUI__WrapGetNumBytesToNextLine(pText, xSize, pObj->WrapMode);
   \                     ??_WrapGetNumBytesToNextLine_0:
   \   0000009C   F400DDE1           LDRSH    R0,[SP, #+4]
   \   000000A0   F010DDE1           LDRSH    R1,[SP, #+0]
   \   000000A4   8C20D5E5           LDRB     R2,[R5, #+140]
   \   000000A8   010040E0           SUB      R0,R0,R1
   \   000000AC   8710D5E5           LDRB     R1,[R5, #+135]
   \   000000B0   810040E0           SUB      R0,R0,R1, LSL #+1
   \   000000B4   011040E2           SUB      R1,R0,#+1
   \   000000B8   0400A0E1           MOV      R0,R4
   \   000000BC   ........           BL       GUI__WrapGetNumBytesToNextLine
    277            }
    278            return r;
   \                     ??_WrapGetNumBytesToNextLine_2:
   \   000000C0   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   000000C4   F081BDE8           POP      {R4-R8,PC}       ;; return
    279          }
    280          
    281          /*********************************************************************
    282          *
    283          *       _GetCharDistX
    284          */
    285          static int _GetCharDistX(const MULTIEDIT_OBJ * pObj, const char * pText) {
    286            int r;
    287            if ((pObj->Flags & MULTIEDIT_SF_PASSWORD) && (_GetNumCharsInPrompt(pObj, pText) == 0)) {
    288              r = GUI_GetCharDistX(MULTIEDIT_PASSWORD_CHAR);
    289            } else {
    290              U16 c;
    291              c = GUI_UC_GetCharCode(pText);
    292              r = GUI_GetCharDistX(c);
    293            }
    294            return r;
    295          }
    296          
    297          /*********************************************************************
    298          *
    299          *       _DispString
    300          */

   \                                 In section .text, align 4, keep-with-next
    301          static void _DispString(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ * pObj, const char * pText, GUI_RECT* pRect) {
   \                     _DispString:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0180A0E1           MOV      R8,R1
   \   00000008   0260A0E1           MOV      R6,R2
   \   0000000C   0340A0E1           MOV      R4,R3
    302            int NumCharsDisp;
    303            NumCharsDisp = _WrapGetNumCharsDisp(hObj, pObj, pText);
   \   00000010   ........           BL       _WrapGetNumCharsDisp
   \   00000014   0070A0E1           MOV      R7,R0
    304            if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
   \   00000018   8400D8E5           LDRB     R0,[R8, #+132]
   \   0000001C   200010E3           TST      R0,#0x20
   \   00000020   2600000A           BEQ      ??_DispString_0
    305              int x, NumCharsPrompt, NumCharsLeft = 0;
   \   00000024   0050A0E3           MOV      R5,#+0
    306              NumCharsPrompt = _GetNumCharsInPrompt(pObj, pText);
   \   00000028   0090A0E3           MOV      R9,#+0
   \   0000002C   440098E5           LDR      R0,[R8, #+68]
   \   00000030   ........           BL       GUI_ALLOC_LockH
   \   00000034   00A0A0E1           MOV      R10,R0
   \   00000038   BC14D8E1           LDRH     R1,[R8, #+76]
   \   0000003C   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000040   0A0080E0           ADD      R0,R0,R10
   \   00000044   000056E1           CMP      R6,R0
   \   00000048   0300002A           BCS      ??_DispString_1
   \   0000004C   061040E0           SUB      R1,R0,R6
   \   00000050   0600A0E1           MOV      R0,R6
   \   00000054   ........           BL       GUI_UC__NumBytes2NumChars
   \   00000058   0090A0E1           MOV      R9,R0
   \                     ??_DispString_1:
   \   0000005C   ........           BL       GUI_ALLOC_UnlockH
    307              if (NumCharsDisp < NumCharsPrompt) {
   \   00000060   090057E1           CMP      R7,R9
    308                NumCharsPrompt = NumCharsDisp;
   \   00000064   0790A0B1           MOVLT    R9,R7
    309              } else {
    310                NumCharsLeft = NumCharsDisp - NumCharsPrompt;
   \   00000068   095047A0           SUBGE    R5,R7,R9
    311              }
    312              GUI_DispStringInRectMax(pText, pRect, GUI_TA_LEFT, NumCharsPrompt);
   \   0000006C   0930A0E1           MOV      R3,R9
   \   00000070   0020A0E3           MOV      R2,#+0
   \   00000074   0410A0E1           MOV      R1,R4
   \   00000078   0600A0E1           MOV      R0,R6
   \   0000007C   ........           BL       GUI_DispStringInRectMax
    313              x = pRect->x0 + GUI__GetLineDistX(pText, NumCharsPrompt);
   \   00000080   0910A0E1           MOV      R1,R9
   \   00000084   0600A0E1           MOV      R0,R6
   \   00000088   ........           BL       GUI__GetLineDistX
    314              if (NumCharsLeft) {
   \   0000008C   000055E3           CMP      R5,#+0
   \   00000090   0F00000A           BEQ      ??_DispString_2
    315                GUI_DispCharAt(MULTIEDIT_PASSWORD_CHAR, x, pRect->y0);
   \   00000094   F010D4E1           LDRSH    R1,[R4, #+0]
   \   00000098   F220D4E1           LDRSH    R2,[R4, #+2]
   \   0000009C   011080E0           ADD      R1,R0,R1
   \   000000A0   0118A0E1           LSL      R1,R1,#+16
   \   000000A4   4118A0E1           ASR      R1,R1,#+16
   \   000000A8   2A00A0E3           MOV      R0,#+42
   \   000000AC   ........           BL       GUI_DispCharAt
    316                GUI_DispChars(MULTIEDIT_PASSWORD_CHAR, NumCharsLeft - 1);
   \   000000B0   011045E2           SUB      R1,R5,#+1
   \   000000B4   F047BDE8           POP      {R4-R10,LR}
   \   000000B8   2A00A0E3           MOV      R0,#+42
   \   000000BC   ........           B        GUI_DispChars    ;; tailcall
    317              }
    318            } else {
    319              GUI_DispStringInRectMax(pText, pRect, pObj->Align, NumCharsDisp);
   \                     ??_DispString_0:
   \   000000C0   0730A0E1           MOV      R3,R7
   \   000000C4   B626D8E1           LDRH     R2,[R8, #+102]
   \   000000C8   0410A0E1           MOV      R1,R4
   \   000000CC   0600A0E1           MOV      R0,R6
   \   000000D0   ........           BL       GUI_DispStringInRectMax
    320            }
    321          }
   \                     ??_DispString_2:
   \   000000D4   F087BDE8           POP      {R4-R10,PC}      ;; return
    322          
    323          /*********************************************************************
    324          *
    325          *       static code, cursor routines
    326          *
    327          **********************************************************************
    328          */
    329          /*********************************************************************
    330          *
    331          *       _GetpLineLocked
    332          *
    333          * Returns a pointer to the beginning of the line with the
    334          * given line number.
    335          */
    336          static char * _GetpLineLocked(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ * pObj, unsigned LineNumber) {
    337            char * pText, * pLine;
    338            pText = (char *)GUI_LOCK_H(pObj->hText);
    339            if ((unsigned)pObj->CacheLineNumber != LineNumber) {
    340              if (LineNumber > (unsigned)pObj->CacheLineNumber) {
    341                /* If new line number > cache we can start with old pointer */
    342                int OldNumber = pObj->CacheLineNumber;
    343                pLine = pText + pObj->CacheLinePosByte;
    344                pObj->CacheLineNumber  = LineNumber;
    345                LineNumber -= OldNumber;
    346              } else {
    347                /* If new line number < cache we need to start with first byte */
    348                pLine = pText;
    349                pObj->CacheLineNumber  = LineNumber;
    350              }
    351              while (LineNumber--) {
    352                pLine += _WrapGetNumBytesToNextLine(hObj, pObj, pLine);
    353              }
    354              pObj->CacheLinePosByte = pLine - pText;
    355            }
    356            return pText + pObj->CacheLinePosByte;
    357          }
    358          
    359          /*********************************************************************
    360          *
    361          *       _ClearCache
    362          *
    363          * Clears the cached position of the linenumber and the first byte
    364          * of the line which holds the cursor.
    365          */
    366          static void _ClearCache(MULTIEDIT_OBJ * pObj) {
    367            pObj->CacheLineNumber = 0;
    368            pObj->CacheLinePosByte = 0;
    369            pObj->CacheFirstVisibleByte = 0;
    370            pObj->CacheFirstVisibleLine = 0;
    371          }
    372          
    373          /*********************************************************************
    374          *
    375          *       _GetCursorLine
    376          *
    377          * Returns the line number of the cursor position.
    378          */
    379          static int _GetCursorLine(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ * pObj, const char * pText, int CursorPosChar) {
    380            const char *pCursor;
    381            const char *pEndLine;
    382            int NumChars, ByteOffsetNewCursor, LineNumber = 0;
    383            ByteOffsetNewCursor = GUI_UC__NumChars2NumBytes(pText, CursorPosChar);
    384            pCursor = pText + ByteOffsetNewCursor;
    385            if (pObj->CacheLinePosByte < ByteOffsetNewCursor) {
    386              /* If cache pos < new position we can use it as start position */
    387              pText      += pObj->CacheLinePosByte;
    388              LineNumber += pObj->CacheLineNumber;
    389            }
    390            while (*pText && (pCursor > pText)) {
    391              NumChars = _WrapGetNumCharsDisp(hObj, pObj, pText);
    392              pEndLine = pText + GUI_UC__NumChars2NumBytes(pText, NumChars);
    393              pText   += _WrapGetNumBytesToNextLine(hObj, pObj, pText);
    394              if (pCursor <= pEndLine) {
    395                if ((pCursor == pEndLine) && (pEndLine == pText) && *pText) {
    396                  LineNumber++;
    397                }
    398                break;
    399              }
    400              LineNumber++;
    401            }
    402            return LineNumber;
    403          }
    404          
    405          /*********************************************************************
    406          *
    407          *       _GetCursorXY
    408          */

   \                                 In section .text, align 4, keep-with-next
    409          static void _GetCursorXY(MULTIEDIT_HANDLE hObj, /*const*/ MULTIEDIT_OBJ * pObj, int* px, int* py) {
   \                     _GetCursorXY:
   \   00000000   FC4F2DE9           PUSH     {R2-R11,LR}
   \   00000004   0070A0E1           MOV      R7,R0
   \   00000008   0150A0E1           MOV      R5,R1
    410            if (pObj->InvalidFlags & INVALID_CURSORXY) {
   \   0000000C   8500D5E5           LDRB     R0,[R5, #+133]
   \   00000010   0CD04DE2           SUB      SP,SP,#+12
   \   00000014   080010E3           TST      R0,#0x8
   \   00000018   7600000A           BEQ      ??_GetCursorXY_0
    411              int CursorLine = 0, x = 0;
   \   0000001C   0080A0E3           MOV      R8,#+0
   \   00000020   0060A0E3           MOV      R6,#+0
    412              GUI_SetFont(pObj->pFont);
   \   00000024   800095E5           LDR      R0,[R5, #+128]
   \   00000028   ........           BL       GUI_SetFont
    413              if (pObj->hText) {
   \   0000002C   440095E5           LDR      R0,[R5, #+68]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   6800000A           BEQ      ??_GetCursorXY_1
    414                const char * pLine;
    415                const char * pCursor;
    416                pLine      = (const char *)GUI_LOCK_H(pObj->hText);
   \   00000038   ........           BL       GUI_ALLOC_LockH
    417                pCursor    = pLine + pObj->CursorPosByte;
   \   0000003C   B815D5E1           LDRH     R1,[R5, #+88]
    418                CursorLine = pObj->CursorLine;
   \   00000040   B485D5E1           LDRH     R8,[R5, #+84]
   \   00000044   004081E0           ADD      R4,R1,R0
    419                GUI_UNLOCK_H(pLine);
   \   00000048   ........           BL       GUI_ALLOC_UnlockH
    420                pLine      = _GetpLineLocked(hObj, pObj, CursorLine);
   \   0000004C   0890A0E1           MOV      R9,R8
   \   00000050   440095E5           LDR      R0,[R5, #+68]
   \   00000054   ........           BL       GUI_ALLOC_LockH
   \   00000058   00A0A0E1           MOV      R10,R0
   \   0000005C   B006D5E1           LDRH     R0,[R5, #+96]
   \   00000060   090050E1           CMP      R0,R9
   \   00000064   1200000A           BEQ      ??_GetCursorXY_2
   \   00000068   0AB0A021           MOVCS    R11,R10
   \   0000006C   B096C521           STRHCS   R9,[R5, #+96]
   \   00000070   0300002A           BCS      ??_GetCursorXY_3
   \   00000074   BE15D5E1           LDRH     R1,[R5, #+94]
   \   00000078   B096C5E1           STRH     R9,[R5, #+96]
   \   0000007C   009049E0           SUB      R9,R9,R0
   \   00000080   0AB081E0           ADD      R11,R1,R10
   \                     ??_GetCursorXY_3:
   \   00000084   000059E3           CMP      R9,#+0
   \   00000088   0700000A           BEQ      ??_GetCursorXY_4
   \                     ??_GetCursorXY_5:
   \   0000008C   019049E2           SUB      R9,R9,#+1
   \   00000090   0B20A0E1           MOV      R2,R11
   \   00000094   0510A0E1           MOV      R1,R5
   \   00000098   0700A0E1           MOV      R0,R7
   \   0000009C   ........           BL       _WrapGetNumBytesToNextLine
   \   000000A0   0BB080E0           ADD      R11,R0,R11
   \   000000A4   000059E3           CMP      R9,#+0
   \   000000A8   F7FFFF1A           BNE      ??_GetCursorXY_5
   \                     ??_GetCursorXY_4:
   \   000000AC   0A004BE0           SUB      R0,R11,R10
   \   000000B0   BE05C5E1           STRH     R0,[R5, #+94]
   \                     ??_GetCursorXY_2:
   \   000000B4   BE05D5E1           LDRH     R0,[R5, #+94]
   \   000000B8   0A9080E0           ADD      R9,R0,R10
    421                if ((pObj->Flags & MULTIEDIT_SF_PASSWORD)) {
   \   000000BC   8400D5E5           LDRB     R0,[R5, #+132]
   \   000000C0   200010E3           TST      R0,#0x20
   \   000000C4   1F00000A           BEQ      ??_GetCursorXY_6
    422                  while (pLine < pCursor) {
   \   000000C8   040059E1           CMP      R9,R4
   \   000000CC   4100002A           BCS      ??_GetCursorXY_7
    423                    x     += _GetCharDistX(pObj, pLine);
   \                     ??_GetCursorXY_8:
   \   000000D0   8400D5E5           LDRB     R0,[R5, #+132]
   \   000000D4   200010E3           TST      R0,#0x20
   \   000000D8   1000000A           BEQ      ??_GetCursorXY_9
   \   000000DC   0070A0E3           MOV      R7,#+0
   \   000000E0   440095E5           LDR      R0,[R5, #+68]
   \   000000E4   ........           BL       GUI_ALLOC_LockH
   \   000000E8   00A0A0E1           MOV      R10,R0
   \   000000EC   BC14D5E1           LDRH     R1,[R5, #+76]
   \   000000F0   ........           BL       GUI_UC__NumChars2NumBytes
   \   000000F4   0A0080E0           ADD      R0,R0,R10
   \   000000F8   000059E1           CMP      R9,R0
   \   000000FC   0300002A           BCS      ??_GetCursorXY_10
   \   00000100   091040E0           SUB      R1,R0,R9
   \   00000104   0900A0E1           MOV      R0,R9
   \   00000108   ........           BL       GUI_UC__NumBytes2NumChars
   \   0000010C   0070A0E1           MOV      R7,R0
   \                     ??_GetCursorXY_10:
   \   00000110   ........           BL       GUI_ALLOC_UnlockH
   \   00000114   000057E3           CMP      R7,#+0
   \   00000118   2A00A003           MOVEQ    R0,#+42
   \   0000011C   0100000A           BEQ      ??_GetCursorXY_11
   \                     ??_GetCursorXY_9:
   \   00000120   0900A0E1           MOV      R0,R9
   \   00000124   ........           BL       GUI_UC_GetCharCode
   \                     ??_GetCursorXY_11:
   \   00000128   ........           BL       GUI_GetCharDistX
   \   0000012C   066080E0           ADD      R6,R0,R6
    424                    pLine += GUI_UC_GetCharSize(pLine);
   \   00000130   0900A0E1           MOV      R0,R9
   \   00000134   ........           BL       GUI_UC_GetCharSize
   \   00000138   099080E0           ADD      R9,R0,R9
   \   0000013C   040059E1           CMP      R9,R4
   \   00000140   E2FFFF3A           BCC      ??_GetCursorXY_8
   \   00000144   230000EA           B        ??_GetCursorXY_7
    425                  }
    426                } else {
    427                  int xSize;
    428                  const char * p;
    429                  int NumChars = 0, NumCharsToNextLine;
    430                  xSize = _GetXSize(hObj, pObj);
   \                     ??_GetCursorXY_6:
   \   00000148   0D10A0E1           MOV      R1,SP
   \   0000014C   0700A0E1           MOV      R0,R7
   \   00000150   ........           BL       WM_GetInsideRectExScrollbar
   \   00000154   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000158   F010DDE1           LDRSH    R1,[SP, #+0]
    431                  p = pLine;
   \   0000015C   09B0A0E1           MOV      R11,R9
    432                  while (pLine < pCursor) {
   \   00000160   040059E1           CMP      R9,R4
   \   00000164   010040E0           SUB      R0,R0,R1
   \   00000168   8710D5E5           LDRB     R1,[R5, #+135]
   \   0000016C   810040E0           SUB      R0,R0,R1, LSL #+1
   \   00000170   01A040E2           SUB      R10,R0,#+1
   \   00000174   0500002A           BCS      ??_GetCursorXY_12
    433                    NumChars++;
   \                     ??_GetCursorXY_13:
   \   00000178   016086E2           ADD      R6,R6,#+1
    434                    pLine += GUI_UC_GetCharSize(pLine);
   \   0000017C   0900A0E1           MOV      R0,R9
   \   00000180   ........           BL       GUI_UC_GetCharSize
   \   00000184   099080E0           ADD      R9,R0,R9
   \   00000188   040059E1           CMP      R9,R4
   \   0000018C   F9FFFF3A           BCC      ??_GetCursorXY_13
    435                  }
    436                  NumCharsToNextLine = _WrapGetNumCharsDisp(hObj, pObj, p);
   \                     ??_GetCursorXY_12:
   \   00000190   0B20A0E1           MOV      R2,R11
   \   00000194   0510A0E1           MOV      R1,R5
   \   00000198   0700A0E1           MOV      R0,R7
   \   0000019C   ........           BL       _WrapGetNumCharsDisp
   \   000001A0   0040A0E1           MOV      R4,R0
    437                  x = GUI__GetCursorPosX(p, NumChars, NumCharsToNextLine);
   \   000001A4   0420A0E1           MOV      R2,R4
   \   000001A8   0610A0E1           MOV      R1,R6
   \   000001AC   0B00A0E1           MOV      R0,R11
   \   000001B0   ........           BL       GUI__GetCursorPosX
   \   000001B4   0060A0E1           MOV      R6,R0
    438                  if (pObj->Align == GUI_TA_RIGHT) {
   \   000001B8   B606D5E1           LDRH     R0,[R5, #+102]
   \   000001BC   010050E3           CMP      R0,#+1
   \   000001C0   0400001A           BNE      ??_GetCursorXY_7
    439                    x += xSize - GUI__GetLineDistX(p, NumCharsToNextLine);
   \   000001C4   06608AE0           ADD      R6,R10,R6
   \   000001C8   0410A0E1           MOV      R1,R4
   \   000001CC   0B00A0E1           MOV      R0,R11
   \   000001D0   ........           BL       GUI__GetLineDistX
   \   000001D4   006046E0           SUB      R6,R6,R0
    440                  }
    441                }
    442                GUI_UNLOCK_H(pLine);
   \                     ??_GetCursorXY_7:
   \   000001D8   ........           BL       GUI_ALLOC_UnlockH
    443              }
    444              pObj->CursorPosX = x;
   \                     ??_GetCursorXY_1:
   \   000001DC   BA65C5E1           STRH     R6,[R5, #+90]
    445              pObj->CursorPosY = CursorLine * GUI_GetFontDistY();
   \   000001E0   ........           BL       GUI_GetFontDistY
   \   000001E4   880060E1           SMULBB   R0,R8,R0
   \   000001E8   BC05C5E1           STRH     R0,[R5, #+92]
    446              pObj->InvalidFlags &= ~INVALID_CURSORXY;
   \   000001EC   8500D5E5           LDRB     R0,[R5, #+133]
   \   000001F0   0800C0E3           BIC      R0,R0,#0x8
   \   000001F4   8500C5E5           STRB     R0,[R5, #+133]
    447            }
    448            *px = pObj->CursorPosX;
   \                     ??_GetCursorXY_0:
   \   000001F8   FA05D5E1           LDRSH    R0,[R5, #+90]
   \   000001FC   0C109DE5           LDR      R1,[SP, #+12]
   \   00000200   000081E5           STR      R0,[R1, #+0]
    449            *py = pObj->CursorPosY;
   \   00000204   BC05D5E1           LDRH     R0,[R5, #+92]
   \   00000208   10109DE5           LDR      R1,[SP, #+16]
    450          }
   \   0000020C   14D08DE2           ADD      SP,SP,#+20
   \   00000210   000081E5           STR      R0,[R1, #+0]
   \   00000214   F08FBDE8           POP      {R4-R11,PC}      ;; return
    451          
    452          /*********************************************************************
    453          *
    454          *       _InvalidateCursorXY
    455          */
    456          static void _InvalidateCursorXY(MULTIEDIT_OBJ * pObj) {
    457            pObj->InvalidFlags |= INVALID_CURSORXY;
    458          }
    459          
    460          /*********************************************************************
    461          *
    462          *       _SetScrollState
    463          */
    464          static void _SetScrollState(WM_HWIN hObj) {
    465            MULTIEDIT_OBJ * pObj;
    466            WM_SCROLL_STATE ScrollStateV, ScrollStateH;
    467            pObj = MULTIEDIT_LOCK_H(hObj);
    468            ScrollStateV = pObj->ScrollStateV;
    469            ScrollStateH = pObj->ScrollStateH;
    470            GUI_UNLOCK_H(pObj);
    471            WIDGET__SetScrollState(hObj, &ScrollStateV, &ScrollStateH);
    472          }
    473          
    474          /*********************************************************************
    475          *
    476          *       _CalcScrollPos
    477          *
    478          * Purpose:
    479          *   Find out if the current position of the cursor is still in the
    480          *   visible area. If it is not, the scroll position is updated.
    481          *   Needs to be called every time the cursor is move, wrap, font or
    482          *   window size are changed.
    483          */

   \                                 In section .text, align 4, keep-with-next
    484          static void _CalcScrollPos(MULTIEDIT_HANDLE hObj) {
   \                     _CalcScrollPos:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   2CD04DE2           SUB      SP,SP,#+44
   \   00000008   0040A0E1           MOV      R4,R0
    485            MULTIEDIT_OBJ * pObj;
    486            int xCursor, yCursor;
    487            pObj = MULTIEDIT_LOCK_H(hObj);
   \   0000000C   ........           BL       GUI_ALLOC_LockH
   \   00000010   0050A0E1           MOV      R5,R0
    488            _GetCursorXY(hObj, pObj, &xCursor, &yCursor);
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   04208DE2           ADD      R2,SP,#+4
   \   0000001C   0510A0E1           MOV      R1,R5
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       _GetCursorXY
    489            yCursor /= GUI_GetYDistOfFont(pObj->pFont);
   \   00000028   800095E5           LDR      R0,[R5, #+128]
   \   0000002C   ........           BL       GUI_GetYDistOfFont
   \   00000030   0010A0E1           MOV      R1,R0
   \   00000034   00009DE5           LDR      R0,[SP, #+0]
   \   00000038   ........           BL       __aeabi_idiv
   \   0000003C   00008DE5           STR      R0,[SP, #+0]
    490            WM_CheckScrollPos(&pObj->ScrollStateV, yCursor, 0, 0);       /* Vertical */
   \   00000040   0010A0E1           MOV      R1,R0
   \   00000044   0030A0E3           MOV      R3,#+0
   \   00000048   0020A0E3           MOV      R2,#+0
   \   0000004C   680085E2           ADD      R0,R5,#+104
   \   00000050   ........           BL       WM_CheckScrollPos
    491            if (pObj->Align == GUI_TA_RIGHT) {
   \   00000054   B606D5E1           LDRH     R0,[R5, #+102]
   \   00000058   010050E3           CMP      R0,#+1
   \   0000005C   0B00001A           BNE      ??_CalcScrollPos_0
    492              xCursor = _GetXSize(hObj, pObj) - xCursor;
   \   00000060   08108DE2           ADD      R1,SP,#+8
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           BL       WM_GetInsideRectExScrollbar
    493            }
   \   0000006C   FC00DDE1           LDRSH    R0,[SP, #+12]
   \   00000070   F810DDE1           LDRSH    R1,[SP, #+8]
   \   00000074   010040E0           SUB      R0,R0,R1
   \   00000078   8710D5E5           LDRB     R1,[R5, #+135]
   \   0000007C   810040E0           SUB      R0,R0,R1, LSL #+1
   \   00000080   04109DE5           LDR      R1,[SP, #+4]
   \   00000084   010040E2           SUB      R0,R0,#+1
   \   00000088   010040E0           SUB      R0,R0,R1
   \   0000008C   04008DE5           STR      R0,[SP, #+4]
    494            WM_CheckScrollPos(&pObj->ScrollStateH, xCursor, 30, 30);     /* Horizontal */
   \                     ??_CalcScrollPos_0:
   \   00000090   1E30A0E3           MOV      R3,#+30
   \   00000094   1E20A0E3           MOV      R2,#+30
   \   00000098   04109DE5           LDR      R1,[SP, #+4]
   \   0000009C   740085E2           ADD      R0,R5,#+116
   \   000000A0   ........           BL       WM_CheckScrollPos
    495            GUI_UNLOCK_H(pObj);
   \   000000A4   ........           BL       GUI_ALLOC_UnlockH
    496            _SetScrollState(hObj);
   \   000000A8   0400A0E1           MOV      R0,R4
   \   000000AC   ........           BL       GUI_ALLOC_LockH
   \   000000B0   682080E2           ADD      R2,R0,#+104
   \   000000B4   0850B2E8           LDM      R2!,{R3,R12,LR}
   \   000000B8   1C108DE2           ADD      R1,SP,#+28
   \   000000BC   0850A1E8           STM      R1!,{R3,R12,LR}
   \   000000C0   740080E2           ADD      R0,R0,#+116
   \   000000C4   0C10B0E8           LDM      R0!,{R2,R3,R12}
   \   000000C8   10108DE2           ADD      R1,SP,#+16
   \   000000CC   0C10A1E8           STM      R1!,{R2,R3,R12}
   \   000000D0   ........           BL       GUI_ALLOC_UnlockH
   \   000000D4   10208DE2           ADD      R2,SP,#+16
   \   000000D8   1C108DE2           ADD      R1,SP,#+28
   \   000000DC   0400A0E1           MOV      R0,R4
   \   000000E0   ........           BL       WIDGET__SetScrollState
    497          }
   \   000000E4   2CD08DE2           ADD      SP,SP,#+44       ;; stack cleaning
   \   000000E8   3080BDE8           POP      {R4,R5,PC}       ;; return
    498          
    499          /*********************************************************************
    500          *
    501          *       _GetTextSizeX
    502          *
    503          * Returns the width of the displayed text.
    504          */

   \                                 In section .text, align 4, keep-with-next
    505          static int _GetTextSizeX(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ * pObj) {
   \                     _GetTextSizeX:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    506            if (pObj->InvalidFlags & INVALID_TEXTSIZE) {
   \   0000000C   8500D5E5           LDRB     R0,[R5, #+133]
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   040010E3           TST      R0,#0x4
   \   00000018   4700000A           BEQ      ??_GetTextSizeX_0
    507              pObj->TextSizeX = 0;
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   B005C5E1           STRH     R0,[R5, #+80]
    508              if (pObj->hText) {
   \   00000024   440095E5           LDR      R0,[R5, #+68]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   3F00000A           BEQ      ??_GetTextSizeX_1
    509                int NumChars, xSizeLine;
    510                char * pText;
    511                char * pLine;
    512                GUI_SetFont(pObj->pFont);
   \   00000030   800095E5           LDR      R0,[R5, #+128]
   \   00000034   ........           BL       GUI_SetFont
    513                pText = (char *)GUI_LOCK_H(pObj->hText);
   \   00000038   440095E5           LDR      R0,[R5, #+68]
   \   0000003C   ........           BL       GUI_ALLOC_LockH
   \   00000040   0060A0E1           MOV      R6,R0
    514                do {
    515                  NumChars = _WrapGetNumCharsDisp(hObj, pObj, pText);
   \                     ??_GetTextSizeX_2:
   \   00000044   0620A0E1           MOV      R2,R6
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       _WrapGetNumCharsDisp
   \   00000054   0090A0E1           MOV      R9,R0
    516                  xSizeLine = 0;
    517                  pLine = pText;
    518                  if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
   \   00000058   8400D5E5           LDRB     R0,[R5, #+132]
   \   0000005C   0070A0E3           MOV      R7,#+0
   \   00000060   0680A0E1           MOV      R8,R6
   \   00000064   200010E3           TST      R0,#0x20
   \   00000068   2000000A           BEQ      ??_GetTextSizeX_3
   \   0000006C   000059E3           CMP      R9,#+0
   \   00000070   2200000A           BEQ      ??_GetTextSizeX_4
    519                    while (NumChars--) {
    520                      xSizeLine += _GetCharDistX(pObj, pLine);
   \                     ??_GetTextSizeX_5:
   \   00000074   8400D5E5           LDRB     R0,[R5, #+132]
   \   00000078   019049E2           SUB      R9,R9,#+1
   \   0000007C   200010E3           TST      R0,#0x20
   \   00000080   1000000A           BEQ      ??_GetTextSizeX_6
   \   00000084   00A0A0E3           MOV      R10,#+0
   \   00000088   440095E5           LDR      R0,[R5, #+68]
   \   0000008C   ........           BL       GUI_ALLOC_LockH
   \   00000090   00B0A0E1           MOV      R11,R0
   \   00000094   BC14D5E1           LDRH     R1,[R5, #+76]
   \   00000098   ........           BL       GUI_UC__NumChars2NumBytes
   \   0000009C   0B0080E0           ADD      R0,R0,R11
   \   000000A0   000058E1           CMP      R8,R0
   \   000000A4   0300002A           BCS      ??_GetTextSizeX_7
   \   000000A8   081040E0           SUB      R1,R0,R8
   \   000000AC   0800A0E1           MOV      R0,R8
   \   000000B0   ........           BL       GUI_UC__NumBytes2NumChars
   \   000000B4   00A0A0E1           MOV      R10,R0
   \                     ??_GetTextSizeX_7:
   \   000000B8   ........           BL       GUI_ALLOC_UnlockH
   \   000000BC   00005AE3           CMP      R10,#+0
   \   000000C0   2A00A003           MOVEQ    R0,#+42
   \   000000C4   0100000A           BEQ      ??_GetTextSizeX_8
   \                     ??_GetTextSizeX_6:
   \   000000C8   0800A0E1           MOV      R0,R8
   \   000000CC   ........           BL       GUI_UC_GetCharCode
   \                     ??_GetTextSizeX_8:
   \   000000D0   ........           BL       GUI_GetCharDistX
   \   000000D4   077080E0           ADD      R7,R0,R7
    521                      pLine     += GUI_UC_GetCharSize(pLine);
   \   000000D8   0800A0E1           MOV      R0,R8
   \   000000DC   ........           BL       GUI_UC_GetCharSize
   \   000000E0   088080E0           ADD      R8,R0,R8
   \   000000E4   000059E3           CMP      R9,#+0
   \   000000E8   E1FFFF1A           BNE      ??_GetTextSizeX_5
   \   000000EC   030000EA           B        ??_GetTextSizeX_4
    522                    }
    523                  } else {
    524                    xSizeLine += GUI__GetLineDistX(pLine, NumChars);
   \                     ??_GetTextSizeX_3:
   \   000000F0   0910A0E1           MOV      R1,R9
   \   000000F4   0800A0E1           MOV      R0,R8
   \   000000F8   ........           BL       GUI__GetLineDistX
   \   000000FC   0070A0E1           MOV      R7,R0
    525                  }
    526                  if (xSizeLine > pObj->TextSizeX) {
   \                     ??_GetTextSizeX_4:
   \   00000100   B005D5E1           LDRH     R0,[R5, #+80]
    527                    pObj->TextSizeX = xSizeLine;
    528                  }
    529                  pText += _WrapGetNumBytesToNextLine(hObj, pObj, pText);
   \   00000104   0620A0E1           MOV      R2,R6
   \   00000108   0510A0E1           MOV      R1,R5
   \   0000010C   070050E1           CMP      R0,R7
   \   00000110   B075C5B1           STRHLT   R7,[R5, #+80]
   \   00000114   0400A0E1           MOV      R0,R4
   \   00000118   ........           BL       _WrapGetNumBytesToNextLine
   \   0000011C   066080E0           ADD      R6,R0,R6
    530                } while (*pText);
   \   00000120   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000124   000050E3           CMP      R0,#+0
   \   00000128   C5FFFF1A           BNE      ??_GetTextSizeX_2
    531                GUI_UNLOCK_H(pText);
   \   0000012C   ........           BL       GUI_ALLOC_UnlockH
    532              }
    533              pObj->InvalidFlags &= ~INVALID_TEXTSIZE;
   \                     ??_GetTextSizeX_1:
   \   00000130   8500D5E5           LDRB     R0,[R5, #+133]
   \   00000134   0400C0E3           BIC      R0,R0,#0x4
   \   00000138   8500C5E5           STRB     R0,[R5, #+133]
    534            }
    535            return pObj->TextSizeX;
   \                     ??_GetTextSizeX_0:
   \   0000013C   B005D5E1           LDRH     R0,[R5, #+80]
   \   00000140   04D08DE2           ADD      SP,SP,#+4
   \   00000144   F08FBDE8           POP      {R4-R11,PC}      ;; return
    536          }
    537          
    538          /*********************************************************************
    539          *
    540          *       _GetNumVisLines
    541          */
    542          static int _GetNumVisLines(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ * pObj) {
    543            GUI_RECT Rect;
    544            WM_GetInsideRectExScrollbar(hObj, &Rect);
    545            return (Rect.y1 - Rect.y0 + 1) / GUI_GetYDistOfFont(pObj->pFont);
    546          }
    547          
    548          /*********************************************************************
    549          *
    550          *       _GetNumLines
    551          *
    552          * Calculates (if needed) and returns the number of lines
    553          */
    554          static int _GetNumLines(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ * pObj) {
    555            if (pObj->InvalidFlags & INVALID_NUMLINES) {
    556              int NumLines = 0;
    557              if (pObj->hText) {
    558                int NumChars, NumBytes;
    559                char * pText;
    560                U16 Char;
    561                pText = (char *)GUI_LOCK_H(pObj->hText);
    562                GUI_SetFont(pObj->pFont);
    563                do {
    564                  NumChars = _WrapGetNumCharsDisp(hObj, pObj, pText);
    565                  NumBytes = GUI_UC__NumChars2NumBytes(pText, NumChars);
    566                  Char     = GUI_UC_GetCharCode(pText + NumBytes);
    567                  if (Char) {
    568                    NumLines++;
    569                  }
    570                  pText += _WrapGetNumBytesToNextLine(hObj, pObj, pText);
    571                } while (Char);
    572                GUI_UNLOCK_H(pText);
    573              }
    574              pObj->NumLines = NumLines + 1;
    575              pObj->InvalidFlags &= ~INVALID_NUMLINES;
    576            }
    577            return pObj->NumLines;
    578          }
    579          
    580          /*********************************************************************
    581          *
    582          *       _InvalidateNumLines
    583          *
    584          * Invalidates the number of lines
    585          */
    586          static void _InvalidateNumLines(MULTIEDIT_OBJ * pObj) {
    587            pObj->InvalidFlags |= INVALID_NUMLINES;
    588          }
    589          
    590          /*********************************************************************
    591          *
    592          *       _InvalidateTextSizeX
    593          *
    594          * Invalidates the TextSizeX
    595          */
    596          static void _InvalidateTextSizeX(MULTIEDIT_OBJ * pObj) {
    597            pObj->InvalidFlags |= INVALID_TEXTSIZE;
    598          }
    599          
    600          /*********************************************************************
    601          *
    602          *       _CalcScrollParas
    603          *
    604          * Purpose:
    605          *   Calculate page size ,number of items & position
    606          */

   \                                 In section .text, align 4, keep-with-next
    607          static void _CalcScrollParas(MULTIEDIT_HANDLE hObj) {
   \                     _CalcScrollParas:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0040A0E1           MOV      R4,R0
    608            MULTIEDIT_OBJ * pObj;
    609            pObj = MULTIEDIT_LOCK_H(hObj);
   \   0000000C   ........           BL       GUI_ALLOC_LockH
   \   00000010   0050A0E1           MOV      R5,R0
    610            /* Calc vertical scroll parameters */
    611            pObj->ScrollStateV.NumItems = _GetNumLines(hObj, pObj);
   \   00000014   8500D5E5           LDRB     R0,[R5, #+133]
   \   00000018   020010E3           TST      R0,#0x2
   \   0000001C   1F00000A           BEQ      ??_CalcScrollParas_0
   \   00000020   440095E5           LDR      R0,[R5, #+68]
   \   00000024   0060A0E3           MOV      R6,#+0
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   1600000A           BEQ      ??_CalcScrollParas_1
   \   00000030   ........           BL       GUI_ALLOC_LockH
   \   00000034   0070A0E1           MOV      R7,R0
   \   00000038   800095E5           LDR      R0,[R5, #+128]
   \   0000003C   ........           BL       GUI_SetFont
   \                     ??_CalcScrollParas_2:
   \   00000040   0720A0E1           MOV      R2,R7
   \   00000044   0510A0E1           MOV      R1,R5
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   ........           BL       _WrapGetNumCharsDisp
   \   00000050   0010A0E1           MOV      R1,R0
   \   00000054   0700A0E1           MOV      R0,R7
   \   00000058   ........           BL       GUI_UC__NumChars2NumBytes
   \   0000005C   070080E0           ADD      R0,R0,R7
   \   00000060   ........           BL       GUI_UC_GetCharCode
   \   00000064   0080B0E1           MOVS     R8,R0
   \   00000068   01608612           ADDNE    R6,R6,#+1
   \   0000006C   0720A0E1           MOV      R2,R7
   \   00000070   0510A0E1           MOV      R1,R5
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   ........           BL       _WrapGetNumBytesToNextLine
   \   0000007C   077080E0           ADD      R7,R0,R7
   \   00000080   000058E3           CMP      R8,#+0
   \   00000084   EDFFFF1A           BNE      ??_CalcScrollParas_2
   \   00000088   ........           BL       GUI_ALLOC_UnlockH
   \                     ??_CalcScrollParas_1:
   \   0000008C   010086E2           ADD      R0,R6,#+1
   \   00000090   BE04C5E1           STRH     R0,[R5, #+78]
   \   00000094   8500D5E5           LDRB     R0,[R5, #+133]
   \   00000098   0200C0E3           BIC      R0,R0,#0x2
   \   0000009C   8500C5E5           STRB     R0,[R5, #+133]
   \                     ??_CalcScrollParas_0:
   \   000000A0   BE04D5E1           LDRH     R0,[R5, #+78]
    612            pObj->ScrollStateV.PageSize = _GetNumVisLines(hObj, pObj);
   \   000000A4   0D10A0E1           MOV      R1,SP
   \   000000A8   680085E5           STR      R0,[R5, #+104]
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   ........           BL       WM_GetInsideRectExScrollbar
   \   000000B4   800095E5           LDR      R0,[R5, #+128]
   \   000000B8   ........           BL       GUI_GetYDistOfFont
   \   000000BC   0010A0E1           MOV      R1,R0
   \   000000C0   F600DDE1           LDRSH    R0,[SP, #+6]
   \   000000C4   F220DDE1           LDRSH    R2,[SP, #+2]
   \   000000C8   020040E0           SUB      R0,R0,R2
   \   000000CC   010080E2           ADD      R0,R0,#+1
   \   000000D0   ........           BL       __aeabi_idiv
   \   000000D4   700085E5           STR      R0,[R5, #+112]
    613            /* Calc horizontal scroll parameters */
    614            pObj->ScrollStateH.NumItems = _GetTextSizeX(hObj, pObj);
   \   000000D8   0510A0E1           MOV      R1,R5
   \   000000DC   0400A0E1           MOV      R0,R4
   \   000000E0   ........           BL       _GetTextSizeX
   \   000000E4   740085E5           STR      R0,[R5, #+116]
    615            pObj->ScrollStateH.PageSize = _GetXSize(hObj, pObj);
   \   000000E8   0D10A0E1           MOV      R1,SP
   \   000000EC   0400A0E1           MOV      R0,R4
   \   000000F0   ........           BL       WM_GetInsideRectExScrollbar
   \   000000F4   F400DDE1           LDRSH    R0,[SP, #+4]
   \   000000F8   F010DDE1           LDRSH    R1,[SP, #+0]
   \   000000FC   010040E0           SUB      R0,R0,R1
   \   00000100   8710D5E5           LDRB     R1,[R5, #+135]
   \   00000104   810040E0           SUB      R0,R0,R1, LSL #+1
   \   00000108   010040E2           SUB      R0,R0,#+1
   \   0000010C   7C0085E5           STR      R0,[R5, #+124]
    616            GUI_UNLOCK_H(pObj);
   \   00000110   ........           BL       GUI_ALLOC_UnlockH
    617            _CalcScrollPos(hObj);
   \   00000114   0400A0E1           MOV      R0,R4
   \   00000118   ........           BL       _CalcScrollPos
    618          }
   \   0000011C   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000120   F081BDE8           POP      {R4-R8,PC}       ;; return
    619          
    620          /*********************************************************************
    621          *
    622          *       _ManageAutoScrollV
    623          */

   \                                 In section .text, align 4, keep-with-next
    624          static void _ManageAutoScrollV(MULTIEDIT_HANDLE hObj) {
   \                     _ManageAutoScrollV:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0040A0E1           MOV      R4,R0
    625            MULTIEDIT_OBJ * pObj;
    626            char IsRequired;
    627            int r;
    628            pObj = MULTIEDIT_LOCK_H(hObj);
   \   0000000C   ........           BL       GUI_ALLOC_LockH
   \   00000010   0050A0E1           MOV      R5,R0
    629            if (pObj->Flags & MULTIEDIT_SF_AUTOSCROLLBAR_V) {
   \   00000014   8400D5E5           LDRB     R0,[R5, #+132]
   \   00000018   080010E3           TST      R0,#0x8
   \   0000001C   4200000A           BEQ      ??_ManageAutoScrollV_0
    630              IsRequired = _GetNumVisLines(hObj, pObj) < _GetNumLines(hObj, pObj);
   \   00000020   0D10A0E1           MOV      R1,SP
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       WM_GetInsideRectExScrollbar
   \   0000002C   800095E5           LDR      R0,[R5, #+128]
   \   00000030   ........           BL       GUI_GetYDistOfFont
   \   00000034   0010A0E1           MOV      R1,R0
   \   00000038   F600DDE1           LDRSH    R0,[SP, #+6]
   \   0000003C   F220DDE1           LDRSH    R2,[SP, #+2]
   \   00000040   020040E0           SUB      R0,R0,R2
   \   00000044   010080E2           ADD      R0,R0,#+1
   \   00000048   ........           BL       __aeabi_idiv
   \   0000004C   0060A0E1           MOV      R6,R0
   \   00000050   8500D5E5           LDRB     R0,[R5, #+133]
   \   00000054   020010E3           TST      R0,#0x2
   \   00000058   1F00000A           BEQ      ??_ManageAutoScrollV_1
   \   0000005C   440095E5           LDR      R0,[R5, #+68]
   \   00000060   0070A0E3           MOV      R7,#+0
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   1600000A           BEQ      ??_ManageAutoScrollV_2
   \   0000006C   ........           BL       GUI_ALLOC_LockH
   \   00000070   0080A0E1           MOV      R8,R0
   \   00000074   800095E5           LDR      R0,[R5, #+128]
   \   00000078   ........           BL       GUI_SetFont
   \                     ??_ManageAutoScrollV_3:
   \   0000007C   0820A0E1           MOV      R2,R8
   \   00000080   0510A0E1           MOV      R1,R5
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   ........           BL       _WrapGetNumCharsDisp
   \   0000008C   0010A0E1           MOV      R1,R0
   \   00000090   0800A0E1           MOV      R0,R8
   \   00000094   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000098   080080E0           ADD      R0,R0,R8
   \   0000009C   ........           BL       GUI_UC_GetCharCode
   \   000000A0   0090B0E1           MOVS     R9,R0
   \   000000A4   01708712           ADDNE    R7,R7,#+1
   \   000000A8   0820A0E1           MOV      R2,R8
   \   000000AC   0510A0E1           MOV      R1,R5
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   ........           BL       _WrapGetNumBytesToNextLine
   \   000000B8   088080E0           ADD      R8,R0,R8
   \   000000BC   000059E3           CMP      R9,#+0
   \   000000C0   EDFFFF1A           BNE      ??_ManageAutoScrollV_3
   \   000000C4   ........           BL       GUI_ALLOC_UnlockH
   \                     ??_ManageAutoScrollV_2:
   \   000000C8   010087E2           ADD      R0,R7,#+1
   \   000000CC   BE04C5E1           STRH     R0,[R5, #+78]
   \   000000D0   8500D5E5           LDRB     R0,[R5, #+133]
   \   000000D4   0200C0E3           BIC      R0,R0,#0x2
   \   000000D8   8500C5E5           STRB     R0,[R5, #+133]
   \                     ??_ManageAutoScrollV_1:
   \   000000DC   BE04D5E1           LDRH     R0,[R5, #+78]
   \   000000E0   0070A0E3           MOV      R7,#+0
   \   000000E4   000056E1           CMP      R6,R0
   \   000000E8   0150A0B3           MOVLT    R5,#+1
   \   000000EC   0050A0A3           MOVGE    R5,#+0
    631              GUI_UNLOCK_H(pObj);
   \   000000F0   ........           BL       GUI_ALLOC_UnlockH
    632              r = WM_SetScrollbarV(hObj, IsRequired);
    633              if (r != IsRequired) {
   \   000000F4   0510A0E1           MOV      R1,R5
   \   000000F8   0400A0E1           MOV      R0,R4
   \   000000FC   ........           BL       WM_SetScrollbarV
   \   00000100   050050E1           CMP      R0,R5
   \   00000104   0900000A           BEQ      ??_ManageAutoScrollV_4
    634                pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000108   0400A0E1           MOV      R0,R4
   \   0000010C   ........           BL       GUI_ALLOC_LockH
    635                _InvalidateNumLines(pObj);
    636                _InvalidateTextSizeX(pObj);
    637                _InvalidateCursorXY(pObj);
   \   00000110   8510D0E5           LDRB     R1,[R0, #+133]
   \   00000114   0E1081E3           ORR      R1,R1,#0xE
   \   00000118   8510C0E5           STRB     R1,[R0, #+133]
    638                _ClearCache(pObj);
   \   0000011C   B076C0E1           STRH     R7,[R0, #+96]
   \   00000120   BE75C0E1           STRH     R7,[R0, #+94]
   \   00000124   B476C0E1           STRH     R7,[R0, #+100]
   \   00000128   B276C0E1           STRH     R7,[R0, #+98]
    639                GUI_UNLOCK_H(pObj);
    640              }
    641            } else {
    642              GUI_UNLOCK_H(pObj);
   \                     ??_ManageAutoScrollV_0:
   \   0000012C   ........           BL       GUI_ALLOC_UnlockH
    643            }
    644          }
   \                     ??_ManageAutoScrollV_4:
   \   00000130   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000134   F083BDE8           POP      {R4-R9,PC}       ;; return
    645          
    646          /*********************************************************************
    647          *
    648          *       _ManageScrollers
    649          *
    650          * Function:
    651          * If autoscroll mode is enabled, add or remove the horizonatal and
    652          * vertical scrollbars as required.
    653          * Caution: This routine should not be called as reaction to a message
    654          * From the child, as this could lead to a recursion problem
    655          */
    656          static void _ManageScrollers(MULTIEDIT_HANDLE hObj) {
    657            MULTIEDIT_OBJ * pObj;
    658            /* 1. Step: Check if vertical scrollbar is required */
    659            _ManageAutoScrollV(hObj);
    660            pObj = MULTIEDIT_LOCK_H(hObj);
    661            /* 2. Step: Check if horizontal scrollbar is required */
    662            if (pObj->Flags & MULTIEDIT_SF_AUTOSCROLLBAR_H) {
    663              char IsRequired;
    664              int r;
    665              IsRequired = (_GetXSize(hObj, pObj) < _GetTextSizeX(hObj, pObj));
    666              GUI_UNLOCK_H(pObj);
    667              r = WM_SetScrollbarH(hObj, IsRequired);
    668              if (r != IsRequired) {
    669                /* 3. Step: Check vertical scrollbar again if horizontal has changed */
    670                _ManageAutoScrollV(hObj);
    671              }
    672            } else {
    673              GUI_UNLOCK_H(pObj);
    674            }
    675            _CalcScrollParas(hObj);
    676          }
    677          
    678          /*********************************************************************
    679          *
    680          *       _Invalidate
    681          */
    682          static void _Invalidate(MULTIEDIT_HANDLE hObj) {
    683            _ManageScrollers(hObj);
    684            WM_Invalidate(hObj);
    685          }
    686          
    687          /*********************************************************************
    688          *
    689          *       _InvalidateTextArea
    690          *
    691          * Invalidates the text area only
    692          */
    693          static void _InvalidateTextArea(MULTIEDIT_HANDLE hObj) {
    694            GUI_RECT rInsideRect;
    695            _ManageScrollers(hObj);
    696            WM_GetInsideRectExScrollbar(hObj, &rInsideRect);
    697            WM_InvalidateRect(hObj, &rInsideRect);
    698          }
    699          
    700          /*********************************************************************
    701          *
    702          *       _InvalidateCursorPos
    703          *
    704          * Sets the position of the cursor to an invalid value
    705          */
    706          static int _InvalidateCursorPos(MULTIEDIT_OBJ * pObj) {
    707            int Value;
    708            Value = pObj->CursorPosChar;
    709            pObj->CursorPosChar = 0xffff;
    710            return Value;
    711          }
    712          
    713          /*********************************************************************
    714          *
    715          *       _SetFlag
    716          */

   \                                 In section .text, align 4, keep-with-next
    717          static void _SetFlag(MULTIEDIT_HANDLE hObj, int OnOff, U8 Flag) {
   \                     _SetFlag:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   14D04DE2           SUB      SP,SP,#+20
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
    718            if (hObj) {
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   3200000A           BEQ      ??_SetFlag_0
    719              MULTIEDIT_OBJ * pObj;
    720              WM_LOCK();
   \   0000001C   ........           BL       GUI_Lock
    721              pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       GUI_ALLOC_LockH
    722              if (OnOff) {
   \   00000028   8410D0E5           LDRB     R1,[R0, #+132]
   \   0000002C   000055E3           CMP      R5,#+0
    723                pObj->Flags |= Flag;
   \   00000030   01108611           ORRNE    R1,R6,R1
    724              } else {
    725                pObj->Flags &= ~(int)Flag;
   \   00000034   0610C101           BICEQ    R1,R1,R6
   \   00000038   8410C0E5           STRB     R1,[R0, #+132]
    726              }
    727              GUI_UNLOCK_H(pObj);
   \   0000003C   ........           BL       GUI_ALLOC_UnlockH
   \   00000040   0050A0E3           MOV      R5,#+0
    728              _InvalidateTextArea(hObj);
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       _ManageAutoScrollV
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       GUI_ALLOC_LockH
   \   00000054   0060A0E1           MOV      R6,R0
   \   00000058   8400D6E5           LDRB     R0,[R6, #+132]
   \   0000005C   100010E3           TST      R0,#0x10
   \   00000060   1600000A           BEQ      ??_SetFlag_1
   \   00000064   0D10A0E1           MOV      R1,SP
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   ........           BL       WM_GetInsideRectExScrollbar
   \   00000070   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000074   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000078   010040E0           SUB      R0,R0,R1
   \   0000007C   8710D6E5           LDRB     R1,[R6, #+135]
   \   00000080   810040E0           SUB      R0,R0,R1, LSL #+1
   \   00000084   017040E2           SUB      R7,R0,#+1
   \   00000088   0610A0E1           MOV      R1,R6
   \   0000008C   0400A0E1           MOV      R0,R4
   \   00000090   ........           BL       _GetTextSizeX
   \   00000094   000057E1           CMP      R7,R0
   \   00000098   0150A0B3           MOVLT    R5,#+1
   \   0000009C   ........           BL       GUI_ALLOC_UnlockH
   \   000000A0   0510A0E1           MOV      R1,R5
   \   000000A4   0400A0E1           MOV      R0,R4
   \   000000A8   ........           BL       WM_SetScrollbarH
   \   000000AC   050050E1           CMP      R0,R5
   \   000000B0   0300000A           BEQ      ??_SetFlag_2
   \   000000B4   0400A0E1           MOV      R0,R4
   \   000000B8   ........           BL       _ManageAutoScrollV
   \   000000BC   000000EA           B        ??_SetFlag_2
   \                     ??_SetFlag_1:
   \   000000C0   ........           BL       GUI_ALLOC_UnlockH
   \                     ??_SetFlag_2:
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   ........           BL       _CalcScrollParas
   \   000000CC   08108DE2           ADD      R1,SP,#+8
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   ........           BL       WM_GetInsideRectExScrollbar
   \   000000D8   08108DE2           ADD      R1,SP,#+8
   \   000000DC   0400A0E1           MOV      R0,R4
   \   000000E0   ........           BL       WM_InvalidateRect
    729              WM_UNLOCK();
   \   000000E4   ........           BL       GUI_Unlock
    730            }
    731          }
   \                     ??_SetFlag_0:
   \   000000E8   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000000EC   F080BDE8           POP      {R4-R7,PC}       ;; return
    732          
    733          /*********************************************************************
    734          *
    735          *       _CalcNextValidCursorPos
    736          *
    737          * Purpose:
    738          *   Calculates the next valid cursor position of the desired position.
    739          *
    740          * Parameters:
    741          *   hObj, pObj    : Obvious
    742          *   CursorPosChar : New character position of the cursor
    743          *   pCursorPosByte: Pointer to save the cursorposition in bytes. Used to abolish further calculations. Could be 0.
    744          *   pCursorLine   : Pointer to save the line number of the cursor. Used to abolish further calculations. Could be 0.
    745          */

   \                                 In section .text, align 4, keep-with-next
    746          static int _CalcNextValidCursorPos(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ * pObj, int CursorPosChar, int * pCursorPosByte, int * pCursorLine) {
   \                     _CalcNextValidCursorPos:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0160A0E1           MOV      R6,R1
    747            if (pObj->hText) {
   \   0000000C   440096E5           LDR      R0,[R6, #+68]
   \   00000010   08D04DE2           SUB      SP,SP,#+8
   \   00000014   0270A0E1           MOV      R7,R2
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   C400000A           BEQ      ??_CalcNextValidCursorPos_0
    748              char * pNextLine;
    749              char * pCursor;
    750              char * pText;
    751              int CursorLine, NumChars, CursorPosByte;
    752              pText    = (char *)GUI_LOCK_H(pObj->hText);
   \   00000020   ........           BL       GUI_ALLOC_LockH
   \   00000024   0040A0E1           MOV      R4,R0
    753              NumChars = _GetNumChars(pObj);
   \   00000028   8500D6E5           LDRB     R0,[R6, #+133]
   \   0000002C   010010E3           TST      R0,#0x1
   \   00000030   0700000A           BEQ      ??_CalcNextValidCursorPos_1
   \   00000034   440096E5           LDR      R0,[R6, #+68]
   \   00000038   ........           BL       GUI_ALLOC_LockH
   \   0000003C   ........           BL       GUI__GetNumChars
   \   00000040   BA04C6E1           STRH     R0,[R6, #+74]
   \   00000044   ........           BL       GUI_ALLOC_UnlockH
   \   00000048   8500D6E5           LDRB     R0,[R6, #+133]
   \   0000004C   FE0000E2           AND      R0,R0,#0xFE
   \   00000050   8500C6E5           STRB     R0,[R6, #+133]
   \                     ??_CalcNextValidCursorPos_1:
   \   00000054   BC14D6E1           LDRH     R1,[R6, #+76]
   \   00000058   BA04D6E1           LDRH     R0,[R6, #+74]
   \   0000005C   010057E1           CMP      R7,R1
    754              /* Set offset in valid range */
    755              if (CursorPosChar < pObj->NumCharsPrompt) {
    756                CursorPosChar = pObj->NumCharsPrompt;
   \   00000060   0170A0B1           MOVLT    R7,R1
    757              }
    758              if (CursorPosChar > NumChars) {
   \   00000064   070050E1           CMP      R0,R7
   \   00000068   0070A0D1           MOVLE    R7,R0
    759                CursorPosChar = NumChars;
    760              }
    761              CursorPosByte = GUI_UC__NumChars2NumBytes(pText, CursorPosChar);
   \   0000006C   0710A0E1           MOV      R1,R7
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000078   04008DE5           STR      R0,[SP, #+4]
    762              CursorLine    = _GetCursorLine(hObj, pObj, pText, CursorPosChar);
   \   0000007C   0480A0E1           MOV      R8,R4
   \   00000080   0090A0E3           MOV      R9,#+0
   \   00000084   0710A0E1           MOV      R1,R7
   \   00000088   0800A0E1           MOV      R0,R8
   \   0000008C   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000090   081080E0           ADD      R1,R0,R8
   \   00000094   00108DE5           STR      R1,[SP, #+0]
   \   00000098   BE15D6E1           LDRH     R1,[R6, #+94]
   \   0000009C   000051E1           CMP      R1,R0
   \   000000A0   030000AA           BGE      ??_CalcNextValidCursorPos_2
   \   000000A4   088081E0           ADD      R8,R1,R8
   \   000000A8   B096D6E1           LDRH     R9,[R6, #+96]
   \   000000AC   000000EA           B        ??_CalcNextValidCursorPos_2
   \                     ??_CalcNextValidCursorPos_3:
   \   000000B0   019089E2           ADD      R9,R9,#+1
   \                     ??_CalcNextValidCursorPos_2:
   \   000000B4   0000D8E5           LDRB     R0,[R8, #+0]
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   1800000A           BEQ      ??_CalcNextValidCursorPos_4
   \   000000C0   00B09DE5           LDR      R11,[SP, #+0]
   \   000000C4   0B0058E1           CMP      R8,R11
   \   000000C8   1500002A           BCS      ??_CalcNextValidCursorPos_4
   \   000000CC   0820A0E1           MOV      R2,R8
   \   000000D0   0610A0E1           MOV      R1,R6
   \   000000D4   0500A0E1           MOV      R0,R5
   \   000000D8   ........           BL       _WrapGetNumCharsDisp
   \   000000DC   0010A0E1           MOV      R1,R0
   \   000000E0   0800A0E1           MOV      R0,R8
   \   000000E4   ........           BL       GUI_UC__NumChars2NumBytes
   \   000000E8   08A080E0           ADD      R10,R0,R8
   \   000000EC   0820A0E1           MOV      R2,R8
   \   000000F0   0610A0E1           MOV      R1,R6
   \   000000F4   0500A0E1           MOV      R0,R5
   \   000000F8   ........           BL       _WrapGetNumBytesToNextLine
   \   000000FC   088080E0           ADD      R8,R0,R8
   \   00000100   0B005AE1           CMP      R10,R11
   \   00000104   E9FFFF3A           BCC      ??_CalcNextValidCursorPos_3
   \   00000108   00009DE5           LDR      R0,[SP, #+0]
   \   0000010C   0A0050E1           CMP      R0,R10
   \   00000110   08005A01           CMPEQ    R10,R8
   \   00000114   0200001A           BNE      ??_CalcNextValidCursorPos_4
   \   00000118   0000D8E5           LDRB     R0,[R8, #+0]
   \   0000011C   000050E3           CMP      R0,#+0
   \   00000120   01908912           ADDNE    R9,R9,#+1
    763              pCursor       = pText + CursorPosByte;
   \                     ??_CalcNextValidCursorPos_4:
   \   00000124   04009DE5           LDR      R0,[SP, #+4]
   \   00000128   00908DE5           STR      R9,[SP, #+0]
   \   0000012C   048080E0           ADD      R8,R0,R4
    764              pNextLine     = _GetpLineLocked(hObj, pObj, CursorLine);
   \   00000130   440096E5           LDR      R0,[R6, #+68]
   \   00000134   ........           BL       GUI_ALLOC_LockH
   \   00000138   00A0A0E1           MOV      R10,R0
   \   0000013C   B006D6E1           LDRH     R0,[R6, #+96]
   \   00000140   090050E1           CMP      R0,R9
   \   00000144   1200000A           BEQ      ??_CalcNextValidCursorPos_5
   \   00000148   0AB0A021           MOVCS    R11,R10
   \   0000014C   B096C621           STRHCS   R9,[R6, #+96]
   \   00000150   0300002A           BCS      ??_CalcNextValidCursorPos_6
   \   00000154   BE15D6E1           LDRH     R1,[R6, #+94]
   \   00000158   B096C6E1           STRH     R9,[R6, #+96]
   \   0000015C   009049E0           SUB      R9,R9,R0
   \   00000160   0AB081E0           ADD      R11,R1,R10
   \                     ??_CalcNextValidCursorPos_6:
   \   00000164   000059E3           CMP      R9,#+0
   \   00000168   0700000A           BEQ      ??_CalcNextValidCursorPos_7
   \                     ??_CalcNextValidCursorPos_8:
   \   0000016C   019049E2           SUB      R9,R9,#+1
   \   00000170   0B20A0E1           MOV      R2,R11
   \   00000174   0610A0E1           MOV      R1,R6
   \   00000178   0500A0E1           MOV      R0,R5
   \   0000017C   ........           BL       _WrapGetNumBytesToNextLine
   \   00000180   0BB080E0           ADD      R11,R0,R11
   \   00000184   000059E3           CMP      R9,#+0
   \   00000188   F7FFFF1A           BNE      ??_CalcNextValidCursorPos_8
   \                     ??_CalcNextValidCursorPos_7:
   \   0000018C   0A004BE0           SUB      R0,R11,R10
   \   00000190   BE05C6E1           STRH     R0,[R6, #+94]
   \                     ??_CalcNextValidCursorPos_5:
   \   00000194   BE05D6E1           LDRH     R0,[R6, #+94]
   \   00000198   0A0080E0           ADD      R0,R0,R10
    765              if (pNextLine > pCursor) {
   \   0000019C   000058E1           CMP      R8,R0
   \   000001A0   5800002A           BCS      ??_CalcNextValidCursorPos_9
    766                if (pObj->CursorPosChar < CursorPosChar) {
   \   000001A4   B615D6E1           LDRH     R1,[R6, #+86]
   \   000001A8   070051E1           CMP      R1,R7
    767                  pCursor = pNextLine;
   \   000001AC   0080A0B1           MOVLT    R8,R0
   \   000001B0   250000BA           BLT      ??_CalcNextValidCursorPos_10
    768                } else {
    769                  char * pPrevLine;
    770                  pPrevLine  = _GetpLineLocked(hObj, pObj, CursorLine - 1);
   \   000001B4   00009DE5           LDR      R0,[SP, #+0]
   \   000001B8   017040E2           SUB      R7,R0,#+1
   \   000001BC   440096E5           LDR      R0,[R6, #+68]
   \   000001C0   ........           BL       GUI_ALLOC_LockH
   \   000001C4   0080A0E1           MOV      R8,R0
   \   000001C8   B006D6E1           LDRH     R0,[R6, #+96]
   \   000001CC   070050E1           CMP      R0,R7
   \   000001D0   1200000A           BEQ      ??_CalcNextValidCursorPos_11
   \   000001D4   0890A021           MOVCS    R9,R8
   \   000001D8   B076C621           STRHCS   R7,[R6, #+96]
   \   000001DC   0300002A           BCS      ??_CalcNextValidCursorPos_12
   \   000001E0   BE15D6E1           LDRH     R1,[R6, #+94]
   \   000001E4   B076C6E1           STRH     R7,[R6, #+96]
   \   000001E8   007047E0           SUB      R7,R7,R0
   \   000001EC   089081E0           ADD      R9,R1,R8
   \                     ??_CalcNextValidCursorPos_12:
   \   000001F0   000057E3           CMP      R7,#+0
   \   000001F4   0700000A           BEQ      ??_CalcNextValidCursorPos_13
   \                     ??_CalcNextValidCursorPos_14:
   \   000001F8   017047E2           SUB      R7,R7,#+1
   \   000001FC   0920A0E1           MOV      R2,R9
   \   00000200   0610A0E1           MOV      R1,R6
   \   00000204   0500A0E1           MOV      R0,R5
   \   00000208   ........           BL       _WrapGetNumBytesToNextLine
   \   0000020C   099080E0           ADD      R9,R0,R9
   \   00000210   000057E3           CMP      R7,#+0
   \   00000214   F7FFFF1A           BNE      ??_CalcNextValidCursorPos_14
   \                     ??_CalcNextValidCursorPos_13:
   \   00000218   080049E0           SUB      R0,R9,R8
   \   0000021C   BE05C6E1           STRH     R0,[R6, #+94]
   \                     ??_CalcNextValidCursorPos_11:
   \   00000220   BE05D6E1           LDRH     R0,[R6, #+94]
    771                  NumChars   = _WrapGetNumCharsDisp(hObj, pObj, pPrevLine);
   \   00000224   0610A0E1           MOV      R1,R6
   \   00000228   087080E0           ADD      R7,R0,R8
   \   0000022C   0720A0E1           MOV      R2,R7
   \   00000230   0500A0E1           MOV      R0,R5
   \   00000234   ........           BL       _WrapGetNumCharsDisp
    772                  pPrevLine += GUI_UC__NumChars2NumBytes(pPrevLine, NumChars);
    773                  pCursor = pPrevLine;
   \   00000238   0010A0E1           MOV      R1,R0
   \   0000023C   0700A0E1           MOV      R0,R7
   \   00000240   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000244   078080E0           ADD      R8,R0,R7
    774                  GUI_UNLOCK_H(pPrevLine);
   \   00000248   ........           BL       GUI_ALLOC_UnlockH
    775                }
    776                CursorPosChar = GUI_UC__NumBytes2NumChars(pText, pCursor - pText);
   \                     ??_CalcNextValidCursorPos_10:
   \   0000024C   041048E0           SUB      R1,R8,R4
   \   00000250   0400A0E1           MOV      R0,R4
   \   00000254   ........           BL       GUI_UC__NumBytes2NumChars
   \   00000258   0070A0E1           MOV      R7,R0
    777                CursorPosByte = GUI_UC__NumChars2NumBytes(pText, CursorPosChar);
   \   0000025C   0710A0E1           MOV      R1,R7
   \   00000260   0400A0E1           MOV      R0,R4
   \   00000264   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000268   04008DE5           STR      R0,[SP, #+4]
    778                CursorLine    = _GetCursorLine(hObj, pObj, pText, CursorPosChar);
   \   0000026C   0080A0E3           MOV      R8,#+0
   \   00000270   0710A0E1           MOV      R1,R7
   \   00000274   0400A0E1           MOV      R0,R4
   \   00000278   ........           BL       GUI_UC__NumChars2NumBytes
   \   0000027C   BE15D6E1           LDRH     R1,[R6, #+94]
   \   00000280   049080E0           ADD      R9,R0,R4
   \   00000284   000051E1           CMP      R1,R0
   \   00000288   030000AA           BGE      ??_CalcNextValidCursorPos_15
   \   0000028C   044081E0           ADD      R4,R1,R4
   \   00000290   B086D6E1           LDRH     R8,[R6, #+96]
   \   00000294   000000EA           B        ??_CalcNextValidCursorPos_15
   \                     ??_CalcNextValidCursorPos_16:
   \   00000298   018088E2           ADD      R8,R8,#+1
   \                     ??_CalcNextValidCursorPos_15:
   \   0000029C   0000D4E5           LDRB     R0,[R4, #+0]
   \   000002A0   000050E3           CMP      R0,#+0
   \   000002A4   1600000A           BEQ      ??_CalcNextValidCursorPos_17
   \   000002A8   090054E1           CMP      R4,R9
   \   000002AC   1400002A           BCS      ??_CalcNextValidCursorPos_17
   \   000002B0   0420A0E1           MOV      R2,R4
   \   000002B4   0610A0E1           MOV      R1,R6
   \   000002B8   0500A0E1           MOV      R0,R5
   \   000002BC   ........           BL       _WrapGetNumCharsDisp
   \   000002C0   0010A0E1           MOV      R1,R0
   \   000002C4   0400A0E1           MOV      R0,R4
   \   000002C8   ........           BL       GUI_UC__NumChars2NumBytes
   \   000002CC   04B080E0           ADD      R11,R0,R4
   \   000002D0   0420A0E1           MOV      R2,R4
   \   000002D4   0610A0E1           MOV      R1,R6
   \   000002D8   0500A0E1           MOV      R0,R5
   \   000002DC   ........           BL       _WrapGetNumBytesToNextLine
   \   000002E0   044080E0           ADD      R4,R0,R4
   \   000002E4   09005BE1           CMP      R11,R9
   \   000002E8   EAFFFF3A           BCC      ??_CalcNextValidCursorPos_16
   \   000002EC   0B0059E1           CMP      R9,R11
   \   000002F0   04005B01           CMPEQ    R11,R4
   \   000002F4   0200001A           BNE      ??_CalcNextValidCursorPos_17
   \   000002F8   0000D4E5           LDRB     R0,[R4, #+0]
   \   000002FC   000050E3           CMP      R0,#+0
   \   00000300   01808812           ADDNE    R8,R8,#+1
    779              }
   \                     ??_CalcNextValidCursorPos_17:
   \   00000304   00808DE5           STR      R8,[SP, #+0]
    780              GUI_UNLOCK_H(pNextLine);
   \                     ??_CalcNextValidCursorPos_9:
   \   00000308   ........           BL       GUI_ALLOC_UnlockH
    781              GUI_UNLOCK_H(pText);
   \   0000030C   ........           BL       GUI_ALLOC_UnlockH
    782              if (pCursorPosByte) {
   \   00000310   08009DE5           LDR      R0,[SP, #+8]
   \   00000314   000050E3           CMP      R0,#+0
    783                *pCursorPosByte = CursorPosByte;
   \   00000318   04109D15           LDRNE    R1,[SP, #+4]
   \   0000031C   00108015           STRNE    R1,[R0, #+0]
    784              }
    785              if (pCursorLine) {
   \   00000320   30009DE5           LDR      R0,[SP, #+48]
   \   00000324   000050E3           CMP      R0,#+0
    786                *pCursorLine = CursorLine;
   \   00000328   00109D15           LDRNE    R1,[SP, #+0]
   \   0000032C   00108015           STRNE    R1,[R0, #+0]
    787              }
    788              return CursorPosChar;
   \   00000330   0700A0E1           MOV      R0,R7
    789            }
    790            return 0;
   \                     ??_CalcNextValidCursorPos_0:
   \   00000334   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000338   F08FBDE8           POP      {R4-R11,PC}      ;; return
    791          }
    792          
    793          /*********************************************************************
    794          *
    795          *       _SetCursorPos
    796          *
    797          * Sets a new cursor position.
    798          */
    799          static void _SetCursorPos(MULTIEDIT_HANDLE hObj, int CursorPosChar) {
    800            MULTIEDIT_OBJ * pObj;
    801            int CursorPosByte, CursorLine;
    802            pObj = MULTIEDIT_LOCK_H(hObj);
    803            CursorPosChar = _CalcNextValidCursorPos(hObj, pObj, CursorPosChar, &CursorPosByte, &CursorLine);
    804            /* Assign value and recalc whatever necessary */
    805            if (pObj->CursorPosChar != CursorPosChar) {
    806              /* Save values */
    807              pObj->CursorPosByte = CursorPosByte;
    808              pObj->CursorPosChar = CursorPosChar;
    809              pObj->CursorLine = CursorLine;
    810              _InvalidateCursorXY(pObj); /* Invalidate X/Y position */
    811              GUI_UNLOCK_H(pObj);
    812              _CalcScrollPos(hObj);
    813            } else {
    814              GUI_UNLOCK_H(pObj);
    815            }
    816          }
    817          
    818          /*********************************************************************
    819          *
    820          *       _SetWrapMode
    821          */

   \                                 In section .text, align 4, keep-with-next
    822          static int _SetWrapMode(MULTIEDIT_HANDLE hObj, GUI_WRAPMODE WrapMode) {
   \                     _SetWrapMode:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   18D04DE2           SUB      SP,SP,#+24
   \   0000000C   0180A0E1           MOV      R8,R1
    823            int r;
    824            r = 0;
   \   00000010   0050A0E3           MOV      R5,#+0
    825            if (hObj) {
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   5C00000A           BEQ      ??_SetWrapMode_0
    826              MULTIEDIT_OBJ * pObj;
    827              WM_LOCK();
   \   0000001C   ........           BL       GUI_Lock
    828              pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       GUI_ALLOC_LockH
   \   00000028   0070A0E1           MOV      R7,R0
    829              r = pObj->WrapMode;
   \   0000002C   8C00D7E5           LDRB     R0,[R7, #+140]
    830              if (pObj->WrapMode != WrapMode) {
   \   00000030   0060A0E3           MOV      R6,#+0
   \   00000034   0050A0E1           MOV      R5,R0
   \   00000038   080050E1           CMP      R0,R8
   \   0000003C   5100000A           BEQ      ??_SetWrapMode_1
    831                int Position;
    832                pObj->WrapMode = WrapMode;
   \   00000040   8C80C7E5           STRB     R8,[R7, #+140]
    833                _ClearCache(pObj);
   \   00000044   B066C7E1           STRH     R6,[R7, #+96]
   \   00000048   BE65C7E1           STRH     R6,[R7, #+94]
   \   0000004C   B466C7E1           STRH     R6,[R7, #+100]
   \   00000050   B266C7E1           STRH     R6,[R7, #+98]
    834                _InvalidateNumLines(pObj);
    835                _InvalidateTextSizeX(pObj);
   \   00000054   8500D7E5           LDRB     R0,[R7, #+133]
   \   00000058   060080E3           ORR      R0,R0,#0x6
   \   0000005C   8500C7E5           STRB     R0,[R7, #+133]
    836                GUI_UNLOCK_H(pObj);
   \   00000060   ........           BL       GUI_ALLOC_UnlockH
    837                _InvalidateTextArea(hObj);
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           BL       _ManageAutoScrollV
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   ........           BL       GUI_ALLOC_LockH
   \   00000074   0080A0E1           MOV      R8,R0
   \   00000078   8400D8E5           LDRB     R0,[R8, #+132]
   \   0000007C   100010E3           TST      R0,#0x10
   \   00000080   1700000A           BEQ      ??_SetWrapMode_2
   \   00000084   0D10A0E1           MOV      R1,SP
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   ........           BL       WM_GetInsideRectExScrollbar
   \   00000090   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000094   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000098   010040E0           SUB      R0,R0,R1
   \   0000009C   8710D8E5           LDRB     R1,[R8, #+135]
   \   000000A0   810040E0           SUB      R0,R0,R1, LSL #+1
   \   000000A4   017040E2           SUB      R7,R0,#+1
   \   000000A8   0810A0E1           MOV      R1,R8
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   ........           BL       _GetTextSizeX
   \   000000B4   000057E1           CMP      R7,R0
   \   000000B8   0070A0A3           MOVGE    R7,#+0
   \   000000BC   0170A0B3           MOVLT    R7,#+1
   \   000000C0   ........           BL       GUI_ALLOC_UnlockH
   \   000000C4   0710A0E1           MOV      R1,R7
   \   000000C8   0400A0E1           MOV      R0,R4
   \   000000CC   ........           BL       WM_SetScrollbarH
   \   000000D0   070050E1           CMP      R0,R7
   \   000000D4   0300000A           BEQ      ??_SetWrapMode_3
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   ........           BL       _ManageAutoScrollV
   \   000000E0   000000EA           B        ??_SetWrapMode_3
   \                     ??_SetWrapMode_2:
   \   000000E4   ........           BL       GUI_ALLOC_UnlockH
   \                     ??_SetWrapMode_3:
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       _CalcScrollParas
   \   000000F0   0C108DE2           ADD      R1,SP,#+12
   \   000000F4   0400A0E1           MOV      R0,R4
   \   000000F8   ........           BL       WM_GetInsideRectExScrollbar
   \   000000FC   0C108DE2           ADD      R1,SP,#+12
   \   00000100   0400A0E1           MOV      R0,R4
   \   00000104   ........           BL       WM_InvalidateRect
    838                pObj = MULTIEDIT_LOCK_H(hObj);
    839                Position = _InvalidateCursorPos(pObj);
   \   00000108   0400A0E1           MOV      R0,R4
   \   0000010C   ........           BL       GUI_ALLOC_LockH
   \   00000110   FF10A0E3           MOV      R1,#+255
   \   00000114   B685D0E1           LDRH     R8,[R0, #+86]
   \   00000118   FF1C81E3           ORR      R1,R1,#0xFF00
   \   0000011C   B615C0E1           STRH     R1,[R0, #+86]
    840                _SetCursorPos(hObj, Position);
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   ........           BL       GUI_ALLOC_LockH
   \   00000128   0070A0E1           MOV      R7,R0
   \   0000012C   04008DE2           ADD      R0,SP,#+4
   \   00000130   00008DE5           STR      R0,[SP, #+0]
   \   00000134   08308DE2           ADD      R3,SP,#+8
   \   00000138   0820A0E1           MOV      R2,R8
   \   0000013C   0710A0E1           MOV      R1,R7
   \   00000140   0400A0E1           MOV      R0,R4
   \   00000144   ........           BL       _CalcNextValidCursorPos
   \   00000148   B615D7E1           LDRH     R1,[R7, #+86]
   \   0000014C   000051E1           CMP      R1,R0
   \   00000150   0100001A           BNE      ??_SetWrapMode_4
   \   00000154   ........           BL       GUI_ALLOC_UnlockH
   \   00000158   0A0000EA           B        ??_SetWrapMode_1
   \                     ??_SetWrapMode_4:
   \   0000015C   08109DE5           LDR      R1,[SP, #+8]
   \   00000160   B815C7E1           STRH     R1,[R7, #+88]
   \   00000164   B605C7E1           STRH     R0,[R7, #+86]
   \   00000168   04009DE5           LDR      R0,[SP, #+4]
   \   0000016C   B405C7E1           STRH     R0,[R7, #+84]
   \   00000170   8500D7E5           LDRB     R0,[R7, #+133]
   \   00000174   080080E3           ORR      R0,R0,#0x8
   \   00000178   8500C7E5           STRB     R0,[R7, #+133]
   \   0000017C   ........           BL       GUI_ALLOC_UnlockH
   \   00000180   0400A0E1           MOV      R0,R4
   \   00000184   ........           BL       _CalcScrollPos
    841              }
    842              GUI_UNLOCK_H(pObj);
   \                     ??_SetWrapMode_1:
   \   00000188   ........           BL       GUI_ALLOC_UnlockH
    843              WM_UNLOCK();
   \   0000018C   ........           BL       GUI_Unlock
    844            }
    845            return r;
   \                     ??_SetWrapMode_0:
   \   00000190   0500A0E1           MOV      R0,R5
   \   00000194   18D08DE2           ADD      SP,SP,#+24
   \   00000198   F081BDE8           POP      {R4-R8,PC}       ;; return
    846          }
    847          
    848          /*********************************************************************
    849          *
    850          *       _SetCursorXY
    851          *
    852          * Sets the cursor position from window coordinates.
    853          */

   \                                 In section .text, align 4, keep-with-next
    854          static void _SetCursorXY(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ * pObj, int x, int y) {
   \                     _SetCursorXY:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0260A0E1           MOV      R6,R2
   \   00000008   0380A0E1           MOV      R8,R3
    855            int CursorPosChar = 0;
    856            if ((x < 0) || (y < 0)) {
   \   0000000C   000056E3           CMP      R6,#+0
   \   00000010   0CD04DE2           SUB      SP,SP,#+12
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   0150A0E1           MOV      R5,R1
   \   0000001C   0070A0E3           MOV      R7,#+0
   \   00000020   00005853           CMPPL    R8,#+0
   \   00000024   AF00004A           BMI      ??_SetCursorXY_0
    857              return;
    858            }
    859            if (pObj->hText) {
   \   00000028   440095E5           LDR      R0,[R5, #+68]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   9200000A           BEQ      ??_SetCursorXY_1
    860              char *pLine, *pText;
    861              int CursorLine, WrapChars;
    862              int SizeX = 0;
    863              U16 Char;
    864              GUI_SetFont(pObj->pFont);
   \   00000034   800095E5           LDR      R0,[R5, #+128]
   \   00000038   ........           BL       GUI_SetFont
    865              CursorLine = y / GUI_GetFontDistY();
    866              pLine      = _GetpLineLocked(hObj, pObj, CursorLine);
   \   0000003C   ........           BL       GUI_GetFontDistY
   \   00000040   0010A0E1           MOV      R1,R0
   \   00000044   0800A0E1           MOV      R0,R8
   \   00000048   ........           BL       __aeabi_idiv
   \   0000004C   0080A0E1           MOV      R8,R0
   \   00000050   440095E5           LDR      R0,[R5, #+68]
   \   00000054   ........           BL       GUI_ALLOC_LockH
   \   00000058   0090A0E1           MOV      R9,R0
   \   0000005C   B006D5E1           LDRH     R0,[R5, #+96]
   \   00000060   080050E1           CMP      R0,R8
   \   00000064   1200000A           BEQ      ??_SetCursorXY_2
   \   00000068   09A0A021           MOVCS    R10,R9
   \   0000006C   B086C521           STRHCS   R8,[R5, #+96]
   \   00000070   0300002A           BCS      ??_SetCursorXY_3
   \   00000074   BE15D5E1           LDRH     R1,[R5, #+94]
   \   00000078   B086C5E1           STRH     R8,[R5, #+96]
   \   0000007C   008048E0           SUB      R8,R8,R0
   \   00000080   09A081E0           ADD      R10,R1,R9
   \                     ??_SetCursorXY_3:
   \   00000084   000058E3           CMP      R8,#+0
   \   00000088   0700000A           BEQ      ??_SetCursorXY_4
   \                     ??_SetCursorXY_5:
   \   0000008C   018048E2           SUB      R8,R8,#+1
   \   00000090   0A20A0E1           MOV      R2,R10
   \   00000094   0510A0E1           MOV      R1,R5
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   ........           BL       _WrapGetNumBytesToNextLine
   \   000000A0   0AA080E0           ADD      R10,R0,R10
   \   000000A4   000058E3           CMP      R8,#+0
   \   000000A8   F7FFFF1A           BNE      ??_SetCursorXY_5
   \                     ??_SetCursorXY_4:
   \   000000AC   09004AE0           SUB      R0,R10,R9
   \   000000B0   BE05C5E1           STRH     R0,[R5, #+94]
   \                     ??_SetCursorXY_2:
   \   000000B4   BE05D5E1           LDRH     R0,[R5, #+94]
   \   000000B8   098080E0           ADD      R8,R0,R9
    867              pText      = (char *)GUI_LOCK_H(pObj->hText);
   \   000000BC   440095E5           LDR      R0,[R5, #+68]
   \   000000C0   ........           BL       GUI_ALLOC_LockH
   \   000000C4   00008DE5           STR      R0,[SP, #+0]
    868              WrapChars  = _WrapGetNumCharsDisp(hObj, pObj, pLine);
   \   000000C8   0820A0E1           MOV      R2,R8
   \   000000CC   0510A0E1           MOV      R1,R5
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   ........           BL       _WrapGetNumCharsDisp
   \   000000D8   0090A0E1           MOV      R9,R0
    869              Char       = GUI_UC__GetCharCode(pLine + GUI_UC__NumChars2NumBytes(pLine, WrapChars));
   \   000000DC   0910A0E1           MOV      R1,R9
   \   000000E0   0800A0E1           MOV      R0,R8
   \   000000E4   ........           BL       GUI_UC__NumChars2NumBytes
   \   000000E8   ........           LDR      R1,??DataTable1
   \   000000EC   080080E0           ADD      R0,R0,R8
   \   000000F0   001091E5           LDR      R1,[R1, #+0]
   \   000000F4   001091E5           LDR      R1,[R1, #+0]
   \   000000F8   31FF2FE1           BLX      R1
   \   000000FC   00A0A0E1           MOV      R10,R0
    870              if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
   \   00000100   8400D5E5           LDRB     R0,[R5, #+132]
   \   00000104   200010E3           TST      R0,#0x20
   \   00000108   0200000A           BEQ      ??_SetCursorXY_6
    871                if (!Char) {
   \   0000010C   00005AE3           CMP      R10,#+0
   \   00000110   0800001A           BNE      ??_SetCursorXY_7
    872                  WrapChars++;
   \   00000114   060000EA           B        ??_SetCursorXY_8
    873                }
    874              } else {
    875                if (!Char || (Char == '\n') || ((Char == ' ') && (pObj->WrapMode == GUI_WRAPMODE_WORD))) {
   \                     ??_SetCursorXY_6:
   \   00000118   00005AE3           CMP      R10,#+0
   \   0000011C   0A005A13           CMPNE    R10,#+10
   \   00000120   0300000A           BEQ      ??_SetCursorXY_8
   \   00000124   20005AE3           CMP      R10,#+32
   \   00000128   8C00D505           LDRBEQ   R0,[R5, #+140]
   \   0000012C   01005003           CMPEQ    R0,#+1
   \   00000130   0000001A           BNE      ??_SetCursorXY_7
    876                  WrapChars++;
   \                     ??_SetCursorXY_8:
   \   00000134   019089E2           ADD      R9,R9,#+1
    877                }
    878              }
    879              if (pObj->Align == GUI_TA_RIGHT) {
   \                     ??_SetCursorXY_7:
   \   00000138   B606D5E1           LDRH     R0,[R5, #+102]
   \   0000013C   010050E3           CMP      R0,#+1
   \   00000140   1000001A           BNE      ??_SetCursorXY_9
    880                x -= _GetXSize(hObj, pObj) - GUI__GetLineDistX(pLine, WrapChars);
   \   00000144   04108DE2           ADD      R1,SP,#+4
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   ........           BL       WM_GetInsideRectExScrollbar
   \   00000150   F800DDE1           LDRSH    R0,[SP, #+8]
   \   00000154   F410DDE1           LDRSH    R1,[SP, #+4]
   \   00000158   010040E0           SUB      R0,R0,R1
   \   0000015C   8710D5E5           LDRB     R1,[R5, #+135]
   \   00000160   810040E0           SUB      R0,R0,R1, LSL #+1
   \   00000164   01A040E2           SUB      R10,R0,#+1
   \   00000168   0910A0E1           MOV      R1,R9
   \   0000016C   0800A0E1           MOV      R0,R8
   \   00000170   ........           BL       GUI__GetLineDistX
    881                x -= pObj->ScrollStateH.v << 1;
   \   00000174   0A1046E0           SUB      R1,R6,R10
   \   00000178   010080E0           ADD      R0,R0,R1
   \   0000017C   781095E5           LDR      R1,[R5, #+120]
   \   00000180   816050E0           SUBS     R6,R0,R1, LSL #+1
    882                if (x < 0) {
    883                  x = 0;
   \   00000184   0060A043           MOVMI    R6,#+0
    884                }
    885              }
    886          
    887              if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
   \                     ??_SetCursorXY_9:
   \   00000188   8400D5E5           LDRB     R0,[R5, #+132]
   \   0000018C   200010E3           TST      R0,#0x20
   \   00000190   2F00000A           BEQ      ??_SetCursorXY_10
   \   00000194   019049E2           SUB      R9,R9,#+1
   \   00000198   010059E3           CMP      R9,#+1
   \   0000019C   270000BA           BLT      ??_SetCursorXY_11
   \   000001A0   04908DE5           STR      R9,[SP, #+4]
    888                while (--WrapChars > 0) {
    889                  Char   = GUI_UC_GetCharCode(pLine);
   \                     ??_SetCursorXY_12:
   \   000001A4   0800A0E1           MOV      R0,R8
   \   000001A8   ........           BL       GUI_UC_GetCharCode
   \   000001AC   00A0A0E1           MOV      R10,R0
    890                  SizeX += _GetCharDistX(pObj, pLine);
   \   000001B0   8400D5E5           LDRB     R0,[R5, #+132]
   \   000001B4   200010E3           TST      R0,#0x20
   \   000001B8   1000000A           BEQ      ??_SetCursorXY_13
   \   000001BC   0090A0E3           MOV      R9,#+0
   \   000001C0   440095E5           LDR      R0,[R5, #+68]
   \   000001C4   ........           BL       GUI_ALLOC_LockH
   \   000001C8   00B0A0E1           MOV      R11,R0
   \   000001CC   BC14D5E1           LDRH     R1,[R5, #+76]
   \   000001D0   ........           BL       GUI_UC__NumChars2NumBytes
   \   000001D4   0B0080E0           ADD      R0,R0,R11
   \   000001D8   000058E1           CMP      R8,R0
   \   000001DC   0300002A           BCS      ??_SetCursorXY_14
   \   000001E0   081040E0           SUB      R1,R0,R8
   \   000001E4   0800A0E1           MOV      R0,R8
   \   000001E8   ........           BL       GUI_UC__NumBytes2NumChars
   \   000001EC   0090A0E1           MOV      R9,R0
   \                     ??_SetCursorXY_14:
   \   000001F0   ........           BL       GUI_ALLOC_UnlockH
   \   000001F4   000059E3           CMP      R9,#+0
   \   000001F8   2A00A003           MOVEQ    R0,#+42
   \   000001FC   0100000A           BEQ      ??_SetCursorXY_15
   \                     ??_SetCursorXY_13:
   \   00000200   0800A0E1           MOV      R0,R8
   \   00000204   ........           BL       GUI_UC_GetCharCode
   \                     ??_SetCursorXY_15:
   \   00000208   ........           BL       GUI_GetCharDistX
   \   0000020C   077080E0           ADD      R7,R0,R7
    891                  if (!Char || (SizeX > x)) {
   \   00000210   00005AE3           CMP      R10,#+0
   \   00000214   0900000A           BEQ      ??_SetCursorXY_11
   \   00000218   070056E1           CMP      R6,R7
   \   0000021C   070000BA           BLT      ??_SetCursorXY_11
    892                    break;
    893                  }
    894                  pLine += GUI_UC_GetCharSize(pLine);
   \   00000220   0800A0E1           MOV      R0,R8
   \   00000224   ........           BL       GUI_UC_GetCharSize
   \   00000228   04109DE5           LDR      R1,[SP, #+4]
   \   0000022C   088080E0           ADD      R8,R0,R8
   \   00000230   011041E2           SUB      R1,R1,#+1
   \   00000234   04108DE5           STR      R1,[SP, #+4]
    895                }
   \   00000238   000051E3           CMP      R1,#+0
   \   0000023C   D8FFFF1A           BNE      ??_SetCursorXY_12
    896                CursorPosChar = GUI_UC__NumBytes2NumChars(pText, pLine - pText);
   \                     ??_SetCursorXY_11:
   \   00000240   00009DE5           LDR      R0,[SP, #+0]
   \   00000244   001048E0           SUB      R1,R8,R0
   \   00000248   ........           BL       GUI_UC__NumBytes2NumChars
   \   0000024C   0070A0E1           MOV      R7,R0
   \   00000250   080000EA           B        ??_SetCursorXY_16
    897              } else {
    898                CursorPosChar = GUI_UC__NumBytes2NumChars(pText, pLine - pText) + GUI__GetCursorPosChar(pLine, x, WrapChars);
   \                     ??_SetCursorXY_10:
   \   00000254   00009DE5           LDR      R0,[SP, #+0]
   \   00000258   001048E0           SUB      R1,R8,R0
   \   0000025C   ........           BL       GUI_UC__NumBytes2NumChars
   \   00000260   0050A0E1           MOV      R5,R0
   \   00000264   0920A0E1           MOV      R2,R9
   \   00000268   0610A0E1           MOV      R1,R6
   \   0000026C   0800A0E1           MOV      R0,R8
   \   00000270   ........           BL       GUI__GetCursorPosChar
   \   00000274   057080E0           ADD      R7,R0,R5
    899              }
    900              GUI_UNLOCK_H(pLine);
   \                     ??_SetCursorXY_16:
   \   00000278   ........           BL       GUI_ALLOC_UnlockH
    901              GUI_UNLOCK_H(pText);
   \   0000027C   ........           BL       GUI_ALLOC_UnlockH
    902            }
    903            _SetCursorPos(hObj, CursorPosChar);
   \                     ??_SetCursorXY_1:
   \   00000280   0400A0E1           MOV      R0,R4
   \   00000284   ........           BL       GUI_ALLOC_LockH
   \   00000288   0050A0E1           MOV      R5,R0
   \   0000028C   04008DE2           ADD      R0,SP,#+4
   \   00000290   00008DE5           STR      R0,[SP, #+0]
   \   00000294   08308DE2           ADD      R3,SP,#+8
   \   00000298   0720A0E1           MOV      R2,R7
   \   0000029C   0510A0E1           MOV      R1,R5
   \   000002A0   0400A0E1           MOV      R0,R4
   \   000002A4   ........           BL       _CalcNextValidCursorPos
   \   000002A8   B615D5E1           LDRH     R1,[R5, #+86]
   \   000002AC   000051E1           CMP      R1,R0
   \   000002B0   0100001A           BNE      ??_SetCursorXY_17
   \   000002B4   ........           BL       GUI_ALLOC_UnlockH
   \   000002B8   0A0000EA           B        ??_SetCursorXY_0
   \                     ??_SetCursorXY_17:
   \   000002BC   08109DE5           LDR      R1,[SP, #+8]
   \   000002C0   B815C5E1           STRH     R1,[R5, #+88]
   \   000002C4   B605C5E1           STRH     R0,[R5, #+86]
   \   000002C8   04009DE5           LDR      R0,[SP, #+4]
   \   000002CC   B405C5E1           STRH     R0,[R5, #+84]
   \   000002D0   8500D5E5           LDRB     R0,[R5, #+133]
   \   000002D4   080080E3           ORR      R0,R0,#0x8
   \   000002D8   8500C5E5           STRB     R0,[R5, #+133]
   \   000002DC   ........           BL       GUI_ALLOC_UnlockH
   \   000002E0   0400A0E1           MOV      R0,R4
   \   000002E4   ........           BL       _CalcScrollPos
   \                     ??_SetCursorXY_0:
   \   000002E8   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   000002EC   F08FBDE8           POP      {R4-R11,PC}      ;; return
    904          }
    905          
    906          /*********************************************************************
    907          *
    908          *       _MoveCursorUp
    909          */
    910          static void _MoveCursorUp(MULTIEDIT_HANDLE hObj) {
    911            MULTIEDIT_OBJ * pObj;
    912            int xPos, yPos;
    913            pObj = MULTIEDIT_LOCK_H(hObj);
    914            _GetCursorXY(hObj, pObj, &xPos, &yPos);
    915            yPos -= GUI_GetYDistOfFont(pObj->pFont);
    916            _SetCursorXY(hObj, pObj, xPos, yPos);
    917            GUI_UNLOCK_H(pObj);
    918          }
    919          
    920          /*********************************************************************
    921          *
    922          *       _MoveCursorDown
    923          */
    924          static void _MoveCursorDown(MULTIEDIT_HANDLE hObj) {
    925            MULTIEDIT_OBJ * pObj;
    926            int xPos, yPos;
    927            pObj = MULTIEDIT_LOCK_H(hObj);
    928            _GetCursorXY(hObj, pObj, &xPos, &yPos);
    929            yPos += GUI_GetYDistOfFont(pObj->pFont);
    930            _SetCursorXY(hObj, pObj, xPos, yPos);
    931            GUI_UNLOCK_H(pObj);
    932          }
    933          
    934          /*********************************************************************
    935          *
    936          *       _MoveCursor2NextLine
    937          */
    938          static void _MoveCursor2NextLine(MULTIEDIT_HANDLE hObj) {
    939            MULTIEDIT_OBJ * pObj;
    940            int xPos, yPos;
    941            pObj = MULTIEDIT_LOCK_H(hObj);
    942            _GetCursorXY(hObj, pObj, &xPos, &yPos);
    943            yPos += GUI_GetYDistOfFont(pObj->pFont);
    944            _SetCursorXY(hObj, pObj, 0, yPos);
    945            GUI_UNLOCK_H(pObj);
    946          }
    947          
    948          /*********************************************************************
    949          *
    950          *       _MoveCursor2LineEnd
    951          */
    952          static void _MoveCursor2LineEnd(MULTIEDIT_HANDLE hObj) {
    953            MULTIEDIT_OBJ * pObj;
    954            int xPos, yPos;
    955            pObj = MULTIEDIT_LOCK_H(hObj);
    956            _GetCursorXY(hObj, pObj, &xPos, &yPos);
    957            _SetCursorXY(hObj, pObj, 0x7FFF, yPos);
    958            GUI_UNLOCK_H(pObj);
    959          }
    960          
    961          /*********************************************************************
    962          *
    963          *       _MoveCursor2LinePos1
    964          */
    965          static void _MoveCursor2LinePos1(MULTIEDIT_HANDLE hObj) {
    966            MULTIEDIT_OBJ * pObj;
    967            int xPos, yPos;
    968            pObj = MULTIEDIT_LOCK_H(hObj);
    969            _GetCursorXY(hObj, pObj, &xPos, &yPos);
    970            _SetCursorXY(hObj, pObj, 0, yPos);
    971            GUI_UNLOCK_H(pObj);
    972          }
    973          
    974          /*********************************************************************
    975          *
    976          *       _IsOverwriteAtThisChar
    977          */

   \                                 In section .text, align 4, keep-with-next
    978          static int _IsOverwriteAtThisChar(MULTIEDIT_HANDLE hObj) {
   \                     _IsOverwriteAtThisChar:
   \   00000000   F04B2DE9           PUSH     {R4-R9,R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
    979            MULTIEDIT_OBJ * pObj;
    980            int r = 0;
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   04108DE5           STR      R1,[SP, #+4]
    981            pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000014   ........           BL       GUI_ALLOC_LockH
   \   00000018   0050A0E1           MOV      R5,R0
    982            if (pObj->hText && !(pObj->Flags & MULTIEDIT_CF_INSERT)) {
   \   0000001C   440095E5           LDR      R0,[R5, #+68]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   4C00000A           BEQ      ??_IsOverwriteAtThisChar_0
   \   00000028   8410D5E5           LDRB     R1,[R5, #+132]
   \   0000002C   040011E3           TST      R1,#0x4
   \   00000030   4900001A           BNE      ??_IsOverwriteAtThisChar_0
    983              const char *pText;
    984              int CurPos, Line1, Line2;
    985              U16 Char;
    986              pText  = (const char *)GUI_LOCK_H(pObj->hText);
   \   00000034   ........           BL       GUI_ALLOC_LockH
    987              Line1  = pObj->CursorLine;
   \   00000038   B415D5E1           LDRH     R1,[R5, #+84]
   \   0000003C   0060A0E1           MOV      R6,R0
    988              CurPos = _CalcNextValidCursorPos(hObj, pObj, pObj->CursorPosChar + 1, 0, 0);
   \   00000040   0000A0E3           MOV      R0,#+0
   \   00000044   08108DE5           STR      R1,[SP, #+8]
   \   00000048   00008DE5           STR      R0,[SP, #+0]
   \   0000004C   B605D5E1           LDRH     R0,[R5, #+86]
   \   00000050   0030A0E3           MOV      R3,#+0
   \   00000054   0510A0E1           MOV      R1,R5
   \   00000058   012080E2           ADD      R2,R0,#+1
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           BL       _CalcNextValidCursorPos
   \   00000064   0010A0E1           MOV      R1,R0
    989              Line2  = _GetCursorLine(hObj, pObj, pText, CurPos);
   \   00000068   0670A0E1           MOV      R7,R6
   \   0000006C   0080A0E3           MOV      R8,#+0
   \   00000070   0700A0E1           MOV      R0,R7
   \   00000074   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000078   BE15D5E1           LDRH     R1,[R5, #+94]
   \   0000007C   079080E0           ADD      R9,R0,R7
   \   00000080   000051E1           CMP      R1,R0
   \   00000084   030000AA           BGE      ??_IsOverwriteAtThisChar_1
   \   00000088   077081E0           ADD      R7,R1,R7
   \   0000008C   B086D5E1           LDRH     R8,[R5, #+96]
   \   00000090   000000EA           B        ??_IsOverwriteAtThisChar_1
   \                     ??_IsOverwriteAtThisChar_2:
   \   00000094   018088E2           ADD      R8,R8,#+1
   \                     ??_IsOverwriteAtThisChar_1:
   \   00000098   0000D7E5           LDRB     R0,[R7, #+0]
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   1600000A           BEQ      ??_IsOverwriteAtThisChar_3
   \   000000A4   090057E1           CMP      R7,R9
   \   000000A8   1400002A           BCS      ??_IsOverwriteAtThisChar_3
   \   000000AC   0720A0E1           MOV      R2,R7
   \   000000B0   0510A0E1           MOV      R1,R5
   \   000000B4   0400A0E1           MOV      R0,R4
   \   000000B8   ........           BL       _WrapGetNumCharsDisp
   \   000000BC   0010A0E1           MOV      R1,R0
   \   000000C0   0700A0E1           MOV      R0,R7
   \   000000C4   ........           BL       GUI_UC__NumChars2NumBytes
   \   000000C8   07B080E0           ADD      R11,R0,R7
   \   000000CC   0720A0E1           MOV      R2,R7
   \   000000D0   0510A0E1           MOV      R1,R5
   \   000000D4   0400A0E1           MOV      R0,R4
   \   000000D8   ........           BL       _WrapGetNumBytesToNextLine
   \   000000DC   077080E0           ADD      R7,R0,R7
   \   000000E0   09005BE1           CMP      R11,R9
   \   000000E4   EAFFFF3A           BCC      ??_IsOverwriteAtThisChar_2
   \   000000E8   0B0059E1           CMP      R9,R11
   \   000000EC   07005B01           CMPEQ    R11,R7
   \   000000F0   0200001A           BNE      ??_IsOverwriteAtThisChar_3
   \   000000F4   0000D7E5           LDRB     R0,[R7, #+0]
   \   000000F8   000050E3           CMP      R0,#+0
   \   000000FC   01808812           ADDNE    R8,R8,#+1
    990              pText += pObj->CursorPosByte;
    991              Char   = GUI_UC_GetCharCode(pText);
   \                     ??_IsOverwriteAtThisChar_3:
   \   00000100   B805D5E1           LDRH     R0,[R5, #+88]
   \   00000104   060080E0           ADD      R0,R0,R6
   \   00000108   ........           BL       GUI_UC_GetCharCode
   \   0000010C   0040A0E1           MOV      R4,R0
    992              GUI_UNLOCK_H(pText);
   \   00000110   ........           BL       GUI_ALLOC_UnlockH
    993              if (Char) {
   \   00000114   000054E3           CMP      R4,#+0
   \   00000118   0F00000A           BEQ      ??_IsOverwriteAtThisChar_0
    994                if ((Line1 == Line2) || (pObj->Flags & MULTIEDIT_SF_PASSWORD)) {
   \   0000011C   08009DE5           LDR      R0,[SP, #+8]
   \   00000120   080050E1           CMP      R0,R8
   \   00000124   0200000A           BEQ      ??_IsOverwriteAtThisChar_4
   \   00000128   8400D5E5           LDRB     R0,[R5, #+132]
   \   0000012C   200010E3           TST      R0,#0x20
   \   00000130   0200000A           BEQ      ??_IsOverwriteAtThisChar_5
    995                  r = 1;
   \                     ??_IsOverwriteAtThisChar_4:
   \   00000134   0110A0E3           MOV      R1,#+1
   \   00000138   04108DE5           STR      R1,[SP, #+4]
   \   0000013C   060000EA           B        ??_IsOverwriteAtThisChar_0
    996                } else {
    997                  if (Char != '\n') {
   \                     ??_IsOverwriteAtThisChar_5:
   \   00000140   0A0054E3           CMP      R4,#+10
   \   00000144   0400000A           BEQ      ??_IsOverwriteAtThisChar_0
    998                    if ((Char != ' ') || (pObj->WrapMode == GUI_WRAPMODE_CHAR)) {
   \   00000148   200054E3           CMP      R4,#+32
   \   0000014C   F8FFFF1A           BNE      ??_IsOverwriteAtThisChar_4
   \   00000150   8C00D5E5           LDRB     R0,[R5, #+140]
   \   00000154   020050E3           CMP      R0,#+2
   \   00000158   F5FFFF0A           BEQ      ??_IsOverwriteAtThisChar_4
    999                      r = 1;
   1000                    }
   1001                  }
   1002                }
   1003              }
   1004            }
   1005            GUI_UNLOCK_H(pObj);
   \                     ??_IsOverwriteAtThisChar_0:
   \   0000015C   ........           BL       GUI_ALLOC_UnlockH
   1006            return r;
   \   00000160   04009DE5           LDR      R0,[SP, #+4]
   \   00000164   10D08DE2           ADD      SP,SP,#+16
   \   00000168   F08BBDE8           POP      {R4-R9,R11,PC}   ;; return
   1007          }
   1008          
   1009          /*********************************************************************
   1010          *
   1011          *       _GetCursorSizeX
   1012          *
   1013          * Returns the width of the cursor to be draw according to the
   1014          * insert mode flag and the cursor position.
   1015          */

   \                                 In section .text, align 4, keep-with-next
   1016          static int _GetCursorSizeX(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ * pObj, int * pIsRTL) {
   \                     _GetCursorSizeX:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
   1017            const char * pText;
   1018            U16 Char;
   1019            int r;
   1020          
   1021            if (_IsOverwriteAtThisChar(hObj)) {
   \   00000010   ........           BL       _IsOverwriteAtThisChar
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   5400000A           BEQ      ??_GetCursorSizeX_0
   1022              if (GUI__BIDI_Enabled == 1) {
   \   0000001C   ........           LDR      R1,??DataTable1_1
   \   00000020   440094E5           LDR      R0,[R4, #+68]
   \   00000024   001091E5           LDR      R1,[R1, #+0]
   \   00000028   010051E3           CMP      R1,#+1
   \   0000002C   3100001A           BNE      ??_GetCursorSizeX_1
   1023                if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
   \   00000030   8410D4E5           LDRB     R1,[R4, #+132]
   \   00000034   200011E3           TST      R1,#0x20
   \   00000038   1D00000A           BEQ      ??_GetCursorSizeX_2
   1024                  pText  = (const char *)GUI_LOCK_H(pObj->hText);
   \   0000003C   ........           BL       GUI_ALLOC_LockH
   1025                  pText += pObj->CursorPosByte;
   1026                  r = _GetCharDistX(pObj, pText);
   \   00000040   B815D4E1           LDRH     R1,[R4, #+88]
   \   00000044   005081E0           ADD      R5,R1,R0
   \   00000048   8400D4E5           LDRB     R0,[R4, #+132]
   \   0000004C   200010E3           TST      R0,#0x20
   \   00000050   1000000A           BEQ      ??_GetCursorSizeX_3
   \   00000054   0060A0E3           MOV      R6,#+0
   \   00000058   440094E5           LDR      R0,[R4, #+68]
   \   0000005C   ........           BL       GUI_ALLOC_LockH
   \   00000060   0070A0E1           MOV      R7,R0
   \   00000064   BC14D4E1           LDRH     R1,[R4, #+76]
   \   00000068   ........           BL       GUI_UC__NumChars2NumBytes
   \   0000006C   070080E0           ADD      R0,R0,R7
   \   00000070   000055E1           CMP      R5,R0
   \   00000074   0300002A           BCS      ??_GetCursorSizeX_4
   \   00000078   051040E0           SUB      R1,R0,R5
   \   0000007C   0500A0E1           MOV      R0,R5
   \   00000080   ........           BL       GUI_UC__NumBytes2NumChars
   \   00000084   0060A0E1           MOV      R6,R0
   \                     ??_GetCursorSizeX_4:
   \   00000088   ........           BL       GUI_ALLOC_UnlockH
   \   0000008C   000056E3           CMP      R6,#+0
   \   00000090   2A00A003           MOVEQ    R0,#+42
   \   00000094   0100000A           BEQ      ??_GetCursorSizeX_5
   \                     ??_GetCursorSizeX_3:
   \   00000098   0500A0E1           MOV      R0,R5
   \   0000009C   ........           BL       GUI_UC_GetCharCode
   \                     ??_GetCursorSizeX_5:
   \   000000A0   ........           BL       GUI_GetCharDistX
   \   000000A4   0040A0E1           MOV      R4,R0
   1027                  GUI_UNLOCK_H(pText);
   \                     ??_GetCursorSizeX_6:
   \   000000A8   ........           BL       GUI_ALLOC_UnlockH
   1028                  return r;
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   3C0000EA           B        ??_GetCursorSizeX_7
   1029                } else {
   1030                  pText  = (const char *)GUI_LOCK_H(pObj->hText);
   \                     ??_GetCursorSizeX_2:
   \   000000B4   ........           BL       GUI_ALLOC_LockH
   1031                  Char = _pfGUI__BIDI_GetLogChar(pText, pObj->NumChars, pObj->CursorPosChar);
   \   000000B8   ........           LDR      R3,??DataTable1_2
   \   000000BC   0060A0E1           MOV      R6,R0
   \   000000C0   B625D4E1           LDRH     R2,[R4, #+86]
   \   000000C4   BA14D4E1           LDRH     R1,[R4, #+74]
   \   000000C8   003093E5           LDR      R3,[R3, #+0]
   \   000000CC   33FF2FE1           BLX      R3
   1032                  *pIsRTL = _pfGUI__BIDI_GetCharDir(pText, pObj->NumChars, pObj->CursorPosChar);
   \   000000D0   ........           LDR      R3,??DataTable1_3
   \   000000D4   0070A0E1           MOV      R7,R0
   \   000000D8   B625D4E1           LDRH     R2,[R4, #+86]
   \   000000DC   BA14D4E1           LDRH     R1,[R4, #+74]
   \   000000E0   0600A0E1           MOV      R0,R6
   \   000000E4   003093E5           LDR      R3,[R3, #+0]
   \   000000E8   33FF2FE1           BLX      R3
   \   000000EC   000085E5           STR      R0,[R5, #+0]
   1033                  r = GUI_GetCharDistX(Char);
   \   000000F0   0700A0E1           MOV      R0,R7
   \   000000F4   E9FFFFEA           B        ??_GetCursorSizeX_5
   1034                  GUI_UNLOCK_H(pText);
   1035                  return r;
   1036                }
   1037              } else {
   1038                *pIsRTL = 0;
   \                     ??_GetCursorSizeX_1:
   \   000000F8   0010A0E3           MOV      R1,#+0
   \   000000FC   001085E5           STR      R1,[R5, #+0]
   1039                pText  = (const char *)GUI_LOCK_H(pObj->hText);
   \   00000100   ........           BL       GUI_ALLOC_LockH
   1040                pText += pObj->CursorPosByte;
   1041                r = _GetCharDistX(pObj, pText);
   \   00000104   B815D4E1           LDRH     R1,[R4, #+88]
   \   00000108   005081E0           ADD      R5,R1,R0
   \   0000010C   8400D4E5           LDRB     R0,[R4, #+132]
   \   00000110   200010E3           TST      R0,#0x20
   \   00000114   1000000A           BEQ      ??_GetCursorSizeX_8
   \   00000118   0060A0E3           MOV      R6,#+0
   \   0000011C   440094E5           LDR      R0,[R4, #+68]
   \   00000120   ........           BL       GUI_ALLOC_LockH
   \   00000124   0070A0E1           MOV      R7,R0
   \   00000128   BC14D4E1           LDRH     R1,[R4, #+76]
   \   0000012C   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000130   070080E0           ADD      R0,R0,R7
   \   00000134   000055E1           CMP      R5,R0
   \   00000138   0300002A           BCS      ??_GetCursorSizeX_9
   \   0000013C   051040E0           SUB      R1,R0,R5
   \   00000140   0500A0E1           MOV      R0,R5
   \   00000144   ........           BL       GUI_UC__NumBytes2NumChars
   \   00000148   0060A0E1           MOV      R6,R0
   \                     ??_GetCursorSizeX_9:
   \   0000014C   ........           BL       GUI_ALLOC_UnlockH
   \   00000150   000056E3           CMP      R6,#+0
   \   00000154   2A00A003           MOVEQ    R0,#+42
   \   00000158   0100000A           BEQ      ??_GetCursorSizeX_10
   \                     ??_GetCursorSizeX_8:
   \   0000015C   0500A0E1           MOV      R0,R5
   \   00000160   ........           BL       GUI_UC_GetCharCode
   \                     ??_GetCursorSizeX_10:
   \   00000164   ........           BL       GUI_GetCharDistX
   \   00000168   0040A0E1           MOV      R4,R0
   1042                GUI_UNLOCK_H(pText);
   \   0000016C   CDFFFFEA           B        ??_GetCursorSizeX_6
   1043                return r;
   1044              }
   1045            } else {
   1046              if (GUI__BIDI_Enabled == 1) {
   \                     ??_GetCursorSizeX_0:
   \   00000170   ........           LDR      R0,??DataTable1_1
   \   00000174   000090E5           LDR      R0,[R0, #+0]
   \   00000178   010050E3           CMP      R0,#+1
   \   0000017C   0800001A           BNE      ??_GetCursorSizeX_11
   1047                pText  = (const char *)GUI_LOCK_H(pObj->hText);
   \   00000180   440094E5           LDR      R0,[R4, #+68]
   \   00000184   ........           BL       GUI_ALLOC_LockH
   1048                *pIsRTL = _pfGUI__BIDI_GetCharDir(pText, pObj->NumChars, pObj->CursorPosChar);
   \   00000188   ........           LDR      R3,??DataTable1_3
   \   0000018C   B625D4E1           LDRH     R2,[R4, #+86]
   \   00000190   BA14D4E1           LDRH     R1,[R4, #+74]
   \   00000194   003093E5           LDR      R3,[R3, #+0]
   \   00000198   33FF2FE1           BLX      R3
   \   0000019C   000085E5           STR      R0,[R5, #+0]
   1049                GUI_UNLOCK_H(pText);
   \   000001A0   ........           BL       GUI_ALLOC_UnlockH
   1050              }
   1051              return 2;
   \                     ??_GetCursorSizeX_11:
   \   000001A4   0200A0E3           MOV      R0,#+2
   \                     ??_GetCursorSizeX_7:
   \   000001A8   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000001AC   F080BDE8           POP      {R4-R7,PC}       ;; return
   1052            }
   1053          }
   1054          
   1055          /*********************************************************************
   1056          *
   1057          *       static code, buffer management
   1058          *
   1059          **********************************************************************
   1060          */
   1061          /*********************************************************************
   1062          *
   1063          *       _IncrementBuffer
   1064          *
   1065          * Increments the buffer size by AddBytes.
   1066          */
   1067          
   1068          static int _IncrementBuffer(MULTIEDIT_HANDLE hObj, unsigned AddBytes) {
   1069            MULTIEDIT_OBJ * pObj;
   1070            WM_HMEM hNew;
   1071            WM_HMEM hText;
   1072            int NewSize;
   1073            pObj = MULTIEDIT_LOCK_H(hObj);
   1074            hText = pObj->hText;
   1075            NewSize = pObj->BufferSize + AddBytes;
   1076            GUI_UNLOCK_H(pObj);
   1077            hNew    = GUI_ALLOC_Realloc(hText, NewSize);
   1078            if (hNew) {
   1079              pObj = MULTIEDIT_LOCK_H(hObj);
   1080              if (!(pObj->hText)) {
   1081                char * pText;
   1082                pText  = (char *)GUI_LOCK_H(hNew);
   1083                *pText = 0;
   1084                GUI_UNLOCK_H(pText);
   1085              }
   1086              pObj->BufferSize = NewSize;
   1087              pObj->hText = hNew;
   1088              GUI_UNLOCK_H(pObj);
   1089              return 1;
   1090            }
   1091            return 0;
   1092          }
   1093          
   1094          /*********************************************************************
   1095          *
   1096          *       _IsSpaceInBuffer
   1097          *
   1098          * Checks the available space in the buffer. If there is not enough
   1099          * space left this function attempts to get more.
   1100          *
   1101          * Returns:
   1102          *  1 = requested space is available
   1103          *  0 = failed to get enough space
   1104          */

   \                                 In section .text, align 4, keep-with-next
   1105          static int _IsSpaceInBuffer(MULTIEDIT_HANDLE hObj, int BytesNeeded) {
   \                     _IsSpaceInBuffer:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   1106            MULTIEDIT_OBJ * pObj;
   1107            int NumBytes = 0;
   \   00000010   0060A0E3           MOV      R6,#+0
   1108            pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000014   ........           BL       GUI_ALLOC_LockH
   \   00000018   0070A0E1           MOV      R7,R0
   1109            if (pObj->hText) {
   \   0000001C   440097E5           LDR      R0,[R7, #+68]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0300000A           BEQ      ??_IsSpaceInBuffer_0
   1110              char * pText;
   1111              pText  = (char *)GUI_LOCK_H(pObj->hText);
   \   00000028   ........           BL       GUI_ALLOC_LockH
   1112              NumBytes = strlen(pText);
   \   0000002C   ........           BL       strlen
   \   00000030   0060A0E1           MOV      R6,R0
   1113              GUI_UNLOCK_H(pText);
   \   00000034   ........           BL       GUI_ALLOC_UnlockH
   1114            }
   1115            BytesNeeded = (BytesNeeded + NumBytes + 1) - pObj->BufferSize;
   \                     ??_IsSpaceInBuffer_0:
   \   00000038   B215D7E1           LDRH     R1,[R7, #+82]
   \   0000003C   050086E0           ADD      R0,R6,R5
   \   00000040   010080E2           ADD      R0,R0,#+1
   \   00000044   016040E0           SUB      R6,R0,R1
   1116            GUI_UNLOCK_H(pObj);
   \   00000048   ........           BL       GUI_ALLOC_UnlockH
   \   0000004C   0050A0E3           MOV      R5,#+0
   1117            if (BytesNeeded > 0) {
   \   00000050   010056E3           CMP      R6,#+1
   \   00000054   180000BA           BLT      ??_IsSpaceInBuffer_1
   1118              if (!_IncrementBuffer(hObj, BytesNeeded + MULTIEDIT_REALLOC_SIZE)) {
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           BL       GUI_ALLOC_LockH
   \   00000060   447090E5           LDR      R7,[R0, #+68]
   \   00000064   B205D0E1           LDRH     R0,[R0, #+82]
   \   00000068   000086E0           ADD      R0,R6,R0
   \   0000006C   106080E2           ADD      R6,R0,#+16
   \   00000070   ........           BL       GUI_ALLOC_UnlockH
   \   00000074   0610A0E1           MOV      R1,R6
   \   00000078   0700A0E1           MOV      R0,R7
   \   0000007C   ........           BL       GUI_ALLOC_Realloc
   \   00000080   0070B0E1           MOVS     R7,R0
   \   00000084   0F00000A           BEQ      ??_IsSpaceInBuffer_2
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   ........           BL       GUI_ALLOC_LockH
   \   00000090   0040A0E1           MOV      R4,R0
   \   00000094   440094E5           LDR      R0,[R4, #+68]
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   0300001A           BNE      ??_IsSpaceInBuffer_3
   \   000000A0   0700A0E1           MOV      R0,R7
   \   000000A4   ........           BL       GUI_ALLOC_LockH
   \   000000A8   0050C0E5           STRB     R5,[R0, #+0]
   \   000000AC   ........           BL       GUI_ALLOC_UnlockH
   \                     ??_IsSpaceInBuffer_3:
   \   000000B0   B265C4E1           STRH     R6,[R4, #+82]
   \   000000B4   447084E5           STR      R7,[R4, #+68]
   \   000000B8   ........           BL       GUI_ALLOC_UnlockH
   1119                return 0;
   1120              }
   1121            }
   1122            return 1;
   \                     ??_IsSpaceInBuffer_1:
   \   000000BC   0100A0E3           MOV      R0,#+1
   \                     ??_IsSpaceInBuffer_4:
   \   000000C0   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000C4   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??_IsSpaceInBuffer_2:
   \   000000C8   0000A0E3           MOV      R0,#+0
   \   000000CC   FBFFFFEA           B        ??_IsSpaceInBuffer_4
   1123          }
   1124          
   1125          /*********************************************************************
   1126          *
   1127          *       _IsCharsAvailable
   1128          *
   1129          * Checks weither the maximum number of characters is reached or not.
   1130          *
   1131          * Returns:
   1132          *  1 = requested number of chars is available
   1133          *  0 = maximum number of chars have reached
   1134          */
   1135          static int _IsCharsAvailable(MULTIEDIT_HANDLE hObj, int CharsNeeded) {
   1136            MULTIEDIT_OBJ * pObj;
   1137            int r = 1;
   1138            pObj = MULTIEDIT_LOCK_H(hObj);
   1139            if ((CharsNeeded > 0) && (pObj->MaxNumChars > 0)) {
   1140              int NumChars = 0;
   1141              if (pObj->hText) {
   1142                NumChars = _GetNumChars(pObj);
   1143              }
   1144              if ((CharsNeeded + NumChars) > pObj->MaxNumChars) {
   1145                r = 0;
   1146              }
   1147            }
   1148            GUI_UNLOCK_H(pObj);
   1149            return r;
   1150          }
   1151          
   1152          /*********************************************************************
   1153          *
   1154          *       static code, string manipulation routines
   1155          *
   1156          **********************************************************************
   1157          */
   1158          /*********************************************************************
   1159          *
   1160          *       _DeleteChar
   1161          *
   1162          * Deletes a character at the current cursor position and moves
   1163          * all bytes after the cursor position.
   1164          */

   \                                 In section .text, align 4, keep-with-next
   1165          static void _DeleteChar(MULTIEDIT_HANDLE hObj) {
   \                     _DeleteChar:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   1166            MULTIEDIT_OBJ * pObj;
   1167            pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000008   ........           BL       GUI_ALLOC_LockH
   \   0000000C   0060A0E1           MOV      R6,R0
   1168            if (pObj->hText) {
   \   00000010   440096E5           LDR      R0,[R6, #+68]
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   7600000A           BEQ      ??_DeleteChar_0
   1169              unsigned CursorOffset;
   1170              char * s;
   1171              s = (char *)GUI_LOCK_H(pObj->hText);
   \   0000001C   ........           BL       GUI_ALLOC_LockH
   \   00000020   0040A0E1           MOV      R4,R0
   1172              CursorOffset = pObj->CursorPosByte;
   \   00000024   B875D6E1           LDRH     R7,[R6, #+88]
   1173              if (CursorOffset < strlen(s)) {
   \   00000028   ........           BL       strlen
   \   0000002C   000057E1           CMP      R7,R0
   \   00000030   6F00002A           BCS      ??_DeleteChar_1
   1174                char *pCursor, *pLine, *pEndLine;
   1175                int CursorLine, NumChars, NumBytes;
   1176                pCursor    = s + CursorOffset;
   \   00000034   047087E0           ADD      R7,R7,R4
   1177                CursorLine = pObj->CursorLine;
   1178                pLine      = _GetpLineLocked(hObj, pObj, CursorLine);
   \   00000038   B485D6E1           LDRH     R8,[R6, #+84]
   \   0000003C   440096E5           LDR      R0,[R6, #+68]
   \   00000040   ........           BL       GUI_ALLOC_LockH
   \   00000044   0090A0E1           MOV      R9,R0
   \   00000048   B006D6E1           LDRH     R0,[R6, #+96]
   \   0000004C   080050E1           CMP      R0,R8
   \   00000050   1200000A           BEQ      ??_DeleteChar_2
   \   00000054   09A0A021           MOVCS    R10,R9
   \   00000058   B086C621           STRHCS   R8,[R6, #+96]
   \   0000005C   0300002A           BCS      ??_DeleteChar_3
   \   00000060   BE15D6E1           LDRH     R1,[R6, #+94]
   \   00000064   B086C6E1           STRH     R8,[R6, #+96]
   \   00000068   008048E0           SUB      R8,R8,R0
   \   0000006C   09A081E0           ADD      R10,R1,R9
   \                     ??_DeleteChar_3:
   \   00000070   000058E3           CMP      R8,#+0
   \   00000074   0700000A           BEQ      ??_DeleteChar_4
   \                     ??_DeleteChar_5:
   \   00000078   018048E2           SUB      R8,R8,#+1
   \   0000007C   0A20A0E1           MOV      R2,R10
   \   00000080   0610A0E1           MOV      R1,R6
   \   00000084   0500A0E1           MOV      R0,R5
   \   00000088   ........           BL       _WrapGetNumBytesToNextLine
   \   0000008C   0AA080E0           ADD      R10,R0,R10
   \   00000090   000058E3           CMP      R8,#+0
   \   00000094   F7FFFF1A           BNE      ??_DeleteChar_5
   \                     ??_DeleteChar_4:
   \   00000098   09004AE0           SUB      R0,R10,R9
   \   0000009C   BE05C6E1           STRH     R0,[R6, #+94]
   \                     ??_DeleteChar_2:
   \   000000A0   BE05D6E1           LDRH     R0,[R6, #+94]
   1179                NumChars   = _WrapGetNumCharsDisp(hObj, pObj, pLine);
   \   000000A4   0610A0E1           MOV      R1,R6
   \   000000A8   098080E0           ADD      R8,R0,R9
   \   000000AC   0820A0E1           MOV      R2,R8
   \   000000B0   0500A0E1           MOV      R0,R5
   \   000000B4   ........           BL       _WrapGetNumCharsDisp
   \   000000B8   0010A0E1           MOV      R1,R0
   1180                pEndLine   = pLine + GUI_UC__NumChars2NumBytes(pLine, NumChars);
   \   000000BC   0800A0E1           MOV      R0,R8
   \   000000C0   ........           BL       GUI_UC__NumChars2NumBytes
   \   000000C4   089080E0           ADD      R9,R0,R8
   1181                pLine      = pLine + _WrapGetNumBytesToNextLine(hObj, pObj, pLine);
   \   000000C8   0820A0E1           MOV      R2,R8
   \   000000CC   0610A0E1           MOV      R1,R6
   \   000000D0   0500A0E1           MOV      R0,R5
   \   000000D4   ........           BL       _WrapGetNumBytesToNextLine
   1182                if (pCursor == pEndLine) {
   \   000000D8   090057E1           CMP      R7,R9
   1183                  NumBytes = pLine - pEndLine;
   \   000000DC   08008000           ADDEQ    R0,R0,R8
   \   000000E0   09604000           SUBEQ    R6,R0,R9
   \   000000E4   0200000A           BEQ      ??_DeleteChar_6
   1184                } else {
   1185                  NumBytes = GUI_UC_GetCharSize(pCursor);
   \   000000E8   0700A0E1           MOV      R0,R7
   \   000000EC   ........           BL       GUI_UC_GetCharSize
   \   000000F0   0060A0E1           MOV      R6,R0
   1186                }
   1187                GUI_UNLOCK_H(pLine);
   \                     ??_DeleteChar_6:
   \   000000F4   ........           BL       GUI_ALLOC_UnlockH
   1188                NumChars = GUI_UC__NumBytes2NumChars(pCursor, NumBytes);
   \   000000F8   0610A0E1           MOV      R1,R6
   \   000000FC   0700A0E1           MOV      R0,R7
   \   00000100   ........           BL       GUI_UC__NumBytes2NumChars
   \   00000104   0080A0E1           MOV      R8,R0
   1189                strcpy(pCursor, pCursor + NumBytes);
   \   00000108   071086E0           ADD      R1,R6,R7
   \   0000010C   0700A0E1           MOV      R0,R7
   \   00000110   ........           BL       strcpy
   1190                GUI_UNLOCK_H(pObj);
   \   00000114   ........           BL       GUI_ALLOC_UnlockH
   1191                WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   00000118   0510A0E3           MOV      R1,#+5
   \   0000011C   0500A0E1           MOV      R0,R5
   \   00000120   ........           BL       WM_NotifyParent
   1192                pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000124   0500A0E1           MOV      R0,R5
   \   00000128   ........           BL       GUI_ALLOC_LockH
   \   0000012C   0060A0E1           MOV      R6,R0
   1193                pObj->NumChars -= NumChars;
   \   00000130   BA04D6E1           LDRH     R0,[R6, #+74]
   1194                _InvalidateNumLines(pObj);
   1195                _InvalidateTextSizeX(pObj);
   1196                _InvalidateCursorXY(pObj); /* Invalidate X/Y position */
   1197                _ClearCache(pObj);
   \   00000134   0070A0E3           MOV      R7,#+0
   \   00000138   080040E0           SUB      R0,R0,R8
   \   0000013C   BA04C6E1           STRH     R0,[R6, #+74]
   \   00000140   8500D6E5           LDRB     R0,[R6, #+133]
   \   00000144   0E0080E3           ORR      R0,R0,#0xE
   \   00000148   8500C6E5           STRB     R0,[R6, #+133]
   \   0000014C   B076C6E1           STRH     R7,[R6, #+96]
   \   00000150   BE75C6E1           STRH     R7,[R6, #+94]
   \   00000154   B476C6E1           STRH     R7,[R6, #+100]
   \   00000158   B276C6E1           STRH     R7,[R6, #+98]
   1198                pObj->CursorLine = _GetCursorLine(hObj, pObj, s, pObj->CursorPosChar);
   \   0000015C   B615D6E1           LDRH     R1,[R6, #+86]
   \   00000160   0400A0E1           MOV      R0,R4
   \   00000164   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000168   BE15D6E1           LDRH     R1,[R6, #+94]
   \   0000016C   048080E0           ADD      R8,R0,R4
   \   00000170   000051E1           CMP      R1,R0
   \   00000174   030000AA           BGE      ??_DeleteChar_7
   \   00000178   044081E0           ADD      R4,R1,R4
   \   0000017C   B076D6E1           LDRH     R7,[R6, #+96]
   \   00000180   000000EA           B        ??_DeleteChar_7
   \                     ??_DeleteChar_8:
   \   00000184   017087E2           ADD      R7,R7,#+1
   \                     ??_DeleteChar_7:
   \   00000188   0000D4E5           LDRB     R0,[R4, #+0]
   \   0000018C   000050E3           CMP      R0,#+0
   \   00000190   1600000A           BEQ      ??_DeleteChar_9
   \   00000194   080054E1           CMP      R4,R8
   \   00000198   1400002A           BCS      ??_DeleteChar_9
   \   0000019C   0420A0E1           MOV      R2,R4
   \   000001A0   0610A0E1           MOV      R1,R6
   \   000001A4   0500A0E1           MOV      R0,R5
   \   000001A8   ........           BL       _WrapGetNumCharsDisp
   \   000001AC   0010A0E1           MOV      R1,R0
   \   000001B0   0400A0E1           MOV      R0,R4
   \   000001B4   ........           BL       GUI_UC__NumChars2NumBytes
   \   000001B8   04A080E0           ADD      R10,R0,R4
   \   000001BC   0420A0E1           MOV      R2,R4
   \   000001C0   0610A0E1           MOV      R1,R6
   \   000001C4   0500A0E1           MOV      R0,R5
   \   000001C8   ........           BL       _WrapGetNumBytesToNextLine
   \   000001CC   044080E0           ADD      R4,R0,R4
   \   000001D0   08005AE1           CMP      R10,R8
   \   000001D4   EAFFFF3A           BCC      ??_DeleteChar_8
   \   000001D8   0A0058E1           CMP      R8,R10
   \   000001DC   04005A01           CMPEQ    R10,R4
   \   000001E0   0200001A           BNE      ??_DeleteChar_9
   \   000001E4   0000D4E5           LDRB     R0,[R4, #+0]
   \   000001E8   000050E3           CMP      R0,#+0
   \   000001EC   01708712           ADDNE    R7,R7,#+1
   1199              }
   \                     ??_DeleteChar_9:
   \   000001F0   B475C6E1           STRH     R7,[R6, #+84]
   1200              GUI_UNLOCK_H(s);
   \                     ??_DeleteChar_1:
   \   000001F4   ........           BL       GUI_ALLOC_UnlockH
   1201            }
   1202            GUI_UNLOCK_H(pObj);
   \                     ??_DeleteChar_0:
   \   000001F8   F047BDE8           POP      {R4-R10,LR}
   \   000001FC   ........           B        GUI_ALLOC_UnlockH  ;; tailcall
   1203          }
   1204          
   1205          /*********************************************************************
   1206          *
   1207          *       _InsertChar
   1208          *
   1209          * Create space at the current cursor position and inserts a character.
   1210          */

   \                                 In section .text, align 4, keep-with-next
   1211          static int _InsertChar(MULTIEDIT_HANDLE hObj, U16 Char) {
   \                     _InsertChar:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   1212            MULTIEDIT_OBJ * pObj;
   1213            if (_IsCharsAvailable(hObj, 1)) {
   \   00000010   0170A0E3           MOV      R7,#+1
   \   00000014   ........           BL       GUI_ALLOC_LockH
   \   00000018   0060A0E1           MOV      R6,R0
   \   0000001C   B804D6E1           LDRH     R0,[R6, #+72]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   1200000A           BEQ      ??_InsertChar_0
   \   00000028   440096E5           LDR      R0,[R6, #+68]
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0A00000A           BEQ      ??_InsertChar_1
   \   00000038   8510D6E5           LDRB     R1,[R6, #+133]
   \   0000003C   010011E3           TST      R1,#0x1
   \   00000040   0600000A           BEQ      ??_InsertChar_2
   \   00000044   ........           BL       GUI_ALLOC_LockH
   \   00000048   ........           BL       GUI__GetNumChars
   \   0000004C   BA04C6E1           STRH     R0,[R6, #+74]
   \   00000050   ........           BL       GUI_ALLOC_UnlockH
   \   00000054   8500D6E5           LDRB     R0,[R6, #+133]
   \   00000058   FE0000E2           AND      R0,R0,#0xFE
   \   0000005C   8500C6E5           STRB     R0,[R6, #+133]
   \                     ??_InsertChar_2:
   \   00000060   BA14D6E1           LDRH     R1,[R6, #+74]
   \                     ??_InsertChar_1:
   \   00000064   B804D6E1           LDRH     R0,[R6, #+72]
   \   00000068   011081E2           ADD      R1,R1,#+1
   \   0000006C   010050E1           CMP      R0,R1
   \   00000070   0070A0B3           MOVLT    R7,#+0
   \                     ??_InsertChar_0:
   \   00000074   ........           BL       GUI_ALLOC_UnlockH
   \   00000078   0060A0E3           MOV      R6,#+0
   \   0000007C   000057E3           CMP      R7,#+0
   \   00000080   2800000A           BEQ      ??_InsertChar_3
   1214              int BytesNeeded;
   1215              BytesNeeded = GUI_UC__CalcSizeOfChar(Char);
   \   00000084   0500A0E1           MOV      R0,R5
   \   00000088   ........           BL       GUI_UC__CalcSizeOfChar
   \   0000008C   0070A0E1           MOV      R7,R0
   1216              if (_IsSpaceInBuffer(hObj, BytesNeeded)) {
   \   00000090   0710A0E1           MOV      R1,R7
   \   00000094   0400A0E1           MOV      R0,R4
   \   00000098   ........           BL       _IsSpaceInBuffer
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   2100000A           BEQ      ??_InsertChar_4
   1217                int CursorOffset;
   1218                char * pText;
   1219                pObj = MULTIEDIT_LOCK_H(hObj);
   \   000000A4   0400A0E1           MOV      R0,R4
   \   000000A8   ........           BL       GUI_ALLOC_LockH
   \   000000AC   0080A0E1           MOV      R8,R0
   1220                pText = (char *)GUI_LOCK_H(pObj->hText);
   \   000000B0   440098E5           LDR      R0,[R8, #+68]
   \   000000B4   ........           BL       GUI_ALLOC_LockH
   1221                CursorOffset = pObj->CursorPosByte;
   1222                pText += CursorOffset;
   \   000000B8   B815D8E1           LDRH     R1,[R8, #+88]
   \   000000BC   009081E0           ADD      R9,R1,R0
   1223                memmove(pText + BytesNeeded, pText, strlen(pText) + 1);
   \   000000C0   0900A0E1           MOV      R0,R9
   \   000000C4   ........           BL       strlen
   \   000000C8   012080E2           ADD      R2,R0,#+1
   \   000000CC   0910A0E1           MOV      R1,R9
   \   000000D0   090087E0           ADD      R0,R7,R9
   \   000000D4   ........           BL       __aeabi_memmove
   1224                GUI_UC_Encode(pText, Char);
   \   000000D8   0510A0E1           MOV      R1,R5
   \   000000DC   0900A0E1           MOV      R0,R9
   \   000000E0   ........           BL       GUI_UC_Encode
   1225                GUI_UNLOCK_H(pText);
   \   000000E4   ........           BL       GUI_ALLOC_UnlockH
   1226                pObj->NumChars += 1;
   \   000000E8   BA04D8E1           LDRH     R0,[R8, #+74]
   \   000000EC   010080E2           ADD      R0,R0,#+1
   \   000000F0   BA04C8E1           STRH     R0,[R8, #+74]
   1227                _InvalidateNumLines(pObj);
   1228                _InvalidateTextSizeX(pObj);
   \   000000F4   8500D8E5           LDRB     R0,[R8, #+133]
   \   000000F8   060080E3           ORR      R0,R0,#0x6
   \   000000FC   8500C8E5           STRB     R0,[R8, #+133]
   1229                _ClearCache(pObj);
   \   00000100   B066C8E1           STRH     R6,[R8, #+96]
   \   00000104   BE65C8E1           STRH     R6,[R8, #+94]
   \   00000108   B466C8E1           STRH     R6,[R8, #+100]
   \   0000010C   B266C8E1           STRH     R6,[R8, #+98]
   1230                GUI_UNLOCK_H(pObj);
   \   00000110   ........           BL       GUI_ALLOC_UnlockH
   1231                WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   00000114   0510A0E3           MOV      R1,#+5
   \   00000118   0400A0E1           MOV      R0,R4
   \   0000011C   ........           BL       WM_NotifyParent
   1232                return 1;
   \   00000120   0100A0E3           MOV      R0,#+1
   \   00000124   000000EA           B        ??_InsertChar_4
   1233              }
   1234            }
   1235            return 0;
   \                     ??_InsertChar_3:
   \   00000128   0000A0E3           MOV      R0,#+0
   \                     ??_InsertChar_4:
   \   0000012C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000130   F083BDE8           POP      {R4-R9,PC}       ;; return
   1236          }
   1237          
   1238          /*********************************************************************
   1239          *
   1240          *       static code
   1241          *
   1242          **********************************************************************
   1243          */
   1244          /*********************************************************************
   1245          *
   1246          *       _InvertCursor
   1247          */

   \                                 In section .text, align 4, keep-with-next
   1248          static void _InvertCursor(MULTIEDIT_HANDLE hObj) {
   \                     _InvertCursor:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   1249            MULTIEDIT_OBJ * pObj;
   1250            int x, y,IsRTL, xOff, yOff, FontSizeY, CursorSize, ScrollPosX, ScrollPosY;
   1251            GUI_RECT r;
   1252            IsRTL      = 0;
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   0080A0E1           MOV      R8,R0
   \   00000010   00108DE5           STR      R1,[SP, #+0]
   1253            pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000014   ........           BL       GUI_ALLOC_LockH
   \   00000018   0040A0E1           MOV      R4,R0
   1254            FontSizeY  = GUI_GetYSizeOfFont(pObj->pFont);
   \   0000001C   800094E5           LDR      R0,[R4, #+128]
   \   00000020   ........           BL       GUI_GetYSizeOfFont
   \   00000024   0050A0E1           MOV      R5,R0
   1255            ScrollPosX = pObj->ScrollStateH.v;
   \   00000028   786094E5           LDR      R6,[R4, #+120]
   1256            ScrollPosY = pObj->ScrollStateV.v;
   \   0000002C   6C9094E5           LDR      R9,[R4, #+108]
   1257            if (WM_HasFocus(hObj)) {
   \   00000030   0800A0E1           MOV      R0,R8
   \   00000034   ........           BL       WM_HasFocus
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   2900000A           BEQ      ??_InvertCursor_0
   1258              xOff       = pObj->Widget.pEffect->EffectSize + pObj->HBorder - ScrollPosX;
   \   00000040   2C0094E5           LDR      R0,[R4, #+44]
   \   00000044   8720D4E5           LDRB     R2,[R4, #+135]
   \   00000048   001090E5           LDR      R1,[R0, #+0]
   1259              yOff       = pObj->Widget.pEffect->EffectSize - ScrollPosY * FontSizeY;
   \   0000004C   000090E5           LDR      R0,[R0, #+0]
   \   00000050   011082E0           ADD      R1,R2,R1
   \   00000054   067041E0           SUB      R7,R1,R6
   \   00000058   950901E0           MUL      R1,R5,R9
   1260              _GetCursorXY(hObj, pObj, &x, &y);
   \   0000005C   04308DE2           ADD      R3,SP,#+4
   \   00000060   019040E0           SUB      R9,R0,R1
   \   00000064   08208DE2           ADD      R2,SP,#+8
   \   00000068   0410A0E1           MOV      R1,R4
   \   0000006C   0800A0E1           MOV      R0,R8
   \   00000070   ........           BL       _GetCursorXY
   1261              CursorSize = _GetCursorSizeX(hObj, pObj, &IsRTL);
   \   00000074   0D20A0E1           MOV      R2,SP
   \   00000078   0410A0E1           MOV      R1,R4
   \   0000007C   0800A0E1           MOV      R0,R8
   \   00000080   ........           BL       _GetCursorSizeX
   \   00000084   0010A0E1           MOV      R1,R0
   1262              if (IsRTL) {
   \   00000088   08009DE5           LDR      R0,[SP, #+8]
   \   0000008C   00209DE5           LDR      R2,[SP, #+0]
   \   00000090   000087E0           ADD      R0,R7,R0
   \   00000094   000052E3           CMP      R2,#+0
   1263                r.x0 = x + xOff - CursorSize;
   \   00000098   01004010           SUBNE    R0,R0,R1
   1264                r.x1 = r.x0 + CursorSize - 1;
   1265              } else {
   1266                r.x0 = x + xOff;
   1267                r.x1 = r.x0 + CursorSize - 1;
   \   0000009C   001081E0           ADD      R1,R1,R0
   \   000000A0   012041E2           SUB      R2,R1,#+1
   1268              }
   1269              r.y0 = y + yOff;
   \   000000A4   04109DE5           LDR      R1,[SP, #+4]
   1270              r.y1 = r.y0 + FontSizeY - 1;
   1271              if (pObj->Align == GUI_TA_RIGHT) {
   \   000000A8   B6C6D4E1           LDRH     R12,[R4, #+102]
   \   000000AC   011089E0           ADD      R1,R9,R1
   \   000000B0   013085E0           ADD      R3,R5,R1
   \   000000B4   01005CE3           CMP      R12,#+1
   \   000000B8   013043E2           SUB      R3,R3,#+1
   1272                r.x0 += ScrollPosX << 1;
   \   000000BC   86008000           ADDEQ    R0,R0,R6, LSL #+1
   1273                r.x1 += ScrollPosX << 1;
   \   000000C0   86208200           ADDEQ    R2,R2,R6, LSL #+1
   1274              }
   1275              GUI_InvertRect(r.x0, r.y0, r.x1, r.y1);
   \   000000C4   0338A0E1           LSL      R3,R3,#+16
   \   000000C8   0228A0E1           LSL      R2,R2,#+16
   \   000000CC   0118A0E1           LSL      R1,R1,#+16
   \   000000D0   0008A0E1           LSL      R0,R0,#+16
   \   000000D4   4338A0E1           ASR      R3,R3,#+16
   \   000000D8   4228A0E1           ASR      R2,R2,#+16
   \   000000DC   4118A0E1           ASR      R1,R1,#+16
   \   000000E0   4008A0E1           ASR      R0,R0,#+16
   \   000000E4   ........           BL       GUI_InvertRect
   1276            }
   1277            GUI_UNLOCK_H(pObj);
   \                     ??_InvertCursor_0:
   \   000000E8   ........           BL       GUI_ALLOC_UnlockH
   1278          }
   \   000000EC   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   000000F0   F083BDE8           POP      {R4-R9,PC}       ;; return
   1279          
   1280          /*********************************************************************
   1281          *
   1282          *       _MULTIEDIT_Paint
   1283          */

   \                                 In section .text, align 4, keep-with-next
   1284          static void _MULTIEDIT_Paint(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ * pObj) {
   \                     _MULTIEDIT_Paint:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   34D04DE2           SUB      SP,SP,#+52
   1285            int ScrollPosX, ScrollPosY, EffectSize, HBorder;
   1286            int xOff, ColorIndex, FontSizeY;
   1287            GUI_RECT r, rClip;
   1288            const GUI_RECT * prOldClip;
   1289            /* Init some values */
   1290            GUI_SetFont(pObj->pFont);
   \   00000010   800095E5           LDR      R0,[R5, #+128]
   \   00000014   ........           BL       GUI_SetFont
   1291            FontSizeY  = GUI_GetFontDistY();
   \   00000018   ........           BL       GUI_GetFontDistY
   \   0000001C   30008DE5           STR      R0,[SP, #+48]
   1292            ScrollPosX = pObj->ScrollStateH.v;
   \   00000020   781095E5           LDR      R1,[R5, #+120]
   \   00000024   0C108DE5           STR      R1,[SP, #+12]
   1293            ScrollPosY = pObj->ScrollStateV.v;
   1294            EffectSize = pObj->Widget.pEffect->EffectSize;
   \   00000028   2C0095E5           LDR      R0,[R5, #+44]
   1295            HBorder    = pObj->HBorder;
   \   0000002C   8710D5E5           LDRB     R1,[R5, #+135]
   \   00000030   6C6095E5           LDR      R6,[R5, #+108]
   \   00000034   007090E5           LDR      R7,[R0, #+0]
   \   00000038   08108DE5           STR      R1,[SP, #+8]
   1296            xOff       = EffectSize + HBorder - ScrollPosX;
   1297            ColorIndex = ((pObj->Flags & MULTIEDIT_SF_READONLY) ? 1 : 0);
   \   0000003C   8400D5E5           LDRB     R0,[R5, #+132]
   \   00000040   010000E2           AND      R0,R0,#0x1
   1298            /* Set colors and draw the background */
   1299            LCD_SetBkColor(pObj->aBkColor[ColorIndex]);
   \   00000044   008185E0           ADD      R8,R5,R0, LSL #+2
   \   00000048   340098E5           LDR      R0,[R8, #+52]
   \   0000004C   ........           BL       LCD_SetBkColor
   1300            LCD_SetColor(pObj->aColor[ColorIndex]);
   \   00000050   3C0098E5           LDR      R0,[R8, #+60]
   \   00000054   ........           BL       LCD_SetColor
   1301            GUI_Clear();
   \   00000058   ........           BL       GUI_Clear
   1302            /* Draw the text if necessary */
   1303            rClip.x0 = EffectSize + HBorder;
   \   0000005C   08209DE5           LDR      R2,[SP, #+8]
   1304            rClip.y0 = EffectSize;
   \   00000060   B671CDE1           STRH     R7,[SP, #+22]
   \   00000064   071082E0           ADD      R1,R2,R7
   \   00000068   B011CDE1           STRH     R1,[SP, #+16]
   \   0000006C   F011DDE1           LDRSH    R1,[SP, #+16]
   1305            rClip.x1 = WM_GetWindowSizeX(hObj) - EffectSize - HBorder - 1;
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   B411CDE1           STRH     R1,[SP, #+20]
   \   00000078   ........           BL       WM_GetWindowSizeX
   \   0000007C   08109DE5           LDR      R1,[SP, #+8]
   \   00000080   070040E0           SUB      R0,R0,R7
   \   00000084   010040E0           SUB      R0,R0,R1
   \   00000088   010040E2           SUB      R0,R0,#+1
   \   0000008C   B801CDE1           STRH     R0,[SP, #+24]
   1306            rClip.y1 = WM_GetWindowSizeY(hObj) - EffectSize - 1;
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   ........           BL       WM_GetWindowSizeY
   \   00000098   070040E0           SUB      R0,R0,R7
   \   0000009C   010040E2           SUB      R0,R0,#+1
   \   000000A0   BA01CDE1           STRH     R0,[SP, #+26]
   1307            prOldClip = WM_SetUserClipRect(&rClip);
   \   000000A4   14008DE2           ADD      R0,SP,#+20
   \   000000A8   ........           BL       WM_SetUserClipRect
   \   000000AC   2C008DE5           STR      R0,[SP, #+44]
   1308            if (pObj->hText) {
   \   000000B0   440095E5           LDR      R0,[R5, #+68]
   \   000000B4   000050E3           CMP      R0,#+0
   \   000000B8   6100000A           BEQ      ??_MULTIEDIT_Paint_0
   1309              const char * pText;
   1310              int Line = 0;
   \   000000BC   0080A0E3           MOV      R8,#+0
   1311              int xSize       = _GetXSize(hObj, pObj);
   \   000000C0   24108DE2           ADD      R1,SP,#+36
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   ........           BL       WM_GetInsideRectExScrollbar
   \   000000CC   F802DDE1           LDRSH    R0,[SP, #+40]
   \   000000D0   F412DDE1           LDRSH    R1,[SP, #+36]
   \   000000D4   010040E0           SUB      R0,R0,R1
   \   000000D8   8710D5E5           LDRB     R1,[R5, #+135]
   \   000000DC   810040E0           SUB      R0,R0,R1, LSL #+1
   \   000000E0   019040E2           SUB      R9,R0,#+1
   1312              int NumVisLines = _GetNumVisLines(hObj, pObj);
   \   000000E4   1C108DE2           ADD      R1,SP,#+28
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       WM_GetInsideRectExScrollbar
   \   000000F0   800095E5           LDR      R0,[R5, #+128]
   \   000000F4   ........           BL       GUI_GetYDistOfFont
   \   000000F8   0010A0E1           MOV      R1,R0
   \   000000FC   F202DDE1           LDRSH    R0,[SP, #+34]
   \   00000100   FE21DDE1           LDRSH    R2,[SP, #+30]
   \   00000104   020040E0           SUB      R0,R0,R2
   \   00000108   010080E2           ADD      R0,R0,#+1
   \   0000010C   ........           BL       __aeabi_idiv
   \   00000110   00A0A0E1           MOV      R10,R0
   1313              /* Get the text */
   1314              pText = (const char *)GUI_LOCK_H(pObj->hText);
   \   00000114   440095E5           LDR      R0,[R5, #+68]
   \   00000118   ........           BL       GUI_ALLOC_LockH
   \   0000011C   00B0A0E1           MOV      R11,R0
   1315              /* Set the rectangle for drawing */
   1316              r.x0 = xOff;
   \   00000120   F001DDE1           LDRSH    R0,[SP, #+16]
   \   00000124   0C109DE5           LDR      R1,[SP, #+12]
   1317              r.y0 = EffectSize;
   \   00000128   B270CDE1           STRH     R7,[SP, #+2]
   \   0000012C   010040E0           SUB      R0,R0,R1
   \   00000130   B000CDE1           STRH     R0,[SP, #+0]
   1318              r.x1 = xSize + EffectSize + HBorder - 1;
   \   00000134   08109DE5           LDR      R1,[SP, #+8]
   \   00000138   090087E0           ADD      R0,R7,R9
   \   0000013C   000081E0           ADD      R0,R1,R0
   \   00000140   010040E2           SUB      R0,R0,#+1
   \   00000144   B400CDE1           STRH     R0,[SP, #+4]
   1319              r.y1 = pObj->Widget.Win.Rect.y1 - pObj->Widget.Win.Rect.y0 + 1;
   \   00000148   F600D5E1           LDRSH    R0,[R5, #+6]
   \   0000014C   F210D5E1           LDRSH    R1,[R5, #+2]
   \   00000150   010040E0           SUB      R0,R0,R1
   \   00000154   010080E2           ADD      R0,R0,#+1
   \   00000158   B600CDE1           STRH     R0,[SP, #+6]
   1320              /* Use cached position of first visible byte if possible */
   1321              if (ScrollPosY >= pObj->CacheFirstVisibleLine) {
   \   0000015C   B206D5E1           LDRH     R0,[R5, #+98]
   \   00000160   000056E1           CMP      R6,R0
   \   00000164   030000BA           BLT      ??_MULTIEDIT_Paint_1
   1322                if (pObj->CacheFirstVisibleByte) {
   \   00000168   B406D5E1           LDRH     R0,[R5, #+100]
   \   0000016C   000050E3           CMP      R0,#+0
   1323                  pText += pObj->CacheFirstVisibleByte;
   \   00000170   0BB08010           ADDNE    R11,R0,R11
   1324                  Line   = pObj->CacheFirstVisibleLine;
   \   00000174   B286D511           LDRHNE   R8,[R5, #+98]
   1325                }
   1326              }
   1327              if (pObj->Align == GUI_TA_RIGHT) {
   \                     ??_MULTIEDIT_Paint_1:
   \   00000178   B606D5E1           LDRH     R0,[R5, #+102]
   \   0000017C   010050E3           CMP      R0,#+1
   \   00000180   0700001A           BNE      ??_MULTIEDIT_Paint_2
   1328                r.x0 += ScrollPosX;
   \   00000184   F000DDE1           LDRSH    R0,[SP, #+0]
   \   00000188   0C109DE5           LDR      R1,[SP, #+12]
   \   0000018C   000081E0           ADD      R0,R1,R0
   \   00000190   B000CDE1           STRH     R0,[SP, #+0]
   1329                r.x1 += ScrollPosX;
   \   00000194   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000198   0C109DE5           LDR      R1,[SP, #+12]
   \   0000019C   000081E0           ADD      R0,R1,R0
   \   000001A0   B400CDE1           STRH     R0,[SP, #+4]
   1330              }
   1331              /* Do the drawing of the text */
   1332              do {
   1333                /* Cache the position of the first visible byte and the depending line number */
   1334                if (pObj->CacheFirstVisibleLine != ScrollPosY) {
   \                     ??_MULTIEDIT_Paint_2:
   \   000001A4   B206D5E1           LDRH     R0,[R5, #+98]
   \   000001A8   060050E1           CMP      R0,R6
   \   000001AC   0800000A           BEQ      ??_MULTIEDIT_Paint_3
   1335                  if (Line == ScrollPosY) {
   \   000001B0   060058E1           CMP      R8,R6
   \   000001B4   0600001A           BNE      ??_MULTIEDIT_Paint_3
   1336                    const char * p;
   1337                    p = (const char *)GUI_LOCK_H(pObj->hText);
   1338                    pObj->CacheFirstVisibleByte = pText - p;
   \   000001B8   440095E5           LDR      R0,[R5, #+68]
   \   000001BC   ........           BL       GUI_ALLOC_LockH
   \   000001C0   00004BE0           SUB      R0,R11,R0
   \   000001C4   B406C5E1           STRH     R0,[R5, #+100]
   1339                    pObj->CacheFirstVisibleLine = ScrollPosY;
   \   000001C8   B266C5E1           STRH     R6,[R5, #+98]
   1340                    GUI_UNLOCK_H(p);
   \   000001CC   ........           BL       GUI_ALLOC_UnlockH
   \   000001D0   010000EA           B        ??_MULTIEDIT_Paint_4
   1341                  }
   1342                }
   1343                /* Draw it */
   1344                if ((Line >= ScrollPosY) && ((Line - ScrollPosY) <= NumVisLines)) {
   \                     ??_MULTIEDIT_Paint_3:
   \   000001D4   060058E1           CMP      R8,R6
   \   000001D8   0B0000BA           BLT      ??_MULTIEDIT_Paint_5
   \                     ??_MULTIEDIT_Paint_4:
   \   000001DC   060048E0           SUB      R0,R8,R6
   \   000001E0   00005AE1           CMP      R10,R0
   \   000001E4   080000BA           BLT      ??_MULTIEDIT_Paint_5
   1345                  _DispString(hObj, pObj, pText, &r);
   \   000001E8   0D30A0E1           MOV      R3,SP
   \   000001EC   0B20A0E1           MOV      R2,R11
   \   000001F0   0510A0E1           MOV      R1,R5
   \   000001F4   0400A0E1           MOV      R0,R4
   \   000001F8   ........           BL       _DispString
   1346                  r.y0 += FontSizeY;  /* Next line */
   \   000001FC   F200DDE1           LDRSH    R0,[SP, #+2]
   \   00000200   30109DE5           LDR      R1,[SP, #+48]
   \   00000204   000081E0           ADD      R0,R1,R0
   \   00000208   B200CDE1           STRH     R0,[SP, #+2]
   1347                }
   1348                pText += _WrapGetNumBytesToNextLine(hObj, pObj, pText);
   \                     ??_MULTIEDIT_Paint_5:
   \   0000020C   0B20A0E1           MOV      R2,R11
   \   00000210   0510A0E1           MOV      R1,R5
   \   00000214   0400A0E1           MOV      R0,R4
   \   00000218   ........           BL       _WrapGetNumBytesToNextLine
   \   0000021C   0BB080E0           ADD      R11,R0,R11
   1349                Line++;
   \   00000220   018088E2           ADD      R8,R8,#+1
   1350              } while (GUI_UC_GetCharCode(pText) && ((Line - ScrollPosY) <= NumVisLines));
   \   00000224   0B00A0E1           MOV      R0,R11
   \   00000228   ........           BL       GUI_UC_GetCharCode
   \   0000022C   000050E3           CMP      R0,#+0
   \   00000230   0200000A           BEQ      ??_MULTIEDIT_Paint_6
   \   00000234   060048E0           SUB      R0,R8,R6
   \   00000238   00005AE1           CMP      R10,R0
   \   0000023C   D8FFFFAA           BGE      ??_MULTIEDIT_Paint_2
   1351              GUI_UNLOCK_H(pText);
   \                     ??_MULTIEDIT_Paint_6:
   \   00000240   ........           BL       GUI_ALLOC_UnlockH
   1352            }
   1353            /* Draw cursor if necessary */
   1354            if (WM__IsEnabled(hObj)) {
   \                     ??_MULTIEDIT_Paint_0:
   \   00000244   0400A0E1           MOV      R0,R4
   \   00000248   ........           BL       WM__IsEnabled
   \   0000024C   000050E3           CMP      R0,#+0
   \   00000250   0400000A           BEQ      ??_MULTIEDIT_Paint_7
   1355              _InvertCursor(hObj);
   \   00000254   0400A0E1           MOV      R0,R4
   \   00000258   ........           BL       _InvertCursor
   1356              WM_RestartTimer(pObj->hTimer, 0);
   \   0000025C   0010A0E3           MOV      R1,#+0
   \   00000260   880095E5           LDR      R0,[R5, #+136]
   \   00000264   ........           BL       WM_RestartTimer
   1357            }
   1358            WM_SetUserClipRect(prOldClip);
   \                     ??_MULTIEDIT_Paint_7:
   \   00000268   2C009DE5           LDR      R0,[SP, #+44]
   \   0000026C   ........           BL       WM_SetUserClipRect
   1359            /* Draw the 3D effect (if configured) */
   1360            WIDGET__EFFECT_DrawDown(&pObj->Widget);
   \   00000270   0500A0E1           MOV      R0,R5
   \   00000274   ........           BL       WIDGET__EFFECT_DrawDown
   1361          }
   \   00000278   34D08DE2           ADD      SP,SP,#+52       ;; stack cleaning
   \   0000027C   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1362          
   1363          /*********************************************************************
   1364          *
   1365          *       _OnTouch
   1366          */

   \                                 In section .text, align 4, keep-with-next
   1367          static void _OnTouch(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ * pObj, WM_MESSAGE * pMsg) {
   \                     _OnTouch:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   1368            int Notification;
   1369            const GUI_PID_STATE * pState = (const GUI_PID_STATE *)pMsg->Data.p;
   \   00000004   0C6092E5           LDR      R6,[R2, #+12]
   \   00000008   08D04DE2           SUB      SP,SP,#+8
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0150A0E1           MOV      R5,R1
   1370            if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
   \   00000014   000056E3           CMP      R6,#+0
   \   00000018   3D00000A           BEQ      ??_OnTouch_0
   1371              if (pState->Pressed) {
   \   0000001C   0800D6E5           LDRB     R0,[R6, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   3800000A           BEQ      ??_OnTouch_1
   1372                int Effect, xPos, yPos;
   1373                Effect = pObj->Widget.pEffect->EffectSize;
   \   00000028   2C0095E5           LDR      R0,[R5, #+44]
   1374                xPos   = pState->x + pObj->ScrollStateH.v - Effect - pObj->HBorder;
   \   0000002C   781095E5           LDR      R1,[R5, #+120]
   \   00000030   007090E5           LDR      R7,[R0, #+0]
   \   00000034   000096E5           LDR      R0,[R6, #+0]
   \   00000038   000081E0           ADD      R0,R1,R0
   \   0000003C   8710D5E5           LDRB     R1,[R5, #+135]
   \   00000040   070040E0           SUB      R0,R0,R7
   \   00000044   018040E0           SUB      R8,R0,R1
   1375                yPos   = pState->y + pObj->ScrollStateV.v * GUI_GetYDistOfFont(pObj->pFont) - Effect;
   \   00000048   800095E5           LDR      R0,[R5, #+128]
   \   0000004C   ........           BL       GUI_GetYDistOfFont
   1376                _SetCursorXY(hObj, pObj, xPos, yPos);
   \   00000050   6C2095E5           LDR      R2,[R5, #+108]
   \   00000054   041096E5           LDR      R1,[R6, #+4]
   \   00000058   901221E0           MLA      R1,R0,R2,R1
   \   0000005C   0820A0E1           MOV      R2,R8
   \   00000060   073041E0           SUB      R3,R1,R7
   \   00000064   0510A0E1           MOV      R1,R5
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   ........           BL       _SetCursorXY
   1377                _Invalidate(hObj);
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   ........           BL       _ManageAutoScrollV
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   ........           BL       GUI_ALLOC_LockH
   \   00000080   0050A0E1           MOV      R5,R0
   \   00000084   8400D5E5           LDRB     R0,[R5, #+132]
   \   00000088   100010E3           TST      R0,#0x10
   \   0000008C   1700000A           BEQ      ??_OnTouch_2
   \   00000090   0D10A0E1           MOV      R1,SP
   \   00000094   0400A0E1           MOV      R0,R4
   \   00000098   ........           BL       WM_GetInsideRectExScrollbar
   \   0000009C   F400DDE1           LDRSH    R0,[SP, #+4]
   \   000000A0   F010DDE1           LDRSH    R1,[SP, #+0]
   \   000000A4   010040E0           SUB      R0,R0,R1
   \   000000A8   8710D5E5           LDRB     R1,[R5, #+135]
   \   000000AC   810040E0           SUB      R0,R0,R1, LSL #+1
   \   000000B0   016040E2           SUB      R6,R0,#+1
   \   000000B4   0510A0E1           MOV      R1,R5
   \   000000B8   0400A0E1           MOV      R0,R4
   \   000000BC   ........           BL       _GetTextSizeX
   \   000000C0   000056E1           CMP      R6,R0
   \   000000C4   0050A0A3           MOVGE    R5,#+0
   \   000000C8   0150A0B3           MOVLT    R5,#+1
   \   000000CC   ........           BL       GUI_ALLOC_UnlockH
   \   000000D0   0510A0E1           MOV      R1,R5
   \   000000D4   0400A0E1           MOV      R0,R4
   \   000000D8   ........           BL       WM_SetScrollbarH
   \   000000DC   050050E1           CMP      R0,R5
   \   000000E0   0300000A           BEQ      ??_OnTouch_3
   \   000000E4   0400A0E1           MOV      R0,R4
   \   000000E8   ........           BL       _ManageAutoScrollV
   \   000000EC   000000EA           B        ??_OnTouch_3
   \                     ??_OnTouch_2:
   \   000000F0   ........           BL       GUI_ALLOC_UnlockH
   \                     ??_OnTouch_3:
   \   000000F4   0400A0E1           MOV      R0,R4
   \   000000F8   ........           BL       _CalcScrollParas
   \   000000FC   0400A0E1           MOV      R0,R4
   \   00000100   ........           BL       WM_InvalidateWindow
   1378                Notification = WM_NOTIFICATION_CLICKED;
   \   00000104   0110A0E3           MOV      R1,#+1
   \   00000108   020000EA           B        ??_OnTouch_4
   1379              } else {
   1380                Notification = WM_NOTIFICATION_RELEASED;
   \                     ??_OnTouch_1:
   \   0000010C   0210A0E3           MOV      R1,#+2
   \   00000110   000000EA           B        ??_OnTouch_4
   1381              }
   1382            } else {
   1383              Notification = WM_NOTIFICATION_MOVED_OUT;
   \                     ??_OnTouch_0:
   \   00000114   0310A0E3           MOV      R1,#+3
   1384            }
   1385            WM_NotifyParent(hObj, Notification);
   \                     ??_OnTouch_4:
   \   00000118   0400A0E1           MOV      R0,R4
   \   0000011C   ........           BL       WM_NotifyParent
   1386          }
   \   00000120   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000124   F081BDE8           POP      {R4-R8,PC}       ;; return
   1387          
   1388          /*********************************************************************
   1389          *
   1390          *       _AddKey
   1391          *
   1392          * Returns: 1 if Key has been consumed
   1393          *          0 else
   1394          */

   \                                 In section .text, align 4, keep-with-next
   1395          static int _AddKey(MULTIEDIT_HANDLE hObj, U16 Key) {
   \                     _AddKey:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
   \   00000008   0040A0E1           MOV      R4,R0
   1396            int r = 0;               /* Key has not been consumed */
   \   0000000C   0070A0E3           MOV      R7,#+0
   1397            const char * pText;
   1398            GUI_RECT RectInvalid;
   1399            int NoScroll;
   1400            int OldCursorPosY;
   1401            int OldCharSizeX;
   1402            MULTIEDIT_OBJ * pObj;
   1403            int OldScrollPosV;
   1404            int OldScrollPosH;
   1405            U16 CursorPosChar;
   1406            U16 NumCharsPrompt;
   1407            U8 Flags;
   1408            int OldCursorPosX;
   1409            int NoChanges = 0;
   \   00000010   00A0A0E3           MOV      R10,#+0
   1410          
   1411            if (WM__IsEnabled(hObj) == 0) {
   \   00000014   ........           BL       WM__IsEnabled
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0F00001A           BNE      ??_AddKey_1
   1412              /* The following makes sure, that the contents of the widget can be scrolled
   1413               * with the keys GUI_KEY_UP and GUI_KEY_DOWN also in disabled state if a
   1414               * vertical scrollbar exists
   1415               */
   1416              void (* pScrollFunc)(WM_HWIN);
   1417              switch (Key) {
   \   00000020   B002DDE1           LDRH     R0,[SP, #+32]
   \   00000024   110050E2           SUBS     R0,R0,#+17
   \   00000028   0200000A           BEQ      ??_AddKey_2
   \   0000002C   020050E2           SUBS     R0,R0,#+2
   \   00000030   0200000A           BEQ      ??_AddKey_3
   \   00000034   DF0100EA           B        ??_AddKey_4
   1418              case GUI_KEY_UP:
   1419                pScrollFunc = SCROLLBAR_Dec;
   \                     ??_AddKey_2:
   \   00000038   ........           LDR      R5,??DataTable3
   1420                break;
   \   0000003C   000000EA           B        ??_AddKey_5
   1421              case GUI_KEY_DOWN:
   1422                pScrollFunc = SCROLLBAR_Inc;
   \                     ??_AddKey_3:
   \   00000040   ........           LDR      R5,??DataTable3_1
   1423                break;
   1424              default:
   1425                pScrollFunc = NULL;
   1426              }
   1427              if (pScrollFunc) {
   \                     ??_AddKey_5:
   \   00000044   000055E3           CMP      R5,#+0
   \   00000048   DA01000A           BEQ      ??_AddKey_4
   1428                pScrollFunc(WM_GetScrollbarV(hObj));
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       WM_GetScrollbarV
   \   00000054   35FF2FE1           BLX      R5
   1429                return 1;
   \   00000058   0100A0E3           MOV      R0,#+1
   \   0000005C   D60100EA           B        ??_AddKey_6
   1430              }
   1431              return 0;
   1432            }
   1433            pObj = MULTIEDIT_LOCK_H(hObj);
   \                     ??_AddKey_1:
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       GUI_ALLOC_LockH
   \   00000068   0080A0E1           MOV      R8,R0
   1434            pText = (const char *)GUI_LOCK_H(pObj->hText);
   \   0000006C   440098E5           LDR      R0,[R8, #+68]
   \   00000070   ........           BL       GUI_ALLOC_LockH
   1435            if (GUI__BIDI_Enabled == 0) {
   \   00000074   ........           LDR      R9,??DataTable3_2
   \   00000078   0060A0E1           MOV      R6,R0
   \   0000007C   000099E5           LDR      R0,[R9, #+0]
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   0300001A           BNE      ??_AddKey_7
   1436              OldCursorPosX = pObj->CursorPosX - pObj->ScrollStateH.v;
   \   00000088   FA15D8E1           LDRSH    R1,[R8, #+90]
   \   0000008C   782098E5           LDR      R2,[R8, #+120]
   \   00000090   021041E0           SUB      R1,R1,R2
   \   00000094   0C108DE5           STR      R1,[SP, #+12]
   1437            }
   1438            OldCursorPosY = pObj->CursorPosY - pObj->ScrollStateV.v * GUI_GetYSizeOfFont(pObj->pFont);
   \                     ??_AddKey_7:
   \   00000098   800098E5           LDR      R0,[R8, #+128]
   \   0000009C   ........           BL       GUI_GetYSizeOfFont
   \   000000A0   6C2098E5           LDR      R2,[R8, #+108]
   \   000000A4   BC15D8E1           LDRH     R1,[R8, #+92]
   \   000000A8   900202E0           MUL      R2,R0,R2
   1439            OldCharSizeX  = GUI_GetCharDistX(GUI_UC_GetCharCode(pText + pObj->CursorPosByte));
   \   000000AC   B805D8E1           LDRH     R0,[R8, #+88]
   \   000000B0   025041E0           SUB      R5,R1,R2
   \   000000B4   060080E0           ADD      R0,R0,R6
   \   000000B8   ........           BL       GUI_UC_GetCharCode
   \   000000BC   ........           BL       GUI_GetCharDistX
   1440            OldScrollPosV = pObj->ScrollStateV.v;
   \   000000C0   6C1098E5           LDR      R1,[R8, #+108]
   \   000000C4   0060A0E1           MOV      R6,R0
   \   000000C8   1C108DE5           STR      R1,[SP, #+28]
   1441            OldScrollPosH = pObj->ScrollStateH.v;
   \   000000CC   781098E5           LDR      R1,[R8, #+120]
   \   000000D0   18108DE5           STR      R1,[SP, #+24]
   1442            CursorPosChar = pObj->CursorPosChar;
   1443            NumCharsPrompt = pObj->NumCharsPrompt;
   \   000000D4   BC14D8E1           LDRH     R1,[R8, #+76]
   \   000000D8   B6B5D8E1           LDRH     R11,[R8, #+86]
   \   000000DC   B011CDE1           STRH     R1,[SP, #+16]
   1444            Flags = pObj->Flags;
   \   000000E0   8410D8E5           LDRB     R1,[R8, #+132]
   \   000000E4   00108DE5           STR      R1,[SP, #+0]
   1445            GUI_UNLOCK_H(pText);
   \   000000E8   ........           BL       GUI_ALLOC_UnlockH
   1446            if (!OldCharSizeX) {
   \   000000EC   000056E3           CMP      R6,#+0
   \   000000F0   0400001A           BNE      ??_AddKey_8
   1447              int IsRTL;
   1448              OldCharSizeX = _GetCursorSizeX(hObj, pObj, &IsRTL);
   \   000000F4   14208DE2           ADD      R2,SP,#+20
   \   000000F8   0810A0E1           MOV      R1,R8
   \   000000FC   0400A0E1           MOV      R0,R4
   \   00000100   ........           BL       _GetCursorSizeX
   \   00000104   0060A0E1           MOV      R6,R0
   1449            }
   1450            GUI_UNLOCK_H(pObj);
   \                     ??_AddKey_8:
   \   00000108   ........           BL       GUI_ALLOC_UnlockH
   1451            switch (Key) {
   \   0000010C   B002DDE1           LDRH     R0,[SP, #+32]
   \   00000110   080040E2           SUB      R0,R0,#+8
   \   00000114   160050E3           CMP      R0,#+22
   \   00000118   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_AddKey_0:
   \   0000011C   F400008A           BHI      ??_AddKey_9
   \   00000120   940000EA           B        ??_AddKey_10
   \   00000124   F20000EA           B        ??_AddKey_9
   \   00000128   F10000EA           B        ??_AddKey_9
   \   0000012C   F00000EA           B        ??_AddKey_9
   \   00000130   EF0000EA           B        ??_AddKey_9
   \   00000134   C10000EA           B        ??_AddKey_11
   \   00000138   ED0000EA           B        ??_AddKey_9
   \   0000013C   EC0000EA           B        ??_AddKey_9
   \   00000140   520000EA           B        ??_AddKey_12
   \   00000144   0C0000EA           B        ??_AddKey_13
   \   00000148   310000EA           B        ??_AddKey_14
   \   0000014C   220000EA           B        ??_AddKey_15
   \   00000150   E70000EA           B        ??_AddKey_9
   \   00000154   E60000EA           B        ??_AddKey_9
   \   00000158   E50000EA           B        ??_AddKey_9
   \   0000015C   760000EA           B        ??_AddKey_16
   \   00000160   650000EA           B        ??_AddKey_17
   \   00000164   E20000EA           B        ??_AddKey_9
   \   00000168   E10000EA           B        ??_AddKey_9
   \   0000016C   0A0100EA           B        ??_AddKey_18
   \   00000170   DF0000EA           B        ??_AddKey_9
   \   00000174   A60000EA           B        ??_AddKey_19
   \   00000178   A10000EA           B        ??_AddKey_20
   1452            case GUI_KEY_UP:
   1453              _MoveCursorUp(hObj);
   \                     ??_AddKey_13:
   \   0000017C   0400A0E1           MOV      R0,R4
   \   00000180   ........           BL       GUI_ALLOC_LockH
   \   00000184   0070A0E1           MOV      R7,R0
   \   00000188   0D30A0E1           MOV      R3,SP
   \   0000018C   10208DE2           ADD      R2,SP,#+16
   \   00000190   0710A0E1           MOV      R1,R7
   \   00000194   0400A0E1           MOV      R0,R4
   \   00000198   ........           BL       _GetCursorXY
   \   0000019C   800097E5           LDR      R0,[R7, #+128]
   \   000001A0   ........           BL       GUI_GetYDistOfFont
   \   000001A4   00109DE5           LDR      R1,[SP, #+0]
   \   000001A8   10209DE5           LDR      R2,[SP, #+16]
   \   000001AC   000041E0           SUB      R0,R1,R0
   \                     ??_AddKey_21:
   \   000001B0   00008DE5           STR      R0,[SP, #+0]
   \   000001B4   0030A0E1           MOV      R3,R0
   \   000001B8   0710A0E1           MOV      R1,R7
   \   000001BC   0400A0E1           MOV      R0,R4
   \   000001C0   ........           BL       _SetCursorXY
   \   000001C4   ........           BL       GUI_ALLOC_UnlockH
   1454              if (GUI__BIDI_Enabled == 0) {
   \                     ??_AddKey_22:
   \   000001C8   000099E5           LDR      R0,[R9, #+0]
   \   000001CC   000050E3           CMP      R0,#+0
   \   000001D0   F000001A           BNE      ??_AddKey_23
   1455                NoChanges = 1;
   \   000001D4   01A0A0E3           MOV      R10,#+1
   1456              }
   1457              r = 1;               /* Key has been consumed */
   \   000001D8   EE0000EA           B        ??_AddKey_23
   1458              break;
   1459            case GUI_KEY_DOWN:
   1460              _MoveCursorDown(hObj);
   \                     ??_AddKey_15:
   \   000001DC   0400A0E1           MOV      R0,R4
   \   000001E0   ........           BL       GUI_ALLOC_LockH
   \   000001E4   0070A0E1           MOV      R7,R0
   \   000001E8   0D30A0E1           MOV      R3,SP
   \   000001EC   10208DE2           ADD      R2,SP,#+16
   \   000001F0   0710A0E1           MOV      R1,R7
   \   000001F4   0400A0E1           MOV      R0,R4
   \   000001F8   ........           BL       _GetCursorXY
   \   000001FC   800097E5           LDR      R0,[R7, #+128]
   \   00000200   ........           BL       GUI_GetYDistOfFont
   \   00000204   00109DE5           LDR      R1,[SP, #+0]
   \   00000208   10209DE5           LDR      R2,[SP, #+16]
   \   0000020C   010080E0           ADD      R0,R0,R1
   \   00000210   E6FFFFEA           B        ??_AddKey_21
   1461              if (GUI__BIDI_Enabled == 0) {
   1462                NoChanges = 1;
   1463              }
   1464              r = 1;               /* Key has been consumed */
   1465              break;
   1466            case GUI_KEY_RIGHT:
   1467              _SetCursorPos(hObj, CursorPosChar + 1);
   \                     ??_AddKey_14:
   \   00000214   0400A0E1           MOV      R0,R4
   \   00000218   ........           BL       GUI_ALLOC_LockH
   \   0000021C   0070A0E1           MOV      R7,R0
   \   00000220   10008DE2           ADD      R0,SP,#+16
   \   00000224   00008DE5           STR      R0,[SP, #+0]
   \   00000228   14308DE2           ADD      R3,SP,#+20
   \   0000022C   01208BE2           ADD      R2,R11,#+1
   \   00000230   0710A0E1           MOV      R1,R7
   \   00000234   0400A0E1           MOV      R0,R4
   \   00000238   ........           BL       _CalcNextValidCursorPos
   \   0000023C   B615D7E1           LDRH     R1,[R7, #+86]
   \   00000240   000051E1           CMP      R1,R0
   \   00000244   0100001A           BNE      ??_AddKey_24
   \   00000248   ........           BL       GUI_ALLOC_UnlockH
   \   0000024C   0A0000EA           B        ??_AddKey_25
   \                     ??_AddKey_24:
   \   00000250   14109DE5           LDR      R1,[SP, #+20]
   \   00000254   B815C7E1           STRH     R1,[R7, #+88]
   \   00000258   B605C7E1           STRH     R0,[R7, #+86]
   \   0000025C   10009DE5           LDR      R0,[SP, #+16]
   \   00000260   B405C7E1           STRH     R0,[R7, #+84]
   \   00000264   8500D7E5           LDRB     R0,[R7, #+133]
   \   00000268   080080E3           ORR      R0,R0,#0x8
   \   0000026C   8500C7E5           STRB     R0,[R7, #+133]
   \   00000270   ........           BL       GUI_ALLOC_UnlockH
   \   00000274   0400A0E1           MOV      R0,R4
   \   00000278   ........           BL       _CalcScrollPos
   1468              if (GUI__BIDI_Enabled == 0) {
   \                     ??_AddKey_25:
   \   0000027C   000099E5           LDR      R0,[R9, #+0]
   \   00000280   000050E3           CMP      R0,#+0
   \   00000284   C300001A           BNE      ??_AddKey_23
   1469                NoChanges = 1;
   \   00000288   01A0A0E3           MOV      R10,#+1
   1470              }
   1471              r = 1;               /* Key has been consumed */
   \   0000028C   C10000EA           B        ??_AddKey_23
   1472              break;
   1473            case GUI_KEY_LEFT:
   1474              _SetCursorPos(hObj, CursorPosChar - 1);
   \                     ??_AddKey_12:
   \   00000290   0400A0E1           MOV      R0,R4
   \   00000294   ........           BL       GUI_ALLOC_LockH
   \   00000298   0070A0E1           MOV      R7,R0
   \   0000029C   10008DE2           ADD      R0,SP,#+16
   \   000002A0   00008DE5           STR      R0,[SP, #+0]
   \   000002A4   14308DE2           ADD      R3,SP,#+20
   \   000002A8   01204BE2           SUB      R2,R11,#+1
   \   000002AC   0710A0E1           MOV      R1,R7
   \   000002B0   0400A0E1           MOV      R0,R4
   \   000002B4   ........           BL       _CalcNextValidCursorPos
   \   000002B8   B615D7E1           LDRH     R1,[R7, #+86]
   \   000002BC   000051E1           CMP      R1,R0
   \   000002C0   0100001A           BNE      ??_AddKey_26
   \   000002C4   ........           BL       GUI_ALLOC_UnlockH
   \   000002C8   BEFFFFEA           B        ??_AddKey_22
   \                     ??_AddKey_26:
   \   000002CC   14109DE5           LDR      R1,[SP, #+20]
   \   000002D0   B815C7E1           STRH     R1,[R7, #+88]
   \   000002D4   B605C7E1           STRH     R0,[R7, #+86]
   \   000002D8   10009DE5           LDR      R0,[SP, #+16]
   \   000002DC   B405C7E1           STRH     R0,[R7, #+84]
   \   000002E0   8500D7E5           LDRB     R0,[R7, #+133]
   \   000002E4   080080E3           ORR      R0,R0,#0x8
   \   000002E8   8500C7E5           STRB     R0,[R7, #+133]
   \   000002EC   ........           BL       GUI_ALLOC_UnlockH
   \   000002F0   0400A0E1           MOV      R0,R4
   \   000002F4   ........           BL       _CalcScrollPos
   1475              if (GUI__BIDI_Enabled == 0) {
   \   000002F8   B2FFFFEA           B        ??_AddKey_22
   1476                NoChanges = 1;
   1477              }
   1478              r = 1;               /* Key has been consumed */
   1479              break;
   1480            case GUI_KEY_END:
   1481              _MoveCursor2LineEnd(hObj);
   \                     ??_AddKey_17:
   \   000002FC   0400A0E1           MOV      R0,R4
   \   00000300   ........           BL       GUI_ALLOC_LockH
   \   00000304   0070A0E1           MOV      R7,R0
   \   00000308   0D30A0E1           MOV      R3,SP
   \   0000030C   10208DE2           ADD      R2,SP,#+16
   \   00000310   0710A0E1           MOV      R1,R7
   \   00000314   0400A0E1           MOV      R0,R4
   \   00000318   ........           BL       _GetCursorXY
   \   0000031C   FF20A0E3           MOV      R2,#+255
   \   00000320   00309DE5           LDR      R3,[SP, #+0]
   \   00000324   7F2C82E3           ORR      R2,R2,#0x7F00
   \   00000328   0710A0E1           MOV      R1,R7
   \   0000032C   0400A0E1           MOV      R0,R4
   \   00000330   ........           BL       _SetCursorXY
   \   00000334   ........           BL       GUI_ALLOC_UnlockH
   1482              if (GUI__BIDI_Enabled == 0) {
   \   00000338   CFFFFFEA           B        ??_AddKey_25
   1483                NoChanges = 1;
   1484              }
   1485              r = 1;               /* Key has been consumed */
   1486              break;
   1487            case GUI_KEY_HOME:
   1488              _MoveCursor2LinePos1(hObj);
   \                     ??_AddKey_16:
   \   0000033C   0400A0E1           MOV      R0,R4
   \   00000340   ........           BL       GUI_ALLOC_LockH
   \   00000344   0070A0E1           MOV      R7,R0
   \   00000348   0D30A0E1           MOV      R3,SP
   \   0000034C   10208DE2           ADD      R2,SP,#+16
   \   00000350   0710A0E1           MOV      R1,R7
   \   00000354   0400A0E1           MOV      R0,R4
   \   00000358   ........           BL       _GetCursorXY
   \   0000035C   00309DE5           LDR      R3,[SP, #+0]
   \   00000360   0020A0E3           MOV      R2,#+0
   \   00000364   0710A0E1           MOV      R1,R7
   \   00000368   0400A0E1           MOV      R0,R4
   \   0000036C   ........           BL       _SetCursorXY
   \   00000370   ........           BL       GUI_ALLOC_UnlockH
   1489              if (GUI__BIDI_Enabled == 0) {
   \   00000374   93FFFFEA           B        ??_AddKey_22
   1490                NoChanges = 1;
   1491              }
   1492              r = 1;               /* Key has been consumed */
   1493              break;
   1494            case GUI_KEY_BACKSPACE:
   1495              if (!(Flags & MULTIEDIT_SF_READONLY)) {
   \                     ??_AddKey_10:
   \   00000378   00009DE5           LDR      R0,[SP, #+0]
   \   0000037C   010010E3           TST      R0,#0x1
   \   00000380   8500001A           BNE      ??_AddKey_18
   1496                if (CursorPosChar > NumCharsPrompt) {
   \   00000384   B001DDE1           LDRH     R0,[SP, #+16]
   \   00000388   0B0050E1           CMP      R0,R11
   \   0000038C   810000AA           BGE      ??_AddKey_23
   1497                  _SetCursorPos(hObj, CursorPosChar - 1);
   \   00000390   0400A0E1           MOV      R0,R4
   \   00000394   ........           BL       GUI_ALLOC_LockH
   \   00000398   0070A0E1           MOV      R7,R0
   \   0000039C   10008DE2           ADD      R0,SP,#+16
   \   000003A0   00008DE5           STR      R0,[SP, #+0]
   \   000003A4   14308DE2           ADD      R3,SP,#+20
   \   000003A8   01204BE2           SUB      R2,R11,#+1
   \   000003AC   0710A0E1           MOV      R1,R7
   \   000003B0   0400A0E1           MOV      R0,R4
   \   000003B4   ........           BL       _CalcNextValidCursorPos
   \   000003B8   B615D7E1           LDRH     R1,[R7, #+86]
   \   000003BC   000051E1           CMP      R1,R0
   \   000003C0   0100001A           BNE      ??_AddKey_27
   \   000003C4   ........           BL       GUI_ALLOC_UnlockH
   \   000003C8   0A0000EA           B        ??_AddKey_28
   \                     ??_AddKey_27:
   \   000003CC   14109DE5           LDR      R1,[SP, #+20]
   \   000003D0   B815C7E1           STRH     R1,[R7, #+88]
   \   000003D4   B605C7E1           STRH     R0,[R7, #+86]
   \   000003D8   10009DE5           LDR      R0,[SP, #+16]
   \   000003DC   B405C7E1           STRH     R0,[R7, #+84]
   \   000003E0   8500D7E5           LDRB     R0,[R7, #+133]
   \   000003E4   080080E3           ORR      R0,R0,#0x8
   \   000003E8   8500C7E5           STRB     R0,[R7, #+133]
   \   000003EC   ........           BL       GUI_ALLOC_UnlockH
   \   000003F0   0400A0E1           MOV      R0,R4
   \   000003F4   ........           BL       _CalcScrollPos
   1498                  _DeleteChar(hObj);
   \                     ??_AddKey_28:
   \   000003F8   0400A0E1           MOV      R0,R4
   \   000003FC   ........           BL       _DeleteChar
   1499                }
   1500                r = 1;               /* Key has been consumed */
   \   00000400   640000EA           B        ??_AddKey_23
   1501              }
   1502              break;
   1503            case GUI_KEY_DELETE:
   1504              if (!(Flags & MULTIEDIT_SF_READONLY)) {
   \                     ??_AddKey_20:
   \   00000404   00009DE5           LDR      R0,[SP, #+0]
   \   00000408   010010E3           TST      R0,#0x1
   \   0000040C   6200001A           BNE      ??_AddKey_18
   1505                _DeleteChar(hObj);
   \   00000410   F8FFFFEA           B        ??_AddKey_28
   1506                r = 1;               /* Key has been consumed */
   1507              }
   1508              break;
   1509            case GUI_KEY_INSERT:
   1510              pObj = MULTIEDIT_LOCK_H(hObj);
   \                     ??_AddKey_19:
   \   00000414   0400A0E1           MOV      R0,R4
   \   00000418   ........           BL       GUI_ALLOC_LockH
   \   0000041C   0080A0E1           MOV      R8,R0
   1511              if (!(Flags & MULTIEDIT_CF_INSERT)) {
   \   00000420   8400D8E5           LDRB     R0,[R8, #+132]
   \   00000424   00109DE5           LDR      R1,[SP, #+0]
   \   00000428   040011E3           TST      R1,#0x4
   1512                pObj->Flags |= MULTIEDIT_CF_INSERT;
   \   0000042C   04008003           ORREQ    R0,R0,#0x4
   1513              } else {
   1514                pObj->Flags &= ~MULTIEDIT_CF_INSERT;
   \   00000430   FB000012           ANDNE    R0,R0,#0xFB
   \   00000434   8400C8E5           STRB     R0,[R8, #+132]
   1515              }
   1516              GUI_UNLOCK_H(pObj);
   \   00000438   ........           BL       GUI_ALLOC_UnlockH
   1517              if (GUI__BIDI_Enabled == 0) {
   \   0000043C   61FFFFEA           B        ??_AddKey_22
   1518                NoChanges = 1;
   1519              }
   1520              r = 1;               /* Key has been consumed */
   1521              break;
   1522            case GUI_KEY_ENTER:
   1523              if (Flags & MULTIEDIT_SF_READONLY) {
   \                     ??_AddKey_11:
   \   00000440   00009DE5           LDR      R0,[SP, #+0]
   \   00000444   010010E3           TST      R0,#0x1
   1524                _MoveCursor2NextLine(hObj);
   \   00000448   0400A011           MOVNE    R0,R4
   \   0000044C   1500001A           BNE      ??_AddKey_29
   1525              } else {
   1526                if (_InsertChar(hObj, (U8)('\n'))) {
   \   00000450   0A10A0E3           MOV      R1,#+10
   \   00000454   0400A0E1           MOV      R0,R4
   \   00000458   ........           BL       _InsertChar
   \   0000045C   000050E3           CMP      R0,#+0
   \   00000460   4C00000A           BEQ      ??_AddKey_23
   1527                  if (Flags & MULTIEDIT_SF_PASSWORD) {
   \   00000464   00009DE5           LDR      R0,[SP, #+0]
   \   00000468   200010E3           TST      R0,#0x20
   \   0000046C   0400A0E1           MOV      R0,R4
   \   00000470   0C00000A           BEQ      ??_AddKey_29
   1528                    _SetCursorPos(hObj, CursorPosChar + 1);
   \   00000474   ........           BL       GUI_ALLOC_LockH
   \   00000478   0070A0E1           MOV      R7,R0
   \   0000047C   10008DE2           ADD      R0,SP,#+16
   \   00000480   00008DE5           STR      R0,[SP, #+0]
   \   00000484   14308DE2           ADD      R3,SP,#+20
   \   00000488   01208BE2           ADD      R2,R11,#+1
   \   0000048C   0710A0E1           MOV      R1,R7
   \   00000490   0400A0E1           MOV      R0,R4
   \   00000494   ........           BL       _CalcNextValidCursorPos
   \   00000498   B615D7E1           LDRH     R1,[R7, #+86]
   \   0000049C   000051E1           CMP      R1,R0
   \   000004A0   1100000A           BEQ      ??_AddKey_30
   \   000004A4   300000EA           B        ??_AddKey_31
   1529                  } else {
   1530                    _MoveCursor2NextLine(hObj);
   \                     ??_AddKey_29:
   \   000004A8   ........           BL       GUI_ALLOC_LockH
   \   000004AC   0070A0E1           MOV      R7,R0
   \   000004B0   0D30A0E1           MOV      R3,SP
   \   000004B4   10208DE2           ADD      R2,SP,#+16
   \   000004B8   0710A0E1           MOV      R1,R7
   \   000004BC   0400A0E1           MOV      R0,R4
   \   000004C0   ........           BL       _GetCursorXY
   \   000004C4   800097E5           LDR      R0,[R7, #+128]
   \   000004C8   ........           BL       GUI_GetYDistOfFont
   \   000004CC   00109DE5           LDR      R1,[SP, #+0]
   \   000004D0   0020A0E3           MOV      R2,#+0
   \   000004D4   010080E0           ADD      R0,R0,R1
   \   000004D8   00008DE5           STR      R0,[SP, #+0]
   \   000004DC   0030A0E1           MOV      R3,R0
   \   000004E0   0710A0E1           MOV      R1,R7
   \   000004E4   0400A0E1           MOV      R0,R4
   \   000004E8   ........           BL       _SetCursorXY
   \                     ??_AddKey_30:
   \   000004EC   ........           BL       GUI_ALLOC_UnlockH
   1531                  }
   1532                }
   1533              }
   1534              r = 1;               /* Key has been consumed */
   \   000004F0   280000EA           B        ??_AddKey_23
   1535              break;
   1536            case GUI_KEY_ESCAPE:
   1537              break;
   1538            default:
   1539              if (!(Flags & MULTIEDIT_SF_READONLY) && (Key >= 0x20)) {
   \                     ??_AddKey_9:
   \   000004F4   00009DE5           LDR      R0,[SP, #+0]
   \   000004F8   010010E3           TST      R0,#0x1
   \   000004FC   2600001A           BNE      ??_AddKey_18
   \   00000500   B002DDE1           LDRH     R0,[SP, #+32]
   \   00000504   200050E3           CMP      R0,#+32
   \   00000508   2300003A           BCC      ??_AddKey_18
   1540                if (_IsOverwriteAtThisChar(hObj)) {
   \   0000050C   0400A0E1           MOV      R0,R4
   \   00000510   ........           BL       _IsOverwriteAtThisChar
   \   00000514   000050E3           CMP      R0,#+0
   \   00000518   0100000A           BEQ      ??_AddKey_32
   1541                  _DeleteChar(hObj); /* Pointer recalculation required, will be done later in this routine */
   \   0000051C   0400A0E1           MOV      R0,R4
   \   00000520   ........           BL       _DeleteChar
   1542                }
   1543                if (_InsertChar(hObj, Key)) {
   \                     ??_AddKey_32:
   \   00000524   B012DDE1           LDRH     R1,[SP, #+32]
   \   00000528   0400A0E1           MOV      R0,R4
   \   0000052C   ........           BL       _InsertChar
   \   00000530   000050E3           CMP      R0,#+0
   \   00000534   1700000A           BEQ      ??_AddKey_23
   1544                  _SetCursorPos(hObj, CursorPosChar + 1);
   \   00000538   0400A0E1           MOV      R0,R4
   \   0000053C   ........           BL       GUI_ALLOC_LockH
   \   00000540   0070A0E1           MOV      R7,R0
   \   00000544   10008DE2           ADD      R0,SP,#+16
   \   00000548   00008DE5           STR      R0,[SP, #+0]
   \   0000054C   14308DE2           ADD      R3,SP,#+20
   \   00000550   01208BE2           ADD      R2,R11,#+1
   \   00000554   0710A0E1           MOV      R1,R7
   \   00000558   0400A0E1           MOV      R0,R4
   \   0000055C   ........           BL       _CalcNextValidCursorPos
   \   00000560   B615D7E1           LDRH     R1,[R7, #+86]
   \   00000564   000051E1           CMP      R1,R0
   \   00000568   DFFFFF0A           BEQ      ??_AddKey_30
   \                     ??_AddKey_31:
   \   0000056C   14109DE5           LDR      R1,[SP, #+20]
   \   00000570   B815C7E1           STRH     R1,[R7, #+88]
   \   00000574   B605C7E1           STRH     R0,[R7, #+86]
   \   00000578   10009DE5           LDR      R0,[SP, #+16]
   \   0000057C   B405C7E1           STRH     R0,[R7, #+84]
   \   00000580   8500D7E5           LDRB     R0,[R7, #+133]
   \   00000584   080080E3           ORR      R0,R0,#0x8
   \   00000588   8500C7E5           STRB     R0,[R7, #+133]
   \   0000058C   ........           BL       GUI_ALLOC_UnlockH
   \   00000590   0400A0E1           MOV      R0,R4
   \   00000594   ........           BL       _CalcScrollPos
   1545                }
   1546                r = 1;               /* Key has been consumed */
   \                     ??_AddKey_23:
   \   00000598   0170A0E3           MOV      R7,#+1
   1547              }
   1548            }
   1549            /* Calculate the invalid rectangle */
   1550            _ManageScrollers(hObj);
   \                     ??_AddKey_18:
   \   0000059C   0400A0E1           MOV      R0,R4
   \   000005A0   ........           BL       _ManageAutoScrollV
   \   000005A4   0400A0E1           MOV      R0,R4
   \   000005A8   ........           BL       GUI_ALLOC_LockH
   \   000005AC   0080A0E1           MOV      R8,R0
   \   000005B0   8400D8E5           LDRB     R0,[R8, #+132]
   \   000005B4   100010E3           TST      R0,#0x10
   \   000005B8   1700000A           BEQ      ??_AddKey_33
   \   000005BC   10108DE2           ADD      R1,SP,#+16
   \   000005C0   0400A0E1           MOV      R0,R4
   \   000005C4   ........           BL       WM_GetInsideRectExScrollbar
   \   000005C8   F401DDE1           LDRSH    R0,[SP, #+20]
   \   000005CC   F011DDE1           LDRSH    R1,[SP, #+16]
   \   000005D0   010040E0           SUB      R0,R0,R1
   \   000005D4   8710D8E5           LDRB     R1,[R8, #+135]
   \   000005D8   810040E0           SUB      R0,R0,R1, LSL #+1
   \   000005DC   01B040E2           SUB      R11,R0,#+1
   \   000005E0   0810A0E1           MOV      R1,R8
   \   000005E4   0400A0E1           MOV      R0,R4
   \   000005E8   ........           BL       _GetTextSizeX
   \   000005EC   00005BE1           CMP      R11,R0
   \   000005F0   0080A0A3           MOVGE    R8,#+0
   \   000005F4   0180A0B3           MOVLT    R8,#+1
   \   000005F8   ........           BL       GUI_ALLOC_UnlockH
   \   000005FC   0810A0E1           MOV      R1,R8
   \   00000600   0400A0E1           MOV      R0,R4
   \   00000604   ........           BL       WM_SetScrollbarH
   \   00000608   080050E1           CMP      R0,R8
   \   0000060C   0300000A           BEQ      ??_AddKey_34
   \   00000610   0400A0E1           MOV      R0,R4
   \   00000614   ........           BL       _ManageAutoScrollV
   \   00000618   000000EA           B        ??_AddKey_34
   \                     ??_AddKey_33:
   \   0000061C   ........           BL       GUI_ALLOC_UnlockH
   \                     ??_AddKey_34:
   \   00000620   0400A0E1           MOV      R0,R4
   \   00000624   ........           BL       _CalcScrollParas
   1551            WM_GetInsideRectExScrollbar(hObj, &RectInvalid); /* Initialize invalid rectangle */
   \   00000628   04108DE2           ADD      R1,SP,#+4
   \   0000062C   0400A0E1           MOV      R0,R4
   \   00000630   ........           BL       WM_GetInsideRectExScrollbar
   1552            /* Check if the scroll position has been changed */
   1553            pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000634   0400A0E1           MOV      R0,R4
   \   00000638   ........           BL       GUI_ALLOC_LockH
   \   0000063C   0080A0E1           MOV      R8,R0
   1554            if ((pObj->ScrollStateH.v == OldScrollPosH) && (pObj->ScrollStateV.v == OldScrollPosV)) {
   \   00000640   780098E5           LDR      R0,[R8, #+120]
   \   00000644   18109DE5           LDR      R1,[SP, #+24]
   \   00000648   010050E1           CMP      R0,R1
   \   0000064C   0400001A           BNE      ??_AddKey_35
   \   00000650   6C0098E5           LDR      R0,[R8, #+108]
   \   00000654   1C109DE5           LDR      R1,[SP, #+28]
   \   00000658   010050E1           CMP      R0,R1
   1555              NoScroll = 1;
   \   0000065C   0100A003           MOVEQ    R0,#+1
   \   00000660   0000000A           BEQ      ??_AddKey_36
   1556            } else {
   1557              NoScroll = 0;
   \                     ??_AddKey_35:
   \   00000664   0000A0E3           MOV      R0,#+0
   1558            }
   1559          
   1560          
   1561            if ((GUI__BIDI_Enabled == 0) && (NoChanges == 1) && (NoScroll == 1)) {
   \                     ??_AddKey_36:
   \   00000668   001099E5           LDR      R1,[R9, #+0]
   \   0000066C   000051E3           CMP      R1,#+0
   \   00000670   4100001A           BNE      ??_AddKey_37
   \   00000674   01005AE3           CMP      R10,#+1
   \   00000678   01005003           CMPEQ    R0,#+1
   \   0000067C   4000001A           BNE      ??_AddKey_38
   1562              /* If only the cursor has been moved, the invalid
   1563               * rectangle is the surrounding rectangle of the old
   1564               * and new position of the cursor
   1565               */
   1566              int EffectSize, HBorder, FontSizeY, CharSizeX;
   1567              int CharRectX0, CharRectX1, CharRectY0, OldCharRectX1;
   1568              pText = (const char *)GUI_LOCK_H(pObj->hText);
   \   00000680   440098E5           LDR      R0,[R8, #+68]
   \   00000684   ........           BL       GUI_ALLOC_LockH
   \   00000688   00008DE5           STR      R0,[SP, #+0]
   1569              EffectSize = pObj->Widget.pEffect->EffectSize;
   \   0000068C   2C0098E5           LDR      R0,[R8, #+44]
   1570              HBorder    = pObj->HBorder;
   \   00000690   87A0D8E5           LDRB     R10,[R8, #+135]
   \   00000694   009090E5           LDR      R9,[R0, #+0]
   1571              FontSizeY  = GUI_GetYSizeOfFont(pObj->pFont);
   \   00000698   800098E5           LDR      R0,[R8, #+128]
   \   0000069C   ........           BL       GUI_GetYSizeOfFont
   \   000006A0   00B0A0E1           MOV      R11,R0
   1572              CharSizeX  = GUI_GetCharDistX(GUI_UC_GetCharCode(pText + pObj->CursorPosByte));
   \   000006A4   B805D8E1           LDRH     R0,[R8, #+88]
   \   000006A8   00109DE5           LDR      R1,[SP, #+0]
   \   000006AC   010080E0           ADD      R0,R0,R1
   \   000006B0   ........           BL       GUI_UC_GetCharCode
   \   000006B4   ........           BL       GUI_GetCharDistX
   1573              if (!CharSizeX) {
   \   000006B8   000050E3           CMP      R0,#+0
   \   000006BC   0300001A           BNE      ??_AddKey_39
   1574                int IsRTL;
   1575                CharSizeX = _GetCursorSizeX(hObj, pObj, &IsRTL);
   \   000006C0   0D20A0E1           MOV      R2,SP
   \   000006C4   0810A0E1           MOV      R1,R8
   \   000006C8   0400A0E1           MOV      R0,R4
   \   000006CC   ........           BL       _GetCursorSizeX
   1576              }
   1577              /* Calculate leftmost pixel of invalid rectangle */
   1578              CharRectX0 = pObj->CursorPosX - pObj->ScrollStateH.v;
   \                     ??_AddKey_39:
   \   000006D0   FA15D8E1           LDRSH    R1,[R8, #+90]
   \   000006D4   782098E5           LDR      R2,[R8, #+120]
   1579              if (OldCursorPosX < CharRectX0) {
   1580                RectInvalid.x0 = OldCursorPosX;
   1581              } else {
   1582                RectInvalid.x0 = CharRectX0;
   1583              }
   1584              RectInvalid.x0 += EffectSize + HBorder;
   \   000006D8   09308AE0           ADD      R3,R10,R9
   \   000006DC   021041E0           SUB      R1,R1,R2
   \   000006E0   0C209DE5           LDR      R2,[SP, #+12]
   1585              /* Calculate rightmost pixel of invalid rectangle */
   1586              CharRectX1    = CharRectX0 + CharSizeX - 1;
   \   000006E4   010080E0           ADD      R0,R0,R1
   \   000006E8   010052E1           CMP      R2,R1
   \   000006EC   B410CDA1           STRHGE   R1,[SP, #+4]
   1587              OldCharRectX1 = OldCursorPosX + OldCharSizeX - 1;
   \   000006F0   0C109DE5           LDR      R1,[SP, #+12]
   \   000006F4   B420CDB1           STRHLT   R2,[SP, #+4]
   \   000006F8   011086E0           ADD      R1,R6,R1
   \   000006FC   010040E2           SUB      R0,R0,#+1
   \   00000700   011041E2           SUB      R1,R1,#+1
   1588              if (OldCharRectX1 > CharRectX1) {
   \   00000704   010050E1           CMP      R0,R1
   1589                RectInvalid.x1 = OldCharRectX1;
   \   00000708   B810CDB1           STRHLT   R1,[SP, #+8]
   1590              } else {
   1591                RectInvalid.x1 = CharRectX1;
   \   0000070C   B800CDA1           STRHGE   R0,[SP, #+8]
   \   00000710   F420DDE1           LDRSH    R2,[SP, #+4]
   1592              }
   1593              RectInvalid.x1 += EffectSize + HBorder;
   \   00000714   F800DDE1           LDRSH    R0,[SP, #+8]
   \   00000718   09108AE0           ADD      R1,R10,R9
   \   0000071C   022083E0           ADD      R2,R3,R2
   \   00000720   000081E0           ADD      R0,R1,R0
   \   00000724   B420CDE1           STRH     R2,[SP, #+4]
   \   00000728   B800CDE1           STRH     R0,[SP, #+8]
   1594              /* Calculate topmost pixel of invalid rectangle */
   1595              CharRectY0 = pObj->CursorPosY - pObj->ScrollStateV.v * FontSizeY;
   \   0000072C   6C1098E5           LDR      R1,[R8, #+108]
   \   00000730   BC05D8E1           LDRH     R0,[R8, #+92]
   \   00000734   9B0101E0           MUL      R1,R11,R1
   \   00000738   010040E0           SUB      R0,R0,R1
   1596              if (OldCursorPosY < CharRectY0) {
   \   0000073C   000055E1           CMP      R5,R0
   1597                RectInvalid.y0 = OldCursorPosY;
   \   00000740   B650CDB1           STRHLT   R5,[SP, #+6]
   1598              } else {
   1599                RectInvalid.y0 = CharRectY0;
   \   00000744   B600CDA1           STRHGE   R0,[SP, #+6]
   1600              }
   1601              RectInvalid.y0 += EffectSize;
   1602              /* Calculate bottommost pixel of invalid rectangle */
   1603              if (OldCursorPosY > CharRectY0) {
   \   00000748   050050E1           CMP      R0,R5
   1604                RectInvalid.y1 = FontSizeY - 1 + OldCursorPosY;
   \   0000074C   0B0085B0           ADDLT    R0,R5,R11
   1605              } else {
   1606                RectInvalid.y1 = FontSizeY - 1 + CharRectY0;
   \   00000750   0B0080A0           ADDGE    R0,R0,R11
   \   00000754   010040E2           SUB      R0,R0,#+1
   \   00000758   BA00CDE1           STRH     R0,[SP, #+10]
   \   0000075C   F610DDE1           LDRSH    R1,[SP, #+6]
   1607              }
   1608              RectInvalid.y1 += EffectSize;
   \   00000760   FA00DDE1           LDRSH    R0,[SP, #+10]
   \   00000764   011089E0           ADD      R1,R9,R1
   \   00000768   000089E0           ADD      R0,R9,R0
   \   0000076C   B610CDE1           STRH     R1,[SP, #+6]
   \   00000770   BA00CDE1           STRH     R0,[SP, #+10]
   1609              GUI_UNLOCK_H(pText);
   \   00000774   ........           BL       GUI_ALLOC_UnlockH
   \   00000778   0A0000EA           B        ??_AddKey_40
   1610            } else {
   1611              if ((GUI__BIDI_Enabled == 0) || (NoScroll)) {
   \                     ??_AddKey_37:
   \   0000077C   000050E3           CMP      R0,#+0
   \   00000780   0800000A           BEQ      ??_AddKey_40
   1612                /* If the contents has been changed and no scroll has been detected, 
   1613                 * invalidate all lines from the topmost cursor position until the 
   1614                 * bottom of the widget.
   1615                 */
   1616                int CharRectY0;
   1617                CharRectY0 = pObj->CursorPosY - pObj->ScrollStateV.v * GUI_GetYSizeOfFont(pObj->pFont);
   \                     ??_AddKey_38:
   \   00000784   800098E5           LDR      R0,[R8, #+128]
   \   00000788   ........           BL       GUI_GetYSizeOfFont
   \   0000078C   6C2098E5           LDR      R2,[R8, #+108]
   \   00000790   BC15D8E1           LDRH     R1,[R8, #+92]
   \   00000794   900202E0           MUL      R2,R0,R2
   \   00000798   020041E0           SUB      R0,R1,R2
   1618                if (OldCursorPosY < CharRectY0) {
   \   0000079C   000055E1           CMP      R5,R0
   1619                  RectInvalid.y0 = OldCursorPosY;
   \   000007A0   B650CDB1           STRHLT   R5,[SP, #+6]
   1620                } else {
   1621                  RectInvalid.y0 = CharRectY0;
   \   000007A4   B600CDA1           STRHGE   R0,[SP, #+6]
   1622                }
   1623              }
   1624            }
   1625            GUI_UNLOCK_H(pObj);
   \                     ??_AddKey_40:
   \   000007A8   ........           BL       GUI_ALLOC_UnlockH
   1626            WM_InvalidateRect(hObj, &RectInvalid);
   \   000007AC   04108DE2           ADD      R1,SP,#+4
   \   000007B0   0400A0E1           MOV      R0,R4
   \   000007B4   ........           BL       WM_InvalidateRect
   1627            return r;
   \                     ??_AddKey_4:
   \   000007B8   0700A0E1           MOV      R0,R7
   \                     ??_AddKey_6:
   \   000007BC   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   000007C0   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1628          }
   1629          
   1630          /*********************************************************************
   1631          *
   1632          *       _SetText
   1633          */

   \                                 In section .text, align 4, keep-with-next
   1634          static void _SetText(MULTIEDIT_HANDLE hObj, const char * pNew) {
   \                     _SetText:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   1635            MULTIEDIT_OBJ * pObj;
   1636            int NumCharsNew, NumCharsOld, NumBytesNew, NumBytesOld;
   1637            char * pText;
   1638            pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000010   ........           BL       GUI_ALLOC_LockH
   \   00000014   0090A0E1           MOV      R9,R0
   1639            NumCharsNew = NumCharsOld = NumBytesNew = NumBytesOld = 0;
   1640            if (pObj->hText) {
   \   00000018   440099E5           LDR      R0,[R9, #+68]
   \   0000001C   0060A0E3           MOV      R6,#+0
   \   00000020   0070A0E3           MOV      R7,#+0
   \   00000024   00A0A0E3           MOV      R10,#+0
   \   00000028   0080A0E3           MOV      R8,#+0
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0C00000A           BEQ      ??_SetText_0
   1641              pText  = (char *)GUI_LOCK_H(pObj->hText);
   \   00000034   ........           BL       GUI_ALLOC_LockH
   \   00000038   0060A0E1           MOV      R6,R0
   1642              pText += GUI_UC__NumChars2NumBytes(pText, pObj->NumCharsPrompt);
   \   0000003C   BC14D9E1           LDRH     R1,[R9, #+76]
   \   00000040   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000044   066080E0           ADD      R6,R0,R6
   1643              NumCharsOld = GUI__GetNumChars(pText);
   \   00000048   0600A0E1           MOV      R0,R6
   \   0000004C   ........           BL       GUI__GetNumChars
   \   00000050   00A0A0E1           MOV      R10,R0
   1644              NumBytesOld = GUI_UC__NumChars2NumBytes(pText, NumCharsOld);
   \   00000054   0A10A0E1           MOV      R1,R10
   \   00000058   0600A0E1           MOV      R0,R6
   \   0000005C   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000060   0060A0E1           MOV      R6,R0
   1645              GUI_UNLOCK_H(pText);
   \   00000064   ........           BL       GUI_ALLOC_UnlockH
   1646            }
   1647            if (pNew) {
   \                     ??_SetText_0:
   \   00000068   000055E3           CMP      R5,#+0
   \   0000006C   0600000A           BEQ      ??_SetText_1
   1648              NumCharsNew = GUI__GetNumChars(pNew);
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   ........           BL       GUI__GetNumChars
   \   00000078   0080A0E1           MOV      R8,R0
   1649              NumBytesNew = GUI_UC__NumChars2NumBytes(pNew, NumCharsNew);
   \   0000007C   0810A0E1           MOV      R1,R8
   \   00000080   0500A0E1           MOV      R0,R5
   \   00000084   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000088   0070A0E1           MOV      R7,R0
   1650            }
   1651            GUI_UNLOCK_H(pObj);
   \                     ??_SetText_1:
   \   0000008C   ........           BL       GUI_ALLOC_UnlockH
   1652            if (_IsCharsAvailable(hObj, NumCharsNew - NumCharsOld)) {
   \   00000090   0A8048E0           SUB      R8,R8,R10
   \   00000094   0190A0E3           MOV      R9,#+1
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   ........           BL       GUI_ALLOC_LockH
   \   000000A0   00A0A0E1           MOV      R10,R0
   \   000000A4   010058E3           CMP      R8,#+1
   \   000000A8   150000BA           BLT      ??_SetText_2
   \   000000AC   B804DAE1           LDRH     R0,[R10, #+72]
   \   000000B0   000050E3           CMP      R0,#+0
   \   000000B4   1200000A           BEQ      ??_SetText_2
   \   000000B8   44009AE5           LDR      R0,[R10, #+68]
   \   000000BC   0010A0E3           MOV      R1,#+0
   \   000000C0   000050E3           CMP      R0,#+0
   \   000000C4   0A00000A           BEQ      ??_SetText_3
   \   000000C8   8510DAE5           LDRB     R1,[R10, #+133]
   \   000000CC   010011E3           TST      R1,#0x1
   \   000000D0   0600000A           BEQ      ??_SetText_4
   \   000000D4   ........           BL       GUI_ALLOC_LockH
   \   000000D8   ........           BL       GUI__GetNumChars
   \   000000DC   BA04CAE1           STRH     R0,[R10, #+74]
   \   000000E0   ........           BL       GUI_ALLOC_UnlockH
   \   000000E4   8500DAE5           LDRB     R0,[R10, #+133]
   \   000000E8   FE0000E2           AND      R0,R0,#0xFE
   \   000000EC   8500CAE5           STRB     R0,[R10, #+133]
   \                     ??_SetText_4:
   \   000000F0   BA14DAE1           LDRH     R1,[R10, #+74]
   \                     ??_SetText_3:
   \   000000F4   B804DAE1           LDRH     R0,[R10, #+72]
   \   000000F8   081081E0           ADD      R1,R1,R8
   \   000000FC   010050E1           CMP      R0,R1
   \   00000100   0090A0B3           MOVLT    R9,#+0
   \                     ??_SetText_2:
   \   00000104   ........           BL       GUI_ALLOC_UnlockH
   \   00000108   000059E3           CMP      R9,#+0
   \   0000010C   6200000A           BEQ      ??_SetText_5
   1653              if (_IsSpaceInBuffer(hObj, NumBytesNew - NumBytesOld)) {
   \   00000110   061047E0           SUB      R1,R7,R6
   \   00000114   0400A0E1           MOV      R0,R4
   \   00000118   ........           BL       _IsSpaceInBuffer
   \   0000011C   000050E3           CMP      R0,#+0
   \   00000120   5D00000A           BEQ      ??_SetText_5
   1654                U16 NumCharsPrompt;
   1655                pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000124   0400A0E1           MOV      R0,R4
   \   00000128   ........           BL       GUI_ALLOC_LockH
   \   0000012C   0070A0E1           MOV      R7,R0
   1656                pText  = (char *)GUI_LOCK_H(pObj->hText);
   \   00000130   440097E5           LDR      R0,[R7, #+68]
   \   00000134   ........           BL       GUI_ALLOC_LockH
   \   00000138   0060A0E1           MOV      R6,R0
   1657                pText += GUI_UC__NumChars2NumBytes(pText, pObj->NumCharsPrompt);
   \   0000013C   BC14D7E1           LDRH     R1,[R7, #+76]
   \   00000140   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000144   066080E0           ADD      R6,R0,R6
   1658                if (pNew) {
   \   00000148   000055E3           CMP      R5,#+0
   \   0000014C   0300000A           BEQ      ??_SetText_6
   1659                  strcpy(pText, pNew);
   \   00000150   0510A0E1           MOV      R1,R5
   \   00000154   0600A0E1           MOV      R0,R6
   \   00000158   ........           BL       strcpy
   \   0000015C   010000EA           B        ??_SetText_7
   1660                } else {
   1661                  *pText = 0;
   \                     ??_SetText_6:
   \   00000160   0000A0E3           MOV      R0,#+0
   \   00000164   0000C6E5           STRB     R0,[R6, #+0]
   1662                }
   1663                NumCharsPrompt = pObj->NumCharsPrompt;
   \                     ??_SetText_7:
   \   00000168   BC64D7E1           LDRH     R6,[R7, #+76]
   1664                GUI_UNLOCK_H(pText);
   \   0000016C   ........           BL       GUI_ALLOC_UnlockH
   1665                GUI_UNLOCK_H(pObj);
   \   00000170   ........           BL       GUI_ALLOC_UnlockH
   1666                _SetCursorPos(hObj, NumCharsPrompt);
   \   00000174   0400A0E1           MOV      R0,R4
   \   00000178   ........           BL       GUI_ALLOC_LockH
   \   0000017C   0050A0E1           MOV      R5,R0
   \   00000180   04008DE2           ADD      R0,SP,#+4
   \   00000184   00008DE5           STR      R0,[SP, #+0]
   \   00000188   08308DE2           ADD      R3,SP,#+8
   \   0000018C   0620A0E1           MOV      R2,R6
   \   00000190   0510A0E1           MOV      R1,R5
   \   00000194   0400A0E1           MOV      R0,R4
   \   00000198   ........           BL       _CalcNextValidCursorPos
   \   0000019C   B615D5E1           LDRH     R1,[R5, #+86]
   \   000001A0   000051E1           CMP      R1,R0
   \   000001A4   0100001A           BNE      ??_SetText_8
   \   000001A8   ........           BL       GUI_ALLOC_UnlockH
   \   000001AC   0A0000EA           B        ??_SetText_9
   \                     ??_SetText_8:
   \   000001B0   08109DE5           LDR      R1,[SP, #+8]
   \   000001B4   B815C5E1           STRH     R1,[R5, #+88]
   \   000001B8   B605C5E1           STRH     R0,[R5, #+86]
   \   000001BC   04009DE5           LDR      R0,[SP, #+4]
   \   000001C0   B405C5E1           STRH     R0,[R5, #+84]
   \   000001C4   8500D5E5           LDRB     R0,[R5, #+133]
   \   000001C8   080080E3           ORR      R0,R0,#0x8
   \   000001CC   8500C5E5           STRB     R0,[R5, #+133]
   \   000001D0   ........           BL       GUI_ALLOC_UnlockH
   \   000001D4   0400A0E1           MOV      R0,R4
   \   000001D8   ........           BL       _CalcScrollPos
   1667                pObj = MULTIEDIT_LOCK_H(hObj);
   \                     ??_SetText_9:
   \   000001DC   0400A0E1           MOV      R0,R4
   \   000001E0   ........           BL       GUI_ALLOC_LockH
   \   000001E4   0090A0E1           MOV      R9,R0
   1668                _InvalidateNumChars(pObj);
   1669                _InvalidateNumLines(pObj);
   1670                _InvalidateTextSizeX(pObj);
   1671                _InvalidateCursorXY(pObj);
   \   000001E8   8500D9E5           LDRB     R0,[R9, #+133]
   \   000001EC   0F0080E3           ORR      R0,R0,#0xF
   \   000001F0   8500C9E5           STRB     R0,[R9, #+133]
   1672                GUI_UNLOCK_H(pObj);
   \   000001F4   ........           BL       GUI_ALLOC_UnlockH
   1673                _InvalidateTextArea(hObj);
   \   000001F8   0400A0E1           MOV      R0,R4
   \   000001FC   ........           BL       _ManageAutoScrollV
   \   00000200   0400A0E1           MOV      R0,R4
   \   00000204   ........           BL       GUI_ALLOC_LockH
   \   00000208   0050A0E1           MOV      R5,R0
   \   0000020C   8400D5E5           LDRB     R0,[R5, #+132]
   \   00000210   100010E3           TST      R0,#0x10
   \   00000214   1700000A           BEQ      ??_SetText_10
   \   00000218   0D10A0E1           MOV      R1,SP
   \   0000021C   0400A0E1           MOV      R0,R4
   \   00000220   ........           BL       WM_GetInsideRectExScrollbar
   \   00000224   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000228   F010DDE1           LDRSH    R1,[SP, #+0]
   \   0000022C   010040E0           SUB      R0,R0,R1
   \   00000230   8710D5E5           LDRB     R1,[R5, #+135]
   \   00000234   810040E0           SUB      R0,R0,R1, LSL #+1
   \   00000238   016040E2           SUB      R6,R0,#+1
   \   0000023C   0510A0E1           MOV      R1,R5
   \   00000240   0400A0E1           MOV      R0,R4
   \   00000244   ........           BL       _GetTextSizeX
   \   00000248   000056E1           CMP      R6,R0
   \   0000024C   0050A0A3           MOVGE    R5,#+0
   \   00000250   0150A0B3           MOVLT    R5,#+1
   \   00000254   ........           BL       GUI_ALLOC_UnlockH
   \   00000258   0510A0E1           MOV      R1,R5
   \   0000025C   0400A0E1           MOV      R0,R4
   \   00000260   ........           BL       WM_SetScrollbarH
   \   00000264   050050E1           CMP      R0,R5
   \   00000268   0300000A           BEQ      ??_SetText_11
   \   0000026C   0400A0E1           MOV      R0,R4
   \   00000270   ........           BL       _ManageAutoScrollV
   \   00000274   000000EA           B        ??_SetText_11
   \                     ??_SetText_10:
   \   00000278   ........           BL       GUI_ALLOC_UnlockH
   \                     ??_SetText_11:
   \   0000027C   0400A0E1           MOV      R0,R4
   \   00000280   ........           BL       _CalcScrollParas
   \   00000284   08108DE2           ADD      R1,SP,#+8
   \   00000288   0400A0E1           MOV      R0,R4
   \   0000028C   ........           BL       WM_GetInsideRectExScrollbar
   \   00000290   08108DE2           ADD      R1,SP,#+8
   \   00000294   0400A0E1           MOV      R0,R4
   \   00000298   ........           BL       WM_InvalidateRect
   1674              }
   1675            }
   1676          }
   \                     ??_SetText_5:
   \   0000029C   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   000002A0   F087BDE8           POP      {R4-R10,PC}      ;; return
   1677          
   1678          /*********************************************************************
   1679          *
   1680          *       Private routines
   1681          *
   1682          **********************************************************************
   1683          */
   1684          /*********************************************************************
   1685          *
   1686          *       MULTIEDIT_LockH
   1687          */
   1688          #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
   1689          MULTIEDIT_OBJ * MULTIEDIT_LockH(MULTIEDIT_HANDLE h) {
   1690            MULTIEDIT_OBJ * p = (MULTIEDIT_OBJ *)GUI_LOCK_H(h);
   1691            if (p) {
   1692              if (p->DebugId != MULTIEDIT_ID) {
   1693                GUI_DEBUG_ERROROUT("MULTIEDIT.c: Wrong handle type or Object not init'ed");
   1694                return 0;
   1695              }
   1696            }
   1697            return p;
   1698          }
   1699          #endif
   1700          
   1701          /*********************************************************************
   1702          *
   1703          *       Exported routines:  Callback
   1704          *
   1705          **********************************************************************
   1706          */
   1707          /*********************************************************************
   1708          *
   1709          *       MULTIEDIT_Callback
   1710          */

   \                                 In section .text, align 4, keep-with-next
   1711          void MULTIEDIT_Callback (WM_MESSAGE *pMsg) {
   \                     MULTIEDIT_Callback:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1712            MULTIEDIT_HANDLE hObj;
   1713            MULTIEDIT_OBJ * pObj;
   1714            WM_SCROLL_STATE ScrollState;
   1715            hObj = pMsg->hWin;
   \   00000008   045094E5           LDR      R5,[R4, #+4]
   \   0000000C   30D04DE2           SUB      SP,SP,#+48
   1716            /* Let widget handle the standard messages */
   1717            if (WIDGET_HandleActive(hObj, pMsg) == 0) {
   \   00000010   0410A0E1           MOV      R1,R4
   \   00000014   0500A0E1           MOV      R0,R5
   \   00000018   ........           BL       WIDGET_HandleActive
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   1F00000A           BEQ      ??MULTIEDIT_Callback_0
   1718              return;
   1719            }
   1720            pObj = (MULTIEDIT_OBJ *)GUI_LOCK_H(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           BL       GUI_ALLOC_LockH
   \   0000002C   0060A0E1           MOV      R6,R0
   1721            switch (pMsg->MsgId) {
   \   00000030   000094E5           LDR      R0,[R4, #+0]
   \   00000034   050050E2           SUBS     R0,R0,#+5
   \   00000038   2700000A           BEQ      ??MULTIEDIT_Callback_1
   \   0000003C   060050E2           SUBS     R0,R0,#+6
   \   00000040   9100000A           BEQ      ??MULTIEDIT_Callback_2
   \   00000044   010050E2           SUBS     R0,R0,#+1
   \   00000048   8A00000A           BEQ      ??MULTIEDIT_Callback_3
   \   0000004C   020050E2           SUBS     R0,R0,#+2
   \   00000050   9000000A           BEQ      ??MULTIEDIT_Callback_4
   \   00000054   010050E2           SUBS     R0,R0,#+1
   \   00000058   8100000A           BEQ      ??MULTIEDIT_Callback_5
   \   0000005C   160050E2           SUBS     R0,R0,#+22
   \   00000060   1100000A           BEQ      ??MULTIEDIT_Callback_6
   \   00000064   010050E2           SUBS     R0,R0,#+1
   \   00000068   4900000A           BEQ      ??MULTIEDIT_Callback_7
   \   0000006C   ED0050E2           SUBS     R0,R0,#+237
   \   00000070   0600001A           BNE      ??MULTIEDIT_Callback_8
   1722            case WM_TIMER:
   1723              WM_SelectWindow(hObj);
   \   00000074   0500A0E1           MOV      R0,R5
   \   00000078   ........           BL       WM_SelectWindow
   1724              _InvertCursor(hObj);
   \   0000007C   0500A0E1           MOV      R0,R5
   \   00000080   ........           BL       _InvertCursor
   1725              WM_RestartTimer(pObj->hTimer, 0);
   \   00000084   0010A0E3           MOV      R1,#+0
   \   00000088   880096E5           LDR      R0,[R6, #+136]
   \   0000008C   ........           BL       WM_RestartTimer
   1726              break;
   1727            case WM_NOTIFY_CLIENTCHANGE:
   1728              _InvalidateCursorXY(pObj);
   1729              _InvalidateNumLines(pObj);
   1730              _InvalidateTextSizeX(pObj);
   1731              _ClearCache(pObj);
   1732              GUI_UNLOCK_H(pObj);
   1733              _CalcScrollParas(hObj);
   1734              break;
   1735            case WM_SIZE:
   1736              _InvalidateCursorXY(pObj);
   1737              _InvalidateNumLines(pObj);
   1738              _InvalidateTextSizeX(pObj);
   1739              _ClearCache(pObj);
   1740              GUI_UNLOCK_H(pObj);
   1741              _Invalidate(hObj);
   1742              break;
   1743            case WM_NOTIFY_PARENT:
   1744              switch (pMsg->Data.v) {
   1745              case WM_NOTIFICATION_VALUE_CHANGED:
   1746                if (pMsg->hWinSrc  == WM_GetScrollbarV(hObj)) {
   1747                  WM_GetScrollState(pMsg->hWinSrc, &ScrollState);
   1748                  pObj->ScrollStateV.v = ScrollState.v;
   1749                  GUI_UNLOCK_H(pObj);
   1750                  WM_InvalidateWindow(hObj);
   1751                  WM_NotifyParent(hObj, WM_NOTIFICATION_SCROLL_CHANGED);
   1752                } else if (pMsg->hWinSrc == WM_GetScrollbarH(hObj)) {
   1753                  WM_GetScrollState(pMsg->hWinSrc, &ScrollState);
   1754                  pObj->ScrollStateH.v = ScrollState.v;
   1755                  GUI_UNLOCK_H(pObj);
   1756                  WM_InvalidateWindow(hObj);
   1757                  WM_NotifyParent(hObj, WM_NOTIFICATION_SCROLL_CHANGED);
   1758                }
   1759                break;
   1760              case WM_NOTIFICATION_SCROLLBAR_ADDED:
   1761                #if WIDGET_USE_PARENT_EFFECT
   1762                  WIDGET_SetEffect(pMsg->hWinSrc, pObj->Widget.pEffect);
   1763                #endif
   1764                GUI_UNLOCK_H(pObj);
   1765                _SetScrollState(hObj);
   1766                break;
   1767              }
   1768              break;
   1769            case WM_PAINT:
   1770              _MULTIEDIT_Paint(hObj, pObj);
   1771              GUI_UNLOCK_H(pObj);
   1772              return;
   1773            case WM_TOUCH:
   1774              _OnTouch(hObj, pObj, pMsg);
   1775              break;
   1776            case WM_DELETE:
   1777              GUI_ALLOC_FreePtr(&pObj->hText);
   1778              break;
   1779            case WM_KEY:
   1780              if (((const WM_KEY_INFO*)(pMsg->Data.p))->PressedCnt >0) {
   1781                int Key = ((const WM_KEY_INFO*)(pMsg->Data.p))->Key;
   1782                /* Leave code for test purpose
   1783                switch (Key) {
   1784                case '4': Key = GUI_KEY_LEFT;  break;
   1785                case '8': Key = GUI_KEY_UP;    break;
   1786                case '6': Key = GUI_KEY_RIGHT; break;
   1787                case '2': Key = GUI_KEY_DOWN;  break;
   1788                }
   1789                */
   1790                GUI_UNLOCK_H(pObj);
   1791                if (_AddKey(hObj, Key)) {
   1792                  return;
   1793                }
   1794              } else {
   1795                if (!(pObj->Flags & MULTIEDIT_SF_READONLY)) {
   1796                  GUI_UNLOCK_H(pObj);
   1797                  return;                /* Key release is consumed (not sent to parent) */
   1798                }
   1799              }
   1800            }
   1801            if (pObj) {
   \                     ??MULTIEDIT_Callback_8:
   \   00000090   000056E3           CMP      R6,#+0
   \   00000094   0000000A           BEQ      ??MULTIEDIT_Callback_9
   1802              GUI_UNLOCK_H(pObj);
   \   00000098   ........           BL       GUI_ALLOC_UnlockH
   1803            }
   1804            WM_DefaultProc(pMsg);
   \                     ??MULTIEDIT_Callback_9:
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   ........           BL       WM_DefaultProc
   1805          }
   \                     ??MULTIEDIT_Callback_0:
   \   000000A4   30D08DE2           ADD      SP,SP,#+48       ;; stack cleaning
   \   000000A8   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??MULTIEDIT_Callback_6:
   \   000000AC   8500D6E5           LDRB     R0,[R6, #+133]
   \   000000B0   0070A0E3           MOV      R7,#+0
   \   000000B4   0E0080E3           ORR      R0,R0,#0xE
   \   000000B8   8500C6E5           STRB     R0,[R6, #+133]
   \   000000BC   B076C6E1           STRH     R7,[R6, #+96]
   \   000000C0   BE75C6E1           STRH     R7,[R6, #+94]
   \   000000C4   B476C6E1           STRH     R7,[R6, #+100]
   \   000000C8   B276C6E1           STRH     R7,[R6, #+98]
   \   000000CC   ........           BL       GUI_ALLOC_UnlockH
   \   000000D0   0500A0E1           MOV      R0,R5
   \   000000D4   ........           BL       _CalcScrollParas
   \   000000D8   EFFFFFEA           B        ??MULTIEDIT_Callback_9
   \                     ??MULTIEDIT_Callback_1:
   \   000000DC   8500D6E5           LDRB     R0,[R6, #+133]
   \   000000E0   0070A0E3           MOV      R7,#+0
   \   000000E4   0E0080E3           ORR      R0,R0,#0xE
   \   000000E8   8500C6E5           STRB     R0,[R6, #+133]
   \   000000EC   B076C6E1           STRH     R7,[R6, #+96]
   \   000000F0   BE75C6E1           STRH     R7,[R6, #+94]
   \   000000F4   B476C6E1           STRH     R7,[R6, #+100]
   \   000000F8   B276C6E1           STRH     R7,[R6, #+98]
   \   000000FC   ........           BL       GUI_ALLOC_UnlockH
   \   00000100   0500A0E1           MOV      R0,R5
   \   00000104   ........           BL       _ManageAutoScrollV
   \   00000108   0500A0E1           MOV      R0,R5
   \   0000010C   ........           BL       GUI_ALLOC_LockH
   \   00000110   0060A0E1           MOV      R6,R0
   \   00000114   8400D6E5           LDRB     R0,[R6, #+132]
   \   00000118   100010E3           TST      R0,#0x10
   \   0000011C   1600000A           BEQ      ??MULTIEDIT_Callback_10
   \   00000120   0D10A0E1           MOV      R1,SP
   \   00000124   0500A0E1           MOV      R0,R5
   \   00000128   ........           BL       WM_GetInsideRectExScrollbar
   \   0000012C   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000130   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000134   010040E0           SUB      R0,R0,R1
   \   00000138   8710D6E5           LDRB     R1,[R6, #+135]
   \   0000013C   810040E0           SUB      R0,R0,R1, LSL #+1
   \   00000140   018040E2           SUB      R8,R0,#+1
   \   00000144   0610A0E1           MOV      R1,R6
   \   00000148   0500A0E1           MOV      R0,R5
   \   0000014C   ........           BL       _GetTextSizeX
   \   00000150   000058E1           CMP      R8,R0
   \   00000154   0170A0B3           MOVLT    R7,#+1
   \   00000158   ........           BL       GUI_ALLOC_UnlockH
   \   0000015C   0710A0E1           MOV      R1,R7
   \   00000160   0500A0E1           MOV      R0,R5
   \   00000164   ........           BL       WM_SetScrollbarH
   \   00000168   070050E1           CMP      R0,R7
   \   0000016C   0300000A           BEQ      ??MULTIEDIT_Callback_11
   \   00000170   0500A0E1           MOV      R0,R5
   \   00000174   ........           BL       _ManageAutoScrollV
   \   00000178   000000EA           B        ??MULTIEDIT_Callback_11
   \                     ??MULTIEDIT_Callback_10:
   \   0000017C   ........           BL       GUI_ALLOC_UnlockH
   \                     ??MULTIEDIT_Callback_11:
   \   00000180   0500A0E1           MOV      R0,R5
   \   00000184   ........           BL       _CalcScrollParas
   \   00000188   0500A0E1           MOV      R0,R5
   \   0000018C   ........           BL       WM_InvalidateWindow
   \   00000190   C1FFFFEA           B        ??MULTIEDIT_Callback_9
   \                     ??MULTIEDIT_Callback_7:
   \   00000194   0C0094E5           LDR      R0,[R4, #+12]
   \   00000198   050050E3           CMP      R0,#+5
   \   0000019C   0300000A           BEQ      ??MULTIEDIT_Callback_12
   \   000001A0   BAFFFF3A           BCC      ??MULTIEDIT_Callback_8
   \   000001A4   060050E3           CMP      R0,#+6
   \   000001A8   1C00000A           BEQ      ??MULTIEDIT_Callback_13
   \   000001AC   B7FFFFEA           B        ??MULTIEDIT_Callback_8
   \                     ??MULTIEDIT_Callback_12:
   \   000001B0   0500A0E1           MOV      R0,R5
   \   000001B4   ........           BL       WM_GetScrollbarV
   \   000001B8   082094E5           LDR      R2,[R4, #+8]
   \   000001BC   000052E1           CMP      R2,R0
   \   000001C0   0B00001A           BNE      ??MULTIEDIT_Callback_14
   \   000001C4   08108DE2           ADD      R1,SP,#+8
   \   000001C8   0200A0E1           MOV      R0,R2
   \   000001CC   ........           BL       WM_GetScrollState
   \   000001D0   0C009DE5           LDR      R0,[SP, #+12]
   \   000001D4   6C0086E5           STR      R0,[R6, #+108]
   \                     ??MULTIEDIT_Callback_15:
   \   000001D8   ........           BL       GUI_ALLOC_UnlockH
   \   000001DC   0500A0E1           MOV      R0,R5
   \   000001E0   ........           BL       WM_InvalidateWindow
   \   000001E4   0A10A0E3           MOV      R1,#+10
   \   000001E8   0500A0E1           MOV      R0,R5
   \   000001EC   ........           BL       WM_NotifyParent
   \   000001F0   A9FFFFEA           B        ??MULTIEDIT_Callback_9
   \                     ??MULTIEDIT_Callback_14:
   \   000001F4   0500A0E1           MOV      R0,R5
   \   000001F8   ........           BL       WM_GetScrollbarH
   \   000001FC   0010A0E1           MOV      R1,R0
   \   00000200   080094E5           LDR      R0,[R4, #+8]
   \   00000204   010050E1           CMP      R0,R1
   \   00000208   A0FFFF1A           BNE      ??MULTIEDIT_Callback_8
   \   0000020C   08108DE2           ADD      R1,SP,#+8
   \   00000210   ........           BL       WM_GetScrollState
   \   00000214   0C009DE5           LDR      R0,[SP, #+12]
   \   00000218   780086E5           STR      R0,[R6, #+120]
   \   0000021C   EDFFFFEA           B        ??MULTIEDIT_Callback_15
   \                     ??MULTIEDIT_Callback_13:
   \   00000220   ........           BL       GUI_ALLOC_UnlockH
   \   00000224   0500A0E1           MOV      R0,R5
   \   00000228   ........           BL       GUI_ALLOC_LockH
   \   0000022C   682080E2           ADD      R2,R0,#+104
   \   00000230   0850B2E8           LDM      R2!,{R3,R12,LR}
   \   00000234   20108DE2           ADD      R1,SP,#+32
   \   00000238   0850A1E8           STM      R1!,{R3,R12,LR}
   \   0000023C   740080E2           ADD      R0,R0,#+116
   \   00000240   0C10B0E8           LDM      R0!,{R2,R3,R12}
   \   00000244   14108DE2           ADD      R1,SP,#+20
   \   00000248   0C10A1E8           STM      R1!,{R2,R3,R12}
   \   0000024C   ........           BL       GUI_ALLOC_UnlockH
   \   00000250   14208DE2           ADD      R2,SP,#+20
   \   00000254   20108DE2           ADD      R1,SP,#+32
   \   00000258   0500A0E1           MOV      R0,R5
   \   0000025C   ........           BL       WIDGET__SetScrollState
   \   00000260   8DFFFFEA           B        ??MULTIEDIT_Callback_9
   \                     ??MULTIEDIT_Callback_5:
   \   00000264   0610A0E1           MOV      R1,R6
   \   00000268   0500A0E1           MOV      R0,R5
   \   0000026C   ........           BL       _MULTIEDIT_Paint
   \                     ??MULTIEDIT_Callback_16:
   \   00000270   ........           BL       GUI_ALLOC_UnlockH
   \   00000274   8AFFFFEA           B        ??MULTIEDIT_Callback_0
   \                     ??MULTIEDIT_Callback_3:
   \   00000278   0420A0E1           MOV      R2,R4
   \   0000027C   0610A0E1           MOV      R1,R6
   \   00000280   0500A0E1           MOV      R0,R5
   \   00000284   ........           BL       _OnTouch
   \   00000288   80FFFFEA           B        ??MULTIEDIT_Callback_8
   \                     ??MULTIEDIT_Callback_2:
   \   0000028C   440086E2           ADD      R0,R6,#+68
   \   00000290   ........           BL       GUI_ALLOC_FreePtr
   \   00000294   7DFFFFEA           B        ??MULTIEDIT_Callback_8
   \                     ??MULTIEDIT_Callback_4:
   \   00000298   0C0094E5           LDR      R0,[R4, #+12]
   \   0000029C   041090E5           LDR      R1,[R0, #+4]
   \   000002A0   010051E3           CMP      R1,#+1
   \   000002A4   080000BA           BLT      ??MULTIEDIT_Callback_17
   \   000002A8   006090E5           LDR      R6,[R0, #+0]
   \   000002AC   ........           BL       GUI_ALLOC_UnlockH
   \   000002B0   0618A0E1           LSL      R1,R6,#+16
   \   000002B4   2118A0E1           LSR      R1,R1,#+16
   \   000002B8   0500A0E1           MOV      R0,R5
   \   000002BC   ........           BL       _AddKey
   \   000002C0   000050E3           CMP      R0,#+0
   \   000002C4   76FFFF1A           BNE      ??MULTIEDIT_Callback_0
   \   000002C8   73FFFFEA           B        ??MULTIEDIT_Callback_9
   \                     ??MULTIEDIT_Callback_17:
   \   000002CC   8400D6E5           LDRB     R0,[R6, #+132]
   \   000002D0   010010E3           TST      R0,#0x1
   \   000002D4   6DFFFF1A           BNE      ??MULTIEDIT_Callback_8
   \   000002D8   E4FFFFEA           B        ??MULTIEDIT_Callback_16
   1806          
   1807          /*********************************************************************
   1808          *
   1809          *       Exported routines:  Create
   1810          *
   1811          **********************************************************************
   1812          */
   1813          
   1814          /* Note: the parameters to a create function may vary.
   1815                   Some widgets may have multiple create functions */
   1816          
   1817          /*********************************************************************
   1818          *
   1819          *       MULTIEDIT_CreateEx
   1820          */

   \                                 In section .text, align 4, keep-with-next
   1821          MULTIEDIT_HANDLE MULTIEDIT_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int WinFlags, int ExFlags,
   1822                                              int Id, int BufferSize, const char * pText)
   1823          {
   \                     MULTIEDIT_CreateEx:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0070A0E1           MOV      R7,R0
   \   0000000C   0180A0E1           MOV      R8,R1
   \   00000010   0290A0E1           MOV      R9,R2
   \   00000014   03A0A0E1           MOV      R10,R3
   \   00000018   38B09DE5           LDR      R11,[SP, #+56]
   \   0000001C   44609DE5           LDR      R6,[SP, #+68]
   \   00000020   48409DE5           LDR      R4,[SP, #+72]
   \   00000024   4C509DE5           LDR      R5,[SP, #+76]
   1824            MULTIEDIT_HANDLE hObj;
   1825            /* Create the window */
   1826            WM_LOCK();
   \   00000028   ........           BL       GUI_Lock
   1827            if ((xsize == 0) && (ysize == 0) && (x0 == 0) && (y0 == 0)) {
   \   0000002C   09008AE1           ORR      R0,R10,R9
   \   00000030   000087E1           ORR      R0,R7,R0
   \   00000034   000098E1           ORRS     R0,R8,R0
   \   00000038   0A00001A           BNE      ??MULTIEDIT_CreateEx_0
   1828              GUI_RECT Rect;
   1829              WM_GetClientRectEx(hParent, &Rect);
   \   0000003C   0D10A0E1           MOV      R1,SP
   \   00000040   0B00A0E1           MOV      R0,R11
   \   00000044   ........           BL       WM_GetClientRectEx
   1830              xsize = Rect.x1 - Rect.x0 + 1;
   \   00000048   F400DDE1           LDRSH    R0,[SP, #+4]
   \   0000004C   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000050   010040E0           SUB      R0,R0,R1
   \   00000054   019080E2           ADD      R9,R0,#+1
   1831              ysize = Rect.y1 - Rect.y0 + 1;
   \   00000058   F600DDE1           LDRSH    R0,[SP, #+6]
   \   0000005C   F210DDE1           LDRSH    R1,[SP, #+2]
   \   00000060   010040E0           SUB      R0,R0,R1
   \   00000064   01A080E2           ADD      R10,R0,#+1
   1832            }
   1833            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, &MULTIEDIT_Callback,
   1834                                          sizeof(MULTIEDIT_OBJ) - sizeof(WM_Obj));
   \                     ??MULTIEDIT_CreateEx_0:
   \   00000068   6400A0E3           MOV      R0,#+100
   \   0000006C   0C008DE5           STR      R0,[SP, #+12]
   \   00000070   ........           LDR      R0,??DataTable3_3
   \   00000074   00B08DE5           STR      R11,[SP, #+0]
   \   00000078   08008DE5           STR      R0,[SP, #+8]
   \   0000007C   3C009DE5           LDR      R0,[SP, #+60]
   \   00000080   0A30A0E1           MOV      R3,R10
   \   00000084   04008DE5           STR      R0,[SP, #+4]
   \   00000088   0920A0E1           MOV      R2,R9
   \   0000008C   0810A0E1           MOV      R1,R8
   \   00000090   0700A0E1           MOV      R0,R7
   \   00000094   ........           BL       WM_CreateWindowAsChild
   \   00000098   0070B0E1           MOVS     R7,R0
   1835            if (hObj) {
   \   0000009C   5300000A           BEQ      ??MULTIEDIT_CreateEx_1
   1836              int i;
   1837              MULTIEDIT_OBJ * pObj;
   1838              pObj = (MULTIEDIT_OBJ *)GUI_LOCK_H(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
   \   000000A0   ........           BL       GUI_ALLOC_LockH
   \   000000A4   0080A0E1           MOV      R8,R0
   1839              /* init widget specific variables */
   1840              WIDGET__Init(&pObj->Widget, Id, WIDGET_STATE_FOCUSSABLE);
   \   000000A8   1020A0E3           MOV      R2,#+16
   \   000000AC   0610A0E1           MOV      R1,R6
   \   000000B0   ........           BL       WIDGET__Init
   1841              /* init member variables */
   1842              MULTIEDIT_INIT_ID(pObj);
   1843              for (i = 0; i < NUM_DISP_MODES; i++) {
   \   000000B4   ........           LDR      R1,??DataTable3_4
   \   000000B8   0800A0E1           MOV      R0,R8
   \   000000BC   082081E2           ADD      R2,R1,#+8
   \   000000C0   0230A0E3           MOV      R3,#+2
   1844                pObj->aBkColor[i]  = _aDefaultBkColor[i];
   \                     ??MULTIEDIT_CreateEx_2:
   \   000000C4   04C091E4           LDR      R12,[R1], #+4
   1845                pObj->aColor[i]    = _aDefaultColor[i];
   1846              }
   \   000000C8   013053E2           SUBS     R3,R3,#+1
   \   000000CC   34C080E5           STR      R12,[R0, #+52]
   \   000000D0   04C092E4           LDR      R12,[R2], #+4
   \   000000D4   3CC080E5           STR      R12,[R0, #+60]
   \   000000D8   040080E2           ADD      R0,R0,#+4
   \   000000DC   F8FFFF1A           BNE      ??MULTIEDIT_CreateEx_2
   1847              pObj->pFont          = _pDefaultFont;
   \   000000E0   ........           LDR      R0,??DataTable3_5
   1848              pObj->Flags          = ExFlags;
   1849              pObj->CursorPosChar  = 0;
   \   000000E4   0060A0E3           MOV      R6,#+0
   \   000000E8   800088E5           STR      R0,[R8, #+128]
   \   000000EC   40009DE5           LDR      R0,[SP, #+64]
   1850              pObj->CursorPosByte  = 0;
   1851              pObj->HBorder        = 1;
   \   000000F0   0190A0E3           MOV      R9,#+1
   \   000000F4   8400C8E5           STRB     R0,[R8, #+132]
   \   000000F8   B665C8E1           STRH     R6,[R8, #+86]
   \   000000FC   B865C8E1           STRH     R6,[R8, #+88]
   \   00000100   8790C8E5           STRB     R9,[R8, #+135]
   1852              pObj->MaxNumChars    = 0;
   \   00000104   B864C8E1           STRH     R6,[R8, #+72]
   1853              pObj->NumCharsPrompt = 0;
   \   00000108   BC64C8E1           STRH     R6,[R8, #+76]
   1854              pObj->BufferSize     = 0;
   \   0000010C   B265C8E1           STRH     R6,[R8, #+82]
   1855              pObj->hText          = 0;
   \   00000110   446088E5           STR      R6,[R8, #+68]
   1856              GUI_UNLOCK_H(pObj);
   \   00000114   ........           BL       GUI_ALLOC_UnlockH
   1857              if (BufferSize > 0) {
   \   00000118   010054E3           CMP      R4,#+1
   \   0000011C   080000BA           BLT      ??MULTIEDIT_CreateEx_3
   1858                WM_HWIN hText;
   1859                hText = GUI_ALLOC_AllocZero(BufferSize);
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   ........           BL       GUI_ALLOC_AllocZero
   \   00000128   00A0B0E1           MOVS     R10,R0
   1860                if (hText != 0) {
   \   0000012C   0700A0E1           MOV      R0,R7
   \   00000130   1F00000A           BEQ      ??MULTIEDIT_CreateEx_4
   1861                  pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000134   ........           BL       GUI_ALLOC_LockH
   1862                  pObj->BufferSize = BufferSize;
   \   00000138   B245C0E1           STRH     R4,[R0, #+82]
   1863                  pObj->hText      = hText;
   \   0000013C   44A080E5           STR      R10,[R0, #+68]
   1864                  GUI_UNLOCK_H(pObj);
   \   00000140   ........           BL       GUI_ALLOC_UnlockH
   \                     ??MULTIEDIT_CreateEx_3:
   \   00000144   ........           BL       GUI_Lock
   \   00000148   0510A0E1           MOV      R1,R5
   \   0000014C   0700A0E1           MOV      R0,R7
   \   00000150   ........           BL       _SetText
   \   00000154   ........           BL       GUI_Unlock
   1865                } else {
   1866                  GUI_DEBUG_ERROROUT("MULTIEDIT_CreateEx failed to alloc buffer");
   1867                  WM_DeleteWindow(hObj);
   1868                  hObj = 0;
   1869                }
   1870              }
   1871              MULTIEDIT_SetText(hObj, pText);
   1872              _ManageScrollers(hObj);
   \                     ??MULTIEDIT_CreateEx_5:
   \   00000158   0700A0E1           MOV      R0,R7
   \   0000015C   ........           BL       _ManageAutoScrollV
   \   00000160   0700A0E1           MOV      R0,R7
   \   00000164   ........           BL       GUI_ALLOC_LockH
   \   00000168   0040A0E1           MOV      R4,R0
   \   0000016C   8400D4E5           LDRB     R0,[R4, #+132]
   \   00000170   100010E3           TST      R0,#0x10
   \   00000174   1A00000A           BEQ      ??MULTIEDIT_CreateEx_6
   \   00000178   0D10A0E1           MOV      R1,SP
   \   0000017C   0700A0E1           MOV      R0,R7
   \   00000180   ........           BL       WM_GetInsideRectExScrollbar
   \   00000184   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000188   F010DDE1           LDRSH    R1,[SP, #+0]
   \   0000018C   010040E0           SUB      R0,R0,R1
   \   00000190   8710D4E5           LDRB     R1,[R4, #+135]
   \   00000194   810040E0           SUB      R0,R0,R1, LSL #+1
   \   00000198   015040E2           SUB      R5,R0,#+1
   \   0000019C   0410A0E1           MOV      R1,R4
   \   000001A0   0700A0E1           MOV      R0,R7
   \   000001A4   ........           BL       _GetTextSizeX
   \   000001A8   000055E1           CMP      R5,R0
   \   000001AC   0160A0B3           MOVLT    R6,#+1
   \   000001B0   020000EA           B        ??MULTIEDIT_CreateEx_7
   \                     ??MULTIEDIT_CreateEx_4:
   \   000001B4   ........           BL       WM_DeleteWindow
   \   000001B8   0070A0E3           MOV      R7,#+0
   \   000001BC   E5FFFFEA           B        ??MULTIEDIT_CreateEx_5
   \                     ??MULTIEDIT_CreateEx_7:
   \   000001C0   ........           BL       GUI_ALLOC_UnlockH
   \   000001C4   0610A0E1           MOV      R1,R6
   \   000001C8   0700A0E1           MOV      R0,R7
   \   000001CC   ........           BL       WM_SetScrollbarH
   \   000001D0   060050E1           CMP      R0,R6
   \   000001D4   0300000A           BEQ      ??MULTIEDIT_CreateEx_8
   \   000001D8   0700A0E1           MOV      R0,R7
   \   000001DC   ........           BL       _ManageAutoScrollV
   \   000001E0   000000EA           B        ??MULTIEDIT_CreateEx_8
   \                     ??MULTIEDIT_CreateEx_6:
   \   000001E4   ........           BL       GUI_ALLOC_UnlockH
   \                     ??MULTIEDIT_CreateEx_8:
   \   000001E8   0700A0E1           MOV      R0,R7
   \   000001EC   ........           BL       _CalcScrollParas
   1873            } else {
   1874              GUI_DEBUG_ERROROUT_IF(hObj == 0, "MULTIEDIT_CreateEx failed")
   1875            }
   1876            WM_UNLOCK();
   \                     ??MULTIEDIT_CreateEx_1:
   \   000001F0   ........           BL       GUI_Unlock
   1877            return hObj;
   \   000001F4   0700A0E1           MOV      R0,R7
   \   000001F8   14D08DE2           ADD      SP,SP,#+20
   \   000001FC   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1878          }
   1879          
   1880          /*********************************************************************
   1881          *
   1882          *       Exported routines:  Various methods
   1883          *
   1884          **********************************************************************
   1885          */
   1886          /*********************************************************************
   1887          *
   1888          *       MULTIEDIT_AddKey
   1889          */

   \                                 In section .text, align 4, keep-with-next
   1890          int MULTIEDIT_AddKey(MULTIEDIT_HANDLE hObj, U16 Key) {
   \                     MULTIEDIT_AddKey:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1891            int r = 0;
   \   0000000C   0060A0E3           MOV      R6,#+0
   1892            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0500000A           BEQ      ??MULTIEDIT_AddKey_0
   1893              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
   1894              r = _AddKey(hObj, Key);
   \   0000001C   0510A0E1           MOV      R1,R5
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       _AddKey
   \   00000028   0060A0E1           MOV      R6,R0
   1895              WM_UNLOCK();
   \   0000002C   ........           BL       GUI_Unlock
   1896            }
   1897            return r;
   \                     ??MULTIEDIT_AddKey_0:
   \   00000030   0600A0E1           MOV      R0,R6
   \   00000034   7080BDE8           POP      {R4-R6,PC}       ;; return
   1898          }
   1899          
   1900          /*********************************************************************
   1901          *
   1902          *       MULTIEDIT_AddText
   1903          */

   \                                 In section .text, align 4, keep-with-next
   1904          int MULTIEDIT_AddText(MULTIEDIT_HANDLE hObj, const char * s) {
   \                     MULTIEDIT_AddText:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1905            int Result;
   1906            Result = 1;
   1907            if (hObj && s) {
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   14D04DE2           SUB      SP,SP,#+20
   \   00000014   01A0A0E3           MOV      R10,#+1
   \   00000018   00005513           CMPNE    R5,#+0
   \   0000001C   9900000A           BEQ      ??MULTIEDIT_AddText_0
   1908              MULTIEDIT_OBJ * pObj;
   1909              WM_HMEM hText;
   1910              U16 MaxNumChars;
   1911              WM_LOCK();
   \   00000020   ........           BL       GUI_Lock
   1912              pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       GUI_ALLOC_LockH
   1913              hText = pObj->hText;
   \   0000002C   446090E5           LDR      R6,[R0, #+68]
   1914              MaxNumChars = pObj->MaxNumChars;
   \   00000030   B894D0E1           LDRH     R9,[R0, #+72]
   1915              GUI_UNLOCK_H(pObj);
   \   00000034   ........           BL       GUI_ALLOC_UnlockH
   1916              if (!hText) {
   \   00000038   000056E3           CMP      R6,#+0
   \   0000003C   0300001A           BNE      ??MULTIEDIT_AddText_1
   1917                _SetText(hObj, s);
   \   00000040   0510A0E1           MOV      R1,R5
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       _SetText
   \   0000004C   8C0000EA           B        ??MULTIEDIT_AddText_2
   1918              } else {
   1919                char * pText;
   1920                int NumCharsNew, NumCharsOld, NumBytesNew, NumBytesOld;
   1921                pText = (char *)GUI_LOCK_H(hText);
   \                     ??MULTIEDIT_AddText_1:
   \   00000050   0600A0E1           MOV      R0,R6
   \   00000054   ........           BL       GUI_ALLOC_LockH
   \   00000058   0060A0E1           MOV      R6,R0
   1922                NumCharsOld = GUI__GetNumChars(pText);
   \   0000005C   ........           BL       GUI__GetNumChars
   \   00000060   00B0A0E1           MOV      R11,R0
   1923                NumBytesOld = GUI_UC__NumChars2NumBytes(pText, NumCharsOld);
   \   00000064   0B10A0E1           MOV      R1,R11
   \   00000068   0600A0E1           MOV      R0,R6
   \   0000006C   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000070   0070A0E1           MOV      R7,R0
   1924                NumCharsNew = GUI__GetNumChars(s);
   \   00000074   0500A0E1           MOV      R0,R5
   \   00000078   ........           BL       GUI__GetNumChars
   \   0000007C   0080A0E1           MOV      R8,R0
   1925                if (MaxNumChars > 0) {
   \   00000080   010059E3           CMP      R9,#+1
   \   00000084   020000BA           BLT      ??MULTIEDIT_AddText_3
   1926                  if ((NumCharsOld + NumCharsNew) > MaxNumChars) {
   \   00000088   0B0088E0           ADD      R0,R8,R11
   \   0000008C   000059E1           CMP      R9,R0
   1927                    NumCharsNew = MaxNumChars - NumCharsOld;
   \   00000090   0B8049B0           SUBLT    R8,R9,R11
   1928                  }
   1929                }
   1930                GUI_UNLOCK_H(pText);
   \                     ??MULTIEDIT_AddText_3:
   \   00000094   ........           BL       GUI_ALLOC_UnlockH
   1931                if (NumCharsNew > 0) {
   \   00000098   010058E3           CMP      R8,#+1
   \   0000009C   780000BA           BLT      ??MULTIEDIT_AddText_2
   1932                  NumBytesNew = GUI_UC__NumChars2NumBytes(s, NumCharsNew);
   \   000000A0   0810A0E1           MOV      R1,R8
   \   000000A4   0500A0E1           MOV      R0,R5
   \   000000A8   ........           BL       GUI_UC__NumChars2NumBytes
   \   000000AC   0090A0E1           MOV      R9,R0
   1933                  if (_IsSpaceInBuffer(hObj, NumBytesNew)) {
   \   000000B0   0910A0E1           MOV      R1,R9
   \   000000B4   0400A0E1           MOV      R0,R4
   \   000000B8   ........           BL       _IsSpaceInBuffer
   \   000000BC   000050E3           CMP      R0,#+0
   \   000000C0   6F00000A           BEQ      ??MULTIEDIT_AddText_2
   1934                    U16 CursorPosChar;
   1935                    pObj = MULTIEDIT_LOCK_H(hObj);
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   ........           BL       GUI_ALLOC_LockH
   \   000000CC   00A0A0E1           MOV      R10,R0
   1936                    CursorPosChar = pObj->CursorPosChar;
   \   000000D0   B6B5DAE1           LDRH     R11,[R10, #+86]
   1937                    pText = (char *)GUI_LOCK_H(pObj->hText);
   \   000000D4   44009AE5           LDR      R0,[R10, #+68]
   \   000000D8   ........           BL       GUI_ALLOC_LockH
   \   000000DC   0060A0E1           MOV      R6,R0
   \   000000E0   B805DAE1           LDRH     R0,[R10, #+88]
   \   000000E4   061080E0           ADD      R1,R0,R6
   \   000000E8   002047E0           SUB      R2,R7,R0
   \   000000EC   010089E0           ADD      R0,R9,R1
   \   000000F0   ........           BL       __aeabi_memmove
   1938                    memmove(pText + pObj->CursorPosByte + NumBytesNew,
   1939                            pText + pObj->CursorPosByte,
   1940                            NumBytesOld - pObj->CursorPosByte);
   1941                    GUI_MEMCPY(pText + pObj->CursorPosByte, s, NumBytesNew);
   \   000000F4   B805DAE1           LDRH     R0,[R10, #+88]
   \   000000F8   0920A0E1           MOV      R2,R9
   \   000000FC   0510A0E1           MOV      R1,R5
   \   00000100   060080E0           ADD      R0,R0,R6
   \   00000104   ........           BL       __aeabi_memcpy
   1942                    *(pText + NumBytesOld + NumBytesNew) = 0;
   \   00000108   0050A0E3           MOV      R5,#+0
   \   0000010C   060087E0           ADD      R0,R7,R6
   \   00000110   0050C9E7           STRB     R5,[R9, +R0]
   1943                    GUI_UNLOCK_H(pText);
   \   00000114   ........           BL       GUI_ALLOC_UnlockH
   1944                    pObj->NumChars += NumCharsNew;
   \   00000118   BA04DAE1           LDRH     R0,[R10, #+74]
   \   0000011C   000088E0           ADD      R0,R8,R0
   \   00000120   BA04CAE1           STRH     R0,[R10, #+74]
   1945                    GUI_UNLOCK_H(pObj);
   \   00000124   ........           BL       GUI_ALLOC_UnlockH
   1946                    _SetCursorPos(hObj, CursorPosChar + NumCharsNew);
   \   00000128   0400A0E1           MOV      R0,R4
   \   0000012C   ........           BL       GUI_ALLOC_LockH
   \   00000130   0060A0E1           MOV      R6,R0
   \   00000134   04008DE2           ADD      R0,SP,#+4
   \   00000138   00008DE5           STR      R0,[SP, #+0]
   \   0000013C   08308DE2           ADD      R3,SP,#+8
   \   00000140   0B2088E0           ADD      R2,R8,R11
   \   00000144   0610A0E1           MOV      R1,R6
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   ........           BL       _CalcNextValidCursorPos
   \   00000150   B615D6E1           LDRH     R1,[R6, #+86]
   \   00000154   000051E1           CMP      R1,R0
   \   00000158   0100001A           BNE      ??MULTIEDIT_AddText_4
   \   0000015C   ........           BL       GUI_ALLOC_UnlockH
   \   00000160   0A0000EA           B        ??MULTIEDIT_AddText_5
   \                     ??MULTIEDIT_AddText_4:
   \   00000164   08109DE5           LDR      R1,[SP, #+8]
   \   00000168   B815C6E1           STRH     R1,[R6, #+88]
   \   0000016C   B605C6E1           STRH     R0,[R6, #+86]
   \   00000170   04009DE5           LDR      R0,[SP, #+4]
   \   00000174   B405C6E1           STRH     R0,[R6, #+84]
   \   00000178   8500D6E5           LDRB     R0,[R6, #+133]
   \   0000017C   080080E3           ORR      R0,R0,#0x8
   \   00000180   8500C6E5           STRB     R0,[R6, #+133]
   \   00000184   ........           BL       GUI_ALLOC_UnlockH
   \   00000188   0400A0E1           MOV      R0,R4
   \   0000018C   ........           BL       _CalcScrollPos
   1947                    pObj = MULTIEDIT_LOCK_H(hObj);
   \                     ??MULTIEDIT_AddText_5:
   \   00000190   0400A0E1           MOV      R0,R4
   \   00000194   ........           BL       GUI_ALLOC_LockH
   1948                    _InvalidateNumLines(pObj);
   1949                    _InvalidateTextSizeX(pObj);
   \   00000198   8510D0E5           LDRB     R1,[R0, #+133]
   \   0000019C   061081E3           ORR      R1,R1,#0x6
   \   000001A0   8510C0E5           STRB     R1,[R0, #+133]
   1950                    GUI_UNLOCK_H(pObj);
   \   000001A4   ........           BL       GUI_ALLOC_UnlockH
   1951                    _InvalidateTextArea(hObj);
   \   000001A8   0400A0E1           MOV      R0,R4
   \   000001AC   ........           BL       _ManageAutoScrollV
   \   000001B0   0400A0E1           MOV      R0,R4
   \   000001B4   ........           BL       GUI_ALLOC_LockH
   \   000001B8   0060A0E1           MOV      R6,R0
   \   000001BC   8400D6E5           LDRB     R0,[R6, #+132]
   \   000001C0   100010E3           TST      R0,#0x10
   \   000001C4   1700000A           BEQ      ??MULTIEDIT_AddText_6
   \   000001C8   0D10A0E1           MOV      R1,SP
   \   000001CC   0400A0E1           MOV      R0,R4
   \   000001D0   ........           BL       WM_GetInsideRectExScrollbar
   \   000001D4   F400DDE1           LDRSH    R0,[SP, #+4]
   \   000001D8   F010DDE1           LDRSH    R1,[SP, #+0]
   \   000001DC   010040E0           SUB      R0,R0,R1
   \   000001E0   8710D6E5           LDRB     R1,[R6, #+135]
   \   000001E4   810040E0           SUB      R0,R0,R1, LSL #+1
   \   000001E8   017040E2           SUB      R7,R0,#+1
   \   000001EC   0610A0E1           MOV      R1,R6
   \   000001F0   0400A0E1           MOV      R0,R4
   \   000001F4   ........           BL       _GetTextSizeX
   \   000001F8   000057E1           CMP      R7,R0
   \   000001FC   0060A0A3           MOVGE    R6,#+0
   \   00000200   0160A0B3           MOVLT    R6,#+1
   \   00000204   ........           BL       GUI_ALLOC_UnlockH
   \   00000208   0610A0E1           MOV      R1,R6
   \   0000020C   0400A0E1           MOV      R0,R4
   \   00000210   ........           BL       WM_SetScrollbarH
   \   00000214   060050E1           CMP      R0,R6
   \   00000218   0300000A           BEQ      ??MULTIEDIT_AddText_7
   \   0000021C   0400A0E1           MOV      R0,R4
   \   00000220   ........           BL       _ManageAutoScrollV
   \   00000224   000000EA           B        ??MULTIEDIT_AddText_7
   \                     ??MULTIEDIT_AddText_6:
   \   00000228   ........           BL       GUI_ALLOC_UnlockH
   \                     ??MULTIEDIT_AddText_7:
   \   0000022C   0400A0E1           MOV      R0,R4
   \   00000230   ........           BL       _CalcScrollParas
   \   00000234   08108DE2           ADD      R1,SP,#+8
   \   00000238   0400A0E1           MOV      R0,R4
   \   0000023C   ........           BL       WM_GetInsideRectExScrollbar
   \   00000240   08108DE2           ADD      R1,SP,#+8
   \   00000244   0400A0E1           MOV      R0,R4
   \   00000248   ........           BL       WM_InvalidateRect
   1952                    pObj = MULTIEDIT_LOCK_H(hObj);
   \   0000024C   0400A0E1           MOV      R0,R4
   \   00000250   ........           BL       GUI_ALLOC_LockH
   1953                    _InvalidateCursorXY(pObj);
   \   00000254   8510D0E5           LDRB     R1,[R0, #+133]
   \   00000258   081081E3           ORR      R1,R1,#0x8
   \   0000025C   8510C0E5           STRB     R1,[R0, #+133]
   1954                    _ClearCache(pObj);
   \   00000260   B056C0E1           STRH     R5,[R0, #+96]
   \   00000264   BE55C0E1           STRH     R5,[R0, #+94]
   \   00000268   B456C0E1           STRH     R5,[R0, #+100]
   \   0000026C   B256C0E1           STRH     R5,[R0, #+98]
   1955                    GUI_UNLOCK_H(pObj);
   \   00000270   ........           BL       GUI_ALLOC_UnlockH
   1956                    WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
   \   00000274   0510A0E3           MOV      R1,#+5
   \   00000278   0400A0E1           MOV      R0,R4
   \   0000027C   ........           BL       WM_NotifyParent
   1957                    Result = 0;
   \   00000280   00A0A0E3           MOV      R10,#+0
   1958                  }
   1959                }
   1960              }
   1961              WM_UNLOCK();
   \                     ??MULTIEDIT_AddText_2:
   \   00000284   ........           BL       GUI_Unlock
   1962            }
   1963            return Result;
   \                     ??MULTIEDIT_AddText_0:
   \   00000288   0A00A0E1           MOV      R0,R10
   \   0000028C   14D08DE2           ADD      SP,SP,#+20
   \   00000290   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1964          }
   1965          
   1966          /*********************************************************************
   1967          *
   1968          *       MULTIEDIT_SetText
   1969          */

   \                                 In section .text, align 4, keep-with-next
   1970          void MULTIEDIT_SetText(MULTIEDIT_HANDLE hObj, const char * pNew) {
   \                     MULTIEDIT_SetText:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
   1971            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0400000A           BEQ      ??MULTIEDIT_SetText_0
   1972              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
   1973              _SetText(hObj, pNew);
   \   0000001C   0510A0E1           MOV      R1,R5
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       _SetText
   1974              WM_UNLOCK();
   \   00000028   ........           BL       GUI_Unlock
   1975            }
   1976          }
   \                     ??MULTIEDIT_SetText_0:
   \   0000002C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000030   3080BDE8           POP      {R4,R5,PC}       ;; return
   1977          
   1978          /*********************************************************************
   1979          *
   1980          *       MULTIEDIT_GetText
   1981          */

   \                                 In section .text, align 4, keep-with-next
   1982          void MULTIEDIT_GetText(MULTIEDIT_HANDLE hObj, char * sDest, int MaxLen) {
   \                     MULTIEDIT_GetText:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0260A0E1           MOV      R6,R2
   1983            if (hObj) {
   \   00000014   000055E3           CMP      R5,#+0
   \   00000018   1800000A           BEQ      ??MULTIEDIT_GetText_0
   1984              MULTIEDIT_OBJ * pObj;
   1985              char * pText;
   1986              int Len;
   1987              WM_LOCK();
   \   0000001C   ........           BL       GUI_Lock
   1988              pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000020   0500A0E1           MOV      R0,R5
   \   00000024   ........           BL       GUI_ALLOC_LockH
   \   00000028   0050A0E1           MOV      R5,R0
   1989              pText  = (char *)GUI_LOCK_H(pObj->hText);
   \   0000002C   440095E5           LDR      R0,[R5, #+68]
   \   00000030   ........           BL       GUI_ALLOC_LockH
   \   00000034   0070A0E1           MOV      R7,R0
   1990              pText += GUI_UC__NumChars2NumBytes(pText, pObj->NumCharsPrompt);
   \   00000038   BC14D5E1           LDRH     R1,[R5, #+76]
   \   0000003C   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000040   075080E0           ADD      R5,R0,R7
   1991              Len    = strlen(pText);
   \   00000044   0500A0E1           MOV      R0,R5
   \   00000048   ........           BL       strlen
   \   0000004C   0070A0E1           MOV      R7,R0
   1992              if (Len > (MaxLen - 1)) {
   \   00000050   010046E2           SUB      R0,R6,#+1
   \   00000054   070050E1           CMP      R0,R7
   1993                Len = MaxLen - 1;
   \   00000058   0070A0B1           MOVLT    R7,R0
   1994              }
   1995              GUI_MEMCPY(sDest, pText, Len);
   \   0000005C   0720A0E1           MOV      R2,R7
   \   00000060   0510A0E1           MOV      R1,R5
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           BL       __aeabi_memcpy
   1996              *(sDest + Len) = 0;
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   0400C7E7           STRB     R0,[R7, +R4]
   1997              GUI_UNLOCK_H(pObj);
   \   00000074   ........           BL       GUI_ALLOC_UnlockH
   1998              GUI_UNLOCK_H(pText);
   \   00000078   ........           BL       GUI_ALLOC_UnlockH
   1999              WM_UNLOCK();
   \   0000007C   ........           BL       GUI_Unlock
   2000            }
   2001          }
   \                     ??MULTIEDIT_GetText_0:
   \   00000080   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000084   F080BDE8           POP      {R4-R7,PC}       ;; return
   2002          
   2003          /*********************************************************************
   2004          *
   2005          *       MULTIEDIT_GetPrompt
   2006          */

   \                                 In section .text, align 4, keep-with-next
   2007          void MULTIEDIT_GetPrompt(MULTIEDIT_HANDLE hObj, char * sDest, int MaxLen) {
   \                     MULTIEDIT_GetPrompt:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   2008            if (hObj) {
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   1500000A           BEQ      ??MULTIEDIT_GetPrompt_0
   2009              char * sSource;
   2010              int Len;
   2011              MULTIEDIT_OBJ * pObj;
   2012              WM_LOCK();
   \   0000001C   ........           BL       GUI_Lock
   2013              pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       GUI_ALLOC_LockH
   \   00000028   0040A0E1           MOV      R4,R0
   2014              sSource = (char *)GUI_LOCK_H(pObj->hText);
   \   0000002C   440094E5           LDR      R0,[R4, #+68]
   \   00000030   ........           BL       GUI_ALLOC_LockH
   \   00000034   0070A0E1           MOV      R7,R0
   2015              Len = GUI_UC__NumChars2NumBytes(sSource, pObj->NumCharsPrompt);
   \   00000038   BC14D4E1           LDRH     R1,[R4, #+76]
   \   0000003C   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000040   0040A0E1           MOV      R4,R0
   2016              if (Len > (MaxLen - 1)) {
   \   00000044   010046E2           SUB      R0,R6,#+1
   \   00000048   040050E1           CMP      R0,R4
   2017                Len = MaxLen - 1;
   \   0000004C   0040A0B1           MOVLT    R4,R0
   2018              }
   2019              GUI_MEMCPY(sDest, sSource, Len);
   \   00000050   0420A0E1           MOV      R2,R4
   \   00000054   0710A0E1           MOV      R1,R7
   \   00000058   0500A0E1           MOV      R0,R5
   \   0000005C   ........           BL       __aeabi_memcpy
   2020              *(sDest + Len) = 0;
   \   00000060   0000A0E3           MOV      R0,#+0
   \   00000064   0500C4E7           STRB     R0,[R4, +R5]
   2021              GUI_UNLOCK_H(pObj);
   \   00000068   ........           BL       GUI_ALLOC_UnlockH
   2022              GUI_UNLOCK_H(sSource);
   \   0000006C   ........           BL       GUI_ALLOC_UnlockH
   2023              WM_UNLOCK();
   \   00000070   ........           BL       GUI_Unlock
   2024            }
   2025          }
   \                     ??MULTIEDIT_GetPrompt_0:
   \   00000074   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000078   F080BDE8           POP      {R4-R7,PC}       ;; return
   2026          
   2027          /*********************************************************************
   2028          *
   2029          *       MULTIEDIT_SetWrapWord
   2030          */

   \                                 In section .text, align 4, keep-with-next
   2031          void MULTIEDIT_SetWrapWord(MULTIEDIT_HANDLE hObj) {
   2032            _SetWrapMode(hObj, GUI_WRAPMODE_WORD);
   \                     MULTIEDIT_SetWrapWord:
   \   00000000   0110A0E3           MOV      R1,#+1
   \   00000004   ........           B        _SetWrapMode     ;; tailcall
   2033          }
   2034          
   2035          /*********************************************************************
   2036          *
   2037          *       MULTIEDIT_SetWrapChar
   2038          */

   \                                 In section .text, align 4, keep-with-next
   2039          void MULTIEDIT_SetWrapChar(MULTIEDIT_HANDLE hObj) {
   2040            _SetWrapMode(hObj, GUI_WRAPMODE_CHAR);
   \                     MULTIEDIT_SetWrapChar:
   \   00000000   0210A0E3           MOV      R1,#+2
   \   00000004   ........           B        _SetWrapMode     ;; tailcall
   2041          }
   2042          
   2043          /*********************************************************************
   2044          *
   2045          *       MULTIEDIT_SetWrapNone
   2046          */

   \                                 In section .text, align 4, keep-with-next
   2047          void MULTIEDIT_SetWrapNone(MULTIEDIT_HANDLE hObj) {
   2048            _SetWrapMode(hObj, GUI_WRAPMODE_NONE);
   \                     MULTIEDIT_SetWrapNone:
   \   00000000   0010A0E3           MOV      R1,#+0
   \   00000004   ........           B        _SetWrapMode     ;; tailcall
   2049          }
   2050          
   2051          /*********************************************************************
   2052          *
   2053          *       MULTIEDIT_SetInsertMode
   2054          */

   \                                 In section .text, align 4, keep-with-next
   2055          void MULTIEDIT_SetInsertMode(MULTIEDIT_HANDLE hObj, int OnOff) {
   2056            _SetFlag(hObj, OnOff, MULTIEDIT_SF_INSERT);
   \                     MULTIEDIT_SetInsertMode:
   \   00000000   0420A0E3           MOV      R2,#+4
   \   00000004   ........           B        _SetFlag         ;; tailcall
   2057          }
   2058          
   2059          /*********************************************************************
   2060          *
   2061          *       MULTIEDIT_SetReadOnly
   2062          */

   \                                 In section .text, align 4, keep-with-next
   2063          void MULTIEDIT_SetReadOnly(MULTIEDIT_HANDLE hObj, int OnOff) {
   2064            _SetFlag(hObj, OnOff, MULTIEDIT_SF_READONLY);
   \                     MULTIEDIT_SetReadOnly:
   \   00000000   0120A0E3           MOV      R2,#+1
   \   00000004   ........           B        _SetFlag         ;; tailcall
   2065          }
   2066          
   2067          /*********************************************************************
   2068          *
   2069          *       MULTIEDIT_SetPasswordMode
   2070          */

   \                                 In section .text, align 4, keep-with-next
   2071          void MULTIEDIT_SetPasswordMode(MULTIEDIT_HANDLE hObj, int OnOff) {
   \                     MULTIEDIT_SetPasswordMode:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
   2072            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0B00000A           BEQ      ??MULTIEDIT_SetPasswordMode_0
   2073              MULTIEDIT_OBJ * pObj;
   2074              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
   2075              _SetFlag(hObj, OnOff, MULTIEDIT_SF_PASSWORD);
   \   0000001C   2020A0E3           MOV      R2,#+32
   \   00000020   0510A0E1           MOV      R1,R5
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       _SetFlag
   2076              pObj = MULTIEDIT_LOCK_H(hObj);
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       GUI_ALLOC_LockH
   2077              _InvalidateCursorXY(pObj);
   2078              _InvalidateNumLines(pObj);
   2079              _InvalidateTextSizeX(pObj);
   \   00000034   8510D0E5           LDRB     R1,[R0, #+133]
   \   00000038   0E1081E3           ORR      R1,R1,#0xE
   \   0000003C   8510C0E5           STRB     R1,[R0, #+133]
   2080              GUI_UNLOCK_H(pObj);
   \   00000040   ........           BL       GUI_ALLOC_UnlockH
   2081              WM_UNLOCK();
   \   00000044   ........           BL       GUI_Unlock
   2082            }
   2083          }
   \                     ??MULTIEDIT_SetPasswordMode_0:
   \   00000048   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000004C   3080BDE8           POP      {R4,R5,PC}       ;; return
   2084          
   2085          /*********************************************************************
   2086          *
   2087          *       MULTIEDIT_SetAutoScrollV
   2088          */

   \                                 In section .text, align 4, keep-with-next
   2089          void MULTIEDIT_SetAutoScrollV(MULTIEDIT_HANDLE hObj, int OnOff) {
   2090            _SetFlag(hObj, OnOff, MULTIEDIT_SF_AUTOSCROLLBAR_V);
   \                     MULTIEDIT_SetAutoScrollV:
   \   00000000   0820A0E3           MOV      R2,#+8
   \   00000004   ........           B        _SetFlag         ;; tailcall
   2091          }
   2092          
   2093          /*********************************************************************
   2094          *
   2095          *       MULTIEDIT_SetAutoScrollH
   2096          */

   \                                 In section .text, align 4, keep-with-next
   2097          void MULTIEDIT_SetAutoScrollH(MULTIEDIT_HANDLE hObj, int OnOff) {
   2098            _SetFlag(hObj, OnOff, MULTIEDIT_SF_AUTOSCROLLBAR_H);
   \                     MULTIEDIT_SetAutoScrollH:
   \   00000000   1020A0E3           MOV      R2,#+16
   \   00000004   ........           B        _SetFlag         ;; tailcall
   2099          }
   2100          
   2101          /*********************************************************************
   2102          *
   2103          *       MULTIEDIT_SetHBorder
   2104          */

   \                                 In section .text, align 4, keep-with-next
   2105          void MULTIEDIT_SetHBorder(MULTIEDIT_HANDLE hObj, unsigned HBorder) {
   \                     MULTIEDIT_SetHBorder:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   0160A0E1           MOV      R6,R1
   2106            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   2F00000A           BEQ      ??MULTIEDIT_SetHBorder_0
   2107              MULTIEDIT_OBJ * pObj;
   2108              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
   2109              pObj = MULTIEDIT_LOCK_H(hObj);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
   2110              if ((unsigned)pObj->HBorder != HBorder) {
   \   00000024   8710D0E5           LDRB     R1,[R0, #+135]
   \   00000028   0050A0E3           MOV      R5,#+0
   \   0000002C   060051E1           CMP      R1,R6
   \   00000030   2600000A           BEQ      ??MULTIEDIT_SetHBorder_1
   2111                pObj->HBorder = HBorder;
   \   00000034   8760C0E5           STRB     R6,[R0, #+135]
   2112                GUI_UNLOCK_H(pObj);
   \   00000038   ........           BL       GUI_ALLOC_UnlockH
   2113                _Invalidate(hObj);
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       _ManageAutoScrollV
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       GUI_ALLOC_LockH
   \   0000004C   0060A0E1           MOV      R6,R0
   \   00000050   8400D6E5           LDRB     R0,[R6, #+132]
   \   00000054   100010E3           TST      R0,#0x10
   \   00000058   1600000A           BEQ      ??MULTIEDIT_SetHBorder_2
   \   0000005C   0D10A0E1           MOV      R1,SP
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       WM_GetInsideRectExScrollbar
   \   00000068   F400DDE1           LDRSH    R0,[SP, #+4]
   \   0000006C   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000070   010040E0           SUB      R0,R0,R1
   \   00000074   8710D6E5           LDRB     R1,[R6, #+135]
   \   00000078   810040E0           SUB      R0,R0,R1, LSL #+1
   \   0000007C   017040E2           SUB      R7,R0,#+1
   \   00000080   0610A0E1           MOV      R1,R6
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   ........           BL       _GetTextSizeX
   \   0000008C   000057E1           CMP      R7,R0
   \   00000090   0150A0B3           MOVLT    R5,#+1
   \   00000094   ........           BL       GUI_ALLOC_UnlockH
   \   00000098   0510A0E1           MOV      R1,R5
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   ........           BL       WM_SetScrollbarH
   \   000000A4   050050E1           CMP      R0,R5
   \   000000A8   0300000A           BEQ      ??MULTIEDIT_SetHBorder_3
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   ........           BL       _ManageAutoScrollV
   \   000000B4   000000EA           B        ??MULTIEDIT_SetHBorder_3
   \                     ??MULTIEDIT_SetHBorder_2:
   \   000000B8   ........           BL       GUI_ALLOC_UnlockH
   \                     ??MULTIEDIT_SetHBorder_3:
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   ........           BL       _CalcScrollParas
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   ........           BL       WM_InvalidateWindow
   2114              } else {
   \   000000CC   000000EA           B        ??MULTIEDIT_SetHBorder_4
   2115                GUI_UNLOCK_H(pObj);
   \                     ??MULTIEDIT_SetHBorder_1:
   \   000000D0   ........           BL       GUI_ALLOC_UnlockH
   2116              }
   2117              WM_UNLOCK();
   \                     ??MULTIEDIT_SetHBorder_4:
   \   000000D4   ........           BL       GUI_Unlock
   2118            }
   2119          }
   \                     ??MULTIEDIT_SetHBorder_0:
   \   000000D8   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   000000DC   F080BDE8           POP      {R4-R7,PC}       ;; return
   2120          
   2121          /*********************************************************************
   2122          *
   2123          *       MULTIEDIT_SetFont
   2124          */

   \                                 In section .text, align 4, keep-with-next
   2125          void MULTIEDIT_SetFont(MULTIEDIT_HANDLE hObj, const GUI_FONT GUI_UNI_PTR * pFont) {
   \                     MULTIEDIT_SetFont:
   \   00000000   D0402DE9           PUSH     {R4,R6,R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   10D04DE2           SUB      SP,SP,#+16
   \   0000000C   0160A0E1           MOV      R6,R1
   2126            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   3700000A           BEQ      ??MULTIEDIT_SetFont_0
   2127              MULTIEDIT_OBJ * pObj;
   2128              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
   2129              pObj = MULTIEDIT_LOCK_H(hObj);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
   2130              if (pObj->pFont != pFont) {
   \   00000024   801090E5           LDR      R1,[R0, #+128]
   \   00000028   060051E1           CMP      R1,R6
   \   0000002C   2F00000A           BEQ      ??MULTIEDIT_SetFont_1
   2131                pObj->pFont = pFont;
   \   00000030   806080E5           STR      R6,[R0, #+128]
   2132                GUI_UNLOCK_H(pObj);
   \   00000034   ........           BL       GUI_ALLOC_UnlockH
   2133                _InvalidateTextArea(hObj);
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   ........           BL       _ManageAutoScrollV
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   ........           BL       GUI_ALLOC_LockH
   \   00000048   0060A0E1           MOV      R6,R0
   \   0000004C   8400D6E5           LDRB     R0,[R6, #+132]
   \   00000050   100010E3           TST      R0,#0x10
   \   00000054   1700000A           BEQ      ??MULTIEDIT_SetFont_2
   \   00000058   0D10A0E1           MOV      R1,SP
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           BL       WM_GetInsideRectExScrollbar
   \   00000064   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000068   F010DDE1           LDRSH    R1,[SP, #+0]
   \   0000006C   010040E0           SUB      R0,R0,R1
   \   00000070   8710D6E5           LDRB     R1,[R6, #+135]
   \   00000074   810040E0           SUB      R0,R0,R1, LSL #+1
   \   00000078   017040E2           SUB      R7,R0,#+1
   \   0000007C   0610A0E1           MOV      R1,R6
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   ........           BL       _GetTextSizeX
   \   00000088   000057E1           CMP      R7,R0
   \   0000008C   0060A0A3           MOVGE    R6,#+0
   \   00000090   0160A0B3           MOVLT    R6,#+1
   \   00000094   ........           BL       GUI_ALLOC_UnlockH
   \   00000098   0610A0E1           MOV      R1,R6
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   ........           BL       WM_SetScrollbarH
   \   000000A4   060050E1           CMP      R0,R6
   \   000000A8   0300000A           BEQ      ??MULTIEDIT_SetFont_3
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   ........           BL       _ManageAutoScrollV
   \   000000B4   000000EA           B        ??MULTIEDIT_SetFont_3
   \                     ??MULTIEDIT_SetFont_2:
   \   000000B8   ........           BL       GUI_ALLOC_UnlockH
   \                     ??MULTIEDIT_SetFont_3:
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   ........           BL       _CalcScrollParas
   \   000000C4   08108DE2           ADD      R1,SP,#+8
   \   000000C8   0400A0E1           MOV      R0,R4
   \   000000CC   ........           BL       WM_GetInsideRectExScrollbar
   \   000000D0   08108DE2           ADD      R1,SP,#+8
   \   000000D4   0400A0E1           MOV      R0,R4
   \   000000D8   ........           BL       WM_InvalidateRect
   2134                pObj = MULTIEDIT_LOCK_H(hObj);
   \   000000DC   0400A0E1           MOV      R0,R4
   \   000000E0   ........           BL       GUI_ALLOC_LockH
   2135                _InvalidateCursorXY(pObj);
   2136                _InvalidateNumLines(pObj);
   2137                _InvalidateTextSizeX(pObj);
   \   000000E4   8510D0E5           LDRB     R1,[R0, #+133]
   \   000000E8   0E1081E3           ORR      R1,R1,#0xE
   \   000000EC   8510C0E5           STRB     R1,[R0, #+133]
   2138              }
   2139              GUI_UNLOCK_H(pObj);
   \                     ??MULTIEDIT_SetFont_1:
   \   000000F0   ........           BL       GUI_ALLOC_UnlockH
   2140              WM_UNLOCK();
   \   000000F4   ........           BL       GUI_Unlock
   2141            }
   2142          }
   \                     ??MULTIEDIT_SetFont_0:
   \   000000F8   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   000000FC   D080BDE8           POP      {R4,R6,R7,PC}    ;; return
   2143          
   2144          /*********************************************************************
   2145          *
   2146          *       MULTIEDIT_SetBkColor
   2147          */

   \                                 In section .text, align 4, keep-with-next
   2148          void MULTIEDIT_SetBkColor(MULTIEDIT_HANDLE hObj, unsigned Index, GUI_COLOR color) {
   \                     MULTIEDIT_SetBkColor:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   10D04DE2           SUB      SP,SP,#+16
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   2149            if (hObj && (Index < NUM_DISP_MODES)) {
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   3100000A           BEQ      ??MULTIEDIT_SetBkColor_0
   \   0000001C   020055E3           CMP      R5,#+2
   \   00000020   2F00002A           BCS      ??MULTIEDIT_SetBkColor_0
   2150              MULTIEDIT_OBJ * pObj;
   2151              WM_LOCK();
   \   00000024   ........           BL       GUI_Lock
   2152              pObj = MULTIEDIT_LOCK_H(hObj);
   2153              pObj->aBkColor[Index] = color;
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       GUI_ALLOC_LockH
   \   00000030   050180E0           ADD      R0,R0,R5, LSL #+2
   \   00000034   346080E5           STR      R6,[R0, #+52]
   2154              GUI_UNLOCK_H(pObj);
   \   00000038   ........           BL       GUI_ALLOC_UnlockH
   2155              _InvalidateTextArea(hObj);
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       _ManageAutoScrollV
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       GUI_ALLOC_LockH
   \   0000004C   0050A0E1           MOV      R5,R0
   \   00000050   8400D5E5           LDRB     R0,[R5, #+132]
   \   00000054   100010E3           TST      R0,#0x10
   \   00000058   1700000A           BEQ      ??MULTIEDIT_SetBkColor_1
   \   0000005C   0D10A0E1           MOV      R1,SP
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       WM_GetInsideRectExScrollbar
   \   00000068   F400DDE1           LDRSH    R0,[SP, #+4]
   \   0000006C   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000070   010040E0           SUB      R0,R0,R1
   \   00000074   8710D5E5           LDRB     R1,[R5, #+135]
   \   00000078   810040E0           SUB      R0,R0,R1, LSL #+1
   \   0000007C   016040E2           SUB      R6,R0,#+1
   \   00000080   0510A0E1           MOV      R1,R5
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   ........           BL       _GetTextSizeX
   \   0000008C   000056E1           CMP      R6,R0
   \   00000090   0050A0A3           MOVGE    R5,#+0
   \   00000094   0150A0B3           MOVLT    R5,#+1
   \   00000098   ........           BL       GUI_ALLOC_UnlockH
   \   0000009C   0510A0E1           MOV      R1,R5
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   ........           BL       WM_SetScrollbarH
   \   000000A8   050050E1           CMP      R0,R5
   \   000000AC   0300000A           BEQ      ??MULTIEDIT_SetBkColor_2
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   ........           BL       _ManageAutoScrollV
   \   000000B8   000000EA           B        ??MULTIEDIT_SetBkColor_2
   \                     ??MULTIEDIT_SetBkColor_1:
   \   000000BC   ........           BL       GUI_ALLOC_UnlockH
   \                     ??MULTIEDIT_SetBkColor_2:
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   ........           BL       _CalcScrollParas
   \   000000C8   08108DE2           ADD      R1,SP,#+8
   \   000000CC   0400A0E1           MOV      R0,R4
   \   000000D0   ........           BL       WM_GetInsideRectExScrollbar
   \   000000D4   08108DE2           ADD      R1,SP,#+8
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   ........           BL       WM_InvalidateRect
   2156              WM_UNLOCK();
   \   000000E0   ........           BL       GUI_Unlock
   2157            }
   2158          }
   \                     ??MULTIEDIT_SetBkColor_0:
   \   000000E4   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   000000E8   7080BDE8           POP      {R4-R6,PC}       ;; return
   2159          
   2160          /*********************************************************************
   2161          *
   2162          *       MULTIEDIT_SetCursorOffset
   2163          */

   \                                 In section .text, align 4, keep-with-next
   2164          void MULTIEDIT_SetCursorOffset(MULTIEDIT_HANDLE hObj, int Offset) {
   \                     MULTIEDIT_SetCursorOffset:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   10D04DE2           SUB      SP,SP,#+16
   \   0000000C   0160A0E1           MOV      R6,R1
   2165            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   1D00000A           BEQ      ??MULTIEDIT_SetCursorOffset_0
   2166              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
   2167              _SetCursorPos(hObj, Offset);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
   \   00000024   0050A0E1           MOV      R5,R0
   \   00000028   04008DE2           ADD      R0,SP,#+4
   \   0000002C   00008DE5           STR      R0,[SP, #+0]
   \   00000030   08308DE2           ADD      R3,SP,#+8
   \   00000034   0620A0E1           MOV      R2,R6
   \   00000038   0510A0E1           MOV      R1,R5
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       _CalcNextValidCursorPos
   \   00000044   B615D5E1           LDRH     R1,[R5, #+86]
   \   00000048   000051E1           CMP      R1,R0
   \   0000004C   0100001A           BNE      ??MULTIEDIT_SetCursorOffset_1
   \   00000050   ........           BL       GUI_ALLOC_UnlockH
   \   00000054   0A0000EA           B        ??MULTIEDIT_SetCursorOffset_2
   \                     ??MULTIEDIT_SetCursorOffset_1:
   \   00000058   08109DE5           LDR      R1,[SP, #+8]
   \   0000005C   B815C5E1           STRH     R1,[R5, #+88]
   \   00000060   B605C5E1           STRH     R0,[R5, #+86]
   \   00000064   04009DE5           LDR      R0,[SP, #+4]
   \   00000068   B405C5E1           STRH     R0,[R5, #+84]
   \   0000006C   8500D5E5           LDRB     R0,[R5, #+133]
   \   00000070   080080E3           ORR      R0,R0,#0x8
   \   00000074   8500C5E5           STRB     R0,[R5, #+133]
   \   00000078   ........           BL       GUI_ALLOC_UnlockH
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   ........           BL       _CalcScrollPos
   2168              WM_Invalidate(hObj);
   \                     ??MULTIEDIT_SetCursorOffset_2:
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   ........           BL       WM_InvalidateWindow
   2169              WM_UNLOCK();
   \   0000008C   ........           BL       GUI_Unlock
   2170            }
   2171          }
   \                     ??MULTIEDIT_SetCursorOffset_0:
   \   00000090   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   00000094   7080BDE8           POP      {R4-R6,PC}       ;; return
   2172          
   2173          /*********************************************************************
   2174          *
   2175          *       MULTIEDIT_SetTextColor
   2176          */

   \                                 In section .text, align 4, keep-with-next
   2177          void MULTIEDIT_SetTextColor(MULTIEDIT_HANDLE hObj, unsigned Index, GUI_COLOR color) {
   \                     MULTIEDIT_SetTextColor:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   2178            if (hObj && (Index < NUM_DISP_MODES)) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0A00000A           BEQ      ??MULTIEDIT_SetTextColor_0
   \   00000018   020055E3           CMP      R5,#+2
   \   0000001C   0800002A           BCS      ??MULTIEDIT_SetTextColor_0
   2179              MULTIEDIT_OBJ * pObj;
   2180              WM_LOCK();
   \   00000020   ........           BL       GUI_Lock
   2181              pObj = MULTIEDIT_LOCK_H(hObj);
   2182              pObj->aColor[Index] = color;
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       GUI_ALLOC_LockH
   \   0000002C   050180E0           ADD      R0,R0,R5, LSL #+2
   \   00000030   3C6080E5           STR      R6,[R0, #+60]
   2183              GUI_UNLOCK_H(pObj);
   \   00000034   ........           BL       GUI_ALLOC_UnlockH
   2184              WM_Invalidate(hObj);
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   ........           BL       WM_InvalidateWindow
   2185              WM_UNLOCK();
   \   00000040   ........           BL       GUI_Unlock
   2186            }
   2187          }
   \                     ??MULTIEDIT_SetTextColor_0:
   \   00000044   7080BDE8           POP      {R4-R6,PC}       ;; return
   2188          
   2189          /*********************************************************************
   2190          *
   2191          *       MULTIEDIT_SetPrompt
   2192          */

   \                                 In section .text, align 4, keep-with-next
   2193          void MULTIEDIT_SetPrompt(MULTIEDIT_HANDLE hObj, const char * pPrompt) {
   \                     MULTIEDIT_SetPrompt:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   14D04DE2           SUB      SP,SP,#+20
   \   0000000C   0150A0E1           MOV      R5,R1
   2194            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   9F00000A           BEQ      ??MULTIEDIT_SetPrompt_0
   2195              MULTIEDIT_OBJ * pObj;
   2196              int NumCharsNew = 0, NumCharsOld = 0;
   \   00000018   0070A0E3           MOV      R7,#+0
   \   0000001C   00A0A0E3           MOV      R10,#+0
   2197              int NumBytesNew = 0, NumBytesOld = 0;
   \   00000020   0080A0E3           MOV      R8,#+0
   \   00000024   0060A0E3           MOV      R6,#+0
   2198              char * pText;
   2199              WM_LOCK();
   \   00000028   ........           BL       GUI_Lock
   2200              pObj = MULTIEDIT_LOCK_H(hObj);
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       GUI_ALLOC_LockH
   \   00000034   0090A0E1           MOV      R9,R0
   2201              if (pObj->hText) {
   \   00000038   440099E5           LDR      R0,[R9, #+68]
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0500000A           BEQ      ??MULTIEDIT_SetPrompt_1
   2202                pText = (char *)GUI_LOCK_H(pObj->hText);
   \   00000044   ........           BL       GUI_ALLOC_LockH
   2203                NumCharsOld = pObj->NumCharsPrompt;
   \   00000048   BCA4D9E1           LDRH     R10,[R9, #+76]
   2204                NumBytesOld = GUI_UC__NumChars2NumBytes(pText, NumCharsOld);
   \   0000004C   0A10A0E1           MOV      R1,R10
   \   00000050   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000054   0060A0E1           MOV      R6,R0
   2205                GUI_UNLOCK_H(pText);
   \   00000058   ........           BL       GUI_ALLOC_UnlockH
   2206              }
   2207              GUI_UNLOCK_H(pObj);
   \                     ??MULTIEDIT_SetPrompt_1:
   \   0000005C   ........           BL       GUI_ALLOC_UnlockH
   2208              if (pPrompt) {
   \   00000060   000055E3           CMP      R5,#+0
   \   00000064   0600000A           BEQ      ??MULTIEDIT_SetPrompt_2
   2209                NumCharsNew = GUI__GetNumChars(pPrompt);
   \   00000068   0500A0E1           MOV      R0,R5
   \   0000006C   ........           BL       GUI__GetNumChars
   \   00000070   0070A0E1           MOV      R7,R0
   2210                NumBytesNew = GUI_UC__NumChars2NumBytes(pPrompt, NumCharsNew);
   \   00000074   0710A0E1           MOV      R1,R7
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000080   0080A0E1           MOV      R8,R0
   2211              }
   2212              if (_IsCharsAvailable(hObj, NumCharsNew - NumCharsOld)) {
   \                     ??MULTIEDIT_SetPrompt_2:
   \   00000084   0A9047E0           SUB      R9,R7,R10
   \   00000088   01A0A0E3           MOV      R10,#+1
   \   0000008C   0400A0E1           MOV      R0,R4
   \   00000090   ........           BL       GUI_ALLOC_LockH
   \   00000094   00B0A0E1           MOV      R11,R0
   \   00000098   010059E3           CMP      R9,#+1
   \   0000009C   150000BA           BLT      ??MULTIEDIT_SetPrompt_3
   \   000000A0   B804DBE1           LDRH     R0,[R11, #+72]
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   1200000A           BEQ      ??MULTIEDIT_SetPrompt_3
   \   000000AC   44009BE5           LDR      R0,[R11, #+68]
   \   000000B0   0010A0E3           MOV      R1,#+0
   \   000000B4   000050E3           CMP      R0,#+0
   \   000000B8   0A00000A           BEQ      ??MULTIEDIT_SetPrompt_4
   \   000000BC   8510DBE5           LDRB     R1,[R11, #+133]
   \   000000C0   010011E3           TST      R1,#0x1
   \   000000C4   0600000A           BEQ      ??MULTIEDIT_SetPrompt_5
   \   000000C8   ........           BL       GUI_ALLOC_LockH
   \   000000CC   ........           BL       GUI__GetNumChars
   \   000000D0   BA04CBE1           STRH     R0,[R11, #+74]
   \   000000D4   ........           BL       GUI_ALLOC_UnlockH
   \   000000D8   8500DBE5           LDRB     R0,[R11, #+133]
   \   000000DC   FE0000E2           AND      R0,R0,#0xFE
   \   000000E0   8500CBE5           STRB     R0,[R11, #+133]
   \                     ??MULTIEDIT_SetPrompt_5:
   \   000000E4   BA14DBE1           LDRH     R1,[R11, #+74]
   \                     ??MULTIEDIT_SetPrompt_4:
   \   000000E8   B804DBE1           LDRH     R0,[R11, #+72]
   \   000000EC   091081E0           ADD      R1,R1,R9
   \   000000F0   010050E1           CMP      R0,R1
   \   000000F4   00A0A0B3           MOVLT    R10,#+0
   \                     ??MULTIEDIT_SetPrompt_3:
   \   000000F8   ........           BL       GUI_ALLOC_UnlockH
   \   000000FC   00005AE3           CMP      R10,#+0
   \   00000100   6300000A           BEQ      ??MULTIEDIT_SetPrompt_6
   2213                if (_IsSpaceInBuffer(hObj, NumBytesNew - NumBytesOld)) {
   \   00000104   061048E0           SUB      R1,R8,R6
   \   00000108   0400A0E1           MOV      R0,R4
   \   0000010C   ........           BL       _IsSpaceInBuffer
   \   00000110   000050E3           CMP      R0,#+0
   \   00000114   5E00000A           BEQ      ??MULTIEDIT_SetPrompt_6
   2214                  pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000118   0400A0E1           MOV      R0,R4
   \   0000011C   ........           BL       GUI_ALLOC_LockH
   \   00000120   0090A0E1           MOV      R9,R0
   2215                  pText = (char *)GUI_LOCK_H(pObj->hText);
   \   00000124   440099E5           LDR      R0,[R9, #+68]
   \   00000128   ........           BL       GUI_ALLOC_LockH
   \   0000012C   00A0A0E1           MOV      R10,R0
   2216                  memmove(pText + NumBytesNew, pText + NumBytesOld, strlen(pText + NumBytesOld) + 1);
   \   00000130   0A0086E0           ADD      R0,R6,R10
   \   00000134   ........           BL       strlen
   \   00000138   012080E2           ADD      R2,R0,#+1
   \   0000013C   0A1086E0           ADD      R1,R6,R10
   \   00000140   0A0088E0           ADD      R0,R8,R10
   \   00000144   ........           BL       __aeabi_memmove
   2217                  if (pPrompt) {
   \   00000148   000055E3           CMP      R5,#+0
   \   0000014C   0300000A           BEQ      ??MULTIEDIT_SetPrompt_7
   2218                    GUI_MEMCPY(pText, pPrompt, NumBytesNew);
   \   00000150   0820A0E1           MOV      R2,R8
   \   00000154   0510A0E1           MOV      R1,R5
   \   00000158   0A00A0E1           MOV      R0,R10
   \   0000015C   ........           BL       __aeabi_memcpy
   2219                  }
   2220                  pObj->NumCharsPrompt = NumCharsNew;
   \                     ??MULTIEDIT_SetPrompt_7:
   \   00000160   BC74C9E1           STRH     R7,[R9, #+76]
   2221                  GUI_UNLOCK_H(pText);
   \   00000164   ........           BL       GUI_ALLOC_UnlockH
   2222                  GUI_UNLOCK_H(pObj);
   \   00000168   ........           BL       GUI_ALLOC_UnlockH
   2223                  _SetCursorPos(hObj, NumCharsNew);
   \   0000016C   0400A0E1           MOV      R0,R4
   \   00000170   ........           BL       GUI_ALLOC_LockH
   \   00000174   0050A0E1           MOV      R5,R0
   \   00000178   04008DE2           ADD      R0,SP,#+4
   \   0000017C   00008DE5           STR      R0,[SP, #+0]
   \   00000180   08308DE2           ADD      R3,SP,#+8
   \   00000184   0720A0E1           MOV      R2,R7
   \   00000188   0510A0E1           MOV      R1,R5
   \   0000018C   0400A0E1           MOV      R0,R4
   \   00000190   ........           BL       _CalcNextValidCursorPos
   \   00000194   B615D5E1           LDRH     R1,[R5, #+86]
   \   00000198   000051E1           CMP      R1,R0
   \   0000019C   0100001A           BNE      ??MULTIEDIT_SetPrompt_8
   \   000001A0   ........           BL       GUI_ALLOC_UnlockH
   \   000001A4   0A0000EA           B        ??MULTIEDIT_SetPrompt_9
   \                     ??MULTIEDIT_SetPrompt_8:
   \   000001A8   08109DE5           LDR      R1,[SP, #+8]
   \   000001AC   B815C5E1           STRH     R1,[R5, #+88]
   \   000001B0   B605C5E1           STRH     R0,[R5, #+86]
   \   000001B4   04009DE5           LDR      R0,[SP, #+4]
   \   000001B8   B405C5E1           STRH     R0,[R5, #+84]
   \   000001BC   8500D5E5           LDRB     R0,[R5, #+133]
   \   000001C0   080080E3           ORR      R0,R0,#0x8
   \   000001C4   8500C5E5           STRB     R0,[R5, #+133]
   \   000001C8   ........           BL       GUI_ALLOC_UnlockH
   \   000001CC   0400A0E1           MOV      R0,R4
   \   000001D0   ........           BL       _CalcScrollPos
   2224                  _InvalidateTextArea(hObj);
   \                     ??MULTIEDIT_SetPrompt_9:
   \   000001D4   0400A0E1           MOV      R0,R4
   \   000001D8   ........           BL       _ManageAutoScrollV
   \   000001DC   0400A0E1           MOV      R0,R4
   \   000001E0   ........           BL       GUI_ALLOC_LockH
   \   000001E4   0050A0E1           MOV      R5,R0
   \   000001E8   8400D5E5           LDRB     R0,[R5, #+132]
   \   000001EC   100010E3           TST      R0,#0x10
   \   000001F0   1700000A           BEQ      ??MULTIEDIT_SetPrompt_10
   \   000001F4   0D10A0E1           MOV      R1,SP
   \   000001F8   0400A0E1           MOV      R0,R4
   \   000001FC   ........           BL       WM_GetInsideRectExScrollbar
   \   00000200   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000204   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000208   010040E0           SUB      R0,R0,R1
   \   0000020C   8710D5E5           LDRB     R1,[R5, #+135]
   \   00000210   810040E0           SUB      R0,R0,R1, LSL #+1
   \   00000214   016040E2           SUB      R6,R0,#+1
   \   00000218   0510A0E1           MOV      R1,R5
   \   0000021C   0400A0E1           MOV      R0,R4
   \   00000220   ........           BL       _GetTextSizeX
   \   00000224   000056E1           CMP      R6,R0
   \   00000228   0050A0A3           MOVGE    R5,#+0
   \   0000022C   0150A0B3           MOVLT    R5,#+1
   \   00000230   ........           BL       GUI_ALLOC_UnlockH
   \   00000234   0510A0E1           MOV      R1,R5
   \   00000238   0400A0E1           MOV      R0,R4
   \   0000023C   ........           BL       WM_SetScrollbarH
   \   00000240   050050E1           CMP      R0,R5
   \   00000244   0300000A           BEQ      ??MULTIEDIT_SetPrompt_11
   \   00000248   0400A0E1           MOV      R0,R4
   \   0000024C   ........           BL       _ManageAutoScrollV
   \   00000250   000000EA           B        ??MULTIEDIT_SetPrompt_11
   \                     ??MULTIEDIT_SetPrompt_10:
   \   00000254   ........           BL       GUI_ALLOC_UnlockH
   \                     ??MULTIEDIT_SetPrompt_11:
   \   00000258   0400A0E1           MOV      R0,R4
   \   0000025C   ........           BL       _CalcScrollParas
   \   00000260   08108DE2           ADD      R1,SP,#+8
   \   00000264   0400A0E1           MOV      R0,R4
   \   00000268   ........           BL       WM_GetInsideRectExScrollbar
   \   0000026C   08108DE2           ADD      R1,SP,#+8
   \   00000270   0400A0E1           MOV      R0,R4
   \   00000274   ........           BL       WM_InvalidateRect
   2225                  pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000278   0400A0E1           MOV      R0,R4
   \   0000027C   ........           BL       GUI_ALLOC_LockH
   \   00000280   0090A0E1           MOV      R9,R0
   2226                  _InvalidateNumChars(pObj);
   2227                  _InvalidateNumLines(pObj);
   2228                  _InvalidateTextSizeX(pObj);
   \   00000284   8500D9E5           LDRB     R0,[R9, #+133]
   \   00000288   070080E3           ORR      R0,R0,#0x7
   \   0000028C   8500C9E5           STRB     R0,[R9, #+133]
   2229                  GUI_UNLOCK_H(pObj);
   \   00000290   ........           BL       GUI_ALLOC_UnlockH
   2230                }
   2231              }
   2232              WM_UNLOCK();
   \                     ??MULTIEDIT_SetPrompt_6:
   \   00000294   ........           BL       GUI_Unlock
   2233            }
   2234          }
   \                     ??MULTIEDIT_SetPrompt_0:
   \   00000298   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   0000029C   F08FBDE8           POP      {R4-R11,PC}      ;; return
   2235          
   2236          /*********************************************************************
   2237          *
   2238          *       MULTIEDIT_SetBufferSize
   2239          */

   \                                 In section .text, align 4, keep-with-next
   2240          void MULTIEDIT_SetBufferSize(MULTIEDIT_HANDLE hObj, int BufferSize) {
   \                     MULTIEDIT_SetBufferSize:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   14D04DE2           SUB      SP,SP,#+20
   \   0000000C   0150A0E1           MOV      R5,R1
   2241            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   5400000A           BEQ      ??MULTIEDIT_SetBufferSize_0
   2242              MULTIEDIT_OBJ * pObj;
   2243              WM_HMEM hText;
   2244              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
   2245              if ((hText = GUI_ALLOC_AllocZero(BufferSize)) == 0) {
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   ........           BL       GUI_ALLOC_AllocZero
   \   00000024   0060B0E1           MOVS     R6,R0
   \   00000028   4E00000A           BEQ      ??MULTIEDIT_SetBufferSize_1
   2246                GUI_DEBUG_ERROROUT("MULTIEDIT_SetBufferSize failed to alloc buffer");
   2247              } else {
   2248                pObj = MULTIEDIT_LOCK_H(hObj);
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       GUI_ALLOC_LockH
   \   00000034   0070A0E1           MOV      R7,R0
   2249                GUI_ALLOC_FreePtr(&pObj->hText);
   \   00000038   440087E2           ADD      R0,R7,#+68
   \   0000003C   ........           BL       GUI_ALLOC_FreePtr
   2250                pObj->hText          = hText;
   \   00000040   446087E5           STR      R6,[R7, #+68]
   2251                pObj->BufferSize     = BufferSize;
   \   00000044   B255C7E1           STRH     R5,[R7, #+82]
   2252                pObj->NumCharsPrompt = 0;
   \   00000048   0050A0E3           MOV      R5,#+0
   \   0000004C   BC54C7E1           STRH     R5,[R7, #+76]
   2253                _InvalidateNumChars(pObj);
   2254                _InvalidateCursorXY(pObj);
   2255                _InvalidateNumLines(pObj);
   2256                _InvalidateTextSizeX(pObj);
   \   00000050   8500D7E5           LDRB     R0,[R7, #+133]
   \   00000054   0F0080E3           ORR      R0,R0,#0xF
   \   00000058   8500C7E5           STRB     R0,[R7, #+133]
   2257                GUI_UNLOCK_H(pObj);
   \   0000005C   ........           BL       GUI_ALLOC_UnlockH
   2258                _SetCursorPos(hObj, 0);
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       GUI_ALLOC_LockH
   \   00000068   0060A0E1           MOV      R6,R0
   \   0000006C   04008DE2           ADD      R0,SP,#+4
   \   00000070   00008DE5           STR      R0,[SP, #+0]
   \   00000074   08308DE2           ADD      R3,SP,#+8
   \   00000078   0020A0E3           MOV      R2,#+0
   \   0000007C   0610A0E1           MOV      R1,R6
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   ........           BL       _CalcNextValidCursorPos
   \   00000088   B615D6E1           LDRH     R1,[R6, #+86]
   \   0000008C   000051E1           CMP      R1,R0
   \   00000090   0100001A           BNE      ??MULTIEDIT_SetBufferSize_2
   \   00000094   ........           BL       GUI_ALLOC_UnlockH
   \   00000098   0A0000EA           B        ??MULTIEDIT_SetBufferSize_3
   \                     ??MULTIEDIT_SetBufferSize_2:
   \   0000009C   08109DE5           LDR      R1,[SP, #+8]
   \   000000A0   B815C6E1           STRH     R1,[R6, #+88]
   \   000000A4   B605C6E1           STRH     R0,[R6, #+86]
   \   000000A8   04009DE5           LDR      R0,[SP, #+4]
   \   000000AC   B405C6E1           STRH     R0,[R6, #+84]
   \   000000B0   8500D6E5           LDRB     R0,[R6, #+133]
   \   000000B4   080080E3           ORR      R0,R0,#0x8
   \   000000B8   8500C6E5           STRB     R0,[R6, #+133]
   \   000000BC   ........           BL       GUI_ALLOC_UnlockH
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   ........           BL       _CalcScrollPos
   2259                _InvalidateTextArea(hObj);
   \                     ??MULTIEDIT_SetBufferSize_3:
   \   000000C8   0400A0E1           MOV      R0,R4
   \   000000CC   ........           BL       _ManageAutoScrollV
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   ........           BL       GUI_ALLOC_LockH
   \   000000D8   0060A0E1           MOV      R6,R0
   \   000000DC   8400D6E5           LDRB     R0,[R6, #+132]
   \   000000E0   100010E3           TST      R0,#0x10
   \   000000E4   1600000A           BEQ      ??MULTIEDIT_SetBufferSize_4
   \   000000E8   0D10A0E1           MOV      R1,SP
   \   000000EC   0400A0E1           MOV      R0,R4
   \   000000F0   ........           BL       WM_GetInsideRectExScrollbar
   \   000000F4   F400DDE1           LDRSH    R0,[SP, #+4]
   \   000000F8   F010DDE1           LDRSH    R1,[SP, #+0]
   \   000000FC   010040E0           SUB      R0,R0,R1
   \   00000100   8710D6E5           LDRB     R1,[R6, #+135]
   \   00000104   810040E0           SUB      R0,R0,R1, LSL #+1
   \   00000108   017040E2           SUB      R7,R0,#+1
   \   0000010C   0610A0E1           MOV      R1,R6
   \   00000110   0400A0E1           MOV      R0,R4
   \   00000114   ........           BL       _GetTextSizeX
   \   00000118   000057E1           CMP      R7,R0
   \   0000011C   0150A0B3           MOVLT    R5,#+1
   \   00000120   ........           BL       GUI_ALLOC_UnlockH
   \   00000124   0510A0E1           MOV      R1,R5
   \   00000128   0400A0E1           MOV      R0,R4
   \   0000012C   ........           BL       WM_SetScrollbarH
   \   00000130   050050E1           CMP      R0,R5
   \   00000134   0300000A           BEQ      ??MULTIEDIT_SetBufferSize_5
   \   00000138   0400A0E1           MOV      R0,R4
   \   0000013C   ........           BL       _ManageAutoScrollV
   \   00000140   000000EA           B        ??MULTIEDIT_SetBufferSize_5
   \                     ??MULTIEDIT_SetBufferSize_4:
   \   00000144   ........           BL       GUI_ALLOC_UnlockH
   \                     ??MULTIEDIT_SetBufferSize_5:
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   ........           BL       _CalcScrollParas
   \   00000150   08108DE2           ADD      R1,SP,#+8
   \   00000154   0400A0E1           MOV      R0,R4
   \   00000158   ........           BL       WM_GetInsideRectExScrollbar
   \   0000015C   08108DE2           ADD      R1,SP,#+8
   \   00000160   0400A0E1           MOV      R0,R4
   \   00000164   ........           BL       WM_InvalidateRect
   2260              }
   2261              WM_UNLOCK();
   \                     ??MULTIEDIT_SetBufferSize_1:
   \   00000168   ........           BL       GUI_Unlock
   2262            }
   2263          }
   \                     ??MULTIEDIT_SetBufferSize_0:
   \   0000016C   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000170   F080BDE8           POP      {R4-R7,PC}       ;; return
   2264          
   2265          /*********************************************************************
   2266          *
   2267          *       MULTIEDIT_SetMaxNumChars
   2268          */

   \                                 In section .text, align 4, keep-with-next
   2269          void MULTIEDIT_SetMaxNumChars(MULTIEDIT_HANDLE hObj, unsigned MaxNumChars) {
   \                     MULTIEDIT_SetMaxNumChars:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   10D04DE2           SUB      SP,SP,#+16
   \   0000000C   0150A0E1           MOV      R5,R1
   2270            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   6700000A           BEQ      ??MULTIEDIT_SetMaxNumChars_0
   2271              MULTIEDIT_OBJ * pObj;
   2272              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
   2273              pObj = MULTIEDIT_LOCK_H(hObj);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
   \   00000024   0060A0E1           MOV      R6,R0
   2274              pObj->MaxNumChars = MaxNumChars;
   \   00000028   B854C6E1           STRH     R5,[R6, #+72]
   2275              if (MaxNumChars < (unsigned)pObj->NumCharsPrompt) {
   \   0000002C   BC04D6E1           LDRH     R0,[R6, #+76]
   \   00000030   000055E1           CMP      R5,R0
   2276                pObj->NumCharsPrompt = MaxNumChars;
   \   00000034   BC54C631           STRHCC   R5,[R6, #+76]
   2277              }
   2278              if (pObj->hText && MaxNumChars) {
   \   00000038   440096E5           LDR      R0,[R6, #+68]
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   00005513           CMPNE    R5,#+0
   \   00000044   5900000A           BEQ      ??MULTIEDIT_SetMaxNumChars_1
   2279                char * pText;
   2280                int Offset, LenText;
   2281                unsigned NumCharsCur;
   2282                pText = (char *)GUI_LOCK_H(pObj->hText);
   \   00000048   ........           BL       GUI_ALLOC_LockH
   \   0000004C   0080A0E1           MOV      R8,R0
   2283                LenText = strlen(pText);
   \   00000050   ........           BL       strlen
   \   00000054   0010A0E1           MOV      R1,R0
   2284                NumCharsCur = GUI__GetLineNumChars(pText, LenText);
   2285                if (NumCharsCur > MaxNumChars) {
   \   00000058   0800A0E1           MOV      R0,R8
   \   0000005C   ........           BL       GUI__GetLineNumChars
   \   00000060   000055E1           CMP      R5,R0
   \   00000064   5000002A           BCS      ??MULTIEDIT_SetMaxNumChars_2
   2286                  Offset = GUI_UC__NumChars2NumBytes(pText, MaxNumChars);
   \   00000068   0510A0E1           MOV      R1,R5
   \   0000006C   0800A0E1           MOV      R0,R8
   \   00000070   ........           BL       GUI_UC__NumChars2NumBytes
   \   00000074   0070A0E1           MOV      R7,R0
   2287                  if (Offset < pObj->BufferSize) {
   \   00000078   B205D6E1           LDRH     R0,[R6, #+82]
   \   0000007C   000057E1           CMP      R7,R0
   \   00000080   490000AA           BGE      ??MULTIEDIT_SetMaxNumChars_2
   2288                    pText += Offset;
   2289                    *pText = 0;
   \   00000084   0050A0E3           MOV      R5,#+0
   \   00000088   0850C7E7           STRB     R5,[R7, +R8]
   2290                    _InvalidateNumChars(pObj);
   \   0000008C   8500D6E5           LDRB     R0,[R6, #+133]
   \   00000090   010080E3           ORR      R0,R0,#0x1
   \   00000094   8500C6E5           STRB     R0,[R6, #+133]
   2291                    GUI_UNLOCK_H(pText);
   \   00000098   ........           BL       GUI_ALLOC_UnlockH
   2292                    GUI_UNLOCK_H(pObj);
   \   0000009C   ........           BL       GUI_ALLOC_UnlockH
   2293                    _SetCursorPos(hObj, Offset);
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   ........           BL       GUI_ALLOC_LockH
   \   000000A8   0060A0E1           MOV      R6,R0
   \   000000AC   04008DE2           ADD      R0,SP,#+4
   \   000000B0   00008DE5           STR      R0,[SP, #+0]
   \   000000B4   08308DE2           ADD      R3,SP,#+8
   \   000000B8   0720A0E1           MOV      R2,R7
   \   000000BC   0610A0E1           MOV      R1,R6
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   ........           BL       _CalcNextValidCursorPos
   \   000000C8   B615D6E1           LDRH     R1,[R6, #+86]
   \   000000CC   000051E1           CMP      R1,R0
   \   000000D0   0100001A           BNE      ??MULTIEDIT_SetMaxNumChars_3
   \   000000D4   ........           BL       GUI_ALLOC_UnlockH
   \   000000D8   0A0000EA           B        ??MULTIEDIT_SetMaxNumChars_4
   \                     ??MULTIEDIT_SetMaxNumChars_3:
   \   000000DC   08109DE5           LDR      R1,[SP, #+8]
   \   000000E0   B815C6E1           STRH     R1,[R6, #+88]
   \   000000E4   B605C6E1           STRH     R0,[R6, #+86]
   \   000000E8   04009DE5           LDR      R0,[SP, #+4]
   \   000000EC   B405C6E1           STRH     R0,[R6, #+84]
   \   000000F0   8500D6E5           LDRB     R0,[R6, #+133]
   \   000000F4   080080E3           ORR      R0,R0,#0x8
   \   000000F8   8500C6E5           STRB     R0,[R6, #+133]
   \   000000FC   ........           BL       GUI_ALLOC_UnlockH
   \   00000100   0400A0E1           MOV      R0,R4
   \   00000104   ........           BL       _CalcScrollPos
   2294                    _InvalidateTextArea(hObj);
   \                     ??MULTIEDIT_SetMaxNumChars_4:
   \   00000108   0400A0E1           MOV      R0,R4
   \   0000010C   ........           BL       _ManageAutoScrollV
   \   00000110   0400A0E1           MOV      R0,R4
   \   00000114   ........           BL       GUI_ALLOC_LockH
   \   00000118   0060A0E1           MOV      R6,R0
   \   0000011C   8400D6E5           LDRB     R0,[R6, #+132]
   \   00000120   100010E3           TST      R0,#0x10
   \   00000124   1600000A           BEQ      ??MULTIEDIT_SetMaxNumChars_5
   \   00000128   0D10A0E1           MOV      R1,SP
   \   0000012C   0400A0E1           MOV      R0,R4
   \   00000130   ........           BL       WM_GetInsideRectExScrollbar
   \   00000134   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000138   F010DDE1           LDRSH    R1,[SP, #+0]
   \   0000013C   010040E0           SUB      R0,R0,R1
   \   00000140   8710D6E5           LDRB     R1,[R6, #+135]
   \   00000144   810040E0           SUB      R0,R0,R1, LSL #+1
   \   00000148   017040E2           SUB      R7,R0,#+1
   \   0000014C   0610A0E1           MOV      R1,R6
   \   00000150   0400A0E1           MOV      R0,R4
   \   00000154   ........           BL       _GetTextSizeX
   \   00000158   000057E1           CMP      R7,R0
   \   0000015C   0150A0B3           MOVLT    R5,#+1
   \   00000160   ........           BL       GUI_ALLOC_UnlockH
   \   00000164   0510A0E1           MOV      R1,R5
   \   00000168   0400A0E1           MOV      R0,R4
   \   0000016C   ........           BL       WM_SetScrollbarH
   \   00000170   050050E1           CMP      R0,R5
   \   00000174   0300000A           BEQ      ??MULTIEDIT_SetMaxNumChars_6
   \   00000178   0400A0E1           MOV      R0,R4
   \   0000017C   ........           BL       _ManageAutoScrollV
   \   00000180   000000EA           B        ??MULTIEDIT_SetMaxNumChars_6
   \                     ??MULTIEDIT_SetMaxNumChars_5:
   \   00000184   ........           BL       GUI_ALLOC_UnlockH
   \                     ??MULTIEDIT_SetMaxNumChars_6:
   \   00000188   0400A0E1           MOV      R0,R4
   \   0000018C   ........           BL       _CalcScrollParas
   \   00000190   08108DE2           ADD      R1,SP,#+8
   \   00000194   0400A0E1           MOV      R0,R4
   \   00000198   ........           BL       WM_GetInsideRectExScrollbar
   \   0000019C   08108DE2           ADD      R1,SP,#+8
   \   000001A0   0400A0E1           MOV      R0,R4
   \   000001A4   ........           BL       WM_InvalidateRect
   2295                  } else {
   \   000001A8   010000EA           B        ??MULTIEDIT_SetMaxNumChars_7
   2296                    GUI_UNLOCK_H(pText);
   \                     ??MULTIEDIT_SetMaxNumChars_2:
   \   000001AC   ........           BL       GUI_ALLOC_UnlockH
   2297                    GUI_UNLOCK_H(pObj);
   2298                  }
   2299                } else {
   2300                  GUI_UNLOCK_H(pText);
   2301                  GUI_UNLOCK_H(pObj);
   2302                }
   2303              } else {
   2304                GUI_UNLOCK_H(pObj);
   \                     ??MULTIEDIT_SetMaxNumChars_1:
   \   000001B0   ........           BL       GUI_ALLOC_UnlockH
   2305              }
   2306              WM_UNLOCK();
   \                     ??MULTIEDIT_SetMaxNumChars_7:
   \   000001B4   ........           BL       GUI_Unlock
   2307            }
   2308          }
   \                     ??MULTIEDIT_SetMaxNumChars_0:
   \   000001B8   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   000001BC   F081BDE8           POP      {R4-R8,PC}       ;; return
   2309          
   2310          /*********************************************************************
   2311          *
   2312          *       MULTIEDIT_GetTextSize
   2313          *
   2314          * Purpose:
   2315          *   Returns the number of bytes required to store the text.
   2316          *   It is typically used when allocating a buffer to pass to
   2317          *   MULTIEDIT_GetText().
   2318          */

   \                                 In section .text, align 4, keep-with-next
   2319          int MULTIEDIT_GetTextSize(MULTIEDIT_HANDLE hObj) {
   \                     MULTIEDIT_GetTextSize:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
   2320            int r = 0;
   \   0000000C   0050A0E3           MOV      R5,#+0
   2321            if (hObj) {
   \   00000010   1000000A           BEQ      ??MULTIEDIT_GetTextSize_0
   2322              MULTIEDIT_OBJ * pObj;
   2323              WM_LOCK();
   \   00000014   ........           BL       GUI_Lock
   2324              pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           BL       GUI_ALLOC_LockH
   \   00000020   0040A0E1           MOV      R4,R0
   2325              if (pObj->hText) {
   \   00000024   440094E5           LDR      R0,[R4, #+68]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0700000A           BEQ      ??MULTIEDIT_GetTextSize_1
   2326                const char * s;
   2327                s = (const char *)GUI_LOCK_H(pObj->hText);
   \   00000030   ........           BL       GUI_ALLOC_LockH
   \   00000034   0050A0E1           MOV      R5,R0
   2328                s += GUI_UC__NumChars2NumBytes(s, pObj->NumCharsPrompt);
   \   00000038   BC14D4E1           LDRH     R1,[R4, #+76]
   \   0000003C   ........           BL       GUI_UC__NumChars2NumBytes
   2329                r = 1 + strlen(s);
   \   00000040   050080E0           ADD      R0,R0,R5
   \   00000044   ........           BL       strlen
   \   00000048   015080E2           ADD      R5,R0,#+1
   2330                GUI_UNLOCK_H(s);
   \   0000004C   ........           BL       GUI_ALLOC_UnlockH
   2331              }
   2332              GUI_UNLOCK_H(pObj);
   \                     ??MULTIEDIT_GetTextSize_1:
   \   00000050   ........           BL       GUI_ALLOC_UnlockH
   2333              WM_UNLOCK();
   \   00000054   ........           BL       GUI_Unlock
   2334            }
   2335            return r;
   \                     ??MULTIEDIT_GetTextSize_0:
   \   00000058   0500A0E1           MOV      R0,R5
   \   0000005C   04D08DE2           ADD      SP,SP,#+4
   \   00000060   3080BDE8           POP      {R4,R5,PC}       ;; return
   2336          }
   2337          
   2338          
   2339          /*********************************************************************
   2340          *
   2341          *       MULTIEDIT_SetTextAlign
   2342          */

   \                                 In section .text, align 4, keep-with-next
   2343          void MULTIEDIT_SetTextAlign(MULTIEDIT_HANDLE hObj, int Align) {
   \                     MULTIEDIT_SetTextAlign:
   \   00000000   D0402DE9           PUSH     {R4,R6,R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   10D04DE2           SUB      SP,SP,#+16
   \   0000000C   0160A0E1           MOV      R6,R1
   2344            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   3800000A           BEQ      ??MULTIEDIT_SetTextAlign_0
   2345              MULTIEDIT_OBJ * pObj;
   2346              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
   2347              pObj = MULTIEDIT_LOCK_H(hObj);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
   2348              Align &= (GUI_TA_LEFT | GUI_TA_RIGHT);
   2349              if (pObj->Align != Align) {
   \   00000024   B616D0E1           LDRH     R1,[R0, #+102]
   \   00000028   016006E2           AND      R6,R6,#0x1
   \   0000002C   060051E1           CMP      R1,R6
   \   00000030   2F00000A           BEQ      ??MULTIEDIT_SetTextAlign_1
   2350                pObj->Align = Align;
   \   00000034   B666C0E1           STRH     R6,[R0, #+102]
   2351                GUI_UNLOCK_H(pObj);
   \   00000038   ........           BL       GUI_ALLOC_UnlockH
   2352                _InvalidateTextArea(hObj);
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       _ManageAutoScrollV
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       GUI_ALLOC_LockH
   \   0000004C   0060A0E1           MOV      R6,R0
   \   00000050   8400D6E5           LDRB     R0,[R6, #+132]
   \   00000054   100010E3           TST      R0,#0x10
   \   00000058   1700000A           BEQ      ??MULTIEDIT_SetTextAlign_2
   \   0000005C   0D10A0E1           MOV      R1,SP
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       WM_GetInsideRectExScrollbar
   \   00000068   F400DDE1           LDRSH    R0,[SP, #+4]
   \   0000006C   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000070   010040E0           SUB      R0,R0,R1
   \   00000074   8710D6E5           LDRB     R1,[R6, #+135]
   \   00000078   810040E0           SUB      R0,R0,R1, LSL #+1
   \   0000007C   017040E2           SUB      R7,R0,#+1
   \   00000080   0610A0E1           MOV      R1,R6
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   ........           BL       _GetTextSizeX
   \   0000008C   000057E1           CMP      R7,R0
   \   00000090   0060A0A3           MOVGE    R6,#+0
   \   00000094   0160A0B3           MOVLT    R6,#+1
   \   00000098   ........           BL       GUI_ALLOC_UnlockH
   \   0000009C   0610A0E1           MOV      R1,R6
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   ........           BL       WM_SetScrollbarH
   \   000000A8   060050E1           CMP      R0,R6
   \   000000AC   0300000A           BEQ      ??MULTIEDIT_SetTextAlign_3
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   ........           BL       _ManageAutoScrollV
   \   000000B8   000000EA           B        ??MULTIEDIT_SetTextAlign_3
   \                     ??MULTIEDIT_SetTextAlign_2:
   \   000000BC   ........           BL       GUI_ALLOC_UnlockH
   \                     ??MULTIEDIT_SetTextAlign_3:
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   ........           BL       _CalcScrollParas
   \   000000C8   08108DE2           ADD      R1,SP,#+8
   \   000000CC   0400A0E1           MOV      R0,R4
   \   000000D0   ........           BL       WM_GetInsideRectExScrollbar
   \   000000D4   08108DE2           ADD      R1,SP,#+8
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   ........           BL       WM_InvalidateRect
   2353                pObj = MULTIEDIT_LOCK_H(hObj);
   \   000000E0   0400A0E1           MOV      R0,R4
   \   000000E4   ........           BL       GUI_ALLOC_LockH
   2354                _InvalidateCursorXY(pObj);
   2355                _InvalidateTextSizeX(pObj);
   \   000000E8   8510D0E5           LDRB     R1,[R0, #+133]
   \   000000EC   0C1081E3           ORR      R1,R1,#0xC
   \   000000F0   8510C0E5           STRB     R1,[R0, #+133]
   2356              }
   2357              GUI_UNLOCK_H(pObj);
   \                     ??MULTIEDIT_SetTextAlign_1:
   \   000000F4   ........           BL       GUI_ALLOC_UnlockH
   2358              WM_UNLOCK();
   \   000000F8   ........           BL       GUI_Unlock
   2359            }
   2360          }
   \                     ??MULTIEDIT_SetTextAlign_0:
   \   000000FC   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   00000100   D080BDE8           POP      {R4,R6,R7,PC}    ;; return
   2361          
   2362          /*********************************************************************
   2363          *
   2364          *       MULTIEDIT_GetCursorCharPos
   2365          */

   \                                 In section .text, align 4, keep-with-next
   2366          int MULTIEDIT_GetCursorCharPos(MULTIEDIT_HANDLE hObj) {
   \                     MULTIEDIT_GetCursorCharPos:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
   2367            int r = 0;
   \   0000000C   0050A0E3           MOV      R5,#+0
   2368            if (hObj) {
   \   00000010   0500000A           BEQ      ??MULTIEDIT_GetCursorCharPos_0
   2369              MULTIEDIT_OBJ * pObj;
   2370              WM_LOCK();
   \   00000014   ........           BL       GUI_Lock
   2371              pObj = MULTIEDIT_LOCK_H(hObj);
   2372              r = pObj->CursorPosChar;
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           BL       GUI_ALLOC_LockH
   \   00000020   B655D0E1           LDRH     R5,[R0, #+86]
   2373              GUI_UNLOCK_H(pObj);
   \   00000024   ........           BL       GUI_ALLOC_UnlockH
   2374              WM_UNLOCK();
   \   00000028   ........           BL       GUI_Unlock
   2375            }
   2376            return r;
   \                     ??MULTIEDIT_GetCursorCharPos_0:
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   04D08DE2           ADD      SP,SP,#+4
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
   2377          }
   2378          
   2379          /*********************************************************************
   2380          *
   2381          *       MULTIEDIT_GetCursorPixelPos
   2382          */

   \                                 In section .text, align 4, keep-with-next
   2383          void MULTIEDIT_GetCursorPixelPos(MULTIEDIT_HANDLE hObj, int * pxPos, int * pyPos) {
   \                     MULTIEDIT_GetCursorPixelPos:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0090A0E1           MOV      R9,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   2384            if (hObj) {
   \   00000014   000059E3           CMP      R9,#+0
   \   00000018   1C00000A           BEQ      ??MULTIEDIT_GetCursorPixelPos_0
   2385              MULTIEDIT_OBJ * pObj;
   2386              int FontSizeY, EffectSize;
   2387              WM_LOCK();
   \   0000001C   ........           BL       GUI_Lock
   2388              pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000020   0900A0E1           MOV      R0,R9
   \   00000024   ........           BL       GUI_ALLOC_LockH
   \   00000028   0060A0E1           MOV      R6,R0
   2389              FontSizeY  = GUI_GetYSizeOfFont(pObj->pFont);
   \   0000002C   800096E5           LDR      R0,[R6, #+128]
   \   00000030   ........           BL       GUI_GetYSizeOfFont
   \   00000034   0070A0E1           MOV      R7,R0
   2390              EffectSize = pObj->Widget.pEffect->EffectSize;
   \   00000038   2C0096E5           LDR      R0,[R6, #+44]
   2391              _GetCursorXY(hObj, pObj, pxPos, pyPos);
   \   0000003C   0530A0E1           MOV      R3,R5
   \   00000040   008090E5           LDR      R8,[R0, #+0]
   \   00000044   0420A0E1           MOV      R2,R4
   \   00000048   0610A0E1           MOV      R1,R6
   \   0000004C   0900A0E1           MOV      R0,R9
   \   00000050   ........           BL       _GetCursorXY
   2392              *pxPos += EffectSize - pObj->ScrollStateH.v + pObj->HBorder;
   \   00000054   000094E5           LDR      R0,[R4, #+0]
   \   00000058   781096E5           LDR      R1,[R6, #+120]
   \   0000005C   000088E0           ADD      R0,R8,R0
   \   00000060   010040E0           SUB      R0,R0,R1
   \   00000064   8710D6E5           LDRB     R1,[R6, #+135]
   \   00000068   000081E0           ADD      R0,R1,R0
   \   0000006C   000084E5           STR      R0,[R4, #+0]
   2393              *pyPos += EffectSize - pObj->ScrollStateV.v * FontSizeY;
   \   00000070   6C1096E5           LDR      R1,[R6, #+108]
   \   00000074   000095E5           LDR      R0,[R5, #+0]
   \   00000078   970101E0           MUL      R1,R7,R1
   \   0000007C   000088E0           ADD      R0,R8,R0
   \   00000080   010040E0           SUB      R0,R0,R1
   \   00000084   000085E5           STR      R0,[R5, #+0]
   2394              GUI_UNLOCK_H(pObj);
   \   00000088   ........           BL       GUI_ALLOC_UnlockH
   2395              WM_UNLOCK();
   \   0000008C   ........           BL       GUI_Unlock
   2396            }
   2397          }
   \                     ??MULTIEDIT_GetCursorPixelPos_0:
   \   00000090   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000094   F083BDE8           POP      {R4-R9,PC}       ;; return
   2398          
   2399          /*********************************************************************
   2400          *
   2401          *       MULTIEDIT_EnableBlink
   2402          */

   \                                 In section .text, align 4, keep-with-next
   2403          void MULTIEDIT_EnableBlink(MULTIEDIT_HANDLE hObj, int Period, int OnOff) {
   \                     MULTIEDIT_EnableBlink:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   2404            if (hObj) {
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   1D00000A           BEQ      ??MULTIEDIT_EnableBlink_0
   2405              MULTIEDIT_OBJ * pObj;
   2406              WM_LOCK();
   \   0000001C   ........           BL       GUI_Lock
   2407              pObj = MULTIEDIT_LOCK_H(hObj);
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       GUI_ALLOC_LockH
   \   00000028   0070A0E1           MOV      R7,R0
   2408              if (OnOff) {
   \   0000002C   880097E5           LDR      R0,[R7, #+136]
   \   00000030   000056E3           CMP      R6,#+0
   \   00000034   0F00000A           BEQ      ??MULTIEDIT_EnableBlink_1
   2409                WM_HTIMER hTimer;
   2410                if (pObj->hTimer) {
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0200000A           BEQ      ??MULTIEDIT_EnableBlink_2
   2411                  WM_RestartTimer(pObj->hTimer, Period);
   \   00000040   0510A0E1           MOV      R1,R5
   \   00000044   ........           BL       WM_RestartTimer
   \   00000048   0F0000EA           B        ??MULTIEDIT_EnableBlink_3
   2412                } else {
   2413                  GUI_UNLOCK_H(pObj);
   \                     ??MULTIEDIT_EnableBlink_2:
   \   0000004C   ........           BL       GUI_ALLOC_UnlockH
   2414                  hTimer = WM_CreateTimer(hObj, 0, Period, 0);
   \   00000050   0030A0E3           MOV      R3,#+0
   \   00000054   0520A0E1           MOV      R2,R5
   \   00000058   0010A0E3           MOV      R1,#+0
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           BL       WM_CreateTimer
   \   00000064   0050A0E1           MOV      R5,R0
   2415                  pObj = MULTIEDIT_LOCK_H(hObj);
   2416                  pObj->hTimer = hTimer;
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   ........           BL       GUI_ALLOC_LockH
   \   00000070   885080E5           STR      R5,[R0, #+136]
   \   00000074   040000EA           B        ??MULTIEDIT_EnableBlink_3
   2417                }
   2418              } else {
   2419                WM_DeleteTimer(pObj->hTimer);
   \                     ??MULTIEDIT_EnableBlink_1:
   \   00000078   ........           BL       WM_DeleteTimer
   2420                pObj->hTimer = 0;
   \   0000007C   0000A0E3           MOV      R0,#+0
   \   00000080   880087E5           STR      R0,[R7, #+136]
   2421                WM_Invalidate(hObj);
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   ........           BL       WM_InvalidateWindow
   2422              }
   2423              GUI_UNLOCK_H(pObj);
   \                     ??MULTIEDIT_EnableBlink_3:
   \   0000008C   ........           BL       GUI_ALLOC_UnlockH
   2424              WM_UNLOCK();
   \   00000090   ........           BL       GUI_Unlock
   2425            }
   2426          }
   \                     ??MULTIEDIT_EnableBlink_0:
   \   00000094   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000098   F080BDE8           POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     GUI_pUC_API

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   ........           DC32     GUI__BIDI_Enabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   ........           DC32     _pfGUI__BIDI_GetLogChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   ........           DC32     _pfGUI__BIDI_GetCharDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     SCROLLBAR_Dec

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   ........           DC32     SCROLLBAR_Inc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   ........           DC32     GUI__BIDI_Enabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   ........           DC32     MULTIEDIT_Callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   ........           DC32     _aDefaultBkColor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   ........           DC32     GUI_Font13_1
   2427          
   2428          #else /* avoid empty object files */
   2429          
   2430          void MULTIEDIT_C(void);
   2431          void MULTIEDIT_C(void){}
   2432          
   2433          #endif  /* #if GUI_WINSUPPORT */

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     MULTIEDIT_AddKey                16
     MULTIEDIT_AddText               56
     MULTIEDIT_Callback              72
     MULTIEDIT_CreateEx              56
     MULTIEDIT_EnableBlink           24
     MULTIEDIT_GetCursorCharPos      16
     MULTIEDIT_GetCursorPixelPos     32
     MULTIEDIT_GetPrompt             24
     MULTIEDIT_GetText               24
     MULTIEDIT_GetTextSize           16
     MULTIEDIT_SetAutoScrollH         8
     MULTIEDIT_SetAutoScrollV         8
     MULTIEDIT_SetBkColor            32
     MULTIEDIT_SetBufferSize         40
     MULTIEDIT_SetCursorOffset       32
     MULTIEDIT_SetFont               40
     MULTIEDIT_SetHBorder            32
     MULTIEDIT_SetInsertMode          8
     MULTIEDIT_SetMaxNumChars        40
     MULTIEDIT_SetPasswordMode       16
     MULTIEDIT_SetPrompt             56
     MULTIEDIT_SetReadOnly            8
     MULTIEDIT_SetText               16
     MULTIEDIT_SetTextAlign          40
     MULTIEDIT_SetTextColor          16
     MULTIEDIT_SetWrapChar            8
     MULTIEDIT_SetWrapNone            8
     MULTIEDIT_SetWrapWord            8
     _AddKey                         72
     _CalcNextValidCursorPos         48
     _CalcScrollParas                32
     _CalcScrollPos                  56
     _DeleteChar                     32
     _DispString                     32
     _GetCursorSizeX                 24
     _GetCursorXY                    56
     _GetTextSizeX                   40
     _InsertChar                     32
     _InvertCursor                   40
     _IsOverwriteAtThisChar          48
     _IsSpaceInBuffer                24
     _MULTIEDIT_Paint                88
     _ManageAutoScrollV              40
     _OnTouch                        32
     _SetCursorXY                    48
     _SetFlag                        40
     _SetText                        48
     _SetWrapMode                    48
     _WrapGetNumBytesToNextLine      32
     _WrapGetNumCharsDisp            40


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     _aDefaultBkColor              16
     _aDefaultColor
     _pDefaultFont                  4
     _WrapGetNumCharsDisp         296
     _WrapGetNumBytesToNextLine   200
     _DispString                  216
     _GetCursorXY                 536
     _CalcScrollPos               236
     _GetTextSizeX                328
     _CalcScrollParas             292
     _ManageAutoScrollV           312
     _SetFlag                     240
     _CalcNextValidCursorPos      828
     _SetWrapMode                 412
     _SetCursorXY                 752
     _IsOverwriteAtThisChar       364
     _GetCursorSizeX              432
     _IsSpaceInBuffer             208
     _DeleteChar                  512
     _InsertChar                  308
     _InvertCursor                244
     _MULTIEDIT_Paint             640
     _OnTouch                     296
     _AddKey                     1988
     _SetText                     676
     MULTIEDIT_Callback           732
     MULTIEDIT_CreateEx           512
     MULTIEDIT_AddKey              56
     MULTIEDIT_AddText            660
     MULTIEDIT_SetText             52
     MULTIEDIT_GetText            136
     MULTIEDIT_GetPrompt          124
     MULTIEDIT_SetWrapWord          8
     MULTIEDIT_SetWrapChar          8
     MULTIEDIT_SetWrapNone          8
     MULTIEDIT_SetInsertMode        8
     MULTIEDIT_SetReadOnly          8
     MULTIEDIT_SetPasswordMode     80
     MULTIEDIT_SetAutoScrollV       8
     MULTIEDIT_SetAutoScrollH       8
     MULTIEDIT_SetHBorder         224
     MULTIEDIT_SetFont            256
     MULTIEDIT_SetBkColor         236
     MULTIEDIT_SetCursorOffset    152
     MULTIEDIT_SetTextColor        72
     MULTIEDIT_SetPrompt          672
     MULTIEDIT_SetBufferSize      372
     MULTIEDIT_SetMaxNumChars     448
     MULTIEDIT_GetTextSize        100
     MULTIEDIT_SetTextAlign       260
     MULTIEDIT_GetCursorCharPos    56
     MULTIEDIT_GetCursorPixelPos  152
     MULTIEDIT_EnableBlink        156
     ??DataTable1                   4
     ??DataTable1_1                 4
     ??DataTable1_2                 4
     ??DataTable1_3                 4
     ??DataTable3                   4
     ??DataTable3_1                 4
     ??DataTable3_2                 4
     ??DataTable3_3                 4
     ??DataTable3_4                 4
     ??DataTable3_5                 4

 
     20 bytes in section .data
 15 920 bytes in section .text
 
 15 920 bytes of CODE memory
     20 bytes of DATA memory

Errors: none
Warnings: none
