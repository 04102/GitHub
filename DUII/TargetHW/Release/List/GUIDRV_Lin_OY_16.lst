###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:15:35 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_OY_16.c                  #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_OY_16.c -D DEBUG=1 -D    #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUIDRV_Lin_OY_16.lst       #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUIDRV_Lin_OY_16.o          #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDRV_Lin_OY_16.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDRV_Lin_OY_16.c
     19          Purpose     : Driver for accessing linear video memory
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stddef.h>
     24          #include <string.h>
     25          
     26          #include "LCD_Private.h"
     27          #include "GUI_Private.h"
     28          #include "LCD_SIM.h"
     29          #include "LCD_ConfDefaults.h"
     30          
     31          #include "GUIDRV_Lin.h"
     32          
     33          #if (!defined(WIN32) | defined(LCD_SIMCONTROLLER))
     34          
     35          /*********************************************************************
     36          *
     37          *       Defines
     38          *
     39          **********************************************************************
     40          */
     41          #ifdef WIN32
     42            //
     43            // Simulation prototypes
     44            //
     45            U16  SIM_Lin_ReadMem16  (unsigned int Off);
     46            U32  SIM_Lin_ReadMem32  (unsigned int Off);
     47            U32  SIM_Lin_ReadMem32p (U32 * p);
     48            void SIM_Lin_WriteMem16 (unsigned int Off, U16 Data);
     49            void SIM_Lin_WriteMem32 (unsigned int Off, U32 Data);
     50            void SIM_Lin_WriteMem16p(U16 * p, U16 Data);
     51            void SIM_Lin_WriteMem32p(U32 * p, U32 Data);
     52            void SIM_Lin_memcpy     (void * pDst, const void * pSrc, int Len);
     53            void SIM_Lin_SetVRAMAddr(int LayerIndex, void * pVRAM);
     54            void SIM_Lin_SetVRAMSize(int LayerIndex, int xSize, int ySize);
     55            //
     56            // Access macro definition for internal simulation
     57            //
     58            #define LCD_READ_MEM16(VRAMAddr, Off)        SIM_Lin_ReadMem16(Off)
     59            #define LCD_READ_MEM32(VRAMAddr, Off)        SIM_Lin_ReadMem32(Off)
     60            #define LCD_READ_MEM32P(p)                   SIM_Lin_ReadMem32p(p)
     61            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) SIM_Lin_WriteMem16(Off, Data)
     62            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) SIM_Lin_WriteMem32(Off, Data)
     63            #define LCD_WRITE_MEM16P(p, Data)            SIM_Lin_WriteMem16p(p, Data)
     64            #define LCD_WRITE_MEM32P(p, Data)            SIM_Lin_WriteMem32p(p, Data)
     65            #undef  GUI_MEMCPY
     66            #define GUI_MEMCPY(pDst, pSrc, Len) SIM_Lin_memcpy(pDst, pSrc, Len)
     67          #else
     68            //
     69            // Access macro definition for hardware
     70            //
     71            #define LCD_READ_MEM16(VRAMAddr, Off)        (*((U16 *)VRAMAddr + (U32)Off))
     72            #define LCD_READ_MEM32(VRAMAddr, Off)        (*((U32 *)VRAMAddr + (U32)Off))
     73            #define LCD_READ_MEM32P(p)                   (*((U32 *)p))
     74            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) *((U16 *)VRAMAddr + (U32)Off) = Data
     75            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) *((U32 *)VRAMAddr + (U32)Off) = Data
     76            #define LCD_WRITE_MEM16P(p, Data)            *((U16 *)p) = Data
     77            #define LCD_WRITE_MEM32P(p, Data)            *((U32 *)p) = Data
     78          #endif
     79          
     80          #define WRITE_MEM16(VRAMAddr, Off, Data) LCD_WRITE_MEM16(VRAMAddr, Off, Data)
     81          #define WRITE_MEM32(VRAMAddr, Off, Data) LCD_WRITE_MEM32(VRAMAddr, Off, Data)
     82          #define READ_MEM16(VRAMAddr, Off)        LCD_READ_MEM16(VRAMAddr, Off)
     83          #define READ_MEM32(VRAMAddr, Off)        LCD_READ_MEM32(VRAMAddr, Off)
     84          #define READ_MEM32P(p)                   LCD_READ_MEM32P(p)
     85          #define WRITE_MEM16P(p, Data)            LCD_WRITE_MEM16P(p, Data)
     86          #define WRITE_MEM32P(p, Data)            LCD_WRITE_MEM32P(p, Data)
     87          
     88          #define OFF2PTR16(VRAMAddr, Off)     (U16 *)((U8 *)VRAMAddr + (Off << 1))
     89          #define OFF2PTR32(VRAMAddr, Off)     (U32 *)((U8 *)VRAMAddr + (Off << 2))
     90          
     91          #define XY2OFF16(vxSizePhys, x, y)    ((U32)y *  vxSizePhys       +       x      )
     92          #define XY2OFF32(vxSizePhys, x, y)    ((U32)y * (vxSizePhys >> 1) + ((U32)x >> 1))
     93          
     94          /*********************************************************************
     95          *
     96          *       Types
     97          *
     98          **********************************************************************
     99          */
    100          typedef struct {
    101            U32 VRAMAddr;
    102            int xSize, ySize;
    103            int vxSize, vySize;
    104            int vxSizePhys;
    105            int xPos, yPos;
    106            int Alpha;
    107            int IsVisible;
    108            void (* pfFillRect)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex);
    109          } DRIVER_CONTEXT;
    110          
    111          /*********************************************************************
    112          *
    113          *       Static functions
    114          *
    115          **********************************************************************
    116          */
    117          /*********************************************************************
    118          *
    119          *       _SetPixelIndex
    120          *
    121          * Purpose:
    122          *   Sets the index of the given pixel. The upper layers
    123          *   calling this routine make sure that the coordinates are in range, so
    124          *   that no check on the parameters needs to be performed.
    125          */

   \                                 In section .text, align 4, keep-with-next
    126          static void _SetPixelIndex(GUI_DEVICE * pDevice, int x, int y, int PixelIndex) {
    127            DRIVER_CONTEXT * pContext;
    128            U32 Off;
    129          
    130            //
    131            // Get context
    132            //
    133            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _SetPixelIndex:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    134            //
    135            // Mirror y
    136            //
    137            y = (pContext->vySize - 1 - (y));
    138            //
    139            // Write into hardware
    140            //
    141            Off      = XY2OFF16(pContext->vxSizePhys, x, y);
    142            WRITE_MEM16(pContext->VRAMAddr, Off, PixelIndex);
   \   00000004   10C090E5           LDR      R12,[R0, #+16]
   \   00000008   01C04CE2           SUB      R12,R12,#+1
   \   0000000C   02204CE0           SUB      R2,R12,R2
   \   00000010   14C090E5           LDR      R12,[R0, #+20]
   \   00000014   000090E5           LDR      R0,[R0, #+0]
   \   00000018   9C1221E0           MLA      R1,R12,R2,R1
   \   0000001C   810080E0           ADD      R0,R0,R1, LSL #+1
   \   00000020   B030C0E1           STRH     R3,[R0, #+0]
    143          }
   \   00000024   1EFF2FE1           BX       LR               ;; return
    144          
    145          /*********************************************************************
    146          *
    147          *       _GetPixelIndex
    148          *
    149          * Purpose:
    150          *   Returns the index of the given pixel. The upper layers
    151          *   calling this routine make sure that the coordinates are in range, so
    152          *   that no check on the parameters needs to be performed.
    153          */

   \                                 In section .text, align 4, keep-with-next
    154          static unsigned int _GetPixelIndex(GUI_DEVICE * pDevice, int x, int y) {
    155            DRIVER_CONTEXT * pContext;
    156            U32 Off;
    157            LCD_PIXELINDEX PixelIndex;
    158          
    159            //
    160            // Get context
    161            //
    162            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetPixelIndex:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    163            //
    164            // Mirror y
    165            //
    166            y = (pContext->vySize - 1 - (y));
    167            Off        = XY2OFF16(pContext->vxSizePhys, x, y);
    168            PixelIndex = READ_MEM16(pContext->VRAMAddr, Off);
    169            return PixelIndex;
   \   00000004   103090E5           LDR      R3,[R0, #+16]
   \   00000008   013043E2           SUB      R3,R3,#+1
   \   0000000C   022043E0           SUB      R2,R3,R2
   \   00000010   143090E5           LDR      R3,[R0, #+20]
   \   00000014   000090E5           LDR      R0,[R0, #+0]
   \   00000018   931221E0           MLA      R1,R3,R2,R1
   \   0000001C   810080E0           ADD      R0,R0,R1, LSL #+1
   \   00000020   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000024   1EFF2FE1           BX       LR               ;; return
    170          }
    171          
    172          /*********************************************************************
    173          *
    174          *       _XorPixel
    175          */

   \                                 In section .text, align 4, keep-with-next
    176          static void _XorPixel(GUI_DEVICE * pDevice, int x, int y) {
   \                     _XorPixel:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0060A0E1           MOV      R6,R0
    177            LCD_PIXELINDEX PixelIndex;
    178            LCD_PIXELINDEX IndexMask;
    179            
    180            PixelIndex = _GetPixelIndex(pDevice, x, y);
   \   00000008   080096E5           LDR      R0,[R6, #+8]
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   101090E5           LDR      R1,[R0, #+16]
   \   00000014   0250A0E1           MOV      R5,R2
   \   00000018   011041E2           SUB      R1,R1,#+1
   \   0000001C   142090E5           LDR      R2,[R0, #+20]
   \   00000020   051041E0           SUB      R1,R1,R5
   \   00000024   924121E0           MLA      R1,R2,R1,R4
   \   00000028   000090E5           LDR      R0,[R0, #+0]
   \   0000002C   04D04DE2           SUB      SP,SP,#+4
   \   00000030   810080E0           ADD      R0,R0,R1, LSL #+1
   \   00000034   B070D0E1           LDRH     R7,[R0, #+0]
    181            IndexMask  = pDevice->pColorConvAPI->pfGetIndexMask();
   \   00000038   100096E5           LDR      R0,[R6, #+16]
   \   0000003C   080090E5           LDR      R0,[R0, #+8]
   \   00000040   30FF2FE1           BLX      R0
    182            _SetPixelIndex(pDevice, x, y, PixelIndex ^ IndexMask);
   \   00000044   081096E5           LDR      R1,[R6, #+8]
   \   00000048   070020E0           EOR      R0,R0,R7
   \   0000004C   102091E5           LDR      R2,[R1, #+16]
   \   00000050   143091E5           LDR      R3,[R1, #+20]
   \   00000054   012042E2           SUB      R2,R2,#+1
   \   00000058   052042E0           SUB      R2,R2,R5
   \   0000005C   934222E0           MLA      R2,R3,R2,R4
   \   00000060   001091E5           LDR      R1,[R1, #+0]
    183          }
   \   00000064   04D08DE2           ADD      SP,SP,#+4
   \   00000068   821081E0           ADD      R1,R1,R2, LSL #+1
   \   0000006C   B000C1E1           STRH     R0,[R1, #+0]
   \   00000070   F080BDE8           POP      {R4-R7,PC}       ;; return
    184          
    185          /*********************************************************************
    186          *
    187          *       _DrawHLine
    188          */

   \                                 In section .text, align 4, keep-with-next
    189          static void _DrawHLine  (GUI_DEVICE * pDevice, int x0, int y,  int x1) {
   \                     _DrawHLine:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0070A0E1           MOV      R7,R0
    190            DRIVER_CONTEXT * pContext;
    191            U32 * pDest;
    192            U32 Off;
    193            int RemPixels;
    194            U32 Data, ColorMask;
    195            LCD_PIXELINDEX ColorIndex;
    196          
    197            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable15
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   0350A0E1           MOV      R5,R3
   \   0000001C   010010E3           TST      R0,#0x1
   \   00000020   1B00000A           BEQ      ??_DrawHLine_0
   \   00000024   040055E1           CMP      R5,R4
   \   00000028   4D0000BA           BLT      ??_DrawHLine_1
    198              for (; x0 <= x1; x0++) {
    199                _XorPixel(pDevice, x0, y);
   \                     ??_DrawHLine_2:
   \   0000002C   080097E5           LDR      R0,[R7, #+8]
   \   00000030   101090E5           LDR      R1,[R0, #+16]
   \   00000034   142090E5           LDR      R2,[R0, #+20]
   \   00000038   011041E2           SUB      R1,R1,#+1
   \   0000003C   061041E0           SUB      R1,R1,R6
   \   00000040   924121E0           MLA      R1,R2,R1,R4
   \   00000044   000090E5           LDR      R0,[R0, #+0]
   \   00000048   810080E0           ADD      R0,R0,R1, LSL #+1
   \   0000004C   B080D0E1           LDRH     R8,[R0, #+0]
   \   00000050   100097E5           LDR      R0,[R7, #+16]
   \   00000054   080090E5           LDR      R0,[R0, #+8]
   \   00000058   30FF2FE1           BLX      R0
   \   0000005C   081097E5           LDR      R1,[R7, #+8]
   \   00000060   080020E0           EOR      R0,R0,R8
   \   00000064   102091E5           LDR      R2,[R1, #+16]
   \   00000068   143091E5           LDR      R3,[R1, #+20]
   \   0000006C   012042E2           SUB      R2,R2,#+1
   \   00000070   062042E0           SUB      R2,R2,R6
   \   00000074   934222E0           MLA      R2,R3,R2,R4
   \   00000078   001091E5           LDR      R1,[R1, #+0]
    200              }
   \   0000007C   014084E2           ADD      R4,R4,#+1
   \   00000080   821081E0           ADD      R1,R1,R2, LSL #+1
   \   00000084   B000C1E1           STRH     R0,[R1, #+0]
   \   00000088   040055E1           CMP      R5,R4
   \   0000008C   E6FFFFAA           BGE      ??_DrawHLine_2
   \   00000090   F081BDE8           POP      {R4-R8,PC}
    201            } else {
    202              ColorIndex = LCD__GetColorIndex();
    203              //
    204              // Get context
    205              //
    206              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     ??_DrawHLine_0:
   \   00000094   081097E5           LDR      R1,[R7, #+8]
   \   00000098   ........           LDR      R0,??DataTable15_1
    207              //
    208              // Mirror y
    209              //
    210              y = (pContext->vySize - 1 - y);
    211              //
    212              // Draw...
    213              //
    214              Off = XY2OFF32(pContext->vxSizePhys, x0, y);
    215              pDest = OFF2PTR32(pContext->VRAMAddr, Off);
   \   0000009C   102091E5           LDR      R2,[R1, #+16]
   \   000000A0   143091E5           LDR      R3,[R1, #+20]
   \   000000A4   012042E2           SUB      R2,R2,#+1
   \   000000A8   062042E0           SUB      R2,R2,R6
   \   000000AC   C330A0E1           ASR      R3,R3,#+1
   \   000000B0   930202E0           MUL      R2,R3,R2
   \   000000B4   001091E5           LDR      R1,[R1, #+0]
   \   000000B8   A42082E0           ADD      R2,R2,R4, LSR #+1
   \   000000BC   000090E5           LDR      R0,[R0, #+0]
   \   000000C0   021181E0           ADD      R1,R1,R2, LSL #+2
    216              RemPixels = x1 - x0 + 1;
   \   000000C4   042045E0           SUB      R2,R5,R4
   \   000000C8   000090E5           LDR      R0,[R0, #+0]
   \   000000CC   012082E2           ADD      R2,R2,#+1
    217              //
    218              // First DWORD
    219              //
    220              if (x0 & 1) {
   \   000000D0   010014E3           TST      R4,#0x1
   \   000000D4   0500000A           BEQ      ??_DrawHLine_3
    221                Data = READ_MEM32P(pDest);
    222                #if (LCD_ENDIAN_BIG == 0)
    223                  Data &= 0xFFFF;
    224                  Data |= (((U32)ColorIndex) << 16);
    225                #else
    226                  Data &= 0xFFFF0000;
    227                  Data |= ColorIndex;
    228                #endif
    229                WRITE_MEM32P(pDest, Data);
   \   000000D8   B030D1E1           LDRH     R3,[R1, #+0]
   \   000000DC   00C8A0E1           LSL      R12,R0,#+16
    230                pDest++;
    231                RemPixels--;
   \   000000E0   012042E2           SUB      R2,R2,#+1
   \   000000E4   0338A0E1           LSL      R3,R3,#+16
   \   000000E8   23388CE1           ORR      R3,R12,R3, LSR #+16
   \   000000EC   043081E4           STR      R3,[R1], #+4
    232              }
    233              //
    234              // Complete DWORDS
    235              //
    236              ColorMask = ColorIndex * 0x00010001;
   \                     ??_DrawHLine_3:
   \   000000F0   003880E0           ADD      R3,R0,R0, LSL #+16
    237              if (RemPixels >= 16) {
   \   000000F4   100052E3           CMP      R2,#+16
   \   000000F8   0B0000BA           BLT      ??_DrawHLine_4
    238                RemPixels -= 16;
   \   000000FC   102042E2           SUB      R2,R2,#+16
    239                do {
    240                  WRITE_MEM32P(pDest,     ColorMask);
   \                     ??_DrawHLine_5:
   \   00000100   043081E4           STR      R3,[R1], #+4
    241                  WRITE_MEM32P(pDest + 1, ColorMask);
   \   00000104   043081E4           STR      R3,[R1], #+4
    242                  WRITE_MEM32P(pDest + 2, ColorMask);
   \   00000108   043081E4           STR      R3,[R1], #+4
    243                  WRITE_MEM32P(pDest + 3, ColorMask);
   \   0000010C   043081E4           STR      R3,[R1], #+4
    244                  WRITE_MEM32P(pDest + 4, ColorMask);
   \   00000110   043081E4           STR      R3,[R1], #+4
    245                  WRITE_MEM32P(pDest + 5, ColorMask);
   \   00000114   043081E4           STR      R3,[R1], #+4
    246                  WRITE_MEM32P(pDest + 6, ColorMask);
   \   00000118   043081E4           STR      R3,[R1], #+4
    247                  WRITE_MEM32P(pDest + 7, ColorMask);
   \   0000011C   043081E4           STR      R3,[R1], #+4
    248                  pDest += 8;
    249                  RemPixels -= 16;
   \   00000120   102052E2           SUBS     R2,R2,#+16
    250                } while (RemPixels >= 0);
   \   00000124   F5FFFF5A           BPL      ??_DrawHLine_5
    251                RemPixels += 16;
   \   00000128   102082E2           ADD      R2,R2,#+16
    252              }
    253              if (RemPixels >= 2) {
   \                     ??_DrawHLine_4:
   \   0000012C   020052E3           CMP      R2,#+2
   \   00000130   030000BA           BLT      ??_DrawHLine_6
    254                do {
    255                  WRITE_MEM32P(pDest, ColorMask);
    256                  pDest++;
    257                  RemPixels -= 2;
   \                     ??_DrawHLine_7:
   \   00000134   022042E2           SUB      R2,R2,#+2
   \   00000138   043081E4           STR      R3,[R1], #+4
    258                } while (RemPixels >= 2);
   \   0000013C   020052E3           CMP      R2,#+2
   \   00000140   FBFFFFAA           BGE      ??_DrawHLine_7
    259              }
    260              //
    261              // Last DWORD
    262              //
    263              if (RemPixels > 0) {
   \                     ??_DrawHLine_6:
   \   00000144   010052E3           CMP      R2,#+1
   \   00000148   050000BA           BLT      ??_DrawHLine_1
    264                Data = READ_MEM32P(pDest);
    265                #if (LCD_ENDIAN_BIG == 0)
    266                  Data &= 0xFFFF0000;
    267                  Data |= ColorIndex & 0xFFFF;
    268                #else
    269                  Data &= 0xFFFF;
    270                  Data |= (((U32)ColorIndex) << 16);
    271                #endif
    272                WRITE_MEM32P(pDest, Data);
   \   0000014C   002091E5           LDR      R2,[R1, #+0]
   \   00000150   0008A0E1           LSL      R0,R0,#+16
   \   00000154   2228A0E1           LSR      R2,R2,#+16
   \   00000158   2008A0E1           LSR      R0,R0,#+16
   \   0000015C   020880E1           ORR      R0,R0,R2, LSL #+16
   \   00000160   000081E5           STR      R0,[R1, #+0]
    273              }
    274            }
    275          }
   \                     ??_DrawHLine_1:
   \   00000164   F081BDE8           POP      {R4-R8,PC}       ;; return
    276          
    277          /*********************************************************************
    278          *
    279          *       _DrawVLine, not optimized
    280          */

   \                                 In section .text, align 4, keep-with-next
    281          static void _DrawVLine  (GUI_DEVICE * pDevice, int x, int y0,  int y1) {
   \                     _DrawVLine:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    282            LCD_PIXELINDEX ColorIndex;
    283          
    284            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable15
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0270A0E1           MOV      R7,R2
   \   00000018   0360A0E1           MOV      R6,R3
   \   0000001C   010010E3           TST      R0,#0x1
   \   00000020   1B00000A           BEQ      ??_DrawVLine_0
   \   00000024   070056E1           CMP      R6,R7
   \   00000028   2A0000BA           BLT      ??_DrawVLine_1
    285              for (; y0 <= y1; y0++) {
    286                _XorPixel(pDevice, x, y0);
   \                     ??_DrawVLine_2:
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   101090E5           LDR      R1,[R0, #+16]
   \   00000034   142090E5           LDR      R2,[R0, #+20]
   \   00000038   011041E2           SUB      R1,R1,#+1
   \   0000003C   071041E0           SUB      R1,R1,R7
   \   00000040   925121E0           MLA      R1,R2,R1,R5
   \   00000044   000090E5           LDR      R0,[R0, #+0]
   \   00000048   810080E0           ADD      R0,R0,R1, LSL #+1
   \   0000004C   B080D0E1           LDRH     R8,[R0, #+0]
   \   00000050   100094E5           LDR      R0,[R4, #+16]
   \   00000054   080090E5           LDR      R0,[R0, #+8]
   \   00000058   30FF2FE1           BLX      R0
   \   0000005C   081094E5           LDR      R1,[R4, #+8]
   \   00000060   080020E0           EOR      R0,R0,R8
   \   00000064   102091E5           LDR      R2,[R1, #+16]
   \   00000068   143091E5           LDR      R3,[R1, #+20]
   \   0000006C   012042E2           SUB      R2,R2,#+1
   \   00000070   072042E0           SUB      R2,R2,R7
   \   00000074   935222E0           MLA      R2,R3,R2,R5
   \   00000078   001091E5           LDR      R1,[R1, #+0]
    287              }
   \   0000007C   017087E2           ADD      R7,R7,#+1
   \   00000080   821081E0           ADD      R1,R1,R2, LSL #+1
   \   00000084   B000C1E1           STRH     R0,[R1, #+0]
   \   00000088   070056E1           CMP      R6,R7
   \   0000008C   E6FFFFAA           BGE      ??_DrawVLine_2
   \   00000090   F081BDE8           POP      {R4-R8,PC}
    288            } else {
    289              ColorIndex = LCD__GetColorIndex();
   \                     ??_DrawVLine_0:
   \   00000094   ........           LDR      R0,??DataTable15_1
   \   00000098   070056E1           CMP      R6,R7
   \   0000009C   000090E5           LDR      R0,[R0, #+0]
   \   000000A0   000090E5           LDR      R0,[R0, #+0]
   \   000000A4   0B0000BA           BLT      ??_DrawVLine_1
    290              for (; y0 <= y1; y0++) {
    291                _SetPixelIndex(pDevice, x, y0, ColorIndex);
   \                     ??_DrawVLine_3:
   \   000000A8   081094E5           LDR      R1,[R4, #+8]
   \   000000AC   102091E5           LDR      R2,[R1, #+16]
   \   000000B0   143091E5           LDR      R3,[R1, #+20]
   \   000000B4   012042E2           SUB      R2,R2,#+1
   \   000000B8   072042E0           SUB      R2,R2,R7
   \   000000BC   935222E0           MLA      R2,R3,R2,R5
   \   000000C0   001091E5           LDR      R1,[R1, #+0]
    292              }
   \   000000C4   017087E2           ADD      R7,R7,#+1
   \   000000C8   821081E0           ADD      R1,R1,R2, LSL #+1
   \   000000CC   B000C1E1           STRH     R0,[R1, #+0]
   \   000000D0   070056E1           CMP      R6,R7
   \   000000D4   F3FFFFAA           BGE      ??_DrawVLine_3
    293            }
    294          }
   \                     ??_DrawVLine_1:
   \   000000D8   F081BDE8           POP      {R4-R8,PC}       ;; return
    295          
    296          /*********************************************************************
    297          *
    298          *       _FillRect
    299          */

   \                                 In section .text, align 4, keep-with-next
    300          static void _FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   18809DE5           LDR      R8,[SP, #+24]
   \   00000008   0260A0E1           MOV      R6,R2
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0370A0E1           MOV      R7,R3
   \   00000018   060058E1           CMP      R8,R6
   \   0000001C   070000BA           BLT      ??_FillRect_0
    301            #ifdef LCD_FILL_RECT
    302               LCD_FILL_RECT(x0, y0, x1, y1, LCD__GetColorIndex());
    303            #else
    304              for (; y0 <= y1; y0++) {
    305                _DrawHLine(pDevice, x0, y0, x1);
   \                     ??_FillRect_1:
   \   00000020   0730A0E1           MOV      R3,R7
   \   00000024   0620A0E1           MOV      R2,R6
   \   00000028   0510A0E1           MOV      R1,R5
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       _DrawHLine
    306              }
   \   00000034   016086E2           ADD      R6,R6,#+1
   \   00000038   060058E1           CMP      R8,R6
   \   0000003C   F7FFFFAA           BGE      ??_FillRect_1
    307            #endif
    308          }
   \                     ??_FillRect_0:
   \   00000040   F081BDE8           POP      {R4-R8,PC}       ;; return
    309          
    310          /*********************************************************************
    311          *
    312          *       Draw Bitmap 1 BPP
    313          */

   \                                 In section .text, align 4, keep-with-next
    314          static void _DrawBitLine1BPP(GUI_DEVICE * pDevice, unsigned x, unsigned y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine1BPP:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    315            DRIVER_CONTEXT * pContext;
    316            unsigned Pixels, PixelCnt;
    317            LCD_PIXELINDEX Index, Index0, Index1, IndexMask;
    318            U32 Off;
    319          
    320            Index0   = *(pTrans + 0);
    321            Index1   = *(pTrans + 1);
    322            //
    323            // Get context
    324            //
    325            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000004   086090E5           LDR      R6,[R0, #+8]
   \   00000008   20C09DE5           LDR      R12,[SP, #+32]
    326            x       += Diff;
    327            //
    328            // Mirror y
    329            //
    330            y = (pContext->vySize - 1 - y);
    331            Off      = XY2OFF16(pContext->vxSizePhys, x, y);
   \   0000000C   107096E5           LDR      R7,[R6, #+16]
   \   00000010   0340A0E1           MOV      R4,R3
   \   00000014   017047E2           SUB      R7,R7,#+1
   \   00000018   022047E0           SUB      R2,R7,R2
   \   0000001C   147096E5           LDR      R7,[R6, #+20]
    332            PixelCnt = 8 - Diff;
    333            Pixels   = LCD_aMirror[*p] >> Diff;
   \   00000020   ........           LDR      R9,??DataTable15_2
   \   00000024   971221E0           MLA      R1,R7,R2,R1
   \   00000028   28E09DE5           LDR      LR,[SP, #+40]
   \   0000002C   01708CE0           ADD      R7,R12,R1
   \   00000030   0010D4E5           LDRB     R1,[R4, #+0]
   \   00000034   00309EE5           LDR      R3,[LR, #+0]
   \   00000038   24509DE5           LDR      R5,[SP, #+36]
   \   0000003C   0910D1E7           LDRB     R1,[R1, +R9]
   \   00000040   04E09EE5           LDR      LR,[LR, #+4]
   \   00000044   08806CE2           RSB      R8,R12,#+8
   \   00000048   51ACA0E1           ASR      R10,R1,R12
    334            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   0000004C   ........           LDR      R1,??DataTable15
   \   00000050   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000054   031001E2           AND      R1,R1,#0x3
   \   00000058   030051E3           CMP      R1,#+3
   \   0000005C   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitLine1BPP_0:
   \   00000060   3400008A           BHI      ??_DrawBitLine1BPP_1
   \   00000064   020000EA           B        ??_DrawBitLine1BPP_2
   \   00000068   1F0000EA           B        ??_DrawBitLine1BPP_3
   \   0000006C   100000EA           B        ??_DrawBitLine1BPP_4
   \   00000070   1D0000EA           B        ??_DrawBitLine1BPP_3
    335            case 0:
    336              do {
    337                Index = (Pixels & 1) ? Index1 : Index0;
    338                WRITE_MEM16(pContext->VRAMAddr, Off, Index);
   \                     ??_DrawBitLine1BPP_2:
   \   00000074   001096E5           LDR      R1,[R6, #+0]
   \   00000078   01001AE3           TST      R10,#0x1
   \   0000007C   0E00A011           MOVNE    R0,LR
   \   00000080   0300A001           MOVEQ    R0,R3
   \   00000084   871081E0           ADD      R1,R1,R7, LSL #+1
    339                Off++;
    340                PixelCnt--;
   \   00000088   018048E2           SUB      R8,R8,#+1
   \   0000008C   B000C1E1           STRH     R0,[R1, #+0]
    341                Pixels >>= 1;
    342                if (PixelCnt == 0) {
   \   00000090   000058E3           CMP      R8,#+0
    343                  Pixels   = LCD_aMirror[*(++p)];
   \   00000094   0100F405           LDRBEQ   R0,[R4, #+1]!
   \   00000098   AAA0A0E1           LSR      R10,R10,#+1
    344                  PixelCnt = 8;
   \   0000009C   0880A003           MOVEQ    R8,#+8
   \   000000A0   09A0D007           LDRBEQ   R10,[R0, +R9]
   \   000000A4   017087E2           ADD      R7,R7,#+1
    345                }
    346              } while (--xsize);
   \   000000A8   015055E2           SUBS     R5,R5,#+1
   \   000000AC   F0FFFF1A           BNE      ??_DrawBitLine1BPP_2
   \   000000B0   F087BDE8           POP      {R4-R10,PC}
    347              break;
    348            case LCD_DRAWMODE_TRANS:
    349              do {
    350                if (Pixels & 1) {
   \                     ??_DrawBitLine1BPP_4:
   \   000000B4   01001AE3           TST      R10,#0x1
    351                  WRITE_MEM16(pContext->VRAMAddr, Off, Index1);
   \   000000B8   00009615           LDRNE    R0,[R6, #+0]
    352                }
    353                Off++;
    354                PixelCnt--;
   \   000000BC   018048E2           SUB      R8,R8,#+1
   \   000000C0   87008010           ADDNE    R0,R0,R7, LSL #+1
   \   000000C4   B0E0C011           STRHNE   LR,[R0, #+0]
    355                Pixels >>= 1;
    356                if (PixelCnt == 0) {
   \   000000C8   000058E3           CMP      R8,#+0
    357                  Pixels   = LCD_aMirror[*(++p)];
   \   000000CC   0100F405           LDRBEQ   R0,[R4, #+1]!
   \   000000D0   AAA0A0E1           LSR      R10,R10,#+1
    358                  PixelCnt = 8;
   \   000000D4   0880A003           MOVEQ    R8,#+8
   \   000000D8   09A0D007           LDRBEQ   R10,[R0, +R9]
   \   000000DC   017087E2           ADD      R7,R7,#+1
    359                }
    360              } while (--xsize);
   \   000000E0   015055E2           SUBS     R5,R5,#+1
   \   000000E4   F2FFFF1A           BNE      ??_DrawBitLine1BPP_4
   \   000000E8   F087BDE8           POP      {R4-R10,PC}
    361              break;
    362            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    363            case LCD_DRAWMODE_XOR:
    364              IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \                     ??_DrawBitLine1BPP_3:
   \   000000EC   100090E5           LDR      R0,[R0, #+16]
   \   000000F0   080090E5           LDR      R0,[R0, #+8]
   \   000000F4   30FF2FE1           BLX      R0
   \   000000F8   001096E5           LDR      R1,[R6, #+0]
   \   000000FC   871081E0           ADD      R1,R1,R7, LSL #+1
    365              do {
    366                if (Pixels & 1) {
   \                     ??_DrawBitLine1BPP_5:
   \   00000100   01001AE3           TST      R10,#0x1
    367                  Index = READ_MEM16(pContext->VRAMAddr, Off);
    368                  Index ^= IndexMask;
    369                  WRITE_MEM16(pContext->VRAMAddr, Off, Index);
   \   00000104   B020D111           LDRHNE   R2,[R1, #+0]
    370                }
    371                Off++;
    372                PixelCnt--;
   \   00000108   018048E2           SUB      R8,R8,#+1
    373                Pixels >>= 1;
   \   0000010C   AAA0A0E1           LSR      R10,R10,#+1
   \   00000110   02202010           EORNE    R2,R0,R2
   \   00000114   B020C111           STRHNE   R2,[R1, #+0]
    374                if (PixelCnt == 0) {
   \   00000118   000058E3           CMP      R8,#+0
    375                  Pixels   = LCD_aMirror[*(++p)];
   \   0000011C   0120F405           LDRBEQ   R2,[R4, #+1]!
    376                  PixelCnt = 8;
   \   00000120   0880A003           MOVEQ    R8,#+8
    377                }
    378              } while (--xsize);
   \   00000124   015045E2           SUB      R5,R5,#+1
   \   00000128   09A0D207           LDRBEQ   R10,[R2, +R9]
   \   0000012C   021081E2           ADD      R1,R1,#+2
   \   00000130   000055E3           CMP      R5,#+0
   \   00000134   F1FFFF1A           BNE      ??_DrawBitLine1BPP_5
    379              break;
    380            }
    381          }
   \                     ??_DrawBitLine1BPP_1:
   \   00000138   F087BDE8           POP      {R4-R10,PC}      ;; return
    382          
    383          /*********************************************************************
    384          *
    385          *       Draw Bitmap 2 BPP, not optimized
    386          */

   \                                 In section .text, align 4, keep-with-next
    387          static void  _DrawBitLine2BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine2BPP:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    388            LCD_PIXELINDEX Pixels, PixelIndex;
    389            int CurrentPixel, Shift, Index;
    390            Pixels       = *p;
    391            CurrentPixel = Diff;
    392            x           += Diff;
    393            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000004   ........           LDR      R6,??DataTable15
   \   00000008   20C09DE5           LDR      R12,[SP, #+32]
   \   0000000C   1060D6E5           LDRB     R6,[R6, #+16]
   \   00000010   24409DE5           LDR      R4,[SP, #+36]
   \   00000014   28509DE5           LDR      R5,[SP, #+40]
   \   00000018   00E0D3E5           LDRB     LR,[R3, #+0]
   \   0000001C   01108CE0           ADD      R1,R12,R1
   \   00000020   036016E2           ANDS     R6,R6,#0x3
   \   00000024   0200000A           BEQ      ??_DrawBitLine2BPP_0
   \   00000028   026056E2           SUBS     R6,R6,#+2
   \   0000002C   3200000A           BEQ      ??_DrawBitLine2BPP_1
   \   00000030   F087BDE8           POP      {R4-R10,PC}
    394            case 0:
    395              if (pTrans) {
   \                     ??_DrawBitLine2BPP_0:
   \   00000034   C060A0E3           MOV      R6,#+192
   \   00000038   000055E3           CMP      R5,#+0
   \   0000003C   1700000A           BEQ      ??_DrawBitLine2BPP_2
    396                do {
    397                  Shift = (3 - CurrentPixel) << 1;
    398                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    399                  PixelIndex = *(pTrans + Index);
    400                  _SetPixelIndex(pDevice, x++, y, PixelIndex);
   \                     ??_DrawBitLine2BPP_3:
   \   00000040   088090E5           LDR      R8,[R0, #+8]
   \   00000044   03706CE2           RSB      R7,R12,#+3
   \   00000048   109098E5           LDR      R9,[R8, #+16]
   \   0000004C   14A098E5           LDR      R10,[R8, #+20]
   \   00000050   019049E2           SUB      R9,R9,#+1
   \   00000054   029049E0           SUB      R9,R9,R2
   \   00000058   9A1929E0           MLA      R9,R10,R9,R1
   \   0000005C   008098E5           LDR      R8,[R8, #+0]
   \   00000060   8770A0E1           LSL      R7,R7,#+1
   \   00000064   898088E0           ADD      R8,R8,R9, LSL #+1
   \   00000068   0790A0E1           MOV      R9,R7
   \   0000006C   069069E2           RSB      R9,R9,#+6
   \   00000070   56990EE0           AND      R9,LR,R6, ASR R9
   \   00000074   3977A0E1           LSR      R7,R9,R7
   \   00000078   077195E7           LDR      R7,[R5, +R7, LSL #+2]
    401                  if (++CurrentPixel == 4) {
   \   0000007C   01C08CE2           ADD      R12,R12,#+1
   \   00000080   B070C8E1           STRH     R7,[R8, #+0]
   \   00000084   04005CE3           CMP      R12,#+4
    402                    CurrentPixel = 0;
   \   00000088   00C0A003           MOVEQ    R12,#+0
    403                    Pixels = *(++p);
   \   0000008C   01E0F305           LDRBEQ   LR,[R3, #+1]!
   \   00000090   011081E2           ADD      R1,R1,#+1
    404                  }
    405          		  } while (--xsize);
   \   00000094   014054E2           SUBS     R4,R4,#+1
   \   00000098   E8FFFF1A           BNE      ??_DrawBitLine2BPP_3
   \   0000009C   F087BDE8           POP      {R4-R10,PC}
    406              } else {
    407                do {
    408                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_2:
   \   000000A0   03506CE2           RSB      R5,R12,#+3
   \   000000A4   8570A0E1           LSL      R7,R5,#+1
    409                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    410                  _SetPixelIndex(pDevice, x++, y, Index);
   \   000000A8   085090E5           LDR      R5,[R0, #+8]
    411                  if (++CurrentPixel == 4) {
   \   000000AC   01C08CE2           ADD      R12,R12,#+1
   \   000000B0   108095E5           LDR      R8,[R5, #+16]
   \   000000B4   149095E5           LDR      R9,[R5, #+20]
   \   000000B8   018048E2           SUB      R8,R8,#+1
   \   000000BC   028048E0           SUB      R8,R8,R2
   \   000000C0   991828E0           MLA      R8,R9,R8,R1
   \   000000C4   005095E5           LDR      R5,[R5, #+0]
   \   000000C8   04005CE3           CMP      R12,#+4
   \   000000CC   885085E0           ADD      R5,R5,R8, LSL #+1
   \   000000D0   0780A0E1           MOV      R8,R7
   \   000000D4   068068E2           RSB      R8,R8,#+6
   \   000000D8   56880EE0           AND      R8,LR,R6, ASR R8
   \   000000DC   3877A0E1           LSR      R7,R8,R7
   \   000000E0   B070C5E1           STRH     R7,[R5, #+0]
    412                    CurrentPixel = 0;
   \   000000E4   00C0A003           MOVEQ    R12,#+0
    413                    Pixels = *(++p);
   \   000000E8   01E0F305           LDRBEQ   LR,[R3, #+1]!
   \   000000EC   011081E2           ADD      R1,R1,#+1
    414                  }
    415          		  } while (--xsize);
   \   000000F0   014054E2           SUBS     R4,R4,#+1
   \   000000F4   E9FFFF1A           BNE      ??_DrawBitLine2BPP_2
   \   000000F8   F087BDE8           POP      {R4-R10,PC}
    416              }
    417              break;
    418            case LCD_DRAWMODE_TRANS:
    419              if (pTrans) {
   \                     ??_DrawBitLine2BPP_1:
   \   000000FC   C060A0E3           MOV      R6,#+192
   \   00000100   000055E3           CMP      R5,#+0
   \   00000104   1800000A           BEQ      ??_DrawBitLine2BPP_4
    420                do {
    421                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_5:
   \   00000108   03706CE2           RSB      R7,R12,#+3
   \   0000010C   8770A0E1           LSL      R7,R7,#+1
    422                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000110   0780A0E1           MOV      R8,R7
   \   00000114   068068E2           RSB      R8,R8,#+6
   \   00000118   56880EE0           AND      R8,LR,R6, ASR R8
   \   0000011C   3877B0E1           LSRS     R7,R8,R7
    423                  if (Index) {
   \   00000120   0900000A           BEQ      ??_DrawBitLine2BPP_6
    424                    PixelIndex = *(pTrans + Index);
    425                    _SetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000124   088090E5           LDR      R8,[R0, #+8]
   \   00000128   077195E7           LDR      R7,[R5, +R7, LSL #+2]
   \   0000012C   109098E5           LDR      R9,[R8, #+16]
   \   00000130   14A098E5           LDR      R10,[R8, #+20]
   \   00000134   019049E2           SUB      R9,R9,#+1
   \   00000138   029049E0           SUB      R9,R9,R2
   \   0000013C   9A1929E0           MLA      R9,R10,R9,R1
   \   00000140   008098E5           LDR      R8,[R8, #+0]
   \   00000144   898088E0           ADD      R8,R8,R9, LSL #+1
   \   00000148   B070C8E1           STRH     R7,[R8, #+0]
    426                  }
    427                  x++;
    428                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_6:
   \   0000014C   01C08CE2           ADD      R12,R12,#+1
   \   00000150   04005CE3           CMP      R12,#+4
    429                    CurrentPixel = 0;
   \   00000154   00C0A003           MOVEQ    R12,#+0
    430                    Pixels = *(++p);
   \   00000158   01E0F305           LDRBEQ   LR,[R3, #+1]!
   \   0000015C   011081E2           ADD      R1,R1,#+1
    431                  }
    432          		  } while (--xsize);
   \   00000160   014054E2           SUBS     R4,R4,#+1
   \   00000164   E7FFFF1A           BNE      ??_DrawBitLine2BPP_5
   \   00000168   F087BDE8           POP      {R4-R10,PC}
    433              } else {
    434                do {
    435                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_4:
   \   0000016C   03506CE2           RSB      R5,R12,#+3
   \   00000170   8570A0E1           LSL      R7,R5,#+1
    436                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000174   0750A0E1           MOV      R5,R7
   \   00000178   065065E2           RSB      R5,R5,#+6
   \   0000017C   56550EE0           AND      R5,LR,R6, ASR R5
   \   00000180   3577B0E1           LSRS     R7,R5,R7
    437                  if (Index) {
   \   00000184   0800000A           BEQ      ??_DrawBitLine2BPP_7
    438                    _SetPixelIndex(pDevice, x, y, Index);
   \   00000188   085090E5           LDR      R5,[R0, #+8]
   \   0000018C   108095E5           LDR      R8,[R5, #+16]
   \   00000190   149095E5           LDR      R9,[R5, #+20]
   \   00000194   018048E2           SUB      R8,R8,#+1
   \   00000198   028048E0           SUB      R8,R8,R2
   \   0000019C   991828E0           MLA      R8,R9,R8,R1
   \   000001A0   005095E5           LDR      R5,[R5, #+0]
   \   000001A4   885085E0           ADD      R5,R5,R8, LSL #+1
   \   000001A8   B070C5E1           STRH     R7,[R5, #+0]
    439                  }
    440                  x++;
    441                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_7:
   \   000001AC   01C08CE2           ADD      R12,R12,#+1
   \   000001B0   04005CE3           CMP      R12,#+4
    442                    CurrentPixel = 0;
   \   000001B4   00C0A003           MOVEQ    R12,#+0
    443                    Pixels = *(++p);
   \   000001B8   01E0F305           LDRBEQ   LR,[R3, #+1]!
   \   000001BC   011081E2           ADD      R1,R1,#+1
    444                  }
    445          		  } while (--xsize);
   \   000001C0   014054E2           SUBS     R4,R4,#+1
   \   000001C4   E8FFFF1A           BNE      ??_DrawBitLine2BPP_4
    446              }
    447              break;
    448            }
    449          }
   \   000001C8   F087BDE8           POP      {R4-R10,PC}      ;; return
    450          
    451          /*********************************************************************
    452          *
    453          *       Draw Bitmap 4 BPP, not optimized
    454          */

   \                                 In section .text, align 4, keep-with-next
    455          static void  _DrawBitLine4BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine4BPP:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    456            LCD_PIXELINDEX Pixels, PixelIndex;
    457            int CurrentPixel, Shift, Index;
    458            Pixels       = *p;
    459            CurrentPixel = Diff;
    460            x           += Diff;
    461            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000004   ........           LDR      R6,??DataTable15
   \   00000008   20C09DE5           LDR      R12,[SP, #+32]
   \   0000000C   1060D6E5           LDRB     R6,[R6, #+16]
   \   00000010   24409DE5           LDR      R4,[SP, #+36]
   \   00000014   28509DE5           LDR      R5,[SP, #+40]
   \   00000018   00E0D3E5           LDRB     LR,[R3, #+0]
   \   0000001C   01108CE0           ADD      R1,R12,R1
   \   00000020   036016E2           ANDS     R6,R6,#0x3
   \   00000024   0200000A           BEQ      ??_DrawBitLine4BPP_0
   \   00000028   026056E2           SUBS     R6,R6,#+2
   \   0000002C   3200000A           BEQ      ??_DrawBitLine4BPP_1
   \   00000030   F087BDE8           POP      {R4-R10,PC}
    462            case 0:
    463              if (pTrans) {
   \                     ??_DrawBitLine4BPP_0:
   \   00000034   F060A0E3           MOV      R6,#+240
   \   00000038   000055E3           CMP      R5,#+0
   \   0000003C   1700000A           BEQ      ??_DrawBitLine4BPP_2
    464                do {
    465                  Shift = (1 - CurrentPixel) << 2;
    466                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    467                  PixelIndex = *(pTrans + Index);
    468                  _SetPixelIndex(pDevice, x++, y, PixelIndex);
   \                     ??_DrawBitLine4BPP_3:
   \   00000040   088090E5           LDR      R8,[R0, #+8]
   \   00000044   01706CE2           RSB      R7,R12,#+1
   \   00000048   109098E5           LDR      R9,[R8, #+16]
   \   0000004C   14A098E5           LDR      R10,[R8, #+20]
   \   00000050   019049E2           SUB      R9,R9,#+1
   \   00000054   029049E0           SUB      R9,R9,R2
   \   00000058   9A1929E0           MLA      R9,R10,R9,R1
   \   0000005C   008098E5           LDR      R8,[R8, #+0]
   \   00000060   0771A0E1           LSL      R7,R7,#+2
   \   00000064   898088E0           ADD      R8,R8,R9, LSL #+1
   \   00000068   0790A0E1           MOV      R9,R7
   \   0000006C   049069E2           RSB      R9,R9,#+4
   \   00000070   56990EE0           AND      R9,LR,R6, ASR R9
   \   00000074   3977A0E1           LSR      R7,R9,R7
   \   00000078   077195E7           LDR      R7,[R5, +R7, LSL #+2]
    469                  if (++CurrentPixel == 2) {
   \   0000007C   01C08CE2           ADD      R12,R12,#+1
   \   00000080   B070C8E1           STRH     R7,[R8, #+0]
   \   00000084   02005CE3           CMP      R12,#+2
    470                    CurrentPixel = 0;
   \   00000088   00C0A003           MOVEQ    R12,#+0
    471                    Pixels = *(++p);
   \   0000008C   01E0F305           LDRBEQ   LR,[R3, #+1]!
   \   00000090   011081E2           ADD      R1,R1,#+1
    472                  }
    473          		  } while (--xsize);
   \   00000094   014054E2           SUBS     R4,R4,#+1
   \   00000098   E8FFFF1A           BNE      ??_DrawBitLine4BPP_3
   \   0000009C   F087BDE8           POP      {R4-R10,PC}
    474              } else {
    475                do {
    476                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_2:
   \   000000A0   01506CE2           RSB      R5,R12,#+1
   \   000000A4   0571A0E1           LSL      R7,R5,#+2
    477                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    478                  _SetPixelIndex(pDevice, x++, y, Index);
   \   000000A8   085090E5           LDR      R5,[R0, #+8]
    479                  if (++CurrentPixel == 2) {
   \   000000AC   01C08CE2           ADD      R12,R12,#+1
   \   000000B0   108095E5           LDR      R8,[R5, #+16]
   \   000000B4   149095E5           LDR      R9,[R5, #+20]
   \   000000B8   018048E2           SUB      R8,R8,#+1
   \   000000BC   028048E0           SUB      R8,R8,R2
   \   000000C0   991828E0           MLA      R8,R9,R8,R1
   \   000000C4   005095E5           LDR      R5,[R5, #+0]
   \   000000C8   02005CE3           CMP      R12,#+2
   \   000000CC   885085E0           ADD      R5,R5,R8, LSL #+1
   \   000000D0   0780A0E1           MOV      R8,R7
   \   000000D4   048068E2           RSB      R8,R8,#+4
   \   000000D8   56880EE0           AND      R8,LR,R6, ASR R8
   \   000000DC   3877A0E1           LSR      R7,R8,R7
   \   000000E0   B070C5E1           STRH     R7,[R5, #+0]
    480                    CurrentPixel = 0;
   \   000000E4   00C0A003           MOVEQ    R12,#+0
    481                    Pixels = *(++p);
   \   000000E8   01E0F305           LDRBEQ   LR,[R3, #+1]!
   \   000000EC   011081E2           ADD      R1,R1,#+1
    482                  }
    483          		  } while (--xsize);
   \   000000F0   014054E2           SUBS     R4,R4,#+1
   \   000000F4   E9FFFF1A           BNE      ??_DrawBitLine4BPP_2
   \   000000F8   F087BDE8           POP      {R4-R10,PC}
    484              }
    485              break;
    486            case LCD_DRAWMODE_TRANS:
    487              if (pTrans) {
   \                     ??_DrawBitLine4BPP_1:
   \   000000FC   F060A0E3           MOV      R6,#+240
   \   00000100   000055E3           CMP      R5,#+0
   \   00000104   1800000A           BEQ      ??_DrawBitLine4BPP_4
    488                do {
    489                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_5:
   \   00000108   01706CE2           RSB      R7,R12,#+1
   \   0000010C   0771A0E1           LSL      R7,R7,#+2
    490                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000110   0780A0E1           MOV      R8,R7
   \   00000114   048068E2           RSB      R8,R8,#+4
   \   00000118   56880EE0           AND      R8,LR,R6, ASR R8
   \   0000011C   3877B0E1           LSRS     R7,R8,R7
    491                  if (Index) {
   \   00000120   0900000A           BEQ      ??_DrawBitLine4BPP_6
    492                    PixelIndex = *(pTrans + Index);
    493                    _SetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000124   088090E5           LDR      R8,[R0, #+8]
   \   00000128   077195E7           LDR      R7,[R5, +R7, LSL #+2]
   \   0000012C   109098E5           LDR      R9,[R8, #+16]
   \   00000130   14A098E5           LDR      R10,[R8, #+20]
   \   00000134   019049E2           SUB      R9,R9,#+1
   \   00000138   029049E0           SUB      R9,R9,R2
   \   0000013C   9A1929E0           MLA      R9,R10,R9,R1
   \   00000140   008098E5           LDR      R8,[R8, #+0]
   \   00000144   898088E0           ADD      R8,R8,R9, LSL #+1
   \   00000148   B070C8E1           STRH     R7,[R8, #+0]
    494                  }
    495                  x++;
    496                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_6:
   \   0000014C   01C08CE2           ADD      R12,R12,#+1
   \   00000150   02005CE3           CMP      R12,#+2
    497                    CurrentPixel = 0;
   \   00000154   00C0A003           MOVEQ    R12,#+0
    498                    Pixels = *(++p);
   \   00000158   01E0F305           LDRBEQ   LR,[R3, #+1]!
   \   0000015C   011081E2           ADD      R1,R1,#+1
    499                  }
    500          		  } while (--xsize);
   \   00000160   014054E2           SUBS     R4,R4,#+1
   \   00000164   E7FFFF1A           BNE      ??_DrawBitLine4BPP_5
   \   00000168   F087BDE8           POP      {R4-R10,PC}
    501              } else {
    502                do {
    503                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_4:
   \   0000016C   01506CE2           RSB      R5,R12,#+1
   \   00000170   0571A0E1           LSL      R7,R5,#+2
    504                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000174   0750A0E1           MOV      R5,R7
   \   00000178   045065E2           RSB      R5,R5,#+4
   \   0000017C   56550EE0           AND      R5,LR,R6, ASR R5
   \   00000180   3577B0E1           LSRS     R7,R5,R7
    505                  if (Index) {
   \   00000184   0800000A           BEQ      ??_DrawBitLine4BPP_7
    506                    _SetPixelIndex(pDevice, x, y, Index);
   \   00000188   085090E5           LDR      R5,[R0, #+8]
   \   0000018C   108095E5           LDR      R8,[R5, #+16]
   \   00000190   149095E5           LDR      R9,[R5, #+20]
   \   00000194   018048E2           SUB      R8,R8,#+1
   \   00000198   028048E0           SUB      R8,R8,R2
   \   0000019C   991828E0           MLA      R8,R9,R8,R1
   \   000001A0   005095E5           LDR      R5,[R5, #+0]
   \   000001A4   885085E0           ADD      R5,R5,R8, LSL #+1
   \   000001A8   B070C5E1           STRH     R7,[R5, #+0]
    507                  }
    508                  x++;
    509                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_7:
   \   000001AC   01C08CE2           ADD      R12,R12,#+1
   \   000001B0   02005CE3           CMP      R12,#+2
    510                    CurrentPixel = 0;
   \   000001B4   00C0A003           MOVEQ    R12,#+0
    511                    Pixels = *(++p);
   \   000001B8   01E0F305           LDRBEQ   LR,[R3, #+1]!
   \   000001BC   011081E2           ADD      R1,R1,#+1
    512                  }
    513          		  } while (--xsize);
   \   000001C0   014054E2           SUBS     R4,R4,#+1
   \   000001C4   E8FFFF1A           BNE      ??_DrawBitLine4BPP_4
    514              }
    515              break;
    516            }
    517          }
   \   000001C8   F087BDE8           POP      {R4-R10,PC}      ;; return
    518          
    519          /*********************************************************************
    520          *
    521          *       Draw Bitmap 8 BPP
    522          */

   \                                 In section .text, align 4, keep-with-next
    523          static void  _DrawBitLine8BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine8BPP:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0CE09DE5           LDR      LR,[SP, #+12]
   \   00000008   08C09DE5           LDR      R12,[SP, #+8]
    524            DRIVER_CONTEXT * pContext;
    525            LCD_PIXELINDEX Pixel;
    526            register U32 Off;
    527            U16 * pDest;
    528          
    529            if (!pTrans) {
   \   0000000C   00005EE3           CMP      LR,#+0
   \   00000010   5000000A           BEQ      ??_DrawBitLine8BPP_0
    530              return; // No translation from 8bpp BMP to 16bpp device makes no sense
    531            }
    532            //
    533            // Get context
    534            //
    535            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000014   080090E5           LDR      R0,[R0, #+8]
    536            //
    537            // Mirror y
    538            //
    539            y = (pContext->vySize - 1 - (y));
    540            Off   = XY2OFF16(pContext->vxSizePhys, x,y);
    541            pDest = OFF2PTR16(pContext->VRAMAddr, Off);
   \   00000018   104090E5           LDR      R4,[R0, #+16]
   \   0000001C   014044E2           SUB      R4,R4,#+1
   \   00000020   022044E0           SUB      R2,R4,R2
   \   00000024   144090E5           LDR      R4,[R0, #+20]
   \   00000028   000090E5           LDR      R0,[R0, #+0]
   \   0000002C   941221E0           MLA      R1,R4,R2,R1
   \   00000030   810080E0           ADD      R0,R0,R1, LSL #+1
    542            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000034   ........           LDR      R1,??DataTable15
   \   00000038   1010D1E5           LDRB     R1,[R1, #+16]
   \   0000003C   031011E2           ANDS     R1,R1,#0x3
   \   00000040   0200000A           BEQ      ??_DrawBitLine8BPP_1
   \   00000044   021051E2           SUBS     R1,R1,#+2
   \   00000048   3700000A           BEQ      ??_DrawBitLine8BPP_2
   \   0000004C   1080BDE8           POP      {R4,PC}
    543            case 0:
    544              while (xsize >= 8) {
   \                     ??_DrawBitLine8BPP_1:
   \   00000050   08005CE3           CMP      R12,#+8
   \   00000054   180000AA           BGE      ??_DrawBitLine8BPP_3
   \                     ??_DrawBitLine8BPP_4:
   \   00000058   04005CE3           CMP      R12,#+4
   \   0000005C   0E0000BA           BLT      ??_DrawBitLine8BPP_5
    545                WRITE_MEM16P(pDest + 0, *(pTrans + *(p + 0)));
    546                WRITE_MEM16P(pDest + 1, *(pTrans + *(p + 1)));
    547                WRITE_MEM16P(pDest + 2, *(pTrans + *(p + 2)));
    548                WRITE_MEM16P(pDest + 3, *(pTrans + *(p + 3)));
    549                WRITE_MEM16P(pDest + 4, *(pTrans + *(p + 4)));
    550                WRITE_MEM16P(pDest + 5, *(pTrans + *(p + 5)));
    551                WRITE_MEM16P(pDest + 6, *(pTrans + *(p + 6)));
    552                WRITE_MEM16P(pDest + 7, *(pTrans + *(p + 7)));
    553                xsize -= 8;
    554                p     += 8;
    555                pDest += 8;
    556              }
    557              while (xsize >= 4) {
    558                WRITE_MEM16P(pDest + 0, *(pTrans + *(p + 0)));
   \                     ??_DrawBitLine8BPP_6:
   \   00000060   0110D3E4           LDRB     R1,[R3], #+1
    559                WRITE_MEM16P(pDest + 1, *(pTrans + *(p + 1)));
    560                WRITE_MEM16P(pDest + 2, *(pTrans + *(p + 2)));
    561                WRITE_MEM16P(pDest + 3, *(pTrans + *(p + 3)));
    562                xsize -= 4;
   \   00000064   04C04CE2           SUB      R12,R12,#+4
    563                p     += 4;
    564                pDest += 4;
   \   00000068   04005CE3           CMP      R12,#+4
   \   0000006C   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000070   B210C0E0           STRH     R1,[R0], #+2
   \   00000074   0110D3E4           LDRB     R1,[R3], #+1
   \   00000078   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   0000007C   B210C0E0           STRH     R1,[R0], #+2
   \   00000080   0110D3E4           LDRB     R1,[R3], #+1
   \   00000084   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000088   B210C0E0           STRH     R1,[R0], #+2
   \   0000008C   0110D3E4           LDRB     R1,[R3], #+1
   \   00000090   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000094   B210C0E0           STRH     R1,[R0], #+2
   \   00000098   F0FFFFAA           BGE      ??_DrawBitLine8BPP_6
    565              }
    566              while (xsize) {
   \                     ??_DrawBitLine8BPP_5:
   \   0000009C   00005CE3           CMP      R12,#+0
   \   000000A0   2C00000A           BEQ      ??_DrawBitLine8BPP_0
    567                WRITE_MEM16P(pDest + 0, *(pTrans + *(p + 0)));
   \                     ??_DrawBitLine8BPP_7:
   \   000000A4   0110D3E4           LDRB     R1,[R3], #+1
    568                xsize--;
   \   000000A8   01C05CE2           SUBS     R12,R12,#+1
   \   000000AC   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000B0   B210C0E0           STRH     R1,[R0], #+2
    569                p++;
    570                pDest++;
   \   000000B4   FAFFFF1A           BNE      ??_DrawBitLine8BPP_7
   \   000000B8   1080BDE8           POP      {R4,PC}
    571              }
   \                     ??_DrawBitLine8BPP_3:
   \   000000BC   0110D3E4           LDRB     R1,[R3], #+1
   \   000000C0   08C04CE2           SUB      R12,R12,#+8
   \   000000C4   08005CE3           CMP      R12,#+8
   \   000000C8   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000CC   B210C0E0           STRH     R1,[R0], #+2
   \   000000D0   0110D3E4           LDRB     R1,[R3], #+1
   \   000000D4   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000D8   B210C0E0           STRH     R1,[R0], #+2
   \   000000DC   0110D3E4           LDRB     R1,[R3], #+1
   \   000000E0   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000E4   B210C0E0           STRH     R1,[R0], #+2
   \   000000E8   0110D3E4           LDRB     R1,[R3], #+1
   \   000000EC   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000F0   B210C0E0           STRH     R1,[R0], #+2
   \   000000F4   0110D3E4           LDRB     R1,[R3], #+1
   \   000000F8   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000FC   B210C0E0           STRH     R1,[R0], #+2
   \   00000100   0110D3E4           LDRB     R1,[R3], #+1
   \   00000104   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000108   B210C0E0           STRH     R1,[R0], #+2
   \   0000010C   0110D3E4           LDRB     R1,[R3], #+1
   \   00000110   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000114   B210C0E0           STRH     R1,[R0], #+2
   \   00000118   0110D3E4           LDRB     R1,[R3], #+1
   \   0000011C   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000120   B210C0E0           STRH     R1,[R0], #+2
   \   00000124   E4FFFFAA           BGE      ??_DrawBitLine8BPP_3
   \   00000128   CAFFFFEA           B        ??_DrawBitLine8BPP_4
    572              break;
    573            case LCD_DRAWMODE_TRANS:
    574              for (; xsize > 0; xsize--, p++, pDest++) {
   \                     ??_DrawBitLine8BPP_2:
   \   0000012C   01005CE3           CMP      R12,#+1
   \   00000130   080000BA           BLT      ??_DrawBitLine8BPP_0
    575                Pixel = *p;
    576                if (Pixel) {
   \                     ??_DrawBitLine8BPP_8:
   \   00000134   0010D3E5           LDRB     R1,[R3, #+0]
    577                  WRITE_MEM16P(pDest, *(pTrans + *p));
    578                }
    579              }
   \   00000138   01C04CE2           SUB      R12,R12,#+1
   \   0000013C   013083E2           ADD      R3,R3,#+1
   \   00000140   000051E3           CMP      R1,#+0
   \   00000144   01119E17           LDRNE    R1,[LR, +R1, LSL #+2]
   \   00000148   B010C011           STRHNE   R1,[R0, #+0]
   \   0000014C   020080E2           ADD      R0,R0,#+2
   \   00000150   01005CE3           CMP      R12,#+1
   \   00000154   F6FFFFAA           BGE      ??_DrawBitLine8BPP_8
   \                     ??_DrawBitLine8BPP_0:
   \   00000158   1080BDE8           POP      {R4,PC}          ;; return
    580              break;
    581            }
    582          }
    583          
    584          /*********************************************************************
    585          *
    586          *       Draw Bitmap 16 BPP
    587          */
    588          static void _DrawBitLine16BPP(GUI_DEVICE * pDevice, int x, int y, U16 const GUI_UNI_PTR *p, int xsize) {
    589            DRIVER_CONTEXT * pContext;
    590            U32 Off;
    591            U16 * pDest;
    592          
    593            //
    594            // Get context
    595            //
    596            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    597            //
    598            // Mirror y
    599            //
    600            y = (pContext->vySize - 1 - (y));
    601            Off = XY2OFF16(pContext->vxSizePhys, x,y);
    602            pDest = OFF2PTR16(pContext->VRAMAddr, Off);
    603            GUI_MEMCPY(pDest, (const void *)p, (U32)xsize << 1);
    604          }
    605          
    606          /*********************************************************************
    607          *
    608          *       _DrawBitmap
    609          */

   \                                 In section .text, align 4, keep-with-next
    610          static void _DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0,
    611                                 int xSize, int ySize,
    612                                 int BitsPerPixel, 
    613                                 int BytesPerLine,
    614                                 const U8 GUI_UNI_PTR * pData, int Diff,
    615                                 const LCD_PIXELINDEX* pTrans) {
   \                     _DrawBitmap:
   \   00000000   F44F2DE9           PUSH     {R2,R4-R11,LR}
   \   00000004   18D04DE2           SUB      SP,SP,#+24
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   44109DE5           LDR      R1,[SP, #+68]
   \   00000010   0040A0E1           MOV      R4,R0
    616            int i;
    617          
    618            switch (BitsPerPixel) {
   \   00000014   011041E2           SUB      R1,R1,#+1
   \   00000018   0380A0E1           MOV      R8,R3
   \   0000001C   40009DE5           LDR      R0,[SP, #+64]
   \   00000020   48609DE5           LDR      R6,[SP, #+72]
   \   00000024   4CA09DE5           LDR      R10,[SP, #+76]
   \   00000028   50709DE5           LDR      R7,[SP, #+80]
   \   0000002C   54909DE5           LDR      R9,[SP, #+84]
   \   00000030   0F0051E3           CMP      R1,#+15
   \   00000034   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitmap_0:
   \   00000038   F200008A           BHI      ??_DrawBitmap_1
   \   0000003C   0E0000EA           B        ??_DrawBitmap_2
   \   00000040   3A0000EA           B        ??_DrawBitmap_3
   \   00000044   EF0000EA           B        ??_DrawBitmap_1
   \   00000048   650000EA           B        ??_DrawBitmap_4
   \   0000004C   ED0000EA           B        ??_DrawBitmap_1
   \   00000050   EC0000EA           B        ??_DrawBitmap_1
   \   00000054   EB0000EA           B        ??_DrawBitmap_1
   \   00000058   8E0000EA           B        ??_DrawBitmap_5
   \   0000005C   E90000EA           B        ??_DrawBitmap_1
   \   00000060   E80000EA           B        ??_DrawBitmap_1
   \   00000064   E70000EA           B        ??_DrawBitmap_1
   \   00000068   E60000EA           B        ??_DrawBitmap_1
   \   0000006C   E50000EA           B        ??_DrawBitmap_1
   \   00000070   E40000EA           B        ??_DrawBitmap_1
   \   00000074   E30000EA           B        ??_DrawBitmap_1
   \   00000078   AB0000EA           B        ??_DrawBitmap_6
    619            case 1:
    620              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_2:
   \   0000007C   010050E3           CMP      R0,#+1
   \   00000080   E00000BA           BLT      ??_DrawBitmap_1
   \   00000084   02B0A0E1           MOV      R11,R2
   \   00000088   10008DE5           STR      R0,[SP, #+16]
   \   0000008C   010010E3           TST      R0,#0x1
   \   00000090   0800000A           BEQ      ??_DrawBitmap_7
    621                _DrawBitLine1BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   00000094   08908DE5           STR      R9,[SP, #+8]
   \   00000098   04808DE5           STR      R8,[SP, #+4]
   \   0000009C   00708DE5           STR      R7,[SP, #+0]
   \   000000A0   0A30A0E1           MOV      R3,R10
   \   000000A4   0510A0E1           MOV      R1,R5
   \   000000A8   0400A0E1           MOV      R0,R4
   \   000000AC   ........           BL       _DrawBitLine1BPP
    622                pData += BytesPerLine;
   \   000000B0   0AA086E0           ADD      R10,R6,R10
   \   000000B4   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_7:
   \   000000B8   10109DE5           LDR      R1,[SP, #+16]
   \   000000BC   A110A0E1           LSR      R1,R1,#+1
   \   000000C0   0C108DE5           STR      R1,[SP, #+12]
   \   000000C4   000051E3           CMP      R1,#+0
   \   000000C8   CE00000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_8:
   \   000000CC   08908DE5           STR      R9,[SP, #+8]
   \   000000D0   04808DE5           STR      R8,[SP, #+4]
   \   000000D4   00708DE5           STR      R7,[SP, #+0]
   \   000000D8   0A30A0E1           MOV      R3,R10
   \   000000DC   0B20A0E1           MOV      R2,R11
   \   000000E0   0510A0E1           MOV      R1,R5
   \   000000E4   0400A0E1           MOV      R0,R4
   \   000000E8   ........           BL       _DrawBitLine1BPP
   \   000000EC   0AA086E0           ADD      R10,R6,R10
   \   000000F0   08908DE5           STR      R9,[SP, #+8]
   \   000000F4   04808DE5           STR      R8,[SP, #+4]
   \   000000F8   00708DE5           STR      R7,[SP, #+0]
   \   000000FC   0A30A0E1           MOV      R3,R10
   \   00000100   01208BE2           ADD      R2,R11,#+1
   \   00000104   0510A0E1           MOV      R1,R5
   \   00000108   0400A0E1           MOV      R0,R4
   \   0000010C   ........           BL       _DrawBitLine1BPP
    623              }
   \   00000110   0C109DE5           LDR      R1,[SP, #+12]
   \   00000114   0AA086E0           ADD      R10,R6,R10
   \   00000118   011041E2           SUB      R1,R1,#+1
   \   0000011C   0C108DE5           STR      R1,[SP, #+12]
   \   00000120   02B08BE2           ADD      R11,R11,#+2
   \   00000124   000051E3           CMP      R1,#+0
   \   00000128   E7FFFF1A           BNE      ??_DrawBitmap_8
   \   0000012C   B50000EA           B        ??_DrawBitmap_1
    624              break;
    625            case 2:
    626              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_3:
   \   00000130   010050E3           CMP      R0,#+1
   \   00000134   B30000BA           BLT      ??_DrawBitmap_1
   \   00000138   02B0A0E1           MOV      R11,R2
   \   0000013C   10008DE5           STR      R0,[SP, #+16]
   \   00000140   010010E3           TST      R0,#0x1
   \   00000144   0800000A           BEQ      ??_DrawBitmap_9
    627                _DrawBitLine2BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   00000148   08908DE5           STR      R9,[SP, #+8]
   \   0000014C   04808DE5           STR      R8,[SP, #+4]
   \   00000150   00708DE5           STR      R7,[SP, #+0]
   \   00000154   0A30A0E1           MOV      R3,R10
   \   00000158   0510A0E1           MOV      R1,R5
   \   0000015C   0400A0E1           MOV      R0,R4
   \   00000160   ........           BL       _DrawBitLine2BPP
    628                pData += BytesPerLine;
   \   00000164   0AA086E0           ADD      R10,R6,R10
   \   00000168   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_9:
   \   0000016C   10109DE5           LDR      R1,[SP, #+16]
   \   00000170   A110A0E1           LSR      R1,R1,#+1
   \   00000174   0C108DE5           STR      R1,[SP, #+12]
   \   00000178   000051E3           CMP      R1,#+0
   \   0000017C   A100000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_10:
   \   00000180   08908DE5           STR      R9,[SP, #+8]
   \   00000184   04808DE5           STR      R8,[SP, #+4]
   \   00000188   00708DE5           STR      R7,[SP, #+0]
   \   0000018C   0A30A0E1           MOV      R3,R10
   \   00000190   0B20A0E1           MOV      R2,R11
   \   00000194   0510A0E1           MOV      R1,R5
   \   00000198   0400A0E1           MOV      R0,R4
   \   0000019C   ........           BL       _DrawBitLine2BPP
   \   000001A0   0AA086E0           ADD      R10,R6,R10
   \   000001A4   08908DE5           STR      R9,[SP, #+8]
   \   000001A8   04808DE5           STR      R8,[SP, #+4]
   \   000001AC   00708DE5           STR      R7,[SP, #+0]
   \   000001B0   0A30A0E1           MOV      R3,R10
   \   000001B4   01208BE2           ADD      R2,R11,#+1
   \   000001B8   0510A0E1           MOV      R1,R5
   \   000001BC   0400A0E1           MOV      R0,R4
   \   000001C0   ........           BL       _DrawBitLine2BPP
    629              }
   \   000001C4   0C109DE5           LDR      R1,[SP, #+12]
   \   000001C8   0AA086E0           ADD      R10,R6,R10
   \   000001CC   011041E2           SUB      R1,R1,#+1
   \   000001D0   0C108DE5           STR      R1,[SP, #+12]
   \   000001D4   02B08BE2           ADD      R11,R11,#+2
   \   000001D8   000051E3           CMP      R1,#+0
   \   000001DC   E7FFFF1A           BNE      ??_DrawBitmap_10
   \   000001E0   880000EA           B        ??_DrawBitmap_1
    630              break;
    631            case 4:
    632              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_4:
   \   000001E4   010050E3           CMP      R0,#+1
   \   000001E8   860000BA           BLT      ??_DrawBitmap_1
   \   000001EC   02B0A0E1           MOV      R11,R2
   \   000001F0   10008DE5           STR      R0,[SP, #+16]
   \   000001F4   010010E3           TST      R0,#0x1
   \   000001F8   0800000A           BEQ      ??_DrawBitmap_11
    633                _DrawBitLine4BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   000001FC   08908DE5           STR      R9,[SP, #+8]
   \   00000200   04808DE5           STR      R8,[SP, #+4]
   \   00000204   00708DE5           STR      R7,[SP, #+0]
   \   00000208   0A30A0E1           MOV      R3,R10
   \   0000020C   0510A0E1           MOV      R1,R5
   \   00000210   0400A0E1           MOV      R0,R4
   \   00000214   ........           BL       _DrawBitLine4BPP
    634                pData += BytesPerLine;
   \   00000218   0AA086E0           ADD      R10,R6,R10
   \   0000021C   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_11:
   \   00000220   10109DE5           LDR      R1,[SP, #+16]
   \   00000224   A110A0E1           LSR      R1,R1,#+1
   \   00000228   0C108DE5           STR      R1,[SP, #+12]
   \   0000022C   000051E3           CMP      R1,#+0
   \   00000230   7400000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_12:
   \   00000234   08908DE5           STR      R9,[SP, #+8]
   \   00000238   04808DE5           STR      R8,[SP, #+4]
   \   0000023C   00708DE5           STR      R7,[SP, #+0]
   \   00000240   0A30A0E1           MOV      R3,R10
   \   00000244   0B20A0E1           MOV      R2,R11
   \   00000248   0510A0E1           MOV      R1,R5
   \   0000024C   0400A0E1           MOV      R0,R4
   \   00000250   ........           BL       _DrawBitLine4BPP
   \   00000254   0AA086E0           ADD      R10,R6,R10
   \   00000258   08908DE5           STR      R9,[SP, #+8]
   \   0000025C   04808DE5           STR      R8,[SP, #+4]
   \   00000260   00708DE5           STR      R7,[SP, #+0]
   \   00000264   0A30A0E1           MOV      R3,R10
   \   00000268   01208BE2           ADD      R2,R11,#+1
   \   0000026C   0510A0E1           MOV      R1,R5
   \   00000270   0400A0E1           MOV      R0,R4
   \   00000274   ........           BL       _DrawBitLine4BPP
    635              }
   \   00000278   0C109DE5           LDR      R1,[SP, #+12]
   \   0000027C   0AA086E0           ADD      R10,R6,R10
   \   00000280   011041E2           SUB      R1,R1,#+1
   \   00000284   0C108DE5           STR      R1,[SP, #+12]
   \   00000288   02B08BE2           ADD      R11,R11,#+2
   \   0000028C   000051E3           CMP      R1,#+0
   \   00000290   E7FFFF1A           BNE      ??_DrawBitmap_12
   \   00000294   5B0000EA           B        ??_DrawBitmap_1
    636              break;
    637            case 8:
    638              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_5:
   \   00000298   010050E3           CMP      R0,#+1
   \   0000029C   590000BA           BLT      ??_DrawBitmap_1
   \   000002A0   0070A0E1           MOV      R7,R0
   \   000002A4   02B0A0E1           MOV      R11,R2
   \   000002A8   010017E3           TST      R7,#0x1
   \   000002AC   0700000A           BEQ      ??_DrawBitmap_13
    639                _DrawBitLine8BPP(pDevice, x0, i + y0, pData, xSize, pTrans);
   \   000002B0   04908DE5           STR      R9,[SP, #+4]
   \   000002B4   00808DE5           STR      R8,[SP, #+0]
   \   000002B8   0A30A0E1           MOV      R3,R10
   \   000002BC   0510A0E1           MOV      R1,R5
   \   000002C0   0400A0E1           MOV      R0,R4
   \   000002C4   ........           BL       _DrawBitLine8BPP
    640                pData += BytesPerLine;
   \   000002C8   0AA086E0           ADD      R10,R6,R10
   \   000002CC   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_13:
   \   000002D0   A770B0E1           LSRS     R7,R7,#+1
   \   000002D4   4B00000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_14:
   \   000002D8   04908DE5           STR      R9,[SP, #+4]
   \   000002DC   00808DE5           STR      R8,[SP, #+0]
   \   000002E0   0A30A0E1           MOV      R3,R10
   \   000002E4   0B20A0E1           MOV      R2,R11
   \   000002E8   0510A0E1           MOV      R1,R5
   \   000002EC   0400A0E1           MOV      R0,R4
   \   000002F0   ........           BL       _DrawBitLine8BPP
   \   000002F4   0AA086E0           ADD      R10,R6,R10
   \   000002F8   04908DE5           STR      R9,[SP, #+4]
   \   000002FC   00808DE5           STR      R8,[SP, #+0]
   \   00000300   0A30A0E1           MOV      R3,R10
   \   00000304   01208BE2           ADD      R2,R11,#+1
   \   00000308   0510A0E1           MOV      R1,R5
   \   0000030C   0400A0E1           MOV      R0,R4
   \   00000310   ........           BL       _DrawBitLine8BPP
    641              }
   \   00000314   017047E2           SUB      R7,R7,#+1
   \   00000318   0AA086E0           ADD      R10,R6,R10
   \   0000031C   02B08BE2           ADD      R11,R11,#+2
   \   00000320   000057E3           CMP      R7,#+0
   \   00000324   EBFFFF1A           BNE      ??_DrawBitmap_14
   \   00000328   360000EA           B        ??_DrawBitmap_1
    642              break;
    643            case 16:
    644              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_6:
   \   0000032C   0090A0E3           MOV      R9,#+0
   \   00000330   010050E3           CMP      R0,#+1
   \   00000334   330000BA           BLT      ??_DrawBitmap_1
   \   00000338   00B0A0E1           MOV      R11,R0
   \   0000033C   8870A0E1           LSL      R7,R8,#+1
   \   00000340   01001BE3           TST      R11,#0x1
   \   00000344   0D00000A           BEQ      ??_DrawBitmap_15
    645                _DrawBitLine16BPP(pDevice, x0, i + y0, (const U16 *)pData, xSize);
   \   00000348   080094E5           LDR      R0,[R4, #+8]
   \   0000034C   18C09DE5           LDR      R12,[SP, #+24]
   \   00000350   103090E5           LDR      R3,[R0, #+16]
   \   00000354   8820A0E1           LSL      R2,R8,#+1
   \   00000358   013043E2           SUB      R3,R3,#+1
   \   0000035C   0C3043E0           SUB      R3,R3,R12
   \   00000360   14C090E5           LDR      R12,[R0, #+20]
   \   00000364   000090E5           LDR      R0,[R0, #+0]
   \   00000368   9C5323E0           MLA      R3,R12,R3,R5
   \   0000036C   0A10A0E1           MOV      R1,R10
   \   00000370   830080E0           ADD      R0,R0,R3, LSL #+1
   \   00000374   ........           BL       __aeabi_memcpy
    646                pData += BytesPerLine;
   \   00000378   0AA086E0           ADD      R10,R6,R10
   \   0000037C   0190A0E3           MOV      R9,#+1
   \                     ??_DrawBitmap_15:
   \   00000380   AB80B0E1           LSRS     R8,R11,#+1
   \   00000384   1F00000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_16:
   \   00000388   080094E5           LDR      R0,[R4, #+8]
   \   0000038C   18C09DE5           LDR      R12,[SP, #+24]
   \   00000390   103090E5           LDR      R3,[R0, #+16]
   \   00000394   0720A0E1           MOV      R2,R7
   \   00000398   013043E2           SUB      R3,R3,#+1
   \   0000039C   093043E0           SUB      R3,R3,R9
   \   000003A0   0C3043E0           SUB      R3,R3,R12
   \   000003A4   14C090E5           LDR      R12,[R0, #+20]
   \   000003A8   000090E5           LDR      R0,[R0, #+0]
   \   000003AC   9C5323E0           MLA      R3,R12,R3,R5
   \   000003B0   0A10A0E1           MOV      R1,R10
   \   000003B4   830080E0           ADD      R0,R0,R3, LSL #+1
   \   000003B8   ........           BL       __aeabi_memcpy
   \   000003BC   080094E5           LDR      R0,[R4, #+8]
   \   000003C0   019089E2           ADD      R9,R9,#+1
   \   000003C4   103090E5           LDR      R3,[R0, #+16]
   \   000003C8   18C09DE5           LDR      R12,[SP, #+24]
   \   000003CC   013043E2           SUB      R3,R3,#+1
   \   000003D0   093043E0           SUB      R3,R3,R9
   \   000003D4   0C3043E0           SUB      R3,R3,R12
   \   000003D8   14C090E5           LDR      R12,[R0, #+20]
   \   000003DC   000090E5           LDR      R0,[R0, #+0]
   \   000003E0   9C5323E0           MLA      R3,R12,R3,R5
   \   000003E4   0AA086E0           ADD      R10,R6,R10
   \   000003E8   0720A0E1           MOV      R2,R7
   \   000003EC   0A10A0E1           MOV      R1,R10
   \   000003F0   830080E0           ADD      R0,R0,R3, LSL #+1
   \   000003F4   ........           BL       __aeabi_memcpy
   \   000003F8   0AA086E0           ADD      R10,R6,R10
    647              }
   \   000003FC   019089E2           ADD      R9,R9,#+1
   \   00000400   018058E2           SUBS     R8,R8,#+1
   \   00000404   DFFFFF1A           BNE      ??_DrawBitmap_16
    648              break;
    649            }
    650          }
   \                     ??_DrawBitmap_1:
   \   00000408   1CD08DE2           ADD      SP,SP,#+28       ;; stack cleaning
   \   0000040C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    651          
    652          /*********************************************************************
    653          *
    654          *       _SetOrg
    655          */

   \                                 In section .text, align 4, keep-with-next
    656          static void _SetOrg(GUI_DEVICE * pDevice, int x, int y) {
   \                     _SetOrg:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    657            #ifndef WIN32
    658              DRIVER_CONTEXT * pContext;
    659            #endif
    660            LCD_X_SETORG_INFO Data = {0};
   \   00000004   ............       ADRL     R12,`?<Constant {0}>`
   \              ....        
   \   0000000C   0CD04DE2           SUB      SP,SP,#+12
   \   00000010   00409CE5           LDR      R4,[R12, #+0]
   \   00000014   04509CE5           LDR      R5,[R12, #+4]
   \   00000018   0D30A0E1           MOV      R3,SP
   \   0000001C   300083E8           STM      R3,{R4,R5}
    661          
    662            #ifdef WIN32
    663              LCDSIM_SetOrg(x, y, pDevice->LayerIndex);
    664            #else
    665              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000020   083090E5           LDR      R3,[R0, #+8]
    666              Data.xPos = x;
   \   00000024   00108DE5           STR      R1,[SP, #+0]
    667              Data.yPos = pContext->vySize - pContext->ySize - y;
   \   00000028   101093E5           LDR      R1,[R3, #+16]
   \   0000002C   083093E5           LDR      R3,[R3, #+8]
   \   00000030   031041E0           SUB      R1,R1,R3
   \   00000034   021041E0           SUB      R1,R1,R2
   \   00000038   04108DE5           STR      R1,[SP, #+4]
    668              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETORG, (void *)&Data);
   \   0000003C   0D20A0E1           MOV      R2,SP
   \   00000040   0310A0E3           MOV      R1,#+3
   \   00000044   180090E5           LDR      R0,[R0, #+24]
   \   00000048   ........           BL       LCD_X_DisplayDriver
    669            #endif
    670          }
   \   0000004C   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000050   3080BDE8           POP      {R4,R5,PC}       ;; return
    671          
    672          /*********************************************************************
    673          *
    674          *       _InitOnce
    675          *
    676          * Purpose:
    677          *   Allocates a fixed block for the context of the driver
    678          *
    679          * Return value:
    680          *   0 on success, 1 on error
    681          */
    682          static int _InitOnce(GUI_DEVICE * pDevice) {
    683            if (pDevice->u.pContext == NULL) {
    684              pDevice->u.pContext = GUI_ALLOC_GetFixedBlock(sizeof(DRIVER_CONTEXT));
    685              GUI__memset((U8 *)pDevice->u.pContext, 0, sizeof(DRIVER_CONTEXT));
    686            }
    687            return pDevice->u.pContext ? 0 : 1;
    688          }
    689          
    690          /*********************************************************************
    691          *
    692          *       _GetRect
    693          */

   \                                 In section .text, align 4, keep-with-next
    694          static void _GetRect(GUI_DEVICE * pDevice, LCD_RECT * pRect) {
    695            DRIVER_CONTEXT * pContext;
    696          
    697            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetRect:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    698            pRect->x0 = 0;
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   B020C1E1           STRH     R2,[R1, #+0]
    699            pRect->y0 = 0;
   \   0000000C   B220C1E1           STRH     R2,[R1, #+2]
    700            pRect->x1 = pContext->vxSize - 1;
   \   00000010   0C2090E5           LDR      R2,[R0, #+12]
   \   00000014   012042E2           SUB      R2,R2,#+1
   \   00000018   B420C1E1           STRH     R2,[R1, #+4]
    701            pRect->y1 = pContext->vySize - 1;
   \   0000001C   100090E5           LDR      R0,[R0, #+16]
   \   00000020   010040E2           SUB      R0,R0,#+1
   \   00000024   B600C1E1           STRH     R0,[R1, #+6]
    702          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
    703          
    704          /*********************************************************************
    705          *
    706          *       _GetDevProp
    707          */

   \                                 In section .text, align 4, keep-with-next
    708          static I32 _GetDevProp(GUI_DEVICE * pDevice, int Index) {
    709            DRIVER_CONTEXT * pContext;
    710          
    711            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    712            switch (Index) {
   \                     _GetDevProp:
   \   00000000   011041E2           SUB      R1,R1,#+1
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   0D0051E3           CMP      R1,#+13
   \   0000000C   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevProp_0:
   \   00000010   1B00008A           BHI      ??_GetDevProp_1
   \   00000014   0C0000EA           B        ??_GetDevProp_2
   \   00000018   0D0000EA           B        ??_GetDevProp_3
   \   0000001C   0E0000EA           B        ??_GetDevProp_4
   \   00000020   0F0000EA           B        ??_GetDevProp_5
   \   00000024   160000EA           B        ??_GetDevProp_1
   \   00000028   150000EA           B        ??_GetDevProp_1
   \   0000002C   140000EA           B        ??_GetDevProp_1
   \   00000030   0D0000EA           B        ??_GetDevProp_6
   \   00000034   0E0000EA           B        ??_GetDevProp_7
   \   00000038   0F0000EA           B        ??_GetDevProp_8
   \   0000003C   0E0000EA           B        ??_GetDevProp_8
   \   00000040   0B0000EA           B        ??_GetDevProp_7
   \   00000044   0C0000EA           B        ??_GetDevProp_8
   \   00000048   090000EA           B        ??_GetDevProp_7
    713            case LCD_DEVCAP_XSIZE:
    714              return pContext->xSize;
   \                     ??_GetDevProp_2:
   \   0000004C   040090E5           LDR      R0,[R0, #+4]
   \   00000050   1EFF2FE1           BX       LR
    715            case LCD_DEVCAP_YSIZE:
    716              return pContext->ySize;
   \                     ??_GetDevProp_3:
   \   00000054   080090E5           LDR      R0,[R0, #+8]
   \   00000058   1EFF2FE1           BX       LR
    717            case LCD_DEVCAP_VXSIZE:
    718              return pContext->vxSize;
   \                     ??_GetDevProp_4:
   \   0000005C   0C0090E5           LDR      R0,[R0, #+12]
   \   00000060   1EFF2FE1           BX       LR
    719            case LCD_DEVCAP_VYSIZE:
    720              return pContext->vySize;
   \                     ??_GetDevProp_5:
   \   00000064   100090E5           LDR      R0,[R0, #+16]
   \   00000068   1EFF2FE1           BX       LR
    721            case LCD_DEVCAP_BITSPERPIXEL:
    722              return 16;
   \                     ??_GetDevProp_6:
   \   0000006C   1000A0E3           MOV      R0,#+16
   \   00000070   1EFF2FE1           BX       LR
    723            case LCD_DEVCAP_NUMCOLORS:
    724              return 0;
   \                     ??_GetDevProp_7:
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   1EFF2FE1           BX       LR
    725            case LCD_DEVCAP_XMAG:
    726              return 1;
   \                     ??_GetDevProp_8:
   \   0000007C   0100A0E3           MOV      R0,#+1
   \   00000080   1EFF2FE1           BX       LR
    727            case LCD_DEVCAP_YMAG:
    728              return 1;
    729            case LCD_DEVCAP_MIRROR_X:
    730              return 0;
    731            case LCD_DEVCAP_MIRROR_Y:
    732              return 1;
    733            case LCD_DEVCAP_SWAP_XY:
    734              return 0;
    735            }
    736            return -1;
   \                     ??_GetDevProp_1:
   \   00000084   0000E0E3           MVN      R0,#+0
   \   00000088   1EFF2FE1           BX       LR               ;; return
    737          }
    738          
    739          /*********************************************************************
    740          *
    741          *       _GetDevData
    742          */

   \                                 In section .text, align 4, keep-with-next
    743          static void * _GetDevData(GUI_DEVICE * pDevice, int Index) {
    744            GUI_USE_PARA(pDevice);
    745            switch (Index) {
   \                     _GetDevData:
   \   00000000   010051E3           CMP      R1,#+1
   \   00000004   0100001A           BNE      ??_GetDevData_0
    746            #if GUI_SUPPORT_MEMDEV
    747              case LCD_DEVDATA_MEMDEV:
    748                return (void *)&GUI_MEMDEV_DEVICE_16;
   \   00000008   ........           LDR      R0,??DataTable16
   \   0000000C   1EFF2FE1           BX       LR
    749            #endif
    750            }
    751            return NULL;
   \                     ??_GetDevData_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
    752          }
    753          
    754          /*********************************************************************
    755          *
    756          *       Static code: Functions available by _GetDevFunc()
    757          *
    758          **********************************************************************
    759          */
    760          /*********************************************************************
    761          *
    762          *       _ReadRect
    763          */

   \                                 In section .text, align 4, keep-with-next
    764          static void _ReadRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer) {
   \                     _ReadRect:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    765            DRIVER_CONTEXT * pContext;
    766            U32 Off;
    767            int x, NumPixelsPerLine;
    768            U16 * p;
    769          
    770            //
    771            // Get context
    772            //
    773            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   10E09DE5           LDR      LR,[SP, #+16]
   \   0000000C   104090E5           LDR      R4,[R0, #+16]
   \   00000010   14C09DE5           LDR      R12,[SP, #+20]
   \   00000014   014044E2           SUB      R4,R4,#+1
   \   00000018   022044E0           SUB      R2,R4,R2
    774            //
    775            // Mirror y
    776            //
    777            y0 = (pContext->vySize - 1 - y0);
    778            y1 = (pContext->vySize - 1 - y1);
   \   0000001C   0EE044E0           SUB      LR,R4,LR
    779            //
    780            p = (U16 *)pBuffer;
    781            x = x0;
   \   00000020   0140A0E1           MOV      R4,R1
    782            do {
    783              Off = XY2OFF16(pContext->vxSizePhys, x0, y0);
    784              NumPixelsPerLine = x1 - x0 + 1;
   \                     ??_ReadRect_0:
   \   00000024   146090E5           LDR      R6,[R0, #+20]
   \   00000028   015043E0           SUB      R5,R3,R1
   \   0000002C   961221E0           MLA      R1,R6,R2,R1
   \   00000030   015085E2           ADD      R5,R5,#+1
   \   00000034   8110A0E1           LSL      R1,R1,#+1
    785              do {
    786                *p++ = READ_MEM16(pContext->VRAMAddr, Off);
   \                     ??_ReadRect_1:
   \   00000038   006090E5           LDR      R6,[R0, #+0]
    787                Off++;
    788              } while (--NumPixelsPerLine);
   \   0000003C   015045E2           SUB      R5,R5,#+1
   \   00000040   B66091E1           LDRH     R6,[R1, +R6]
   \   00000044   021081E2           ADD      R1,R1,#+2
   \   00000048   000055E3           CMP      R5,#+0
   \   0000004C   B260CCE0           STRH     R6,[R12], #+2
   \   00000050   F8FFFF1A           BNE      ??_ReadRect_1
    789              x0 = x;
    790            } while (y0-- > y1);
   \   00000054   0250A0E1           MOV      R5,R2
   \   00000058   0410A0E1           MOV      R1,R4
   \   0000005C   012045E2           SUB      R2,R5,#+1
   \   00000060   05005EE1           CMP      LR,R5
   \   00000064   EEFFFFBA           BLT      ??_ReadRect_0
    791          }
   \   00000068   7080BDE8           POP      {R4-R6,PC}       ;; return
    792          
    793          /*********************************************************************
    794          *
    795          *       _SetVRAMAddr
    796          */

   \                                 In section .text, align 4, keep-with-next
    797          static void _SetVRAMAddr(GUI_DEVICE * pDevice, void * pVRAM) {
   \                     _SetVRAMAddr:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    798            DRIVER_CONTEXT * pContext;
    799            LCD_X_SETVRAMADDR_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {(void *)0}>`
   \              ....        
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   001091E5           LDR      R1,[R1, #+0]
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
    800          
    801            _InitOnce(pDevice);
   \   00000020   080094E5           LDR      R0,[R4, #+8]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0500001A           BNE      ??_SetVRAMAddr_0
   \   0000002C   2C00A0E3           MOV      R0,#+44
   \   00000030   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000034   080084E5           STR      R0,[R4, #+8]
   \   00000038   2C20A0E3           MOV      R2,#+44
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   ........           BL       GUI__memset
    802            if (pDevice->u.pContext) {
   \                     ??_SetVRAMAddr_0:
   \   00000044   080094E5           LDR      R0,[R4, #+8]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0500000A           BEQ      ??_SetVRAMAddr_1
    803              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    804              pContext->VRAMAddr = (U32)pVRAM;
   \   00000050   005080E5           STR      R5,[R0, #+0]
    805              Data.pVRAM = pVRAM;
   \   00000054   00508DE5           STR      R5,[SP, #+0]
    806              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVRAMADDR, (void *)&Data);
   \   00000058   0D20A0E1           MOV      R2,SP
   \   0000005C   0210A0E3           MOV      R1,#+2
   \   00000060   180094E5           LDR      R0,[R4, #+24]
   \   00000064   ........           BL       LCD_X_DisplayDriver
    807            }
    808            #ifdef WIN32
    809              SIM_Lin_SetVRAMAddr(pDevice->LayerIndex, pVRAM);
    810            #endif
    811          }
   \                     ??_SetVRAMAddr_1:
   \   00000068   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000006C   3080BDE8           POP      {R4,R5,PC}       ;; return
    812          
    813          /*********************************************************************
    814          *
    815          *       _SetVSize
    816          */

   \                                 In section .text, align 4, keep-with-next
    817          static void _SetVSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetVSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    818            DRIVER_CONTEXT * pContext;
    819          
    820            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetVSize_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
    821            if (pDevice->u.pContext) {
   \                     ??_SetVSize_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
    822              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    823              pContext->vxSize = xSize;
   \   0000003C   0C508015           STRNE    R5,[R0, #+12]
    824              pContext->vySize = ySize;
   \   00000040   10608015           STRNE    R6,[R0, #+16]
    825              pContext->vxSizePhys = xSize;
   \   00000044   14508015           STRNE    R5,[R0, #+20]
    826            }
    827            #ifdef WIN32
    828              SIM_Lin_SetVRAMSize(pDevice->LayerIndex, xSize, ySize);
    829            #endif
    830          }
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
    831          
    832          /*********************************************************************
    833          *
    834          *       _SetSize
    835          */

   \                                 In section .text, align 4, keep-with-next
    836          static void _SetSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    837            DRIVER_CONTEXT * pContext;
    838            LCD_X_SETSIZE_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_1`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
    839          
    840            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetSize_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
    841            if (pDevice->u.pContext) {
   \                     ??_SetSize_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0A00000A           BEQ      ??_SetSize_1
    842              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    843              if (pContext->vxSizePhys == 0) {
   \   0000005C   141090E5           LDR      R1,[R0, #+20]
    844                pContext->vxSizePhys = xSize;
    845              }
    846              pContext->xSize = xSize;
    847              pContext->ySize = ySize;
    848              Data.xSize = xSize;
    849              Data.ySize = ySize;
    850              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETSIZE, (void *)&Data);
   \   00000060   0D20A0E1           MOV      R2,SP
   \   00000064   000051E3           CMP      R1,#+0
   \   00000068   14508005           STREQ    R5,[R0, #+20]
   \   0000006C   045080E5           STR      R5,[R0, #+4]
   \   00000070   086080E5           STR      R6,[R0, #+8]
   \   00000074   00508DE5           STR      R5,[SP, #+0]
   \   00000078   04608DE5           STR      R6,[SP, #+4]
   \   0000007C   0710A0E3           MOV      R1,#+7
   \   00000080   180094E5           LDR      R0,[R4, #+24]
   \   00000084   ........           BL       LCD_X_DisplayDriver
    851            }
    852          }
   \                     ??_SetSize_1:
   \   00000088   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   0000008C   7080BDE8           POP      {R4-R6,PC}       ;; return
    853          
    854          /*********************************************************************
    855          *
    856          *       _SetPos
    857          */

   \                                 In section .text, align 4, keep-with-next
    858          static void _SetPos(GUI_DEVICE * pDevice, int xPos, int yPos) {
   \                     _SetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    859            DRIVER_CONTEXT * pContext;
    860            LCD_X_SETPOS_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_2`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
    861          
    862            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetPos_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
    863            if (pDevice->u.pContext) {
   \                     ??_SetPos_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0700000A           BEQ      ??_SetPos_1
    864              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    865              pContext->xPos = xPos;
   \   0000005C   185080E5           STR      R5,[R0, #+24]
    866              pContext->yPos = yPos;
   \   00000060   1C6080E5           STR      R6,[R0, #+28]
    867              Data.xPos = xPos;
   \   00000064   00508DE5           STR      R5,[SP, #+0]
    868              Data.yPos = yPos;
   \   00000068   04608DE5           STR      R6,[SP, #+4]
    869              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETPOS, (void *)&Data);
   \   0000006C   0D20A0E1           MOV      R2,SP
   \   00000070   0810A0E3           MOV      R1,#+8
   \   00000074   180094E5           LDR      R0,[R4, #+24]
   \   00000078   ........           BL       LCD_X_DisplayDriver
    870            }
    871          }
   \                     ??_SetPos_1:
   \   0000007C   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000080   7080BDE8           POP      {R4-R6,PC}       ;; return
    872          
    873          /*********************************************************************
    874          *
    875          *       _GetPos
    876          */

   \                                 In section .text, align 4, keep-with-next
    877          static void _GetPos(GUI_DEVICE * pDevice, int * pxPos, int * pyPos) {
   \                     _GetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    878            DRIVER_CONTEXT * pContext;
    879          
    880            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_GetPos_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
    881            if (pDevice->u.pContext) {
   \                     ??_GetPos_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0300000A           BEQ      ??_GetPos_1
    882              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    883              *pxPos = pContext->xPos;
   \   00000040   181090E5           LDR      R1,[R0, #+24]
   \   00000044   001085E5           STR      R1,[R5, #+0]
    884              *pyPos = pContext->yPos;
   \   00000048   1C0090E5           LDR      R0,[R0, #+28]
   \   0000004C   000086E5           STR      R0,[R6, #+0]
    885            }
    886          }
   \                     ??_GetPos_1:
   \   00000050   7080BDE8           POP      {R4-R6,PC}       ;; return
    887          
    888          /*********************************************************************
    889          *
    890          *       _SetAlpha
    891          */

   \                                 In section .text, align 4, keep-with-next
    892          static void _SetAlpha(GUI_DEVICE * pDevice, int Alpha) {
   \                     _SetAlpha:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    893            DRIVER_CONTEXT * pContext;
    894            LCD_X_SETALPHA_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_3`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
    895          
    896            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetAlpha_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
    897            if (pDevice->u.pContext) {
   \                     ??_SetAlpha_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetAlpha_1
    898              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    899              pContext->Alpha = Alpha;
   \   0000004C   205080E5           STR      R5,[R0, #+32]
    900              Data.Alpha = Alpha;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
    901              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHA, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0A10A0E3           MOV      R1,#+10
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
    902            }
    903          }
   \                     ??_SetAlpha_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
    904          
    905          /*********************************************************************
    906          *
    907          *       _SetVis
    908          */

   \                                 In section .text, align 4, keep-with-next
    909          static void _SetVis(GUI_DEVICE * pDevice, int OnOff) {
   \                     _SetVis:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    910            DRIVER_CONTEXT * pContext;
    911            LCD_X_SETVIS_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_4`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
    912          
    913            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetVis_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
    914            if (pDevice->u.pContext) {
   \                     ??_SetVis_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetVis_1
    915              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    916              pContext->IsVisible = OnOff;
   \   0000004C   245080E5           STR      R5,[R0, #+36]
    917              Data.OnOff = OnOff;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
    918              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVIS, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0910A0E3           MOV      R1,#+9
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
    919            }
    920          }
   \                     ??_SetVis_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
    921          
    922          /*********************************************************************
    923          *
    924          *       _Init
    925          */

   \                                 In section .text, align 4, keep-with-next
    926          static int  _Init(GUI_DEVICE * pDevice) {
   \                     _Init:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    927            int r;
    928          
    929            r = _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0500001A           BNE      ??_Init_0
   \   00000018   2C00A0E3           MOV      R0,#+44
   \   0000001C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000020   080084E5           STR      R0,[R4, #+8]
   \   00000024   2C20A0E3           MOV      R2,#+44
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   ........           BL       GUI__memset
   \                     ??_Init_0:
   \   00000030   080094E5           LDR      R0,[R4, #+8]
    930            r |= LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_INITCONTROLLER, NULL);
    931            return r;
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0150A003           MOVEQ    R5,#+1
   \   00000040   0050A013           MOVNE    R5,#+0
   \   00000044   0110A0E3           MOV      R1,#+1
   \   00000048   180094E5           LDR      R0,[R4, #+24]
   \   0000004C   ........           BL       LCD_X_DisplayDriver
   \   00000050   050080E1           ORR      R0,R0,R5
   \   00000054   04D08DE2           ADD      SP,SP,#+4
   \   00000058   3080BDE8           POP      {R4,R5,PC}       ;; return
    932          }
    933          
    934          /*********************************************************************
    935          *
    936          *       _On
    937          */

   \                                 In section .text, align 4, keep-with-next
    938          static void _On (GUI_DEVICE * pDevice) {
    939            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_ON, NULL);
   \                     _On:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0510A0E3           MOV      R1,#+5
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
    940          }
    941          
    942          /*********************************************************************
    943          *
    944          *       _Off
    945          */

   \                                 In section .text, align 4, keep-with-next
    946          static void _Off (GUI_DEVICE * pDevice) {
    947            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_OFF, NULL);
   \                     _Off:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0610A0E3           MOV      R1,#+6
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
    948          }
    949          
    950          /*********************************************************************
    951          *
    952          *       _SetLUTEntry
    953          */

   \                                 In section .text, align 4, keep-with-next
    954          static void _SetLUTEntry(GUI_DEVICE * pDevice, U8 Pos, LCD_COLOR Color) {
   \                     _SetLUTEntry:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    955            LCD_X_SETLUTENTRY_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
    956          
    957            Data.Pos   = Pos;
   \   0000001C   0410CDE5           STRB     R1,[SP, #+4]
    958            Data.Color = Color;
   \   00000020   00208DE5           STR      R2,[SP, #+0]
    959            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETLUTENTRY, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0410A0E3           MOV      R1,#+4
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
    960          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
    961          
    962          /*********************************************************************
    963          *
    964          *       _SetAlphaMode
    965          */

   \                                 In section .text, align 4, keep-with-next
    966          static void _SetAlphaMode(GUI_DEVICE * pDevice, int AlphaMode) {
   \                     _SetAlphaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
    967            LCD_X_SETALPHAMODE_INFO Data = {0};
    968          
    969            Data.AlphaMode = AlphaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
    970            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0B10A0E3           MOV      R1,#+11
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
    971          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
    972          
    973          /*********************************************************************
    974          *
    975          *       _SetChromaMode
    976          */

   \                                 In section .text, align 4, keep-with-next
    977          static void _SetChromaMode(GUI_DEVICE * pDevice, int ChromaMode) {
   \                     _SetChromaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
    978            LCD_X_SETCHROMAMODE_INFO Data = {0};
    979          
    980            Data.ChromaMode = ChromaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
    981            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0C10A0E3           MOV      R1,#+12
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
    982          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
    983          
    984          /*********************************************************************
    985          *
    986          *       _SetChroma
    987          */

   \                                 In section .text, align 4, keep-with-next
    988          static void _SetChroma(GUI_DEVICE * pDevice, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax) {
   \                     _SetChroma:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    989            LCD_X_SETCHROMA_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>_1`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
    990          
    991            Data.ChromaMin = ChromaMin;
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
    992            Data.ChromaMax = ChromaMax;
   \   00000020   04208DE5           STR      R2,[SP, #+4]
    993            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMA, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0D10A0E3           MOV      R1,#+13
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
    994          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
    995          
    996          /*********************************************************************
    997          *
    998          *       _SetFunc
    999          */

   \                                 In section .text, align 4, keep-with-next
   1000          static void _SetFunc(GUI_DEVICE * pDevice, int Index, void (* pFunc)(void)) {
   \                     _SetFunc:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1001            DRIVER_CONTEXT * pContext;
   1002          
   1003            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetFunc_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
   1004            if (pDevice->u.pContext) {
   \                     ??_SetFunc_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0100000A           BEQ      ??_SetFunc_1
   1005              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1006              switch (Index) {
   \   00000040   170055E3           CMP      R5,#+23
   1007              case LCD_DEVFUNC_FILLRECT:
   1008                pContext->pfFillRect = (void (*)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex))pFunc;
   \   00000044   28608005           STREQ    R6,[R0, #+40]
   1009                break;
   1010              }
   1011            }
   1012          }
   \                     ??_SetFunc_1:
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1013          
   1014          /*********************************************************************
   1015          *
   1016          *       _GetDevFunc
   1017          */

   \                                 In section .text, align 4, keep-with-next
   1018          static void (* _GetDevFunc(GUI_DEVICE ** ppDevice, int Index))(void) {
   1019            GUI_USE_PARA(ppDevice);
   1020            switch (Index) {
   \                     _GetDevFunc:
   \   00000000   011041E2           SUB      R1,R1,#+1
   \   00000004   150051E3           CMP      R1,#+21
   \   00000008   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevFunc_0:
   \   0000000C   3500008A           BHI      ??_GetDevFunc_1
   \   00000010   140000EA           B        ??_GetDevFunc_2
   \   00000014   1F0000EA           B        ??_GetDevFunc_3
   \   00000018   1A0000EA           B        ??_GetDevFunc_4
   \   0000001C   1B0000EA           B        ??_GetDevFunc_5
   \   00000020   300000EA           B        ??_GetDevFunc_1
   \   00000024   1D0000EA           B        ??_GetDevFunc_6
   \   00000028   2E0000EA           B        ??_GetDevFunc_1
   \   0000002C   2D0000EA           B        ??_GetDevFunc_1
   \   00000030   0E0000EA           B        ??_GetDevFunc_7
   \   00000034   0F0000EA           B        ??_GetDevFunc_8
   \   00000038   100000EA           B        ??_GetDevFunc_9
   \   0000003C   190000EA           B        ??_GetDevFunc_10
   \   00000040   280000EA           B        ??_GetDevFunc_1
   \   00000044   190000EA           B        ??_GetDevFunc_11
   \   00000048   1A0000EA           B        ??_GetDevFunc_12
   \   0000004C   1B0000EA           B        ??_GetDevFunc_13
   \   00000050   240000EA           B        ??_GetDevFunc_1
   \   00000054   230000EA           B        ??_GetDevFunc_1
   \   00000058   1A0000EA           B        ??_GetDevFunc_14
   \   0000005C   1B0000EA           B        ??_GetDevFunc_15
   \   00000060   1C0000EA           B        ??_GetDevFunc_16
   \   00000064   1D0000EA           B        ??_GetDevFunc_17
   1021            case LCD_DEVFUNC_READRECT:
   1022              return (void (*)(void))_ReadRect;
   \                     ??_GetDevFunc_2:
   \   00000068   ........           LDR      R0,??DataTable16_1
   \   0000006C   1EFF2FE1           BX       LR
   1023            case LCD_DEVFUNC_SET_VRAM_ADDR:
   1024              return (void (*)(void))_SetVRAMAddr;
   \                     ??_GetDevFunc_7:
   \   00000070   ........           LDR      R0,??DataTable16_2
   \   00000074   1EFF2FE1           BX       LR
   1025            case LCD_DEVFUNC_SET_VSIZE:
   1026              return (void (*)(void))_SetVSize;
   \                     ??_GetDevFunc_8:
   \   00000078   ........           LDR      R0,??DataTable16_3
   \   0000007C   1EFF2FE1           BX       LR
   1027            case LCD_DEVFUNC_SET_SIZE:
   1028              return (void (*)(void))_SetSize;
   \                     ??_GetDevFunc_9:
   \   00000080   ........           LDR      R0,??DataTable16_4
   \   00000084   1EFF2FE1           BX       LR
   1029            case LCD_DEVFUNC_SETPOS:
   1030              return (void (*)(void))_SetPos;
   \                     ??_GetDevFunc_4:
   \   00000088   ........           LDR      R0,??DataTable16_5
   \   0000008C   1EFF2FE1           BX       LR
   1031            case LCD_DEVFUNC_GETPOS:
   1032              return (void (*)(void))_GetPos;
   \                     ??_GetDevFunc_5:
   \   00000090   ........           LDR      R0,??DataTable16_6
   \   00000094   1EFF2FE1           BX       LR
   1033            case LCD_DEVFUNC_SETALPHA:
   1034              return (void (*)(void))_SetAlpha;
   \                     ??_GetDevFunc_3:
   \   00000098   ........           LDR      R0,??DataTable16_7
   \   0000009C   1EFF2FE1           BX       LR
   1035            case LCD_DEVFUNC_SETVIS:
   1036              return (void (*)(void))_SetVis;
   \                     ??_GetDevFunc_6:
   \   000000A0   ........           LDR      R0,??DataTable16_8
   \   000000A4   1EFF2FE1           BX       LR
   1037            case LCD_DEVFUNC_INIT:
   1038              return (void (*)(void))_Init;
   \                     ??_GetDevFunc_10:
   \   000000A8   ........           LDR      R0,??DataTable16_9
   \   000000AC   1EFF2FE1           BX       LR
   1039            case LCD_DEVFUNC_ON:
   1040              return (void (*)(void))_On;
   \                     ??_GetDevFunc_11:
   \   000000B0   ........           LDR      R0,??DataTable16_10
   \   000000B4   1EFF2FE1           BX       LR
   1041            case LCD_DEVFUNC_OFF:
   1042              return (void (*)(void))_Off;
   \                     ??_GetDevFunc_12:
   \   000000B8   ........           LDR      R0,??DataTable16_11
   \   000000BC   1EFF2FE1           BX       LR
   1043            case LCD_DEVFUNC_SETLUTENTRY:
   1044              return (void (*)(void))_SetLUTEntry;
   \                     ??_GetDevFunc_13:
   \   000000C0   ........           LDR      R0,??DataTable16_12
   \   000000C4   1EFF2FE1           BX       LR
   1045          
   1046            case LCD_DEVFUNC_ALPHAMODE:
   1047              return (void (*)(void))_SetAlphaMode;
   \                     ??_GetDevFunc_14:
   \   000000C8   ........           LDR      R0,??DataTable16_13
   \   000000CC   1EFF2FE1           BX       LR
   1048            case LCD_DEVFUNC_CHROMAMODE:
   1049              return (void (*)(void))_SetChromaMode;
   \                     ??_GetDevFunc_15:
   \   000000D0   ........           LDR      R0,??DataTable16_14
   \   000000D4   1EFF2FE1           BX       LR
   1050            case LCD_DEVFUNC_CHROMA:
   1051              return (void (*)(void))_SetChroma;
   \                     ??_GetDevFunc_16:
   \   000000D8   ........           LDR      R0,??DataTable16_15
   \   000000DC   1EFF2FE1           BX       LR
   1052            
   1053            case LCD_DEVFUNC_SETFUNC:
   1054              return (void (*)(void))_SetFunc;
   \                     ??_GetDevFunc_17:
   \   000000E0   ........           LDR      R0,??DataTable16_16
   \   000000E4   1EFF2FE1           BX       LR
   1055            }
   1056            return NULL;
   \                     ??_GetDevFunc_1:
   \   000000E8   0000A0E3           MOV      R0,#+0
   \   000000EC   1EFF2FE1           BX       LR               ;; return
   1057          }
   1058          
   1059          /*********************************************************************
   1060          *
   1061          *       Public data
   1062          *
   1063          **********************************************************************
   1064          */
   1065          /*********************************************************************
   1066          *
   1067          *       GUI_DEVICE_API structure
   1068          */

   \                                 In section .rodata, align 4, keep-with-next
   1069          const GUI_DEVICE_API GUIDRV_Lin_OY_16_API = {
   \                     GUIDRV_Lin_OY_16_API:
   \   00000000                      ; Initializer data, 52 bytes
   \   00000000   00000000....       DC32 0, _DrawBitmap, _DrawHLine, _DrawVLine, _FillRect, _GetPixelIndex, _SetPixelIndex, _XorPixel, _SetOrg, _GetDevFunc
   \              ............
   \              ............
   \              ............
   \              ............
   \              ............
   \              ........    
   \   00000028   ............       DC32 _GetDevProp, _GetDevData, _GetRect
   \              ............

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   ........           DC32     LCD_aMirror

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     GUI_MEMDEV_DEVICE_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   ........           DC32     _ReadRect

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   ........           DC32     _SetVRAMAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   ........           DC32     _SetVSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   ........           DC32     _SetSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   ........           DC32     _SetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   ........           DC32     _GetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   ........           DC32     _SetAlpha

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   ........           DC32     _SetVis

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   ........           DC32     _Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   ........           DC32     _On

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   ........           DC32     _Off

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   ........           DC32     _SetLUTEntry

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   ........           DC32     _SetAlphaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   ........           DC32     _SetChromaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   ........           DC32     _SetChroma

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \   00000000   ........           DC32     _SetFunc

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {(void *)0}>`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_2`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_3`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_4`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0
   1070            //
   1071            // Data
   1072            //
   1073            DEVICE_CLASS_DRIVER,
   1074            //
   1075            // Drawing functions
   1076            //
   1077            _DrawBitmap,
   1078            _DrawHLine,
   1079            _DrawVLine,
   1080            _FillRect,
   1081            _GetPixelIndex,
   1082            _SetPixelIndex,
   1083            _XorPixel,
   1084            //
   1085            // Set origin
   1086            //
   1087            _SetOrg,
   1088            //
   1089            // Request information
   1090            //
   1091            _GetDevFunc,
   1092            _GetDevProp,
   1093            _GetDevData,
   1094            _GetRect,
   1095          };
   1096          
   1097          #else
   1098          
   1099          void GUIDRV_Lin_OY_16_C(void);   // Avoid empty object files
   1100          void GUIDRV_Lin_OY_16_C(void) {}
   1101          
   1102          #endif
   1103          
   1104          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     _DrawBitLine1BPP     32
     _DrawBitLine2BPP     32
     _DrawBitLine4BPP     32
     _DrawBitLine8BPP      8
     _DrawBitmap          64
     _DrawHLine           24
     _DrawVLine           24
     _FillRect            24
     _GetDevData           0
     _GetDevFunc           0
     _GetDevProp           0
     _GetPixelIndex        0
     _GetPos              16
     _GetRect              0
     _Init                16
     _Off                  8
     _On                   8
     _ReadRect            16
     _SetAlpha            16
     _SetAlphaMode         8
     _SetChroma           24
     _SetChromaMode        8
     _SetFunc             16
     _SetLUTEntry         24
     _SetOrg              24
     _SetPixelIndex        0
     _SetPos              24
     _SetSize             24
     _SetVRAMAddr         16
     _SetVSize            16
     _SetVis              16
     _XorPixel            24


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     _SetPixelIndex            40
     _GetPixelIndex            40
     _XorPixel                116
     _DrawHLine               360
     _DrawVLine               220
     _FillRect                 68
     _DrawBitLine1BPP         316
     _DrawBitLine2BPP         460
     _DrawBitLine4BPP         460
     _DrawBitLine8BPP         348
     _DrawBitmap             1040
     _SetOrg                   84
     _GetRect                  44
     _GetDevProp              140
     _GetDevData               24
     _ReadRect                108
     _SetVRAMAddr             112
     _SetVSize                 76
     _SetSize                 144
     _SetPos                  132
     _GetPos                   84
     _SetAlpha                108
     _SetVis                  108
     _Init                     92
     _On                       16
     _Off                      16
     _SetLUTEntry              60
     _SetAlphaMode             36
     _SetChromaMode            36
     _SetChroma                60
     _SetFunc                  76
     _GetDevFunc              240
     GUIDRV_Lin_OY_16_API      52
     ??DataTable15              4
     ??DataTable15_1            4
     ??DataTable15_2            4
     ??DataTable16              4
     ??DataTable16_1            4
     ??DataTable16_2            4
     ??DataTable16_3            4
     ??DataTable16_4            4
     ??DataTable16_5            4
     ??DataTable16_6            4
     ??DataTable16_7            4
     ??DataTable16_8            4
     ??DataTable16_9            4
     ??DataTable16_10           4
     ??DataTable16_11           4
     ??DataTable16_12           4
     ??DataTable16_13           4
     ??DataTable16_14           4
     ??DataTable16_15           4
     ??DataTable16_16           4
     ?<Constant {0}>            8
     ?<Constant {(void *)0}>    4
     ?<Constant {0}>_1          8
     ?<Constant {0}>_2          8
     ?<Constant {0}>_3          4
     ?<Constant {0}>_4          4
     ?<Constant {0L}>           8
     ?<Constant {0L}>_1         8

 
    52 bytes in section .rodata
 5 396 bytes in section .text
 
 5 396 bytes of CODE  memory
    52 bytes of CONST memory

Errors: none
Warnings: none
