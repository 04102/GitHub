###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:13:14 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDEV_StaticDevices.c              #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDEV_StaticDevices.c -D DEBUG=1   #
#                    -D SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D  #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUIDEV_StaticDevices.lst   #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUIDEV_StaticDevices.o      #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDEV_StaticDevices.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDEV_StaticDevices.c
     19          Purpose     : Manages window drawing with memory devices
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <string.h>
     24          #include <stddef.h>
     25          
     26          #include "GUI_Private.h"
     27          
     28          #if (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
     29          
     30          #include "WM_Intern.h"
     31          
     32          #if (WM_SUPPORT_STATIC_MEMDEV)
     33          
     34          /*********************************************************************
     35          *
     36          *       Static data
     37          *
     38          **********************************************************************
     39          */

   \                                 In section .data, align 1
     40          static U8 _FillByte = 0xFF;
   \                     _FillByte:
   \   00000000   FF                 DC8 255
     41          
     42          /*********************************************************************
     43          *
     44          *       Static code
     45          *
     46          **********************************************************************
     47          */
     48          /*********************************************************************
     49          *
     50          *       _GetDistToNextAlpha
     51          */
     52          static int _GetDistToNextAlpha(U32 * pSrc, int NumPixels) {
     53            int r = 0;
     54          
     55            do {
     56              if (((*pSrc++) >> 24) == 0xff) {
     57                break;
     58              }
     59              r++;
     60            } while (--NumPixels);
     61            return r;
     62          }
     63          
     64          /*********************************************************************
     65          *
     66          *       _CopyContent
     67          *
     68          * Purpose:
     69          *   Copies content of source device into destination device with taking
     70          *   account of different sizes and positions.
     71          */

   \                                 In section .text, align 4, keep-with-next
     72          static void _CopyContent(GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst) {
   \                     _CopyContent:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   01B0A0E1           MOV      R11,R1
     73            int x0s, y0s, x0d, y0d, x1s, y1s, x1d, y1d;
     74            int xRem, yRem;
     75            int xSizeSrc, ySizeSrc, xSizeDst, ySizeDst;
     76            int DistToNextAlpha, PixelPerLine;
     77            U32 * pSrc;
     78            U32 * pDst;
     79            U32 * pLineSrc;
     80            U32 * pLineDst;
     81          
     82            //
     83            // Get properties from source device
     84            //
     85            xSizeSrc = GUI_MEMDEV_GetXSize(hSrc);
   \   00000010   ........           BL       GUI_MEMDEV_GetXSize
   \   00000014   04008DE5           STR      R0,[SP, #+4]
     86            ySizeSrc = GUI_MEMDEV_GetYSize(hSrc);
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           BL       GUI_MEMDEV_GetYSize
   \   00000020   0C008DE5           STR      R0,[SP, #+12]
     87            pSrc     = (U32 *)GUI_MEMDEV_GetDataPtr(hSrc);
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       GUI_MEMDEV_GetDataPtr
   \   0000002C   0060A0E1           MOV      R6,R0
     88            x0s      = GUI_MEMDEV_GetXPos(hSrc);
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       GUI_MEMDEV_GetXPos
   \   00000038   0080A0E1           MOV      R8,R0
     89            y0s      = GUI_MEMDEV_GetYPos(hSrc);
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       GUI_MEMDEV_GetYPos
   \   00000044   0040A0E1           MOV      R4,R0
     90            x1s      = x0s + xSizeSrc - 1;
   \   00000048   04009DE5           LDR      R0,[SP, #+4]
     91            y1s      = y0s + ySizeSrc - 1;
   \   0000004C   0C109DE5           LDR      R1,[SP, #+12]
   \   00000050   080080E0           ADD      R0,R0,R8
   \   00000054   041081E0           ADD      R1,R1,R4
   \   00000058   019040E2           SUB      R9,R0,#+1
   \   0000005C   011041E2           SUB      R1,R1,#+1
   \   00000060   00108DE5           STR      R1,[SP, #+0]
     92            //
     93            // Get properties from destination device
     94            //
     95            xSizeDst = GUI_MEMDEV_GetXSize(hDst);
   \   00000064   0B00A0E1           MOV      R0,R11
   \   00000068   ........           BL       GUI_MEMDEV_GetXSize
   \   0000006C   0050A0E1           MOV      R5,R0
     96            ySizeDst = GUI_MEMDEV_GetYSize(hDst);
   \   00000070   0B00A0E1           MOV      R0,R11
   \   00000074   ........           BL       GUI_MEMDEV_GetYSize
   \   00000078   08008DE5           STR      R0,[SP, #+8]
     97            pDst     = (U32 *)GUI_MEMDEV_GetDataPtr(hDst);
   \   0000007C   0B00A0E1           MOV      R0,R11
   \   00000080   ........           BL       GUI_MEMDEV_GetDataPtr
   \   00000084   0070A0E1           MOV      R7,R0
     98            x0d      = GUI_MEMDEV_GetXPos(hDst);
   \   00000088   0B00A0E1           MOV      R0,R11
   \   0000008C   ........           BL       GUI_MEMDEV_GetXPos
   \   00000090   00A0A0E1           MOV      R10,R0
     99            y0d      = GUI_MEMDEV_GetYPos(hDst);
   \   00000094   0B00A0E1           MOV      R0,R11
   \   00000098   ........           BL       GUI_MEMDEV_GetYPos
    100            x1d      = x0d + xSizeDst - 1;
   \   0000009C   0A1085E0           ADD      R1,R5,R10
    101            y1d      = y0d + ySizeDst - 1;
   \   000000A0   08209DE5           LDR      R2,[SP, #+8]
   \   000000A4   011041E2           SUB      R1,R1,#+1
   \   000000A8   002082E0           ADD      R2,R2,R0
    102            //
    103            // Check if something is to do
    104            //
    105            if ((x0s > x1d) || (x1s < x0d) || (y0s > y1d) || (y1s < y0d)) {
   \   000000AC   080051E1           CMP      R1,R8
   \   000000B0   012042E2           SUB      R2,R2,#+1
   \   000000B4   0A0059A1           CMPGE    R9,R10
   \   000000B8   040052A1           CMPGE    R2,R4
   \   000000BC   00309DA5           LDRGE    R3,[SP, #+0]
   \   000000C0   000053A1           CMPGE    R3,R0
   \   000000C4   4D0000BA           BLT      ??_CopyContent_0
    106              return;
    107            }
    108            //
    109            // Adjust source pointer
    110            //
    111            if (x0d > x0s) {
   \   000000C8   0A0058E1           CMP      R8,R10
    112              pSrc += x0d - x0s;
   \   000000CC   08304AB0           SUBLT    R3,R10,R8
   \   000000D0   036186B0           ADDLT    R6,R6,R3, LSL #+2
    113            }
    114            if (y0d > y0s) {
   \   000000D4   000054E1           CMP      R4,R0
   \   000000D8   030000AA           BGE      ??_CopyContent_1
    115              pSrc += (y0d - y0s) * xSizeSrc;
   \   000000DC   04C09DE5           LDR      R12,[SP, #+4]
   \   000000E0   043040E0           SUB      R3,R0,R4
   \   000000E4   9C0303E0           MUL      R3,R12,R3
   \   000000E8   036186E0           ADD      R6,R6,R3, LSL #+2
    116            }
    117            //
    118            // Adjust destination pointer
    119            //
    120            if (x0s > x0d) {
   \                     ??_CopyContent_1:
   \   000000EC   08005AE1           CMP      R10,R8
    121              pDst += x0s - x0d;
   \   000000F0   0A3048B0           SUBLT    R3,R8,R10
   \   000000F4   037187B0           ADDLT    R7,R7,R3, LSL #+2
    122            }
    123            if (y0s > y0d) {
   \   000000F8   040050E1           CMP      R0,R4
    124              pDst += (y0s - y0d) * xSizeDst;
   \   000000FC   003044B0           SUBLT    R3,R4,R0
   \   00000100   950303B0           MULLT    R3,R5,R3
   \   00000104   037187B0           ADDLT    R7,R7,R3, LSL #+2
    125            }
    126            //
    127            // Calculate remaining size
    128            //
    129            if        ((x0d >= x0s) && (x1d >= x1s)) {
   \   00000108   08005AE1           CMP      R10,R8
   \   0000010C   040000BA           BLT      ??_CopyContent_2
   \   00000110   090051E1           CMP      R1,R9
    130              xRem = x1s - x0d + 1;
   \   00000114   0A1049A0           SUBGE    R1,R9,R10
   \   00000118   050000AA           BGE      ??_CopyContent_3
    131            } else if ((x0d >= x0s) && (x1d <= x1s)) {
    132              xRem = xSizeDst;
   \   0000011C   0580A0E1           MOV      R8,R5
   \   00000120   040000EA           B        ??_CopyContent_4
    133            } else if ((x0d <= x0s) && (x1d >= x1s)) {
   \                     ??_CopyContent_2:
   \   00000124   090051E1           CMP      R1,R9
    134              xRem = xSizeSrc;
   \   00000128   04809DA5           LDRGE    R8,[SP, #+4]
   \   0000012C   010000AA           BGE      ??_CopyContent_4
    135            } else if ((x0d <= x0s) && (x1d <= x1s)) {
    136              xRem = x1d - x0s + 1;
   \   00000130   081041E0           SUB      R1,R1,R8
   \                     ??_CopyContent_3:
   \   00000134   018081E2           ADD      R8,R1,#+1
    137            } else {
    138              return; // Never reach
    139            }
    140            if        ((y0d >= y0s) && (y1d >= y1s)) {
   \                     ??_CopyContent_4:
   \   00000138   040050E1           CMP      R0,R4
   \   0000013C   050000BA           BLT      ??_CopyContent_5
   \   00000140   00109DE5           LDR      R1,[SP, #+0]
   \   00000144   010052E1           CMP      R2,R1
    141              yRem = y1s - y0d + 1;
   \   00000148   000041A0           SUBGE    R0,R1,R0
   \   0000014C   060000AA           BGE      ??_CopyContent_6
    142            } else if ((y0d >= y0s) && (y1d <= y1s)) {
    143              yRem = ySizeDst;
   \   00000150   08409DE5           LDR      R4,[SP, #+8]
   \   00000154   050000EA           B        ??_CopyContent_7
    144            } else if ((y0d <= y0s) && (y1d >= y1s)) {
   \                     ??_CopyContent_5:
   \   00000158   00009DE5           LDR      R0,[SP, #+0]
   \   0000015C   000052E1           CMP      R2,R0
    145              yRem = ySizeSrc;
   \   00000160   0C409DA5           LDRGE    R4,[SP, #+12]
   \   00000164   010000AA           BGE      ??_CopyContent_7
    146            } else if ((y0d <= y0s) && (y1d <= y1s)) {
    147              yRem = y1d - y0s + 1;
   \   00000168   040042E0           SUB      R0,R2,R4
   \                     ??_CopyContent_6:
   \   0000016C   014080E2           ADD      R4,R0,#+1
    148            } else {
    149              return; // Never reach
    150            }
    151            PixelPerLine = xRem;
   \                     ??_CopyContent_7:
   \   00000170   00808DE5           STR      R8,[SP, #+0]
    152            do {
    153              xRem     = PixelPerLine;
   \                     ??_CopyContent_8:
   \   00000174   00809DE5           LDR      R8,[SP, #+0]
    154              pLineSrc = pSrc;
   \   00000178   0690A0E1           MOV      R9,R6
    155              pLineDst = pDst;
   \   0000017C   07A0A0E1           MOV      R10,R7
   \   00000180   040000EA           B        ??_CopyContent_9
    156              do {
    157                while (((DistToNextAlpha = _GetDistToNextAlpha(pLineSrc, xRem)) == 0) && xRem) {
   \                     ??_CopyContent_10:
   \   00000184   000058E3           CMP      R8,#+0
   \   00000188   1700000A           BEQ      ??_CopyContent_11
    158                  pLineSrc++;
   \   0000018C   049089E2           ADD      R9,R9,#+4
    159                  pLineDst++;
   \   00000190   04A08AE2           ADD      R10,R10,#+4
    160                  xRem--;
   \   00000194   018048E2           SUB      R8,R8,#+1
    161                }
   \                     ??_CopyContent_9:
   \   00000198   0800A0E1           MOV      R0,R8
   \   0000019C   0910A0E1           MOV      R1,R9
   \   000001A0   00B0A0E3           MOV      R11,#+0
   \                     ??_CopyContent_12:
   \   000001A4   042091E4           LDR      R2,[R1], #+4
   \   000001A8   222CA0E1           LSR      R2,R2,#+24
   \   000001AC   FF0052E3           CMP      R2,#+255
   \   000001B0   01B08B12           ADDNE    R11,R11,#+1
   \   000001B4   01005012           SUBSNE   R0,R0,#+1
   \   000001B8   F9FFFF1A           BNE      ??_CopyContent_12
   \   000001BC   00005BE3           CMP      R11,#+0
   \   000001C0   EFFFFF0A           BEQ      ??_CopyContent_10
    162                if (xRem) {
   \   000001C4   000058E3           CMP      R8,#+0
   \   000001C8   0700000A           BEQ      ??_CopyContent_11
    163                  GUI_MEMCPY(pLineDst, pLineSrc, DistToNextAlpha << 2);
   \   000001CC   0B21A0E1           LSL      R2,R11,#+2
   \   000001D0   0910A0E1           MOV      R1,R9
   \   000001D4   0A00A0E1           MOV      R0,R10
   \   000001D8   ........           BL       __aeabi_memcpy4
    164                  pLineSrc += DistToNextAlpha;
   \   000001DC   0B9189E0           ADD      R9,R9,R11, LSL #+2
    165                  pLineDst += DistToNextAlpha;
   \   000001E0   0BA18AE0           ADD      R10,R10,R11, LSL #+2
    166                  xRem -= DistToNextAlpha;
   \   000001E4   0B8058E0           SUBS     R8,R8,R11
    167                }
    168              } while (xRem);
   \   000001E8   EAFFFF1A           BNE      ??_CopyContent_9
    169              pDst += xSizeDst;
    170              pSrc += xSizeSrc;
   \                     ??_CopyContent_11:
   \   000001EC   04009DE5           LDR      R0,[SP, #+4]
   \   000001F0   057187E0           ADD      R7,R7,R5, LSL #+2
   \   000001F4   006186E0           ADD      R6,R6,R0, LSL #+2
    171            } while (--yRem);
   \   000001F8   014054E2           SUBS     R4,R4,#+1
   \   000001FC   DCFFFF1A           BNE      ??_CopyContent_8
   \                     ??_CopyContent_0:
   \   00000200   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000204   F08FBDE8           POP      {R4-R11,PC}      ;; return
    172          }
    173          
    174          /*********************************************************************
    175          *
    176          *       _CreateStaticDevice
    177          */

   \                                 In section .text, align 4, keep-with-next
    178          static GUI_MEMDEV_Handle _CreateStaticDevice(WM_HWIN hWin, WM_Obj * pWin) {
   \                     _CreateStaticDevice:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    179            U8                * pMem;
    180            GUI_MEMDEV        * pDev;
    181            GUI_MEMDEV_Handle   hMem, hMemOld;
    182            int                 x0, y0, x1, y1, xSizeReq, ySizeReq, xPosMem, yPosMem, xSizeMax, ySizeMax;
    183            WM_HWIN             hDesktop;
    184          
    185            //
    186            // Get the required size of the memory device
    187            //
    188            x0       = pWin->Rect.x0;
   \   00000008   F090D1E1           LDRSH    R9,[R1, #+0]
    189            y0       = pWin->Rect.y0;
    190            x1       = pWin->Rect.x1;
    191            y1       = pWin->Rect.y1;
    192            xSizeReq = x1 - x0 + 1;
   \   0000000C   F400D1E1           LDRSH    R0,[R1, #+4]
   \   00000010   F2A0D1E1           LDRSH    R10,[R1, #+2]
   \   00000014   10D04DE2           SUB      SP,SP,#+16
   \   00000018   090040E0           SUB      R0,R0,R9
   \   0000001C   015080E2           ADD      R5,R0,#+1
    193            ySizeReq = y1 - y0 + 1;
   \   00000020   F600D1E1           LDRSH    R0,[R1, #+6]
    194            //
    195            // Check if there is something to do
    196            //
    197            if ((xSizeReq <= 0) || (ySizeReq <= 0)) {
   \   00000024   010055E3           CMP      R5,#+1
   \   00000028   0A0040E0           SUB      R0,R0,R10
   \   0000002C   016080E2           ADD      R6,R0,#+1
   \   00000030   010056A3           CMPGE    R6,#+1
   \   00000034   010000AA           BGE      ??_CreateStaticDevice_0
    198              return 0; // Nothing to do ...
   \                     ??_CreateStaticDevice_1:
   \   00000038   0000A0E3           MOV      R0,#+0
   \   0000003C   510000EA           B        ??_CreateStaticDevice_2
    199            }
    200            //
    201            // Check if there is already a memory device of the required size and format
    202            //
    203            hMem = pWin->hMem;
   \                     ??_CreateStaticDevice_0:
   \   00000040   248091E5           LDR      R8,[R1, #+36]
    204            if (hMem) {
   \   00000044   000058E3           CMP      R8,#+0
   \   00000048   0C00000A           BEQ      ??_CreateStaticDevice_3
    205              pDev = (GUI_MEMDEV *)GUI_LOCK_H(hMem);
   \   0000004C   0800A0E1           MOV      R0,R8
   \   00000050   ........           BL       GUI_ALLOC_LockH
    206              xPosMem  = pDev->x0;
   \   00000054   F440D0E1           LDRSH    R4,[R0, #+4]
    207              yPosMem  = pDev->y0;
   \   00000058   F650D0E1           LDRSH    R5,[R0, #+6]
    208              GUI_UNLOCK_H(pDev);
   \   0000005C   ........           BL       GUI_ALLOC_UnlockH
    209              if ((xPosMem != x0) || (yPosMem != y0)) {
   \   00000060   090054E1           CMP      R4,R9
   \   00000064   0A005501           CMPEQ    R5,R10
   \   00000068   4500000A           BEQ      ??_CreateStaticDevice_4
    210                GUI_MEMDEV_SetOrg(hMem, x0, y0);
   \   0000006C   0A20A0E1           MOV      R2,R10
   \   00000070   0910A0E1           MOV      R1,R9
   \   00000074   0800A0E1           MOV      R0,R8
   \   00000078   ........           BL       GUI_MEMDEV_SetOrg
   \   0000007C   400000EA           B        ??_CreateStaticDevice_4
    211              }
    212            }
    213            //
    214            // Create memory device (if required)
    215            //
    216            if (hMem == 0) {
    217              //
    218              // !!! Check if the required size is within the legal range !!!
    219              //
    220              // Please note that the default size of the desktop windows is 4095 x 4095.
    221              // When using static memory devices this does not work because it waste too
    222              // much memory. So the size of the desktop windows will be clipped at the
    223              // border of the virtual display.
    224              //
    225              hDesktop = WM_GetDesktopWindow();
    226              if (hWin == hDesktop) {
   \                     ??_CreateStaticDevice_3:
   \   00000080   ........           BL       WM_GetDesktopWindow
   \   00000084   000054E1           CMP      R4,R0
   \   00000088   0E00001A           BNE      ??_CreateStaticDevice_5
    227                xSizeMax = LCD_GetVXSize();
   \   0000008C   ........           BL       LCD_GetVXSize
   \   00000090   0070A0E1           MOV      R7,R0
    228                ySizeMax = LCD_GetVYSize();
   \   00000094   ........           BL       LCD_GetVYSize
    229                if ((xSizeReq > xSizeMax) || (ySizeReq > ySizeMax)) {
   \   00000098   050057E1           CMP      R7,R5
   \   0000009C   020000BA           BLT      ??_CreateStaticDevice_6
   \   000000A0   060050E1           CMP      R0,R6
   \   000000A4   070000AA           BGE      ??_CreateStaticDevice_5
   \   000000A8   000000EA           B        ??_CreateStaticDevice_7
    230                  if (xSizeReq > xSizeMax) {
    231                    xSizeReq = xSizeMax;
   \                     ??_CreateStaticDevice_6:
   \   000000AC   0750A0E1           MOV      R5,R7
    232                  }
    233                  if (ySizeReq > ySizeMax) {
   \                     ??_CreateStaticDevice_7:
   \   000000B0   060050E1           CMP      R0,R6
   \   000000B4   0060A0D1           MOVLE    R6,R0
    234                    ySizeReq = ySizeMax;
    235                  }
    236                  WM_SetSize(hWin, xSizeReq, ySizeReq);
   \   000000B8   0620A0E1           MOV      R2,R6
   \   000000BC   0510A0E1           MOV      R1,R5
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   ........           BL       WM_SetSize
    237                }
    238              }
    239              //
    240              // Create device
    241              //
    242              hMem = GUI_MEMDEV__CreateFixed(x0, y0, xSizeReq, ySizeReq, GUI_MEMDEV_NOTRANS, GUI_MEMDEV_APILIST_32, GUI_COLOR_CONV_8888);
   \                     ??_CreateStaticDevice_5:
   \   000000C8   ........           LDR      R0,??DataTable3
   \   000000CC   0630A0E1           MOV      R3,R6
   \   000000D0   08008DE5           STR      R0,[SP, #+8]
   \   000000D4   ........           LDR      R0,??DataTable3_1
   \   000000D8   0520A0E1           MOV      R2,R5
   \   000000DC   04008DE5           STR      R0,[SP, #+4]
   \   000000E0   0100A0E3           MOV      R0,#+1
   \   000000E4   00008DE5           STR      R0,[SP, #+0]
   \   000000E8   0A10A0E1           MOV      R1,R10
   \   000000EC   0900A0E1           MOV      R0,R9
   \   000000F0   ........           BL       GUI_MEMDEV__CreateFixed
   \   000000F4   0080A0E1           MOV      R8,R0
    243              //
    244              // Recalculate pointer
    245              //
    246              pWin = WM_H2P(hWin);
   \   000000F8   0400A0E1           MOV      R0,R4
   \   000000FC   ........           BL       GUI_ALLOC_h2p
   \   00000100   0070A0E1           MOV      R7,R0
    247              //
    248              // Save handle of memory device
    249              //
    250              pWin->hMem = hMem;
   \   00000104   248087E5           STR      R8,[R7, #+36]
    251              if (!hMem) {
   \   00000108   000058E3           CMP      R8,#+0
   \   0000010C   0300001A           BNE      ??_CreateStaticDevice_8
    252                GUI_DEBUG_ERROROUT("Not enough memory to create static memory device!");
    253                //
    254                // Do the drawing operation without a memory device ...
    255                //
    256                WM__Paint1(hWin, pWin);
   \   00000110   0710A0E1           MOV      R1,R7
   \   00000114   0400A0E1           MOV      R0,R4
   \   00000118   ........           BL       WM__Paint1
    257                //_pfPaint1Func(hWin, pWin);
    258                //
    259                // ... and return
    260                //
    261                return 0; // Not enough memory !
   \   0000011C   C5FFFFEA           B        ??_CreateStaticDevice_1
    262              } else {
    263                //
    264                // Set flag to tell WM that the device has to be deleted in case of invalidation
    265                //
    266                pWin->Status |= WM_CF_STATIC;
   \                     ??_CreateStaticDevice_8:
   \   00000120   280097E5           LDR      R0,[R7, #+40]
   \   00000124   400B80E3           ORR      R0,R0,#0x10000
   \   00000128   280087E5           STR      R0,[R7, #+40]
    267                //
    268                // Get device pointer
    269                //
    270                pDev = (GUI_MEMDEV *)GUI_LOCK_H(hMem);
   \   0000012C   0800A0E1           MOV      R0,R8
   \   00000130   ........           BL       GUI_ALLOC_LockH
    271                GUI_UNLOCK_H(pDev);
   \   00000134   ........           BL       GUI_ALLOC_UnlockH
    272                //
    273                // Here it is important to suppress mixing up colors with the background so that the alpha values will be written
    274                // into the memory device. Mixing up colors will be done when drawing the device.
    275                //
    276                hMemOld = GUI_MEMDEV_Select(hMem);
   \   00000138   0800A0E1           MOV      R0,R8
   \   0000013C   ........           BL       GUI_MEMDEV_Select
   \   00000140   0090A0E1           MOV      R9,R0
    277                GUI__AlphaSuppressMixing(1);
   \   00000144   0100A0E3           MOV      R0,#+1
   \   00000148   ........           BL       GUI__AlphaSuppressMixing
    278                //
    279                // Make sure all pixels are transparent after creating the device
    280                //
    281                pMem = (U8 *)GUI_MEMDEV_GetDataPtr(hMem);
   \   0000014C   0800A0E1           MOV      R0,R8
   \   00000150   ........           BL       GUI_MEMDEV_GetDataPtr
    282                GUI_MEMSET(pMem, _FillByte, (xSizeReq * ySizeReq) << 2);
   \   00000154   960501E0           MUL      R1,R6,R5
   \   00000158   0121A0E1           LSL      R2,R1,#+2
   \   0000015C   ........           LDR      R1,??DataTable3_2
   \   00000160   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000164   ........           BL       GUI__memset
    283                //
    284                // Draw content
    285                //
    286                WM__Paint1(hWin, pWin); // Note: After this function call, the pointer pWin can become invalid!
   \   00000168   0710A0E1           MOV      R1,R7
   \   0000016C   0400A0E1           MOV      R0,R4
   \   00000170   ........           BL       WM__Paint1
    287                //
    288                // Restore previous mode
    289                //
    290                GUI__AlphaSuppressMixing(0);
   \   00000174   0000A0E3           MOV      R0,#+0
   \   00000178   ........           BL       GUI__AlphaSuppressMixing
    291                GUI_MEMDEV_Select(hMemOld);
   \   0000017C   0900A0E1           MOV      R0,R9
   \   00000180   ........           BL       GUI_MEMDEV_Select
    292              }
    293            }
    294            return hMem;
   \                     ??_CreateStaticDevice_4:
   \   00000184   0800A0E1           MOV      R0,R8
   \                     ??_CreateStaticDevice_2:
   \   00000188   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   0000018C   F087BDE8           POP      {R4-R10,PC}      ;; return
    295          }
    296          
    297          /*********************************************************************
    298          *
    299          *       _AddContent
    300          */

   \                                 In section .text, align 4, keep-with-next
    301          static void _AddContent(WM_HWIN hWin, GUI_MEMDEV_Handle * phMem) {
   \                     _AddContent:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    302            int xSize, ySize;
    303            GUI_MEMDEV_Handle hMemDst, hMemSrc;
    304            GUI_RECT Rect;
    305            U8 * pSrc;
    306            U8 * pDst;
    307          
    308            hMemDst = *phMem;
   \   00000008   008095E5           LDR      R8,[R5, #+0]
   \   0000000C   18D04DE2           SUB      SP,SP,#+24
   \   00000010   0040A0E1           MOV      R4,R0
    309            if (hMemDst == 0) {
   \   00000014   000058E3           CMP      R8,#+0
   \   00000018   2900001A           BNE      ??_AddContent_0
    310              WM_GetWindowRectEx(hWin, &Rect);
   \   0000001C   0C108DE2           ADD      R1,SP,#+12
   \   00000020   ........           BL       WM_GetWindowRectEx
    311              xSize = (Rect.x1 - Rect.x0) + 1;
   \   00000024   FC00DDE1           LDRSH    R0,[SP, #+12]
   \   00000028   F011DDE1           LDRSH    R1,[SP, #+16]
    312              ySize = (Rect.y1 - Rect.y0) + 1;
   \   0000002C   F221DDE1           LDRSH    R2,[SP, #+18]
   \   00000030   001041E0           SUB      R1,R1,R0
   \   00000034   016081E2           ADD      R6,R1,#+1
   \   00000038   FE10DDE1           LDRSH    R1,[SP, #+14]
   \   0000003C   012042E0           SUB      R2,R2,R1
   \   00000040   017082E2           ADD      R7,R2,#+1
    313              hMemDst = GUI_MEMDEV_CreateFixed(Rect.x0, Rect.y0, xSize, ySize, 0, &GUI_MEMDEV_DEVICE_32, GUICC_8888);
   \   00000044   ........           LDR      R2,??DataTable3
   \   00000048   0730A0E1           MOV      R3,R7
   \   0000004C   08208DE5           STR      R2,[SP, #+8]
   \   00000050   ........           LDR      R2,??DataTable3_1
   \   00000054   04208DE5           STR      R2,[SP, #+4]
   \   00000058   0020A0E3           MOV      R2,#+0
   \   0000005C   00208DE5           STR      R2,[SP, #+0]
   \   00000060   0620A0E1           MOV      R2,R6
   \   00000064   ........           BL       GUI_MEMDEV_CreateFixed
   \   00000068   0080B0E1           MOVS     R8,R0
    314              if (hMemDst == 0) {
   \   0000006C   2100000A           BEQ      ??_AddContent_1
    315                return;
    316              }
    317              *phMem = hMemDst;
   \   00000070   008085E5           STR      R8,[R5, #+0]
    318              hMemSrc = GUI_MEMDEV_GetStaticDevice(hWin);
   \   00000074   ........           BL       GUI_Lock
   \   00000078   0050A0E3           MOV      R5,#+0
   \   0000007C   000054E3           CMP      R4,#+0
   \   00000080   0200000A           BEQ      ??_AddContent_2
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   ........           BL       GUI_ALLOC_h2p
   \   0000008C   245090E5           LDR      R5,[R0, #+36]
   \                     ??_AddContent_2:
   \   00000090   ........           BL       GUI_Unlock
    319              if (hMemSrc) {
   \   00000094   000055E3           CMP      R5,#+0
   \   00000098   1600000A           BEQ      ??_AddContent_1
    320                pSrc = (U8 *)GUI_MEMDEV_GetDataPtr(hMemSrc);
   \   0000009C   0500A0E1           MOV      R0,R5
   \   000000A0   ........           BL       GUI_MEMDEV_GetDataPtr
   \   000000A4   0040A0E1           MOV      R4,R0
    321                pDst = (U8 *)GUI_MEMDEV_GetDataPtr(hMemDst);
   \   000000A8   0800A0E1           MOV      R0,R8
   \   000000AC   ........           BL       GUI_MEMDEV_GetDataPtr
    322                GUI_MEMCPY(pDst, pSrc, (xSize * ySize) << 2);
   \   000000B0   970601E0           MUL      R1,R7,R6
   \   000000B4   0121A0E1           LSL      R2,R1,#+2
   \   000000B8   0410A0E1           MOV      R1,R4
   \   000000BC   ........           BL       __aeabi_memcpy
    323              }
    324            } else {
   \   000000C0   0C0000EA           B        ??_AddContent_1
    325              hMemSrc = GUI_MEMDEV_GetStaticDevice(hWin);
   \                     ??_AddContent_0:
   \   000000C4   ........           BL       GUI_Lock
   \   000000C8   0050A0E3           MOV      R5,#+0
   \   000000CC   000054E3           CMP      R4,#+0
   \   000000D0   0200000A           BEQ      ??_AddContent_3
   \   000000D4   0400A0E1           MOV      R0,R4
   \   000000D8   ........           BL       GUI_ALLOC_h2p
   \   000000DC   245090E5           LDR      R5,[R0, #+36]
   \                     ??_AddContent_3:
   \   000000E0   ........           BL       GUI_Unlock
    326              if (hMemSrc) {
   \   000000E4   000055E3           CMP      R5,#+0
   \   000000E8   0200000A           BEQ      ??_AddContent_1
    327                _CopyContent(hMemSrc, hMemDst);
   \   000000EC   0810A0E1           MOV      R1,R8
   \   000000F0   0500A0E1           MOV      R0,R5
   \   000000F4   ........           BL       _CopyContent
   \                     ??_AddContent_1:
   \   000000F8   18D08DE2           ADD      SP,SP,#+24       ;; stack cleaning
   \   000000FC   F081BDE8           POP      {R4-R8,PC}       ;; return
    328              }
    329            }
    330          }
    331          
    332          /*********************************************************************
    333          *
    334          *       _GetWindowDevice
    335          */

   \                                 In section .text, align 4, keep-with-next
    336          static void _GetWindowDevice(WM_HWIN hWin, GUI_MEMDEV_Handle * phMem) {
   \                     _GetWindowDevice:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
    337            WM_HWIN hChild;
    338            WM_Obj * pWin;
    339            WM_Obj * pChild;
    340            GUI_RECT Rect;
    341          
    342            pWin = WM_H2P(hWin);
   \   00000010   ........           BL       GUI_ALLOC_h2p
   \   00000014   0060A0E1           MOV      R6,R0
    343            if ((pWin->Status & WM_SF_ISVIS) && (pWin->cb)) {
   \   00000018   2800D6E5           LDRB     R0,[R6, #+40]
   \   0000001C   020010E3           TST      R0,#0x2
   \   00000020   10009615           LDRNE    R0,[R6, #+16]
   \   00000024   00005013           CMPNE    R0,#+0
   \   00000028   1600000A           BEQ      ??_GetWindowDevice_0
    344              Rect = pWin->Rect;
   \   0000002C   0D00A0E1           MOV      R0,SP
   \   00000030   0610A0E1           MOV      R1,R6
   \   00000034   0820A0E3           MOV      R2,#+8
   \   00000038   ........           BL       __aeabi_memcpy
    345              if (WM__ClipAtParentBorders(&Rect, hWin)) {
   \   0000003C   0410A0E1           MOV      R1,R4
   \   00000040   0D00A0E1           MOV      R0,SP
   \   00000044   ........           BL       WM__ClipAtParentBorders
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0D00000A           BEQ      ??_GetWindowDevice_0
    346                _AddContent(hWin, phMem);
   \   00000050   0510A0E1           MOV      R1,R5
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       _AddContent
    347                for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
   \   0000005C   1C4096E5           LDR      R4,[R6, #+28]
   \   00000060   000054E3           CMP      R4,#+0
   \   00000064   0700000A           BEQ      ??_GetWindowDevice_0
    348                  _GetWindowDevice(hChild, phMem);
   \                     ??_GetWindowDevice_1:
   \   00000068   0510A0E1           MOV      R1,R5
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   ........           BL       _GetWindowDevice
    349                  pChild = WM_H2P(hChild);
    350                }
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   ........           BL       GUI_ALLOC_h2p
   \   0000007C   204090E5           LDR      R4,[R0, #+32]
   \   00000080   000054E3           CMP      R4,#+0
   \   00000084   F7FFFF1A           BNE      ??_GetWindowDevice_1
    351              }
    352            }
    353          }
   \                     ??_GetWindowDevice_0:
   \   00000088   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   0000008C   7080BDE8           POP      {R4-R6,PC}       ;; return
    354          
    355          /*********************************************************************
    356          *
    357          *       _CreateStatic
    358          */

   \                                 In section .text, align 4, keep-with-next
    359          static void _CreateStatic(WM_HWIN hWin) {
   \                     _CreateStatic:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0040A0E1           MOV      R4,R0
    360            WM_HWIN hChild;
    361            WM_Obj * pWin;
    362            WM_Obj * pChild;
    363            GUI_RECT Rect;
    364          
    365            pWin = WM_H2P(hWin);
   \   0000000C   ........           BL       GUI_ALLOC_h2p
   \   00000010   0050A0E1           MOV      R5,R0
    366            if ((pWin->Status & WM_SF_ISVIS) && (pWin->cb)) {
   \   00000014   2800D5E5           LDRB     R0,[R5, #+40]
   \   00000018   020010E3           TST      R0,#0x2
   \   0000001C   10009515           LDRNE    R0,[R5, #+16]
   \   00000020   00005013           CMPNE    R0,#+0
   \   00000024   1E00000A           BEQ      ??_CreateStatic_0
    367              Rect = pWin->Rect;
   \   00000028   0D00A0E1           MOV      R0,SP
   \   0000002C   0510A0E1           MOV      R1,R5
   \   00000030   0820A0E3           MOV      R2,#+8
   \   00000034   ........           BL       __aeabi_memcpy
    368              if (WM__ClipAtParentBorders(&Rect, hWin)) {
   \   00000038   0410A0E1           MOV      R1,R4
   \   0000003C   0D00A0E1           MOV      R0,SP
   \   00000040   ........           BL       WM__ClipAtParentBorders
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   1500000A           BEQ      ??_CreateStatic_0
    369                WM_SetDefault();
   \   0000004C   ........           BL       WM_SetDefault
    370                WM_SelectWindow(hWin);
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           BL       WM_SelectWindow
    371                GUI_GotoXY(0,0);
   \   00000058   0010A0E3           MOV      R1,#+0
   \   0000005C   0000A0E3           MOV      R0,#+0
   \   00000060   ........           BL       GUI_GotoXY
    372                _CreateStaticDevice(hWin, pWin);
   \   00000064   0510A0E1           MOV      R1,R5
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   ........           BL       _CreateStaticDevice
    373                _FillByte = 0xFF;
   \   00000070   ........           LDR      R0,??DataTable3_2
   \   00000074   FF10A0E3           MOV      R1,#+255
   \   00000078   0010C0E5           STRB     R1,[R0, #+0]
    374                for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
   \   0000007C   1C4095E5           LDR      R4,[R5, #+28]
   \   00000080   000054E3           CMP      R4,#+0
   \   00000084   0600000A           BEQ      ??_CreateStatic_0
    375                  _CreateStatic(hChild);
   \                     ??_CreateStatic_1:
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   ........           BL       _CreateStatic
    376                  pChild = WM_H2P(hChild);
    377                }
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   ........           BL       GUI_ALLOC_h2p
   \   00000098   204090E5           LDR      R4,[R0, #+32]
   \   0000009C   000054E3           CMP      R4,#+0
   \   000000A0   F8FFFF1A           BNE      ??_CreateStatic_1
    378              }
    379            }
    380          }
   \                     ??_CreateStatic_0:
   \   000000A4   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   000000A8   3080BDE8           POP      {R4,R5,PC}       ;; return
    381          
    382          /*********************************************************************
    383          *
    384          *       Public code
    385          *
    386          **********************************************************************
    387          */
    388          /*********************************************************************
    389          *
    390          *       GUI_MEMDEV_Paint1Static
    391          */

   \                                 In section .text, align 4, keep-with-next
    392          void GUI_MEMDEV_Paint1Static(WM_HWIN hWin, WM_Obj * pWin) {
   \                     GUI_MEMDEV_Paint1Static:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
    393            GUI_MEMDEV_Handle hMem;
    394          
    395            //
    396            // Create static device...
    397            //
    398            hMem = _CreateStaticDevice(hWin, pWin);
   \   00000008   ........           BL       _CreateStaticDevice
    399            //
    400            // ...and write it into currently selected device
    401            //
    402            if (hMem) {
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0000000A           BEQ      ??GUI_MEMDEV_Paint1Static_0
    403              GUI_MEMDEV_Write(hMem);
   \   00000014   ........           BL       GUI_MEMDEV_Write
    404            }
    405          }
   \                     ??GUI_MEMDEV_Paint1Static_0:
   \   00000018   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000001C   0080BDE8           POP      {PC}             ;; return
    406          
    407          /*********************************************************************
    408          *
    409          *       GUI_MEMDEV_CreateStatic
    410          */

   \                                 In section .text, align 4, keep-with-next
    411          void GUI_MEMDEV_CreateStatic(WM_HWIN hWin) {
    412            _FillByte = 0xFF;
   \                     GUI_MEMDEV_CreateStatic:
   \   00000000   ........           LDR      R1,??DataTable3_2
   \   00000004   FF20A0E3           MOV      R2,#+255
   \   00000008   0020C1E5           STRB     R2,[R1, #+0]
    413            _CreateStatic(hWin);
   \   0000000C   ........           B        _CreateStatic    ;; tailcall
    414          }
    415          
    416          /*********************************************************************
    417          *
    418          *       GUI_MEMDEV_GetWindowDevice
    419          */

   \                                 In section .text, align 4, keep-with-next
    420          GUI_MEMDEV_Handle GUI_MEMDEV_GetWindowDevice(WM_HWIN hWin) {
   \                     GUI_MEMDEV_GetWindowDevice:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
    421            GUI_MEMDEV_Handle hMem;
    422            
    423            hMem = 0;
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   00108DE5           STR      R1,[SP, #+0]
    424            _GetWindowDevice(hWin, &hMem);
   \   00000014   ........           BL       GUI_ALLOC_h2p
   \   00000018   0050A0E1           MOV      R5,R0
   \   0000001C   2800D5E5           LDRB     R0,[R5, #+40]
   \   00000020   020010E3           TST      R0,#0x2
   \   00000024   10009515           LDRNE    R0,[R5, #+16]
   \   00000028   00005013           CMPNE    R0,#+0
   \   0000002C   1600000A           BEQ      ??GUI_MEMDEV_GetWindowDevice_0
   \   00000030   04008DE2           ADD      R0,SP,#+4
   \   00000034   0510A0E1           MOV      R1,R5
   \   00000038   0820A0E3           MOV      R2,#+8
   \   0000003C   ........           BL       __aeabi_memcpy
   \   00000040   0410A0E1           MOV      R1,R4
   \   00000044   04008DE2           ADD      R0,SP,#+4
   \   00000048   ........           BL       WM__ClipAtParentBorders
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0D00000A           BEQ      ??GUI_MEMDEV_GetWindowDevice_0
   \   00000054   0D10A0E1           MOV      R1,SP
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           BL       _AddContent
   \   00000060   1C4095E5           LDR      R4,[R5, #+28]
   \   00000064   000054E3           CMP      R4,#+0
   \   00000068   0700000A           BEQ      ??GUI_MEMDEV_GetWindowDevice_0
   \                     ??GUI_MEMDEV_GetWindowDevice_1:
   \   0000006C   0D10A0E1           MOV      R1,SP
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   ........           BL       _GetWindowDevice
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   ........           BL       GUI_ALLOC_h2p
   \   00000080   204090E5           LDR      R4,[R0, #+32]
   \   00000084   000054E3           CMP      R4,#+0
   \   00000088   F7FFFF1A           BNE      ??GUI_MEMDEV_GetWindowDevice_1
    425            return hMem;
   \                     ??GUI_MEMDEV_GetWindowDevice_0:
   \   0000008C   00009DE5           LDR      R0,[SP, #+0]
   \   00000090   0CD08DE2           ADD      SP,SP,#+12
   \   00000094   3080BDE8           POP      {R4,R5,PC}       ;; return
    426          }
    427          
    428          /*********************************************************************
    429          *
    430          *       GUI_MEMDEV_GetStaticDevice
    431          */

   \                                 In section .text, align 4, keep-with-next
    432          GUI_MEMDEV_Handle GUI_MEMDEV_GetStaticDevice(WM_HWIN hWin) {
   \                     GUI_MEMDEV_GetStaticDevice:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
    433            GUI_MEMDEV_Handle hMem;
    434            WM_Obj * pWin;
    435          
    436            GUI_LOCK();
   \   0000000C   ........           BL       GUI_Lock
    437            hMem = 0;
   \   00000010   0050A0E3           MOV      R5,#+0
    438            if (hWin) {
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   0200000A           BEQ      ??GUI_MEMDEV_GetStaticDevice_0
    439              pWin = WM_H2P(hWin);
    440              hMem = pWin->hMem;
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_h2p
   \   00000024   245090E5           LDR      R5,[R0, #+36]
    441            }
    442            GUI_UNLOCK();
   \                     ??GUI_MEMDEV_GetStaticDevice_0:
   \   00000028   ........           BL       GUI_Unlock
    443            return hMem;
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   04D08DE2           ADD      SP,SP,#+4
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
    444          }
    445          
    446          #endif /* WM_SUPPORT_STATIC_MEMDEV */
    447          
    448          void GUIDEV_StaticDevices_C(void);

   \                                 In section .text, align 4, keep-with-next
    449          void GUIDEV_StaticDevices_C(void) {} /* avoid empty object files */
   \                     GUIDEV_StaticDevices_C:
   \   00000000   1EFF2FE1           BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     LCD_API_ColorConv_8888

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   ........           DC32     GUI_MEMDEV_DEVICE_32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   ........           DC32     _FillByte
    450          
    451          #else
    452          
    453          void GUIDEV_StaticDevices_C(void);
    454          void GUIDEV_StaticDevices_C(void) {} /* avoid empty object files */
    455          
    456          #endif /* (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT) */
    457          
    458          /*************************** end of file ****************************/

   Maximum stack usage in bytes:

     Function                   .cstack
     --------                   -------
     GUIDEV_StaticDevices_C          0
     GUI_MEMDEV_CreateStatic         8
     GUI_MEMDEV_GetStaticDevice     16
     GUI_MEMDEV_GetWindowDevice     24
     GUI_MEMDEV_Paint1Static         8
     _AddContent                    48
     _CopyContent                   56
     _CreateStatic                  24
     _CreateStaticDevice            48
     _GetWindowDevice               24


   Section sizes:

     Function/Label             Bytes
     --------------             -----
     _FillByte                     1
     _CopyContent                520
     _CreateStaticDevice         400
     _AddContent                 256
     _GetWindowDevice            144
     _CreateStatic               172
     GUI_MEMDEV_Paint1Static      32
     GUI_MEMDEV_CreateStatic      16
     GUI_MEMDEV_GetWindowDevice  152
     GUI_MEMDEV_GetStaticDevice   56
     GUIDEV_StaticDevices_C        4
     ??DataTable3                  4
     ??DataTable3_1                4
     ??DataTable3_2                4

 
     1 byte  in section .data
 1 764 bytes in section .text
 
 1 764 bytes of CODE memory
     1 byte  of DATA memory

Errors: none
Warnings: none
