###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:09:30 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\FS\FAT_Misc.c                           #
#    Command line =  C:\DUII\TargetHW\FS\FAT_Misc.c -D DEBUG=1 -D             #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\FAT_Misc.lst               #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\FAT_Misc.o                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\FS\FAT_Misc.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          **** emFile file system for embedded applications ****
     13          emFile is protected by international copyright laws. Knowledge of the
     14          source code may not be used to write a similar product. This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : FAT_Misc.c
     19          Purpose     : File system's FAT File System Layer misc routines
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          /*********************************************************************
     24          *
     25          *       #include Section
     26          *
     27          **********************************************************************
     28          */
     29          
     30          #include "FAT_Intern.h"
     31          
     32          /*********************************************************************
     33          *
     34          *       defines, configurable
     35          *
     36          **********************************************************************
     37          */
     38          
     39          /*********************************************************************
     40          *
     41          *       defines, non configurable
     42          *
     43          **********************************************************************
     44          */
     45          
     46          /*********************************************************************
     47          *
     48          *       Public code
     49          *
     50          **********************************************************************
     51          */

   \                                 In section .data, align 4
     52          const FAT_DIRENTRY_API * FAT_pDirEntryAPI = &FAT_SFN_API;
   \                     FAT_pDirEntryAPI:
   \   00000000   ........           DC32 FAT_SFN_API
     53          /*********************************************************************
     54          *
     55          *       Static code
     56          *
     57          **********************************************************************
     58          */
     59          
     60          /*********************************************************************
     61          *
     62          *       _ClusterId2FATOff
     63          *
     64          *  Function description
     65          *
     66          */
     67          static U32 _ClusterId2FATOff(U8 FATType, U32 ClusterId) {
     68            switch (FATType) {
     69            case FS_FAT_TYPE_FAT12:
     70              return ClusterId + (ClusterId >> 1);
     71            case FS_FAT_TYPE_FAT16:
     72              return ClusterId << 1;
     73            }
     74            return ClusterId << 2;
     75          }
     76          
     77          
     78          /*********************************************************************
     79          *
     80          *       _SetFATSector
     81          *
     82          *  Function description
     83          *    Assigns a FAT sector to a sector buffer
     84          */
     85          static void _SetFATSector(FS_SB * pSB, U32 SectorNo, FS_FAT_INFO * pFATInfo) {
     86            FS_USE_PARA(pFATInfo);
     87            FS__SB_SetSector(pSB, SectorNo, FS_SB_TYPE_MANAGEMENT);
     88          #if FS_MAINTAIN_FAT_COPY
     89            FS__SB_SetWriteCopyOff(pSB, pFATInfo->FATSize);
     90          #endif
     91          }
     92          
     93          /*********************************************************************
     94          *
     95          *       _WriteFATEntry
     96          *
     97          *  Parameters
     98          *    ClusterId    Id of the cluster to write. If it is invalid ( == 0), the routine does nothing. This is permitted !
     99          *
    100          *  Function description
    101          *
    102          *  Return value
    103          *    0   O.K.
    104          *    1   Error
    105          *
    106          *  Notes
    107          *    None
    108          */

   \                                 In section .text, align 4, keep-with-next
    109          static char _WriteFATEntry(FS_VOLUME* pVolume, FS_SB * pSB, U32 ClusterId, U32 Value) {
   \                     _WriteFATEntry:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   02B0A0E1           MOV      R11,R2
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0360A0E1           MOV      R6,R3
    110            U32 SectorNo;
    111            U32 Off;          /* Total offset in bytes */
    112            U16 SectorOff;    /* Offset within the sector */
    113            U8 * pData;
    114            FS_FAT_INFO* pFATInfo;
    115            U32 ValueOld;     /* Previous value of this FATEntry */
    116          
    117            if (ClusterId == 0) {
   \   00000018   00005BE3           CMP      R11,#+0
   \   0000001C   0100001A           BNE      ??_WriteFATEntry_0
    118              return 1;               /* Invalid cluster Id, ignore the write */
   \                     ??_WriteFATEntry_1:
   \   00000020   0100A0E3           MOV      R0,#+1
   \   00000024   8C0000EA           B        ??_WriteFATEntry_2
    119            }
    120            pFATInfo = &pVolume->FSInfo.FATInfo;
   \                     ??_WriteFATEntry_0:
   \   00000028   1C7084E2           ADD      R7,R4,#+28
    121          
    122            Off = _ClusterId2FATOff(pFATInfo->FATType, ClusterId);
   \   0000002C   1E00D7E5           LDRB     R0,[R7, #+30]
   \   00000030   0C0050E2           SUBS     R0,R0,#+12
   \   00000034   0300000A           BEQ      ??_WriteFATEntry_3
   \   00000038   040050E2           SUBS     R0,R0,#+4
   \   0000003C   8B90A001           LSLEQ    R9,R11,#+1
   \   00000040   0B91A011           LSLNE    R9,R11,#+2
   \   00000044   000000EA           B        ??_WriteFATEntry_4
   \                     ??_WriteFATEntry_3:
   \   00000048   AB908BE0           ADD      R9,R11,R11, LSR #+1
   \                     ??_WriteFATEntry_4:
   \   0000004C   B600D7E1           LDRH     R0,[R7, #+6]
   \   00000050   101097E5           LDR      R1,[R7, #+16]
   \   00000054   3900A0E1           LSR      R0,R9,R0
   \   00000058   010050E1           CMP      R0,R1
   \   0000005C   EFFFFF2A           BCS      ??_WriteFATEntry_1
    123            if ((Off >> pFATInfo->ldBytesPerSector) >= pFATInfo->FATSize) {
    124              FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_WriteFATEntry is trying to write an entry beyond the FAT.\n"));
    125              return 1;
    126            }
    127            SectorNo = pFATInfo->RsvdSecCnt + (Off >> pFATInfo->ldBytesPerSector);
   \   00000060   BA11D7E1           LDRH     R1,[R7, #+26]
    128            _SetFATSector(pSB, SectorNo, pFATInfo);
   \   00000064   0220A0E3           MOV      R2,#+2
   \   00000068   018080E0           ADD      R8,R0,R1
   \   0000006C   0810A0E1           MOV      R1,R8
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   ........           BL       FS__SB_SetSector
    129            FS__SB_Read(pSB);
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           BL       FS__SB_Read
    130            if (pSB->HasError) {
   \   00000080   0D00D5E5           LDRB     R0,[R5, #+13]
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   E4FFFF1A           BNE      ??_WriteFATEntry_1
    131              return 1;            /* Read failed */
    132            }
    133            SectorOff = (U16)(Off & (pFATInfo->BytesPerSec - 1));
   \   0000008C   B400D7E1           LDRH     R0,[R7, #+4]
    134            pData = pSB->pBuffer + SectorOff;
    135            /*
    136             * Tell lower layer driver about the unused cluster
    137             */
    138            #if FS_SUPPORT_FREE_SECTOR || FS_SUPPORT_CACHE
    139            if (Value == 0) {
   \   00000090   000056E3           CMP      R6,#+0
   \   00000094   010040E2           SUB      R0,R0,#+1
   \   00000098   099000E0           AND      R9,R0,R9
   \   0000009C   0998A0E1           LSL      R9,R9,#+16
   \   000000A0   080095E5           LDR      R0,[R5, #+8]
   \   000000A4   2998A0E1           LSR      R9,R9,#+16
   \   000000A8   00A089E0           ADD      R10,R9,R0
   \   000000AC   0A00001A           BNE      ??_WriteFATEntry_5
   \   000000B0   1C20D7E5           LDRB     R2,[R7, #+28]
   \   000000B4   080097E5           LDR      R0,[R7, #+8]
   \   000000B8   02104BE2           SUB      R1,R11,#+2
   \   000000BC   920121E0           MLA      R1,R2,R1,R0
   \   000000C0   0400A0E1           MOV      R0,R4
    140              U32 Sector;
    141              int    NumSectors;
    142              FS_PARTITION * pPart;
    143              pPart      = &pVolume->Partition;
    144              Sector     = FS_FAT_ClusterId2SectorNo(pFATInfo, ClusterId);
    145              NumSectors = pFATInfo->SecPerClus;
    146              FS_LB_FreePartSectors(pPart, Sector, NumSectors);
   \   000000C4   ........           BL       FS_LB_FreePartSectors
    147            }
    148            #endif
    149            //
    150            // Update FATInfo, NextFreeCluster
    151            //
    152            if (Value == 0) {
    153              if (ClusterId < pFATInfo->NextFreeCluster) {
   \   000000C8   280097E5           LDR      R0,[R7, #+40]
   \   000000CC   00005BE1           CMP      R11,R0
   \   000000D0   0200008A           BHI      ??_WriteFATEntry_6
   \   000000D4   0B00A0E1           MOV      R0,R11
   \   000000D8   000000EA           B        ??_WriteFATEntry_6
    154                pFATInfo->NextFreeCluster = ClusterId;
    155              }
    156            } else {
    157              pFATInfo->NextFreeCluster = ClusterId + 1;
   \                     ??_WriteFATEntry_5:
   \   000000DC   01008BE2           ADD      R0,R11,#+1
   \                     ??_WriteFATEntry_6:
   \   000000E0   280087E5           STR      R0,[R7, #+40]
    158            }
    159            //
    160            // Perform the actual write operation
    161            //
    162            switch (pFATInfo->FATType) {
   \   000000E4   1E00D7E5           LDRB     R0,[R7, #+30]
   \   000000E8   100050E2           SUBS     R0,R0,#+16
   \   000000EC   0800000A           BEQ      ??_WriteFATEntry_7
   \   000000F0   100050E2           SUBS     R0,R0,#+16
   \   000000F4   0E00001A           BNE      ??_WriteFATEntry_8
    163            case FS_FAT_TYPE_FAT32:
    164              ValueOld = FS_LoadU32LE(pData);
   \   000000F8   0A00A0E1           MOV      R0,R10
   \   000000FC   ........           BL       FS_LoadU32LE
   \   00000100   0040A0E1           MOV      R4,R0
    165              FS_StoreU32LE(pData, Value);
   \   00000104   0610A0E1           MOV      R1,R6
   \   00000108   0A00A0E1           MOV      R0,R10
   \   0000010C   ........           BL       FS_StoreU32LE
    166              break;
   \   00000110   330000EA           B        ??_WriteFATEntry_9
    167            case FS_FAT_TYPE_FAT16:
    168              ValueOld = FS_LoadU16LE(pData);
   \                     ??_WriteFATEntry_7:
   \   00000114   0A00A0E1           MOV      R0,R10
   \   00000118   ........           BL       FS_LoadU16LE
   \   0000011C   0040A0E1           MOV      R4,R0
    169              FS_StoreU16LE(pData, (U16)Value);
   \   00000120   0618A0E1           LSL      R1,R6,#+16
   \   00000124   2118A0E1           LSR      R1,R1,#+16
   \   00000128   0A00A0E1           MOV      R0,R10
   \   0000012C   ........           BL       FS_StoreU16LE
    170              break;
   \   00000130   2B0000EA           B        ??_WriteFATEntry_9
    171            default:
    172              FS__SB_MarkDirty(pSB);
   \                     ??_WriteFATEntry_8:
   \   00000134   0500A0E1           MOV      R0,R5
   \   00000138   ........           BL       FS__SB_MarkDirty
    173              if (ClusterId & 1) {
   \   0000013C   0040DAE5           LDRB     R4,[R10, #+0]
   \   00000140   01001BE3           TST      R11,#0x1
   \   00000144   1200000A           BEQ      ??_WriteFATEntry_10
    174                ValueOld = (*pData >> 4);
    175                *pData = (U8)((*pData & 0xf) | ((Value & 0xf) << 4));
   \   00000148   0F0004E2           AND      R0,R4,#0xF
   \   0000014C   060280E1           ORR      R0,R0,R6, LSL #+4
   \   00000150   0100CAE4           STRB     R0,[R10], #+1
    176                pData++;
    177                if (SectorOff == pFATInfo->BytesPerSec - 1) {    /* With Fat12, the next byte could be in the next sector */
   \   00000154   B400D7E1           LDRH     R0,[R7, #+4]
   \   00000158   24B2A0E1           LSR      R11,R4,#+4
   \   0000015C   010040E2           SUB      R0,R0,#+1
   \   00000160   000059E1           CMP      R9,R0
   \   00000164   0600001A           BNE      ??_WriteFATEntry_11
    178                  _SetFATSector(pSB, SectorNo + 1, pFATInfo);
   \   00000168   0220A0E3           MOV      R2,#+2
   \   0000016C   011088E2           ADD      R1,R8,#+1
   \   00000170   0500A0E1           MOV      R0,R5
   \   00000174   ........           BL       FS__SB_SetSector
    179                  FS__SB_Read(pSB);
   \   00000178   0500A0E1           MOV      R0,R5
   \   0000017C   ........           BL       FS__SB_Read
    180                  pData  = pSB->pBuffer;
   \   00000180   08A095E5           LDR      R10,[R5, #+8]
    181                }
    182                ValueOld |= ((unsigned)*pData << 4);
   \                     ??_WriteFATEntry_11:
   \   00000184   0000DAE5           LDRB     R0,[R10, #+0]
   \   00000188   00428BE1           ORR      R4,R11,R0, LSL #+4
    183                *pData = (U8)(Value >> 4);
   \   0000018C   2602A0E1           LSR      R0,R6,#+4
   \   00000190   120000EA           B        ??_WriteFATEntry_12
    184              } else {
    185                ValueOld = *pData;
    186                *pData = (U8)Value;
   \                     ??_WriteFATEntry_10:
   \   00000194   0160CAE4           STRB     R6,[R10], #+1
    187                pData++;
    188                if (SectorOff == pFATInfo->BytesPerSec - 1) {    /* With Fat12, the next byte could be in the next sector */
   \   00000198   B400D7E1           LDRH     R0,[R7, #+4]
   \   0000019C   010040E2           SUB      R0,R0,#+1
   \   000001A0   000059E1           CMP      R9,R0
   \   000001A4   0600001A           BNE      ??_WriteFATEntry_13
    189                  _SetFATSector(pSB, SectorNo + 1, pFATInfo);
   \   000001A8   0220A0E3           MOV      R2,#+2
   \   000001AC   011088E2           ADD      R1,R8,#+1
   \   000001B0   0500A0E1           MOV      R0,R5
   \   000001B4   ........           BL       FS__SB_SetSector
    190                  FS__SB_Read(pSB);
   \   000001B8   0500A0E1           MOV      R0,R5
   \   000001BC   ........           BL       FS__SB_Read
    191                  pData  = pSB->pBuffer;
   \   000001C0   08A095E5           LDR      R10,[R5, #+8]
    192                }
    193                ValueOld |= (*pData & 0xF) << 8;
   \                     ??_WriteFATEntry_13:
   \   000001C4   0000DAE5           LDRB     R0,[R10, #+0]
   \   000001C8   0F1000E2           AND      R1,R0,#0xF
   \   000001CC   014484E1           ORR      R4,R4,R1, LSL #+8
    194                *pData = (U8)((*pData & 0xf0) | ((Value >> 8) & 0xf));
   \   000001D0   2614A0E1           LSR      R1,R6,#+8
   \   000001D4   F00000E2           AND      R0,R0,#0xF0
   \   000001D8   0F1001E2           AND      R1,R1,#0xF
   \   000001DC   000081E1           ORR      R0,R1,R0
   \                     ??_WriteFATEntry_12:
   \   000001E0   0000CAE5           STRB     R0,[R10, #+0]
    195              }
    196            }
    197            FS__SB_MarkDirty(pSB);
   \                     ??_WriteFATEntry_9:
   \   000001E4   0500A0E1           MOV      R0,R5
   \   000001E8   ........           BL       FS__SB_MarkDirty
    198          #if FS_FAT_USE_FSINFO_SECTOR
    199            if (pFATInfo->FATType == FS_FAT_TYPE_FAT32) {
   \   000001EC   1E00D7E5           LDRB     R0,[R7, #+30]
   \   000001F0   200050E3           CMP      R0,#+32
    200              if (pFATInfo->FSInfoSectorIsInvalidated == 0) {
   \   000001F4   BE02D701           LDRHEQ   R0,[R7, #+46]
   \   000001F8   00005003           CMPEQ    R0,#+0
   \   000001FC   0D00001A           BNE      ??_WriteFATEntry_14
    201                FS__SB_SetSector(pSB, pFATInfo->FSInfoSector, FS_SB_TYPE_DATA);
   \   00000200   0020A0E3           MOV      R2,#+0
   \   00000204   BC12D7E1           LDRH     R1,[R7, #+44]
   \   00000208   0500A0E1           MOV      R0,R5
   \   0000020C   ........           BL       FS__SB_SetSector
    202                FS__SB_Read(pSB);
   \   00000210   0500A0E1           MOV      R0,R5
   \   00000214   ........           BL       FS__SB_Read
    203                //
    204                //  To be on the safe side, we invalidate the NumFreeClusters value in
    205                //  the FS info sector.
    206                //  When the drive is not unmounted properly [removing the card without calling
    207                //  FS_Unmount()], the NumFreeClusters value in the FS Info sector is still the same,
    208                //  since it was not updated.
    209                //  When remounting the volume, the value will be interpreted as the correct NumFreeClusters value,
    210                //  even when there are more or less clusters available.
    211                // 
    212                FS_StoreU32LE(&pSB->pBuffer[FSINFO_OFF_FREE_CLUSTERS], INVALID_NUM_FREE_CLUSTERS_VALUE);
   \   00000218   080095E5           LDR      R0,[R5, #+8]
   \   0000021C   0010E0E3           MVN      R1,#+0
   \   00000220   7A0F80E2           ADD      R0,R0,#+488
   \   00000224   ........           BL       FS_StoreU32LE
    213                FS__SB_MarkDirty(pSB);
   \   00000228   0500A0E1           MOV      R0,R5
   \   0000022C   ........           BL       FS__SB_MarkDirty
    214                pFATInfo->FSInfoSectorIsInvalidated = 1;
   \   00000230   0100A0E3           MOV      R0,#+1
   \   00000234   BE02C7E1           STRH     R0,[R7, #+46]
    215              }
    216            }
    217          #endif
    218            //
    219            // Update FATInfo, NumFreeClusters
    220            //
    221            if (pFATInfo->NumFreeClusters != INVALID_NUM_FREE_CLUSTERS_VALUE) {
   \                     ??_WriteFATEntry_14:
   \   00000238   240097E5           LDR      R0,[R7, #+36]
   \   0000023C   010070E3           CMN      R0,#+1
   \   00000240   0300000A           BEQ      ??_WriteFATEntry_15
    222              if (ValueOld) {
   \   00000244   000054E3           CMP      R4,#+0
    223                pFATInfo->NumFreeClusters++;
   \   00000248   01008012           ADDNE    R0,R0,#+1
    224              }
    225              if (Value) {
   \   0000024C   000056E3           CMP      R6,#+0
    226                pFATInfo->NumFreeClusters--;
   \   00000250   01004012           SUBNE    R0,R0,#+1
   \                     ??_WriteFATEntry_15:
   \   00000254   240087E5           STR      R0,[R7, #+36]
    227              }
    228            }
    229            return 0;                   /* O.K. */
   \   00000258   0000A0E3           MOV      R0,#+0
   \                     ??_WriteFATEntry_2:
   \   0000025C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000260   F08FBDE8           POP      {R4-R11,PC}      ;; return
    230          }
    231          
    232          
    233          /*********************************************************************
    234          *
    235          *       _SFN_ReadDirEntryInfo
    236          *
    237          *  Description:
    238          *    Search for short directory entry and store the information
    239          *    in the DirEntryInfo structure.
    240          *
    241          *  Return value:
    242          *    ==-1     - Error, invalid directory or no more entries available
    243          *    == 0     - Success.
    244          *
    245          */

   \                                 In section .text, align 4, keep-with-next
    246          static int _SFN_ReadDirEntryInfo(FS__DIR * pDir, FS_DIRENTRY_INFO * pDirEntryInfo, FS_SB * pSB) {
   \                     _SFN_ReadDirEntryInfo:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    247            FS_FAT_DENTRY  * pDirEntry;
    248            U32              DirIndex;
    249            FS_FAT_INFO    * pFATInfo;
    250            FS_VOLUME      * pVolume;
    251            int              r;
    252          
    253            pVolume    = pDir->pVolume;
    254            pFATInfo   = &pVolume->FSInfo.FATInfo;
    255            DirIndex   = pDir->DirEntryIndex;
    256            r          = -1;
    257            if (DirIndex == 0) {
   \   00000008   B001D4E1           LDRH     R0,[R4, #+16]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0270A0E1           MOV      R7,R2
   \   00000018   188094E5           LDR      R8,[R4, #+24]
   \   0000001C   0090E0E3           MVN      R9,#+0
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0300001A           BNE      ??_SFN_ReadDirEntryInfo_0
    258              FS_FAT_InitDirEntryScan(pFATInfo, &pDir->DirPos, pDir->FirstCluster);
   \   00000028   142094E5           LDR      R2,[R4, #+20]
   \   0000002C   0410A0E1           MOV      R1,R4
   \   00000030   1C0088E2           ADD      R0,R8,#+28
   \   00000034   ........           BL       FS_FAT_InitDirEntryScan
    259            }
    260            do {
    261              pDirEntry = FS_FAT_GetDirEntry(pVolume, pSB, &pDir->DirPos);
   \                     ??_SFN_ReadDirEntryInfo_0:
   \   00000038   0420A0E1           MOV      R2,R4
   \   0000003C   0710A0E1           MOV      R1,R7
   \   00000040   0800A0E1           MOV      R0,R8
   \   00000044   ........           BL       FS_FAT_GetDirEntry
   \   00000048   0060A0E1           MOV      R6,R0
    262              FS_FAT_IncDirPos(&pDir->DirPos);
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       FS_FAT_IncDirPos
    263              if (pDirEntry == 0) {
   \   00000054   000056E3           CMP      R6,#+0
    264                break;
    265              }
    266              if (pDirEntry->data[0] == 0x00) {         /* Last entry found ? */
   \   00000058   0000D615           LDRBNE   R0,[R6, #+0]
   \   0000005C   00005013           CMPNE    R0,#+0
   \   00000060   2F00000A           BEQ      ??_SFN_ReadDirEntryInfo_1
    267                break;
    268              }
    269              if (pDirEntry->data[0] != (U8)0xE5) { /* not a deleted file */
   \   00000064   E50050E3           CMP      R0,#+229
    270                U8 Attrib;
    271                Attrib = pDirEntry->data[DIR_ENTRY_OFF_ATTRIBUTES];
   \   00000068   0B00D615           LDRBNE   R0,[R6, #+11]
    272                if ((Attrib != (FS_FAT_ATTR_LONGNAME)) && ((Attrib & FS_FAT_ATTR_VOLUME_ID) != FS_FAT_ATTR_VOLUME_ID)) { /* Also not a long entry nor a volume id, so it is a valid entry */
   \   0000006C   0F005013           CMPNE    R0,#+15
   \   00000070   F0FFFF0A           BEQ      ??_SFN_ReadDirEntryInfo_0
   \   00000074   080010E3           TST      R0,#0x8
   \   00000078   EEFFFF1A           BNE      ??_SFN_ReadDirEntryInfo_0
    273                  FS_FAT_CopyShortName(pDirEntryInfo->sFileName, (const char*)&pDirEntry->data[0], pDirEntryInfo->SizeofFileName);
   \   0000007C   140095E5           LDR      R0,[R5, #+20]
   \   00000080   181095E5           LDR      R1,[R5, #+24]
   \   00000084   0620A0E1           MOV      R2,R6
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   0900000A           BEQ      ??_SFN_ReadDirEntryInfo_2
   \   00000090   011041E2           SUB      R1,R1,#+1
   \   00000094   0B0051E3           CMP      R1,#+11
   \   00000098   0B10A0A3           MOVGE    R1,#+11
   \   0000009C   0030A0A3           MOVGE    R3,#+0
   \   000000A0   0030A0B3           MOVLT    R3,#+0
   \   000000A4   010051B3           CMPLT    R1,#+1
   \   000000A8   2EC0A0A3           MOVGE    R12,#+46
   \   000000AC   210000AA           BGE      ??_SFN_ReadDirEntryInfo_3
   \                     ??_SFN_ReadDirEntryInfo_4:
   \   000000B0   0010A0E3           MOV      R1,#+0
   \   000000B4   0010C0E5           STRB     R1,[R0, #+0]
    274                  FS_FAT_CopyDirEntryInfo(pDirEntry, pDirEntryInfo);
   \                     ??_SFN_ReadDirEntryInfo_2:
   \   000000B8   0B00D6E5           LDRB     R0,[R6, #+11]
   \   000000BC   0000C5E5           STRB     R0,[R5, #+0]
   \   000000C0   100086E2           ADD      R0,R6,#+16
   \   000000C4   ........           BL       FS_LoadU16LE
   \   000000C8   0070A0E1           MOV      R7,R0
   \   000000CC   0E0086E2           ADD      R0,R6,#+14
   \   000000D0   ........           BL       FS_LoadU16LE
   \   000000D4   070880E1           ORR      R0,R0,R7, LSL #+16
   \   000000D8   040085E5           STR      R0,[R5, #+4]
   \   000000DC   120086E2           ADD      R0,R6,#+18
   \   000000E0   ........           BL       FS_LoadU16LE
   \   000000E4   0008A0E1           LSL      R0,R0,#+16
   \   000000E8   080085E5           STR      R0,[R5, #+8]
   \   000000EC   180086E2           ADD      R0,R6,#+24
   \   000000F0   ........           BL       FS_LoadU16LE
   \   000000F4   0070A0E1           MOV      R7,R0
   \   000000F8   160086E2           ADD      R0,R6,#+22
   \   000000FC   ........           BL       FS_LoadU16LE
   \   00000100   070880E1           ORR      R0,R0,R7, LSL #+16
   \   00000104   0C0085E5           STR      R0,[R5, #+12]
   \   00000108   1C0086E2           ADD      R0,R6,#+28
   \   0000010C   ........           BL       FS_LoadU32LE
   \   00000110   100085E5           STR      R0,[R5, #+16]
    275                  pDir->DirEntryIndex++;
   \   00000114   B001D4E1           LDRH     R0,[R4, #+16]
    276                  r = 0;
   \   00000118   0090A0E3           MOV      R9,#+0
   \   0000011C   010080E2           ADD      R0,R0,#+1
   \   00000120   B001C4E1           STRH     R0,[R4, #+16]
    277                  break;
    278                }
    279              }
    280            } while (1);
    281            return r;
   \                     ??_SFN_ReadDirEntryInfo_1:
   \   00000124   0900A0E1           MOV      R0,R9
   \   00000128   04D08DE2           ADD      SP,SP,#+4
   \   0000012C   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??_SFN_ReadDirEntryInfo_5:
   \   00000130   000053E3           CMP      R3,#+0
   \   00000134   0200001A           BNE      ??_SFN_ReadDirEntryInfo_6
   \                     ??_SFN_ReadDirEntryInfo_3:
   \   00000138   00E0D2E5           LDRB     LR,[R2, #+0]
   \   0000013C   05005EE3           CMP      LR,#+5
   \   00000140   0500000A           BEQ      ??_SFN_ReadDirEntryInfo_7
   \                     ??_SFN_ReadDirEntryInfo_6:
   \   00000144   00E0D2E5           LDRB     LR,[R2, #+0]
   \   00000148   20005EE3           CMP      LR,#+32
   \   0000014C   01E0D214           LDRBNE   LR,[R2], #+1
   \   00000150   0300001A           BNE      ??_SFN_ReadDirEntryInfo_8
   \                     ??_SFN_ReadDirEntryInfo_9:
   \   00000154   012082E2           ADD      R2,R2,#+1
   \   00000158   020000EA           B        ??_SFN_ReadDirEntryInfo_10
   \                     ??_SFN_ReadDirEntryInfo_7:
   \   0000015C   012082E2           ADD      R2,R2,#+1
   \   00000160   E5E0A0E3           MOV      LR,#+229
   \                     ??_SFN_ReadDirEntryInfo_8:
   \   00000164   01E0C0E4           STRB     LR,[R0], #+1
   \                     ??_SFN_ReadDirEntryInfo_10:
   \   00000168   013083E2           ADD      R3,R3,#+1
   \   0000016C   010053E1           CMP      R3,R1
   \   00000170   CEFFFFAA           BGE      ??_SFN_ReadDirEntryInfo_4
   \   00000174   080053E3           CMP      R3,#+8
   \   00000178   ECFFFF1A           BNE      ??_SFN_ReadDirEntryInfo_5
   \   0000017C   00E0D2E5           LDRB     LR,[R2, #+0]
   \   00000180   20005EE3           CMP      LR,#+32
   \   00000184   F2FFFF0A           BEQ      ??_SFN_ReadDirEntryInfo_9
   \   00000188   01C0C0E4           STRB     R12,[R0], #+1
   \   0000018C   ECFFFFEA           B        ??_SFN_ReadDirEntryInfo_6
    282          }
    283          
    284          /*********************************************************************
    285          *
    286          *       _SFN_FindDirEntry
    287          *
    288          *  Description:
    289          *    Tries to locate the directory entry in the specified directory.
    290          *    The short name space is searched first;
    291          *    if LFN support is activated, the long name space is search
    292          *    if no short name match was found.
    293          *
    294          *  Parameters:
    295          *    pVolume     - Volume information
    296          *    pEntryName  - Directory entry name
    297          *
    298          *  Return value:
    299          *    != NULL     - pointer to directory entry (in the smart buffer)
    300          *    NULL        - Entry not found
    301          */

   \                                 In section .text, align 4, keep-with-next
    302          static FS_FAT_DENTRY * _SFN_FindDirEntry(FS_VOLUME * pVolume, FS_SB * pSB, const char *pEntryName, int Len, U32 DirStart, U8 AttrRequired, I32 * pLongDirEntryIndex) {
   \                     _SFN_FindDirEntry:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   14E0DDE5           LDRB     LR,[SP, #+20]
   \   0000000C   10C09DE5           LDR      R12,[SP, #+16]
    303            FS_USE_PARA(pLongDirEntryIndex);
    304            return FS_FAT_FindDirEntryShort(pVolume, pSB, pEntryName, Len, DirStart, AttrRequired);
   \   00000010   04E08DE5           STR      LR,[SP, #+4]
   \   00000014   00C08DE5           STR      R12,[SP, #+0]
   \   00000018   ........           BL       FS_FAT_FindDirEntryShort
   \   0000001C   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
    305          }
    306          
    307          
    308          
    309          /*********************************************************************
    310          *
    311          *       _SFN_CreateDirEntry
    312          *
    313          */

   \                                 In section .text, align 4, keep-with-next
    314          static FS_FAT_DENTRY * _SFN_CreateDirEntry(FS_VOLUME  * pVolume, FS_SB      * pSB, const char * pFileName, U32 DirStart, U32 ClusterId, U8 Attributes, U32 Size, U16 Time, U16 Date) {
   \                     _SFN_CreateDirEntry:
   \   00000000   F14F2DE9           PUSH     {R0,R4-R11,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   18D04DE2           SUB      SP,SP,#+24
   \   0000000C   0210A0E1           MOV      R1,R2
   \   00000010   0350A0E1           MOV      R5,R3
   \   00000014   40609DE5           LDR      R6,[SP, #+64]
   \   00000018   4470DDE5           LDRB     R7,[SP, #+68]
   \   0000001C   48809DE5           LDR      R8,[SP, #+72]
   \   00000020   BC94DDE1           LDRH     R9,[SP, #+76]
   \   00000024   B0A5DDE1           LDRH     R10,[SP, #+80]
    315            FS_FAT_DENTRY * pDirEntry;
    316            FS_83NAME   FATEntryName;
    317          
    318            pDirEntry = NULL;
   \   00000028   00B0A0E3           MOV      R11,#+0
    319            if (FS_FAT_Make83Name(&FATEntryName, pFileName, 0) == 0) {
   \   0000002C   0020A0E3           MOV      R2,#+0
   \   00000030   0C008DE2           ADD      R0,SP,#+12
   \   00000034   ........           BL       FS_FAT_Make83Name
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0E00001A           BNE      ??_SFN_CreateDirEntry_0
    320              pDirEntry = FS_FAT_FindEmptyDirEntry(pVolume, pSB, DirStart);
   \   00000040   0520A0E1           MOV      R2,R5
   \   00000044   0410A0E1           MOV      R1,R4
   \   00000048   18009DE5           LDR      R0,[SP, #+24]
   \   0000004C   ........           BL       FS_FAT_FindEmptyDirEntry
   \   00000050   00B0B0E1           MOVS     R11,R0
    321              if (pDirEntry) {
   \   00000054   0800000A           BEQ      ??_SFN_CreateDirEntry_0
    322                FS_FAT_WriteDirEntry83(pDirEntry, &FATEntryName, ClusterId, Attributes, Size, Time, Date);
   \   00000058   08A08DE5           STR      R10,[SP, #+8]
   \   0000005C   04908DE5           STR      R9,[SP, #+4]
   \   00000060   00808DE5           STR      R8,[SP, #+0]
   \   00000064   0730A0E1           MOV      R3,R7
   \   00000068   0620A0E1           MOV      R2,R6
   \   0000006C   0C108DE2           ADD      R1,SP,#+12
   \   00000070   ........           BL       FS_FAT_WriteDirEntry83
    323                FS__SB_MarkDirty(pSB);
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   ........           BL       FS__SB_MarkDirty
    324              }
    325            } else {
    326              FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_SFN_CreateDirEntry: File or directory name is not a legal 8.3 name: Either too long or illegal characters.\n"));
    327            }
    328            return pDirEntry;
   \                     ??_SFN_CreateDirEntry_0:
   \   0000007C   0B00A0E1           MOV      R0,R11
   \   00000080   1CD08DE2           ADD      SP,SP,#+28
   \   00000084   F08FBDE8           POP      {R4-R11,PC}      ;; return
    329          }
    330          
    331          
    332          
    333          /*********************************************************************
    334          *
    335          *       _CheckBPB
    336          *
    337          *  Description:
    338          *    Checks the Bios-Parameter-Block (BPB) of the volume
    339          *    and initialize the FS specific information in the volume structure.
    340          *
    341          *  Parameters:
    342          *    pVolume     - Pointer to volume structure.
    343          *    pBuffer     - Pointer to buffer with read BPB.
    344          *
    345          *  Return value:
    346          *    1           - OK     - BPB contains valid information.
    347          *    0           - Error- - BPB contains invalid information.
    348          */

   \                                 In section .text, align 4, keep-with-next
    349          static int _CheckBPB(FS_VOLUME * pVolume, U8 * pBuffer) {
   \                     _CheckBPB:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0080A0E1           MOV      R8,R0
    350            FS_FAT_INFO * pFATInfo;
    351            U16           BytesPerSector;
    352            U32           FirstDataSector;
    353            U32           NumSectors;
    354            U32           NumClusters;
    355            U32           FATSize;
    356            U32           FirstSectorAfterFAT;
    357            U8            SectorsPerCluster;
    358            U16           Signature;
    359            U8            FATType;
    360            int           i;
    361          
    362            //
    363            // Check if this a valid BPB
    364            //
    365            Signature     = FS_LoadU16LE(&pBuffer[BPB_OFF_SIGNATURE]);
    366            if (Signature != 0xaa55) {
   \   00000008   FE00A0E3           MOV      R0,#+254
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   400F80E3           ORR      R0,R0,#0x100
   \   00000014   04D04DE2           SUB      SP,SP,#+4
   \   00000018   060080E0           ADD      R0,R0,R6
   \   0000001C   ........           BL       FS_LoadU16LE
   \   00000020   5510A0E3           MOV      R1,#+85
   \   00000024   AA1C81E3           ORR      R1,R1,#0xAA00
   \   00000028   010050E1           CMP      R0,R1
   \   0000002C   0100000A           BEQ      ??_CheckBPB_0
    367              FS_DEBUG_WARN((FS_MTYPE_FS, "_CheckBPB: Invalid signature, format not valid.\n"));
    368              return 0;                         /* Error, not a valid BPB */
   \                     ??_CheckBPB_1:
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   850000EA           B        ??_CheckBPB_2
    369            }
    370            BytesPerSector          = FS_LoadU16LE(&pBuffer[BPB_OFF_BYTES_PER_SECTOR]);  /* _512_,1024,2048,4096           */
   \                     ??_CheckBPB_0:
   \   00000038   0B0086E2           ADD      R0,R6,#+11
   \   0000003C   ........           BL       FS_LoadU16LE
   \   00000040   0040A0E1           MOV      R4,R0
    371            if (((BytesPerSector & 0xFE00) == 0) || (BytesPerSector > FS_Global.MaxSectorSize)) {  /* must be divisible by 512  and */
   \   00000044   FE0C14E3           TST      R4,#0xFE00
   \   00000048   F8FFFF0A           BEQ      ??_CheckBPB_1
   \   0000004C   ........           LDR      R0,??DataTable6
   \   00000050   B001D0E1           LDRH     R0,[R0, #+16]
   \   00000054   040050E1           CMP      R0,R4
   \   00000058   F4FFFFBA           BLT      ??_CheckBPB_1
    372              FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_CheckBPB: BPB error: BytesPerSector (%d) is not valid.\n", BytesPerSector));
    373              return 0;                         /* Error, not a valid BPB */
    374            }
    375            if (pBuffer[BPB_OFF_NUM_FATS] != 2) {               /* Verify that NumFATs == 2 */
   \   0000005C   1000D6E5           LDRB     R0,[R6, #+16]
   \   00000060   020050E3           CMP      R0,#+2
   \   00000064   F1FFFF1A           BNE      ??_CheckBPB_1
    376              FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_CheckBPB: BPB error: Only 2 FATs supported.\n"));
    377              return 0;                         /* Error, not a valid BPB */
    378            }
    379            SectorsPerCluster = pBuffer[BPB_OFF_SECTOR_PER_CLUSTER];
   \   00000068   0D90D6E5           LDRB     R9,[R6, #+13]
    380            if (SectorsPerCluster == 0) {
   \   0000006C   000059E3           CMP      R9,#+0
   \   00000070   EEFFFF0A           BEQ      ??_CheckBPB_1
    381              FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_CheckBPB: BPB error: SectorsPerCluster == 0.\n"));
    382              return 0;                         /* Error, not a valid BPB */
    383            }
    384            //
    385            // Analyze BPB and fill the FATInfo structure in pVolume.
    386            //
    387            pFATInfo = &pVolume->FSInfo.FATInfo;
   \   00000074   1C5088E2           ADD      R5,R8,#+28
    388            FS_MEMSET(pFATInfo, 0, sizeof(FS_FAT_INFO));
   \   00000078   4010A0E3           MOV      R1,#+64
   \   0000007C   0500A0E1           MOV      R0,R5
   \   00000080   ........           BL       __aeabi_memclr4
    389            NumSectors              = FS_LoadU16LE(&pBuffer[BPB_OFF_NUMSECTORS_16BIT]);            /* RSVD + FAT + ROOT + FATA (<64k)  */
   \   00000084   130086E2           ADD      R0,R6,#+19
   \   00000088   ........           BL       FS_LoadU16LE
   \   0000008C   0070B0E1           MOVS     R7,R0
    390            if (NumSectors == 0) {
   \   00000090   0200001A           BNE      ??_CheckBPB_3
    391              NumSectors            = FS_LoadU32LE(&pBuffer[BPB_OFF_NUMSECTORS_32BIT]);            /* RSVD + FAT + ROOT + FATA (>=64k) */
   \   00000094   200086E2           ADD      R0,R6,#+32
   \   00000098   ........           BL       FS_LoadU32LE
   \   0000009C   0070A0E1           MOV      R7,R0
    392            }
    393            FATSize                 = FS_LoadU16LE(&pBuffer[BPB_OFF_FATSIZE_16BIT]);               /* number of FAT sectors            */
   \                     ??_CheckBPB_3:
   \   000000A0   160086E2           ADD      R0,R6,#+22
   \   000000A4   ........           BL       FS_LoadU16LE
   \   000000A8   00B0B0E1           MOVS     R11,R0
    394            if (FATSize == 0) {
   \   000000AC   0900001A           BNE      ??_CheckBPB_4
    395              U16 ExtFlags       = FS_LoadU16LE(&pBuffer[BPB_OFF_FAT32_EXTFLAGS]);                 /* mirroring info                   */
    396              // Check FAT mirroring flags for FAT32 volumes
    397              if (ExtFlags & 0x008F) {
   \   000000B0   280086E2           ADD      R0,R6,#+40
   \   000000B4   ........           BL       FS_LoadU16LE
   \   000000B8   8F0010E3           TST      R0,#0x8F
   \   000000BC   DBFFFF1A           BNE      ??_CheckBPB_1
    398                FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_CheckBPB: BPB error: FAT32 feature \"FAT mirroring\" not supported.\n"));
    399                return 0;                         /* Error, not a valid BPB */
    400              }
    401              //
    402              // Fat32
    403              //
    404              FATSize                 = FS_LoadU32LE(&pBuffer[BPB_OFF_FATSIZE_32BIT]);    /* number of FAT sectors                            */
   \   000000C0   240086E2           ADD      R0,R6,#+36
   \   000000C4   ........           BL       FS_LoadU32LE
   \   000000C8   00B0A0E1           MOV      R11,R0
    405              pFATInfo->RootDirPos    = FS_LoadU32LE(&pBuffer[BPB_OFF_ROOTDIR_CLUSTER]);  /* root dir cluster for FAT32. Typically cluster 2. */
   \   000000CC   2C0086E2           ADD      R0,R6,#+44
   \   000000D0   ........           BL       FS_LoadU32LE
   \   000000D4   140085E5           STR      R0,[R5, #+20]
    406            }
    407            pFATInfo->NumSectors      = NumSectors;
   \                     ??_CheckBPB_4:
   \   000000D8   007085E5           STR      R7,[R5, #+0]
    408            pFATInfo->FATSize         = FATSize;
   \   000000DC   10B085E5           STR      R11,[R5, #+16]
    409            pFATInfo->NumFATs         = 2;
   \   000000E0   0200A0E3           MOV      R0,#+2
   \   000000E4   1D00C5E5           STRB     R0,[R5, #+29]
    410            pFATInfo->SecPerClus      = SectorsPerCluster;
   \   000000E8   1C90C5E5           STRB     R9,[R5, #+28]
    411            pFATInfo->RsvdSecCnt      = FS_LoadU16LE(&pBuffer[14]);                /* 1 for FAT12 & FAT16            */
   \   000000EC   0E0086E2           ADD      R0,R6,#+14
   \   000000F0   ........           BL       FS_LoadU16LE
   \   000000F4   BA01C5E1           STRH     R0,[R5, #+26]
    412            pFATInfo->RootEntCnt      = FS_LoadU16LE(&pBuffer[17]);                /* number of root dir entries     */
   \   000000F8   110086E2           ADD      R0,R6,#+17
   \   000000FC   ........           BL       FS_LoadU16LE
   \   00000100   B801C5E1           STRH     R0,[R5, #+24]
    413            pFATInfo->BytesPerSec     = BytesPerSector;
   \   00000104   B440C5E1           STRH     R4,[R5, #+4]
    414            FirstSectorAfterFAT       = pFATInfo->RsvdSecCnt + pFATInfo->NumFATs * FATSize;
   \   00000108   1D10D5E5           LDRB     R1,[R5, #+29]
   \   0000010C   BA01D5E1           LDRH     R0,[R5, #+26]
   \   00000110   9B012AE0           MLA      R10,R11,R1,R0
    415            FirstDataSector           = FirstSectorAfterFAT  + pFATInfo->RootEntCnt / (BytesPerSector / FS_FAT_DENTRY_SIZE);    /* Add number of sectors of root directory */
   \   00000114   4412A0E1           ASR      R1,R4,#+4
   \   00000118   A11D84E0           ADD      R1,R4,R1, LSR #+27
   \   0000011C   B801D5E1           LDRH     R0,[R5, #+24]
   \   00000120   C112A0E1           ASR      R1,R1,#+5
   \   00000124   ........           BL       __aeabi_idiv
   \   00000128   0A0080E0           ADD      R0,R0,R10
    416            pFATInfo->FirstDataSector = FirstDataSector;
   \   0000012C   080085E5           STR      R0,[R5, #+8]
    417            //
    418            // Compute the shift for bytes per sector
    419            //
    420            for (i = 9; i < 16; i++) {
   \   00000130   0910A0E3           MOV      R1,#+9
    421              if ((1L << i) == BytesPerSector) {
   \   00000134   800F54E3           CMP      R4,#+512
   \   00000138   0100001A           BNE      ??_CheckBPB_5
    422                pFATInfo->ldBytesPerSector = (U16)i;
   \                     ??_CheckBPB_6:
   \   0000013C   B610C5E1           STRH     R1,[R5, #+6]
    423                break;
   \   00000140   0C0000EA           B        ??_CheckBPB_7
    424              }
   \                     ??_CheckBPB_5:
   \   00000144   0A10A0E3           MOV      R1,#+10
   \   00000148   400E54E3           CMP      R4,#+1024
   \   0000014C   0B10A013           MOVNE    R1,#+11
   \   00000150   800E5413           CMPNE    R4,#+2048
   \   00000154   0C10A013           MOVNE    R1,#+12
   \   00000158   400D5413           CMPNE    R4,#+4096
   \   0000015C   0D10A013           MOVNE    R1,#+13
   \   00000160   800D5413           CMPNE    R4,#+8192
   \   00000164   0E10A013           MOVNE    R1,#+14
   \   00000168   400C5413           CMPNE    R4,#+16384
   \   0000016C   0F10A013           MOVNE    R1,#+15
   \   00000170   800C5413           CMPNE    R4,#+32768
   \   00000174   F0FFFF0A           BEQ      ??_CheckBPB_6
    425            }
    426            //
    427            // Compute NumClusters
    428            //
    429            NumClusters = (NumSectors - FirstDataSector) / SectorsPerCluster;
   \                     ??_CheckBPB_7:
   \   00000178   000047E0           SUB      R0,R7,R0
   \   0000017C   0910A0E1           MOV      R1,R9
   \   00000180   ........           BL       __aeabi_uidiv
   \   00000184   0070A0E1           MOV      R7,R0
    430            pFATInfo->NumClusters     = NumClusters;
    431            pFATInfo->BytesPerCluster = (U32)SectorsPerCluster * (U32)BytesPerSector;
   \   00000188   940900E0           MUL      R0,R4,R9
   \   0000018C   207085E5           STR      R7,[R5, #+32]
   \   00000190   0C0085E5           STR      R0,[R5, #+12]
    432            //
    433            // Determine the type of FAT (12/16/32), based on the number of clusters. (acc. MS spec)
    434            //
    435            FATType = FS_FAT_GetFATType(NumClusters);
   \   00000194   F500A0E3           MOV      R0,#+245
   \   00000198   F00E80E3           ORR      R0,R0,#0xF00
   \   0000019C   000057E1           CMP      R7,R0
   \   000001A0   2E00003A           BCC      ??_CheckBPB_8
   \   000001A4   F00C80E3           ORR      R0,R0,#0xF000
   \   000001A8   000057E1           CMP      R7,R0
   \   000001AC   2900003A           BCC      ??_CheckBPB_9
   \   000001B0   2000A0E3           MOV      R0,#+32
   \   000001B4   1E00C5E5           STRB     R0,[R5, #+30]
    436            pFATInfo->FATType         = FATType;
    437            if(FATType != FS_FAT_TYPE_FAT32) {
    438              pFATInfo->RootDirPos = FirstSectorAfterFAT;     /* For FAT12 / FAT16 */
    439            }
    440            pFATInfo->NumFreeClusters = INVALID_NUM_FREE_CLUSTERS_VALUE;
   \   000001B8   0000E0E3           MVN      R0,#+0
   \   000001BC   240085E5           STR      R0,[R5, #+36]
    441          #if FS_FAT_USE_FSINFO_SECTOR
    442            if (FATType == FS_FAT_TYPE_FAT32) {
    443              U16  FSInfo_Sector;
    444              U32  FAT32Signature1;
    445              U32  FAT32Signature2;
    446              U32  FAT32Signature3;
    447              U32  NumFreeClusters;
    448          
    449              FSInfo_Sector = FS_LoadU16LE(&pBuffer[BPB_OFF_FAT32_FSINFO_SECTOR]);
   \   000001C0   300086E2           ADD      R0,R6,#+48
   \   000001C4   ........           BL       FS_LoadU16LE
    450              pFATInfo->FSInfoSector = FSInfo_Sector;
   \   000001C8   BC02C5E1           STRH     R0,[R5, #+44]
    451              if (FS_LB_ReadPart(&pVolume->Partition, FSInfo_Sector, pBuffer, FS_SECTOR_TYPE_DATA) < 0) {
   \   000001CC   0010A0E1           MOV      R1,R0
   \   000001D0   0030A0E3           MOV      R3,#+0
   \   000001D4   0620A0E1           MOV      R2,R6
   \   000001D8   0800A0E1           MOV      R0,R8
   \   000001DC   ........           BL       FS_LB_ReadPart
   \   000001E0   000050E3           CMP      R0,#+0
   \   000001E4   91FFFF4A           BMI      ??_CheckBPB_1
    452                return 0;               /* Error, FAT32 FSInfo sector could not be read */
    453              }
    454              /* Use FSInfo Sector if it has the correct signatures */
    455              FAT32Signature1 = FS_LoadU32LE(&pBuffer[FSINFO_OFF_SIGNATURE_1]);
   \   000001E8   0600A0E1           MOV      R0,R6
   \   000001EC   ........           BL       FS_LoadU32LE
   \   000001F0   0040A0E1           MOV      R4,R0
    456              FAT32Signature2 = FS_LoadU32LE(&pBuffer[FSINFO_OFF_SIGNATURE_2]);
   \   000001F4   790F86E2           ADD      R0,R6,#+484
   \   000001F8   ........           BL       FS_LoadU32LE
   \   000001FC   0080A0E1           MOV      R8,R0
    457              FAT32Signature3 = FS_LoadU32LE(&pBuffer[FSINFO_OFF_SIGNATURE_3]);
   \   00000200   7F0F86E2           ADD      R0,R6,#+508
   \   00000204   ........           BL       FS_LoadU32LE
    458              if ((FAT32Signature1 == FSINFO_SIGNATURE_1) &&
    459                  (FAT32Signature2 == FSINFO_SIGNATURE_2) &&
    460                  (FAT32Signature3 == FSINFO_SIGNATURE_3)) {
   \   00000208   ........           LDR      R1,??DataTable7  ;; 0x41615252
   \   0000020C   010054E1           CMP      R4,R1
   \   00000210   ........           LDREQ    R1,??DataTable7_1  ;; 0x61417272
   \   00000214   01005801           CMPEQ    R8,R1
   \   00000218   0B00001A           BNE      ??_CheckBPB_10
   \   0000021C   AA14A0E3           MOV      R1,#-1442840576
   \   00000220   551881E3           ORR      R1,R1,#0x550000
   \   00000224   010050E1           CMP      R0,R1
   \   00000228   0700001A           BNE      ??_CheckBPB_10
    461                    pFATInfo->NextFreeCluster = FS_LoadU32LE(&pBuffer[FSINFO_OFF_NEXT_FREE_CLUSTER]);
   \   0000022C   7B0F86E2           ADD      R0,R6,#+492
   \   00000230   ........           BL       FS_LoadU32LE
   \   00000234   280085E5           STR      R0,[R5, #+40]
    462                    NumFreeClusters = FS_LoadU32LE(&pBuffer[FSINFO_OFF_FREE_CLUSTERS]);
   \   00000238   7A0F86E2           ADD      R0,R6,#+488
   \   0000023C   ........           BL       FS_LoadU32LE
    463                    if (NumFreeClusters <= NumClusters) {
   \   00000240   000057E1           CMP      R7,R0
   \   00000244   0000003A           BCC      ??_CheckBPB_10
    464                      pFATInfo->NumFreeClusters = NumFreeClusters;
   \                     ??_CheckBPB_11:
   \   00000248   240085E5           STR      R0,[R5, #+36]
    465                    }
    466              }
    467            }
    468          #endif
    469            return 1;                   // OK. BPB contains valid .
   \                     ??_CheckBPB_10:
   \   0000024C   0100A0E3           MOV      R0,#+1
   \                     ??_CheckBPB_2:
   \   00000250   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000254   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??_CheckBPB_9:
   \   00000258   1000A0E3           MOV      R0,#+16
   \   0000025C   000000EA           B        ??_CheckBPB_12
   \                     ??_CheckBPB_8:
   \   00000260   0C00A0E3           MOV      R0,#+12
   \                     ??_CheckBPB_12:
   \   00000264   1E00C5E5           STRB     R0,[R5, #+30]
   \   00000268   14A085E5           STR      R10,[R5, #+20]
   \   0000026C   0000E0E3           MVN      R0,#+0
   \   00000270   F4FFFFEA           B        ??_CheckBPB_11
    470          }
    471          
    472          /*********************************************************************
    473          *
    474          *       _CalcLogClusterPos
    475          *
    476          *  Function description
    477          *    Calculates the logical cluster index of a file
    478          *
    479          *  Return value
    480          *    Logical cluster index
    481          *
    482          */
    483          static U32 _CalcLogClusterPos(FS_FILE * pFile) {
    484            FS_FAT_INFO* pFATInfo;
    485          
    486            pFATInfo = &pFile->pFileObj->pVolume->FSInfo.FATInfo;
    487            return pFile->FilePos / pFATInfo->BytesPerCluster;
    488          }
    489          
    490          /*********************************************************************
    491          *
    492          *       _WalkAdjFileClusters
    493          *
    494          *  Function description
    495          *    Walks the adjacent clusters within a file
    496          *
    497          *  Return value
    498          *    NumClustersToWalk
    499          */

   \                                 In section .text, align 4, keep-with-next
    500          static U32 _WalkAdjFileClusters(FS_FILE * pFile) {
   \                     _WalkAdjFileClusters:
   \   00000000   10402DE9           PUSH     {R4,LR}
    501            U32           CurClusterIndex;
    502            unsigned      i;
    503            U32           NumClustersToWalk;
    504            FS_FILE_OBJ * pFileObj;
    505          
    506            pFileObj = pFile->pFileObj;
   \   00000004   004090E5           LDR      R4,[R0, #+0]
    507            CurClusterIndex = _CalcLogClusterPos(pFile);
   \   00000008   040090E5           LDR      R0,[R0, #+4]
   \   0000000C   081094E5           LDR      R1,[R4, #+8]
   \   00000010   281091E5           LDR      R1,[R1, #+40]
   \   00000014   ........           BL       __aeabi_uidiv
    508            if (CurClusterIndex < pFileObj->Data.Fat.CurClusterFile) {
   \   00000018   101094E5           LDR      R1,[R4, #+16]
   \   0000001C   0020E0E3           MVN      R2,#+0
   \   00000020   010050E1           CMP      R0,R1
    509              pFileObj->Data.Fat.CurClusterFile = 0xFFFFFFFFUL;   /// File position moved back ... Invalidate
   \   00000024   10208435           STRCC    R2,[R4, #+16]
   \   00000028   0100003A           BCC      ??_WalkAdjFileClusters_0
    510            }
    511            if (pFileObj->Data.Fat.CurClusterFile == 0xFFFFFFFFUL) {
   \   0000002C   020051E1           CMP      R1,R2
   \   00000030   0400001A           BNE      ??_WalkAdjFileClusters_1
    512              pFileObj->Data.Fat.CurClusterFile = 0;
   \                     ??_WalkAdjFileClusters_0:
   \   00000034   0010A0E3           MOV      R1,#+0
   \   00000038   101084E5           STR      R1,[R4, #+16]
    513              pFileObj->Data.Fat.CurClusterAbs  = pFileObj->FirstCluster;
   \   0000003C   002094E5           LDR      R2,[R4, #+0]
   \   00000040   142084E5           STR      R2,[R4, #+20]
    514              pFileObj->Data.Fat.NumAdjClusters = 0;
   \   00000044   BE11C4E1           STRH     R1,[R4, #+30]
    515            }
    516            //
    517            // Walk to the right cluster starting from the last known cluster position.
    518            //
    519            NumClustersToWalk = CurClusterIndex - pFileObj->Data.Fat.CurClusterFile;
   \                     ??_WalkAdjFileClusters_1:
   \   00000048   101094E5           LDR      R1,[R4, #+16]
    520            if (NumClustersToWalk <= pFileObj->Data.Fat.NumAdjClusters) {
   \   0000004C   BE21D4E1           LDRH     R2,[R4, #+30]
   \   00000050   010040E0           SUB      R0,R0,R1
   \   00000054   000052E1           CMP      R2,R0
   \   00000058   0020A081           MOVHI    R2,R0
    521              i = NumClustersToWalk;
    522            } else {
    523              i = pFileObj->Data.Fat.NumAdjClusters;
    524            }
    525            if (i) {
   \   0000005C   000052E3           CMP      R2,#+0
   \   00000060   0800000A           BEQ      ??_WalkAdjFileClusters_2
    526              pFileObj->Data.Fat.CurClusterAbs  += i;
   \   00000064   143094E5           LDR      R3,[R4, #+20]
    527              pFileObj->Data.Fat.CurClusterFile += i;
   \   00000068   011082E0           ADD      R1,R2,R1
   \   0000006C   033082E0           ADD      R3,R2,R3
   \   00000070   143084E5           STR      R3,[R4, #+20]
   \   00000074   101084E5           STR      R1,[R4, #+16]
    528              pFileObj->Data.Fat.NumAdjClusters -= i;
   \   00000078   BE11D4E1           LDRH     R1,[R4, #+30]
    529              NumClustersToWalk -= i;
   \   0000007C   020040E0           SUB      R0,R0,R2
   \   00000080   021041E0           SUB      R1,R1,R2
   \   00000084   BE11C4E1           STRH     R1,[R4, #+30]
    530            }
    531            return NumClustersToWalk;
   \                     ??_WalkAdjFileClusters_2:
   \   00000088   1080BDE8           POP      {R4,PC}          ;; return
    532          }
    533          
    534          /*********************************************************************
    535          *
    536          *       _GrowRootDir
    537          *
    538          *  Description:
    539          *    Let the root directory of a FAT32 volume grow.
    540          *    This function shall be called after formatting the volume.
    541          *    If the function is not called after format or called for
    542          *    a FAT12/16 volume the function will fail.
    543          *
    544          *
    545          *  Parameters:
    546          *    sVolume       - Pointer to a string that specifies the volume string.
    547          *    NumAddEntries - Number of entries to be added.
    548          *    
    549          *  Returns value
    550          *    > 0           - Number of entries added
    551          *    = 0           - Clusters after root directory are not free.
    552          *    0xFFFFFFFF    - Failed (Invalid volume, volume not mountable, volume is not FAT32)
    553          */

   \                                 In section .text, align 4, keep-with-next
    554          static U32 _GrowRootDir(const char * sVolume, U32 NumAddEntries) {
   \                     _GrowRootDir:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   14D04DE2           SUB      SP,SP,#+20
    555            FS_VOLUME   * pVolume;
    556            FS_FAT_INFO * pFATInfo;
    557            //
    558            //  Find correct volume
    559            //
    560            pVolume = FS__FindVolume(sVolume, NULL);
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   ........           BL       FS__FindVolume
   \   00000014   0050B0E1           MOVS     R5,R0
    561            if (pVolume) {
   \   00000018   A900000A           BEQ      ??_GrowRootDir_0
    562              //
    563              // Mount the volume if necessary
    564              //
    565              if (FS__AutoMount(pVolume) == FS_MOUNT_RW) {
   \   0000001C   ........           BL       FS__AutoMount
   \   00000020   030050E3           CMP      R0,#+3
   \   00000024   A600001A           BNE      ??_GrowRootDir_0
    566                //
    567                //  Check whether volume is a FAT32 volume.
    568                // 
    569                pFATInfo = &pVolume->FSInfo.FATInfo;
   \   00000028   1C6085E2           ADD      R6,R5,#+28
    570                if (pFATInfo->FATType == FS_FAT_TYPE_FAT32) {
   \   0000002C   1E00D6E5           LDRB     R0,[R6, #+30]
   \   00000030   200050E3           CMP      R0,#+32
   \   00000034   A200001A           BNE      ??_GrowRootDir_0
    571                  U32 NumClustersReq;
    572                  U32 NumSectors;
    573                  U32 StartCluster;
    574                  U32 StartSector;
    575                  FS_SB  SB;
    576          
    577                  FS__SB_Create(&SB, &pVolume->Partition);
   \   00000038   0510A0E1           MOV      R1,R5
   \   0000003C   04008DE2           ADD      R0,SP,#+4
   \   00000040   ........           BL       FS__SB_Create
    578                  //
    579                  //  Calculate how many clusters are necessary
    580                  //
    581                  NumClustersReq = FS__DivideU32Up(NumAddEntries << FS_FAT_DENTRY_SIZE_SHIFT, pFATInfo->BytesPerCluster);
   \   00000044   0C1096E5           LDR      R1,[R6, #+12]
   \   00000048   8402A0E1           LSL      R0,R4,#+5
   \   0000004C   ........           BL       FS__DivideU32Up
   \   00000050   0070A0E1           MOV      R7,R0
    582                  //
    583                  //  Check whether the adjacent cluster after the root directory are available.
    584                  //
    585                  StartCluster = FS_FAT_FindLastCluster(pVolume, &SB, pFATInfo->RootDirPos, NULL) + 1;
   \   00000054   149096E5           LDR      R9,[R6, #+20]
   \   00000058   0080A0E3           MOV      R8,#+0
   \   0000005C   000000EA           B        ??_GrowRootDir_1
   \                     ??_GrowRootDir_2:
   \   00000060   0090A0E1           MOV      R9,R0
   \                     ??_GrowRootDir_1:
   \   00000064   0110A0E3           MOV      R1,#+1
   \   00000068   00108DE5           STR      R1,[SP, #+0]
   \   0000006C   0D30A0E1           MOV      R3,SP
   \   00000070   0920A0E1           MOV      R2,R9
   \   00000074   04108DE2           ADD      R1,SP,#+4
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           BL       FS_FAT_WalkClusterEx
   \   00000080   00109DE5           LDR      R1,[SP, #+0]
   \   00000084   000051E3           CMP      R1,#+0
   \   00000088   0500001A           BNE      ??_GrowRootDir_3
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   0300000A           BEQ      ??_GrowRootDir_3
   \   00000094   3C1095E5           LDR      R1,[R5, #+60]
   \   00000098   018088E2           ADD      R8,R8,#+1
   \   0000009C   080051E1           CMP      R1,R8
   \   000000A0   EEFFFF2A           BCS      ??_GrowRootDir_2
   \                     ??_GrowRootDir_3:
   \   000000A4   018089E2           ADD      R8,R9,#+1
    586                  if (FS_FAT_AllocClusterBlock(pVolume, StartCluster, NumClustersReq, &SB) == 2) {
   \   000000A8   3C0095E5           LDR      R0,[R5, #+60]
   \   000000AC   081087E0           ADD      R1,R7,R8
   \   000000B0   021041E2           SUB      R1,R1,#+2
   \   000000B4   010050E1           CMP      R0,R1
   \   000000B8   6500003A           BCC      ??_GrowRootDir_4
   \   000000BC   000057E3           CMP      R7,#+0
   \   000000C0   1B00000A           BEQ      ??_GrowRootDir_5
   \   000000C4   0890A0E1           MOV      R9,R8
   \   000000C8   010017E3           TST      R7,#0x1
   \   000000CC   0600000A           BEQ      ??_GrowRootDir_6
   \   000000D0   0920A0E1           MOV      R2,R9
   \   000000D4   04108DE2           ADD      R1,SP,#+4
   \   000000D8   0500A0E1           MOV      R0,R5
   \   000000DC   ........           BL       FS_FAT_ReadFATEntry
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   7200001A           BNE      ??_GrowRootDir_7
   \   000000E8   019089E2           ADD      R9,R9,#+1
   \                     ??_GrowRootDir_6:
   \   000000EC   A7A0B0E1           LSRS     R10,R7,#+1
   \   000000F0   0F00000A           BEQ      ??_GrowRootDir_5
   \                     ??_GrowRootDir_8:
   \   000000F4   0920A0E1           MOV      R2,R9
   \   000000F8   04108DE2           ADD      R1,SP,#+4
   \   000000FC   0500A0E1           MOV      R0,R5
   \   00000100   ........           BL       FS_FAT_ReadFATEntry
   \   00000104   000050E3           CMP      R0,#+0
   \   00000108   6900001A           BNE      ??_GrowRootDir_7
   \   0000010C   012089E2           ADD      R2,R9,#+1
   \   00000110   04108DE2           ADD      R1,SP,#+4
   \   00000114   0500A0E1           MOV      R0,R5
   \   00000118   ........           BL       FS_FAT_ReadFATEntry
   \   0000011C   000050E3           CMP      R0,#+0
   \   00000120   6300001A           BNE      ??_GrowRootDir_7
   \   00000124   01A04AE2           SUB      R10,R10,#+1
   \   00000128   029089E2           ADD      R9,R9,#+2
   \   0000012C   00005AE3           CMP      R10,#+0
   \   00000130   EFFFFF1A           BNE      ??_GrowRootDir_8
   \                     ??_GrowRootDir_5:
   \   00000134   08B0A0E1           MOV      R11,R8
   \   00000138   000057E3           CMP      R7,#+0
   \   0000013C   3F00000A           BEQ      ??_GrowRootDir_9
   \   00000140   010017E3           TST      R7,#0x1
   \   00000144   1300000A           BEQ      ??_GrowRootDir_10
   \   00000148   0030A0E3           MOV      R3,#+0
   \   0000014C   0B20A0E1           MOV      R2,R11
   \   00000150   04108DE2           ADD      R1,SP,#+4
   \   00000154   0500A0E1           MOV      R0,R5
   \   00000158   ........           BL       FS_FAT_FindFreeCluster
   \   0000015C   0090B0E1           MOVS     R9,R0
   \   00000160   0B00000A           BEQ      ??_GrowRootDir_11
   \   00000164   00005BE3           CMP      R11,#+0
   \   00000168   0400000A           BEQ      ??_GrowRootDir_12
   \   0000016C   0930A0E1           MOV      R3,R9
   \   00000170   0B20A0E1           MOV      R2,R11
   \   00000174   04108DE2           ADD      R1,SP,#+4
   \   00000178   0500A0E1           MOV      R0,R5
   \   0000017C   ........           BL       _WriteFATEntry
   \                     ??_GrowRootDir_12:
   \   00000180   F034E0E3           MVN      R3,#-268435456
   \   00000184   0920A0E1           MOV      R2,R9
   \   00000188   04108DE2           ADD      R1,SP,#+4
   \   0000018C   0500A0E1           MOV      R0,R5
   \   00000190   ........           BL       _WriteFATEntry
   \                     ??_GrowRootDir_11:
   \   00000194   09B0A0E1           MOV      R11,R9
   \                     ??_GrowRootDir_10:
   \   00000198   A790B0E1           LSRS     R9,R7,#+1
   \   0000019C   2700000A           BEQ      ??_GrowRootDir_9
   \                     ??_GrowRootDir_13:
   \   000001A0   0030A0E3           MOV      R3,#+0
   \   000001A4   0B20A0E1           MOV      R2,R11
   \   000001A8   04108DE2           ADD      R1,SP,#+4
   \   000001AC   0500A0E1           MOV      R0,R5
   \   000001B0   ........           BL       FS_FAT_FindFreeCluster
   \   000001B4   00A0B0E1           MOVS     R10,R0
   \   000001B8   0B00000A           BEQ      ??_GrowRootDir_14
   \   000001BC   00005BE3           CMP      R11,#+0
   \   000001C0   0400000A           BEQ      ??_GrowRootDir_15
   \   000001C4   0A30A0E1           MOV      R3,R10
   \   000001C8   0B20A0E1           MOV      R2,R11
   \   000001CC   04108DE2           ADD      R1,SP,#+4
   \   000001D0   0500A0E1           MOV      R0,R5
   \   000001D4   ........           BL       _WriteFATEntry
   \                     ??_GrowRootDir_15:
   \   000001D8   F034E0E3           MVN      R3,#-268435456
   \   000001DC   0A20A0E1           MOV      R2,R10
   \   000001E0   04108DE2           ADD      R1,SP,#+4
   \   000001E4   0500A0E1           MOV      R0,R5
   \   000001E8   ........           BL       _WriteFATEntry
   \                     ??_GrowRootDir_14:
   \   000001EC   0030A0E3           MOV      R3,#+0
   \   000001F0   0A20A0E1           MOV      R2,R10
   \   000001F4   04108DE2           ADD      R1,SP,#+4
   \   000001F8   0500A0E1           MOV      R0,R5
   \   000001FC   ........           BL       FS_FAT_FindFreeCluster
   \   00000200   00B0B0E1           MOVS     R11,R0
   \   00000204   0B00000A           BEQ      ??_GrowRootDir_16
   \   00000208   00005AE3           CMP      R10,#+0
   \   0000020C   0400000A           BEQ      ??_GrowRootDir_17
   \   00000210   0B30A0E1           MOV      R3,R11
   \   00000214   0A20A0E1           MOV      R2,R10
   \   00000218   04108DE2           ADD      R1,SP,#+4
   \   0000021C   0500A0E1           MOV      R0,R5
   \   00000220   ........           BL       _WriteFATEntry
   \                     ??_GrowRootDir_17:
   \   00000224   F034E0E3           MVN      R3,#-268435456
   \   00000228   0B20A0E1           MOV      R2,R11
   \   0000022C   04108DE2           ADD      R1,SP,#+4
   \   00000230   0500A0E1           MOV      R0,R5
   \   00000234   ........           BL       _WriteFATEntry
   \                     ??_GrowRootDir_16:
   \   00000238   019059E2           SUBS     R9,R9,#+1
   \   0000023C   D7FFFF1A           BNE      ??_GrowRootDir_13
   \                     ??_GrowRootDir_9:
   \   00000240   F034E0E3           MVN      R3,#-268435456
   \   00000244   0B20A0E1           MOV      R2,R11
   \   00000248   04108DE2           ADD      R1,SP,#+4
   \   0000024C   0500A0E1           MOV      R0,R5
   \   00000250   ........           BL       _WriteFATEntry
    587                    FS__SB_Delete(&SB);
    588                    return 0;
    589                  }
    590                  //
    591                  //  Update the FAT entry for the root directory
    592                  //
    593                  _WriteFATEntry(pVolume, &SB, pFATInfo->RootDirPos, StartCluster);
   \                     ??_GrowRootDir_4:
   \   00000254   0830A0E1           MOV      R3,R8
   \   00000258   142096E5           LDR      R2,[R6, #+20]
   \   0000025C   04108DE2           ADD      R1,SP,#+4
   \   00000260   0500A0E1           MOV      R0,R5
   \   00000264   ........           BL       _WriteFATEntry
    594                  //
    595                  //  Let the smart buffer flush the .
    596                  //  We need the buffer to zero the new directory sectors
    597                  //
    598                  FS__SB_Clean(&SB);
   \   00000268   04008DE2           ADD      R0,SP,#+4
   \   0000026C   ........           BL       FS__SB_Clean
    599                  FS_MEMSET(SB.pBuffer, 0x00, pFATInfo->BytesPerSec);
   \   00000270   B410D6E1           LDRH     R1,[R6, #+4]
   \   00000274   0C009DE5           LDR      R0,[SP, #+12]
   \   00000278   ........           BL       __aeabi_memclr
   \   0000027C   1C00D6E5           LDRB     R0,[R6, #+28]
   \   00000280   0110A0E3           MOV      R1,#+1
   \   00000284   00108DE5           STR      R1,[SP, #+0]
   \   00000288   081096E5           LDR      R1,[R6, #+8]
   \   0000028C   02C048E2           SUB      R12,R8,#+2
   \   00000290   900702E0           MUL      R2,R0,R7
   \   00000294   901C21E0           MLA      R1,R0,R12,R1
   \   00000298   0C309DE5           LDR      R3,[SP, #+12]
   \   0000029C   0500A0E1           MOV      R0,R5
    600                  StartSector = FS_FAT_ClusterId2SectorNo(pFATInfo, StartCluster);
    601                  NumSectors  = NumClustersReq * pFATInfo->SecPerClus;
    602                  FS_LB_WriteMultiplePart(&pVolume->Partition, StartSector, NumSectors, SB.pBuffer, FS_SECTOR_TYPE_DIR);
   \   000002A0   ........           BL       FS_LB_WriteMultiplePart
    603                  FS__SB_Delete(&SB);
   \   000002A4   04008DE2           ADD      R0,SP,#+4
   \   000002A8   ........           BL       FS__SB_Delete
    604                  return NumAddEntries;
   \   000002AC   0400A0E1           MOV      R0,R4
   \   000002B0   040000EA           B        ??_GrowRootDir_18
   \                     ??_GrowRootDir_7:
   \   000002B4   04008DE2           ADD      R0,SP,#+4
   \   000002B8   ........           BL       FS__SB_Delete
   \   000002BC   0000A0E3           MOV      R0,#+0
   \   000002C0   000000EA           B        ??_GrowRootDir_18
    605                }
    606              }
    607          
    608            }
    609            return 0xFFFFFFFFUL;
   \                     ??_GrowRootDir_0:
   \   000002C4   0000E0E3           MVN      R0,#+0
   \                     ??_GrowRootDir_18:
   \   000002C8   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000002CC   F08FBDE8           POP      {R4-R11,PC}      ;; return
    610          }
    611          
    612          /*********************************************************************
    613          *
    614          *       _WriteEmptyFATSectors
    615          *
    616          *  Function description:
    617          *    This ...
    618          *
    619          *
    620          *  Notes
    621          */
    622          #if FS_FAT_OPTIMIZE_DELETE
    623          static void _WriteEmptyFATSectors(FS_SB * pSB, U32 FirstFreeFATSector, U32 LastFreeFATSector) {
    624            U32 NumSectors;
    625            if (LastFreeFATSector != 0xFFFFFFFFUL) {
    626              NumSectors = LastFreeFATSector - FirstFreeFATSector + 1;
    627              if (NumSectors) {
    628                FS__SB_Clean(pSB);
    629                FS_MEMSET(pSB->pBuffer, 0, FS_Global.MaxSectorSize);
    630                FS_LB_WriteMultiplePart(pSB->pPart, FirstFreeFATSector, NumSectors, pSB->pBuffer, FS_SECTOR_TYPE_MAN);
    631                //
    632                //  Invalidate in smart buffer that this sector has been read.
    633                //
    634                pSB->Read = 0;
    635              }
    636            }
    637          }
    638          #endif
    639          
    640          /*********************************************************************
    641          *
    642          *       _SectorIsBlank
    643          *
    644          *  Function description:
    645          *    This ...
    646          *
    647          *
    648          */
    649          #if FS_FAT_OPTIMIZE_DELETE
    650          static int _SectorIsBlank(U32 * pSectorBuffer, unsigned SectorSizeU32) {
    651            do {
    652              if (*pSectorBuffer++ != 0) {
    653                return 0;                  /* Not blank */
    654              }
    655            } while (--SectorSizeU32);
    656            return 1;                      /* Blank */
    657          }
    658          #endif
    659          
    660          /*********************************************************************
    661          *
    662          *       _CalcFreeClusterCnt
    663          *
    664          *  Function description:
    665          *    Only used if FS_WRITEMODE_FAST is selected.
    666          *    
    667          *
    668          *  Parameters:
    669          *    pVolume    - 
    670          *    pSB    - 
    671          *  
    672          *  Return value:
    673          *    void       - 
    674          *
    675          */

   \                                 In section .text, align 4, keep-with-next
    676          static void _CalcFreeClusterCnt(FS_VOLUME * pVolume, FS_SB * pSB, U32 StartCluster, FS_FILE * pFile) {
   \                     _CalcFreeClusterCnt:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370B0E1           MOVS     R7,R3
    677            U32 LastCluster;
    678            U32 Off;
    679            U32 LastOff;
    680            U32 iCluster;
    681            FS_FAT_INFO * pFATInfo;
    682          
    683            if (pFile) {
   \   00000014   3100000A           BEQ      ??_CalcFreeClusterCnt_0
    684              pFATInfo = &pVolume->FSInfo.FATInfo;
   \   00000018   1C8084E2           ADD      R8,R4,#+28
   \   0000001C   1E10D8E5           LDRB     R1,[R8, #+30]
   \   00000020   0C0051E2           SUBS     R0,R1,#+12
   \   00000024   0300000A           BEQ      ??_CalcFreeClusterCnt_1
   \   00000028   040050E2           SUBS     R0,R0,#+4
    685              Off     = _ClusterId2FATOff(pFATInfo->FATType, StartCluster) & (pFATInfo->BytesPerSec - 1);
   \   0000002C   8600A001           LSLEQ    R0,R6,#+1
   \   00000030   0601A011           LSLNE    R0,R6,#+2
   \   00000034   000000EA           B        ??_CalcFreeClusterCnt_2
   \                     ??_CalcFreeClusterCnt_1:
   \   00000038   A60086E0           ADD      R0,R6,R6, LSR #+1
   \                     ??_CalcFreeClusterCnt_2:
   \   0000003C   B420D8E1           LDRH     R2,[R8, #+4]
    686              LastOff = pFATInfo->BytesPerSec - 1;
    687              LastCluster = ((LastOff - Off) << 3) / pFATInfo->FATType + StartCluster;
    688              for (iCluster = StartCluster; iCluster <= LastCluster; iCluster++) {
   \   00000040   06A0A0E1           MOV      R10,R6
   \   00000044   012042E2           SUB      R2,R2,#+1
   \   00000048   000002E0           AND      R0,R2,R0
   \   0000004C   000042E0           SUB      R0,R2,R0
   \   00000050   8001A0E1           LSL      R0,R0,#+3
   \   00000054   ........           BL       __aeabi_uidiv
   \   00000058   009086E0           ADD      R9,R6,R0
   \   0000005C   0A0059E1           CMP      R9,R10
   \   00000060   0E00003A           BCC      ??_CalcFreeClusterCnt_3
    689                if (FS_FAT_ReadFATEntry(pVolume, pSB, iCluster) == 0) {
   \                     ??_CalcFreeClusterCnt_4:
   \   00000064   0A20A0E1           MOV      R2,R10
   \   00000068   0510A0E1           MOV      R1,R5
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   ........           BL       FS_FAT_ReadFATEntry
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   0800001A           BNE      ??_CalcFreeClusterCnt_3
    690                  if (pFATInfo->FreeClusterStart == 0) {
   \   0000007C   300098E5           LDR      R0,[R8, #+48]
   \   00000080   000050E3           CMP      R0,#+0
    691                    pFATInfo->FreeClusterStart = iCluster;
   \   00000084   30A08805           STREQ    R10,[R8, #+48]
    692                  }
    693                  pFATInfo->FreeClusterCnt++;
   \   00000088   340098E5           LDR      R0,[R8, #+52]
    694                } else {
    695                  break;
    696                }
    697              }
   \   0000008C   01A08AE2           ADD      R10,R10,#+1
   \   00000090   010080E2           ADD      R0,R0,#+1
   \   00000094   340088E5           STR      R0,[R8, #+52]
   \   00000098   0A0059E1           CMP      R9,R10
   \   0000009C   F0FFFF2A           BCS      ??_CalcFreeClusterCnt_4
    698              if (pFATInfo->FreeClusterCnt) {
   \                     ??_CalcFreeClusterCnt_3:
   \   000000A0   340098E5           LDR      R0,[R8, #+52]
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   0C00000A           BEQ      ??_CalcFreeClusterCnt_0
    699                pFATInfo->pFileUsedWithFreeCluster = pFile;
   \   000000AC   3C7088E5           STR      R7,[R8, #+60]
    700                LastCluster = pFile->pFileObj->Data.Fat.CurClusterAbs;
   \   000000B0   000097E5           LDR      R0,[R7, #+0]
   \   000000B4   149090E5           LDR      R9,[R0, #+20]
    701                if (LastCluster) {
   \   000000B8   000059E3           CMP      R9,#+0
   \   000000BC   0400000A           BEQ      ??_CalcFreeClusterCnt_5
    702                  _WriteFATEntry(pVolume, pSB, LastCluster, StartCluster);
   \   000000C0   0630A0E1           MOV      R3,R6
   \   000000C4   0920A0E1           MOV      R2,R9
   \   000000C8   0510A0E1           MOV      R1,R5
   \   000000CC   0400A0E1           MOV      R0,R4
   \   000000D0   ........           BL       _WriteFATEntry
    703                }
    704                pFATInfo->FreeClusterUse++;
   \                     ??_CalcFreeClusterCnt_5:
   \   000000D4   380098E5           LDR      R0,[R8, #+56]
   \   000000D8   010080E2           ADD      R0,R0,#+1
   \   000000DC   380088E5           STR      R0,[R8, #+56]
    705              }
    706            }
    707          }
   \                     ??_CalcFreeClusterCnt_0:
   \   000000E0   F087BDE8           POP      {R4-R10,PC}      ;; return
    708          
    709          /*********************************************************************
    710          *
    711          *       _Value2FatEntry
    712          *
    713          */
    714          static U32 _Value2FatEntry(char FATType, U32 Cluster) {
    715            switch (FATType) {
    716            case FS_FAT_TYPE_FAT12:
    717              return ((Cluster & 0xFFF));
    718            case FS_FAT_TYPE_FAT16:
    719              return ((Cluster & 0xFFFF));
    720            }
    721            return ((Cluster & 0xFFFFFFFUL));
    722          }
    723          
    724          /*********************************************************************
    725          *
    726          *       _ReadFromFreeClusterCache
    727          *
    728          */
    729          static char _ReadFromFreeClusterCache(FS_VOLUME * pVolume, U32 Cluster, U32 * pFATEntry) {
    730            FS_FAT_INFO * pFATInfo;
    731            U32           FreeClusterStart;
    732            U32           FreeClusterUse;
    733            char          SkipRead;
    734            U32           FATEntry;
    735          
    736            SkipRead         = 0;
    737            pFATInfo         = &pVolume->FSInfo.FATInfo;
    738            FreeClusterStart = pFATInfo->FreeClusterStart;
    739            FreeClusterUse   = pFATInfo->FreeClusterUse;
    740          
    741            //
    742            // Check if we have used any
    743            //
    744            if (pFATInfo->FreeClusterUse) {
    745              //
    746              //  We need to simulate the FAT here in order to give the right value
    747              //
    748              if ((Cluster >= FreeClusterStart) && (Cluster < (FreeClusterStart + FreeClusterUse))) {
    749                //
    750                // Check whether within our internal free cluster cache range
    751                //
    752                if (Cluster == (FreeClusterStart  + FreeClusterUse - 1)) {
    753                  FATEntry = 0xffffffff;
    754                } else {
    755                  FATEntry = Cluster + 1;
    756                }
    757                //
    758                // Give the entry in correct entry size
    759                //
    760                if (pFATEntry) {
    761                  *pFATEntry  = _Value2FatEntry(pFATInfo->FATType, FATEntry);
    762                }
    763                SkipRead  = 1;   // No need to read the entry from real FAT table
    764              }
    765            }
    766            return SkipRead;
    767          }
    768          
    769          /*********************************************************************
    770          *
    771          *       Public code
    772          *
    773          **********************************************************************
    774          */
    775          
    776          /*********************************************************************
    777          *
    778          *       FS_FAT_CheckBPB
    779          *
    780          *  Description:
    781          *    Read Bios-Parameter-Block from a device and analyze this sector.
    782          *
    783          *  Parameters:
    784          *    pVolume     - pointer to volume the BPB should be read.
    785          *
    786          *  Return value:
    787          *    1           - BPB successfully read and contains valid information.
    788          *    0           - An error has occurred.
    789          */

   \                                 In section .text, align 4, keep-with-next
    790          int FS_FAT_CheckBPB(FS_VOLUME * pVolume) {
   \                     FS_FAT_CheckBPB:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
    791            int     r;
    792            U8 * pBuffer;
    793            U16  BytesPerSector;
    794          
    795            pBuffer = FS__AllocSectorBuffer();
   \   0000000C   ........           BL       FS__AllocSectorBuffer
   \   00000010   0050B0E1           MOVS     R5,R0
    796            r = 0;
    797            if (pBuffer == NULL) {
   \   00000014   0100001A           BNE      ??FS_FAT_CheckBPB_0
    798              return 0;
   \                     ??FS_FAT_CheckBPB_1:
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   180000EA           B        ??FS_FAT_CheckBPB_2
    799            }
    800            BytesPerSector = FS_GetSectorSize(&pVolume->Partition.Device);
   \                     ??FS_FAT_CheckBPB_0:
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       FS_GetSectorSize
    801            /*
    802             * Check if the a sector fits into the sector buffer
    803             */
    804            if ((BytesPerSector > FS_Global.MaxSectorSize) || (BytesPerSector == 0)) {
   \   00000028   ........           LDR      R1,??DataTable6
   \   0000002C   B011D1E1           LDRH     R1,[R1, #+16]
   \   00000030   000051E1           CMP      R1,R0
   \   00000034   010000BA           BLT      ??FS_FAT_CheckBPB_3
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0200001A           BNE      ??FS_FAT_CheckBPB_4
    805              FS_DEBUG_ERROROUT((FS_MTYPE_FS, "FS_FAT_CheckBPB: Invalid BytesPerSector value: %d.\n", BytesPerSector));
    806              FS__FreeSectorBuffer(pBuffer);
   \                     ??FS_FAT_CheckBPB_3:
   \   00000040   0500A0E1           MOV      R0,R5
   \   00000044   ........           BL       FS__FreeSectorBuffer
    807              return 0;
   \   00000048   F2FFFFEA           B        ??FS_FAT_CheckBPB_1
    808            }
    809          
    810            r = FS_LB_ReadPart(&pVolume->Partition, 0, (void*)pBuffer, FS_SECTOR_TYPE_DATA);
    811            if (r < 0) {
   \                     ??FS_FAT_CheckBPB_4:
   \   0000004C   0030A0E3           MOV      R3,#+0
   \   00000050   0520A0E1           MOV      R2,R5
   \   00000054   0010A0E3           MOV      R1,#+0
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           BL       FS_LB_ReadPart
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   F5FFFF4A           BMI      ??FS_FAT_CheckBPB_3
    812              FS__FreeSectorBuffer(pBuffer);
    813              return 0;
    814            }
    815          
    816            r = _CheckBPB(pVolume, pBuffer);
   \   00000068   0510A0E1           MOV      R1,R5
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   ........           BL       _CheckBPB
   \   00000074   0040A0E1           MOV      R4,R0
    817            FS__FreeSectorBuffer(pBuffer);
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           BL       FS__FreeSectorBuffer
    818            return r;
   \   00000080   0400A0E1           MOV      R0,R4
   \                     ??FS_FAT_CheckBPB_2:
   \   00000084   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000088   3080BDE8           POP      {R4,R5,PC}       ;; return
    819          }
    820          
    821          /*********************************************************************
    822          *
    823          *       FS_FAT_GetFATType
    824          *
    825          *  Description:
    826          *    Returns the FAT type.
    827          *
    828          *  Parameters:
    829          *    Number of available clusters
    830          *
    831          *  Return value:
    832          *    FAT type
    833          */

   \                                 In section .text, align 4, keep-with-next
    834          char FS_FAT_GetFATType(U32 NumClusters) {
    835            char FATType;
    836            if (NumClusters < 4085) {
   \                     FS_FAT_GetFATType:
   \   00000000   F510A0E3           MOV      R1,#+245
   \   00000004   F01E81E3           ORR      R1,R1,#0xF00
   \   00000008   010050E1           CMP      R0,R1
   \   0000000C   0100002A           BCS      ??FS_FAT_GetFATType_0
    837              FATType = FS_FAT_TYPE_FAT12;
   \   00000010   0C00A0E3           MOV      R0,#+12
   \   00000014   1EFF2FE1           BX       LR
    838            } else if (NumClusters < 65525UL) {
   \                     ??FS_FAT_GetFATType_0:
   \   00000018   F01C81E3           ORR      R1,R1,#0xF000
   \   0000001C   010050E1           CMP      R0,R1
   \   00000020   0100002A           BCS      ??FS_FAT_GetFATType_1
    839              FATType = FS_FAT_TYPE_FAT16;  /* FAT16 */
   \   00000024   1000A0E3           MOV      R0,#+16
   \   00000028   1EFF2FE1           BX       LR
    840            } else {
    841              FATType = FS_FAT_TYPE_FAT32;    /* FAT32 */
   \                     ??FS_FAT_GetFATType_1:
   \   0000002C   2000A0E3           MOV      R0,#+32
    842            }
    843            return FATType;
   \   00000030   1EFF2FE1           BX       LR               ;; return
    844          }
    845          
    846          /*********************************************************************
    847          *
    848          *       FS_FAT_ClusterId2SectorNo
    849          *
    850          *  Function description
    851          *    Converts the cluster Id into a sector number. The SectorNo can then
    852          *    be used to read write the .
    853          *
    854          *  Return value
    855          *    SectorNo of the first sector of the specified cluster
    856          *
    857          *  Notes
    858          *    The  area (start of cluster 2) starts right behind the root directory,
    859          *    which in turn lies right behind the FAT(s) (usually 2).
    860          */

   \                                 In section .text, align 4, keep-with-next
    861          U32 FS_FAT_ClusterId2SectorNo(FS_FAT_INFO * pFATInfo, U32 ClusterId) {
    862            return pFATInfo->FirstDataSector + (ClusterId - FAT_FIRST_CLUSTER) * pFATInfo->SecPerClus;
   \                     FS_FAT_ClusterId2SectorNo:
   \   00000000   1C30D0E5           LDRB     R3,[R0, #+28]
   \   00000004   082090E5           LDR      R2,[R0, #+8]
   \   00000008   021041E2           SUB      R1,R1,#+2
   \   0000000C   932120E0           MLA      R0,R3,R1,R2
   \   00000010   1EFF2FE1           BX       LR               ;; return
    863          }
    864          
    865          /*********************************************************************
    866          *
    867          *       FS_FAT_ReadFATEntry
    868          *
    869          *  Function description
    870          *
    871          *  Return value
    872          *    The value of the FAT entry as defined in the FAT spec.
    873          *    0xFFFFFFFF is illegal and used on error
    874          *
    875          *  Notes
    876          *    (1) Pointer incrementing
    877          *        The  pointer is pre-incremented before accesses for the
    878          *        FAT32 entries. This is so because it does in fact allow the
    879          *        compiler to generate better code.
    880          *    (2) This cast is necessary, because the value is promoted to a
    881          *        signed int. On 16bit target this value could be negative and
    882          *        would result in using the wrong FAT entry value.
    883          *
    884          */

   \                                 In section .text, align 4, keep-with-next
    885          U32 FS_FAT_ReadFATEntry(FS_VOLUME * pVolume, FS_SB * pSB, U32 ClusterId) {
   \                     FS_FAT_ReadFATEntry:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
    886            U32 FATEntry;
    887            U32 SectorNo;
    888            U32 Off;          /* Total offset in bytes */
    889            U16 SectorOff;    /* Offset within the sector */
    890            U8  FATType;
    891            U8 * pData;
    892            FS_FAT_INFO* pFATInfo;
    893          
    894            pFATInfo = &pVolume->FSInfo.FATInfo;
   \   00000004   1C8080E2           ADD      R8,R0,#+28
    895            FATType = pFATInfo->FATType;
   \   00000008   1E50D8E5           LDRB     R5,[R8, #+30]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0160A0E1           MOV      R6,R1
   \   00000014   0240A0E1           MOV      R4,R2
    896            Off = _ClusterId2FATOff(FATType, ClusterId);
   \   00000018   0C0055E2           SUBS     R0,R5,#+12
   \   0000001C   0300000A           BEQ      ??FS_FAT_ReadFATEntry_0
   \   00000020   040050E2           SUBS     R0,R0,#+4
   \   00000024   8490A001           LSLEQ    R9,R4,#+1
   \   00000028   0491A011           LSLNE    R9,R4,#+2
   \   0000002C   000000EA           B        ??FS_FAT_ReadFATEntry_1
   \                     ??FS_FAT_ReadFATEntry_0:
   \   00000030   A49084E0           ADD      R9,R4,R4, LSR #+1
   \                     ??FS_FAT_ReadFATEntry_1:
   \   00000034   B600D8E1           LDRH     R0,[R8, #+6]
   \   00000038   101098E5           LDR      R1,[R8, #+16]
   \   0000003C   3900A0E1           LSR      R0,R9,R0
   \   00000040   010050E1           CMP      R0,R1
    897            if ((Off >> pFATInfo->ldBytesPerSector) >= pFATInfo->FATSize) {
    898              FS_DEBUG_WARN((FS_MTYPE_FS, "FS_FAT_ReadFATEntry is trying to read beyond the FAT. ClusterId = 0x%x", ClusterId));
    899              return 0;
   \   00000044   0000A023           MOVCS    R0,#+0
   \   00000048   2D00002A           BCS      ??FS_FAT_ReadFATEntry_2
    900            }
    901            SectorNo = pFATInfo->RsvdSecCnt + (Off >> pFATInfo->ldBytesPerSector);
   \   0000004C   BA11D8E1           LDRH     R1,[R8, #+26]
    902            _SetFATSector(pSB, SectorNo, pFATInfo);
   \   00000050   0220A0E3           MOV      R2,#+2
   \   00000054   017080E0           ADD      R7,R0,R1
   \   00000058   0710A0E1           MOV      R1,R7
   \   0000005C   0600A0E1           MOV      R0,R6
   \   00000060   ........           BL       FS__SB_SetSector
    903            if (FS__SB_Read(pSB)) {
   \   00000064   0600A0E1           MOV      R0,R6
   \   00000068   ........           BL       FS__SB_Read
   \   0000006C   000050E3           CMP      R0,#+0
    904              FS_DEBUG_WARN((FS_MTYPE_FS, "FS_FAT_ReadFATEntry() : Read error"));
    905              return 0xFFFFFFFF;
   \   00000070   0000E013           MVNNE    R0,#+0
   \   00000074   2200001A           BNE      ??FS_FAT_ReadFATEntry_2
    906            }
    907            SectorOff = (U16)(Off & (pFATInfo->BytesPerSec - 1));
   \   00000078   B400D8E1           LDRH     R0,[R8, #+4]
    908            pData = pSB->pBuffer + SectorOff;
   \   0000007C   082096E5           LDR      R2,[R6, #+8]
   \   00000080   011040E2           SUB      R1,R0,#+1
   \   00000084   091001E0           AND      R1,R1,R9
   \   00000088   0118A0E1           LSL      R1,R1,#+16
   \   0000008C   2118A0E1           LSR      R1,R1,#+16
   \   00000090   022081E0           ADD      R2,R1,R2
    909          
    910            FATEntry = *pData++;
    911            if (SectorOff == pFATInfo->BytesPerSec - 1) {    /* With Fat12, the next byte could be in the next sector */
   \   00000094   010040E2           SUB      R0,R0,#+1
   \   00000098   0180D2E4           LDRB     R8,[R2], #+1
   \   0000009C   000051E1           CMP      R1,R0
   \   000000A0   0600001A           BNE      ??FS_FAT_ReadFATEntry_3
    912              _SetFATSector(pSB, SectorNo + 1, pFATInfo);
   \   000000A4   0220A0E3           MOV      R2,#+2
   \   000000A8   011087E2           ADD      R1,R7,#+1
   \   000000AC   0600A0E1           MOV      R0,R6
   \   000000B0   ........           BL       FS__SB_SetSector
    913              FS__SB_Read(pSB);
   \   000000B4   0600A0E1           MOV      R0,R6
   \   000000B8   ........           BL       FS__SB_Read
    914              pData = pSB->pBuffer;
   \   000000BC   082096E5           LDR      R2,[R6, #+8]
    915            }
    916            FATEntry |= ((U32)*pData) << 8;                         /* Note 1, Note 3 */
   \                     ??FS_FAT_ReadFATEntry_3:
   \   000000C0   0000D2E5           LDRB     R0,[R2, #+0]
    917            switch (FATType) {
   \   000000C4   0C5055E2           SUBS     R5,R5,#+12
   \   000000C8   000488E1           ORR      R0,R8,R0, LSL #+8
   \   000000CC   0800000A           BEQ      ??FS_FAT_ReadFATEntry_4
   \   000000D0   145055E2           SUBS     R5,R5,#+20
   \   000000D4   0A00001A           BNE      ??FS_FAT_ReadFATEntry_2
    918            case FS_FAT_TYPE_FAT32:      /* We have to read 2 more bytes */
    919              FATEntry |= ((U32)*++pData) << 16;          /* Note 1 */
   \   000000D8   011082E2           ADD      R1,R2,#+1
    920              FATEntry |= ((U32)*++pData) << 24;          /* Note 1 */
   \   000000DC   0020D1E5           LDRB     R2,[R1, #+0]
   \   000000E0   0110D1E5           LDRB     R1,[R1, #+1]
   \   000000E4   011CA0E1           LSL      R1,R1,#+24
   \   000000E8   021881E1           ORR      R1,R1,R2, LSL #+16
   \   000000EC   000081E1           ORR      R0,R1,R0
    921              break;
   \   000000F0   030000EA           B        ??FS_FAT_ReadFATEntry_2
    922            case FS_FAT_TYPE_FAT12:
    923              if (ClusterId & 1) {
   \                     ??FS_FAT_ReadFATEntry_4:
   \   000000F4   010014E3           TST      R4,#0x1
    924                FATEntry >>= 4;
    925              } else {
    926                FATEntry &= 0xfff;
   \   000000F8   000AA001           LSLEQ    R0,R0,#+20
   \   000000FC   2002A011           LSRNE    R0,R0,#+4
   \   00000100   200AA001           LSREQ    R0,R0,#+20
    927              }
    928            }
    929            return FATEntry;
   \                     ??FS_FAT_ReadFATEntry_2:
   \   00000104   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000108   F083BDE8           POP      {R4-R9,PC}       ;; return
    930          }
    931          
    932          
    933          /*********************************************************************
    934          *
    935          *       FS_FAT_FindFreeCluster
    936          *
    937          *  Function description
    938          *    Finds the first available sector in the FAT.
    939          *    Search starts at the specified cluster number, which makes it
    940          *    possible to allocate consecutive sectors (if available)
    941          *
    942          *  Parameters
    943          *    FirstCluster         Index of the first free cluster to look at.
    944          *                         Can be 0 or out of range, in which case the first cluster assumed to be free is used.
    945          *
    946          *  Return value
    947          *    ClusterId   if free cluster has been found
    948          *    0           if no free cluster is available
    949          *
    950          *  Notes
    951          */

   \                                 In section .text, align 4, keep-with-next
    952          U32 FS_FAT_FindFreeCluster(FS_VOLUME * pVolume, FS_SB * pSB, U32 FirstCluster, FS_FILE * pFile) {
   \                     FS_FAT_FindFreeCluster:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    953            U32           i;
    954            U32          LastCluster;
    955            FS_FAT_INFO* pFATInfo;
    956          
    957            pFATInfo    = &pVolume->FSInfo.FATInfo;
   \   00000008   1C7084E2           ADD      R7,R4,#+28
    958            LastCluster = pFATInfo->NumClusters + FAT_FIRST_CLUSTER - 1;    /* Cluster id of first cluster is 2 */
   \   0000000C   200097E5           LDR      R0,[R7, #+32]
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   018080E2           ADD      R8,R0,#+1
    959            if (FS_Global.WriteMode == FS_WRITEMODE_FAST) {
   \   00000018   ........           LDR      R0,??DataTable6
   \   0000001C   0260A0E1           MOV      R6,R2
   \   00000020   8400D0E5           LDRB     R0,[R0, #+132]
   \   00000024   020050E3           CMP      R0,#+2
   \   00000028   4600001A           BNE      ??FS_FAT_FindFreeCluster_0
    960              //
    961              // Check if the file is changed. If so then we need to sync
    962              //
    963              if ((pFile != pFATInfo->pFileUsedWithFreeCluster)  && (pFATInfo->FreeClusterCnt)) {
   \   0000002C   3C1097E5           LDR      R1,[R7, #+60]
   \   00000030   010053E1           CMP      R3,R1
   \   00000034   34009715           LDRNE    R0,[R7, #+52]
   \   00000038   00005013           CMPNE    R0,#+0
   \   0000003C   1200000A           BEQ      ??FS_FAT_FindFreeCluster_1
    964                FS_FAT_SyncFAT(pVolume, pSB);
   \   00000040   1C9084E2           ADD      R9,R4,#+28
   \   00000044   30A089E2           ADD      R10,R9,#+48
   \   00000048   08009AE5           LDR      R0,[R10, #+8]
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0900000A           BEQ      ??FS_FAT_FindFreeCluster_2
   \   00000054   00B0A0E3           MOV      R11,#+0
   \   00000058   010050E2           SUBS     R0,R0,#+1
   \   0000005C   1B00001A           BNE      ??FS_FAT_FindFreeCluster_3
   \                     ??FS_FAT_FindFreeCluster_4:
   \   00000060   300099E5           LDR      R0,[R9, #+48]
   \   00000064   F034E0E3           MVN      R3,#-268435456
   \   00000068   0B2080E0           ADD      R2,R0,R11
   \   0000006C   0510A0E1           MOV      R1,R5
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   ........           BL       _WriteFATEntry
   \   00000078   0000A0E3           MOV      R0,#+0
   \                     ??FS_FAT_FindFreeCluster_2:
   \   0000007C   300089E5           STR      R0,[R9, #+48]
   \   00000080   08008AE5           STR      R0,[R10, #+8]
   \   00000084   04008AE5           STR      R0,[R10, #+4]
   \   00000088   0C008AE5           STR      R0,[R10, #+12]
    965              }
    966              //
    967              // Can we handle the free cluster from the free fat cache.
    968              //
    969              if ((pFile != NULL)) {
   \                     ??FS_FAT_FindFreeCluster_1:
   \   0000008C   00009DE5           LDR      R0,[SP, #+0]
   \   00000090   000050E3           CMP      R0,#+0
   \   00000094   2B00000A           BEQ      ??FS_FAT_FindFreeCluster_0
    970                if (pFATInfo->pFileUsedWithFreeCluster == pFile) {
   \   00000098   3C0097E5           LDR      R0,[R7, #+60]
   \   0000009C   00109DE5           LDR      R1,[SP, #+0]
   \   000000A0   010050E1           CMP      R0,R1
   \   000000A4   2700001A           BNE      ??FS_FAT_FindFreeCluster_0
    971                  if (pFATInfo->FreeClusterCnt > pFATInfo->FreeClusterUse) {
   \   000000A8   380097E5           LDR      R0,[R7, #+56]
   \   000000AC   341097E5           LDR      R1,[R7, #+52]
   \   000000B0   010050E1           CMP      R0,R1
   \   000000B4   1100002A           BCS      ??FS_FAT_FindFreeCluster_5
    972                    
    973                    i = pFATInfo->FreeClusterStart + pFATInfo->FreeClusterUse;
   \   000000B8   301097E5           LDR      R1,[R7, #+48]
   \   000000BC   019080E0           ADD      R9,R0,R1
    974                    pFATInfo->FreeClusterUse++;
   \   000000C0   010080E2           ADD      R0,R0,#+1
   \   000000C4   380087E5           STR      R0,[R7, #+56]
    975                    return i;
   \                     ??FS_FAT_FindFreeCluster_6:
   \   000000C8   0900A0E1           MOV      R0,R9
   \   000000CC   5F0000EA           B        ??FS_FAT_FindFreeCluster_7
   \                     ??FS_FAT_FindFreeCluster_3:
   \   000000D0   300099E5           LDR      R0,[R9, #+48]
   \   000000D4   0510A0E1           MOV      R1,R5
   \   000000D8   0B2080E0           ADD      R2,R0,R11
   \   000000DC   013082E2           ADD      R3,R2,#+1
   \   000000E0   0400A0E1           MOV      R0,R4
   \   000000E4   ........           BL       _WriteFATEntry
   \   000000E8   08009AE5           LDR      R0,[R10, #+8]
   \   000000EC   01B08BE2           ADD      R11,R11,#+1
   \   000000F0   010040E2           SUB      R0,R0,#+1
   \   000000F4   00005BE1           CMP      R11,R0
   \   000000F8   F4FFFF3A           BCC      ??FS_FAT_FindFreeCluster_3
   \   000000FC   D7FFFFEA           B        ??FS_FAT_FindFreeCluster_4
    976                  } else {
    977                    FS_FAT_SyncFAT(pVolume, pSB);
   \                     ??FS_FAT_FindFreeCluster_5:
   \   00000100   1C9084E2           ADD      R9,R4,#+28
   \   00000104   30A089E2           ADD      R10,R9,#+48
   \   00000108   000050E3           CMP      R0,#+0
   \   0000010C   0900000A           BEQ      ??FS_FAT_FindFreeCluster_8
   \   00000110   00B0A0E3           MOV      R11,#+0
   \   00000114   010050E2           SUBS     R0,R0,#+1
   \   00000118   1D00001A           BNE      ??FS_FAT_FindFreeCluster_9
   \                     ??FS_FAT_FindFreeCluster_10:
   \   0000011C   300099E5           LDR      R0,[R9, #+48]
   \   00000120   F034E0E3           MVN      R3,#-268435456
   \   00000124   0B2080E0           ADD      R2,R0,R11
   \   00000128   0510A0E1           MOV      R1,R5
   \   0000012C   0400A0E1           MOV      R0,R4
   \   00000130   ........           BL       _WriteFATEntry
   \   00000134   0000A0E3           MOV      R0,#+0
   \                     ??FS_FAT_FindFreeCluster_8:
   \   00000138   300089E5           STR      R0,[R9, #+48]
   \   0000013C   08008AE5           STR      R0,[R10, #+8]
   \   00000140   04008AE5           STR      R0,[R10, #+4]
   \   00000144   0C008AE5           STR      R0,[R10, #+12]
    978                  }
    979                }
    980              }
    981            }
    982          
    983            /* Compute the first cluster to look at. If no valid cluster is specified, try the next one which should be free. */
    984            if ((FirstCluster < FAT_FIRST_CLUSTER) || (FirstCluster > LastCluster)) {
   \                     ??FS_FAT_FindFreeCluster_0:
   \   00000148   020056E3           CMP      R6,#+2
   \   0000014C   06005821           CMPCS    R8,R6
    985              FirstCluster = pFATInfo->NextFreeCluster;
   \   00000150   28609735           LDRCC    R6,[R7, #+40]
    986            }
    987            if ((FirstCluster < FAT_FIRST_CLUSTER) || (FirstCluster > LastCluster)) {
   \   00000154   02005633           CMPCC    R6,#+2
   \   00000158   06005821           CMPCS    R8,R6
    988              FirstCluster = FAT_FIRST_CLUSTER;
   \   0000015C   0260A033           MOVCC    R6,#+2
    989            }
    990            i = FirstCluster;
   \   00000160   0690A0E1           MOV      R9,R6
    991            //
    992            // Search starting with the given cluster
    993            //
    994            do {
    995              if (FS_FAT_ReadFATEntry(pVolume, pSB, i) == 0) {
   \                     ??FS_FAT_FindFreeCluster_11:
   \   00000164   0920A0E1           MOV      R2,R9
   \   00000168   0510A0E1           MOV      R1,R5
   \   0000016C   0400A0E1           MOV      R0,R4
   \   00000170   ........           BL       FS_FAT_ReadFATEntry
   \   00000174   000050E3           CMP      R0,#+0
   \   00000178   1100001A           BNE      ??FS_FAT_FindFreeCluster_12
    996                _CalcFreeClusterCnt(pVolume, pSB, i, pFile);
   \                     ??FS_FAT_FindFreeCluster_13:
   \   0000017C   00309DE5           LDR      R3,[SP, #+0]
   \   00000180   0920A0E1           MOV      R2,R9
   \   00000184   0510A0E1           MOV      R1,R5
   \   00000188   0400A0E1           MOV      R0,R4
   \   0000018C   ........           BL       _CalcFreeClusterCnt
    997                return i;      /* We found a free cluster */
   \   00000190   CCFFFFEA           B        ??FS_FAT_FindFreeCluster_6
   \                     ??FS_FAT_FindFreeCluster_9:
   \   00000194   300099E5           LDR      R0,[R9, #+48]
   \   00000198   0510A0E1           MOV      R1,R5
   \   0000019C   0B2080E0           ADD      R2,R0,R11
   \   000001A0   013082E2           ADD      R3,R2,#+1
   \   000001A4   0400A0E1           MOV      R0,R4
   \   000001A8   ........           BL       _WriteFATEntry
   \   000001AC   08009AE5           LDR      R0,[R10, #+8]
   \   000001B0   01B08BE2           ADD      R11,R11,#+1
   \   000001B4   010040E2           SUB      R0,R0,#+1
   \   000001B8   00005BE1           CMP      R11,R0
   \   000001BC   F4FFFF3A           BCC      ??FS_FAT_FindFreeCluster_9
   \   000001C0   D5FFFFEA           B        ??FS_FAT_FindFreeCluster_10
    998              }
    999            } while (++i <= LastCluster);
   \                     ??FS_FAT_FindFreeCluster_12:
   \   000001C4   019089E2           ADD      R9,R9,#+1
   \   000001C8   090058E1           CMP      R8,R9
   \   000001CC   E4FFFF2A           BCS      ??FS_FAT_FindFreeCluster_11
   1000            //
   1001            // If we did not find any free cluster from the given cluster to the last cluster of the medium,
   1002            // continue search from first cluster of the medium to the given cluster.
   1003            //
   1004            for (i = FAT_FIRST_CLUSTER; i < FirstCluster; i++) {
   \   000001D0   0290A0E3           MOV      R9,#+2
   \   000001D4   030056E3           CMP      R6,#+3
   \   000001D8   1B00003A           BCC      ??FS_FAT_FindFreeCluster_14
   \   000001DC   026046E2           SUB      R6,R6,#+2
   \   000001E0   010016E3           TST      R6,#0x1
   \   000001E4   0600000A           BEQ      ??FS_FAT_FindFreeCluster_15
   1005              if (FS_FAT_ReadFATEntry(pVolume, pSB, i) == 0) {
   \   000001E8   0220A0E3           MOV      R2,#+2
   \   000001EC   0510A0E1           MOV      R1,R5
   \   000001F0   0400A0E1           MOV      R0,R4
   \   000001F4   ........           BL       FS_FAT_ReadFATEntry
   \   000001F8   000050E3           CMP      R0,#+0
   \   000001FC   DEFFFF0A           BEQ      ??FS_FAT_FindFreeCluster_13
   \   00000200   0390A0E3           MOV      R9,#+3
   \                     ??FS_FAT_FindFreeCluster_15:
   \   00000204   A660B0E1           LSRS     R6,R6,#+1
   \   00000208   0F00000A           BEQ      ??FS_FAT_FindFreeCluster_14
   \                     ??FS_FAT_FindFreeCluster_16:
   \   0000020C   0920A0E1           MOV      R2,R9
   \   00000210   0510A0E1           MOV      R1,R5
   \   00000214   0400A0E1           MOV      R0,R4
   \   00000218   ........           BL       FS_FAT_ReadFATEntry
   \   0000021C   000050E3           CMP      R0,#+0
   \   00000220   D5FFFF0A           BEQ      ??FS_FAT_FindFreeCluster_13
   \   00000224   019089E2           ADD      R9,R9,#+1
   \   00000228   0920A0E1           MOV      R2,R9
   \   0000022C   0510A0E1           MOV      R1,R5
   \   00000230   0400A0E1           MOV      R0,R4
   \   00000234   ........           BL       FS_FAT_ReadFATEntry
   \   00000238   000050E3           CMP      R0,#+0
   \   0000023C   CEFFFF0A           BEQ      ??FS_FAT_FindFreeCluster_13
   1006                _CalcFreeClusterCnt(pVolume, pSB, i, pFile);
   1007                return i;      /* We found a free cluster */
   1008              }
   1009            }
   \   00000240   019089E2           ADD      R9,R9,#+1
   \   00000244   016056E2           SUBS     R6,R6,#+1
   \   00000248   EFFFFF1A           BNE      ??FS_FAT_FindFreeCluster_16
   1010            return 0;                /* Error, no free cluster */
   \                     ??FS_FAT_FindFreeCluster_14:
   \   0000024C   0000A0E3           MOV      R0,#+0
   \                     ??FS_FAT_FindFreeCluster_7:
   \   00000250   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000254   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1011          }
   1012          
   1013          /*********************************************************************
   1014          *
   1015          *       FS_FAT_MarkClusterEOC
   1016          *
   1017          *  Function description
   1018          *    Marks the given cluster as the last in the cluster chain
   1019          *
   1020          *  Return value
   1021          *    0   O.K.
   1022          *    1   Error
   1023          */

   \                                 In section .text, align 4, keep-with-next
   1024          char FS_FAT_MarkClusterEOC(FS_VOLUME * pVolume, FS_SB * pSB, U32 Cluster) {
   1025            return _WriteFATEntry(pVolume, pSB, Cluster, 0xFFFFFFFUL);
   \                     FS_FAT_MarkClusterEOC:
   \   00000000   F034E0E3           MVN      R3,#-268435456
   \   00000004   ........           B        _WriteFATEntry   ;; tailcall
   1026          }
   1027          
   1028          /*********************************************************************
   1029          *
   1030          *       FS_FAT_LinkCluster
   1031          *
   1032          *  Function description
   1033          *
   1034          *  Notes
   1035          */

   \                                 In section .text, align 4, keep-with-next
   1036          void FS_FAT_LinkCluster(FS_VOLUME * pVolume, FS_SB * pSB, U32 LastCluster, U32 NewCluster) {
   \                     FS_FAT_LinkCluster:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0360A0E1           MOV      R6,R3
   1037            if (LastCluster) {
   \   00000010   000052E3           CMP      R2,#+0
   \   00000014   0000000A           BEQ      ??FS_FAT_LinkCluster_0
   1038              _WriteFATEntry(pVolume, pSB, LastCluster, NewCluster);
   \   00000018   ........           BL       _WriteFATEntry
   1039            }
   1040            FS_FAT_MarkClusterEOC(pVolume, pSB, NewCluster);
   \                     ??FS_FAT_LinkCluster_0:
   \   0000001C   0620A0E1           MOV      R2,R6
   \   00000020   0510A0E1           MOV      R1,R5
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   7040BDE8           POP      {R4-R6,LR}
   \   0000002C   F034E0E3           MVN      R3,#-268435456
   \   00000030   ........           B        _WriteFATEntry   ;; tailcall
   1041          }
   1042          
   1043          /*********************************************************************
   1044          *
   1045          *       FS_FAT_FindLastCluster
   1046          *
   1047          *  Parameters
   1048          *    Cluster    Any cluster of the cluster chain. Must be valid (0 not allowed)
   1049          *
   1050          *  Function description
   1051          *    returns the last cluster in the cluster chain
   1052          *
   1053          */

   \                                 In section .text, align 4, keep-with-next
   1054          U32 FS_FAT_FindLastCluster(FS_VOLUME * pVolume, FS_SB * pSB, U32 Cluster, U32 * pNumClusters) {
   \                     FS_FAT_FindLastCluster:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0280A0E1           MOV      R8,R2
   \   00000014   0360A0E1           MOV      R6,R3
   1055            U32 NumClusters = 0;
   \   00000018   0070A0E3           MOV      R7,#+0
   \   0000001C   000000EA           B        ??FS_FAT_FindLastCluster_0
   1056            do {
   1057              U32 NextCluster;
   1058              NextCluster = FS_FAT_WalkCluster(pVolume, pSB, Cluster, 1);
   1059              if (NextCluster == 0) {
   1060                break;
   1061              }
   1062              NumClusters++;
   1063              if (NumClusters > pVolume->FSInfo.FATInfo.NumClusters) {
   1064                FS_DEBUG_ERROROUT((FS_MTYPE_FS, "FS_FAT_FindLastCluster: NumCluster for an entry is beyond the available number of clusters."));
   1065                NumClusters = 0;
   1066                break;
   1067              }
   1068              Cluster = NextCluster;
   \                     ??FS_FAT_FindLastCluster_1:
   \   00000020   0080A0E1           MOV      R8,R0
   1069            } while (1);
   \                     ??FS_FAT_FindLastCluster_0:
   \   00000024   0110A0E3           MOV      R1,#+1
   \   00000028   00108DE5           STR      R1,[SP, #+0]
   \   0000002C   0D30A0E1           MOV      R3,SP
   \   00000030   0820A0E1           MOV      R2,R8
   \   00000034   0510A0E1           MOV      R1,R5
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   ........           BL       FS_FAT_WalkClusterEx
   \   00000040   00109DE5           LDR      R1,[SP, #+0]
   \   00000044   000051E3           CMP      R1,#+0
   \   00000048   0600001A           BNE      ??FS_FAT_FindLastCluster_2
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0400000A           BEQ      ??FS_FAT_FindLastCluster_2
   \   00000054   3C1094E5           LDR      R1,[R4, #+60]
   \   00000058   017087E2           ADD      R7,R7,#+1
   \   0000005C   070051E1           CMP      R1,R7
   \   00000060   EEFFFF2A           BCS      ??FS_FAT_FindLastCluster_1
   \   00000064   0070A0E3           MOV      R7,#+0
   1070            if (pNumClusters) {
   \                     ??FS_FAT_FindLastCluster_2:
   \   00000068   000056E3           CMP      R6,#+0
   1071              *pNumClusters = NumClusters;
   \   0000006C   00708615           STRNE    R7,[R6, #+0]
   1072            }
   1073            return Cluster;
   \   00000070   0800A0E1           MOV      R0,R8
   \   00000074   08D08DE2           ADD      SP,SP,#+8
   \   00000078   F081BDE8           POP      {R4-R8,PC}       ;; return
   1074          }
   1075          
   1076          /*********************************************************************
   1077          *
   1078          *       FS_FAT_AllocCluster
   1079          *
   1080          *  Function description
   1081          *    Allocates a cluster and (optionally) links it to an existing cluster
   1082          *    chain, specified by the last cluster
   1083          *
   1084          *  Return value
   1085          *    0             On error (No new cluster)
   1086          *    ClusterId >0  If new cluster has been allocated (and possibly added to the chain)
   1087          */

   \                                 In section .text, align 4, keep-with-next
   1088          U32 FS_FAT_AllocCluster(FS_VOLUME * pVolume, FS_SB * pSB, U32 LastCluster, FS_FILE * pFile) {
   \                     FS_FAT_AllocCluster:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   1089            U32 NewCluster;
   1090          
   1091            NewCluster = FS_FAT_FindFreeCluster(pVolume, pSB, LastCluster, pFile);
   \   00000014   ........           BL       FS_FAT_FindFreeCluster
   \   00000018   0070B0E1           MOVS     R7,R0
   1092            if (NewCluster) {
   \   0000001C   0B00000A           BEQ      ??FS_FAT_AllocCluster_0
   1093              FS_FAT_LinkCluster(pVolume, pSB, LastCluster, NewCluster);
   \   00000020   000056E3           CMP      R6,#+0
   \   00000024   0400000A           BEQ      ??FS_FAT_AllocCluster_1
   \   00000028   0730A0E1           MOV      R3,R7
   \   0000002C   0620A0E1           MOV      R2,R6
   \   00000030   0510A0E1           MOV      R1,R5
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       _WriteFATEntry
   \                     ??FS_FAT_AllocCluster_1:
   \   0000003C   F034E0E3           MVN      R3,#-268435456
   \   00000040   0720A0E1           MOV      R2,R7
   \   00000044   0510A0E1           MOV      R1,R5
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   ........           BL       _WriteFATEntry
   1094            }
   1095            return NewCluster;
   \                     ??FS_FAT_AllocCluster_0:
   \   00000050   0700A0E1           MOV      R0,R7
   \   00000054   04D08DE2           ADD      SP,SP,#+4
   \   00000058   F080BDE8           POP      {R4-R7,PC}       ;; return
   1096          }
   1097          
   1098          /*********************************************************************
   1099          *
   1100          *       FS_FAT_WalkCluster
   1101          *
   1102          *  Function description
   1103          *    Walks a chain of clusters and returns the cluster Id of the
   1104          *    cluster found
   1105          *
   1106          *  Return value
   1107          *    if (ClusterChain long enough) {
   1108          *      ClusterId of destination cluster
   1109          *    } else {
   1110          *      last cluster in chain
   1111          *    }
   1112          *
   1113          *  Parameters
   1114          *    pNumClusters      IN:  Number of clusters to walk
   1115          *                      OUT: Number of clusters which could not be walked
   1116          *  Notes
   1117          */

   \                                 In section .text, align 4, keep-with-next
   1118          U32 FS_FAT_WalkClusterEx(FS_VOLUME * pVolume, FS_SB * pSB, U32 Cluster, U32 * pNumClusters) {
   \                     FS_FAT_WalkClusterEx:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0370A0E1           MOV      R7,R3
   1119            U32  NumClusters;
   1120            char SkipRead;
   1121          
   1122            NumClusters = *pNumClusters;
   \   00000008   008097E5           LDR      R8,[R7, #+0]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0040A0E1           MOV      R4,R0
   \   00000014   0150A0E1           MOV      R5,R1
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   000058E3           CMP      R8,#+0
   \   00000020   2F00000A           BEQ      ??FS_FAT_WalkClusterEx_0
   \   00000024   FF90A0E3           MOV      R9,#+255
   \   00000028   F09E89E3           ORR      R9,R9,#0xF00
   \   0000002C   F0AC89E3           ORR      R10,R9,#0xF000
   \   00000030   ........           LDR      R11,??DataTable6
   1123            for (; NumClusters; NumClusters--) {
   1124              U32 FATEntry;
   1125          
   1126              SkipRead = 0;
   1127              //
   1128              // If fast write mode is used we need to retrieve the value from our internal FAT free cluster cache
   1129              //
   1130              if (FS_Global.WriteMode == FS_WRITEMODE_FAST) {
   \                     ??FS_FAT_WalkClusterEx_1:
   \   00000034   8400DBE5           LDRB     R0,[R11, #+132]
   \   00000038   020050E3           CMP      R0,#+2
   \   0000003C   1800001A           BNE      ??FS_FAT_WalkClusterEx_2
   1131                SkipRead = _ReadFromFreeClusterCache(pVolume, Cluster, &FATEntry);
   \   00000040   1C0084E2           ADD      R0,R4,#+28
   \   00000044   382090E5           LDR      R2,[R0, #+56]
   \   00000048   301090E5           LDR      R1,[R0, #+48]
   \   0000004C   000052E3           CMP      R2,#+0
   \   00000050   1300000A           BEQ      ??FS_FAT_WalkClusterEx_2
   \   00000054   010056E1           CMP      R6,R1
   \   00000058   1100003A           BCC      ??FS_FAT_WalkClusterEx_2
   \   0000005C   013082E0           ADD      R3,R2,R1
   \   00000060   030056E1           CMP      R6,R3
   \   00000064   0E00002A           BCS      ??FS_FAT_WalkClusterEx_2
   \   00000068   021081E0           ADD      R1,R1,R2
   \   0000006C   011041E2           SUB      R1,R1,#+1
   \   00000070   1E00D0E5           LDRB     R0,[R0, #+30]
   \   00000074   010056E1           CMP      R6,R1
   \   00000078   01108612           ADDNE    R1,R6,#+1
   \   0000007C   0010E003           MVNEQ    R1,#+0
   \   00000080   0C0050E2           SUBS     R0,R0,#+12
   \   00000084   0400000A           BEQ      ??FS_FAT_WalkClusterEx_3
   \   00000088   040050E2           SUBS     R0,R0,#+4
   \   0000008C   0102A011           LSLNE    R0,R1,#+4
   \   00000090   01000A00           ANDEQ    R0,R10,R1
   \   00000094   2002A011           LSRNE    R0,R0,#+4
   \   00000098   050000EA           B        ??FS_FAT_WalkClusterEx_4
   \                     ??FS_FAT_WalkClusterEx_3:
   \   0000009C   010009E0           AND      R0,R9,R1
   \   000000A0   030000EA           B        ??FS_FAT_WalkClusterEx_4
   1132              } 
   1133              if (SkipRead == 0) {
   1134                FATEntry = FS_FAT_ReadFATEntry(pVolume, pSB, Cluster);
   \                     ??FS_FAT_WalkClusterEx_2:
   \   000000A4   0620A0E1           MOV      R2,R6
   \   000000A8   0510A0E1           MOV      R1,R5
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   ........           BL       FS_FAT_ReadFATEntry
   1135              }
   1136              if (pSB->HasError) {
   \                     ??FS_FAT_WalkClusterEx_4:
   \   000000B4   0D10D5E5           LDRB     R1,[R5, #+13]
   \   000000B8   000051E3           CMP      R1,#+0
   1137                return 0;             /* Read error */
   \   000000BC   0000A013           MOVNE    R0,#+0
   \   000000C0   0900001A           BNE      ??FS_FAT_WalkClusterEx_5
   1138              }
   1139              //
   1140              // Check validity of FATEntry
   1141              //
   1142              if (FATEntry > pVolume->FSInfo.FATInfo.NumClusters + 1) {
   \   000000C4   3C1094E5           LDR      R1,[R4, #+60]
   \   000000C8   011081E2           ADD      R1,R1,#+1
   \   000000CC   000051E1           CMP      R1,R0
   \   000000D0   0300003A           BCC      ??FS_FAT_WalkClusterEx_0
   1143                break;
   1144              }
   1145              if (FATEntry == 0) {
   \   000000D4   000050E3           CMP      R0,#+0
   1146                FS_DEBUG_ERROROUT((FS_MTYPE_FS, "Cluster 0x%x contains an invalid entry of value 0x%x. Should be >= 2 and <= 0x%x.", Cluster, FATEntry, pVolume->FSInfo.FATInfo.NumClusters + 1));
   1147                break;
   1148              }
   1149              Cluster = FATEntry;
   \   000000D8   0060A011           MOVNE    R6,R0
   1150            }
   \   000000DC   01805812           SUBSNE   R8,R8,#+1
   \   000000E0   D3FFFF1A           BNE      ??FS_FAT_WalkClusterEx_1
   1151            *pNumClusters = NumClusters;
   \                     ??FS_FAT_WalkClusterEx_0:
   \   000000E4   008087E5           STR      R8,[R7, #+0]
   1152            return Cluster;
   \   000000E8   0600A0E1           MOV      R0,R6
   \                     ??FS_FAT_WalkClusterEx_5:
   \   000000EC   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000F0   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1153          }
   1154          
   1155          /*********************************************************************
   1156          *
   1157          *       FS_FAT_WalkCluster
   1158          *
   1159          *  Function description
   1160          *    Walks a chain of clusters and returns the cluster Id of the
   1161          *    cluster found
   1162          *
   1163          *  Return value
   1164          *    ClusterId   if cluster is in chain
   1165          *    0           if cluster is not valid
   1166          *
   1167          *  Notes
   1168          */

   \                                 In section .text, align 4, keep-with-next
   1169          U32 FS_FAT_WalkCluster(FS_VOLUME * pVolume, FS_SB * pSB, U32 Cluster, U32 NumClusters) {
   \                     FS_FAT_WalkCluster:
   \   00000000   08402DE9           PUSH     {R3,LR}
   1170            Cluster = FS_FAT_WalkClusterEx(pVolume, pSB, Cluster, &NumClusters);
   \   00000004   0D30A0E1           MOV      R3,SP
   \   00000008   ........           BL       FS_FAT_WalkClusterEx
   1171            if (NumClusters) {
   \   0000000C   00109DE5           LDR      R1,[SP, #+0]
   1172              Cluster = 0;     // Could not go all the way
   1173            }
   1174            return Cluster;
   \   00000010   04D08DE2           ADD      SP,SP,#+4
   \   00000014   000051E3           CMP      R1,#+0
   \   00000018   0000A013           MOVNE    R0,#+0
   \   0000001C   0080BDE8           POP      {PC}             ;; return
   1175          }
   1176          
   1177          /*********************************************************************
   1178          *
   1179          *       FS_FAT_GotoCluster
   1180          *
   1181          *  Purpose
   1182          *    Find the cluster which matches the current file position
   1183          *
   1184          *  Return value
   1185          *    Number of clusters missing
   1186          *
   1187          *  Notes
   1188          *    (1) Caller
   1189          *        This routine is called both when reading and writing a file.
   1190          *        When reading, a non-zero return value is an error meaning: File is too short
   1191          *        When writing, a non-zero return value means that add. clusters need to be allocated
   1192          */

   \                                 In section .text, align 4, keep-with-next
   1193          int FS_FAT_GotoCluster(FS_FILE * pFile, FS_SB * pSBfat) {
   \                     FS_FAT_GotoCluster:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   1194            U32        NumClustersToWalk;
   1195            U32        NumClustersRem;
   1196            U32        CurClusterAbs;
   1197            FS_FILE_OBJ * pFileObj;
   1198          
   1199            pFileObj  = pFile->pFileObj;
   \   00000004   005090E5           LDR      R5,[R0, #+0]
   \   00000008   0140A0E1           MOV      R4,R1
   1200          
   1201            if (pFileObj->FirstCluster == 0) {
   \   0000000C   001095E5           LDR      R1,[R5, #+0]
   \   00000010   08D04DE2           SUB      SP,SP,#+8
   \   00000014   000051E3           CMP      R1,#+0
   \   00000018   0500001A           BNE      ??FS_FAT_GotoCluster_0
   1202              return 1 + _CalcLogClusterPos(pFile);
   \   0000001C   081095E5           LDR      R1,[R5, #+8]
   \   00000020   040090E5           LDR      R0,[R0, #+4]
   \   00000024   281091E5           LDR      R1,[R1, #+40]
   \   00000028   ........           BL       __aeabi_uidiv
   \   0000002C   010080E2           ADD      R0,R0,#+1
   \   00000030   180000EA           B        ??FS_FAT_GotoCluster_1
   1203            }
   1204            NumClustersToWalk = _WalkAdjFileClusters(pFile);
   \                     ??FS_FAT_GotoCluster_0:
   \   00000034   ........           BL       _WalkAdjFileClusters
   \   00000038   0060B0E1           MOVS     R6,R0
   1205            if (NumClustersToWalk == 0) {
   1206              return 0;                // Same cluster, we are done
   \   0000003C   0000A003           MOVEQ    R0,#+0
   \   00000040   1400000A           BEQ      ??FS_FAT_GotoCluster_1
   1207            }
   1208            NumClustersRem = NumClustersToWalk;
   \   00000044   00608DE5           STR      R6,[SP, #+0]
   1209            CurClusterAbs = FS_FAT_WalkClusterEx(pFileObj->pVolume, pSBfat, pFileObj->Data.Fat.CurClusterAbs, &NumClustersRem);
   \   00000048   0D30A0E1           MOV      R3,SP
   \   0000004C   142095E5           LDR      R2,[R5, #+20]
   \   00000050   0410A0E1           MOV      R1,R4
   \   00000054   080095E5           LDR      R0,[R5, #+8]
   \   00000058   ........           BL       FS_FAT_WalkClusterEx
   \   0000005C   0020A0E1           MOV      R2,R0
   1210            //
   1211            // Update values in pFile.
   1212            //
   1213            pFileObj->Data.Fat.CurClusterAbs   = CurClusterAbs;
   \   00000060   142085E5           STR      R2,[R5, #+20]
   1214            pFileObj->Data.Fat.CurClusterFile += NumClustersToWalk - NumClustersRem;   // Advance cluster index by number of clusters walked
   \   00000064   100095E5           LDR      R0,[R5, #+16]
   \   00000068   00109DE5           LDR      R1,[SP, #+0]
   \   0000006C   000086E0           ADD      R0,R6,R0
   \   00000070   010040E0           SUB      R0,R0,R1
   \   00000074   100085E5           STR      R0,[R5, #+16]
   1215            if (NumClustersRem == 0) {
   \   00000078   00009DE5           LDR      R0,[SP, #+0]
   \   0000007C   000050E3           CMP      R0,#+0
   \   00000080   0300001A           BNE      ??FS_FAT_GotoCluster_2
   1216              pFileObj->Data.Fat.NumAdjClusters = FS_FAT_GetNumAdjClustersInChain(pFileObj->pVolume, pSBfat, CurClusterAbs);
   \   00000084   0410A0E1           MOV      R1,R4
   \   00000088   080095E5           LDR      R0,[R5, #+8]
   \   0000008C   ........           BL       FS_FAT_GetNumAdjClustersInChain
   \   00000090   BE01C5E1           STRH     R0,[R5, #+30]
   1217            }
   1218            return NumClustersRem;
   \                     ??FS_FAT_GotoCluster_2:
   \   00000094   00009DE5           LDR      R0,[SP, #+0]
   \                     ??FS_FAT_GotoCluster_1:
   \   00000098   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   0000009C   7080BDE8           POP      {R4-R6,PC}       ;; return
   1219          }
   1220          
   1221          /*********************************************************************
   1222          *
   1223          *       FS_FAT_FreeClusterChain
   1224          *
   1225          *  Function description
   1226          *    Marks all clusters in a cluster chain as free.
   1227          *
   1228          *  Return value
   1229          *    Number of remaining clusters: (NumClusters - NumDeletedClusters)
   1230          *
   1231          */

   \                                 In section .text, align 4, keep-with-next
   1232          U32 FS_FAT_FreeClusterChain(FS_VOLUME * pVolume, FS_SB * pSB, U32 FirstCluster, U32 NumClusters) {
   \                     FS_FAT_FreeClusterChain:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1233            U32 NextCluster;
   1234          
   1235          #if FS_FAT_OPTIMIZE_DELETE
   1236            if (pVolume->FSInfo.FATInfo.FATType != FS_FAT_TYPE_FAT12) {
   \   00000008   3A00D4E5           LDRB     R0,[R4, #+58]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   0370A0E1           MOV      R7,R3
   \   0000001C   0C0050E3           CMP      R0,#+12
   \   00000020   1800001A           BNE      ??FS_FAT_FreeClusterChain_0
   \   00000024   000057E3           CMP      R7,#+0
   \   00000028   1300000A           BEQ      ??FS_FAT_FreeClusterChain_1
   1237              FS_FAT_INFO * pFATInfo;
   1238              U32 FirstFreeFATSector = 0xFFFFFFFFUL;
   1239              U32 LastFreeFATSector  = 0xFFFFFFFFUL;
   1240          
   1241              pFATInfo = &pVolume->FSInfo.FATInfo;
   1242          
   1243              for (; NumClusters; NumClusters--) {
   1244                U32 Off;
   1245                U32 SectorNo;
   1246          
   1247                Off      = _ClusterId2FATOff(pFATInfo->FATType, FirstCluster);
   1248                SectorNo = pFATInfo->RsvdSecCnt + (Off >> pFATInfo->ldBytesPerSector) - 1;
   1249                Off &= pFATInfo->BytesPerSec - 1;
   1250                if (Off == 0) {
   1251                  FS__SB_SetSector(pSB, SectorNo, FS_SB_TYPE_MANAGEMENT);
   1252                  if (_SectorIsBlank((U32 *)pSB->pBuffer, pFATInfo->BytesPerSec >>  2)) {
   1253                    if (SectorNo == LastFreeFATSector + 1) {
   1254                      LastFreeFATSector++;
   1255                    } else {
   1256                      _WriteEmptyFATSectors(pSB, FirstFreeFATSector, LastFreeFATSector);
   1257                      FirstFreeFATSector = SectorNo;
   1258                      LastFreeFATSector  = SectorNo;
   1259                    }
   1260                    FS__SB_MarkNotDirty(pSB);
   1261                  }
   1262                }
   1263                NextCluster = FS_FAT_WalkCluster(pVolume, pSB, FirstCluster, 1);
   1264                _WriteFATEntry(pVolume, pSB, FirstCluster, 0);
   1265                if (NextCluster == 0) {
   1266                  break;
   1267                }
   1268                FirstCluster = NextCluster;
   1269              }
   1270              _WriteEmptyFATSectors(pSB, FirstFreeFATSector, LastFreeFATSector);
   1271            } else
   1272          #endif
   1273            {
   1274              for (; NumClusters; NumClusters--) {
   1275                NextCluster = FS_FAT_WalkCluster(pVolume, pSB, FirstCluster, 1);
   \                     ??FS_FAT_FreeClusterChain_2:
   \   0000002C   0110A0E3           MOV      R1,#+1
   \   00000030   00108DE5           STR      R1,[SP, #+0]
   \   00000034   0D30A0E1           MOV      R3,SP
   \   00000038   0620A0E1           MOV      R2,R6
   \   0000003C   0510A0E1           MOV      R1,R5
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   ........           BL       FS_FAT_WalkClusterEx
   \   00000048   0080A0E1           MOV      R8,R0
   \   0000004C   00009DE5           LDR      R0,[SP, #+0]
   1276                _WriteFATEntry(pVolume, pSB, FirstCluster, 0);
   \   00000050   0030A0E3           MOV      R3,#+0
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0080A013           MOVNE    R8,#+0
   \   0000005C   0620A0E1           MOV      R2,R6
   \   00000060   0510A0E1           MOV      R1,R5
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           BL       _WriteFATEntry
   1277                if (NextCluster == 0) {
   \   0000006C   000058E3           CMP      R8,#+0
   1278                  break;
   1279                }
   1280                FirstCluster = NextCluster;
   \   00000070   0860A011           MOVNE    R6,R8
   1281              }
   \   00000074   01705712           SUBSNE   R7,R7,#+1
   \   00000078   EBFFFF1A           BNE      ??FS_FAT_FreeClusterChain_2
   1282            }
   1283            return NumClusters;
   \                     ??FS_FAT_FreeClusterChain_1:
   \   0000007C   0700A0E1           MOV      R0,R7
   \   00000080   04D08DE2           ADD      SP,SP,#+4
   \   00000084   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??FS_FAT_FreeClusterChain_0:
   \   00000088   0080E0E3           MVN      R8,#+0
   \   0000008C   08B0A0E1           MOV      R11,R8
   \   00000090   1C9084E2           ADD      R9,R4,#+28
   \   00000094   000057E3           CMP      R7,#+0
   \   00000098   F7FFFF0A           BEQ      ??FS_FAT_FreeClusterChain_1
   \                     ??FS_FAT_FreeClusterChain_3:
   \   0000009C   1E00D9E5           LDRB     R0,[R9, #+30]
   \   000000A0   0C0050E2           SUBS     R0,R0,#+12
   \   000000A4   0300000A           BEQ      ??FS_FAT_FreeClusterChain_4
   \   000000A8   040050E2           SUBS     R0,R0,#+4
   \   000000AC   8600A001           LSLEQ    R0,R6,#+1
   \   000000B0   0601A011           LSLNE    R0,R6,#+2
   \   000000B4   000000EA           B        ??FS_FAT_FreeClusterChain_5
   \                     ??FS_FAT_FreeClusterChain_4:
   \   000000B8   A60086E0           ADD      R0,R6,R6, LSR #+1
   \                     ??FS_FAT_FreeClusterChain_5:
   \   000000BC   B610D9E1           LDRH     R1,[R9, #+6]
   \   000000C0   BA21D9E1           LDRH     R2,[R9, #+26]
   \   000000C4   301182E0           ADD      R1,R2,R0, LSR R1
   \   000000C8   01A041E2           SUB      R10,R1,#+1
   \   000000CC   B410D9E1           LDRH     R1,[R9, #+4]
   \   000000D0   011041E2           SUB      R1,R1,#+1
   \   000000D4   000011E1           TST      R1,R0
   \   000000D8   2600001A           BNE      ??FS_FAT_FreeClusterChain_6
   \   000000DC   0220A0E3           MOV      R2,#+2
   \   000000E0   0A10A0E1           MOV      R1,R10
   \   000000E4   0500A0E1           MOV      R0,R5
   \   000000E8   ........           BL       FS__SB_SetSector
   \   000000EC   B400D9E1           LDRH     R0,[R9, #+4]
   \   000000F0   081095E5           LDR      R1,[R5, #+8]
   \   000000F4   2001A0E1           LSR      R0,R0,#+2
   \                     ??FS_FAT_FreeClusterChain_7:
   \   000000F8   042091E4           LDR      R2,[R1], #+4
   \   000000FC   000052E3           CMP      R2,#+0
   \   00000100   1C00001A           BNE      ??FS_FAT_FreeClusterChain_6
   \   00000104   010050E2           SUBS     R0,R0,#+1
   \   00000108   FAFFFF1A           BNE      ??FS_FAT_FreeClusterChain_7
   \   0000010C   01008BE2           ADD      R0,R11,#+1
   \   00000110   00005AE1           CMP      R10,R0
   \   00000114   00B0A001           MOVEQ    R11,R0
   \   00000118   1400000A           BEQ      ??FS_FAT_FreeClusterChain_8
   \   0000011C   01007BE3           CMN      R11,#+1
   \   00000120   08004B10           SUBNE    R0,R11,R8
   \   00000124   01B09012           ADDSNE   R11,R0,#+1
   \   00000128   0E00000A           BEQ      ??FS_FAT_FreeClusterChain_9
   \   0000012C   0500A0E1           MOV      R0,R5
   \   00000130   ........           BL       FS__SB_Clean
   \   00000134   ........           LDR      R0,??DataTable6
   \   00000138   B011D0E1           LDRH     R1,[R0, #+16]
   \   0000013C   080095E5           LDR      R0,[R5, #+8]
   \   00000140   ........           BL       __aeabi_memclr
   \   00000144   0200A0E3           MOV      R0,#+2
   \   00000148   00008DE5           STR      R0,[SP, #+0]
   \   0000014C   083095E5           LDR      R3,[R5, #+8]
   \   00000150   0B20A0E1           MOV      R2,R11
   \   00000154   0810A0E1           MOV      R1,R8
   \   00000158   040095E5           LDR      R0,[R5, #+4]
   \   0000015C   ........           BL       FS_LB_WriteMultiplePart
   \   00000160   0000A0E3           MOV      R0,#+0
   \   00000164   0F00C5E5           STRB     R0,[R5, #+15]
   \                     ??FS_FAT_FreeClusterChain_9:
   \   00000168   0A80A0E1           MOV      R8,R10
   \   0000016C   0AB0A0E1           MOV      R11,R10
   \                     ??FS_FAT_FreeClusterChain_8:
   \   00000170   0500A0E1           MOV      R0,R5
   \   00000174   ........           BL       FS__SB_MarkNotDirty
   \                     ??FS_FAT_FreeClusterChain_6:
   \   00000178   0110A0E3           MOV      R1,#+1
   \   0000017C   00108DE5           STR      R1,[SP, #+0]
   \   00000180   0D30A0E1           MOV      R3,SP
   \   00000184   0620A0E1           MOV      R2,R6
   \   00000188   0510A0E1           MOV      R1,R5
   \   0000018C   0400A0E1           MOV      R0,R4
   \   00000190   ........           BL       FS_FAT_WalkClusterEx
   \   00000194   00A0A0E1           MOV      R10,R0
   \   00000198   00009DE5           LDR      R0,[SP, #+0]
   \   0000019C   0030A0E3           MOV      R3,#+0
   \   000001A0   000050E3           CMP      R0,#+0
   \   000001A4   00A0A013           MOVNE    R10,#+0
   \   000001A8   0620A0E1           MOV      R2,R6
   \   000001AC   0510A0E1           MOV      R1,R5
   \   000001B0   0400A0E1           MOV      R0,R4
   \   000001B4   ........           BL       _WriteFATEntry
   \   000001B8   00005AE3           CMP      R10,#+0
   \   000001BC   0A60A011           MOVNE    R6,R10
   \   000001C0   01705712           SUBSNE   R7,R7,#+1
   \   000001C4   B4FFFF1A           BNE      ??FS_FAT_FreeClusterChain_3
   \   000001C8   01007BE3           CMN      R11,#+1
   \   000001CC   08004B10           SUBNE    R0,R11,R8
   \   000001D0   01409012           ADDSNE   R4,R0,#+1
   \   000001D4   A8FFFF0A           BEQ      ??FS_FAT_FreeClusterChain_1
   \   000001D8   0500A0E1           MOV      R0,R5
   \   000001DC   ........           BL       FS__SB_Clean
   \   000001E0   ........           LDR      R0,??DataTable6
   \   000001E4   B011D0E1           LDRH     R1,[R0, #+16]
   \   000001E8   080095E5           LDR      R0,[R5, #+8]
   \   000001EC   ........           BL       __aeabi_memclr
   \   000001F0   0200A0E3           MOV      R0,#+2
   \   000001F4   00008DE5           STR      R0,[SP, #+0]
   \   000001F8   083095E5           LDR      R3,[R5, #+8]
   \   000001FC   0420A0E1           MOV      R2,R4
   \   00000200   0810A0E1           MOV      R1,R8
   \   00000204   040095E5           LDR      R0,[R5, #+4]
   \   00000208   ........           BL       FS_LB_WriteMultiplePart
   \   0000020C   0000A0E3           MOV      R0,#+0
   \   00000210   0F00C5E5           STRB     R0,[R5, #+15]
   \   00000214   98FFFFEA           B        ??FS_FAT_FreeClusterChain_1
   1284          }
   1285          
   1286          /*********************************************************************
   1287          *
   1288          *       FS_FAT_GetNumAdjClustersInChain
   1289          *
   1290          *  Function description
   1291          *    Return these number of adjacent clusters in this cluster chain.
   1292          *    This allows us to find out if multiple adjacent clusters are used for file storage
   1293          *    and reduces the number of FAT-read operations
   1294          *
   1295          *  Return value
   1296          *    Number of adjacent clusters following (in this FAT sector)
   1297          *
   1298          *  Notes
   1299          *    (1) Optimization
   1300          *    This code is basically a pure optimization; it allows the read / write routines
   1301          *    to reduce the number of FAT reads. Since this routine scans only one FAT sector,
   1302          *    the real number may be greater than the value returned
   1303          */

   \                                 In section .text, align 4, keep-with-next
   1304          U16 FS_FAT_GetNumAdjClustersInChain(FS_VOLUME * pVolume, FS_SB * pSB, U32 CurCluster) {
   \                     FS_FAT_GetNumAdjClustersInChain:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1305            FS_FAT_INFO * pFATInfo;
   1306            U32           BitOff;
   1307            int           NumRemEntries;
   1308            U16           NumClusters;
   1309          
   1310            NumClusters         = 0;
   1311            pFATInfo            = &pVolume->FSInfo.FATInfo;
   \   0000000C   1C0084E2           ADD      R0,R4,#+28
   1312          
   1313            BitOff              = pFATInfo->FATType * CurCluster;         /* Bit number in FAT. */
   1314            BitOff             &= (pFATInfo->BytesPerSec << 3) - 1;       /* Bit number in sector */
   1315            NumRemEntries       = ((pFATInfo->BytesPerSec << 3) - BitOff) / pFATInfo->FATType;
   \   00000010   B410D0E1           LDRH     R1,[R0, #+4]
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   FF70A0E3           MOV      R7,#+255
   \   0000001C   8121A0E1           LSL      R2,R1,#+3
   \   00000020   1E10D0E5           LDRB     R1,[R0, #+30]
   \   00000024   013042E2           SUB      R3,R2,#+1
   \   00000028   F07E87E3           ORR      R7,R7,#0xF00
   \   0000002C   960100E0           MUL      R0,R6,R1
   \   00000030   04D04DE2           SUB      SP,SP,#+4
   \   00000034   000003E0           AND      R0,R3,R0
   \   00000038   000042E0           SUB      R0,R2,R0
   \   0000003C   ........           BL       __aeabi_uidiv
   \   00000040   00A0A0E3           MOV      R10,#+0
   \   00000044   00B0A0E1           MOV      R11,R0
   \   00000048   F08C87E3           ORR      R8,R7,#0xF000
   \   0000004C   ........           LDR      R9,??DataTable8
   \   00000050   010000EA           B        ??FS_FAT_GetNumAdjClustersInChain_0
   1316          
   1317            for (; NumRemEntries > 0; NumRemEntries--) {
   1318              U32 NextCluster;
   1319              char SkipRead;
   1320          
   1321              SkipRead = 0;
   1322              if (FS_Global.WriteMode == FS_WRITEMODE_FAST) {
   1323                SkipRead = _ReadFromFreeClusterCache(pVolume, CurCluster, &NextCluster);
   1324              } 
   1325              if (SkipRead == 0) {
   1326                NextCluster = FS_FAT_ReadFATEntry(pVolume, pSB, CurCluster);
   1327              }
   1328              if (NextCluster != ++CurCluster) {
   1329                break;                                                    /* This one is not adjacent */
   1330              }
   1331              NumClusters++;
   \                     ??FS_FAT_GetNumAdjClustersInChain_1:
   \   00000054   01A08AE2           ADD      R10,R10,#+1
   \   00000058   01B04BE2           SUB      R11,R11,#+1
   \                     ??FS_FAT_GetNumAdjClustersInChain_0:
   \   0000005C   01005BE3           CMP      R11,#+1
   \   00000060   230000BA           BLT      ??FS_FAT_GetNumAdjClustersInChain_2
   \   00000064   8400D9E5           LDRB     R0,[R9, #+132]
   \   00000068   020050E3           CMP      R0,#+2
   \   0000006C   1900001A           BNE      ??FS_FAT_GetNumAdjClustersInChain_3
   \   00000070   1C0084E2           ADD      R0,R4,#+28
   \   00000074   302080E2           ADD      R2,R0,#+48
   \   00000078   082092E5           LDR      R2,[R2, #+8]
   \   0000007C   301090E5           LDR      R1,[R0, #+48]
   \   00000080   000052E3           CMP      R2,#+0
   \   00000084   1300000A           BEQ      ??FS_FAT_GetNumAdjClustersInChain_3
   \   00000088   010056E1           CMP      R6,R1
   \   0000008C   1100003A           BCC      ??FS_FAT_GetNumAdjClustersInChain_3
   \   00000090   013082E0           ADD      R3,R2,R1
   \   00000094   030056E1           CMP      R6,R3
   \   00000098   0E00002A           BCS      ??FS_FAT_GetNumAdjClustersInChain_3
   \   0000009C   021081E0           ADD      R1,R1,R2
   \   000000A0   011041E2           SUB      R1,R1,#+1
   \   000000A4   1E00D0E5           LDRB     R0,[R0, #+30]
   \   000000A8   010056E1           CMP      R6,R1
   \   000000AC   01108612           ADDNE    R1,R6,#+1
   \   000000B0   0010E003           MVNEQ    R1,#+0
   \   000000B4   0C0050E2           SUBS     R0,R0,#+12
   \   000000B8   0400000A           BEQ      ??FS_FAT_GetNumAdjClustersInChain_4
   \   000000BC   040050E2           SUBS     R0,R0,#+4
   \   000000C0   0102A011           LSLNE    R0,R1,#+4
   \   000000C4   01000800           ANDEQ    R0,R8,R1
   \   000000C8   2002A011           LSRNE    R0,R0,#+4
   \   000000CC   050000EA           B        ??FS_FAT_GetNumAdjClustersInChain_5
   \                     ??FS_FAT_GetNumAdjClustersInChain_4:
   \   000000D0   010007E0           AND      R0,R7,R1
   \   000000D4   030000EA           B        ??FS_FAT_GetNumAdjClustersInChain_5
   \                     ??FS_FAT_GetNumAdjClustersInChain_3:
   \   000000D8   0620A0E1           MOV      R2,R6
   \   000000DC   0510A0E1           MOV      R1,R5
   \   000000E0   0400A0E1           MOV      R0,R4
   \   000000E4   ........           BL       FS_FAT_ReadFATEntry
   \                     ??FS_FAT_GetNumAdjClustersInChain_5:
   \   000000E8   016086E2           ADD      R6,R6,#+1
   \   000000EC   060050E1           CMP      R0,R6
   \   000000F0   D7FFFF0A           BEQ      ??FS_FAT_GetNumAdjClustersInChain_1
   1332            }
   1333            return NumClusters;
   \                     ??FS_FAT_GetNumAdjClustersInChain_2:
   \   000000F4   0A08A0E1           LSL      R0,R10,#+16
   \   000000F8   2008A0E1           LSR      R0,R0,#+16
   \   000000FC   04D08DE2           ADD      SP,SP,#+4
   \   00000100   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1334          }
   1335          
   1336          /*********************************************************************
   1337          *
   1338          *       FS_FAT_AllocClusterBlock
   1339          *
   1340          *  Description:
   1341          *    Allocates a cluster block.
   1342          *
   1343          *  Parameters:
   1344          *    pVolume      - Pointer to a volume
   1345          *    FirstCluster - First cluster that shall be used for allocation
   1346          *    NumClusters  - Number of cluster to allocate
   1347          * 
   1348          *  Return value:
   1349          *    ==0         - O.K., allocated NumCluster on block
   1350          *    !=0         - Error, clusters can not be allocated as requested
   1351          */

   \                                 In section .text, align 4, keep-with-next
   1352          int FS_FAT_AllocClusterBlock(FS_VOLUME * pVolume, U32 FirstCluster, U32 NumClusters, FS_SB * pSB) {
   \                     FS_FAT_AllocClusterBlock:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0160A0E1           MOV      R6,R1
   \   0000000C   0270A0E1           MOV      R7,R2
   1353            U32 i;
   1354            U32 LastClusterId;
   1355          
   1356            //
   1357            // Check if parameters are valid
   1358            //
   1359            if (FirstCluster + NumClusters - FAT_FIRST_CLUSTER> pVolume->FSInfo.FATInfo.NumClusters) {    
   \   00000010   3C0094E5           LDR      R0,[R4, #+60]
   \   00000014   061087E0           ADD      R1,R7,R6
   \   00000018   021041E2           SUB      R1,R1,#+2
   \   0000001C   010050E1           CMP      R0,R1
   \   00000020   04D04DE2           SUB      SP,SP,#+4
   \   00000024   0350A0E1           MOV      R5,R3
   1360              return 1;          // Trying to allocate out of bounds clusters.
   \   00000028   0100A033           MOVCC    R0,#+1
   \   0000002C   6700003A           BCC      ??FS_FAT_AllocClusterBlock_0
   1361            }
   1362            //
   1363            // Check if all requested clusters are available
   1364            //
   1365            for (i = 0; i < NumClusters; i++) {
   \   00000030   000057E3           CMP      R7,#+0
   \   00000034   1D00000A           BEQ      ??FS_FAT_AllocClusterBlock_1
   \   00000038   0680A0E1           MOV      R8,R6
   \   0000003C   010017E3           TST      R7,#0x1
   \   00000040   0600000A           BEQ      ??FS_FAT_AllocClusterBlock_2
   1366              if (FS_FAT_ReadFATEntry(pVolume, pSB, i + FirstCluster)) {
   \   00000044   0820A0E1           MOV      R2,R8
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       FS_FAT_ReadFATEntry
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0800001A           BNE      ??FS_FAT_AllocClusterBlock_3
   \   0000005C   018088E2           ADD      R8,R8,#+1
   \                     ??FS_FAT_AllocClusterBlock_2:
   \   00000060   A790B0E1           LSRS     R9,R7,#+1
   \   00000064   1100000A           BEQ      ??FS_FAT_AllocClusterBlock_1
   \                     ??FS_FAT_AllocClusterBlock_4:
   \   00000068   0820A0E1           MOV      R2,R8
   \   0000006C   0510A0E1           MOV      R1,R5
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   ........           BL       FS_FAT_ReadFATEntry
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   0100000A           BEQ      ??FS_FAT_AllocClusterBlock_5
   1367                return 2;          // Cluster is already used
   \                     ??FS_FAT_AllocClusterBlock_3:
   \   00000080   0200A0E3           MOV      R0,#+2
   \   00000084   510000EA           B        ??FS_FAT_AllocClusterBlock_0
   1368              }
   \                     ??FS_FAT_AllocClusterBlock_5:
   \   00000088   012088E2           ADD      R2,R8,#+1
   \   0000008C   0510A0E1           MOV      R1,R5
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   ........           BL       FS_FAT_ReadFATEntry
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   F7FFFF1A           BNE      ??FS_FAT_AllocClusterBlock_3
   1369            }
   \   000000A0   019049E2           SUB      R9,R9,#+1
   \   000000A4   028088E2           ADD      R8,R8,#+2
   \   000000A8   000059E3           CMP      R9,#+0
   \   000000AC   EDFFFF1A           BNE      ??FS_FAT_AllocClusterBlock_4
   1370            //
   1371            // Mark all clusters as used. The first one is the head of the cluster chain
   1372            //
   1373            LastClusterId = FirstCluster;
   1374            for (i = 0; i < NumClusters; i++) {
   \                     ??FS_FAT_AllocClusterBlock_1:
   \   000000B0   000057E3           CMP      R7,#+0
   \   000000B4   3F00000A           BEQ      ??FS_FAT_AllocClusterBlock_6
   \   000000B8   010017E3           TST      R7,#0x1
   \   000000BC   1300000A           BEQ      ??FS_FAT_AllocClusterBlock_7
   1375              LastClusterId = FS_FAT_AllocCluster(pVolume, pSB, LastClusterId, NULL);
   \   000000C0   0030A0E3           MOV      R3,#+0
   \   000000C4   0620A0E1           MOV      R2,R6
   \   000000C8   0510A0E1           MOV      R1,R5
   \   000000CC   0400A0E1           MOV      R0,R4
   \   000000D0   ........           BL       FS_FAT_FindFreeCluster
   \   000000D4   0080B0E1           MOVS     R8,R0
   \   000000D8   0B00000A           BEQ      ??FS_FAT_AllocClusterBlock_8
   \   000000DC   000056E3           CMP      R6,#+0
   \   000000E0   0400000A           BEQ      ??FS_FAT_AllocClusterBlock_9
   \   000000E4   0830A0E1           MOV      R3,R8
   \   000000E8   0620A0E1           MOV      R2,R6
   \   000000EC   0510A0E1           MOV      R1,R5
   \   000000F0   0400A0E1           MOV      R0,R4
   \   000000F4   ........           BL       _WriteFATEntry
   \                     ??FS_FAT_AllocClusterBlock_9:
   \   000000F8   F034E0E3           MVN      R3,#-268435456
   \   000000FC   0820A0E1           MOV      R2,R8
   \   00000100   0510A0E1           MOV      R1,R5
   \   00000104   0400A0E1           MOV      R0,R4
   \   00000108   ........           BL       _WriteFATEntry
   \                     ??FS_FAT_AllocClusterBlock_8:
   \   0000010C   0860A0E1           MOV      R6,R8
   \                     ??FS_FAT_AllocClusterBlock_7:
   \   00000110   A770B0E1           LSRS     R7,R7,#+1
   \   00000114   2700000A           BEQ      ??FS_FAT_AllocClusterBlock_6
   \                     ??FS_FAT_AllocClusterBlock_10:
   \   00000118   0030A0E3           MOV      R3,#+0
   \   0000011C   0620A0E1           MOV      R2,R6
   \   00000120   0510A0E1           MOV      R1,R5
   \   00000124   0400A0E1           MOV      R0,R4
   \   00000128   ........           BL       FS_FAT_FindFreeCluster
   \   0000012C   0080B0E1           MOVS     R8,R0
   \   00000130   0B00000A           BEQ      ??FS_FAT_AllocClusterBlock_11
   \   00000134   000056E3           CMP      R6,#+0
   \   00000138   0400000A           BEQ      ??FS_FAT_AllocClusterBlock_12
   \   0000013C   0830A0E1           MOV      R3,R8
   \   00000140   0620A0E1           MOV      R2,R6
   \   00000144   0510A0E1           MOV      R1,R5
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   ........           BL       _WriteFATEntry
   \                     ??FS_FAT_AllocClusterBlock_12:
   \   00000150   F034E0E3           MVN      R3,#-268435456
   \   00000154   0820A0E1           MOV      R2,R8
   \   00000158   0510A0E1           MOV      R1,R5
   \   0000015C   0400A0E1           MOV      R0,R4
   \   00000160   ........           BL       _WriteFATEntry
   \                     ??FS_FAT_AllocClusterBlock_11:
   \   00000164   0030A0E3           MOV      R3,#+0
   \   00000168   0820A0E1           MOV      R2,R8
   \   0000016C   0510A0E1           MOV      R1,R5
   \   00000170   0400A0E1           MOV      R0,R4
   \   00000174   ........           BL       FS_FAT_FindFreeCluster
   \   00000178   0060B0E1           MOVS     R6,R0
   \   0000017C   0B00000A           BEQ      ??FS_FAT_AllocClusterBlock_13
   \   00000180   000058E3           CMP      R8,#+0
   \   00000184   0400000A           BEQ      ??FS_FAT_AllocClusterBlock_14
   \   00000188   0630A0E1           MOV      R3,R6
   \   0000018C   0820A0E1           MOV      R2,R8
   \   00000190   0510A0E1           MOV      R1,R5
   \   00000194   0400A0E1           MOV      R0,R4
   \   00000198   ........           BL       _WriteFATEntry
   \                     ??FS_FAT_AllocClusterBlock_14:
   \   0000019C   F034E0E3           MVN      R3,#-268435456
   \   000001A0   0620A0E1           MOV      R2,R6
   \   000001A4   0510A0E1           MOV      R1,R5
   \   000001A8   0400A0E1           MOV      R0,R4
   \   000001AC   ........           BL       _WriteFATEntry
   1376            }
   \                     ??FS_FAT_AllocClusterBlock_13:
   \   000001B0   017057E2           SUBS     R7,R7,#+1
   \   000001B4   D7FFFF1A           BNE      ??FS_FAT_AllocClusterBlock_10
   1377            FS_FAT_MarkClusterEOC(pVolume, pSB, LastClusterId);
   \                     ??FS_FAT_AllocClusterBlock_6:
   \   000001B8   F034E0E3           MVN      R3,#-268435456
   \   000001BC   0620A0E1           MOV      R2,R6
   \   000001C0   0510A0E1           MOV      R1,R5
   \   000001C4   0400A0E1           MOV      R0,R4
   \   000001C8   ........           BL       _WriteFATEntry
   1378            return 0;
   \   000001CC   0000A0E3           MOV      R0,#+0
   \                     ??FS_FAT_AllocClusterBlock_0:
   \   000001D0   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000001D4   F083BDE8           POP      {R4-R9,PC}       ;; return
   1379          }
   1380          
   1381          /*********************************************************************
   1382          *
   1383          *       FS_FAT_IsValidShortNameChar
   1384          *
   1385          *  Return value
   1386          *    1      valid character
   1387          *    0      not a valid character
   1388          */

   \                                 In section .text, align 4, keep-with-next
   1389          int FS_FAT_IsValidShortNameChar(U8 c) {
   1390            if ((c > 0) && (c <= 0x20)) {
   \                     FS_FAT_IsValidShortNameChar:
   \   00000000   011040E2           SUB      R1,R0,#+1
   \   00000004   FF1001E2           AND      R1,R1,#0xFF
   \   00000008   200051E3           CMP      R1,#+32
   \   0000000C   0100002A           BCS      ??FS_FAT_IsValidShortNameChar_1
   1391               return 0;  // Error
   \                     ??FS_FAT_IsValidShortNameChar_2:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR
   1392            }
   1393            switch (c) {
   \                     ??FS_FAT_IsValidShortNameChar_1:
   \   00000018   220040E2           SUB      R0,R0,#+34
   \   0000001C   3B0050E3           CMP      R0,#+59
   \   00000020   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??FS_FAT_IsValidShortNameChar_0:
   \   00000024   3B00008A           BHI      ??FS_FAT_IsValidShortNameChar_3
   \   00000028   F8FFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   0000002C   390000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000030   380000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000034   370000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000038   F4FFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   0000003C   350000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000040   340000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000044   330000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000048   F0FFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   0000004C   EFFFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   00000050   EEFFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   00000054   2F0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000058   2E0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   0000005C   EBFFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   00000060   2C0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000064   2B0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000068   2A0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   0000006C   290000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000070   280000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000074   270000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000078   260000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   0000007C   250000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000080   240000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000084   230000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000088   E0FFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   0000008C   DFFFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   00000090   DEFFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   00000094   DDFFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   00000098   DCFFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   0000009C   DBFFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   000000A0   1C0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000A4   1B0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000A8   1A0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000AC   190000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000B0   180000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000B4   170000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000B8   160000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000BC   150000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000C0   140000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000C4   130000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000C8   120000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000CC   110000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000D0   100000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000D4   0F0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000D8   0E0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000DC   0D0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000E0   0C0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000E4   0B0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000E8   0A0000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000EC   090000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000F0   080000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000F4   070000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000F8   060000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   000000FC   050000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000100   040000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000104   030000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   00000108   020000EA           B        ??FS_FAT_IsValidShortNameChar_3
   \   0000010C   BFFFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   00000110   BEFFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   \   00000114   BDFFFFEA           B        ??FS_FAT_IsValidShortNameChar_2
   1394            case '"':
   1395            case '&':
   1396            case '*':
   1397            case '+':
   1398            case ',':
   1399            case '/':
   1400            case ':':
   1401            case ';':
   1402            case '<':
   1403            case '=':
   1404            case '>':
   1405            case '?':
   1406            case '[':
   1407            case ']':
   1408            case '\\':
   1409               return 0;  // Error
   1410            }
   1411            return 1;     // O.K.
   \                     ??FS_FAT_IsValidShortNameChar_3:
   \   00000118   0100A0E3           MOV      R0,#+1
   \   0000011C   1EFF2FE1           BX       LR               ;; return
   1412          }
   1413          
   1414          /*********************************************************************
   1415          *
   1416          *       FS_FAT_CopyShortName
   1417          *
   1418          */

   \                                 In section .text, align 4, keep-with-next
   1419          void FS_FAT_CopyShortName(char * pDest, const char* pSrc, int MaxNumBytes) {
   1420            int i;
   1421            int NumCharacter2Copy;
   1422          
   1423            if (pDest) {
   \                     FS_FAT_CopyShortName:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   0000001A           BNE      ??FS_FAT_CopyShortName_0
   1424              NumCharacter2Copy = MIN(MaxNumBytes - 1, 11);
   \   00000008   1EFF2FE1           BX       LR
   \                     ??FS_FAT_CopyShortName_0:
   \   0000000C   10402DE9           PUSH     {R4,LR}
   \   00000010   012042E2           SUB      R2,R2,#+1
   \   00000014   0B0052E3           CMP      R2,#+11
   \   00000018   030000AA           BGE      ??FS_FAT_CopyShortName_1
   1425              for (i = 0; i < NumCharacter2Copy; i++) {
   \   0000001C   0030A0E3           MOV      R3,#+0
   \   00000020   010052E3           CMP      R2,#+1
   \   00000024   020000AA           BGE      ??FS_FAT_CopyShortName_2
   \   00000028   1C0000EA           B        ??FS_FAT_CopyShortName_3
   \                     ??FS_FAT_CopyShortName_1:
   \   0000002C   0B20A0E3           MOV      R2,#+11
   \   00000030   0030A0E3           MOV      R3,#+0
   \                     ??FS_FAT_CopyShortName_2:
   \   00000034   2EC0A0E3           MOV      R12,#+46
   \   00000038   E5E0A0E3           MOV      LR,#+229
   \   0000003C   0C0000EA           B        ??FS_FAT_CopyShortName_4
   1426                /* Start of extension. If we have no Space, then append the dot. */
   1427                if ((i == 8) && (*pSrc != ' ')) {
   \                     ??FS_FAT_CopyShortName_5:
   \   00000040   080053E3           CMP      R3,#+8
   \   00000044   0800001A           BNE      ??FS_FAT_CopyShortName_6
   \   00000048   0040D1E5           LDRB     R4,[R1, #+0]
   \   0000004C   200054E3           CMP      R4,#+32
   \   00000050   0300000A           BEQ      ??FS_FAT_CopyShortName_7
   1428                  *pDest++ = '.';
   \   00000054   01C0C0E4           STRB     R12,[R0], #+1
   1429                }
   1430                /* if the first character of the directory entry is 0x05,
   1431                 * it is changed to 0xe5. FAT spec V1.03: FAT directories
   1432                 */
   1433                if ((i == 0) && (*pSrc == 0x05)) {
   1434                  pSrc++;
   1435                  *pDest++ = (char)0xe5;
   1436                } else if (*pSrc == ' ') { /* Copy everything except Spaces */
   \                     ??FS_FAT_CopyShortName_8:
   \   00000058   0040D1E5           LDRB     R4,[R1, #+0]
   \   0000005C   200054E3           CMP      R4,#+32
   \   00000060   0900001A           BNE      ??FS_FAT_CopyShortName_9
   1437                   pSrc++;
   \                     ??FS_FAT_CopyShortName_7:
   \   00000064   011081E2           ADD      R1,R1,#+1
   \   00000068   090000EA           B        ??FS_FAT_CopyShortName_10
   1438                } else {
   \                     ??FS_FAT_CopyShortName_6:
   \   0000006C   000053E3           CMP      R3,#+0
   \   00000070   F8FFFF1A           BNE      ??FS_FAT_CopyShortName_8
   \                     ??FS_FAT_CopyShortName_4:
   \   00000074   0040D1E5           LDRB     R4,[R1, #+0]
   \   00000078   050054E3           CMP      R4,#+5
   \   0000007C   F5FFFF1A           BNE      ??FS_FAT_CopyShortName_8
   \   00000080   011081E2           ADD      R1,R1,#+1
   \   00000084   01E0C0E4           STRB     LR,[R0], #+1
   \   00000088   010000EA           B        ??FS_FAT_CopyShortName_10
   1439                  *pDest++ = *pSrc++;
   \                     ??FS_FAT_CopyShortName_9:
   \   0000008C   0140D1E4           LDRB     R4,[R1], #+1
   \   00000090   0140C0E4           STRB     R4,[R0], #+1
   1440                }
   1441              }
   \                     ??FS_FAT_CopyShortName_10:
   \   00000094   013083E2           ADD      R3,R3,#+1
   \   00000098   020053E1           CMP      R3,R2
   \   0000009C   E7FFFFBA           BLT      ??FS_FAT_CopyShortName_5
   1442              *pDest = 0;
   \                     ??FS_FAT_CopyShortName_3:
   \   000000A0   0010A0E3           MOV      R1,#+0
   \   000000A4   0010C0E5           STRB     R1,[R0, #+0]
   1443            }
   1444          }
   \   000000A8   1080BDE8           POP      {R4,PC}          ;; return
   1445          
   1446          /*********************************************************************
   1447          *
   1448          *       FS_FAT_FindDirEntry
   1449          *
   1450          *  Description:
   1451          *    Tries to locate the directory entry in the specified directory.
   1452          *    The short name space is searched first;
   1453          *    if LFN support is activated, the long name space is search
   1454          *    if no short name match was found.
   1455          *
   1456          *  Parameters:
   1457          *    pVolume     - Volume information
   1458          *    pEntryName  - Directory entry name
   1459          *
   1460          *  Return value:
   1461          *    != NULL     - pointer to directory entry (in the smart buffer)
   1462          *    NULL        - Entry not found
   1463          */

   \                                 In section .text, align 4, keep-with-next
   1464          FS_FAT_DENTRY * FS_FAT_FindDirEntry(FS_VOLUME * pVolume, FS_SB * pSB, const char *pEntryName, int Len, U32 DirStart, U8 AttrRequired, I32 * pLongDirEntryIndex) {
   \                     FS_FAT_FindDirEntry:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   3490DDE5           LDRB     R9,[SP, #+52]
   1465            FS_FAT_DENTRY       * pDirEntry;
   1466          
   1467            pDirEntry = FAT_pDirEntryAPI->pfFindDirEntry(pVolume, pSB, pEntryName, Len, DirStart, AttrRequired, pLongDirEntryIndex);
   \   0000000C   ........           LDR      R11,??DataTable8_1
   \   00000010   30809DE5           LDR      R8,[SP, #+48]
   \   00000014   38A09DE5           LDR      R10,[SP, #+56]
   \   00000018   00C09BE5           LDR      R12,[R11, #+0]
   \   0000001C   08A08DE5           STR      R10,[SP, #+8]
   \   00000020   04908DE5           STR      R9,[SP, #+4]
   \   00000024   00808DE5           STR      R8,[SP, #+0]
   \   00000028   0040A0E1           MOV      R4,R0
   \   0000002C   0150A0E1           MOV      R5,R1
   \   00000030   0260A0E1           MOV      R6,R2
   \   00000034   0370A0E1           MOV      R7,R3
   \   00000038   04C09CE5           LDR      R12,[R12, #+4]
   \   0000003C   3CFF2FE1           BLX      R12
   1468            if (FAT_pDirEntryAPI != &FAT_SFN_API) {
   \   00000040   00109BE5           LDR      R1,[R11, #+0]
   \   00000044   ............       ADRL     R2,FAT_SFN_API
   \              ....        
   \   0000004C   020051E1           CMP      R1,R2
   \   00000050   0900000A           BEQ      ??FS_FAT_FindDirEntry_0
   1469              if (pDirEntry == NULL) {
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0700001A           BNE      ??FS_FAT_FindDirEntry_0
   1470                pDirEntry = FAT_SFN_API.pfFindDirEntry(pVolume, pSB, pEntryName, Len, DirStart, AttrRequired, pLongDirEntryIndex);
   \   0000005C   08A08DE5           STR      R10,[SP, #+8]
   \   00000060   04908DE5           STR      R9,[SP, #+4]
   \   00000064   00808DE5           STR      R8,[SP, #+0]
   \   00000068   0730A0E1           MOV      R3,R7
   \   0000006C   0620A0E1           MOV      R2,R6
   \   00000070   0510A0E1           MOV      R1,R5
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   ........           BL       _SFN_FindDirEntry
   1471              }
   1472            }
   1473            return pDirEntry;
   \                     ??FS_FAT_FindDirEntry_0:
   \   0000007C   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000080   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1474          }
   1475          
   1476          /*********************************************************************
   1477          *
   1478          *       FS_FAT_CopyDirEntryInfo
   1479          *
   1480          */

   \                                 In section .text, align 4, keep-with-next
   1481          void FS_FAT_CopyDirEntryInfo(FS_FAT_DENTRY * pDirEntry, FS_DIRENTRY_INFO * pDirEntryInfo) {
   \                     FS_FAT_CopyDirEntryInfo:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1482            pDirEntryInfo->Attributes     = pDirEntry->data[DIR_ENTRY_OFF_ATTRIBUTES];
   \   00000008   0B00D4E5           LDRB     R0,[R4, #+11]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0000C5E5           STRB     R0,[R5, #+0]
   1483            pDirEntryInfo->CreationTime   = (U32)((U32)FS_LoadU16LE(&pDirEntry->data[DIR_ENTRY_OFF_CREATION_DATE]) << 16) | FS_LoadU16LE(&pDirEntry->data[DIR_ENTRY_OFF_CREATION_TIME]);
   \   00000014   100084E2           ADD      R0,R4,#+16
   \   00000018   ........           BL       FS_LoadU16LE
   \   0000001C   0060A0E1           MOV      R6,R0
   \   00000020   0E0084E2           ADD      R0,R4,#+14
   \   00000024   ........           BL       FS_LoadU16LE
   \   00000028   060880E1           ORR      R0,R0,R6, LSL #+16
   \   0000002C   040085E5           STR      R0,[R5, #+4]
   1484            pDirEntryInfo->LastAccessTime = (U32)FS_LoadU16LE(&pDirEntry->data[DIR_ENTRY_OFF_LAST_ACCESS_DATE]) << 16;
   \   00000030   120084E2           ADD      R0,R4,#+18
   \   00000034   ........           BL       FS_LoadU16LE
   \   00000038   0008A0E1           LSL      R0,R0,#+16
   \   0000003C   080085E5           STR      R0,[R5, #+8]
   1485            pDirEntryInfo->LastWriteTime  = (U32)((U32)FS_LoadU16LE(&pDirEntry->data[DIR_ENTRY_OFF_WRITE_DATE])    << 16) | FS_LoadU16LE(&pDirEntry->data[DIR_ENTRY_OFF_WRITE_TIME]);
   \   00000040   180084E2           ADD      R0,R4,#+24
   \   00000044   ........           BL       FS_LoadU16LE
   \   00000048   0060A0E1           MOV      R6,R0
   \   0000004C   160084E2           ADD      R0,R4,#+22
   \   00000050   ........           BL       FS_LoadU16LE
   \   00000054   060880E1           ORR      R0,R0,R6, LSL #+16
   \   00000058   0C0085E5           STR      R0,[R5, #+12]
   1486            pDirEntryInfo->FileSize       = FS_LoadU32LE(&pDirEntry->data[DIR_ENTRY_OFF_SIZE]);
   \   0000005C   1C0084E2           ADD      R0,R4,#+28
   \   00000060   ........           BL       FS_LoadU32LE
   \   00000064   100085E5           STR      R0,[R5, #+16]
   1487          }
   \   00000068   7080BDE8           POP      {R4-R6,PC}       ;; return
   1488          
   1489          /*********************************************************************
   1490          *
   1491          *       FS_FAT_CreateJournalFile
   1492          *
   1493          *  Description:
   1494          *    Creates a Journal file for the file system.
   1495          *
   1496          *  Parameters:
   1497          *    pVolume       - Pointer to a mounted volume.
   1498          *
   1499          *  Return value:
   1500          *    0    O.K., Successfully created
   1501          *    1    Journal file already present
   1502          *   <0    Error
   1503          */

   \                                 In section .text, align 4, keep-with-next
   1504          int FS_FAT_CreateJournalFile(FS_VOLUME * pVolume, U32 NumBytes, U32 * pFirstSector, U32 * pNumSectors) {
   \                     FS_FAT_CreateJournalFile:
   \   00000000   FC4F2DE9           PUSH     {R2-R11,LR}
   \   00000004   0080A0E1           MOV      R8,R0
   \   00000008   0100A0E1           MOV      R0,R1
   1505            FS_FILE       FileHandle;
   1506            FS_FILE_OBJ   FileObj;
   1507            FS_SB         sb;
   1508            FS_FAT_INFO * pFATInfo;
   1509            int           r;
   1510            U32           FirstCluster;
   1511            U32           NumClusters;
   1512            U8            Attributes;
   1513          
   1514            pFATInfo = &pVolume->FSInfo.FATInfo;
   \   0000000C   1C4088E2           ADD      R4,R8,#+28
   \   00000010   54D04DE2           SUB      SP,SP,#+84
   1515            NumClusters = FS__DivideU32Up(NumBytes, pFATInfo->BytesPerCluster);
   \   00000014   0C1094E5           LDR      R1,[R4, #+12]
   \   00000018   ........           BL       FS__DivideU32Up
   \   0000001C   0050A0E1           MOV      R5,R0
   1516            FS__SB_Create(&sb, &pVolume->Partition);
   \   00000020   0810A0E1           MOV      R1,R8
   \   00000024   08008DE2           ADD      R0,SP,#+8
   \   00000028   ........           BL       FS__SB_Create
   1517            FS_MEMSET(&FileHandle, 0, sizeof(FS_FILE));
   \   0000002C   18008DE2           ADD      R0,SP,#+24
   \   00000030   0010A0E3           MOV      R1,#+0
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   0030A0E3           MOV      R3,#+0
   \   0000003C   00C0A0E3           MOV      R12,#+0
   \   00000040   0E10A0E8           STM      R0!,{R1-R3,R12}
   1518            FS_MEMSET(&FileObj, 0, sizeof(FS_FILE_OBJ));
   \   00000044   2C10A0E3           MOV      R1,#+44
   \   00000048   ........           BL       __aeabi_memclr4
   1519            //
   1520            // Create journal file
   1521            //
   1522            FileHandle.AccessFlags = FS_FILE_ACCESS_FLAGS_CW;
   \   0000004C   1410A0E3           MOV      R1,#+20
   \   00000050   2310CDE5           STRB     R1,[SP, #+35]
   1523            FileHandle.pFileObj    = &FileObj;
   \   00000054   28108DE2           ADD      R1,SP,#+40
   1524            FileObj.pVolume        = pVolume;
   1525            if (FS_FAT_Open(FS_JOURNAL_FILE_NAME, &FileHandle, 0, 0, 1)) {
   \   00000058   ............       ADRL     R6,`?<Constant "Journal.dat">`
   \              ....        
   \   00000060   0100A0E3           MOV      R0,#+1
   \   00000064   18108DE5           STR      R1,[SP, #+24]
   \   00000068   00008DE5           STR      R0,[SP, #+0]
   \   0000006C   30808DE5           STR      R8,[SP, #+48]
   \   00000070   0030A0E3           MOV      R3,#+0
   \   00000074   0020A0E3           MOV      R2,#+0
   \   00000078   18108DE2           ADD      R1,SP,#+24
   \   0000007C   0600A0E1           MOV      R0,R6
   \   00000080   ........           BL       FS_FAT_Open
   \   00000084   000050E3           CMP      R0,#+0
   1526              r = -1;
   \   00000088   0080E013           MVNNE    R8,#+0
   1527              goto End;
   \   0000008C   8E00001A           BNE      ??FS_FAT_CreateJournalFile_0
   1528            }
   1529            //
   1530            // Add clusters to journal file
   1531            //
   1532            FirstCluster = pFATInfo->NumClusters - NumClusters + FAT_FIRST_CLUSTER;
   \   00000090   200094E5           LDR      R0,[R4, #+32]
   \   00000094   050040E0           SUB      R0,R0,R5
   \   00000098   027080E2           ADD      R7,R0,#+2
   1533            if (FS_FAT_AllocClusterBlock(pVolume, FirstCluster, NumClusters, &sb)) {
   \   0000009C   3C0098E5           LDR      R0,[R8, #+60]
   \   000000A0   071085E0           ADD      R1,R5,R7
   \   000000A4   021041E2           SUB      R1,R1,#+2
   \   000000A8   010050E1           CMP      R0,R1
   \   000000AC   7E00003A           BCC      ??FS_FAT_CreateJournalFile_1
   \   000000B0   000055E3           CMP      R5,#+0
   \   000000B4   1B00000A           BEQ      ??FS_FAT_CreateJournalFile_2
   \   000000B8   0790A0E1           MOV      R9,R7
   \   000000BC   010015E3           TST      R5,#0x1
   \   000000C0   0600000A           BEQ      ??FS_FAT_CreateJournalFile_3
   \   000000C4   0920A0E1           MOV      R2,R9
   \   000000C8   08108DE2           ADD      R1,SP,#+8
   \   000000CC   0800A0E1           MOV      R0,R8
   \   000000D0   ........           BL       FS_FAT_ReadFATEntry
   \   000000D4   000050E3           CMP      R0,#+0
   \   000000D8   7300001A           BNE      ??FS_FAT_CreateJournalFile_1
   \   000000DC   019089E2           ADD      R9,R9,#+1
   \                     ??FS_FAT_CreateJournalFile_3:
   \   000000E0   A5A0B0E1           LSRS     R10,R5,#+1
   \   000000E4   0F00000A           BEQ      ??FS_FAT_CreateJournalFile_2
   \                     ??FS_FAT_CreateJournalFile_4:
   \   000000E8   0920A0E1           MOV      R2,R9
   \   000000EC   08108DE2           ADD      R1,SP,#+8
   \   000000F0   0800A0E1           MOV      R0,R8
   \   000000F4   ........           BL       FS_FAT_ReadFATEntry
   \   000000F8   000050E3           CMP      R0,#+0
   \   000000FC   6A00001A           BNE      ??FS_FAT_CreateJournalFile_1
   \   00000100   012089E2           ADD      R2,R9,#+1
   \   00000104   08108DE2           ADD      R1,SP,#+8
   \   00000108   0800A0E1           MOV      R0,R8
   \   0000010C   ........           BL       FS_FAT_ReadFATEntry
   \   00000110   000050E3           CMP      R0,#+0
   \   00000114   6400001A           BNE      ??FS_FAT_CreateJournalFile_1
   \   00000118   01A04AE2           SUB      R10,R10,#+1
   \   0000011C   029089E2           ADD      R9,R9,#+2
   \   00000120   00005AE3           CMP      R10,#+0
   \   00000124   EFFFFF1A           BNE      ??FS_FAT_CreateJournalFile_4
   \                     ??FS_FAT_CreateJournalFile_2:
   \   00000128   0790A0E1           MOV      R9,R7
   \   0000012C   000055E3           CMP      R5,#+0
   \   00000130   3F00000A           BEQ      ??FS_FAT_CreateJournalFile_5
   \   00000134   010015E3           TST      R5,#0x1
   \   00000138   1300000A           BEQ      ??FS_FAT_CreateJournalFile_6
   \   0000013C   0030A0E3           MOV      R3,#+0
   \   00000140   0920A0E1           MOV      R2,R9
   \   00000144   08108DE2           ADD      R1,SP,#+8
   \   00000148   0800A0E1           MOV      R0,R8
   \   0000014C   ........           BL       FS_FAT_FindFreeCluster
   \   00000150   00A0B0E1           MOVS     R10,R0
   \   00000154   0B00000A           BEQ      ??FS_FAT_CreateJournalFile_7
   \   00000158   000059E3           CMP      R9,#+0
   \   0000015C   0400000A           BEQ      ??FS_FAT_CreateJournalFile_8
   \   00000160   0A30A0E1           MOV      R3,R10
   \   00000164   0920A0E1           MOV      R2,R9
   \   00000168   08108DE2           ADD      R1,SP,#+8
   \   0000016C   0800A0E1           MOV      R0,R8
   \   00000170   ........           BL       _WriteFATEntry
   \                     ??FS_FAT_CreateJournalFile_8:
   \   00000174   F034E0E3           MVN      R3,#-268435456
   \   00000178   0A20A0E1           MOV      R2,R10
   \   0000017C   08108DE2           ADD      R1,SP,#+8
   \   00000180   0800A0E1           MOV      R0,R8
   \   00000184   ........           BL       _WriteFATEntry
   \                     ??FS_FAT_CreateJournalFile_7:
   \   00000188   0A90A0E1           MOV      R9,R10
   \                     ??FS_FAT_CreateJournalFile_6:
   \   0000018C   A5A0B0E1           LSRS     R10,R5,#+1
   \   00000190   2700000A           BEQ      ??FS_FAT_CreateJournalFile_5
   \                     ??FS_FAT_CreateJournalFile_9:
   \   00000194   0030A0E3           MOV      R3,#+0
   \   00000198   0920A0E1           MOV      R2,R9
   \   0000019C   08108DE2           ADD      R1,SP,#+8
   \   000001A0   0800A0E1           MOV      R0,R8
   \   000001A4   ........           BL       FS_FAT_FindFreeCluster
   \   000001A8   00B0B0E1           MOVS     R11,R0
   \   000001AC   0B00000A           BEQ      ??FS_FAT_CreateJournalFile_10
   \   000001B0   000059E3           CMP      R9,#+0
   \   000001B4   0400000A           BEQ      ??FS_FAT_CreateJournalFile_11
   \   000001B8   0B30A0E1           MOV      R3,R11
   \   000001BC   0920A0E1           MOV      R2,R9
   \   000001C0   08108DE2           ADD      R1,SP,#+8
   \   000001C4   0800A0E1           MOV      R0,R8
   \   000001C8   ........           BL       _WriteFATEntry
   \                     ??FS_FAT_CreateJournalFile_11:
   \   000001CC   F034E0E3           MVN      R3,#-268435456
   \   000001D0   0B20A0E1           MOV      R2,R11
   \   000001D4   08108DE2           ADD      R1,SP,#+8
   \   000001D8   0800A0E1           MOV      R0,R8
   \   000001DC   ........           BL       _WriteFATEntry
   \                     ??FS_FAT_CreateJournalFile_10:
   \   000001E0   0030A0E3           MOV      R3,#+0
   \   000001E4   0B20A0E1           MOV      R2,R11
   \   000001E8   08108DE2           ADD      R1,SP,#+8
   \   000001EC   0800A0E1           MOV      R0,R8
   \   000001F0   ........           BL       FS_FAT_FindFreeCluster
   \   000001F4   0090B0E1           MOVS     R9,R0
   \   000001F8   0B00000A           BEQ      ??FS_FAT_CreateJournalFile_12
   \   000001FC   00005BE3           CMP      R11,#+0
   \   00000200   0400000A           BEQ      ??FS_FAT_CreateJournalFile_13
   \   00000204   0930A0E1           MOV      R3,R9
   \   00000208   0B20A0E1           MOV      R2,R11
   \   0000020C   08108DE2           ADD      R1,SP,#+8
   \   00000210   0800A0E1           MOV      R0,R8
   \   00000214   ........           BL       _WriteFATEntry
   \                     ??FS_FAT_CreateJournalFile_13:
   \   00000218   F034E0E3           MVN      R3,#-268435456
   \   0000021C   0920A0E1           MOV      R2,R9
   \   00000220   08108DE2           ADD      R1,SP,#+8
   \   00000224   0800A0E1           MOV      R0,R8
   \   00000228   ........           BL       _WriteFATEntry
   \                     ??FS_FAT_CreateJournalFile_12:
   \   0000022C   01A05AE2           SUBS     R10,R10,#+1
   \   00000230   D7FFFF1A           BNE      ??FS_FAT_CreateJournalFile_9
   \                     ??FS_FAT_CreateJournalFile_5:
   \   00000234   F034E0E3           MVN      R3,#-268435456
   \   00000238   0920A0E1           MOV      R2,R9
   \   0000023C   08108DE2           ADD      R1,SP,#+8
   \   00000240   0800A0E1           MOV      R0,R8
   \   00000244   ........           BL       _WriteFATEntry
   1534              r = -1;
   1535              //
   1536              // The cluster block could not be allocated therefore we remove the file,
   1537              // otherwise the next call of FS_JOURNAL_Create will fail.
   1538              //
   1539              FS_FAT_Open(FS_JOURNAL_FILE_NAME, &FileHandle, 1, 0, 0);
   1540              goto End;
   1541            }
   1542            //
   1543            // Update file object information
   1544            //
   1545            FileObj.FirstCluster = FirstCluster;
   \   00000248   28708DE5           STR      R7,[SP, #+40]
   1546            FileObj.Size         = NumClusters * pFATInfo->BytesPerCluster;
   \   0000024C   0C0094E5           LDR      R0,[R4, #+12]
   \   00000250   900501E0           MUL      R1,R0,R5
   1547            //
   1548            //  Call FS_EFS_Close to update directory entry
   1549            //
   1550            FS_FAT_Close(&FileHandle);
   \   00000254   18008DE2           ADD      R0,SP,#+24
   \   00000258   2C108DE5           STR      R1,[SP, #+44]
   \   0000025C   ........           BL       FS_FAT_Close
   1551            //
   1552            // Set the file's attribute to SYSTEM and HIDDEN
   1553            // 
   1554            Attributes = FS_ATTR_HIDDEN | FS_ATTR_SYSTEM;
   \   00000260   0610A0E3           MOV      R1,#+6
   \   00000264   0410CDE5           STRB     R1,[SP, #+4]
   1555            FS_FAT_SetDirEntryInfo(pVolume, FS_JOURNAL_FILE_NAME, &Attributes, FS_DIRENTRY_SET_ATTRIBUTES);
   \   00000268   0130A0E3           MOV      R3,#+1
   \   0000026C   04208DE2           ADD      R2,SP,#+4
   \   00000270   0610A0E1           MOV      R1,R6
   \   00000274   0800A0E1           MOV      R0,R8
   \   00000278   ........           BL       FS_FAT_SetDirEntryInfo
   1556            //
   1557            // Set return value and out parameters
   1558            //
   1559            r = 0;
   1560            *pFirstSector = FS_FAT_ClusterId2SectorNo(pFATInfo, FirstCluster);
   \   0000027C   1C20D4E5           LDRB     R2,[R4, #+28]
   \   00000280   080094E5           LDR      R0,[R4, #+8]
   \   00000284   021047E2           SUB      R1,R7,#+2
   \   00000288   920120E0           MLA      R0,R2,R1,R0
   \   0000028C   54109DE5           LDR      R1,[SP, #+84]
   \   00000290   0080A0E3           MOV      R8,#+0
   \   00000294   000081E5           STR      R0,[R1, #+0]
   1561            *pNumSectors  = NumClusters * pFATInfo->SecPerClus;
   \   00000298   1C00D4E5           LDRB     R0,[R4, #+28]
   \   0000029C   900501E0           MUL      R1,R0,R5
   \   000002A0   58009DE5           LDR      R0,[SP, #+88]
   \   000002A4   001080E5           STR      R1,[R0, #+0]
   \   000002A8   070000EA           B        ??FS_FAT_CreateJournalFile_0
   \                     ??FS_FAT_CreateJournalFile_1:
   \   000002AC   0000A0E3           MOV      R0,#+0
   \   000002B0   00008DE5           STR      R0,[SP, #+0]
   \   000002B4   0080E0E3           MVN      R8,#+0
   \   000002B8   0030A0E3           MOV      R3,#+0
   \   000002BC   0120A0E3           MOV      R2,#+1
   \   000002C0   18108DE2           ADD      R1,SP,#+24
   \   000002C4   0600A0E1           MOV      R0,R6
   \   000002C8   ........           BL       FS_FAT_Open
   1562          End:
   1563            //
   1564            // Cleanup
   1565            //
   1566            FS__SB_Delete(&sb);
   \                     ??FS_FAT_CreateJournalFile_0:
   \   000002CC   08008DE2           ADD      R0,SP,#+8
   \   000002D0   ........           BL       FS__SB_Delete
   1567            return r;
   \   000002D4   0800A0E1           MOV      R0,R8
   \   000002D8   5CD08DE2           ADD      SP,SP,#+92
   \   000002DC   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1568          }
   1569          
   1570          /*********************************************************************
   1571          *
   1572          *       FS_FAT_OpenJournalFile
   1573          *
   1574          *  Description:
   1575          *    Tries a Journal file for the file system.
   1576          *
   1577          *  Parameters:
   1578          *    pVolume       - Pointer to a mounted volume.
   1579          *
   1580          *  Return value:
   1581          *     0    O.K., journal file exists
   1582          *   !=0    Error
   1583          */

   \                                 In section .text, align 4, keep-with-next
   1584          int FS_FAT_OpenJournalFile(FS_VOLUME * pVolume) {
   \                     FS_FAT_OpenJournalFile:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   44D04DE2           SUB      SP,SP,#+68
   \   00000008   0040A0E1           MOV      R4,R0
   1585            FS_FILE       FileHandle;
   1586            FS_FILE_OBJ   FileObj;
   1587            int           r;
   1588          
   1589            r  = 0;
   1590            FS_MEMSET(&FileHandle, 0, sizeof(FS_FILE));
   \   0000000C   04008DE2           ADD      R0,SP,#+4
   \   00000010   0010A0E3           MOV      R1,#+0
   \   00000014   0020A0E3           MOV      R2,#+0
   \   00000018   0030A0E3           MOV      R3,#+0
   \   0000001C   00C0A0E3           MOV      R12,#+0
   \   00000020   0E10A0E8           STM      R0!,{R1-R3,R12}
   \   00000024   0050A0E3           MOV      R5,#+0
   1591            FS_MEMSET(&FileObj,    0, sizeof(FS_FILE_OBJ));
   \   00000028   2C10A0E3           MOV      R1,#+44
   \   0000002C   ........           BL       __aeabi_memclr4
   1592            //
   1593            // Open journal file
   1594            //
   1595            FileHandle.AccessFlags = FS_FILE_ACCESS_FLAG_R;
   \   00000030   0810A0E3           MOV      R1,#+8
   \   00000034   0F10CDE5           STRB     R1,[SP, #+15]
   1596            FileHandle.pFileObj    = &FileObj;
   \   00000038   14108DE2           ADD      R1,SP,#+20
   \   0000003C   04108DE5           STR      R1,[SP, #+4]
   1597            FileObj.pVolume        = pVolume;
   \   00000040   1C408DE5           STR      R4,[SP, #+28]
   1598            if (FS_FAT_Open(FS_JOURNAL_FILE_NAME, &FileHandle, 0, 1, 0)) {
   \   00000044   00508DE5           STR      R5,[SP, #+0]
   \   00000048   0130A0E3           MOV      R3,#+1
   \   0000004C   0020A0E3           MOV      R2,#+0
   \   00000050   04108DE2           ADD      R1,SP,#+4
   \   00000054   ........           ADR      R0,`?<Constant "Journal.dat">`
   \   00000058   ........           BL       FS_FAT_Open
   \   0000005C   000050E3           CMP      R0,#+0
   1599              r = 1;
   \   00000060   0150A013           MOVNE    R5,#+1
   1600            }
   1601            return r;
   \   00000064   0500A0E1           MOV      R0,R5
   \   00000068   44D08DE2           ADD      SP,SP,#+68
   \   0000006C   3080BDE8           POP      {R4,R5,PC}       ;; return
   1602          }
   1603          
   1604          /*********************************************************************
   1605          *
   1606          *       FS_FAT_GetIndexOfLastSector
   1607          *
   1608          *  Description:
   1609          *    Returns the last sector that is used by the FS.
   1610          *
   1611          *  Parameters:
   1612          *    pVolume       - Pointer to a mounted volume.
   1613          *
   1614          */

   \                                 In section .text, align 4, keep-with-next
   1615          U32  FS_FAT_GetIndexOfLastSector(FS_VOLUME * pVolume) {
   1616            FS_FAT_INFO * pFATInfo;
   1617          
   1618            pFATInfo = &pVolume->FSInfo.FATInfo;
   \                     FS_FAT_GetIndexOfLastSector:
   \   00000000   1C0080E2           ADD      R0,R0,#+28
   \   00000004   1C10D0E5           LDRB     R1,[R0, #+28]
   \   00000008   082090E5           LDR      R2,[R0, #+8]
   \   0000000C   200090E5           LDR      R0,[R0, #+32]
   \   00000010   010040E2           SUB      R0,R0,#+1
   \   00000014   912020E0           MLA      R0,R1,R0,R2
   \   00000018   000081E0           ADD      R0,R1,R0
   \   0000001C   010040E2           SUB      R0,R0,#+1
   \   00000020   1EFF2FE1           BX       LR               ;; return
   1619            return FS_FAT_ClusterId2SectorNo(pFATInfo, pFATInfo->NumClusters + FAT_FIRST_CLUSTER - 1) + pFATInfo->SecPerClus - 1;
   1620          }
   1621          
   1622          /*********************************************************************
   1623          *
   1624          *       FS_FAT_GrowRootDir
   1625          *
   1626          *  Description:
   1627          *    Let the root directory of a FAT32 volume grow.
   1628          *    This function shall be called after formatting the volume.
   1629          *    If the function is not called after format or called for
   1630          *    a FAT12/16 volume the function will fail.
   1631          *
   1632          *
   1633          *  Parameters:
   1634          *    sVolume       - Pointer to a string that specifies 
   1635          *                    the volume string.
   1636          *    NumAddEntries - Number of entries to be added.
   1637          *    
   1638          *  Returns value
   1639          *    > 0           - Number of entries added
   1640          *    = 0           - Clusters after root directory are not free.
   1641          *    0xFFFFFFFF    - Failed (Invalid volume, volume not mountable, volume is not FAT32)
   1642          */

   \                                 In section .text, align 4, keep-with-next
   1643          U32  FS_FAT_GrowRootDir(const char * sVolume, U32 NumAddEntries) {
   \                     FS_FAT_GrowRootDir:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
   1644            U32           r;
   1645          
   1646            FS_LOCK();
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   ........           BL       FS_OS_Lock
   1647            r = _GrowRootDir(sVolume, NumAddEntries);  
   \   00000018   0510A0E1           MOV      R1,R5
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       _GrowRootDir
   \   00000024   0040A0E1           MOV      R4,R0
   1648            FS_UNLOCK();
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   ........           BL       FS_OS_Unlock
   1649            return r;
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   04D08DE2           ADD      SP,SP,#+4
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
   1650          }
   1651          
   1652          /*********************************************************************
   1653          *
   1654          *       FS_FAT_SyncFAT
   1655          *
   1656          *  Function description:
   1657          *    In fast file write mode, this is necessary to update the FAT.
   1658          *
   1659          *  Parameters:
   1660          *    pVolume  - Pointer to the volume
   1661          *    pSB      - Pointer to a sector buffer used to handle read/write 
   1662          *               operation
   1663          *  
   1664          */

   \                                 In section .text, align 4, keep-with-next
   1665          void FS_FAT_SyncFAT(FS_VOLUME * pVolume, FS_SB * pSB) {
   \                     FS_FAT_SyncFAT:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   1666            FS_FAT_INFO * pFATInfo;
   1667            U32           iCluster;
   1668            
   1669            pFATInfo = &pVolume->FSInfo.FATInfo;
   \   00000008   1C4085E2           ADD      R4,R5,#+28
   1670            //
   1671            // Mark all clusters as used. The first one is the head of the cluster chain
   1672            //
   1673            if (pFATInfo->FreeClusterUse) {
   \   0000000C   380094E5           LDR      R0,[R4, #+56]
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   0160A0E1           MOV      R6,R1
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   1400000A           BEQ      ??FS_FAT_SyncFAT_0
   1674              for (iCluster = 0; iCluster < (pFATInfo->FreeClusterUse - 1); iCluster++) {
   \   00000020   0070A0E3           MOV      R7,#+0
   \   00000024   010050E2           SUBS     R0,R0,#+1
   \   00000028   0A00000A           BEQ      ??FS_FAT_SyncFAT_1
   1675                _WriteFATEntry(pVolume, pSB, iCluster + pFATInfo->FreeClusterStart, iCluster + 1 + pFATInfo->FreeClusterStart);
   \                     ??FS_FAT_SyncFAT_2:
   \   0000002C   300094E5           LDR      R0,[R4, #+48]
   \   00000030   0610A0E1           MOV      R1,R6
   \   00000034   072080E0           ADD      R2,R0,R7
   \   00000038   013082E2           ADD      R3,R2,#+1
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   ........           BL       _WriteFATEntry
   1676              }
   \   00000044   380094E5           LDR      R0,[R4, #+56]
   \   00000048   017087E2           ADD      R7,R7,#+1
   \   0000004C   010040E2           SUB      R0,R0,#+1
   \   00000050   000057E1           CMP      R7,R0
   \   00000054   F4FFFF3A           BCC      ??FS_FAT_SyncFAT_2
   1677              FS_FAT_MarkClusterEOC(pVolume, pSB, iCluster + pFATInfo->FreeClusterStart);
   \                     ??FS_FAT_SyncFAT_1:
   \   00000058   300094E5           LDR      R0,[R4, #+48]
   \   0000005C   F034E0E3           MVN      R3,#-268435456
   \   00000060   072080E0           ADD      R2,R0,R7
   \   00000064   0610A0E1           MOV      R1,R6
   \   00000068   0500A0E1           MOV      R0,R5
   \   0000006C   ........           BL       _WriteFATEntry
   1678            }
   1679            pFATInfo->FreeClusterStart         = 0;
   \   00000070   0000A0E3           MOV      R0,#+0
   \                     ??FS_FAT_SyncFAT_0:
   \   00000074   300084E5           STR      R0,[R4, #+48]
   1680            pFATInfo->FreeClusterUse           = 0;
   \   00000078   380084E5           STR      R0,[R4, #+56]
   1681            pFATInfo->FreeClusterCnt           = 0;
   \   0000007C   340084E5           STR      R0,[R4, #+52]
   1682            pFATInfo->pFileUsedWithFreeCluster = NULL;
   \   00000080   3C0084E5           STR      R0,[R4, #+60]
   1683          }
   \   00000084   04D08DE2           ADD      SP,SP,#+4
   \   00000088   F080BDE8           POP      {R4-R7,PC}       ;; return
   1684          
   1685          
   1686          
   1687          /*********************************************************************
   1688          *
   1689          *       Public const
   1690          *
   1691          **********************************************************************
   1692          */

   \                                 In section .text, align 4, keep-with-next
   1693          const FAT_DIRENTRY_API FAT_SFN_API = {
   \                     FAT_SFN_API:
   \   00000000                      ; Initializer data, 16 bytes
   \   00000000   ............       DC32 _SFN_ReadDirEntryInfo, _SFN_FindDirEntry, _SFN_CreateDirEntry, 0
   \              ............
   \              00000000    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     FS_Global

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   52526141           DC32     0x41615252

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   72724161           DC32     0x61417272

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     FS_Global

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   ........           DC32     FAT_pDirEntryAPI

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Journal.dat">`:
   \   00000000                      ; Initializer data, 12 bytes
   \   00000000   4A6F75726E61       DC8 74, 111, 117, 114, 110, 97, 108, 46, 100, 97
   \              6C2E6461    
   \   0000000A   7400               DC8 116, 0
   1694            _SFN_ReadDirEntryInfo,
   1695            _SFN_FindDirEntry,
   1696            _SFN_CreateDirEntry,
   1697            NULL
   1698          };
   1699          
   1700          
   1701          
   1702          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     FS_FAT_AllocCluster                24
     FS_FAT_AllocClusterBlock           32
     FS_FAT_CheckBPB                    16
     FS_FAT_ClusterId2SectorNo           0
     FS_FAT_CopyDirEntryInfo            16
     FS_FAT_CopyShortName                8
     FS_FAT_CreateJournalFile          128
     FS_FAT_FindDirEntry                48
     FS_FAT_FindFreeCluster             40
     FS_FAT_FindLastCluster             32
     FS_FAT_FreeClusterChain            40
     FS_FAT_GetFATType                   0
     FS_FAT_GetIndexOfLastSector         0
     FS_FAT_GetNumAdjClustersInChain
                                        40
     FS_FAT_GotoCluster                 24
     FS_FAT_GrowRootDir                 16
     FS_FAT_IsValidShortNameChar         0
     FS_FAT_LinkCluster                 16
     FS_FAT_MarkClusterEOC               8
     FS_FAT_OpenJournalFile             80
     FS_FAT_ReadFATEntry                32
     FS_FAT_SyncFAT                     24
     FS_FAT_WalkCluster                  8
     FS_FAT_WalkClusterEx               40
     _CalcFreeClusterCnt                32
     _CheckBPB                          40
     _GrowRootDir                       56
     _SFN_CreateDirEntry                64
     _SFN_FindDirEntry                  16
     _SFN_ReadDirEntryInfo              32
     _WalkAdjFileClusters                8
     _WriteFATEntry                     40


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     FAT_pDirEntryAPI                  4
     _WriteFATEntry                  612
     _SFN_ReadDirEntryInfo           400
     _SFN_FindDirEntry                36
     _SFN_CreateDirEntry             136
     _CheckBPB                       628
     _WalkAdjFileClusters            140
     _GrowRootDir                    720
     _CalcFreeClusterCnt             228
     FS_FAT_CheckBPB                 140
     FS_FAT_GetFATType                52
     FS_FAT_ClusterId2SectorNo        20
     FS_FAT_ReadFATEntry             268
     FS_FAT_FindFreeCluster          600
     FS_FAT_MarkClusterEOC             8
     FS_FAT_LinkCluster               52
     FS_FAT_FindLastCluster          124
     FS_FAT_AllocCluster              92
     FS_FAT_WalkClusterEx            244
     FS_FAT_WalkCluster               32
     FS_FAT_GotoCluster              160
     FS_FAT_FreeClusterChain         536
     FS_FAT_GetNumAdjClustersInChain
                                     260
     FS_FAT_AllocClusterBlock        472
     FS_FAT_IsValidShortNameChar     288
     FS_FAT_CopyShortName            172
     FS_FAT_FindDirEntry             132
     FS_FAT_CopyDirEntryInfo         108
     FS_FAT_CreateJournalFile        736
     FS_FAT_OpenJournalFile          112
     FS_FAT_GetIndexOfLastSector      36
     FS_FAT_GrowRootDir               60
     FS_FAT_SyncFAT                  140
     FAT_SFN_API                      16
     ??DataTable6                      4
     ??DataTable7                      4
     ??DataTable7_1                    4
     ??DataTable8                      4
     ??DataTable8_1                    4
     ?<Constant "Journal.dat">        12

 
     4 bytes in section .data
 7 792 bytes in section .text
 
 7 792 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
