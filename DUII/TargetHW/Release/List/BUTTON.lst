###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:08:22 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\BUTTON.c                            #
#    Command line =  C:\DUII\TargetHW\GUI\BUTTON.c -D DEBUG=1 -D              #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\BUTTON.lst                 #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\BUTTON.o                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\BUTTON.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : BUTTON.c
     19          Purpose     : Implementation of button widget
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stdlib.h>
     24          #include <string.h>
     25          #include "BUTTON_Private.h"
     26          
     27          #if GUI_WINSUPPORT
     28          
     29          /*********************************************************************
     30          *
     31          *       Private config defaults
     32          *
     33          **********************************************************************
     34          */
     35          
     36          /* Define default fonts */
     37          #ifndef   BUTTON_FONT_DEFAULT
     38            #if   WIDGET_USE_SCHEME_SMALL
     39              #define BUTTON_FONT_DEFAULT &GUI_Font13_1
     40            #elif WIDGET_USE_SCHEME_MEDIUM
     41              #define BUTTON_FONT_DEFAULT &GUI_Font16_1
     42            #elif WIDGET_USE_SCHEME_LARGE
     43              #define BUTTON_FONT_DEFAULT &GUI_Font24_1
     44            #endif
     45          #endif
     46          
     47          /* Define colors */
     48          #ifndef   BUTTON_BKCOLOR0_DEFAULT
     49            #define BUTTON_BKCOLOR0_DEFAULT   0xAAAAAA
     50          #endif
     51          
     52          #ifndef   BUTTON_BKCOLOR1_DEFAULT
     53            #define BUTTON_BKCOLOR1_DEFAULT   GUI_WHITE
     54          #endif
     55          
     56          #ifndef   BUTTON_BKCOLOR2_DEFAULT
     57            #define BUTTON_BKCOLOR2_DEFAULT   GUI_LIGHTGRAY
     58          #endif
     59          
     60          #ifndef   BUTTON_TEXTCOLOR0_DEFAULT
     61            #define BUTTON_TEXTCOLOR0_DEFAULT GUI_BLACK
     62          #endif
     63          
     64          #ifndef   BUTTON_TEXTCOLOR1_DEFAULT
     65            #define BUTTON_TEXTCOLOR1_DEFAULT GUI_BLACK
     66          #endif
     67          
     68          #ifndef   BUTTON_TEXTCOLOR2_DEFAULT
     69            #define BUTTON_TEXTCOLOR2_DEFAULT GUI_DARKGRAY
     70          #endif
     71          
     72          #ifndef   BUTTON_FOCUSCOLOR_DEFAULT
     73            #define BUTTON_FOCUSCOLOR_DEFAULT GUI_BLACK
     74          #endif
     75          
     76          #ifndef   BUTTON_FRAMECOLOR_DEFAULT
     77            #define BUTTON_FRAMECOLOR_DEFAULT GUI_BLACK
     78          #endif
     79          
     80          #ifndef   BUTTON_REACT_ON_LEVEL
     81            #define BUTTON_REACT_ON_LEVEL 0
     82          #endif
     83          
     84          #ifndef   BUTTON_ALIGN_DEFAULT
     85            #define BUTTON_ALIGN_DEFAULT GUI_TA_HCENTER | GUI_TA_VCENTER
     86          #endif
     87          
     88          #ifndef   BUTTON_DRAW_SKIN_DEFAULT
     89            #define BUTTON_DRAW_SKIN_DEFAULT NULL
     90          #endif
     91          
     92          /*********************************************************************
     93          *
     94          *       Static data
     95          *
     96          **********************************************************************
     97          */

   \                                 In section .data, align 4
     98          BUTTON_PROPS BUTTON__DefaultProps = {
   \                     BUTTON__DefaultProps:
   \   00000000   AAAAAA00FFFF       DC32 11184810, 16777215, 13882323, 16777215, 0, 4210752, 8421504, 0
   \              FF00D3D3D300
   \              FFFFFF000000
   \              000040404000
   \              808080000000
   \              0000        
   \   00000020   ........0000       DC32 GUI_Font13_1, 0H
   \              0000        
   \   00000028   0E00               DC16 14
   \   0000002A   0000               DC8 0, 0
     99            {
    100              BUTTON_BKCOLOR0_DEFAULT,
    101              BUTTON_BKCOLOR1_DEFAULT,
    102              BUTTON_BKCOLOR2_DEFAULT,
    103            },
    104            {
    105              BUTTON_TEXTCOLOR0_DEFAULT,
    106              BUTTON_TEXTCOLOR1_DEFAULT,
    107              BUTTON_TEXTCOLOR2_DEFAULT,
    108            },
    109            BUTTON_FOCUSCOLOR_DEFAULT,
    110            BUTTON_FRAMECOLOR_DEFAULT,
    111            BUTTON_FONT_DEFAULT,
    112            {
    113              BUTTON_DRAW_SKIN_DEFAULT
    114            },
    115            BUTTON_ALIGN_DEFAULT
    116          };
    117          
    118          WIDGET_SKIN const * BUTTON__pSkinDefault = &BUTTON__SkinClassic;
   \                     BUTTON__pSkinDefault:
   \   0000002C   ........           DC32 BUTTON__SkinClassic
    119          
    120          /*********************************************************************
    121          *
    122          *       Static routines
    123          *
    124          **********************************************************************
    125          */
    126          /*********************************************************************
    127          *
    128          *       _Paint
    129          */
    130          static void _Paint(BUTTON_Handle hObj) {
    131            BUTTON_Obj * pObj;
    132            WIDGET_PAINT * pfPaint;
    133          
    134            pObj = BUTTON_LOCK_H(hObj);
    135            pfPaint = pObj->pWidgetSkin->pfPaint;
    136            GUI_UNLOCK_H(pObj);
    137            if (pfPaint) {
    138              pfPaint(hObj);
    139            }
    140          }
    141          
    142          /*********************************************************************
    143          *
    144          *       _Delete
    145          *
    146          * Delete attached objects (if any)
    147          */
    148          static void _Delete(BUTTON_Handle hObj) {
    149            BUTTON_Obj * pObj;
    150            pObj = BUTTON_LOCK_H(hObj);
    151            GUI_ALLOC_FreePtr(&pObj->hpText);
    152            GUI_ALLOC_FreePtrArray(pObj->ahDrawObj, GUI_COUNTOF(pObj->ahDrawObj));
    153            GUI_UNLOCK_H(pObj);
    154          }
    155          
    156          /*********************************************************************
    157          *
    158          *       _OnButtonPressed
    159          */
    160          static void _OnButtonPressed(BUTTON_Handle hObj) {
    161            BUTTON_Obj * pObj;
    162            U16 Status;
    163            WIDGET_OrState(hObj, BUTTON_STATE_PRESSED);
    164            pObj = BUTTON_LOCK_H(hObj);
    165            Status = pObj->Widget.Win.Status;
    166            GUI_UNLOCK_H(pObj);
    167            if (Status & WM_SF_ISVIS) {
    168              WM_NotifyParent(hObj, WM_NOTIFICATION_CLICKED);
    169            }
    170          }
    171          
    172          /*********************************************************************
    173          *
    174          *       _OnButtonReleased
    175          */
    176          static void _OnButtonReleased(BUTTON_Handle hObj, int Notification) {
    177            BUTTON_Obj * pObj;
    178            U16 Status, Id;
    179            WIDGET_AndState(hObj, BUTTON_STATE_PRESSED);
    180            pObj = BUTTON_LOCK_H(hObj);
    181            Status = pObj->Widget.Win.Status;
    182            Id     = pObj->Widget.Id;
    183            GUI_UNLOCK_H(pObj);
    184            if (Notification == WM_NOTIFICATION_RELEASED) {
    185              GUI_DEBUG_LOG("BUTTON: Hit\n");
    186              GUI_StoreKey(Id);
    187            }
    188            if (Status & WM_SF_ISVIS) {
    189              WM_NotifyParent(hObj, Notification);
    190            }
    191          }
    192          
    193          /*********************************************************************
    194          *
    195          *       _OnTouchDefault
    196          */
    197          static void _OnTouchDefault(BUTTON_Handle hObj, WM_MESSAGE * pMsg) {
    198            const GUI_PID_STATE * pState;
    199            BUTTON_Obj * pObj;
    200            U16 State;
    201          
    202            pObj = BUTTON_LOCK_H(hObj);
    203            State = pObj->Widget.State;
    204            GUI_UNLOCK_H(pObj);
    205            pState = (const GUI_PID_STATE *)pMsg->Data.p;
    206            if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
    207              if (pState->Pressed) {
    208                if ((State & BUTTON_STATE_PRESSED) == 0){   
    209                  _OnButtonPressed(hObj);
    210                }
    211              } else {
    212                /* React only if button was pressed before ... avoid problems with moving / hiding windows above (such as dropdown) */
    213                if (State & BUTTON_STATE_PRESSED) {   
    214                  _OnButtonReleased(hObj, WM_NOTIFICATION_RELEASED);
    215                }
    216              }
    217            } else {
    218              _OnButtonReleased(hObj, WM_NOTIFICATION_MOVED_OUT);
    219            }
    220          }
    221          
    222          /*********************************************************************
    223          *
    224          *       _OnTouchReactOnLevel
    225          */

   \                                 In section .text, align 4, keep-with-next
    226          static void _OnTouchReactOnLevel(BUTTON_Handle hObj, WM_MESSAGE * pMsg) {
   \                     _OnTouchReactOnLevel:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    227            const GUI_PID_STATE * pState;
    228            BUTTON_Obj * pObj;
    229            U16 State;
    230          
    231            pObj = BUTTON_LOCK_H(hObj);
    232            State = pObj->Widget.State;
   \   0000000C   ........           BL       GUI_ALLOC_LockH
   \   00000010   B263D0E1           LDRH     R6,[R0, #+50]
    233            GUI_UNLOCK_H(pObj);
   \   00000014   ........           BL       GUI_ALLOC_UnlockH
    234            pState = (const GUI_PID_STATE *)pMsg->Data.p;
    235            if (!pMsg->Data.p) {  /* Mouse moved out */
   \   00000018   0C0095E5           LDR      R0,[R5, #+12]
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0400000A           BEQ      ??_OnTouchReactOnLevel_0
    236              _OnButtonReleased(hObj, WM_NOTIFICATION_MOVED_OUT);
    237            } else if ((!pState->Pressed) && (State & BUTTON_STATE_PRESSED)) {
   \   00000024   0800D0E5           LDRB     R0,[R0, #+8]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0F00001A           BNE      ??_OnTouchReactOnLevel_1
   \   00000030   400F16E3           TST      R6,#0x100
   \   00000034   0D00000A           BEQ      ??_OnTouchReactOnLevel_1
    238              _OnButtonReleased(hObj, WM_NOTIFICATION_MOVED_OUT);
   \                     ??_OnTouchReactOnLevel_0:
   \   00000038   401FA0E3           MOV      R1,#+256
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       WIDGET_AndState
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       GUI_ALLOC_LockH
   \   0000004C   285090E5           LDR      R5,[R0, #+40]
   \   00000050   0558A0E1           LSL      R5,R5,#+16
   \   00000054   2558A0E1           LSR      R5,R5,#+16
   \   00000058   ........           BL       GUI_ALLOC_UnlockH
   \   0000005C   020015E3           TST      R5,#0x2
   \   00000060   0200000A           BEQ      ??_OnTouchReactOnLevel_1
   \   00000064   0310A0E3           MOV      R1,#+3
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   ........           BL       WM_NotifyParent
    239            }
    240          }
   \                     ??_OnTouchReactOnLevel_1:
   \   00000070   7080BDE8           POP      {R4-R6,PC}       ;; return
    241          
    242          /*********************************************************************
    243          *
    244          *       _OnPidStateChange
    245          */

   \                                 In section .text, align 4, keep-with-next
    246          static void _OnPidStateChange(BUTTON_Handle hObj, WM_MESSAGE * pMsg) {
   \                     _OnPidStateChange:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    247            const WM_PID_STATE_CHANGED_INFO * pState;
    248            BUTTON_Obj * pObj;
    249            U16 State;
    250            pObj = BUTTON_LOCK_H(hObj);
    251            State = pObj->Widget.State;
   \   0000000C   ........           BL       GUI_ALLOC_LockH
   \   00000010   B263D0E1           LDRH     R6,[R0, #+50]
    252            GUI_UNLOCK_H(pObj);
   \   00000014   ........           BL       GUI_ALLOC_UnlockH
    253            pState = (const WM_PID_STATE_CHANGED_INFO *)pMsg->Data.p;
   \   00000018   0C0095E5           LDR      R0,[R5, #+12]
    254            if ((pState->StatePrev == 0) && pState->State) {
   \   0000001C   0910D0E5           LDRB     R1,[R0, #+9]
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   1100001A           BNE      ??_OnPidStateChange_0
   \   00000028   0800D0E5           LDRB     R0,[R0, #+8]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   2500000A           BEQ      ??_OnPidStateChange_1
    255              if ((State & BUTTON_STATE_PRESSED) == 0){   
   \   00000034   400F16E3           TST      R6,#0x100
   \   00000038   2300001A           BNE      ??_OnPidStateChange_1
    256                _OnButtonPressed(hObj);
   \   0000003C   401FA0E3           MOV      R1,#+256
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   ........           BL       WIDGET_OrState
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   ........           BL       GUI_ALLOC_LockH
   \   00000050   285090E5           LDR      R5,[R0, #+40]
   \   00000054   0558A0E1           LSL      R5,R5,#+16
   \   00000058   2558A0E1           LSR      R5,R5,#+16
   \   0000005C   ........           BL       GUI_ALLOC_UnlockH
   \   00000060   020015E3           TST      R5,#0x2
   \   00000064   1800000A           BEQ      ??_OnPidStateChange_1
   \   00000068   0110A0E3           MOV      R1,#+1
   \   0000006C   140000EA           B        ??_OnPidStateChange_2
    257              }
    258            } else if ((pState->StatePrev == 1) && (pState->State == 0)) {
   \                     ??_OnPidStateChange_0:
   \   00000070   010051E3           CMP      R1,#+1
   \   00000074   0800D005           LDRBEQ   R0,[R0, #+8]
   \   00000078   00005003           CMPEQ    R0,#+0
   \   0000007C   1200001A           BNE      ??_OnPidStateChange_1
    259              if (State & BUTTON_STATE_PRESSED) {   
   \   00000080   400F16E3           TST      R6,#0x100
   \   00000084   1000000A           BEQ      ??_OnPidStateChange_1
    260                _OnButtonReleased(hObj, WM_NOTIFICATION_RELEASED);
   \   00000088   401FA0E3           MOV      R1,#+256
   \   0000008C   0400A0E1           MOV      R0,R4
   \   00000090   ........           BL       WIDGET_AndState
   \   00000094   0400A0E1           MOV      R0,R4
   \   00000098   ........           BL       GUI_ALLOC_LockH
   \   0000009C   285090E5           LDR      R5,[R0, #+40]
   \   000000A0   B063D0E1           LDRH     R6,[R0, #+48]
   \   000000A4   0558A0E1           LSL      R5,R5,#+16
   \   000000A8   2558A0E1           LSR      R5,R5,#+16
   \   000000AC   ........           BL       GUI_ALLOC_UnlockH
   \   000000B0   0600A0E1           MOV      R0,R6
   \   000000B4   ........           BL       GUI_StoreKey
   \   000000B8   020015E3           TST      R5,#0x2
   \   000000BC   0200000A           BEQ      ??_OnPidStateChange_1
   \   000000C0   0210A0E3           MOV      R1,#+2
   \                     ??_OnPidStateChange_2:
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   ........           BL       WM_NotifyParent
    261              }
    262            }
    263          }
   \                     ??_OnPidStateChange_1:
   \   000000CC   7080BDE8           POP      {R4-R6,PC}       ;; return
    264          
    265          /*********************************************************************
    266          *
    267          *       Function pointers for BUTTON_REACT_ON_LEVEL
    268          */
    269          #if (BUTTON_REACT_ON_LEVEL == 1)

   \                                 In section .data, align 4
    270            static void (* _pfOnTouch)         (BUTTON_Handle hObj, WM_MESSAGE * pMsg) = _OnTouchReactOnLevel;
   \                     _pfOnTouch:
   \   00000000   ........           DC32 _OnTouchReactOnLevel
   \   00000004   ........           DC32 _OnPidStateChange
    271            static void (* _pfOnPidStateChange)(BUTTON_Handle hObj, WM_MESSAGE * pMsg) = _OnPidStateChange;
    272          #else
    273            static void (* _pfOnTouch)         (BUTTON_Handle hObj, WM_MESSAGE * pMsg) = _OnTouchDefault;
    274            static void (* _pfOnPidStateChange)(BUTTON_Handle hObj, WM_MESSAGE * pMsg);
    275          #endif
    276          
    277          /*********************************************************************
    278          *
    279          *       BUTTON_SetReactOnLevel
    280          */

   \                                 In section .text, align 4, keep-with-next
    281          void BUTTON_SetReactOnLevel(void) {
    282            _pfOnTouch          = _OnTouchReactOnLevel;
   \                     BUTTON_SetReactOnLevel:
   \   00000000   ........           LDR      R0,??DataTable2
   \   00000004   ........           LDR      R1,??DataTable2_1
   \   00000008   001080E5           STR      R1,[R0, #+0]
    283            _pfOnPidStateChange = _OnPidStateChange;
   \   0000000C   ........           LDR      R1,??DataTable2_2
   \   00000010   041080E5           STR      R1,[R0, #+4]
    284          }
   \   00000014   1EFF2FE1           BX       LR               ;; return
    285          
    286          /*********************************************************************
    287          *
    288          *       Private routines
    289          *
    290          **********************************************************************
    291          */
    292          /*********************************************************************
    293          *
    294          *       BUTTON_LockH
    295          */
    296          #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
    297          BUTTON_Obj * BUTTON_LockH(BUTTON_Handle h) {
    298            BUTTON_Obj * p = (BUTTON_Obj *)GUI_LOCK_H(h);
    299            if (p) {
    300              if (p->DebugId != BUTTON_ID) {
    301                GUI_DEBUG_ERROROUT("BUTTON.c: Wrong handle type or Object not init'ed");
    302                return 0;
    303              }
    304            }
    305            return p;
    306          }
    307          #endif
    308          
    309          /*********************************************************************
    310          *
    311          *       Exported routines:  Callback
    312          *
    313          **********************************************************************
    314          */
    315          /*********************************************************************
    316          *
    317          *       BUTTON_Callback
    318          */

   \                                 In section .text, align 4, keep-with-next
    319          void BUTTON_Callback(WM_MESSAGE *pMsg) {
   \                     BUTTON_Callback:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    320            int PressedCnt, Key;
    321            BUTTON_Handle hObj;
    322            
    323            hObj = pMsg->hWin;
   \   00000008   044095E5           LDR      R4,[R5, #+4]
    324            /* Let widget handle the standard messages */
    325            if (WIDGET_HandleActive(hObj, pMsg) == 0) {
   \   0000000C   0510A0E1           MOV      R1,R5
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   ........           BL       WIDGET_HandleActive
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   2E00000A           BEQ      ??BUTTON_Callback_1
    326              return;
    327            }
    328            switch (pMsg->MsgId) {
   \   00000020   000095E5           LDR      R0,[R5, #+0]
   \   00000024   0B0040E2           SUB      R0,R0,#+11
   \   00000028   060050E3           CMP      R0,#+6
   \   0000002C   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??BUTTON_Callback_0:
   \   00000030   2700008A           BHI      ??BUTTON_Callback_2
   \   00000034   1D0000EA           B        ??BUTTON_Callback_3
   \   00000038   0C0000EA           B        ??BUTTON_Callback_4
   \   0000003C   240000EA           B        ??BUTTON_Callback_2
   \   00000040   260000EA           B        ??BUTTON_Callback_5
   \   00000044   0F0000EA           B        ??BUTTON_Callback_6
   \   00000048   210000EA           B        ??BUTTON_Callback_2
   \   0000004C   FFFFFFEA           B        ??BUTTON_Callback_7
   \                     ??BUTTON_Callback_7:
   \   00000050   ........           LDR      R0,??DataTable2
   \   00000054   042090E5           LDR      R2,[R0, #+4]
   \   00000058   000052E3           CMP      R2,#+0
   \   0000005C   1E00000A           BEQ      ??BUTTON_Callback_1
    329            case WM_PID_STATE_CHANGED:
    330              if (_pfOnPidStateChange) {
    331                _pfOnPidStateChange(hObj, pMsg);
   \   00000060   0510A0E1           MOV      R1,R5
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   7040BDE8           POP      {R4-R6,LR}
   \   0000006C   12FF2FE1           BX       R2               ;; tailcall
    332              }
    333              return;
    334            case WM_TOUCH:
    335              _pfOnTouch(hObj, pMsg);
   \                     ??BUTTON_Callback_4:
   \   00000070   0510A0E1           MOV      R1,R5
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   7040BDE8           POP      {R4-R6,LR}
   \   0000007C   ........           LDR      R2,??DataTable2
   \   00000080   002092E5           LDR      R2,[R2, #+0]
   \   00000084   12FF2FE1           BX       R2               ;; tailcall
    336              return;      /* Message handled. Do not call WM_DefaultProc, because the window may have been destroyed */
    337            case WM_PAINT:
    338              GUI_DEBUG_LOG("BUTTON: _BUTTON_Callback(WM_PAINT)\n");
    339              _Paint(hObj);
   \                     ??BUTTON_Callback_6:
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   ........           BL       GUI_ALLOC_LockH
   \   00000090   600090E5           LDR      R0,[R0, #+96]
   \   00000094   005090E5           LDR      R5,[R0, #+0]
   \   00000098   ........           BL       GUI_ALLOC_UnlockH
   \   0000009C   000055E3           CMP      R5,#+0
   \   000000A0   0D00000A           BEQ      ??BUTTON_Callback_1
   \   000000A4   0400A0E1           MOV      R0,R4
   \   000000A8   35FF2FE1           BLX      R5
   \   000000AC   7080BDE8           POP      {R4-R6,PC}
    340              return;
    341            case WM_DELETE:
    342              GUI_DEBUG_LOG("BUTTON: _BUTTON_Callback(WM_DELETE)\n");
    343              _Delete(hObj);
   \                     ??BUTTON_Callback_3:
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   ........           BL       GUI_ALLOC_LockH
   \   000000B8   0040A0E1           MOV      R4,R0
   \   000000BC   640084E2           ADD      R0,R4,#+100
   \   000000C0   ........           BL       GUI_ALLOC_FreePtr
   \   000000C4   0310A0E3           MOV      R1,#+3
   \   000000C8   680084E2           ADD      R0,R4,#+104
   \   000000CC   ........           BL       GUI_ALLOC_FreePtrArray
   \   000000D0   ........           BL       GUI_ALLOC_UnlockH
    344              break;       /* No return here ... WM_DefaultProc needs to be called */
    345            case WM_KEY:
    346              PressedCnt = ((WM_KEY_INFO*)(pMsg->Data.p))->PressedCnt;
    347              Key        = ((WM_KEY_INFO*)(pMsg->Data.p))->Key;
    348              switch (Key) {
    349              case GUI_KEY_ENTER:
    350                if (PressedCnt > 0) {
    351                  _OnButtonPressed(hObj);
    352                  _OnButtonReleased(hObj, WM_NOTIFICATION_RELEASED);
    353                  return;
    354                }
    355                break;
    356              case GUI_KEY_SPACE:
    357                if (PressedCnt > 0) {
    358                  _OnButtonPressed(hObj);
    359                } else {
    360                  _OnButtonReleased(hObj, WM_NOTIFICATION_RELEASED);
    361                }
    362                return;
    363              }
    364            }
    365            WM_DefaultProc(pMsg);
   \                     ??BUTTON_Callback_2:
   \   000000D4   0500A0E1           MOV      R0,R5
   \   000000D8   ........           BL       WM_DefaultProc
    366          }
   \                     ??BUTTON_Callback_1:
   \   000000DC   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??BUTTON_Callback_5:
   \   000000E0   0C0095E5           LDR      R0,[R5, #+12]
   \   000000E4   041090E5           LDR      R1,[R0, #+4]
   \   000000E8   000090E5           LDR      R0,[R0, #+0]
   \   000000EC   0D0050E2           SUBS     R0,R0,#+13
   \   000000F0   0200000A           BEQ      ??BUTTON_Callback_8
   \   000000F4   130050E2           SUBS     R0,R0,#+19
   \   000000F8   2200000A           BEQ      ??BUTTON_Callback_9
   \   000000FC   F4FFFFEA           B        ??BUTTON_Callback_2
   \                     ??BUTTON_Callback_8:
   \   00000100   010051E3           CMP      R1,#+1
   \   00000104   F2FFFFBA           BLT      ??BUTTON_Callback_2
   \   00000108   401FA0E3           MOV      R1,#+256
   \   0000010C   0400A0E1           MOV      R0,R4
   \   00000110   ........           BL       WIDGET_OrState
   \   00000114   0400A0E1           MOV      R0,R4
   \   00000118   ........           BL       GUI_ALLOC_LockH
   \   0000011C   285090E5           LDR      R5,[R0, #+40]
   \   00000120   0558A0E1           LSL      R5,R5,#+16
   \   00000124   2558A0E1           LSR      R5,R5,#+16
   \   00000128   ........           BL       GUI_ALLOC_UnlockH
   \   0000012C   020015E3           TST      R5,#0x2
   \   00000130   0200000A           BEQ      ??BUTTON_Callback_10
   \   00000134   0110A0E3           MOV      R1,#+1
   \   00000138   0400A0E1           MOV      R0,R4
   \   0000013C   ........           BL       WM_NotifyParent
   \                     ??BUTTON_Callback_10:
   \   00000140   401FA0E3           MOV      R1,#+256
   \   00000144   0400A0E1           MOV      R0,R4
   \                     ??BUTTON_Callback_11:
   \   00000148   ........           BL       WIDGET_AndState
   \   0000014C   0400A0E1           MOV      R0,R4
   \   00000150   ........           BL       GUI_ALLOC_LockH
   \   00000154   285090E5           LDR      R5,[R0, #+40]
   \   00000158   B063D0E1           LDRH     R6,[R0, #+48]
   \   0000015C   0558A0E1           LSL      R5,R5,#+16
   \   00000160   2558A0E1           LSR      R5,R5,#+16
   \   00000164   ........           BL       GUI_ALLOC_UnlockH
   \   00000168   0600A0E1           MOV      R0,R6
   \   0000016C   ........           BL       GUI_StoreKey
   \   00000170   020015E3           TST      R5,#0x2
   \   00000174   D8FFFF0A           BEQ      ??BUTTON_Callback_1
   \   00000178   0210A0E3           MOV      R1,#+2
   \                     ??BUTTON_Callback_12:
   \   0000017C   0400A0E1           MOV      R0,R4
   \   00000180   7040BDE8           POP      {R4-R6,LR}
   \   00000184   ........           B        WM_NotifyParent  ;; tailcall
   \                     ??BUTTON_Callback_9:
   \   00000188   010051E3           CMP      R1,#+1
   \   0000018C   401FA0E3           MOV      R1,#+256
   \   00000190   0400A0E1           MOV      R0,R4
   \   00000194   EBFFFFBA           BLT      ??BUTTON_Callback_11
   \   00000198   ........           BL       WIDGET_OrState
   \   0000019C   0400A0E1           MOV      R0,R4
   \   000001A0   ........           BL       GUI_ALLOC_LockH
   \   000001A4   285090E5           LDR      R5,[R0, #+40]
   \   000001A8   0558A0E1           LSL      R5,R5,#+16
   \   000001AC   2558A0E1           LSR      R5,R5,#+16
   \   000001B0   ........           BL       GUI_ALLOC_UnlockH
   \   000001B4   020015E3           TST      R5,#0x2
   \   000001B8   C7FFFF0A           BEQ      ??BUTTON_Callback_1
   \   000001BC   0110A0E3           MOV      R1,#+1
   \   000001C0   EDFFFFEA           B        ??BUTTON_Callback_12
    367          
    368          /*********************************************************************
    369          *
    370          *       Exported routines:  Create
    371          *
    372          **********************************************************************
    373          */
    374          /*********************************************************************
    375          *
    376          *       BUTTON_CreateEx
    377          */

   \                                 In section .text, align 4, keep-with-next
    378          BUTTON_Handle BUTTON_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id) {
   \                     BUTTON_CreateEx:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0270A0E1           MOV      R7,R2
   \   00000014   0380A0E1           MOV      R8,R3
   \   00000018   30909DE5           LDR      R9,[SP, #+48]
   \   0000001C   34A09DE5           LDR      R10,[SP, #+52]
   \   00000020   3C409DE5           LDR      R4,[SP, #+60]
    379            BUTTON_Handle hObj;
    380            BUTTON_Obj * pObj;
    381          
    382            GUI_USE_PARA(ExFlags);
    383            /* Create the window */
    384            WM_LOCK();
   \   00000024   ........           BL       GUI_Lock
    385            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, BUTTON_Callback,
    386                                          sizeof(BUTTON_Obj) - sizeof(WM_Obj));
   \   00000028   4800A0E3           MOV      R0,#+72
   \   0000002C   0C008DE5           STR      R0,[SP, #+12]
   \   00000030   ........           LDR      R0,??DataTable2_3
   \   00000034   04A08DE5           STR      R10,[SP, #+4]
   \   00000038   08008DE5           STR      R0,[SP, #+8]
   \   0000003C   00908DE5           STR      R9,[SP, #+0]
   \   00000040   0830A0E1           MOV      R3,R8
   \   00000044   0720A0E1           MOV      R2,R7
   \   00000048   0610A0E1           MOV      R1,R6
   \   0000004C   0500A0E1           MOV      R0,R5
   \   00000050   ........           BL       WM_CreateWindowAsChild
   \   00000054   0050B0E1           MOVS     R5,R0
    387            if (hObj) {
   \   00000058   1200000A           BEQ      ??BUTTON_CreateEx_0
    388              pObj = (BUTTON_Obj *)GUI_LOCK_H(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
   \   0000005C   ........           BL       GUI_ALLOC_LockH
   \   00000060   0060A0E1           MOV      R6,R0
    389              /* init widget specific variables */
    390              WIDGET__Init(&pObj->Widget, Id, WIDGET_STATE_FOCUSSABLE);
   \   00000064   1020A0E3           MOV      R2,#+16
   \   00000068   0410A0E1           MOV      R1,R4
   \   0000006C   ........           BL       WIDGET__Init
    391              /* init member variables */
    392              BUTTON_INIT_ID(pObj);
    393              pObj->Props = BUTTON__DefaultProps;
   \   00000070   ........           LDR      R4,??DataTable2_4
   \   00000074   340086E2           ADD      R0,R6,#+52
   \   00000078   8E50B4E8           LDM      R4!,{R1-R3,R7,R12,LR}
   \   0000007C   8E50A0E8           STM      R0!,{R1-R3,R7,R12,LR}
   \   00000080   0E50B4E8           LDM      R4!,{R1-R3,R12,LR}
   \   00000084   2C4044E2           SUB      R4,R4,#+44
   \   00000088   0E50A0E8           STM      R0!,{R1-R3,R12,LR}
    394              pObj->pWidgetSkin = BUTTON__pSkinDefault;
   \   0000008C   2C0094E5           LDR      R0,[R4, #+44]
   \   00000090   600086E5           STR      R0,[R6, #+96]
    395              GUI_UNLOCK_H(pObj);
   \   00000094   ........           BL       GUI_ALLOC_UnlockH
    396              BUTTON__pSkinDefault->pfCreate(hObj);
   \   00000098   2C1094E5           LDR      R1,[R4, #+44]
   \   0000009C   0500A0E1           MOV      R0,R5
   \   000000A0   041091E5           LDR      R1,[R1, #+4]
   \   000000A4   31FF2FE1           BLX      R1
    397            } else {
    398              GUI_DEBUG_ERROROUT_IF(hObj==0, "BUTTON_Create failed")
    399            }
    400            WM_UNLOCK();
   \                     ??BUTTON_CreateEx_0:
   \   000000A8   ........           BL       GUI_Unlock
    401            return hObj;
   \   000000AC   0500A0E1           MOV      R0,R5
   \   000000B0   10D08DE2           ADD      SP,SP,#+16
   \   000000B4   F087BDE8           POP      {R4-R10,PC}      ;; return
    402          }
    403          
    404          /*********************************************************************
    405          *
    406          *       Exported routines:  Various methods
    407          *
    408          **********************************************************************
    409          */
    410          
    411          /*********************************************************************
    412          *
    413          *       BUTTON_SetText
    414          */

   \                                 In section .text, align 4, keep-with-next
    415          void BUTTON_SetText(BUTTON_Handle hObj, const char* s) {
   \                     BUTTON_SetText:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   08D04DE2           SUB      SP,SP,#+8
   \   0000000C   0150A0E1           MOV      R5,R1
    416            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   1500000A           BEQ      ??BUTTON_SetText_0
    417              BUTTON_Obj * pObj;
    418              WM_HMEM hpText;
    419              WM_HMEM hpTextOld;
    420              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
    421              pObj = BUTTON_LOCK_H(hObj);
    422              hpText = hpTextOld = pObj->hpText;
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
   \   00000024   646090E5           LDR      R6,[R0, #+100]
   \   00000028   00608DE5           STR      R6,[SP, #+0]
    423              GUI_UNLOCK_H(pObj);
   \   0000002C   ........           BL       GUI_ALLOC_UnlockH
    424              if (GUI__SetText(&hpText, s)) {
   \   00000030   0510A0E1           MOV      R1,R5
   \   00000034   0D00A0E1           MOV      R0,SP
   \   00000038   ........           BL       GUI__SetText
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0900000A           BEQ      ??BUTTON_SetText_1
    425                if (hpText != hpTextOld) {
   \   00000044   00009DE5           LDR      R0,[SP, #+0]
   \   00000048   060050E1           CMP      R0,R6
   \   0000004C   0400000A           BEQ      ??BUTTON_SetText_2
    426                  pObj = BUTTON_LOCK_H(hObj);
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           BL       GUI_ALLOC_LockH
    427                  pObj->hpText = hpText;
   \   00000058   00109DE5           LDR      R1,[SP, #+0]
   \   0000005C   641080E5           STR      R1,[R0, #+100]
    428                  GUI_UNLOCK_H(pObj);
   \   00000060   ........           BL       GUI_ALLOC_UnlockH
    429                }
    430                BUTTON_Invalidate(hObj);
   \                     ??BUTTON_SetText_2:
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           BL       WM_InvalidateWindow
    431              }
    432              WM_UNLOCK();
   \                     ??BUTTON_SetText_1:
   \   0000006C   ........           BL       GUI_Unlock
    433            }
    434          }
   \                     ??BUTTON_SetText_0:
   \   00000070   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000074   7080BDE8           POP      {R4-R6,PC}       ;; return
    435          
    436          /*********************************************************************
    437          *
    438          *       BUTTON_SetFont
    439          */

   \                                 In section .text, align 4, keep-with-next
    440          void BUTTON_SetFont(BUTTON_Handle hObj, const GUI_FONT GUI_UNI_PTR * pfont) {
   \                     BUTTON_SetFont:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
    441            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0700000A           BEQ      ??BUTTON_SetFont_0
    442              BUTTON_Obj * pObj;
    443              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
    444              pObj = BUTTON_LOCK_H(hObj);
    445              pObj->Props.pFont = pfont;
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
   \   00000024   545080E5           STR      R5,[R0, #+84]
    446              GUI_UNLOCK_H(pObj);
   \   00000028   ........           BL       GUI_ALLOC_UnlockH
    447              BUTTON_Invalidate(hObj);
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       WM_InvalidateWindow
    448              WM_UNLOCK();
   \   00000034   ........           BL       GUI_Unlock
    449            }
    450          }
   \                     ??BUTTON_SetFont_0:
   \   00000038   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000003C   3080BDE8           POP      {R4,R5,PC}       ;; return
    451          
    452          /*********************************************************************
    453          *
    454          *       BUTTON_SetState
    455          */

   \                                 In section .text, align 4, keep-with-next
    456          void BUTTON_SetState(BUTTON_Handle hObj, int State) {
    457            WIDGET_SetState(hObj, State);
   \                     BUTTON_SetState:
   \   00000000   ........           B        WIDGET_SetState  ;; tailcall
    458          }
    459          
    460          /*********************************************************************
    461          *
    462          *       BUTTON_SetPressed
    463          */

   \                                 In section .text, align 4, keep-with-next
    464          void BUTTON_SetPressed(BUTTON_Handle hObj, int State) {
   \                     BUTTON_SetPressed:
   \   00000000   00402DE9           PUSH     {LR}
    465            if (State) {
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   401FA0E3           MOV      R1,#+256
   \   00000010   0100000A           BEQ      ??BUTTON_SetPressed_0
    466              WIDGET_OrState(hObj, BUTTON_STATE_PRESSED);
   \   00000014   ........           BL       WIDGET_OrState
   \   00000018   000000EA           B        ??BUTTON_SetPressed_1
    467            } else {
    468              WIDGET_AndState(hObj, BUTTON_STATE_PRESSED);
   \                     ??BUTTON_SetPressed_0:
   \   0000001C   ........           BL       WIDGET_AndState
    469            }
    470          }
   \                     ??BUTTON_SetPressed_1:
   \   00000020   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000024   0080BDE8           POP      {PC}             ;; return
    471          
    472          /*********************************************************************
    473          *
    474          *       BUTTON_SetFocussable
    475          */

   \                                 In section .text, align 4, keep-with-next
    476          void BUTTON_SetFocussable(BUTTON_Handle hObj, int State) {
   \                     BUTTON_SetFocussable:
   \   00000000   00402DE9           PUSH     {LR}
    477            if (State) {
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   1010A0E3           MOV      R1,#+16
   \   00000010   0100000A           BEQ      ??BUTTON_SetFocussable_0
    478              WIDGET_OrState(hObj, WIDGET_STATE_FOCUSSABLE);
   \   00000014   ........           BL       WIDGET_OrState
   \   00000018   000000EA           B        ??BUTTON_SetFocussable_1
    479            } else {
    480              WIDGET_AndState(hObj, WIDGET_STATE_FOCUSSABLE);
   \                     ??BUTTON_SetFocussable_0:
   \   0000001C   ........           BL       WIDGET_AndState
    481            }
    482          }
   \                     ??BUTTON_SetFocussable_1:
   \   00000020   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000024   0080BDE8           POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     _pfOnTouch

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   ........           DC32     _OnTouchReactOnLevel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   ........           DC32     _OnPidStateChange

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   ........           DC32     BUTTON_Callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   ........           DC32     BUTTON__DefaultProps
    483          
    484          #else                            /* Avoid problems with empty object modules */
    485            void BUTTON_C(void) {}
    486          #endif /* GUI_WINSUPPORT */
    487          
    488          
    489          
    490          

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     BUTTON_Callback            16
     BUTTON_CreateEx            48
     BUTTON_SetFocussable        8
     BUTTON_SetFont             16
     BUTTON_SetPressed           8
     BUTTON_SetReactOnLevel      0
     BUTTON_SetState             8
     BUTTON_SetText             24
     _OnPidStateChange          16
     _OnTouchReactOnLevel       16


   Section sizes:

     Function/Label         Bytes
     --------------         -----
     BUTTON__DefaultProps     48
     BUTTON__pSkinDefault
     _OnTouchReactOnLevel    116
     _OnPidStateChange       208
     _pfOnTouch                8
     _pfOnPidStateChange
     BUTTON_SetReactOnLevel   24
     BUTTON_Callback         452
     BUTTON_CreateEx         184
     BUTTON_SetText          120
     BUTTON_SetFont           64
     BUTTON_SetState           4
     BUTTON_SetPressed        40
     BUTTON_SetFocussable     40
     ??DataTable2              4
     ??DataTable2_1            4
     ??DataTable2_2            4
     ??DataTable2_3            4
     ??DataTable2_4            4

 
    56 bytes in section .data
 1 272 bytes in section .text
 
 1 272 bytes of CODE memory
    56 bytes of DATA memory

Errors: none
Warnings: 1
