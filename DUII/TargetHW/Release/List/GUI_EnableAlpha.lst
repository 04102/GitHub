###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:15:42 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUI_EnableAlpha.c                   #
#    Command line =  C:\DUII\TargetHW\GUI\GUI_EnableAlpha.c -D DEBUG=1 -D     #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUI_EnableAlpha.lst        #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUI_EnableAlpha.o           #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUI_EnableAlpha.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUI_EnableAlpha.c
     19          Purpose     : Enables automatic alphablending
     20          ----------------------------------------------------------------------
     21          */
     22          
     23          #include "GUI_Private.h"
     24          
     25          /*********************************************************************
     26          *
     27          *       Static data
     28          *
     29          **********************************************************************
     30          */

   \                                 In section .bss, align 4
     31          static const LCD_SET_COLOR_API * _pSetColorAPI;
   \                     _pSetColorAPI:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
   \   0000000C                      DS8 4
   \   00000010                      DS8 4
   \   00000014                      DS8 4
   \   00000018                      DS8 4
   \   0000001C                      DS8 4
   \   00000020                      DS8 4
     32          
     33          static U32          _Color;
     34          static U32          _BkColor;
     35          static U8         * _pBuffer;
     36          static GUI_DEVICE * _pDevice;
     37          static int          _Linked;
     38          static int          _Buffersize;
     39          static U32          _UserAlpha;
     40          
     41          /*********************************************************************
     42          *
     43          *       Static code
     44          *
     45          **********************************************************************
     46          */
     47          /*********************************************************************
     48          *
     49          *       _SwapIndices
     50          */
     51          static void _SwapIndices(void) {
     52            LCD_PIXELINDEX Temp;
     53            //
     54            // Swap GUI indices
     55            //
     56            Temp = LCD__GetColorIndex();
     57            LCD__SetColorIndex(LCD__GetBkColorIndex());
     58            LCD__SetBkColorIndex(Temp);
     59          }
     60          
     61          /*********************************************************************
     62          *
     63          *       _SwapColors
     64          */
     65          static void _SwapColors(void) {
     66            GUI_COLOR      Temp;
     67            //
     68            // Swap internal colors
     69            //
     70            Temp     = _Color;
     71            _Color   = _BkColor;
     72            _BkColor = Temp;
     73          }
     74          
     75          /*********************************************************************
     76          *
     77          *       _ManageAlpha
     78          */
     79          static void _ManageAlpha(void) {
     80            static U32 AlphaOld;
     81            U32 Alpha;
     82            U32 BkAlpha;
     83          
     84            Alpha   = _Color   >> 24;
     85            BkAlpha = _BkColor >> 24;
     86            if (Alpha || BkAlpha) {
     87              if (_Linked == 0) {
     88                GUI_DEVICE_Link(_pDevice);
     89                _Linked = 1;
     90              }
     91            } else {
     92              if (_Linked == 1) {
     93                GUI_DEVICE_Unlink(_pDevice);
     94                _Linked = 0;
     95              }
     96            }
     97            if (_UserAlpha) {
     98              Alpha += ((255 - Alpha) * _UserAlpha) / 255;
     99            }
    100            if (Alpha != AlphaOld) {
    101              GUI_SetAlpha(Alpha);
    102              AlphaOld = Alpha;
    103            }
    104          }
    105          
    106          /*********************************************************************
    107          *
    108          *       _DrawBitmap
    109          *
    110          * Purpose:
    111          *   This is the only function which should do something other than
    112          *   routing. It has to make sure that 1bpp bitmaps are drawn right.
    113          *   Drawing these bitmaps is the only operation which requires the
    114          *   background color in the display driver routines.
    115          *   
    116          *   The trick of drawing text with the right alpha blending for foreground
    117          *   and background pixels is the following:
    118          *
    119          *   First set the mode to 'LCD_DRAWMODE_TRANS' and draw the text pixels.
    120          *   Then swap the background colors and color indices for the driver and
    121          *   set the alpha blending values according to the background color.
    122          *   Then invert and draw the bitmap pixels line by line. The effect is
    123          *   that only the background pixels will be drawn during this second step.
    124          */

   \                                 In section .text, align 4, keep-with-next
    125          static void _DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0,
    126                                 int xSize, int ySize,
    127                                 int BitsPerPixel, 
    128                                 int BytesPerLine,
    129                                 const U8 * pData, int Diff,
    130                                 const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitmap:
   \   00000000   F14F2DE9           PUSH     {R0,R4-R11,LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
   \   00000008   4C009DE5           LDR      R0,[SP, #+76]
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   03B0A0E1           MOV      R11,R3
   \   00000018   48609DE5           LDR      R6,[SP, #+72]
   \   0000001C   50709DE5           LDR      R7,[SP, #+80]
   \   00000020   54809DE5           LDR      R8,[SP, #+84]
    131            GUI_DEVICE * pDeviceNext;
    132            int i, MaxBytes;
    133            U8 * pSrc;
    134            U8 * pDst;
    135          
    136            if ((BitsPerPixel == 1) &&                        // Only 1bpp bitmaps
    137                (pTrans == LCD_pBkColorIndex) &&              // Only device dependent bitmaps (text)
    138                (GUI_Context.DrawMode == LCD_DRAWMODE_NORMAL) // Only non transparent text
    139               ) {
   \   00000024   010050E3           CMP      R0,#+1
   \   00000028   9D00001A           BNE      ??_DrawBitmap_0
   \   0000002C   ........           LDR      R2,??DataTable8
   \   00000030   5C109DE5           LDR      R1,[SP, #+92]
   \   00000034   002092E5           LDR      R2,[R2, #+0]
   \   00000038   020051E1           CMP      R1,R2
   \   0000003C   9800001A           BNE      ??_DrawBitmap_0
   \   00000040   ........           LDR      R1,??DataTable8_1
   \   00000044   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000048   000051E3           CMP      R1,#+0
   \   0000004C   9400001A           BNE      ??_DrawBitmap_0
    140              //
    141              // Draw foreground pixels with the required color
    142              //
    143              GUI_Context.DrawMode = LCD_DRAWMODE_TRANS;
   \   00000050   ........           LDR      R0,??DataTable8_1
   \   00000054   0210A0E3           MOV      R1,#+2
   \   00000058   1010C0E5           STRB     R1,[R0, #+16]
    144              pDeviceNext = pDevice->pNext;
   \   0000005C   20009DE5           LDR      R0,[SP, #+32]
    145              pDeviceNext->pDeviceAPI->pfDrawBitmap(pDeviceNext, 
    146                                                    x0, y0, 
    147                                                    xSize, ySize, 
    148                                                    BitsPerPixel, BytesPerLine, pData, Diff, pTrans);
   \   00000060   5C109DE5           LDR      R1,[SP, #+92]
   \   00000064   000090E5           LDR      R0,[R0, #+0]
   \   00000068   14108DE5           STR      R1,[SP, #+20]
   \   0000006C   58109DE5           LDR      R1,[SP, #+88]
   \   00000070   0C808DE5           STR      R8,[SP, #+12]
   \   00000074   10108DE5           STR      R1,[SP, #+16]
   \   00000078   0110A0E3           MOV      R1,#+1
   \   0000007C   08708DE5           STR      R7,[SP, #+8]
   \   00000080   04108DE5           STR      R1,[SP, #+4]
   \   00000084   00608DE5           STR      R6,[SP, #+0]
   \   00000088   0CC090E5           LDR      R12,[R0, #+12]
   \   0000008C   0520A0E1           MOV      R2,R5
   \   00000090   0410A0E1           MOV      R1,R4
   \   00000094   04C09CE5           LDR      R12,[R12, #+4]
   \   00000098   3CFF2FE1           BLX      R12
    149              //
    150              // Prepare alpha blending for background pixels
    151              //
    152              _SwapColors();
   \   0000009C   ........           LDR      R9,??DataTable8_2
    153              _SwapIndices();
   \   000000A0   ........           LDR      R12,??DataTable8
   \   000000A4   040099E5           LDR      R0,[R9, #+4]
   \   000000A8   081099E5           LDR      R1,[R9, #+8]
   \   000000AC   ........           LDR      R2,??DataTable8_3
   \   000000B0   00C09CE5           LDR      R12,[R12, #+0]
   \   000000B4   041089E5           STR      R1,[R9, #+4]
   \   000000B8   080089E5           STR      R0,[R9, #+8]
   \   000000BC   002092E5           LDR      R2,[R2, #+0]
   \   000000C0   00E09CE5           LDR      LR,[R12, #+0]
   \   000000C4   003092E5           LDR      R3,[R2, #+0]
   \   000000C8   00E082E5           STR      LR,[R2, #+0]
    154              _ManageAlpha();
   \   000000CC   21ACB0E1           LSRS     R10,R1,#+24
   \   000000D0   00308CE5           STR      R3,[R12, #+0]
   \   000000D4   200CB001           LSRSEQ   R0,R0,#+24
   \   000000D8   0600000A           BEQ      ??_DrawBitmap_1
   \   000000DC   140099E5           LDR      R0,[R9, #+20]
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   0A00001A           BNE      ??_DrawBitmap_2
   \   000000E8   100099E5           LDR      R0,[R9, #+16]
   \   000000EC   ........           BL       GUI_DEVICE_Link
   \   000000F0   0100A0E3           MOV      R0,#+1
   \   000000F4   050000EA           B        ??_DrawBitmap_3
   \                     ??_DrawBitmap_1:
   \   000000F8   140099E5           LDR      R0,[R9, #+20]
   \   000000FC   010050E3           CMP      R0,#+1
   \   00000100   0300001A           BNE      ??_DrawBitmap_2
   \   00000104   100099E5           LDR      R0,[R9, #+16]
   \   00000108   ........           BL       GUI_DEVICE_Unlink
   \   0000010C   0000A0E3           MOV      R0,#+0
   \                     ??_DrawBitmap_3:
   \   00000110   140089E5           STR      R0,[R9, #+20]
   \                     ??_DrawBitmap_2:
   \   00000114   1C0099E5           LDR      R0,[R9, #+28]
   \   00000118   000050E3           CMP      R0,#+0
   \   0000011C   0400000A           BEQ      ??_DrawBitmap_4
   \   00000120   FF106AE2           RSB      R1,R10,#+255
   \   00000124   900101E0           MUL      R1,R0,R1
   \   00000128   ........           LDR      R2,??DataTable8_4  ;; 0x80808081
   \   0000012C   912280E0           UMULL    R2,R0,R1,R2
   \   00000130   A0A38AE0           ADD      R10,R10,R0, LSR #+7
   \                     ??_DrawBitmap_4:
   \   00000134   200099E5           LDR      R0,[R9, #+32]
   \   00000138   00005AE1           CMP      R10,R0
   \   0000013C   0200000A           BEQ      ??_DrawBitmap_5
   \   00000140   FF000AE2           AND      R0,R10,#0xFF
   \   00000144   ........           BL       GUI_SetAlpha
   \   00000148   20A089E5           STR      R10,[R9, #+32]
    155              pDevice = pDevice->pNext;
   \                     ??_DrawBitmap_5:
   \   0000014C   20009DE5           LDR      R0,[SP, #+32]
   \   00000150   00A090E5           LDR      R10,[R0, #+0]
    156              //
    157              // Draw foreground pixels with the required color line by line
    158              //
    159              if (_pBuffer) {
   \   00000154   0C0099E5           LDR      R0,[R9, #+12]
   \   00000158   000050E3           CMP      R0,#+0
   \   0000015C   2100000A           BEQ      ??_DrawBitmap_6
    160                if (BytesPerLine > _Buffersize) {
   \   00000160   180099E5           LDR      R0,[R9, #+24]
   \   00000164   070050E1           CMP      R0,R7
    161                  MaxBytes = _Buffersize;
   \   00000168   18008DB5           STRLT    R0,[SP, #+24]
    162                  xSize    = _Buffersize << 3;
   \   0000016C   80B1A0B1           LSLLT    R11,R0,#+3
    163                } else {
    164                  MaxBytes = BytesPerLine;
   \   00000170   18708DA5           STRGE    R7,[SP, #+24]
    165                }
    166                do {
    167                  i    = MaxBytes;
    168                  pSrc = (U8 *)pData;
    169                  pDst = _pBuffer;
   \                     ??_DrawBitmap_7:
   \   00000174   0C0099E5           LDR      R0,[R9, #+12]
   \   00000178   18109DE5           LDR      R1,[SP, #+24]
   \   0000017C   0820A0E1           MOV      R2,R8
   \   00000180   0030A0E1           MOV      R3,R0
    170                  //
    171                  // Invert pixel data of 1bpp bitmap
    172                  //
    173                  do {
    174                    *pDst++ = (*pSrc++) ^ 0xff;
   \                     ??_DrawBitmap_8:
   \   00000184   01C0D2E4           LDRB     R12,[R2], #+1
    175                  } while (--i);
   \   00000188   011051E2           SUBS     R1,R1,#+1
   \   0000018C   FFC02CE2           EOR      R12,R12,#0xFF
   \   00000190   01C0C3E4           STRB     R12,[R3], #+1
   \   00000194   FAFFFF1A           BNE      ??_DrawBitmap_8
    176                  //
    177                  // Draw one line of bitmap
    178                  //
    179                  pDevice->pDeviceAPI->pfDrawBitmap(pDevice, 
    180                                                    x0, y0++, 
    181                                                    xSize, 1, 
    182                                                    BitsPerPixel, BytesPerLine, _pBuffer, Diff, pTrans);
   \   00000198   5C109DE5           LDR      R1,[SP, #+92]
   \   0000019C   0C008DE5           STR      R0,[SP, #+12]
   \   000001A0   14108DE5           STR      R1,[SP, #+20]
   \   000001A4   58109DE5           LDR      R1,[SP, #+88]
   \   000001A8   0100A0E3           MOV      R0,#+1
   \   000001AC   10108DE5           STR      R1,[SP, #+16]
   \   000001B0   08708DE5           STR      R7,[SP, #+8]
   \   000001B4   04008DE5           STR      R0,[SP, #+4]
   \   000001B8   00008DE5           STR      R0,[SP, #+0]
   \   000001BC   0CC09AE5           LDR      R12,[R10, #+12]
   \   000001C0   0B30A0E1           MOV      R3,R11
   \   000001C4   0520A0E1           MOV      R2,R5
   \   000001C8   0410A0E1           MOV      R1,R4
   \   000001CC   0A00A0E1           MOV      R0,R10
   \   000001D0   04C09CE5           LDR      R12,[R12, #+4]
   \   000001D4   3CFF2FE1           BLX      R12
   \   000001D8   015085E2           ADD      R5,R5,#+1
    183                  //
    184                  // Increment data pointer
    185                  //
    186                  pData += BytesPerLine;
   \   000001DC   088087E0           ADD      R8,R7,R8
    187                } while (--ySize);
   \   000001E0   016056E2           SUBS     R6,R6,#+1
   \   000001E4   E2FFFF1A           BNE      ??_DrawBitmap_7
    188              }
    189              //
    190              // Reset alpha settings
    191              //
    192              _SwapColors();
    193              _SwapIndices();
   \                     ??_DrawBitmap_6:
   \   000001E8   ........           LDR      R12,??DataTable8
   \   000001EC   040099E5           LDR      R0,[R9, #+4]
   \   000001F0   081099E5           LDR      R1,[R9, #+8]
   \   000001F4   ........           LDR      R2,??DataTable8_3
   \   000001F8   00C09CE5           LDR      R12,[R12, #+0]
   \   000001FC   041089E5           STR      R1,[R9, #+4]
   \   00000200   080089E5           STR      R0,[R9, #+8]
   \   00000204   002092E5           LDR      R2,[R2, #+0]
   \   00000208   00E09CE5           LDR      LR,[R12, #+0]
   \   0000020C   003092E5           LDR      R3,[R2, #+0]
   \   00000210   00E082E5           STR      LR,[R2, #+0]
    194              _ManageAlpha();
   \   00000214   214CB0E1           LSRS     R4,R1,#+24
   \   00000218   00308CE5           STR      R3,[R12, #+0]
   \   0000021C   200CB001           LSRSEQ   R0,R0,#+24
   \   00000220   0600000A           BEQ      ??_DrawBitmap_9
   \   00000224   140099E5           LDR      R0,[R9, #+20]
   \   00000228   000050E3           CMP      R0,#+0
   \   0000022C   0A00001A           BNE      ??_DrawBitmap_10
   \   00000230   100099E5           LDR      R0,[R9, #+16]
   \   00000234   ........           BL       GUI_DEVICE_Link
   \   00000238   0100A0E3           MOV      R0,#+1
   \   0000023C   050000EA           B        ??_DrawBitmap_11
   \                     ??_DrawBitmap_9:
   \   00000240   140099E5           LDR      R0,[R9, #+20]
   \   00000244   010050E3           CMP      R0,#+1
   \   00000248   0300001A           BNE      ??_DrawBitmap_10
   \   0000024C   100099E5           LDR      R0,[R9, #+16]
   \   00000250   ........           BL       GUI_DEVICE_Unlink
   \   00000254   0000A0E3           MOV      R0,#+0
   \                     ??_DrawBitmap_11:
   \   00000258   140089E5           STR      R0,[R9, #+20]
   \                     ??_DrawBitmap_10:
   \   0000025C   1C0099E5           LDR      R0,[R9, #+28]
   \   00000260   000050E3           CMP      R0,#+0
   \   00000264   0400000A           BEQ      ??_DrawBitmap_12
   \   00000268   FF1064E2           RSB      R1,R4,#+255
   \   0000026C   900101E0           MUL      R1,R0,R1
   \   00000270   ........           LDR      R2,??DataTable8_4  ;; 0x80808081
   \   00000274   912280E0           UMULL    R2,R0,R1,R2
   \   00000278   A04384E0           ADD      R4,R4,R0, LSR #+7
   \                     ??_DrawBitmap_12:
   \   0000027C   200099E5           LDR      R0,[R9, #+32]
   \   00000280   000054E1           CMP      R4,R0
   \   00000284   0200000A           BEQ      ??_DrawBitmap_13
   \   00000288   FF0004E2           AND      R0,R4,#0xFF
   \   0000028C   ........           BL       GUI_SetAlpha
   \   00000290   204089E5           STR      R4,[R9, #+32]
    195              GUI_Context.DrawMode = LCD_DRAWMODE_NORMAL;
   \                     ??_DrawBitmap_13:
   \   00000294   ........           LDR      R0,??DataTable8_1
   \   00000298   0010A0E3           MOV      R1,#+0
   \   0000029C   1010C0E5           STRB     R1,[R0, #+16]
   \   000002A0   110000EA           B        ??_DrawBitmap_14
    196            } else {
    197              //
    198              // Draw bitmaps other than text by passing it to the next device
    199              //
    200              pDevice = pDevice->pNext;
   \                     ??_DrawBitmap_0:
   \   000002A4   20109DE5           LDR      R1,[SP, #+32]
   \   000002A8   00A091E5           LDR      R10,[R1, #+0]
    201              if (pDevice) {
   \   000002AC   00005AE3           CMP      R10,#+0
   \   000002B0   0D00000A           BEQ      ??_DrawBitmap_14
    202                pDevice->pDeviceAPI->pfDrawBitmap(pDevice, 
    203                                                  x0, y0, 
    204                                                  xSize, ySize, 
    205                                                  BitsPerPixel, BytesPerLine, pData, Diff, pTrans);
   \   000002B4   5C109DE5           LDR      R1,[SP, #+92]
   \   000002B8   0C808DE5           STR      R8,[SP, #+12]
   \   000002BC   14108DE5           STR      R1,[SP, #+20]
   \   000002C0   58109DE5           LDR      R1,[SP, #+88]
   \   000002C4   08708DE5           STR      R7,[SP, #+8]
   \   000002C8   10108DE5           STR      R1,[SP, #+16]
   \   000002CC   04008DE5           STR      R0,[SP, #+4]
   \   000002D0   00608DE5           STR      R6,[SP, #+0]
   \   000002D4   0CC09AE5           LDR      R12,[R10, #+12]
   \   000002D8   0520A0E1           MOV      R2,R5
   \   000002DC   0410A0E1           MOV      R1,R4
   \   000002E0   0A00A0E1           MOV      R0,R10
   \   000002E4   04C09CE5           LDR      R12,[R12, #+4]
   \   000002E8   3CFF2FE1           BLX      R12
    206              }
    207            }
    208          }
   \                     ??_DrawBitmap_14:
   \   000002EC   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   000002F0   F08FBDE8           POP      {R4-R11,PC}      ;; return
    209          
    210          /*********************************************************************
    211          *
    212          *       _DrawHLine
    213          *
    214          * Purpose:
    215          *   Routing to the next device...
    216          */

   \                                 In section .text, align 4, keep-with-next
    217          static void _DrawHLine(GUI_DEVICE * pDevice, int x0, int y,  int x1) {
    218            pDevice = pDevice->pNext;
   \                     _DrawHLine:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    219            if (pDevice) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0000001A           BNE      ??_DrawHLine_0
    220              pDevice->pDeviceAPI->pfDrawHLine(pDevice, x0, y,  x1);
   \   0000000C   1EFF2FE1           BX       LR
    221            }
   \                     ??_DrawHLine_0:
   \   00000010   00402DE9           PUSH     {LR}
   \   00000014   0CC090E5           LDR      R12,[R0, #+12]
   \   00000018   04D04DE2           SUB      SP,SP,#+4
   \   0000001C   08C09CE5           LDR      R12,[R12, #+8]
   \   00000020   3CFF2FE1           BLX      R12
    222          }
   \   00000024   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000028   0080BDE8           POP      {PC}             ;; return
    223          
    224          /*********************************************************************
    225          *
    226          *       _DrawVLine
    227          *
    228          * Purpose:
    229          *   Routing to the next device...
    230          */

   \                                 In section .text, align 4, keep-with-next
    231          static void _DrawVLine(GUI_DEVICE * pDevice, int x, int y0,  int y1) {
    232            pDevice = pDevice->pNext;
   \                     _DrawVLine:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    233            if (pDevice) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0000001A           BNE      ??_DrawVLine_0
    234              pDevice->pDeviceAPI->pfDrawVLine(pDevice, x, y0,  y1);
   \   0000000C   1EFF2FE1           BX       LR
    235            }
   \                     ??_DrawVLine_0:
   \   00000010   00402DE9           PUSH     {LR}
   \   00000014   0CC090E5           LDR      R12,[R0, #+12]
   \   00000018   04D04DE2           SUB      SP,SP,#+4
   \   0000001C   0CC09CE5           LDR      R12,[R12, #+12]
   \   00000020   3CFF2FE1           BLX      R12
    236          }
   \   00000024   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000028   0080BDE8           POP      {PC}             ;; return
    237          
    238          /*********************************************************************
    239          *
    240          *       _FillRect
    241          *
    242          * Purpose:
    243          *   Routing to the next device...
    244          */

   \                                 In section .text, align 4, keep-with-next
    245          static void _FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect:
   \   00000000   00402DE9           PUSH     {LR}
    246            pDevice = pDevice->pNext;
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   08C09DE5           LDR      R12,[SP, #+8]
    247            if (pDevice) {
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0300000A           BEQ      ??_FillRect_0
    248              pDevice->pDeviceAPI->pfFillRect(pDevice, x0, y0, x1, y1);
   \   00000018   00C08DE5           STR      R12,[SP, #+0]
   \   0000001C   0CC090E5           LDR      R12,[R0, #+12]
   \   00000020   10C09CE5           LDR      R12,[R12, #+16]
   \   00000024   3CFF2FE1           BLX      R12
    249            }
    250          }
   \                     ??_FillRect_0:
   \   00000028   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000002C   0080BDE8           POP      {PC}             ;; return
    251          
    252          /*********************************************************************
    253          *
    254          *       _GetPixelIndex
    255          *
    256          * Purpose:
    257          *   Routing to the next device...
    258          */

   \                                 In section .text, align 4, keep-with-next
    259          static unsigned _GetPixelIndex(GUI_DEVICE * pDevice, int x, int y)  {
    260            pDevice = pDevice->pNext;
   \                     _GetPixelIndex:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    261            if (pDevice) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0000001A           BNE      ??_GetPixelIndex_0
    262              return pDevice->pDeviceAPI->pfGetPixelIndex(pDevice, x, y);
   \   0000000C   1EFF2FE1           BX       LR
    263            }
   \                     ??_GetPixelIndex_0:
   \   00000010   00402DE9           PUSH     {LR}
   \   00000014   0C3090E5           LDR      R3,[R0, #+12]
   \   00000018   04D04DE2           SUB      SP,SP,#+4
   \   0000001C   143093E5           LDR      R3,[R3, #+20]
   \   00000020   33FF2FE1           BLX      R3
    264            return 0;
   \   00000024   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000028   0080BDE8           POP      {PC}             ;; return
    265          }
    266          
    267          /*********************************************************************
    268          *
    269          *       _SetPixelIndex
    270          *
    271          * Purpose:
    272          *   Routing to the next device...
    273          */

   \                                 In section .text, align 4, keep-with-next
    274          static void _SetPixelIndex(GUI_DEVICE * pDevice, int x, int y, int ColorIndex) {
    275            pDevice = pDevice->pNext;
   \                     _SetPixelIndex:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    276            if (pDevice) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0000001A           BNE      ??_SetPixelIndex_0
    277              pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x, y, ColorIndex);
   \   0000000C   1EFF2FE1           BX       LR
    278            }
   \                     ??_SetPixelIndex_0:
   \   00000010   00402DE9           PUSH     {LR}
   \   00000014   0CC090E5           LDR      R12,[R0, #+12]
   \   00000018   04D04DE2           SUB      SP,SP,#+4
   \   0000001C   18C09CE5           LDR      R12,[R12, #+24]
   \   00000020   3CFF2FE1           BLX      R12
    279          }
   \   00000024   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000028   0080BDE8           POP      {PC}             ;; return
    280          
    281          /*********************************************************************
    282          *
    283          *       _XorPixel
    284          *
    285          * Purpose:
    286          *   Routing to the next device...
    287          */

   \                                 In section .text, align 4, keep-with-next
    288          static void _XorPixel(GUI_DEVICE * pDevice, int x, int y) {
    289            pDevice = pDevice->pNext;
   \                     _XorPixel:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    290            if (pDevice) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0000001A           BNE      ??_XorPixel_0
    291              pDevice->pDeviceAPI->pfXorPixel(pDevice, x, y);
   \   0000000C   1EFF2FE1           BX       LR
    292            }
   \                     ??_XorPixel_0:
   \   00000010   00402DE9           PUSH     {LR}
   \   00000014   0C3090E5           LDR      R3,[R0, #+12]
   \   00000018   04D04DE2           SUB      SP,SP,#+4
   \   0000001C   1C3093E5           LDR      R3,[R3, #+28]
   \   00000020   33FF2FE1           BLX      R3
    293          }
   \   00000024   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000028   0080BDE8           POP      {PC}             ;; return
    294          
    295          /*********************************************************************
    296          *
    297          *       _GetDevData
    298          *
    299          * Purpose:
    300          *   Routing to the next device...
    301          */

   \                                 In section .text, align 4, keep-with-next
    302          static void * _GetDevData(GUI_DEVICE * pDevice, int Index) {
    303            pDevice = pDevice->pNext;
   \                     _GetDevData:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    304            if (pDevice) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0000001A           BNE      ??_GetDevData_0
    305              return pDevice->pDeviceAPI->pfGetDevData(pDevice, Index);
   \   0000000C   1EFF2FE1           BX       LR
    306            }
   \                     ??_GetDevData_0:
   \   00000010   00402DE9           PUSH     {LR}
   \   00000014   0C2090E5           LDR      R2,[R0, #+12]
   \   00000018   04D04DE2           SUB      SP,SP,#+4
   \   0000001C   2C2092E5           LDR      R2,[R2, #+44]
   \   00000020   32FF2FE1           BLX      R2
    307            return NULL;
   \   00000024   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000028   0080BDE8           POP      {PC}             ;; return
    308          }
    309          
    310          /*********************************************************************
    311          *
    312          *       _SetOrg
    313          *
    314          * Purpose:
    315          *   Routing to the next device...
    316          */

   \                                 In section .text, align 4, keep-with-next
    317          static void _SetOrg(GUI_DEVICE * pDevice, int x, int y) {
    318            pDevice = pDevice->pNext;
   \                     _SetOrg:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    319            if (pDevice) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0000001A           BNE      ??_SetOrg_0
    320              pDevice->pDeviceAPI->pfSetOrg(pDevice, x, y);
   \   0000000C   1EFF2FE1           BX       LR
    321            }
   \                     ??_SetOrg_0:
   \   00000010   00402DE9           PUSH     {LR}
   \   00000014   0C3090E5           LDR      R3,[R0, #+12]
   \   00000018   04D04DE2           SUB      SP,SP,#+4
   \   0000001C   203093E5           LDR      R3,[R3, #+32]
   \   00000020   33FF2FE1           BLX      R3
    322          }
   \   00000024   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000028   0080BDE8           POP      {PC}             ;; return
    323          
    324          /*********************************************************************
    325          *
    326          *       _GetDevFunc
    327          *
    328          * Purpose:
    329          *   Routing to the next device...
    330          */

   \                                 In section .text, align 4, keep-with-next
    331          static void (* _GetDevFunc(GUI_DEVICE ** ppDevice, int Index))(void) {
   \                     _GetDevFunc:
   \   00000000   00402DE9           PUSH     {LR}
    332            *ppDevice = (*ppDevice)->pNext;
   \   00000004   002090E5           LDR      R2,[R0, #+0]
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   002092E5           LDR      R2,[R2, #+0]
   \   00000010   002080E5           STR      R2,[R0, #+0]
    333            if (*ppDevice) {
   \   00000014   000052E3           CMP      R2,#+0
   \   00000018   0300000A           BEQ      ??_GetDevFunc_0
    334              return (*ppDevice)->pDeviceAPI->pfGetDevFunc(ppDevice, Index);
   \   0000001C   0C2092E5           LDR      R2,[R2, #+12]
   \   00000020   242092E5           LDR      R2,[R2, #+36]
   \   00000024   32FF2FE1           BLX      R2
   \   00000028   000000EA           B        ??_GetDevFunc_1
    335            }
    336            return NULL;
   \                     ??_GetDevFunc_0:
   \   0000002C   0000A0E3           MOV      R0,#+0
   \                     ??_GetDevFunc_1:
   \   00000030   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000034   0080BDE8           POP      {PC}             ;; return
    337          }
    338          
    339          /*********************************************************************
    340          *
    341          *       _GetDevProp
    342          *
    343          * Purpose:
    344          *   Routing to the next device...
    345          */

   \                                 In section .text, align 4, keep-with-next
    346          static I32 _GetDevProp(GUI_DEVICE * pDevice, int Index) {
    347            pDevice = pDevice->pNext;
   \                     _GetDevProp:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    348            if (pDevice) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0000001A           BNE      ??_GetDevProp_0
    349              return pDevice->pDeviceAPI->pfGetDevProp(pDevice, Index);
   \   0000000C   1EFF2FE1           BX       LR
    350            }
   \                     ??_GetDevProp_0:
   \   00000010   00402DE9           PUSH     {LR}
   \   00000014   0C2090E5           LDR      R2,[R0, #+12]
   \   00000018   04D04DE2           SUB      SP,SP,#+4
   \   0000001C   282092E5           LDR      R2,[R2, #+40]
   \   00000020   32FF2FE1           BLX      R2
    351            return 0;
   \   00000024   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000028   0080BDE8           POP      {PC}             ;; return
    352          }
    353          
    354          /*********************************************************************
    355          *
    356          *       _GetRect
    357          *
    358          * Purpose:
    359          *   Routing to the next device...
    360          */

   \                                 In section .text, align 4, keep-with-next
    361          static void _GetRect(GUI_DEVICE * pDevice, LCD_RECT * pRect) {
    362            pDevice = pDevice->pNext;
   \                     _GetRect:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    363            if (pDevice) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0000001A           BNE      ??_GetRect_0
    364              pDevice->pDeviceAPI->pfGetRect(pDevice, pRect);
   \   0000000C   1EFF2FE1           BX       LR
    365            }
   \                     ??_GetRect_0:
   \   00000010   00402DE9           PUSH     {LR}
   \   00000014   0C2090E5           LDR      R2,[R0, #+12]
   \   00000018   04D04DE2           SUB      SP,SP,#+4
   \   0000001C   302092E5           LDR      R2,[R2, #+48]
   \   00000020   32FF2FE1           BLX      R2
    366          }
   \   00000024   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000028   0080BDE8           POP      {PC}             ;; return
    367          
    368          /*********************************************************************
    369          *
    370          *       Static data, API table GUI_DEVICE_API _ALPHA_Device_API
    371          *
    372          **********************************************************************
    373          */

   \                                 In section .text, align 4, keep-with-next
    374          static const GUI_DEVICE_API _ALPHA_Device_API = {
   \                     _ALPHA_Device_API:
   \   00000000                      ; Initializer data, 52 bytes
   \   00000000   06000000....       DC32 6, _DrawBitmap, _DrawHLine, _DrawVLine, _FillRect, _GetPixelIndex, _SetPixelIndex, _XorPixel, _SetOrg, _GetDevFunc
   \              ............
   \              ............
   \              ............
   \              ............
   \              ............
   \              ........    
   \   00000028   ............       DC32 _GetDevProp, _GetDevData, _GetRect
   \              ............
    375            //
    376            // Data
    377            //
    378            DEVICE_CLASS_AUTOALPHA,
    379            //
    380            // Drawing functions
    381            //
    382            _DrawBitmap   ,
    383            _DrawHLine    ,
    384            _DrawVLine    ,
    385            _FillRect     ,
    386            _GetPixelIndex,
    387            _SetPixelIndex,
    388            _XorPixel     ,
    389            //
    390            // Set origin
    391            //
    392            _SetOrg       ,
    393            //
    394            // Request information
    395            //
    396            _GetDevFunc   ,
    397            _GetDevProp   ,
    398            _GetDevData,
    399            _GetRect      ,
    400          };
    401          
    402          /*********************************************************************
    403          *
    404          *       _SetBkColor
    405          */

   \                                 In section .text, align 4, keep-with-next
    406          static void _SetBkColor(GUI_COLOR Color) {
   \                     _SetBkColor:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    407            //
    408            // Get the right color
    409            //
    410            if (GUI_Context.DrawMode & LCD_DRAWMODE_REV) {
   \   00000008   ........           LDR      R0,??DataTable8_1
   \   0000000C   ........           LDR      R5,??DataTable8_2
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   040010E3           TST      R0,#0x4
    411              _Color = Color;
   \   00000018   04408515           STRNE    R4,[R5, #+4]
    412            } else {
    413              _BkColor = Color;
    414            }
    415            //
    416            // Manage alpha blending in dependence of the current color(s)
    417            //
    418            _ManageAlpha();
   \   0000001C   040095E5           LDR      R0,[R5, #+4]
   \   00000020   08408505           STREQ    R4,[R5, #+8]
   \   00000024   206CB0E1           LSRS     R6,R0,#+24
   \   00000028   08009505           LDREQ    R0,[R5, #+8]
   \   0000002C   200CB001           LSRSEQ   R0,R0,#+24
   \   00000030   0600000A           BEQ      ??_SetBkColor_0
   \   00000034   140095E5           LDR      R0,[R5, #+20]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0A00001A           BNE      ??_SetBkColor_1
   \   00000040   100095E5           LDR      R0,[R5, #+16]
   \   00000044   ........           BL       GUI_DEVICE_Link
   \   00000048   0100A0E3           MOV      R0,#+1
   \   0000004C   050000EA           B        ??_SetBkColor_2
   \                     ??_SetBkColor_0:
   \   00000050   140095E5           LDR      R0,[R5, #+20]
   \   00000054   010050E3           CMP      R0,#+1
   \   00000058   0300001A           BNE      ??_SetBkColor_1
   \   0000005C   100095E5           LDR      R0,[R5, #+16]
   \   00000060   ........           BL       GUI_DEVICE_Unlink
   \   00000064   0000A0E3           MOV      R0,#+0
   \                     ??_SetBkColor_2:
   \   00000068   140085E5           STR      R0,[R5, #+20]
   \                     ??_SetBkColor_1:
   \   0000006C   1C0095E5           LDR      R0,[R5, #+28]
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   0400000A           BEQ      ??_SetBkColor_3
   \   00000078   FF1066E2           RSB      R1,R6,#+255
   \   0000007C   900101E0           MUL      R1,R0,R1
   \   00000080   ........           LDR      R2,??DataTable8_4  ;; 0x80808081
   \   00000084   912280E0           UMULL    R2,R0,R1,R2
   \   00000088   A06386E0           ADD      R6,R6,R0, LSR #+7
   \                     ??_SetBkColor_3:
   \   0000008C   200095E5           LDR      R0,[R5, #+32]
   \   00000090   000056E1           CMP      R6,R0
   \   00000094   0200000A           BEQ      ??_SetBkColor_4
   \   00000098   FF0006E2           AND      R0,R6,#0xFF
   \   0000009C   ........           BL       GUI_SetAlpha
   \   000000A0   206085E5           STR      R6,[R5, #+32]
    419            //
    420            // Call the original function
    421            //
    422            _pSetColorAPI->pfSetBkColor(Color & 0xFFFFFF);
   \                     ??_SetBkColor_4:
   \   000000A4   0404A0E1           LSL      R0,R4,#+8
   \   000000A8   001095E5           LDR      R1,[R5, #+0]
   \   000000AC   7040BDE8           POP      {R4-R6,LR}
   \   000000B0   2004A0E1           LSR      R0,R0,#+8
   \   000000B4   041091E5           LDR      R1,[R1, #+4]
   \   000000B8   11FF2FE1           BX       R1               ;; tailcall
    423          }
    424          
    425          /*********************************************************************
    426          *
    427          *       _SetColor
    428          */

   \                                 In section .text, align 4, keep-with-next
    429          static void _SetColor(GUI_COLOR Color) {
   \                     _SetColor:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    430            //
    431            // Get the right color
    432            //
    433            if (GUI_Context.DrawMode & LCD_DRAWMODE_REV) {
   \   00000008   ........           LDR      R0,??DataTable8_1
   \   0000000C   ........           LDR      R5,??DataTable8_2
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   040010E3           TST      R0,#0x4
    434              _BkColor = Color;
    435            } else {
    436              _Color = Color;
   \   00000018   04408505           STREQ    R4,[R5, #+4]
    437            }
    438            //
    439            // Manage alpha blending in dependence of the current color(s)
    440            //
    441            _ManageAlpha();
   \   0000001C   040095E5           LDR      R0,[R5, #+4]
   \   00000020   08408515           STRNE    R4,[R5, #+8]
   \   00000024   206CB0E1           LSRS     R6,R0,#+24
   \   00000028   08009505           LDREQ    R0,[R5, #+8]
   \   0000002C   200CB001           LSRSEQ   R0,R0,#+24
   \   00000030   0600000A           BEQ      ??_SetColor_0
   \   00000034   140095E5           LDR      R0,[R5, #+20]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0A00001A           BNE      ??_SetColor_1
   \   00000040   100095E5           LDR      R0,[R5, #+16]
   \   00000044   ........           BL       GUI_DEVICE_Link
   \   00000048   0100A0E3           MOV      R0,#+1
   \   0000004C   050000EA           B        ??_SetColor_2
   \                     ??_SetColor_0:
   \   00000050   140095E5           LDR      R0,[R5, #+20]
   \   00000054   010050E3           CMP      R0,#+1
   \   00000058   0300001A           BNE      ??_SetColor_1
   \   0000005C   100095E5           LDR      R0,[R5, #+16]
   \   00000060   ........           BL       GUI_DEVICE_Unlink
   \   00000064   0000A0E3           MOV      R0,#+0
   \                     ??_SetColor_2:
   \   00000068   140085E5           STR      R0,[R5, #+20]
   \                     ??_SetColor_1:
   \   0000006C   1C0095E5           LDR      R0,[R5, #+28]
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   0400000A           BEQ      ??_SetColor_3
   \   00000078   FF1066E2           RSB      R1,R6,#+255
   \   0000007C   900101E0           MUL      R1,R0,R1
   \   00000080   ........           LDR      R2,??DataTable8_4  ;; 0x80808081
   \   00000084   912280E0           UMULL    R2,R0,R1,R2
   \   00000088   A06386E0           ADD      R6,R6,R0, LSR #+7
   \                     ??_SetColor_3:
   \   0000008C   200095E5           LDR      R0,[R5, #+32]
   \   00000090   000056E1           CMP      R6,R0
   \   00000094   0200000A           BEQ      ??_SetColor_4
   \   00000098   FF0006E2           AND      R0,R6,#0xFF
   \   0000009C   ........           BL       GUI_SetAlpha
   \   000000A0   206085E5           STR      R6,[R5, #+32]
    442            //
    443            // Call the original function
    444            //
    445            _pSetColorAPI->pfSetColor(Color & 0xFFFFFF);
   \                     ??_SetColor_4:
   \   000000A4   0404A0E1           LSL      R0,R4,#+8
   \   000000A8   001095E5           LDR      R1,[R5, #+0]
   \   000000AC   7040BDE8           POP      {R4-R6,LR}
   \   000000B0   2004A0E1           LSR      R0,R0,#+8
   \   000000B4   001091E5           LDR      R1,[R1, #+0]
   \   000000B8   11FF2FE1           BX       R1               ;; tailcall
    446          }
    447          
    448          /*********************************************************************
    449          *
    450          *       _SetDrawMode
    451          */

   \                                 In section .text, align 4, keep-with-next
    452          static LCD_DRAWMODE _SetDrawMode(LCD_DRAWMODE dm) {
   \                     _SetDrawMode:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    453            if ((GUI_Context.DrawMode ^ dm) & LCD_DRAWMODE_REV) {
   \   00000008   ........           LDR      R0,??DataTable8_1
   \   0000000C   ........           LDR      R5,??DataTable8_2
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   000024E0           EOR      R0,R4,R0
   \   00000018   040010E3           TST      R0,#0x4
   \   0000001C   0300000A           BEQ      ??_SetDrawMode_0
    454              _SwapColors();
   \   00000020   040095E5           LDR      R0,[R5, #+4]
   \   00000024   081095E5           LDR      R1,[R5, #+8]
   \   00000028   080085E5           STR      R0,[R5, #+8]
   \   0000002C   041085E5           STR      R1,[R5, #+4]
    455            }
    456            //
    457            // Manage alpha blending in dependence of the current color(s)
    458            //
    459            _ManageAlpha();
   \                     ??_SetDrawMode_0:
   \   00000030   040095E5           LDR      R0,[R5, #+4]
   \   00000034   206CB0E1           LSRS     R6,R0,#+24
   \   00000038   08009505           LDREQ    R0,[R5, #+8]
   \   0000003C   200CB001           LSRSEQ   R0,R0,#+24
   \   00000040   0600000A           BEQ      ??_SetDrawMode_1
   \   00000044   140095E5           LDR      R0,[R5, #+20]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0A00001A           BNE      ??_SetDrawMode_2
   \   00000050   100095E5           LDR      R0,[R5, #+16]
   \   00000054   ........           BL       GUI_DEVICE_Link
   \   00000058   0100A0E3           MOV      R0,#+1
   \   0000005C   050000EA           B        ??_SetDrawMode_3
   \                     ??_SetDrawMode_1:
   \   00000060   140095E5           LDR      R0,[R5, #+20]
   \   00000064   010050E3           CMP      R0,#+1
   \   00000068   0300001A           BNE      ??_SetDrawMode_2
   \   0000006C   100095E5           LDR      R0,[R5, #+16]
   \   00000070   ........           BL       GUI_DEVICE_Unlink
   \   00000074   0000A0E3           MOV      R0,#+0
   \                     ??_SetDrawMode_3:
   \   00000078   140085E5           STR      R0,[R5, #+20]
   \                     ??_SetDrawMode_2:
   \   0000007C   1C0095E5           LDR      R0,[R5, #+28]
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   0400000A           BEQ      ??_SetDrawMode_4
   \   00000088   FF1066E2           RSB      R1,R6,#+255
   \   0000008C   900101E0           MUL      R1,R0,R1
   \   00000090   ........           LDR      R2,??DataTable8_4  ;; 0x80808081
   \   00000094   912280E0           UMULL    R2,R0,R1,R2
   \   00000098   A06386E0           ADD      R6,R6,R0, LSR #+7
   \                     ??_SetDrawMode_4:
   \   0000009C   200095E5           LDR      R0,[R5, #+32]
   \   000000A0   000056E1           CMP      R6,R0
   \   000000A4   0200000A           BEQ      ??_SetDrawMode_5
   \   000000A8   FF0006E2           AND      R0,R6,#0xFF
   \   000000AC   ........           BL       GUI_SetAlpha
   \   000000B0   206085E5           STR      R6,[R5, #+32]
    460            //
    461            // Call the original function
    462            //
    463            return _pSetColorAPI->pfSetDrawMode(dm);
   \                     ??_SetDrawMode_5:
   \   000000B4   0400A0E1           MOV      R0,R4
   \   000000B8   001095E5           LDR      R1,[R5, #+0]
   \   000000BC   7040BDE8           POP      {R4-R6,LR}
   \   000000C0   081091E5           LDR      R1,[R1, #+8]
   \   000000C4   11FF2FE1           BX       R1               ;; tailcall
    464          }
    465          
    466          /*********************************************************************
    467          *
    468          *       Static data, API table _SetColorAPI
    469          *
    470          **********************************************************************
    471          */

   \                                 In section .text, align 4, keep-with-next
    472          static const LCD_SET_COLOR_API _SetColorAPI = {
   \                     _SetColorAPI:
   \   00000000                      ; Initializer data, 12 bytes
   \   00000000   ............       DC32 _SetColor, _SetBkColor, _SetDrawMode
   \              ............
    473            _SetColor,
    474            _SetBkColor,
    475            _SetDrawMode,
    476          };
    477          
    478          /*********************************************************************
    479          *
    480          *       Public code
    481          *
    482          **********************************************************************
    483          */
    484          /*********************************************************************
    485          *
    486          *       GUI_SetUserAlpha
    487          */

   \                                 In section .text, align 4, keep-with-next
    488          U32 GUI_SetUserAlpha(GUI_ALPHA_STATE * pAlphaState, U32 UserAlpha) {
    489            pAlphaState->UserAlpha = _UserAlpha;
   \                     GUI_SetUserAlpha:
   \   00000000   ........           LDR      R2,??DataTable8_2
   \   00000004   1C3092E5           LDR      R3,[R2, #+28]
   \   00000008   003080E5           STR      R3,[R0, #+0]
    490            _UserAlpha = UserAlpha;
   \   0000000C   1C1082E5           STR      R1,[R2, #+28]
    491            return pAlphaState->UserAlpha;
   \   00000010   000090E5           LDR      R0,[R0, #+0]
   \   00000014   1EFF2FE1           BX       LR               ;; return
    492          }
    493          
    494          /*********************************************************************
    495          *
    496          *       GUI_RestoreUserAlpha
    497          */

   \                                 In section .text, align 4, keep-with-next
    498          U32 GUI_RestoreUserAlpha(GUI_ALPHA_STATE * pAlphaState) {
    499            U32 OldUserAlpha;
    500          
    501            OldUserAlpha = _UserAlpha;
   \                     GUI_RestoreUserAlpha:
   \   00000000   ........           LDR      R2,??DataTable8_2
    502            _UserAlpha = pAlphaState->UserAlpha;
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   1C1092E5           LDR      R1,[R2, #+28]
   \   0000000C   1C0082E5           STR      R0,[R2, #+28]
    503            return OldUserAlpha;
   \   00000010   0100A0E1           MOV      R0,R1
   \   00000014   1EFF2FE1           BX       LR               ;; return
    504          }
    505          
    506          /*********************************************************************
    507          *
    508          *       GUI_EnableAlpha
    509          */

   \                                 In section .text, align 4, keep-with-next
    510          unsigned GUI_EnableAlpha(unsigned OnOff) {
   \                     GUI_EnableAlpha:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    511            unsigned OldState;
    512            unsigned vxSizeMax;
    513          
    514            if (_pDevice == NULL) {
   \   00000004   ........           LDR      R4,??DataTable8_2
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   100094E5           LDR      R0,[R4, #+16]
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0F00001A           BNE      ??GUI_EnableAlpha_0
    515              //
    516              // Make sure that buffers are allocated at the beginning
    517              //
    518              GUI_SetAlpha(1);
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   ........           BL       GUI_SetAlpha
    519              GUI_SetAlpha(0);
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   ........           BL       GUI_SetAlpha
    520              //
    521              // Create device
    522              //
    523              _pDevice = GUI_DEVICE_Create(&_ALPHA_Device_API, NULL, 0, 0);
   \   0000002C   0030A0E3           MOV      R3,#+0
   \   00000030   0020A0E3           MOV      R2,#+0
   \   00000034   0010A0E3           MOV      R1,#+0
   \   00000038   ........           ADR      R0,_ALPHA_Device_API
   \   0000003C   ........           BL       GUI_DEVICE_Create
   \   00000040   100084E5           STR      R0,[R4, #+16]
    524              //
    525              // Get buffer for at least one line of bitmap data
    526              //
    527              vxSizeMax   = LCD_GetVXSizeMax();
    528              _Buffersize = (vxSizeMax + 7) >> 3;
   \   00000044   ........           BL       LCD_GetVXSizeMax
   \   00000048   070080E2           ADD      R0,R0,#+7
   \   0000004C   A001A0E1           LSR      R0,R0,#+3
   \   00000050   180084E5           STR      R0,[R4, #+24]
    529              //
    530              // Allocate buffer for 1bpp bitmaps
    531              //
    532              _pBuffer = (U8 *)GUI_ALLOC_GetFixedBlock(_Buffersize);
   \   00000054   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000058   0C0084E5           STR      R0,[R4, #+12]
    533            }
    534            if (OnOff) {
   \                     ??GUI_EnableAlpha_0:
   \   0000005C   001094E5           LDR      R1,[R4, #+0]
   \   00000060   000055E3           CMP      R5,#+0
   \   00000064   0A00000A           BEQ      ??GUI_EnableAlpha_1
    535              if (_pSetColorAPI == NULL) {
   \   00000068   000051E3           CMP      R1,#+0
   \   0000006C   0600001A           BNE      ??GUI_EnableAlpha_2
    536                OldState = 0;
    537                _pSetColorAPI     = LCD__pSetColorAPI;
   \   00000070   ........           LDR      R1,??DataTable8_5
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   002091E5           LDR      R2,[R1, #+0]
   \   0000007C   002084E5           STR      R2,[R4, #+0]
    538                LCD__pSetColorAPI = &_SetColorAPI;
   \   00000080   ........           ADR      R2,_SetColorAPI
   \   00000084   002081E5           STR      R2,[R1, #+0]
   \   00000088   0A0000EA           B        ??GUI_EnableAlpha_3
    539              } else {
    540                OldState = 1;
   \                     ??GUI_EnableAlpha_2:
   \   0000008C   0100A0E3           MOV      R0,#+1
   \   00000090   080000EA           B        ??GUI_EnableAlpha_3
    541              }
    542            } else {
    543              if (_pSetColorAPI != NULL) {
   \                     ??GUI_EnableAlpha_1:
   \   00000094   0020A0E3           MOV      R2,#+0
   \   00000098   000051E3           CMP      R1,#+0
   \   0000009C   0400000A           BEQ      ??GUI_EnableAlpha_4
    544                OldState = 1;
    545                LCD__pSetColorAPI = _pSetColorAPI;
   \   000000A0   ........           LDR      R3,??DataTable8_5
   \   000000A4   0100A0E3           MOV      R0,#+1
   \   000000A8   001083E5           STR      R1,[R3, #+0]
    546                _pSetColorAPI     = NULL;
   \   000000AC   002084E5           STR      R2,[R4, #+0]
   \   000000B0   000000EA           B        ??GUI_EnableAlpha_3
    547              } else {
    548                OldState = 0;
   \                     ??GUI_EnableAlpha_4:
   \   000000B4   0000A0E3           MOV      R0,#+0
    549              }
    550            }
    551            return OldState;
   \                     ??GUI_EnableAlpha_3:
   \   000000B8   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000BC   3080BDE8           POP      {R4,R5,PC}       ;; return
    552          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     LCD_pBkColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   ........           DC32     _pSetColorAPI

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   81808080           DC32     0x80808081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   ........           DC32     LCD__pSetColorAPI
    553          
    554          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function             .cstack
     --------             -------
     GUI_EnableAlpha          16
     GUI_RestoreUserAlpha      0
     GUI_SetUserAlpha          0
     _DrawBitmap              72
     _DrawHLine                8
     _DrawVLine                8
     _FillRect                 8
     _GetDevData               8
     _GetDevFunc               8
     _GetDevProp               8
     _GetPixelIndex            8
     _GetRect                  8
     _SetBkColor              16
     _SetColor                16
     _SetDrawMode             16
     _SetOrg                   8
     _SetPixelIndex            8
     _XorPixel                 8


   Section sizes:

     Function/Label       Bytes
     --------------       -----
     _pSetColorAPI          36
     _Color
     _BkColor
     _pBuffer
     _pDevice
     _Linked
     _Buffersize
     _UserAlpha
     AlphaOld
     _DrawBitmap           756
     _DrawHLine             44
     _DrawVLine             44
     _FillRect              48
     _GetPixelIndex         44
     _SetPixelIndex         44
     _XorPixel              44
     _GetDevData            44
     _SetOrg                44
     _GetDevFunc            56
     _GetDevProp            44
     _GetRect               44
     _ALPHA_Device_API      52
     _SetBkColor           188
     _SetColor             188
     _SetDrawMode          200
     _SetColorAPI           12
     GUI_SetUserAlpha       24
     GUI_RestoreUserAlpha   24
     GUI_EnableAlpha       192
     ??DataTable8            4
     ??DataTable8_1          4
     ??DataTable8_2          4
     ??DataTable8_3          4
     ??DataTable8_4          4
     ??DataTable8_5          4

 
    36 bytes in section .bss
 2 160 bytes in section .text
 
 2 160 bytes of CODE memory
    36 bytes of DATA memory

Errors: none
Warnings: none
