###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:10:05 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_32.c                     #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_32.c -D DEBUG=1 -D       #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUIDRV_Lin_32.lst          #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUIDRV_Lin_32.o             #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDRV_Lin_32.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDRV_Lin_32.c
     19          Purpose     : Driver for accessing linear video memory
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stddef.h>
     24          
     25          #include "LCD_Private.h"
     26          #include "GUI_Private.h"
     27          #include "LCD_SIM.h"
     28          #include "LCD_ConfDefaults.h"
     29          
     30          #include "GUIDRV_Lin.h"
     31          
     32          #if (!defined(WIN32) | defined(LCD_SIMCONTROLLER))
     33          
     34          /*********************************************************************
     35          *
     36          *       Defines
     37          *
     38          **********************************************************************
     39          */
     40          #ifdef WIN32
     41            //
     42            // Simulation prototypes
     43            //
     44            U16  SIM_Lin_ReadMem16  (unsigned int Off);
     45            U32  SIM_Lin_ReadMem32  (unsigned int Off);
     46            U32  SIM_Lin_ReadMem32p (U32 * p);
     47            void SIM_Lin_WriteMem16 (unsigned int Off, U16 Data);
     48            void SIM_Lin_WriteMem32 (unsigned int Off, U32 Data);
     49            void SIM_Lin_WriteMem16p(U16 * p, U16 Data);
     50            void SIM_Lin_WriteMem32p(U32 * p, U32 Data);
     51            void SIM_Lin_memcpy     (void * pDst, const void * pSrc, int Len);
     52            void SIM_Lin_SetVRAMAddr(int LayerIndex, void * pVRAM);
     53            void SIM_Lin_SetVRAMSize(int LayerIndex, int xSize, int ySize);
     54            //
     55            // Access macro definition for internal simulation
     56            //
     57            #define LCD_READ_MEM16(VRAMAddr, Off)        SIM_Lin_ReadMem16(Off)
     58            #define LCD_READ_MEM32(VRAMAddr, Off)        SIM_Lin_ReadMem32(Off)
     59            #define LCD_READ_MEM32P(p)                   SIM_Lin_ReadMem32p(p)
     60            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) SIM_Lin_WriteMem16(Off, Data)
     61            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) SIM_Lin_WriteMem32(Off, Data)
     62            #define LCD_WRITE_MEM16P(p, Data)            SIM_Lin_WriteMem16p(p, Data)
     63            #define LCD_WRITE_MEM32P(p, Data)            SIM_Lin_WriteMem32p(p, Data)
     64            #undef  GUI_MEMCPY
     65            #define GUI_MEMCPY(pDst, pSrc, Len) SIM_Lin_memcpy(pDst, pSrc, Len)
     66          #else
     67            //
     68            // Access macro definition for hardware
     69            //
     70            #define LCD_READ_MEM16(VRAMAddr, Off)        (*((U16 *)VRAMAddr + (U32)Off))
     71            #define LCD_READ_MEM32(VRAMAddr, Off)        (*((U32 *)VRAMAddr + (U32)Off))
     72            #define LCD_READ_MEM32P(p)                   (*((U32 *)p))
     73            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) *((U16 *)VRAMAddr + (U32)Off) = Data
     74            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) *((U32 *)VRAMAddr + (U32)Off) = Data
     75            #define LCD_WRITE_MEM16P(p, Data)            *((U16 *)p) = Data
     76            #define LCD_WRITE_MEM32P(p, Data)            *((U32 *)p) = Data
     77          #endif
     78          
     79          #define WRITE_MEM16(VRAMAddr, Off, Data) LCD_WRITE_MEM16(VRAMAddr, Off, Data)
     80          #define WRITE_MEM32(VRAMAddr, Off, Data) LCD_WRITE_MEM32(VRAMAddr, Off, Data)
     81          #define READ_MEM16(VRAMAddr, Off)        LCD_READ_MEM16(VRAMAddr, Off)
     82          #define READ_MEM32(VRAMAddr, Off)        LCD_READ_MEM32(VRAMAddr, Off)
     83          #define READ_MEM32P(p)                   LCD_READ_MEM32P(p)
     84          #define WRITE_MEM16P(p, Data)            LCD_WRITE_MEM16P(p, Data)
     85          #define WRITE_MEM32P(p, Data)            LCD_WRITE_MEM32P(p, Data)
     86          
     87          #define OFF2PTR16(VRAMAddr, Off)     (U16 *)((U8 *)VRAMAddr + (Off << 1))
     88          #define OFF2PTR32(VRAMAddr, Off)     (U32 *)((U8 *)VRAMAddr + (Off << 2))
     89          
     90          #define XY2OFF16(vxSizePhys, x, y)    ((U32)y * (vxSizePhys << 1) + ((U32)x << 1))
     91          #define XY2OFF32(vxSizePhys, x, y)    ((U32)y *  vxSizePhys       +       x      )
     92          
     93          /*********************************************************************
     94          *
     95          *       Types
     96          *
     97          **********************************************************************
     98          */
     99          typedef struct {
    100            U32 VRAMAddr;
    101            int xSize, ySize;
    102            int vxSize, vySize;
    103            int vxSizePhys;
    104            int xPos, yPos;
    105            int Alpha;
    106            int IsVisible;
    107            void (* pfFillRect)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex);
    108          } DRIVER_CONTEXT;
    109          
    110          /*********************************************************************
    111          *
    112          *       Static functions
    113          *
    114          **********************************************************************
    115          */
    116          /*********************************************************************
    117          *
    118          *       _SetPixelIndex
    119          *
    120          * Purpose:
    121          *   Sets the index of the given pixel. The upper layers
    122          *   calling this routine make sure that the coordinates are in range, so
    123          *   that no check on the parameters needs to be performed.
    124          */

   \                                 In section .text, align 4, keep-with-next
    125          static void _SetPixelIndex(GUI_DEVICE * pDevice, int x, int y, int PixelIndex) {
    126            DRIVER_CONTEXT * pContext;
    127            U32 Off;
    128          
    129            //
    130            // Write into hardware
    131            //
    132            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _SetPixelIndex:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    133            Off      = XY2OFF32(pContext->vxSizePhys, x, y);
    134            WRITE_MEM32(pContext->VRAMAddr, Off, PixelIndex);
   \   00000004   14C090E5           LDR      R12,[R0, #+20]
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   9C1221E0           MLA      R1,R12,R2,R1
   \   00000010   013180E7           STR      R3,[R0, +R1, LSL #+2]
    135          }
   \   00000014   1EFF2FE1           BX       LR               ;; return
    136          
    137          /*********************************************************************
    138          *
    139          *       _GetPixelIndex
    140          *
    141          * Purpose:
    142          *   Returns the index of the given pixel. The upper layers
    143          *   calling this routine make sure that the coordinates are in range, so
    144          *   that no check on the parameters needs to be performed.
    145          */

   \                                 In section .text, align 4, keep-with-next
    146          static unsigned int _GetPixelIndex(GUI_DEVICE * pDevice, int x, int y) {
    147            DRIVER_CONTEXT * pContext;
    148            U32 Off;
    149            LCD_PIXELINDEX PixelIndex;
    150          
    151            //
    152            // Read from hardware
    153            //
    154            pContext   = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetPixelIndex:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    155            Off        = XY2OFF32(pContext->vxSizePhys, x, y);
    156            PixelIndex = READ_MEM32(pContext->VRAMAddr, Off);
    157            return PixelIndex;
   \   00000004   143090E5           LDR      R3,[R0, #+20]
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   931221E0           MLA      R1,R3,R2,R1
   \   00000010   010190E7           LDR      R0,[R0, +R1, LSL #+2]
   \   00000014   1EFF2FE1           BX       LR               ;; return
    158          }
    159          
    160          /*********************************************************************
    161          *
    162          *       _XorPixel
    163          */

   \                                 In section .text, align 4, keep-with-next
    164          static void _XorPixel(GUI_DEVICE * pDevice, int x, int y) {
   \                     _XorPixel:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0060A0E1           MOV      R6,R0
    165            LCD_PIXELINDEX PixelIndex;
    166            LCD_PIXELINDEX IndexMask;
    167          
    168            PixelIndex = _GetPixelIndex(pDevice, x, y);
   \   00000008   080096E5           LDR      R0,[R6, #+8]
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   141090E5           LDR      R1,[R0, #+20]
   \   00000014   0250A0E1           MOV      R5,R2
   \   00000018   914522E0           MLA      R2,R1,R5,R4
   \   0000001C   000090E5           LDR      R0,[R0, #+0]
   \   00000020   04D04DE2           SUB      SP,SP,#+4
   \   00000024   027190E7           LDR      R7,[R0, +R2, LSL #+2]
    169            IndexMask  = pDevice->pColorConvAPI->pfGetIndexMask();
   \   00000028   100096E5           LDR      R0,[R6, #+16]
   \   0000002C   080090E5           LDR      R0,[R0, #+8]
   \   00000030   30FF2FE1           BLX      R0
    170            _SetPixelIndex(pDevice, x, y, PixelIndex ^ IndexMask);
   \   00000034   081096E5           LDR      R1,[R6, #+8]
   \   00000038   070020E0           EOR      R0,R0,R7
   \   0000003C   142091E5           LDR      R2,[R1, #+20]
   \   00000040   001091E5           LDR      R1,[R1, #+0]
   \   00000044   924523E0           MLA      R3,R2,R5,R4
    171          }
   \   00000048   04D08DE2           ADD      SP,SP,#+4
   \   0000004C   030181E7           STR      R0,[R1, +R3, LSL #+2]
   \   00000050   F080BDE8           POP      {R4-R7,PC}       ;; return
    172          
    173          /*********************************************************************
    174          *
    175          *       _DrawHLine
    176          */

   \                                 In section .text, align 4, keep-with-next
    177          static void _DrawHLine  (GUI_DEVICE * pDevice, int x0, int y,  int x1) {
   \                     _DrawHLine:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0070A0E1           MOV      R7,R0
    178            DRIVER_CONTEXT * pContext;
    179            register LCD_PIXELINDEX Color;
    180            U32 * pDest;
    181            U32 Off, RemPixels;
    182            LCD_PIXELINDEX ColorIndex;
    183          
    184            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable16
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0240A0E1           MOV      R4,R2
   \   00000018   0350A0E1           MOV      R5,R3
   \   0000001C   010010E3           TST      R0,#0x1
   \   00000020   1300000A           BEQ      ??_DrawHLine_0
   \   00000024   060055E1           CMP      R5,R6
   \   00000028   350000BA           BLT      ??_DrawHLine_1
    185              for (; x0 <= x1; x0++) {
    186                _XorPixel(pDevice, x0, y);
   \                     ??_DrawHLine_2:
   \   0000002C   080097E5           LDR      R0,[R7, #+8]
   \   00000030   141090E5           LDR      R1,[R0, #+20]
   \   00000034   000090E5           LDR      R0,[R0, #+0]
   \   00000038   916422E0           MLA      R2,R1,R4,R6
   \   0000003C   028190E7           LDR      R8,[R0, +R2, LSL #+2]
   \   00000040   100097E5           LDR      R0,[R7, #+16]
   \   00000044   080090E5           LDR      R0,[R0, #+8]
   \   00000048   30FF2FE1           BLX      R0
   \   0000004C   081097E5           LDR      R1,[R7, #+8]
   \   00000050   080020E0           EOR      R0,R0,R8
   \   00000054   142091E5           LDR      R2,[R1, #+20]
   \   00000058   001091E5           LDR      R1,[R1, #+0]
   \   0000005C   926423E0           MLA      R3,R2,R4,R6
    187              }
   \   00000060   016086E2           ADD      R6,R6,#+1
   \   00000064   030181E7           STR      R0,[R1, +R3, LSL #+2]
   \   00000068   060055E1           CMP      R5,R6
   \   0000006C   EEFFFFAA           BGE      ??_DrawHLine_2
   \   00000070   F081BDE8           POP      {R4-R8,PC}
    188            } else {
    189              ColorIndex = LCD__GetColorIndex();
    190              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     ??_DrawHLine_0:
   \   00000074   081097E5           LDR      R1,[R7, #+8]
   \   00000078   ........           LDR      R0,??DataTable16_1
    191              Color = ColorIndex;
    192              Off = XY2OFF32(pContext->vxSizePhys, x0, y);
    193              pDest = OFF2PTR32(pContext->VRAMAddr, Off);
   \   0000007C   142091E5           LDR      R2,[R1, #+20]
   \   00000080   000090E5           LDR      R0,[R0, #+0]
   \   00000084   926423E0           MLA      R3,R2,R4,R6
   \   00000088   001091E5           LDR      R1,[R1, #+0]
    194              RemPixels = x1 - x0 + 1;
   \   0000008C   062045E0           SUB      R2,R5,R6
   \   00000090   012082E2           ADD      R2,R2,#+1
   \   00000094   000090E5           LDR      R0,[R0, #+0]
   \   00000098   031181E0           ADD      R1,R1,R3, LSL #+2
    195              if (RemPixels >= 16) {
   \   0000009C   100052E3           CMP      R2,#+16
   \   000000A0   1200003A           BCC      ??_DrawHLine_3
    196                do {
    197                  WRITE_MEM32P(pDest     , Color);
   \                     ??_DrawHLine_4:
   \   000000A4   040081E4           STR      R0,[R1], #+4
    198                  WRITE_MEM32P(pDest +  1, Color);
   \   000000A8   040081E4           STR      R0,[R1], #+4
    199                  WRITE_MEM32P(pDest +  2, Color);
   \   000000AC   040081E4           STR      R0,[R1], #+4
    200                  WRITE_MEM32P(pDest +  3, Color);
   \   000000B0   040081E4           STR      R0,[R1], #+4
    201                  WRITE_MEM32P(pDest +  4, Color);
   \   000000B4   040081E4           STR      R0,[R1], #+4
    202                  WRITE_MEM32P(pDest +  5, Color);
   \   000000B8   040081E4           STR      R0,[R1], #+4
    203                  WRITE_MEM32P(pDest +  6, Color);
   \   000000BC   040081E4           STR      R0,[R1], #+4
    204                  WRITE_MEM32P(pDest +  7, Color);
   \   000000C0   040081E4           STR      R0,[R1], #+4
    205                  WRITE_MEM32P(pDest +  8, Color);
   \   000000C4   040081E4           STR      R0,[R1], #+4
    206                  WRITE_MEM32P(pDest +  9, Color);
   \   000000C8   040081E4           STR      R0,[R1], #+4
    207                  WRITE_MEM32P(pDest + 10, Color);
   \   000000CC   040081E4           STR      R0,[R1], #+4
    208                  WRITE_MEM32P(pDest + 11, Color);
   \   000000D0   040081E4           STR      R0,[R1], #+4
    209                  WRITE_MEM32P(pDest + 12, Color);
   \   000000D4   040081E4           STR      R0,[R1], #+4
    210                  WRITE_MEM32P(pDest + 13, Color);
   \   000000D8   040081E4           STR      R0,[R1], #+4
    211                  WRITE_MEM32P(pDest + 14, Color);
   \   000000DC   040081E4           STR      R0,[R1], #+4
    212                  WRITE_MEM32P(pDest + 15, Color);
    213                  pDest += 16;
    214                  RemPixels -= 16;
   \   000000E0   102042E2           SUB      R2,R2,#+16
   \   000000E4   040081E4           STR      R0,[R1], #+4
    215                } while (RemPixels >= 16);
   \   000000E8   100052E3           CMP      R2,#+16
   \   000000EC   ECFFFF2A           BCS      ??_DrawHLine_4
    216              }
    217              if (RemPixels) {
   \                     ??_DrawHLine_3:
   \   000000F0   000052E3           CMP      R2,#+0
   \   000000F4   0200000A           BEQ      ??_DrawHLine_1
    218                do {
    219                  WRITE_MEM32P(pDest, ColorIndex);
   \                     ??_DrawHLine_5:
   \   000000F8   040081E4           STR      R0,[R1], #+4
    220                  pDest++;
    221                } while (--RemPixels);
   \   000000FC   012052E2           SUBS     R2,R2,#+1
   \   00000100   FCFFFF1A           BNE      ??_DrawHLine_5
    222              }
    223            }
    224          }
   \                     ??_DrawHLine_1:
   \   00000104   F081BDE8           POP      {R4-R8,PC}       ;; return
    225          
    226          /*********************************************************************
    227          *
    228          *       _DrawVLine, not optimized
    229          */

   \                                 In section .text, align 4, keep-with-next
    230          static void _DrawVLine  (GUI_DEVICE * pDevice, int x, int y0,  int y1) {
   \                     _DrawVLine:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    231            LCD_PIXELINDEX ColorIndex;
    232          
    233            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable16
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0270A0E1           MOV      R7,R2
   \   00000018   0360A0E1           MOV      R6,R3
   \   0000001C   010010E3           TST      R0,#0x1
   \   00000020   1300000A           BEQ      ??_DrawVLine_0
   \   00000024   070056E1           CMP      R6,R7
   \   00000028   1E0000BA           BLT      ??_DrawVLine_1
    234              for (; y0 <= y1; y0++) {
    235                _XorPixel(pDevice, x, y0);
   \                     ??_DrawVLine_2:
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   141090E5           LDR      R1,[R0, #+20]
   \   00000034   000090E5           LDR      R0,[R0, #+0]
   \   00000038   915722E0           MLA      R2,R1,R7,R5
   \   0000003C   028190E7           LDR      R8,[R0, +R2, LSL #+2]
   \   00000040   100094E5           LDR      R0,[R4, #+16]
   \   00000044   080090E5           LDR      R0,[R0, #+8]
   \   00000048   30FF2FE1           BLX      R0
   \   0000004C   081094E5           LDR      R1,[R4, #+8]
   \   00000050   080020E0           EOR      R0,R0,R8
   \   00000054   142091E5           LDR      R2,[R1, #+20]
   \   00000058   001091E5           LDR      R1,[R1, #+0]
   \   0000005C   925723E0           MLA      R3,R2,R7,R5
    236              }
   \   00000060   017087E2           ADD      R7,R7,#+1
   \   00000064   030181E7           STR      R0,[R1, +R3, LSL #+2]
   \   00000068   070056E1           CMP      R6,R7
   \   0000006C   EEFFFFAA           BGE      ??_DrawVLine_2
   \   00000070   F081BDE8           POP      {R4-R8,PC}
    237            } else {
    238              ColorIndex = LCD__GetColorIndex();
   \                     ??_DrawVLine_0:
   \   00000074   ........           LDR      R0,??DataTable16_1
   \   00000078   070056E1           CMP      R6,R7
   \   0000007C   000090E5           LDR      R0,[R0, #+0]
   \   00000080   000090E5           LDR      R0,[R0, #+0]
   \   00000084   070000BA           BLT      ??_DrawVLine_1
    239              for (; y0 <= y1; y0++) {
    240                _SetPixelIndex(pDevice, x, y0, ColorIndex);
   \                     ??_DrawVLine_3:
   \   00000088   081094E5           LDR      R1,[R4, #+8]
   \   0000008C   142091E5           LDR      R2,[R1, #+20]
   \   00000090   001091E5           LDR      R1,[R1, #+0]
   \   00000094   925723E0           MLA      R3,R2,R7,R5
    241              }
   \   00000098   017087E2           ADD      R7,R7,#+1
   \   0000009C   030181E7           STR      R0,[R1, +R3, LSL #+2]
   \   000000A0   070056E1           CMP      R6,R7
   \   000000A4   F7FFFFAA           BGE      ??_DrawVLine_3
    242            }
    243          }
   \                     ??_DrawVLine_1:
   \   000000A8   F081BDE8           POP      {R4-R8,PC}       ;; return
    244          
    245          /*********************************************************************
    246          *
    247          *       _FillRect
    248          */

   \                                 In section .text, align 4, keep-with-next
    249          static void _FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    250            DRIVER_CONTEXT * pContext;
    251          
    252            #ifdef LCD_FILL_RECT
    253               LCD_FILL_RECT(x0, y0, x1, y1, LCD__GetColorIndex());
    254            #else
    255              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   08D04DE2           SUB      SP,SP,#+8
    256              if (pContext->pfFillRect) {
   \   00000010   28C090E5           LDR      R12,[R0, #+40]
   \   00000014   0150A0E1           MOV      R5,R1
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   0370A0E1           MOV      R7,R3
   \   00000020   20809DE5           LDR      R8,[SP, #+32]
   \   00000024   00005CE3           CMP      R12,#+0
   \   00000028   0B00001A           BNE      ??_FillRect_0
   \   0000002C   060058E1           CMP      R8,R6
   \   00000030   070000BA           BLT      ??_FillRect_1
    257                pContext->pfFillRect(pDevice->LayerIndex, x0, y0, x1, y1, LCD__GetColorIndex());
    258              } else {
    259                for (; y0 <= y1; y0++) {
    260                  _DrawHLine(pDevice, x0, y0, x1);
   \                     ??_FillRect_2:
   \   00000034   0730A0E1           MOV      R3,R7
   \   00000038   0620A0E1           MOV      R2,R6
   \   0000003C   0510A0E1           MOV      R1,R5
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   ........           BL       _DrawHLine
    261                }
   \   00000048   016086E2           ADD      R6,R6,#+1
   \   0000004C   060058E1           CMP      R8,R6
   \   00000050   F7FFFFAA           BGE      ??_FillRect_2
    262              }
    263            #endif
    264          }
   \                     ??_FillRect_1:
   \   00000054   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000058   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??_FillRect_0:
   \   0000005C   ........           LDR      R0,??DataTable16_1
   \   00000060   000090E5           LDR      R0,[R0, #+0]
   \   00000064   000090E5           LDR      R0,[R0, #+0]
   \   00000068   00808DE5           STR      R8,[SP, #+0]
   \   0000006C   04008DE5           STR      R0,[SP, #+4]
   \   00000070   180094E5           LDR      R0,[R4, #+24]
   \   00000074   3CFF2FE1           BLX      R12
   \   00000078   F5FFFFEA           B        ??_FillRect_1
    265          
    266          /*********************************************************************
    267          *
    268          *       Draw Bitmap 1 BPP
    269          */

   \                                 In section .text, align 4, keep-with-next
    270          static void _DrawBitLine1BPP(GUI_DEVICE * pDevice, unsigned x, unsigned y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine1BPP:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   20709DE5           LDR      R7,[SP, #+32]
   \   00000008   0250A0E1           MOV      R5,R2
    271            DRIVER_CONTEXT * pContext;
    272            LCD_PIXELINDEX Index0, Index1, IndexMask;
    273            U32 * pDest;
    274            U32 Color;
    275            unsigned Pixels, PixelCnt, Off;
    276          
    277            Index0 = *(pTrans + 0);
    278            Index1 = *(pTrans + 1);
    279            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    280            x += Diff;
   \   0000000C   019087E0           ADD      R9,R7,R1
    281            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000010   ........           LDR      R1,??DataTable16
   \   00000014   28209DE5           LDR      R2,[SP, #+40]
   \   00000018   1010D1E5           LDRB     R1,[R1, #+16]
   \   0000001C   0040A0E1           MOV      R4,R0
   \   00000020   0360A0E1           MOV      R6,R3
   \   00000024   000092E5           LDR      R0,[R2, #+0]
   \   00000028   031001E2           AND      R1,R1,#0x3
   \   0000002C   24809DE5           LDR      R8,[SP, #+36]
   \   00000030   042092E5           LDR      R2,[R2, #+4]
   \   00000034   083094E5           LDR      R3,[R4, #+8]
   \   00000038   030051E3           CMP      R1,#+3
   \   0000003C   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitLine1BPP_0:
   \   00000040   4300008A           BHI      ??_DrawBitLine1BPP_1
   \   00000044   020000EA           B        ??_DrawBitLine1BPP_2
   \   00000048   2A0000EA           B        ??_DrawBitLine1BPP_3
   \   0000004C   150000EA           B        ??_DrawBitLine1BPP_4
   \   00000050   280000EA           B        ??_DrawBitLine1BPP_3
    282            case 0:
    283              PixelCnt = 8 - Diff;
    284              Pixels   = LCD_aMirror[*p] >> Diff;
   \                     ??_DrawBitLine1BPP_2:
   \   00000054   00E0D6E5           LDRB     LR,[R6, #+0]
   \   00000058   ........           LDR      R12,??DataTable17
    285              Off      = XY2OFF32(pContext->vxSizePhys, x, y);
    286              pDest    = OFF2PTR32(pContext->VRAMAddr, Off);
   \   0000005C   144093E5           LDR      R4,[R3, #+20]
   \   00000060   0CE0DEE7           LDRB     LR,[LR, +R12]
   \   00000064   949525E0           MLA      R5,R4,R5,R9
   \   00000068   003093E5           LDR      R3,[R3, #+0]
   \   0000006C   081067E2           RSB      R1,R7,#+8
   \   00000070   5EE7A0E1           ASR      LR,LR,R7
   \   00000074   053183E0           ADD      R3,R3,R5, LSL #+2
    287              do {
    288                Color    = (Pixels & 1) ? Index1 : Index0;
   \                     ??_DrawBitLine1BPP_5:
   \   00000078   01001EE3           TST      LR,#0x1
   \   0000007C   0240A011           MOVNE    R4,R2
   \   00000080   0040A001           MOVEQ    R4,R0
    289                Pixels >>= 1;
    290                if (--PixelCnt == 0) {
   \   00000084   011051E2           SUBS     R1,R1,#+1
    291                  Pixels = LCD_aMirror[*(++p)];
   \   00000088   0110F605           LDRBEQ   R1,[R6, #+1]!
   \   0000008C   AEE0A0E1           LSR      LR,LR,#+1
   \   00000090   0CE0D107           LDRBEQ   LR,[R1, +R12]
    292                  PixelCnt = 8;
   \   00000094   0810A003           MOVEQ    R1,#+8
    293                }
    294                WRITE_MEM32P(pDest, Color);
   \   00000098   044083E4           STR      R4,[R3], #+4
    295                pDest++;
    296              } while (--xsize);
   \   0000009C   018058E2           SUBS     R8,R8,#+1
   \   000000A0   F4FFFF1A           BNE      ??_DrawBitLine1BPP_5
   \   000000A4   F087BDE8           POP      {R4-R10,PC}
    297              break;
    298            case LCD_DRAWMODE_TRANS:
    299              PixelCnt = 8 - Diff;
    300              Pixels   = LCD_aMirror[*p] >> Diff;
   \                     ??_DrawBitLine1BPP_4:
   \   000000A8   0000D6E5           LDRB     R0,[R6, #+0]
   \   000000AC   ........           LDR      R12,??DataTable17
   \   000000B0   081067E2           RSB      R1,R7,#+8
   \   000000B4   0C00D0E7           LDRB     R0,[R0, +R12]
   \   000000B8   50E7A0E1           ASR      LR,R0,R7
    301              Off      = XY2OFF32(pContext->vxSizePhys, x, y);
    302              pDest    = OFF2PTR32(pContext->VRAMAddr, Off);
   \   000000BC   140093E5           LDR      R0,[R3, #+20]
   \   000000C0   909524E0           MLA      R4,R0,R5,R9
   \   000000C4   000093E5           LDR      R0,[R3, #+0]
   \   000000C8   043180E0           ADD      R3,R0,R4, LSL #+2
    303              do {
    304                if (Pixels & 1) {
   \                     ??_DrawBitLine1BPP_6:
   \   000000CC   01001EE3           TST      LR,#0x1
    305                  WRITE_MEM32P(pDest, Index1);
   \   000000D0   00208315           STRNE    R2,[R3, #+0]
    306                }
    307                pDest++;
    308                Pixels >>= 1;
    309                if (--PixelCnt == 0) {
   \   000000D4   011051E2           SUBS     R1,R1,#+1
    310                  Pixels = LCD_aMirror[*(++p)];
   \   000000D8   0100F605           LDRBEQ   R0,[R6, #+1]!
   \   000000DC   AEE0A0E1           LSR      LR,LR,#+1
    311                  PixelCnt = 8;
   \   000000E0   0810A003           MOVEQ    R1,#+8
   \   000000E4   0CE0D007           LDRBEQ   LR,[R0, +R12]
   \   000000E8   043083E2           ADD      R3,R3,#+4
    312                }
    313              } while (--xsize);
   \   000000EC   018058E2           SUBS     R8,R8,#+1
   \   000000F0   F5FFFF1A           BNE      ??_DrawBitLine1BPP_6
   \   000000F4   F087BDE8           POP      {R4-R10,PC}
    314              break;
    315            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    316            case LCD_DRAWMODE_XOR:
    317              IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \                     ??_DrawBitLine1BPP_3:
   \   000000F8   100094E5           LDR      R0,[R4, #+16]
   \   000000FC   080090E5           LDR      R0,[R0, #+8]
   \   00000100   30FF2FE1           BLX      R0
   \   00000104   8010A0E3           MOV      R1,#+128
    318              do {
    319                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_7:
   \   00000108   0020D6E5           LDRB     R2,[R6, #+0]
   \   0000010C   510712E1           TST      R2,R1, ASR R7
   \   00000110   0800000A           BEQ      ??_DrawBitLine1BPP_8
    320                  int Pixel = _GetPixelIndex(pDevice, x, y);
   \   00000114   08C094E5           LDR      R12,[R4, #+8]
    321                  _SetPixelIndex(pDevice, x, y, Pixel ^ IndexMask);
   \   00000118   14309CE5           LDR      R3,[R12, #+20]
   \   0000011C   14E09CE5           LDR      LR,[R12, #+20]
   \   00000120   939522E0           MLA      R2,R3,R5,R9
   \   00000124   9E952AE0           MLA      R10,LR,R5,R9
   \   00000128   00309CE5           LDR      R3,[R12, #+0]
   \   0000012C   0AC193E7           LDR      R12,[R3, +R10, LSL #+2]
   \   00000130   0CC020E0           EOR      R12,R0,R12
   \   00000134   02C183E7           STR      R12,[R3, +R2, LSL #+2]
    322                }
    323                x++;
    324                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_8:
   \   00000138   017087E2           ADD      R7,R7,#+1
   \   0000013C   080057E3           CMP      R7,#+8
    325                  Diff = 0;
   \   00000140   0070A003           MOVEQ    R7,#+0
    326                  p++;
   \   00000144   01608602           ADDEQ    R6,R6,#+1
   \   00000148   019089E2           ADD      R9,R9,#+1
    327                }
    328              } while (--xsize);
   \   0000014C   018058E2           SUBS     R8,R8,#+1
   \   00000150   ECFFFF1A           BNE      ??_DrawBitLine1BPP_7
    329              break;
    330            }
    331          }
   \                     ??_DrawBitLine1BPP_1:
   \   00000154   F087BDE8           POP      {R4-R10,PC}      ;; return
    332          
    333          /*********************************************************************
    334          *
    335          *       Draw Bitmap 2 BPP
    336          */

   \                                 In section .text, align 4, keep-with-next
    337          static void  _DrawBitLine2BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine2BPP:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   18409DE5           LDR      R4,[SP, #+24]
   \   00000008   10C09DE5           LDR      R12,[SP, #+16]
   \   0000000C   14E09DE5           LDR      LR,[SP, #+20]
    338            DRIVER_CONTEXT * pContext;
    339            LCD_PIXELINDEX Pixels, PixelIndex;
    340            int CurrentPixel, Shift, Index;
    341            U32 * pDest;
    342            U32 Off;
    343          
    344            if (pTrans == NULL) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   2D00000A           BEQ      ??_DrawBitLine2BPP_0
    345              return; // pTrans is required
    346            }
    347            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000018   085090E5           LDR      R5,[R0, #+8]
    348            CurrentPixel = Diff;
    349            Pixels       = *p;
    350            x           += Diff;
    351            Off          = XY2OFF32(pContext->vxSizePhys, x, y);
    352            pDest        = OFF2PTR32(pContext->VRAMAddr, Off);
   \   0000001C   01108CE0           ADD      R1,R12,R1
   \   00000020   146095E5           LDR      R6,[R5, #+20]
   \   00000024   0000D3E5           LDRB     R0,[R3, #+0]
   \   00000028   961221E0           MLA      R1,R6,R2,R1
   \   0000002C   002095E5           LDR      R2,[R5, #+0]
   \   00000030   011182E0           ADD      R1,R2,R1, LSL #+2
    353            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000034   ........           LDR      R2,??DataTable16
   \   00000038   1020D2E5           LDRB     R2,[R2, #+16]
   \   0000003C   032012E2           ANDS     R2,R2,#0x3
   \   00000040   0200000A           BEQ      ??_DrawBitLine2BPP_1
   \   00000044   022052E2           SUBS     R2,R2,#+2
   \   00000048   1000000A           BEQ      ??_DrawBitLine2BPP_2
   \   0000004C   7080BDE8           POP      {R4-R6,PC}
    354            case 0:
    355              do {
    356                Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_1:
   \   00000050   03206CE2           RSB      R2,R12,#+3
   \   00000054   8220A0E1           LSL      R2,R2,#+1
    357                Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    358                PixelIndex = *(pTrans + Index);
    359                WRITE_MEM32P(pDest, PixelIndex);
   \   00000058   0260A0E1           MOV      R6,R2
   \   0000005C   C050A0E3           MOV      R5,#+192
   \   00000060   066066E2           RSB      R6,R6,#+6
   \   00000064   555600E0           AND      R5,R0,R5, ASR R6
   \   00000068   3522A0E1           LSR      R2,R5,R2
   \   0000006C   022194E7           LDR      R2,[R4, +R2, LSL #+2]
    360                pDest++;
    361                if (++CurrentPixel == 4) {
   \   00000070   01C08CE2           ADD      R12,R12,#+1
   \   00000074   042081E4           STR      R2,[R1], #+4
   \   00000078   04005CE3           CMP      R12,#+4
    362                  CurrentPixel = 0;
   \   0000007C   00C0A003           MOVEQ    R12,#+0
    363                  Pixels = *(++p);
   \   00000080   0100F305           LDRBEQ   R0,[R3, #+1]!
    364                }
    365          		} while (--xsize);
   \   00000084   01E05EE2           SUBS     LR,LR,#+1
   \   00000088   F0FFFF1A           BNE      ??_DrawBitLine2BPP_1
   \   0000008C   7080BDE8           POP      {R4-R6,PC}
    366              break;
    367            case LCD_DRAWMODE_TRANS:
    368              do {
    369                Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_2:
   \   00000090   03206CE2           RSB      R2,R12,#+3
   \   00000094   8220A0E1           LSL      R2,R2,#+1
    370                Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000098   0260A0E1           MOV      R6,R2
   \   0000009C   C050A0E3           MOV      R5,#+192
   \   000000A0   066066E2           RSB      R6,R6,#+6
   \   000000A4   555600E0           AND      R5,R0,R5, ASR R6
   \   000000A8   3522B0E1           LSRS     R2,R5,R2
    371                if (Index) {
    372                  PixelIndex = *(pTrans + Index);
    373                  WRITE_MEM32P(pDest, PixelIndex);
   \   000000AC   02219417           LDRNE    R2,[R4, +R2, LSL #+2]
    374                }
    375                pDest++;
    376                if (++CurrentPixel == 4) {
   \   000000B0   01C08CE2           ADD      R12,R12,#+1
   \   000000B4   00208115           STRNE    R2,[R1, #+0]
   \   000000B8   04005CE3           CMP      R12,#+4
    377                  CurrentPixel = 0;
   \   000000BC   00C0A003           MOVEQ    R12,#+0
    378                  Pixels = *(++p);
   \   000000C0   0100F305           LDRBEQ   R0,[R3, #+1]!
   \   000000C4   041081E2           ADD      R1,R1,#+4
    379                }
    380          		} while (--xsize);
   \   000000C8   01E05EE2           SUBS     LR,LR,#+1
   \   000000CC   EFFFFF1A           BNE      ??_DrawBitLine2BPP_2
   \                     ??_DrawBitLine2BPP_0:
   \   000000D0   7080BDE8           POP      {R4-R6,PC}       ;; return
    381              break;
    382            }
    383          }
    384          
    385          /*********************************************************************
    386          *
    387          *       Draw Bitmap 4 BPP
    388          */

   \                                 In section .text, align 4, keep-with-next
    389          static void  _DrawBitLine4BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine4BPP:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   18409DE5           LDR      R4,[SP, #+24]
   \   00000008   10C09DE5           LDR      R12,[SP, #+16]
   \   0000000C   14E09DE5           LDR      LR,[SP, #+20]
    390            DRIVER_CONTEXT * pContext;
    391            LCD_PIXELINDEX Pixels, PixelIndex;
    392            int CurrentPixel, Shift, Index;
    393            U32 * pDest;
    394            U32 Off;
    395          
    396            if (pTrans == NULL) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   2D00000A           BEQ      ??_DrawBitLine4BPP_0
    397              return; // pTrans is required
    398            }
    399            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000018   085090E5           LDR      R5,[R0, #+8]
    400            Pixels       = *p;
    401            CurrentPixel = Diff;
    402            x           += Diff;
    403            Off          = XY2OFF32(pContext->vxSizePhys, x, y);
    404            pDest        = OFF2PTR32(pContext->VRAMAddr, Off);
   \   0000001C   01108CE0           ADD      R1,R12,R1
   \   00000020   146095E5           LDR      R6,[R5, #+20]
   \   00000024   0000D3E5           LDRB     R0,[R3, #+0]
   \   00000028   961221E0           MLA      R1,R6,R2,R1
   \   0000002C   002095E5           LDR      R2,[R5, #+0]
   \   00000030   011182E0           ADD      R1,R2,R1, LSL #+2
    405            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000034   ........           LDR      R2,??DataTable16
   \   00000038   1020D2E5           LDRB     R2,[R2, #+16]
   \   0000003C   032012E2           ANDS     R2,R2,#0x3
   \   00000040   0200000A           BEQ      ??_DrawBitLine4BPP_1
   \   00000044   022052E2           SUBS     R2,R2,#+2
   \   00000048   1000000A           BEQ      ??_DrawBitLine4BPP_2
   \   0000004C   7080BDE8           POP      {R4-R6,PC}
    406            case 0:
    407              do {
    408                Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_1:
   \   00000050   01206CE2           RSB      R2,R12,#+1
   \   00000054   0221A0E1           LSL      R2,R2,#+2
    409                Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    410                PixelIndex = *(pTrans + Index);
    411                WRITE_MEM32P(pDest, PixelIndex);
   \   00000058   0260A0E1           MOV      R6,R2
   \   0000005C   F050A0E3           MOV      R5,#+240
   \   00000060   046066E2           RSB      R6,R6,#+4
   \   00000064   555600E0           AND      R5,R0,R5, ASR R6
   \   00000068   3522A0E1           LSR      R2,R5,R2
   \   0000006C   022194E7           LDR      R2,[R4, +R2, LSL #+2]
    412                pDest++;
    413                if (++CurrentPixel == 2) {
   \   00000070   01C08CE2           ADD      R12,R12,#+1
   \   00000074   042081E4           STR      R2,[R1], #+4
   \   00000078   02005CE3           CMP      R12,#+2
    414                  CurrentPixel = 0;
   \   0000007C   00C0A003           MOVEQ    R12,#+0
    415                  Pixels = *(++p);
   \   00000080   0100F305           LDRBEQ   R0,[R3, #+1]!
    416                }
    417          		} while (--xsize);
   \   00000084   01E05EE2           SUBS     LR,LR,#+1
   \   00000088   F0FFFF1A           BNE      ??_DrawBitLine4BPP_1
   \   0000008C   7080BDE8           POP      {R4-R6,PC}
    418              break;
    419            case LCD_DRAWMODE_TRANS:
    420              do {
    421                Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_2:
   \   00000090   01206CE2           RSB      R2,R12,#+1
   \   00000094   0221A0E1           LSL      R2,R2,#+2
    422                Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000098   0260A0E1           MOV      R6,R2
   \   0000009C   F050A0E3           MOV      R5,#+240
   \   000000A0   046066E2           RSB      R6,R6,#+4
   \   000000A4   555600E0           AND      R5,R0,R5, ASR R6
   \   000000A8   3522B0E1           LSRS     R2,R5,R2
    423                if (Index) {
    424                  PixelIndex = *(pTrans + Index);
    425                  WRITE_MEM32P(pDest, PixelIndex);
   \   000000AC   02219417           LDRNE    R2,[R4, +R2, LSL #+2]
    426                }
    427                pDest++;
    428                if (++CurrentPixel == 2) {
   \   000000B0   01C08CE2           ADD      R12,R12,#+1
   \   000000B4   00208115           STRNE    R2,[R1, #+0]
   \   000000B8   02005CE3           CMP      R12,#+2
    429                  CurrentPixel = 0;
   \   000000BC   00C0A003           MOVEQ    R12,#+0
    430                  Pixels = *(++p);
   \   000000C0   0100F305           LDRBEQ   R0,[R3, #+1]!
   \   000000C4   041081E2           ADD      R1,R1,#+4
    431                }
    432          		} while (--xsize);
   \   000000C8   01E05EE2           SUBS     LR,LR,#+1
   \   000000CC   EFFFFF1A           BNE      ??_DrawBitLine4BPP_2
   \                     ??_DrawBitLine4BPP_0:
   \   000000D0   7080BDE8           POP      {R4-R6,PC}       ;; return
    433              break;
    434            }
    435          }
    436          
    437          /*********************************************************************
    438          *
    439          *       Draw Bitmap 8 BPP
    440          */

   \                                 In section .text, align 4, keep-with-next
    441          static void  _DrawBitLine8BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine8BPP:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0CE09DE5           LDR      LR,[SP, #+12]
   \   00000008   08C09DE5           LDR      R12,[SP, #+8]
    442            DRIVER_CONTEXT * pContext;
    443            LCD_PIXELINDEX Pixel;
    444            register U32 Off;
    445            U32 * pDest;
    446          
    447            if (!pTrans) {
   \   0000000C   00005EE3           CMP      LR,#+0
   \   00000010   4D00000A           BEQ      ??_DrawBitLine8BPP_0
    448              return; // No translation from 8bpp BMP to 16bpp device makes no sense
    449            }
    450            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000014   080090E5           LDR      R0,[R0, #+8]
    451            Off   = XY2OFF32(pContext->vxSizePhys, x,y);
    452            pDest = OFF2PTR32(pContext->VRAMAddr, Off);
   \   00000018   144090E5           LDR      R4,[R0, #+20]
   \   0000001C   000090E5           LDR      R0,[R0, #+0]
   \   00000020   941221E0           MLA      R1,R4,R2,R1
   \   00000024   010180E0           ADD      R0,R0,R1, LSL #+2
    453            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000028   ........           LDR      R1,??DataTable16
   \   0000002C   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000030   031011E2           ANDS     R1,R1,#0x3
   \   00000034   0200000A           BEQ      ??_DrawBitLine8BPP_1
   \   00000038   021051E2           SUBS     R1,R1,#+2
   \   0000003C   3700000A           BEQ      ??_DrawBitLine8BPP_2
   \   00000040   1080BDE8           POP      {R4,PC}
    454            case 0:
    455              while (xsize >= 8) {
   \                     ??_DrawBitLine8BPP_1:
   \   00000044   08005CE3           CMP      R12,#+8
   \   00000048   180000AA           BGE      ??_DrawBitLine8BPP_3
   \                     ??_DrawBitLine8BPP_4:
   \   0000004C   04005CE3           CMP      R12,#+4
   \   00000050   0E0000BA           BLT      ??_DrawBitLine8BPP_5
    456                WRITE_MEM32P(pDest + 0, *(pTrans + *(p + 0)));
    457                WRITE_MEM32P(pDest + 1, *(pTrans + *(p + 1)));
    458                WRITE_MEM32P(pDest + 2, *(pTrans + *(p + 2)));
    459                WRITE_MEM32P(pDest + 3, *(pTrans + *(p + 3)));
    460                WRITE_MEM32P(pDest + 4, *(pTrans + *(p + 4)));
    461                WRITE_MEM32P(pDest + 5, *(pTrans + *(p + 5)));
    462                WRITE_MEM32P(pDest + 6, *(pTrans + *(p + 6)));
    463                WRITE_MEM32P(pDest + 7, *(pTrans + *(p + 7)));
    464                xsize -= 8;
    465                p     += 8;
    466                pDest += 8;
    467              }
    468              while (xsize >= 4) {
    469                WRITE_MEM32P(pDest + 0, *(pTrans + *(p + 0)));
   \                     ??_DrawBitLine8BPP_6:
   \   00000054   0110D3E4           LDRB     R1,[R3], #+1
    470                WRITE_MEM32P(pDest + 1, *(pTrans + *(p + 1)));
    471                WRITE_MEM32P(pDest + 2, *(pTrans + *(p + 2)));
    472                WRITE_MEM32P(pDest + 3, *(pTrans + *(p + 3)));
    473                xsize -= 4;
   \   00000058   04C04CE2           SUB      R12,R12,#+4
    474                p     += 4;
    475                pDest += 4;
   \   0000005C   04005CE3           CMP      R12,#+4
   \   00000060   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000064   041080E4           STR      R1,[R0], #+4
   \   00000068   0110D3E4           LDRB     R1,[R3], #+1
   \   0000006C   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000070   041080E4           STR      R1,[R0], #+4
   \   00000074   0110D3E4           LDRB     R1,[R3], #+1
   \   00000078   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   0000007C   041080E4           STR      R1,[R0], #+4
   \   00000080   0110D3E4           LDRB     R1,[R3], #+1
   \   00000084   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000088   041080E4           STR      R1,[R0], #+4
   \   0000008C   F0FFFFAA           BGE      ??_DrawBitLine8BPP_6
    476              }
    477              while (xsize) {
   \                     ??_DrawBitLine8BPP_5:
   \   00000090   00005CE3           CMP      R12,#+0
   \   00000094   2C00000A           BEQ      ??_DrawBitLine8BPP_0
    478                WRITE_MEM32P(pDest + 0, *(pTrans + *(p + 0)));
   \                     ??_DrawBitLine8BPP_7:
   \   00000098   0110D3E4           LDRB     R1,[R3], #+1
    479                xsize--;
   \   0000009C   01C05CE2           SUBS     R12,R12,#+1
   \   000000A0   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000A4   041080E4           STR      R1,[R0], #+4
    480                p++;
    481                pDest++;
   \   000000A8   FAFFFF1A           BNE      ??_DrawBitLine8BPP_7
   \   000000AC   1080BDE8           POP      {R4,PC}
    482              }
   \                     ??_DrawBitLine8BPP_3:
   \   000000B0   0110D3E4           LDRB     R1,[R3], #+1
   \   000000B4   08C04CE2           SUB      R12,R12,#+8
   \   000000B8   08005CE3           CMP      R12,#+8
   \   000000BC   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000C0   041080E4           STR      R1,[R0], #+4
   \   000000C4   0110D3E4           LDRB     R1,[R3], #+1
   \   000000C8   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000CC   041080E4           STR      R1,[R0], #+4
   \   000000D0   0110D3E4           LDRB     R1,[R3], #+1
   \   000000D4   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000D8   041080E4           STR      R1,[R0], #+4
   \   000000DC   0110D3E4           LDRB     R1,[R3], #+1
   \   000000E0   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000E4   041080E4           STR      R1,[R0], #+4
   \   000000E8   0110D3E4           LDRB     R1,[R3], #+1
   \   000000EC   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000F0   041080E4           STR      R1,[R0], #+4
   \   000000F4   0110D3E4           LDRB     R1,[R3], #+1
   \   000000F8   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000FC   041080E4           STR      R1,[R0], #+4
   \   00000100   0110D3E4           LDRB     R1,[R3], #+1
   \   00000104   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000108   041080E4           STR      R1,[R0], #+4
   \   0000010C   0110D3E4           LDRB     R1,[R3], #+1
   \   00000110   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000114   041080E4           STR      R1,[R0], #+4
   \   00000118   E4FFFFAA           BGE      ??_DrawBitLine8BPP_3
   \   0000011C   CAFFFFEA           B        ??_DrawBitLine8BPP_4
    483              break;
    484            case LCD_DRAWMODE_TRANS:
    485              for (; xsize > 0; xsize--, p++, pDest++) {
   \                     ??_DrawBitLine8BPP_2:
   \   00000120   01005CE3           CMP      R12,#+1
   \   00000124   080000BA           BLT      ??_DrawBitLine8BPP_0
    486                Pixel = *p;
    487                if (Pixel) {
   \                     ??_DrawBitLine8BPP_8:
   \   00000128   0010D3E5           LDRB     R1,[R3, #+0]
    488                  WRITE_MEM32P(pDest, *(pTrans + *p));
    489                }
    490              }
   \   0000012C   01C04CE2           SUB      R12,R12,#+1
   \   00000130   013083E2           ADD      R3,R3,#+1
   \   00000134   000051E3           CMP      R1,#+0
   \   00000138   01119E17           LDRNE    R1,[LR, +R1, LSL #+2]
   \   0000013C   00108015           STRNE    R1,[R0, #+0]
   \   00000140   040080E2           ADD      R0,R0,#+4
   \   00000144   01005CE3           CMP      R12,#+1
   \   00000148   F6FFFFAA           BGE      ??_DrawBitLine8BPP_8
   \                     ??_DrawBitLine8BPP_0:
   \   0000014C   1080BDE8           POP      {R4,PC}          ;; return
    491              break;
    492            }
    493          }
    494          
    495          /*********************************************************************
    496          *
    497          *       Draw Bitmap 16 BPP, not optimized
    498          */
    499          static void _DrawBitLine16BPP(GUI_DEVICE * pDevice, int x, int y, U16 const GUI_UNI_PTR * p, int xsize) {
    500            for (;xsize > 0; xsize--, x++, p++) {
    501              _SetPixelIndex(pDevice, x, y, *p);
    502            }
    503          }
    504          
    505          /*********************************************************************
    506          *
    507          *       Draw Bitmap 32 BPP, not optimized
    508          */
    509          static void _DrawBitLine32BPP(GUI_DEVICE * pDevice, int x, int y, U32 const GUI_UNI_PTR * p, int xsize) {
    510            for (;xsize > 0; xsize--, x++, p++) {
    511              _SetPixelIndex(pDevice, x, y, *p);
    512            }
    513          }
    514          
    515          /*********************************************************************
    516          *
    517          *       _DrawBitmap
    518          */

   \                                 In section .text, align 4, keep-with-next
    519          static void _DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0,
    520                                 int xSize, int ySize,
    521                                 int BitsPerPixel, 
    522                                 int BytesPerLine,
    523                                 const U8 GUI_UNI_PTR * pData, int Diff,
    524                                 const LCD_PIXELINDEX* pTrans) {
   \                     _DrawBitmap:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   3C009DE5           LDR      R0,[SP, #+60]
   \   00000010   0150A0E1           MOV      R5,R1
    525            int i;
    526          
    527            //
    528            // Use _DrawBitLineXBPP and _DrawBitLineXBPP_Swap
    529            //
    530            switch (BitsPerPixel) {
   \   00000014   010040E2           SUB      R0,R0,#+1
   \   00000018   0360A0E1           MOV      R6,R3
   \   0000001C   40709DE5           LDR      R7,[SP, #+64]
   \   00000020   44809DE5           LDR      R8,[SP, #+68]
   \   00000024   48909DE5           LDR      R9,[SP, #+72]
   \   00000028   4CA09DE5           LDR      R10,[SP, #+76]
   \   0000002C   1F0050E3           CMP      R0,#+31
   \   00000030   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_DrawBitmap_0:
   \   00000034   4B00008A           BHI      ??_DrawBitmap_1
   \   00000038   1E0000EA           B        ??_DrawBitmap_2
   \   0000003C   4B0000EA           B        ??_DrawBitmap_3
   \   00000040   480000EA           B        ??_DrawBitmap_1
   \   00000044   760000EA           B        ??_DrawBitmap_4
   \   00000048   460000EA           B        ??_DrawBitmap_1
   \   0000004C   450000EA           B        ??_DrawBitmap_1
   \   00000050   440000EA           B        ??_DrawBitmap_1
   \   00000054   9F0000EA           B        ??_DrawBitmap_5
   \   00000058   420000EA           B        ??_DrawBitmap_1
   \   0000005C   410000EA           B        ??_DrawBitmap_1
   \   00000060   400000EA           B        ??_DrawBitmap_1
   \   00000064   3F0000EA           B        ??_DrawBitmap_1
   \   00000068   3E0000EA           B        ??_DrawBitmap_1
   \   0000006C   3D0000EA           B        ??_DrawBitmap_1
   \   00000070   3C0000EA           B        ??_DrawBitmap_1
   \   00000074   BC0000EA           B        ??_DrawBitmap_6
   \   00000078   3A0000EA           B        ??_DrawBitmap_1
   \   0000007C   390000EA           B        ??_DrawBitmap_1
   \   00000080   380000EA           B        ??_DrawBitmap_1
   \   00000084   370000EA           B        ??_DrawBitmap_1
   \   00000088   360000EA           B        ??_DrawBitmap_1
   \   0000008C   350000EA           B        ??_DrawBitmap_1
   \   00000090   340000EA           B        ??_DrawBitmap_1
   \   00000094   330000EA           B        ??_DrawBitmap_1
   \   00000098   320000EA           B        ??_DrawBitmap_1
   \   0000009C   310000EA           B        ??_DrawBitmap_1
   \   000000A0   300000EA           B        ??_DrawBitmap_1
   \   000000A4   2F0000EA           B        ??_DrawBitmap_1
   \   000000A8   2E0000EA           B        ??_DrawBitmap_1
   \   000000AC   2D0000EA           B        ??_DrawBitmap_1
   \   000000B0   2C0000EA           B        ??_DrawBitmap_1
   \   000000B4   C70000EA           B        ??_DrawBitmap_7
    531            case 1:
    532              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_2:
   \   000000B8   38009DE5           LDR      R0,[SP, #+56]
   \   000000BC   010050E3           CMP      R0,#+1
   \   000000C0   280000BA           BLT      ??_DrawBitmap_1
   \   000000C4   02B0A0E1           MOV      R11,R2
   \   000000C8   10008DE5           STR      R0,[SP, #+16]
   \   000000CC   010010E3           TST      R0,#0x1
   \   000000D0   0700000A           BEQ      ??_DrawBitmap_8
    533                _DrawBitLine1BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   000000D4   08A08DE5           STR      R10,[SP, #+8]
   \   000000D8   04608DE5           STR      R6,[SP, #+4]
   \   000000DC   00908DE5           STR      R9,[SP, #+0]
   \   000000E0   0830A0E1           MOV      R3,R8
   \   000000E4   0400A0E1           MOV      R0,R4
   \   000000E8   ........           BL       _DrawBitLine1BPP
    534                pData += BytesPerLine;
   \   000000EC   088087E0           ADD      R8,R7,R8
   \   000000F0   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_8:
   \   000000F4   10109DE5           LDR      R1,[SP, #+16]
   \   000000F8   A110A0E1           LSR      R1,R1,#+1
   \   000000FC   0C108DE5           STR      R1,[SP, #+12]
   \   00000100   000051E3           CMP      R1,#+0
   \   00000104   1700000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_9:
   \   00000108   08A08DE5           STR      R10,[SP, #+8]
   \   0000010C   04608DE5           STR      R6,[SP, #+4]
   \   00000110   00908DE5           STR      R9,[SP, #+0]
   \   00000114   0830A0E1           MOV      R3,R8
   \   00000118   0B20A0E1           MOV      R2,R11
   \   0000011C   0510A0E1           MOV      R1,R5
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   ........           BL       _DrawBitLine1BPP
   \   00000128   088087E0           ADD      R8,R7,R8
   \   0000012C   08A08DE5           STR      R10,[SP, #+8]
   \   00000130   04608DE5           STR      R6,[SP, #+4]
   \   00000134   00908DE5           STR      R9,[SP, #+0]
   \   00000138   0830A0E1           MOV      R3,R8
   \   0000013C   01208BE2           ADD      R2,R11,#+1
   \   00000140   0510A0E1           MOV      R1,R5
   \   00000144   0400A0E1           MOV      R0,R4
   \   00000148   ........           BL       _DrawBitLine1BPP
    535              }
   \   0000014C   0C109DE5           LDR      R1,[SP, #+12]
   \   00000150   088087E0           ADD      R8,R7,R8
   \   00000154   011041E2           SUB      R1,R1,#+1
   \   00000158   0C108DE5           STR      R1,[SP, #+12]
   \   0000015C   02B08BE2           ADD      R11,R11,#+2
   \   00000160   000051E3           CMP      R1,#+0
   \   00000164   E7FFFF1A           BNE      ??_DrawBitmap_9
    536              break;
    537            case 2:
    538              for (i = 0; i < ySize; i++) {
    539                _DrawBitLine2BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
    540                pData += BytesPerLine;
    541              }
    542              break;
    543            case 4:
    544              for (i = 0; i < ySize; i++) {
    545                _DrawBitLine4BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
    546                pData += BytesPerLine;
    547              }
    548              break;
    549            case 8:
    550              for (i = 0; i < ySize; i++) {
    551                _DrawBitLine8BPP(pDevice, x0, i + y0, pData, xSize, pTrans);
    552                pData += BytesPerLine;
    553              }
    554              break;
    555            case 16:
    556              for (i = 0; i < ySize; i++) {
    557                _DrawBitLine16BPP(pDevice, x0, i + y0, (const U16 *)pData, xSize);
    558                pData += BytesPerLine;
    559              }
    560              break;
    561            case 32:
    562              for (i = 0; i < ySize; i++) {
    563                _DrawBitLine32BPP(pDevice, x0, i + y0, (const U32 *)pData, xSize);
    564                pData += BytesPerLine;
    565              }
    566              break;
    567            }
    568          }
   \                     ??_DrawBitmap_1:
   \   00000168   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   0000016C   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??_DrawBitmap_3:
   \   00000170   38009DE5           LDR      R0,[SP, #+56]
   \   00000174   010050E3           CMP      R0,#+1
   \   00000178   FAFFFFBA           BLT      ??_DrawBitmap_1
   \   0000017C   02B0A0E1           MOV      R11,R2
   \   00000180   10008DE5           STR      R0,[SP, #+16]
   \   00000184   010010E3           TST      R0,#0x1
   \   00000188   0700000A           BEQ      ??_DrawBitmap_10
   \   0000018C   08A08DE5           STR      R10,[SP, #+8]
   \   00000190   04608DE5           STR      R6,[SP, #+4]
   \   00000194   00908DE5           STR      R9,[SP, #+0]
   \   00000198   0830A0E1           MOV      R3,R8
   \   0000019C   0400A0E1           MOV      R0,R4
   \   000001A0   ........           BL       _DrawBitLine2BPP
   \   000001A4   088087E0           ADD      R8,R7,R8
   \   000001A8   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_10:
   \   000001AC   10109DE5           LDR      R1,[SP, #+16]
   \   000001B0   A110A0E1           LSR      R1,R1,#+1
   \   000001B4   0C108DE5           STR      R1,[SP, #+12]
   \   000001B8   000051E3           CMP      R1,#+0
   \   000001BC   E9FFFF0A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_11:
   \   000001C0   08A08DE5           STR      R10,[SP, #+8]
   \   000001C4   04608DE5           STR      R6,[SP, #+4]
   \   000001C8   00908DE5           STR      R9,[SP, #+0]
   \   000001CC   0830A0E1           MOV      R3,R8
   \   000001D0   0B20A0E1           MOV      R2,R11
   \   000001D4   0510A0E1           MOV      R1,R5
   \   000001D8   0400A0E1           MOV      R0,R4
   \   000001DC   ........           BL       _DrawBitLine2BPP
   \   000001E0   088087E0           ADD      R8,R7,R8
   \   000001E4   08A08DE5           STR      R10,[SP, #+8]
   \   000001E8   04608DE5           STR      R6,[SP, #+4]
   \   000001EC   00908DE5           STR      R9,[SP, #+0]
   \   000001F0   0830A0E1           MOV      R3,R8
   \   000001F4   01208BE2           ADD      R2,R11,#+1
   \   000001F8   0510A0E1           MOV      R1,R5
   \   000001FC   0400A0E1           MOV      R0,R4
   \   00000200   ........           BL       _DrawBitLine2BPP
   \   00000204   0C109DE5           LDR      R1,[SP, #+12]
   \   00000208   088087E0           ADD      R8,R7,R8
   \   0000020C   011041E2           SUB      R1,R1,#+1
   \   00000210   0C108DE5           STR      R1,[SP, #+12]
   \   00000214   02B08BE2           ADD      R11,R11,#+2
   \   00000218   000051E3           CMP      R1,#+0
   \   0000021C   E7FFFF1A           BNE      ??_DrawBitmap_11
   \   00000220   D0FFFFEA           B        ??_DrawBitmap_1
   \                     ??_DrawBitmap_4:
   \   00000224   38009DE5           LDR      R0,[SP, #+56]
   \   00000228   010050E3           CMP      R0,#+1
   \   0000022C   CDFFFFBA           BLT      ??_DrawBitmap_1
   \   00000230   02B0A0E1           MOV      R11,R2
   \   00000234   10008DE5           STR      R0,[SP, #+16]
   \   00000238   010010E3           TST      R0,#0x1
   \   0000023C   0700000A           BEQ      ??_DrawBitmap_12
   \   00000240   08A08DE5           STR      R10,[SP, #+8]
   \   00000244   04608DE5           STR      R6,[SP, #+4]
   \   00000248   00908DE5           STR      R9,[SP, #+0]
   \   0000024C   0830A0E1           MOV      R3,R8
   \   00000250   0400A0E1           MOV      R0,R4
   \   00000254   ........           BL       _DrawBitLine4BPP
   \   00000258   088087E0           ADD      R8,R7,R8
   \   0000025C   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_12:
   \   00000260   10109DE5           LDR      R1,[SP, #+16]
   \   00000264   A110A0E1           LSR      R1,R1,#+1
   \   00000268   0C108DE5           STR      R1,[SP, #+12]
   \   0000026C   000051E3           CMP      R1,#+0
   \   00000270   BCFFFF0A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_13:
   \   00000274   08A08DE5           STR      R10,[SP, #+8]
   \   00000278   04608DE5           STR      R6,[SP, #+4]
   \   0000027C   00908DE5           STR      R9,[SP, #+0]
   \   00000280   0830A0E1           MOV      R3,R8
   \   00000284   0B20A0E1           MOV      R2,R11
   \   00000288   0510A0E1           MOV      R1,R5
   \   0000028C   0400A0E1           MOV      R0,R4
   \   00000290   ........           BL       _DrawBitLine4BPP
   \   00000294   088087E0           ADD      R8,R7,R8
   \   00000298   08A08DE5           STR      R10,[SP, #+8]
   \   0000029C   04608DE5           STR      R6,[SP, #+4]
   \   000002A0   00908DE5           STR      R9,[SP, #+0]
   \   000002A4   0830A0E1           MOV      R3,R8
   \   000002A8   01208BE2           ADD      R2,R11,#+1
   \   000002AC   0510A0E1           MOV      R1,R5
   \   000002B0   0400A0E1           MOV      R0,R4
   \   000002B4   ........           BL       _DrawBitLine4BPP
   \   000002B8   0C109DE5           LDR      R1,[SP, #+12]
   \   000002BC   088087E0           ADD      R8,R7,R8
   \   000002C0   011041E2           SUB      R1,R1,#+1
   \   000002C4   0C108DE5           STR      R1,[SP, #+12]
   \   000002C8   02B08BE2           ADD      R11,R11,#+2
   \   000002CC   000051E3           CMP      R1,#+0
   \   000002D0   E7FFFF1A           BNE      ??_DrawBitmap_13
   \   000002D4   A3FFFFEA           B        ??_DrawBitmap_1
   \                     ??_DrawBitmap_5:
   \   000002D8   38009DE5           LDR      R0,[SP, #+56]
   \   000002DC   010050E3           CMP      R0,#+1
   \   000002E0   A0FFFFBA           BLT      ??_DrawBitmap_1
   \   000002E4   00B0A0E1           MOV      R11,R0
   \   000002E8   0290A0E1           MOV      R9,R2
   \   000002EC   01001BE3           TST      R11,#0x1
   \   000002F0   0600000A           BEQ      ??_DrawBitmap_14
   \   000002F4   04A08DE5           STR      R10,[SP, #+4]
   \   000002F8   00608DE5           STR      R6,[SP, #+0]
   \   000002FC   0830A0E1           MOV      R3,R8
   \   00000300   0400A0E1           MOV      R0,R4
   \   00000304   ........           BL       _DrawBitLine8BPP
   \   00000308   088087E0           ADD      R8,R7,R8
   \   0000030C   019089E2           ADD      R9,R9,#+1
   \                     ??_DrawBitmap_14:
   \   00000310   ABB0B0E1           LSRS     R11,R11,#+1
   \   00000314   93FFFF0A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_15:
   \   00000318   04A08DE5           STR      R10,[SP, #+4]
   \   0000031C   00608DE5           STR      R6,[SP, #+0]
   \   00000320   0830A0E1           MOV      R3,R8
   \   00000324   0920A0E1           MOV      R2,R9
   \   00000328   0510A0E1           MOV      R1,R5
   \   0000032C   0400A0E1           MOV      R0,R4
   \   00000330   ........           BL       _DrawBitLine8BPP
   \   00000334   088087E0           ADD      R8,R7,R8
   \   00000338   04A08DE5           STR      R10,[SP, #+4]
   \   0000033C   00608DE5           STR      R6,[SP, #+0]
   \   00000340   0830A0E1           MOV      R3,R8
   \   00000344   012089E2           ADD      R2,R9,#+1
   \   00000348   0510A0E1           MOV      R1,R5
   \   0000034C   0400A0E1           MOV      R0,R4
   \   00000350   ........           BL       _DrawBitLine8BPP
   \   00000354   01B04BE2           SUB      R11,R11,#+1
   \   00000358   088087E0           ADD      R8,R7,R8
   \   0000035C   029089E2           ADD      R9,R9,#+2
   \   00000360   00005BE3           CMP      R11,#+0
   \   00000364   EBFFFF1A           BNE      ??_DrawBitmap_15
   \   00000368   7EFFFFEA           B        ??_DrawBitmap_1
   \                     ??_DrawBitmap_6:
   \   0000036C   38109DE5           LDR      R1,[SP, #+56]
   \   00000370   0000A0E3           MOV      R0,#+0
   \   00000374   010051E3           CMP      R1,#+1
   \   00000378   7AFFFFBA           BLT      ??_DrawBitmap_1
   \                     ??_DrawBitmap_16:
   \   0000037C   0610A0E1           MOV      R1,R6
   \   00000380   0830A0E1           MOV      R3,R8
   \   00000384   05E0A0E1           MOV      LR,R5
   \   00000388   010051E3           CMP      R1,#+1
   \   0000038C   060000AA           BGE      ??_DrawBitmap_17
   \                     ??_DrawBitmap_18:
   \   00000390   38109DE5           LDR      R1,[SP, #+56]
   \   00000394   010080E2           ADD      R0,R0,#+1
   \   00000398   088087E0           ADD      R8,R7,R8
   \   0000039C   012082E2           ADD      R2,R2,#+1
   \   000003A0   010050E1           CMP      R0,R1
   \   000003A4   6FFFFFAA           BGE      ??_DrawBitmap_1
   \   000003A8   F3FFFFEA           B        ??_DrawBitmap_16
   \                     ??_DrawBitmap_17:
   \   000003AC   08A094E5           LDR      R10,[R4, #+8]
   \   000003B0   011041E2           SUB      R1,R1,#+1
   \   000003B4   14B09AE5           LDR      R11,[R10, #+20]
   \   000003B8   00A09AE5           LDR      R10,[R10, #+0]
   \   000003BC   9BE229E0           MLA      R9,R11,R2,LR
   \   000003C0   B2B0D3E0           LDRH     R11,[R3], #+2
   \   000003C4   01E08EE2           ADD      LR,LR,#+1
   \   000003C8   010051E3           CMP      R1,#+1
   \   000003CC   09B18AE7           STR      R11,[R10, +R9, LSL #+2]
   \   000003D0   F5FFFFAA           BGE      ??_DrawBitmap_17
   \   000003D4   EDFFFFEA           B        ??_DrawBitmap_18
   \                     ??_DrawBitmap_7:
   \   000003D8   38109DE5           LDR      R1,[SP, #+56]
   \   000003DC   0000A0E3           MOV      R0,#+0
   \   000003E0   010051E3           CMP      R1,#+1
   \   000003E4   5FFFFFBA           BLT      ??_DrawBitmap_1
   \                     ??_DrawBitmap_19:
   \   000003E8   0610A0E1           MOV      R1,R6
   \   000003EC   0830A0E1           MOV      R3,R8
   \   000003F0   05E0A0E1           MOV      LR,R5
   \   000003F4   010051E3           CMP      R1,#+1
   \   000003F8   060000AA           BGE      ??_DrawBitmap_20
   \                     ??_DrawBitmap_21:
   \   000003FC   38109DE5           LDR      R1,[SP, #+56]
   \   00000400   010080E2           ADD      R0,R0,#+1
   \   00000404   088087E0           ADD      R8,R7,R8
   \   00000408   012082E2           ADD      R2,R2,#+1
   \   0000040C   010050E1           CMP      R0,R1
   \   00000410   54FFFFAA           BGE      ??_DrawBitmap_1
   \   00000414   F3FFFFEA           B        ??_DrawBitmap_19
   \                     ??_DrawBitmap_20:
   \   00000418   08A094E5           LDR      R10,[R4, #+8]
   \   0000041C   011041E2           SUB      R1,R1,#+1
   \   00000420   14B09AE5           LDR      R11,[R10, #+20]
   \   00000424   00A09AE5           LDR      R10,[R10, #+0]
   \   00000428   9BE229E0           MLA      R9,R11,R2,LR
   \   0000042C   04B093E4           LDR      R11,[R3], #+4
   \   00000430   01E08EE2           ADD      LR,LR,#+1
   \   00000434   09B18AE7           STR      R11,[R10, +R9, LSL #+2]
   \   00000438   010051E3           CMP      R1,#+1
   \   0000043C   F5FFFFAA           BGE      ??_DrawBitmap_20
   \   00000440   EDFFFFEA           B        ??_DrawBitmap_21
    569          
    570          /*********************************************************************
    571          *
    572          *       _SetOrg
    573          */

   \                                 In section .text, align 4, keep-with-next
    574          static void _SetOrg(GUI_DEVICE * pDevice, int x, int y) {
   \                     _SetOrg:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    575            LCD_X_SETORG_INFO Data = {0};
   \   00000004   ............       ADRL     R12,`?<Constant {0}>`
   \              ....        
   \   0000000C   0CD04DE2           SUB      SP,SP,#+12
   \   00000010   00409CE5           LDR      R4,[R12, #+0]
   \   00000014   04509CE5           LDR      R5,[R12, #+4]
   \   00000018   0D30A0E1           MOV      R3,SP
   \   0000001C   300083E8           STM      R3,{R4,R5}
    576          
    577            #ifdef WIN32
    578              LCDSIM_SetOrg(x, y, pDevice->LayerIndex);
    579            #else
    580              Data.xPos = x;
   \   00000020   00108DE5           STR      R1,[SP, #+0]
    581              Data.yPos = y;
   \   00000024   04208DE5           STR      R2,[SP, #+4]
    582              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETORG, (void *)&Data);
   \   00000028   0D20A0E1           MOV      R2,SP
   \   0000002C   0310A0E3           MOV      R1,#+3
   \   00000030   180090E5           LDR      R0,[R0, #+24]
   \   00000034   ........           BL       LCD_X_DisplayDriver
    583            #endif
    584          }
   \   00000038   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   0000003C   3080BDE8           POP      {R4,R5,PC}       ;; return
    585          
    586          /*********************************************************************
    587          *
    588          *       _InitOnce
    589          *
    590          * Purpose:
    591          *   Allocates a fixed block for the context of the driver
    592          *
    593          * Return value:
    594          *   0 on success, 1 on error
    595          */
    596          static int _InitOnce(GUI_DEVICE * pDevice) {
    597            if (pDevice->u.pContext == NULL) {
    598              pDevice->u.pContext = GUI_ALLOC_GetFixedBlock(sizeof(DRIVER_CONTEXT));
    599              GUI__memset((U8 *)pDevice->u.pContext, 0, sizeof(DRIVER_CONTEXT));
    600            }
    601            return pDevice->u.pContext ? 0 : 1;
    602          }
    603          
    604          /*********************************************************************
    605          *
    606          *       _GetRect
    607          */

   \                                 In section .text, align 4, keep-with-next
    608          static void _GetRect(GUI_DEVICE * pDevice, LCD_RECT * pRect) {
    609            DRIVER_CONTEXT * pContext;
    610          
    611            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetRect:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    612            pRect->x0 = 0;
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   B020C1E1           STRH     R2,[R1, #+0]
    613            pRect->y0 = 0;
   \   0000000C   B220C1E1           STRH     R2,[R1, #+2]
    614            pRect->x1 = pContext->vxSize - 1;
   \   00000010   0C2090E5           LDR      R2,[R0, #+12]
   \   00000014   012042E2           SUB      R2,R2,#+1
   \   00000018   B420C1E1           STRH     R2,[R1, #+4]
    615            pRect->y1 = pContext->vySize - 1;
   \   0000001C   100090E5           LDR      R0,[R0, #+16]
   \   00000020   010040E2           SUB      R0,R0,#+1
   \   00000024   B600C1E1           STRH     R0,[R1, #+6]
    616          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
    617          
    618          /*********************************************************************
    619          *
    620          *       _GetDevProp
    621          */

   \                                 In section .text, align 4, keep-with-next
    622          static I32 _GetDevProp(GUI_DEVICE * pDevice, int Index) {
    623            DRIVER_CONTEXT * pContext;
    624          
    625            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    626            switch (Index) {
   \                     _GetDevProp:
   \   00000000   011041E2           SUB      R1,R1,#+1
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   0D0051E3           CMP      R1,#+13
   \   0000000C   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevProp_0:
   \   00000010   1B00008A           BHI      ??_GetDevProp_1
   \   00000014   0C0000EA           B        ??_GetDevProp_2
   \   00000018   0D0000EA           B        ??_GetDevProp_3
   \   0000001C   0E0000EA           B        ??_GetDevProp_4
   \   00000020   0F0000EA           B        ??_GetDevProp_5
   \   00000024   160000EA           B        ??_GetDevProp_1
   \   00000028   150000EA           B        ??_GetDevProp_1
   \   0000002C   140000EA           B        ??_GetDevProp_1
   \   00000030   0D0000EA           B        ??_GetDevProp_6
   \   00000034   0E0000EA           B        ??_GetDevProp_7
   \   00000038   0F0000EA           B        ??_GetDevProp_8
   \   0000003C   0E0000EA           B        ??_GetDevProp_8
   \   00000040   0B0000EA           B        ??_GetDevProp_7
   \   00000044   0A0000EA           B        ??_GetDevProp_7
   \   00000048   090000EA           B        ??_GetDevProp_7
    627            case LCD_DEVCAP_XSIZE:
    628              return pContext->xSize;
   \                     ??_GetDevProp_2:
   \   0000004C   040090E5           LDR      R0,[R0, #+4]
   \   00000050   1EFF2FE1           BX       LR
    629            case LCD_DEVCAP_YSIZE:
    630              return pContext->ySize;
   \                     ??_GetDevProp_3:
   \   00000054   080090E5           LDR      R0,[R0, #+8]
   \   00000058   1EFF2FE1           BX       LR
    631            case LCD_DEVCAP_VXSIZE:
    632              return pContext->vxSize;
   \                     ??_GetDevProp_4:
   \   0000005C   0C0090E5           LDR      R0,[R0, #+12]
   \   00000060   1EFF2FE1           BX       LR
    633            case LCD_DEVCAP_VYSIZE:
    634              return pContext->vySize;
   \                     ??_GetDevProp_5:
   \   00000064   100090E5           LDR      R0,[R0, #+16]
   \   00000068   1EFF2FE1           BX       LR
    635            case LCD_DEVCAP_BITSPERPIXEL:
    636              return 32;
   \                     ??_GetDevProp_6:
   \   0000006C   2000A0E3           MOV      R0,#+32
   \   00000070   1EFF2FE1           BX       LR
    637            case LCD_DEVCAP_NUMCOLORS:
    638              return 0;
   \                     ??_GetDevProp_7:
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   1EFF2FE1           BX       LR
    639            case LCD_DEVCAP_XMAG:
    640              return 1;
   \                     ??_GetDevProp_8:
   \   0000007C   0100A0E3           MOV      R0,#+1
   \   00000080   1EFF2FE1           BX       LR
    641            case LCD_DEVCAP_YMAG:
    642              return 1;
    643            case LCD_DEVCAP_MIRROR_X:
    644              return 0;
    645            case LCD_DEVCAP_MIRROR_Y:
    646              return 0;
    647            case LCD_DEVCAP_SWAP_XY:
    648              return 0;
    649            }
    650            return -1;
   \                     ??_GetDevProp_1:
   \   00000084   0000E0E3           MVN      R0,#+0
   \   00000088   1EFF2FE1           BX       LR               ;; return
    651          }
    652          
    653          /*********************************************************************
    654          *
    655          *       _GetDevData
    656          */

   \                                 In section .text, align 4, keep-with-next
    657          static void * _GetDevData(GUI_DEVICE * pDevice, int Index) {
    658            GUI_USE_PARA(pDevice);
    659            switch (Index) {
   \                     _GetDevData:
   \   00000000   010051E3           CMP      R1,#+1
   \   00000004   0100001A           BNE      ??_GetDevData_0
    660            #if GUI_SUPPORT_MEMDEV
    661              case LCD_DEVDATA_MEMDEV:
    662                return (void *)&GUI_MEMDEV_DEVICE_32;
   \   00000008   ........           LDR      R0,??DataTable17_1
   \   0000000C   1EFF2FE1           BX       LR
    663            #endif
    664            }
    665            return NULL;
   \                     ??_GetDevData_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
    666          }
    667          
    668          /*********************************************************************
    669          *
    670          *       Static code: Functions available by _GetDevFunc()
    671          *
    672          **********************************************************************
    673          */
    674          /*********************************************************************
    675          *
    676          *       _ReadRect
    677          */

   \                                 In section .text, align 4, keep-with-next
    678          static void _ReadRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer) {
   \                     _ReadRect:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   10C09DE5           LDR      R12,[SP, #+16]
   \   00000008   14E09DE5           LDR      LR,[SP, #+20]
    679            DRIVER_CONTEXT * pContext;
    680            U32 Off;
    681            int x, NumPixelsPerLine;
    682            U32 * p;
    683          
    684            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   0000000C   080090E5           LDR      R0,[R0, #+8]
    685            p = (U32 *)pBuffer;
    686            x = x0;
   \   00000010   0140A0E1           MOV      R4,R1
    687            do {
    688              Off = XY2OFF32(pContext->vxSizePhys, x0, y0);
    689              NumPixelsPerLine = x1 - x0 + 1;
   \                     ??_ReadRect_0:
   \   00000014   146090E5           LDR      R6,[R0, #+20]
   \   00000018   015043E0           SUB      R5,R3,R1
   \   0000001C   961221E0           MLA      R1,R6,R2,R1
   \   00000020   015085E2           ADD      R5,R5,#+1
   \   00000024   0111A0E1           LSL      R1,R1,#+2
    690              do {
    691                *p++ = READ_MEM32(pContext->VRAMAddr, Off);
   \                     ??_ReadRect_1:
   \   00000028   006090E5           LDR      R6,[R0, #+0]
    692                Off++;
    693              } while (--NumPixelsPerLine);
   \   0000002C   015045E2           SUB      R5,R5,#+1
   \   00000030   066091E7           LDR      R6,[R1, +R6]
   \   00000034   041081E2           ADD      R1,R1,#+4
   \   00000038   04608EE4           STR      R6,[LR], #+4
   \   0000003C   000055E3           CMP      R5,#+0
   \   00000040   F8FFFF1A           BNE      ??_ReadRect_1
    694              x0 = x;
    695            } while (y0++ < y1);
   \   00000044   0250A0E1           MOV      R5,R2
   \   00000048   0410A0E1           MOV      R1,R4
   \   0000004C   012085E2           ADD      R2,R5,#+1
   \   00000050   0C0055E1           CMP      R5,R12
   \   00000054   EEFFFFBA           BLT      ??_ReadRect_0
    696          }
   \   00000058   7080BDE8           POP      {R4-R6,PC}       ;; return
    697          
    698          /*********************************************************************
    699          *
    700          *       _SetVRAMAddr
    701          */

   \                                 In section .text, align 4, keep-with-next
    702          static void _SetVRAMAddr(GUI_DEVICE * pDevice, void * pVRAM) {
   \                     _SetVRAMAddr:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    703            DRIVER_CONTEXT * pContext;
    704            LCD_X_SETVRAMADDR_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {(void *)0}>`
   \              ....        
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   001091E5           LDR      R1,[R1, #+0]
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
    705          
    706            _InitOnce(pDevice);
   \   00000020   080094E5           LDR      R0,[R4, #+8]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0500001A           BNE      ??_SetVRAMAddr_0
   \   0000002C   2C00A0E3           MOV      R0,#+44
   \   00000030   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000034   080084E5           STR      R0,[R4, #+8]
   \   00000038   2C20A0E3           MOV      R2,#+44
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   ........           BL       GUI__memset
    707            if (pDevice->u.pContext) {
   \                     ??_SetVRAMAddr_0:
   \   00000044   080094E5           LDR      R0,[R4, #+8]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0500000A           BEQ      ??_SetVRAMAddr_1
    708              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    709              pContext->VRAMAddr = (U32)pVRAM;
   \   00000050   005080E5           STR      R5,[R0, #+0]
    710              Data.pVRAM = pVRAM;
   \   00000054   00508DE5           STR      R5,[SP, #+0]
    711              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVRAMADDR, (void *)&Data);
   \   00000058   0D20A0E1           MOV      R2,SP
   \   0000005C   0210A0E3           MOV      R1,#+2
   \   00000060   180094E5           LDR      R0,[R4, #+24]
   \   00000064   ........           BL       LCD_X_DisplayDriver
    712            }
    713            #ifdef WIN32
    714              SIM_Lin_SetVRAMAddr(pDevice->LayerIndex, pVRAM);
    715            #endif
    716          }
   \                     ??_SetVRAMAddr_1:
   \   00000068   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000006C   3080BDE8           POP      {R4,R5,PC}       ;; return
    717          
    718          /*********************************************************************
    719          *
    720          *       _SetVSize
    721          */

   \                                 In section .text, align 4, keep-with-next
    722          static void _SetVSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetVSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    723            DRIVER_CONTEXT * pContext;
    724          
    725            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetVSize_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
    726            if (pDevice->u.pContext) {
   \                     ??_SetVSize_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
    727              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    728              pContext->vxSize = xSize;
   \   0000003C   0C508015           STRNE    R5,[R0, #+12]
    729              pContext->vySize = ySize;
   \   00000040   10608015           STRNE    R6,[R0, #+16]
    730              pContext->vxSizePhys = xSize;
   \   00000044   14508015           STRNE    R5,[R0, #+20]
    731            }
    732            #ifdef WIN32
    733              SIM_Lin_SetVRAMSize(pDevice->LayerIndex, xSize, ySize);
    734            #endif
    735          }
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
    736          
    737          /*********************************************************************
    738          *
    739          *       _SetSize
    740          */

   \                                 In section .text, align 4, keep-with-next
    741          static void _SetSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    742            DRIVER_CONTEXT * pContext;
    743            LCD_X_SETSIZE_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_1`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
    744          
    745            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetSize_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
    746            if (pDevice->u.pContext) {
   \                     ??_SetSize_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0A00000A           BEQ      ??_SetSize_1
    747              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    748              if (pContext->vxSizePhys == 0) {
   \   0000005C   141090E5           LDR      R1,[R0, #+20]
    749                pContext->vxSizePhys = xSize;
    750              }
    751              pContext->xSize = xSize;
    752              pContext->ySize = ySize;
    753              Data.xSize = xSize;
    754              Data.ySize = ySize;
    755              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETSIZE, (void *)&Data);
   \   00000060   0D20A0E1           MOV      R2,SP
   \   00000064   000051E3           CMP      R1,#+0
   \   00000068   14508005           STREQ    R5,[R0, #+20]
   \   0000006C   045080E5           STR      R5,[R0, #+4]
   \   00000070   086080E5           STR      R6,[R0, #+8]
   \   00000074   00508DE5           STR      R5,[SP, #+0]
   \   00000078   04608DE5           STR      R6,[SP, #+4]
   \   0000007C   0710A0E3           MOV      R1,#+7
   \   00000080   180094E5           LDR      R0,[R4, #+24]
   \   00000084   ........           BL       LCD_X_DisplayDriver
    756            }
    757          }
   \                     ??_SetSize_1:
   \   00000088   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   0000008C   7080BDE8           POP      {R4-R6,PC}       ;; return
    758          
    759          /*********************************************************************
    760          *
    761          *       _SetPos
    762          */

   \                                 In section .text, align 4, keep-with-next
    763          static void _SetPos(GUI_DEVICE * pDevice, int xPos, int yPos) {
   \                     _SetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    764            DRIVER_CONTEXT * pContext;
    765            LCD_X_SETPOS_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_2`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
    766          
    767            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetPos_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
    768            if (pDevice->u.pContext) {
   \                     ??_SetPos_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0700000A           BEQ      ??_SetPos_1
    769              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    770              pContext->xPos = xPos;
   \   0000005C   185080E5           STR      R5,[R0, #+24]
    771              pContext->yPos = yPos;
   \   00000060   1C6080E5           STR      R6,[R0, #+28]
    772              Data.xPos = xPos;
   \   00000064   00508DE5           STR      R5,[SP, #+0]
    773              Data.yPos = yPos;
   \   00000068   04608DE5           STR      R6,[SP, #+4]
    774              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETPOS, (void *)&Data);
   \   0000006C   0D20A0E1           MOV      R2,SP
   \   00000070   0810A0E3           MOV      R1,#+8
   \   00000074   180094E5           LDR      R0,[R4, #+24]
   \   00000078   ........           BL       LCD_X_DisplayDriver
    775            }
    776          }
   \                     ??_SetPos_1:
   \   0000007C   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000080   7080BDE8           POP      {R4-R6,PC}       ;; return
    777          
    778          /*********************************************************************
    779          *
    780          *       _GetPos
    781          */

   \                                 In section .text, align 4, keep-with-next
    782          static void _GetPos(GUI_DEVICE * pDevice, int * pxPos, int * pyPos) {
   \                     _GetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    783            DRIVER_CONTEXT * pContext;
    784          
    785            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_GetPos_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
    786            if (pDevice->u.pContext) {
   \                     ??_GetPos_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0300000A           BEQ      ??_GetPos_1
    787              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    788              *pxPos = pContext->xPos;
   \   00000040   181090E5           LDR      R1,[R0, #+24]
   \   00000044   001085E5           STR      R1,[R5, #+0]
    789              *pyPos = pContext->yPos;
   \   00000048   1C0090E5           LDR      R0,[R0, #+28]
   \   0000004C   000086E5           STR      R0,[R6, #+0]
    790            }
    791          }
   \                     ??_GetPos_1:
   \   00000050   7080BDE8           POP      {R4-R6,PC}       ;; return
    792          
    793          /*********************************************************************
    794          *
    795          *       _SetAlpha
    796          */

   \                                 In section .text, align 4, keep-with-next
    797          static void _SetAlpha(GUI_DEVICE * pDevice, int Alpha) {
   \                     _SetAlpha:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    798            DRIVER_CONTEXT * pContext;
    799            LCD_X_SETALPHA_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_3`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
    800          
    801            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetAlpha_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
    802            if (pDevice->u.pContext) {
   \                     ??_SetAlpha_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetAlpha_1
    803              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    804              pContext->Alpha = Alpha;
   \   0000004C   205080E5           STR      R5,[R0, #+32]
    805              Data.Alpha = Alpha;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
    806              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHA, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0A10A0E3           MOV      R1,#+10
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
    807            }
    808          }
   \                     ??_SetAlpha_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
    809          
    810          /*********************************************************************
    811          *
    812          *       _SetVis
    813          */

   \                                 In section .text, align 4, keep-with-next
    814          static void _SetVis(GUI_DEVICE * pDevice, int OnOff) {
   \                     _SetVis:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    815            DRIVER_CONTEXT * pContext;
    816            LCD_X_SETVIS_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_4`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
    817          
    818            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetVis_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
    819            if (pDevice->u.pContext) {
   \                     ??_SetVis_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetVis_1
    820              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    821              pContext->IsVisible = OnOff;
   \   0000004C   245080E5           STR      R5,[R0, #+36]
    822              Data.OnOff = OnOff;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
    823              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVIS, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0910A0E3           MOV      R1,#+9
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
    824            }
    825          }
   \                     ??_SetVis_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
    826          
    827          /*********************************************************************
    828          *
    829          *       _Init
    830          */

   \                                 In section .text, align 4, keep-with-next
    831          static int  _Init(GUI_DEVICE * pDevice) {
   \                     _Init:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    832            int r;
    833          
    834            r = _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0500001A           BNE      ??_Init_0
   \   00000018   2C00A0E3           MOV      R0,#+44
   \   0000001C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000020   080084E5           STR      R0,[R4, #+8]
   \   00000024   2C20A0E3           MOV      R2,#+44
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   ........           BL       GUI__memset
   \                     ??_Init_0:
   \   00000030   080094E5           LDR      R0,[R4, #+8]
    835            r |= LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_INITCONTROLLER, NULL);
    836            return r;
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0150A003           MOVEQ    R5,#+1
   \   00000040   0050A013           MOVNE    R5,#+0
   \   00000044   0110A0E3           MOV      R1,#+1
   \   00000048   180094E5           LDR      R0,[R4, #+24]
   \   0000004C   ........           BL       LCD_X_DisplayDriver
   \   00000050   050080E1           ORR      R0,R0,R5
   \   00000054   04D08DE2           ADD      SP,SP,#+4
   \   00000058   3080BDE8           POP      {R4,R5,PC}       ;; return
    837          }
    838          
    839          /*********************************************************************
    840          *
    841          *       _On
    842          */

   \                                 In section .text, align 4, keep-with-next
    843          static void _On (GUI_DEVICE * pDevice) {
    844            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_ON, NULL);
   \                     _On:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0510A0E3           MOV      R1,#+5
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
    845          }
    846          
    847          /*********************************************************************
    848          *
    849          *       _Off
    850          */

   \                                 In section .text, align 4, keep-with-next
    851          static void _Off (GUI_DEVICE * pDevice) {
    852            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_OFF, NULL);
   \                     _Off:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0610A0E3           MOV      R1,#+6
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
    853          }
    854          
    855          /*********************************************************************
    856          *
    857          *       _SetLUTEntry
    858          */

   \                                 In section .text, align 4, keep-with-next
    859          static void _SetLUTEntry(GUI_DEVICE * pDevice, U8 Pos, LCD_COLOR Color) {
   \                     _SetLUTEntry:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    860            LCD_X_SETLUTENTRY_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
    861          
    862            Data.Pos   = Pos;
   \   0000001C   0410CDE5           STRB     R1,[SP, #+4]
    863            Data.Color = Color;
   \   00000020   00208DE5           STR      R2,[SP, #+0]
    864            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETLUTENTRY, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0410A0E3           MOV      R1,#+4
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
    865          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
    866          
    867          /*********************************************************************
    868          *
    869          *       _SetAlphaMode
    870          */

   \                                 In section .text, align 4, keep-with-next
    871          static void _SetAlphaMode(GUI_DEVICE * pDevice, int AlphaMode) {
   \                     _SetAlphaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
    872            LCD_X_SETALPHAMODE_INFO Data = {0};
    873          
    874            Data.AlphaMode = AlphaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
    875            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0B10A0E3           MOV      R1,#+11
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
    876          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
    877          
    878          /*********************************************************************
    879          *
    880          *       _SetChromaMode
    881          */

   \                                 In section .text, align 4, keep-with-next
    882          static void _SetChromaMode(GUI_DEVICE * pDevice, int ChromaMode) {
   \                     _SetChromaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
    883            LCD_X_SETCHROMAMODE_INFO Data = {0};
    884          
    885            Data.ChromaMode = ChromaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
    886            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0C10A0E3           MOV      R1,#+12
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
    887          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
    888          
    889          /*********************************************************************
    890          *
    891          *       _SetChroma
    892          */

   \                                 In section .text, align 4, keep-with-next
    893          static void _SetChroma(GUI_DEVICE * pDevice, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax) {
   \                     _SetChroma:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    894            LCD_X_SETCHROMA_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>_1`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
    895          
    896            Data.ChromaMin = ChromaMin;
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
    897            Data.ChromaMax = ChromaMax;
   \   00000020   04208DE5           STR      R2,[SP, #+4]
    898            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMA, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0D10A0E3           MOV      R1,#+13
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
    899          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
    900          
    901          /*********************************************************************
    902          *
    903          *       _SetFunc
    904          */

   \                                 In section .text, align 4, keep-with-next
    905          static void _SetFunc(GUI_DEVICE * pDevice, int Index, void (* pFunc)(void)) {
   \                     _SetFunc:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    906            DRIVER_CONTEXT * pContext;
    907          
    908            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetFunc_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
    909            if (pDevice->u.pContext) {
   \                     ??_SetFunc_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0100000A           BEQ      ??_SetFunc_1
    910              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    911              switch (Index) {
   \   00000040   170055E3           CMP      R5,#+23
    912              case LCD_DEVFUNC_FILLRECT:
    913                pContext->pfFillRect = (void (*)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex))pFunc;
   \   00000044   28608005           STREQ    R6,[R0, #+40]
    914                break;
    915              }
    916            }
    917          }
   \                     ??_SetFunc_1:
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
    918          
    919          /*********************************************************************
    920          *
    921          *       _GetDevFunc
    922          */

   \                                 In section .text, align 4, keep-with-next
    923          static void (* _GetDevFunc(GUI_DEVICE ** ppDevice, int Index))(void) {
    924            GUI_USE_PARA(ppDevice);
    925            switch (Index) {
   \                     _GetDevFunc:
   \   00000000   011041E2           SUB      R1,R1,#+1
   \   00000004   150051E3           CMP      R1,#+21
   \   00000008   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevFunc_0:
   \   0000000C   3500008A           BHI      ??_GetDevFunc_1
   \   00000010   140000EA           B        ??_GetDevFunc_2
   \   00000014   1F0000EA           B        ??_GetDevFunc_3
   \   00000018   1A0000EA           B        ??_GetDevFunc_4
   \   0000001C   1B0000EA           B        ??_GetDevFunc_5
   \   00000020   300000EA           B        ??_GetDevFunc_1
   \   00000024   1D0000EA           B        ??_GetDevFunc_6
   \   00000028   2E0000EA           B        ??_GetDevFunc_1
   \   0000002C   2D0000EA           B        ??_GetDevFunc_1
   \   00000030   0E0000EA           B        ??_GetDevFunc_7
   \   00000034   0F0000EA           B        ??_GetDevFunc_8
   \   00000038   100000EA           B        ??_GetDevFunc_9
   \   0000003C   190000EA           B        ??_GetDevFunc_10
   \   00000040   280000EA           B        ??_GetDevFunc_1
   \   00000044   190000EA           B        ??_GetDevFunc_11
   \   00000048   1A0000EA           B        ??_GetDevFunc_12
   \   0000004C   1B0000EA           B        ??_GetDevFunc_13
   \   00000050   240000EA           B        ??_GetDevFunc_1
   \   00000054   230000EA           B        ??_GetDevFunc_1
   \   00000058   1A0000EA           B        ??_GetDevFunc_14
   \   0000005C   1B0000EA           B        ??_GetDevFunc_15
   \   00000060   1C0000EA           B        ??_GetDevFunc_16
   \   00000064   1D0000EA           B        ??_GetDevFunc_17
    926            case LCD_DEVFUNC_READRECT:
    927              return (void (*)(void))_ReadRect;
   \                     ??_GetDevFunc_2:
   \   00000068   ........           LDR      R0,??DataTable17_2
   \   0000006C   1EFF2FE1           BX       LR
    928            case LCD_DEVFUNC_SET_VRAM_ADDR:
    929              return (void (*)(void))_SetVRAMAddr;
   \                     ??_GetDevFunc_7:
   \   00000070   ........           LDR      R0,??DataTable17_3
   \   00000074   1EFF2FE1           BX       LR
    930            case LCD_DEVFUNC_SET_VSIZE:
    931              return (void (*)(void))_SetVSize;
   \                     ??_GetDevFunc_8:
   \   00000078   ........           LDR      R0,??DataTable17_4
   \   0000007C   1EFF2FE1           BX       LR
    932            case LCD_DEVFUNC_SET_SIZE:
    933              return (void (*)(void))_SetSize;
   \                     ??_GetDevFunc_9:
   \   00000080   ........           LDR      R0,??DataTable17_5
   \   00000084   1EFF2FE1           BX       LR
    934            case LCD_DEVFUNC_SETPOS:
    935              return (void (*)(void))_SetPos;
   \                     ??_GetDevFunc_4:
   \   00000088   ........           LDR      R0,??DataTable17_6
   \   0000008C   1EFF2FE1           BX       LR
    936            case LCD_DEVFUNC_GETPOS:
    937              return (void (*)(void))_GetPos;
   \                     ??_GetDevFunc_5:
   \   00000090   ........           LDR      R0,??DataTable17_7
   \   00000094   1EFF2FE1           BX       LR
    938            case LCD_DEVFUNC_SETALPHA:
    939              return (void (*)(void))_SetAlpha;
   \                     ??_GetDevFunc_3:
   \   00000098   ........           LDR      R0,??DataTable17_8
   \   0000009C   1EFF2FE1           BX       LR
    940            case LCD_DEVFUNC_SETVIS:
    941              return (void (*)(void))_SetVis;
   \                     ??_GetDevFunc_6:
   \   000000A0   ........           LDR      R0,??DataTable17_9
   \   000000A4   1EFF2FE1           BX       LR
    942            case LCD_DEVFUNC_INIT:
    943              return (void (*)(void))_Init;
   \                     ??_GetDevFunc_10:
   \   000000A8   ........           LDR      R0,??DataTable17_10
   \   000000AC   1EFF2FE1           BX       LR
    944            case LCD_DEVFUNC_ON:
    945              return (void (*)(void))_On;
   \                     ??_GetDevFunc_11:
   \   000000B0   ........           LDR      R0,??DataTable17_11
   \   000000B4   1EFF2FE1           BX       LR
    946            case LCD_DEVFUNC_OFF:
    947              return (void (*)(void))_Off;
   \                     ??_GetDevFunc_12:
   \   000000B8   ........           LDR      R0,??DataTable17_12
   \   000000BC   1EFF2FE1           BX       LR
    948            case LCD_DEVFUNC_SETLUTENTRY:
    949              return (void (*)(void))_SetLUTEntry;
   \                     ??_GetDevFunc_13:
   \   000000C0   ........           LDR      R0,??DataTable17_13
   \   000000C4   1EFF2FE1           BX       LR
    950          
    951            case LCD_DEVFUNC_ALPHAMODE:
    952              return (void (*)(void))_SetAlphaMode;
   \                     ??_GetDevFunc_14:
   \   000000C8   ........           LDR      R0,??DataTable17_14
   \   000000CC   1EFF2FE1           BX       LR
    953            case LCD_DEVFUNC_CHROMAMODE:
    954              return (void (*)(void))_SetChromaMode;
   \                     ??_GetDevFunc_15:
   \   000000D0   ........           LDR      R0,??DataTable17_15
   \   000000D4   1EFF2FE1           BX       LR
    955            case LCD_DEVFUNC_CHROMA:
    956              return (void (*)(void))_SetChroma;
   \                     ??_GetDevFunc_16:
   \   000000D8   ........           LDR      R0,??DataTable17_16
   \   000000DC   1EFF2FE1           BX       LR
    957            
    958            case LCD_DEVFUNC_SETFUNC:
    959              return (void (*)(void))_SetFunc;
   \                     ??_GetDevFunc_17:
   \   000000E0   ........           LDR      R0,??DataTable17_17
   \   000000E4   1EFF2FE1           BX       LR
    960            }
    961            return NULL;
   \                     ??_GetDevFunc_1:
   \   000000E8   0000A0E3           MOV      R0,#+0
   \   000000EC   1EFF2FE1           BX       LR               ;; return
    962          }
    963          
    964          /*********************************************************************
    965          *
    966          *       Public data
    967          *
    968          **********************************************************************
    969          */
    970          /*********************************************************************
    971          *
    972          *       GUI_DEVICE_API structure
    973          */

   \                                 In section .rodata, align 4, keep-with-next
    974          const GUI_DEVICE_API GUIDRV_Lin_32_API = {
   \                     GUIDRV_Lin_32_API:
   \   00000000                      ; Initializer data, 52 bytes
   \   00000000   00000000....       DC32 0, _DrawBitmap, _DrawHLine, _DrawVLine, _FillRect, _GetPixelIndex, _SetPixelIndex, _XorPixel, _SetOrg, _GetDevFunc
   \              ............
   \              ............
   \              ............
   \              ............
   \              ............
   \              ........    
   \   00000028   ............       DC32 _GetDevProp, _GetDevData, _GetRect
   \              ............

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   ........           DC32     LCD_aMirror

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   ........           DC32     GUI_MEMDEV_DEVICE_32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   ........           DC32     _ReadRect

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   ........           DC32     _SetVRAMAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   ........           DC32     _SetVSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   ........           DC32     _SetSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   ........           DC32     _SetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   ........           DC32     _GetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   ........           DC32     _SetAlpha

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   ........           DC32     _SetVis

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   ........           DC32     _Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   ........           DC32     _On

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   ........           DC32     _Off

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   ........           DC32     _SetLUTEntry

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   ........           DC32     _SetAlphaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \   00000000   ........           DC32     _SetChromaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_16:
   \   00000000   ........           DC32     _SetChroma

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_17:
   \   00000000   ........           DC32     _SetFunc

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {(void *)0}>`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_2`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_3`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_4`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0
    975            //
    976            // Data
    977            //
    978            DEVICE_CLASS_DRIVER,
    979            //
    980            // Drawing functions
    981            //
    982            _DrawBitmap,
    983            _DrawHLine,
    984            _DrawVLine,
    985            _FillRect,
    986            _GetPixelIndex,
    987            _SetPixelIndex,
    988            _XorPixel,
    989            //
    990            // Set origin
    991            //
    992            _SetOrg,
    993            //
    994            // Request information
    995            //
    996            _GetDevFunc,
    997            _GetDevProp,
    998            _GetDevData,
    999            _GetRect,
   1000          };
   1001          
   1002          #else
   1003          
   1004          void GUIDRV_Lin_32_C(void);   // Avoid empty object files
   1005          void GUIDRV_Lin_32_C(void) {}
   1006          
   1007          #endif
   1008          
   1009          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     _DrawBitLine1BPP     32
     _DrawBitLine2BPP     16
     _DrawBitLine4BPP     16
     _DrawBitLine8BPP      8
     _DrawBitmap          56
     _DrawHLine           24
     _DrawVLine           24
     _FillRect            32
     _GetDevData           0
     _GetDevFunc           0
     _GetDevProp           0
     _GetPixelIndex        0
     _GetPos              16
     _GetRect              0
     _Init                16
     _Off                  8
     _On                   8
     _ReadRect            16
     _SetAlpha            16
     _SetAlphaMode         8
     _SetChroma           24
     _SetChromaMode        8
     _SetFunc             16
     _SetLUTEntry         24
     _SetOrg              24
     _SetPixelIndex        0
     _SetPos              24
     _SetSize             24
     _SetVRAMAddr         16
     _SetVSize            16
     _SetVis              16
     _XorPixel            24


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     _SetPixelIndex            24
     _GetPixelIndex            24
     _XorPixel                 84
     _DrawHLine               264
     _DrawVLine               172
     _FillRect                124
     _DrawBitLine1BPP         344
     _DrawBitLine2BPP         212
     _DrawBitLine4BPP         212
     _DrawBitLine8BPP         336
     _DrawBitmap             1092
     _SetOrg                   64
     _GetRect                  44
     _GetDevProp              140
     _GetDevData               24
     _ReadRect                 92
     _SetVRAMAddr             112
     _SetVSize                 76
     _SetSize                 144
     _SetPos                  132
     _GetPos                   84
     _SetAlpha                108
     _SetVis                  108
     _Init                     92
     _On                       16
     _Off                      16
     _SetLUTEntry              60
     _SetAlphaMode             36
     _SetChromaMode            36
     _SetChroma                60
     _SetFunc                  76
     _GetDevFunc              240
     GUIDRV_Lin_32_API         52
     ??DataTable16              4
     ??DataTable16_1            4
     ??DataTable17              4
     ??DataTable17_1            4
     ??DataTable17_2            4
     ??DataTable17_3            4
     ??DataTable17_4            4
     ??DataTable17_5            4
     ??DataTable17_6            4
     ??DataTable17_7            4
     ??DataTable17_8            4
     ??DataTable17_9            4
     ??DataTable17_10           4
     ??DataTable17_11           4
     ??DataTable17_12           4
     ??DataTable17_13           4
     ??DataTable17_14           4
     ??DataTable17_15           4
     ??DataTable17_16           4
     ??DataTable17_17           4
     ?<Constant {0}>            8
     ?<Constant {(void *)0}>    4
     ?<Constant {0}>_1          8
     ?<Constant {0}>_2          8
     ?<Constant {0}>_3          4
     ?<Constant {0}>_4          4
     ?<Constant {0L}>           8
     ?<Constant {0L}>_1         8

 
    52 bytes in section .rodata
 4 780 bytes in section .text
 
 4 780 bytes of CODE  memory
    52 bytes of CONST memory

Errors: none
Warnings: none
