###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:16:40 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\WM.c                                #
#    Command line =  C:\DUII\TargetHW\GUI\WM.c -D DEBUG=1 -D SDRAM_TARGET=1   #
#                    -D USB_IS_HIGH_SPEED -D NOPROFILER -D OS_TRACE=0 -D      #
#                    OS_VIEW_ENABLE=0 -lCN C:\DUII\TargetHW\Release\List\ -o  #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\WM.lst                     #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\WM.o                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\WM.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : WM.c
     19          Purpose     : Windows manager core
     20          ----------------------------------------------------------------------
     21          */
     22          
     23          #include <stddef.h>           /* needed for definition of NULL */
     24          //#include <string.h>           /* required for memset */
     25          
     26          #define WM_C
     27          #include "WM_Intern_ConfDep.h"

   \                                 In section .bss, align 4
     28          
     29          #if GUI_WINSUPPORT    /* If 0, WM will not generate any code */
     30          
     31          /*********************************************************************
     32          *
     33          *       Macro definitions
     34          *
     35          **********************************************************************
     36          */
     37          #define ASSIGN_IF_LESS(v0, v1) if (v1 < v0) v0 = v1
     38          
     39          /*********************************************************************
     40          *
     41          *       Type definitions
     42          *
     43          **********************************************************************
     44          */
     45          typedef struct {
     46            GUI_RECT ClientRect;
     47            GUI_RECT CurRect;
     48            int Cnt;
     49            int EntranceCnt;
     50          } WM_IVR_CONTEXT;
     51          
     52          /*********************************************************************
     53          *
     54          *       Public data
     55          *
     56          **********************************************************************
     57          */
     58          U8             WM_IsActive;
     59          U32            WM__CreateFlags;
     60          WM_HWIN        WM__ahCapture[GUI_NUM_LAYERS];
     61          WM_HWIN        WM__ahWinFocus[GUI_NUM_LAYERS];
     62          char           WM__CaptureReleaseAuto;
     63          WM_tfPollPID * WM_pfPollPID;
     64          U8             WM__PaintCallbackCnt;      /* Public for assertions only */
     65          
     66          #if WM_SUPPORT_TRANSPARENCY
     67            int          WM__TransWindowCnt;
     68            WM_HWIN      WM__hATransWindow;
     69          #endif
     70          
     71          #if WM_SUPPORT_DIAG
     72            void      (* WM__pfShowInvalid)(WM_HWIN hWin);
     73          #endif
     74          
     75          /*********************************************************************
     76          *
     77          *       Static data
     78          *
     79          **********************************************************************
     80          */
     81          static WM_HWIN        _NextDrawWin;
     82          static WM_IVR_CONTEXT _ClipContext;
   \                     _ClipContext:
   \   00000000                      DS8 24
   \   __absolute unsigned short WM__NumWindows
   \                     WM__NumWindows:
   \   00000018                      DS8 2
   \   __absolute unsigned short WM__NumInvalidWindows
   \                     WM__NumInvalidWindows:
   \   0000001A                      DS8 2
   \   __absolute unsigned int WM__TouchedLayer
   \                     WM__TouchedLayer:
   \   0000001C                      DS8 4
   \   __absolute GUI_HWIN WM__FirstWin
   \                     WM__FirstWin:
   \   00000020                      DS8 4
   \   __absolute WM_CRITICAL_HANDLE *WM__pFirstCriticalHandle
   \                     WM__pFirstCriticalHandle:
   \   00000024                      DS8 4
   \   __absolute GUI_HWIN WM__ahDesktopWin[16]
   \                     WM__ahDesktopWin:
   \   00000028                      DS8 64
   \   __absolute GUI_COLOR WM__aBkColor[16]
   \                     WM__aBkColor:
   \   00000068                      DS8 64
   \                     WM__CreateFlags:
   \   000000A8                      DS8 4
   \                     WM__ahCapture:
   \   000000AC                      DS8 64
   \                     WM__ahWinFocus:
   \   000000EC                      DS8 64
   \                     WM_pfPollPID:
   \   0000012C                      DS8 4
   \                     WM__TransWindowCnt:
   \   00000130                      DS8 4
   \                     WM__hATransWindow:
   \   00000134                      DS8 4
   \   00000138                      DS8 4
   \   0000013C                      DS8 4
   \                     WM_IsActive:
   \   00000140                      DS8 1
   \                     WM__PaintCallbackCnt:
   \   00000141                      DS8 1
   \   00000142                      DS8 1

   \                                 In section .bss, align 1
   \                     WM__CaptureReleaseAuto:
   \   00000000                      DS8 1
     83          static char           _IsInited;
     84          
     85          static int _DeleteWindows; // Is set to 1 if any window needs to be deleted within WM_Exec()
     86          
     87          /*********************************************************************
     88          *
     89          *       Static routines
     90          *
     91          **********************************************************************
     92          */
     93          /*********************************************************************
     94          *
     95          *       _CheckCriticalHandles
     96          *
     97          * Purpose:
     98          *   Checks the critical handles and resets the matching one
     99          */
    100          static void _CheckCriticalHandles(WM_HWIN hWin) {
    101            WM_CRITICAL_HANDLE * pCH;
    102          
    103            for (pCH = WM__pFirstCriticalHandle; pCH; pCH = pCH->pNext) {
    104              if (pCH->hWin == hWin) {
    105                pCH->hWin = 0;
    106              }
    107            }
    108          }
    109          
    110          /*********************************************************************
    111          *
    112          *       _DesktopHandle2Index
    113          *
    114          * Function:
    115          *   Convert the given desktop window into the display index.
    116          *
    117          * Return value:
    118          *   Desktop index if window handle is valid.
    119          *   else: -1
    120          */
    121          static int _DesktopHandle2Index(WM_HWIN hDesktop) {
    122          #if GUI_NUM_LAYERS > 1
    123            int i;
    124          
    125            for (i = 0; i < GUI_NUM_LAYERS; i++) {
    126              if (hDesktop == WM__ahDesktopWin[i]) {
    127                return i;
    128              }
    129            }
    130          #else
    131            if (hDesktop == WM__ahDesktopWin[0]) {
    132              return 0;
    133            }
    134          #endif
    135            return -1;
    136          }
    137          
    138          /*********************************************************************
    139          *
    140          *       _GetTopLevelWindow
    141          */
    142          #if GUI_NUM_LAYERS > 1
    143          static WM_HWIN _GetTopLevelWindow(WM_HWIN hWin) {
    144            WM_Obj * pWin;
    145            WM_HWIN hTop;
    146          
    147            while (hTop = hWin, pWin = WM_H2P(hWin), (hWin = pWin->hParent) != 0);
    148            return hTop;
    149          }
    150          #endif
    151          
    152          /*********************************************************************
    153          *
    154          *       ResetNextDrawWin
    155          
    156            When drawing, we have to start at the bottom window !
    157          */
    158          static void ResetNextDrawWin(void) {
    159            _NextDrawWin = WM_HWIN_NULL;
    160          }
    161          
    162          /*********************************************************************
    163          *
    164          *       _GethDrawWin
    165          *
    166          * Return Window being drawn.
    167          * Normally same as pAWin, except if overlaying transparent window is drawn
    168          *
    169          */
    170          static WM_HWIN _GethDrawWin(void) {
    171            WM_HWIN h;
    172          
    173            #if WM_SUPPORT_TRANSPARENCY
    174            if (WM__hATransWindow) {
    175              h = WM__hATransWindow;
    176            } else
    177            #endif
    178            {
    179              h = GUI_Context.hAWin;
    180            }
    181            return h;
    182          }
    183          
    184          /*********************************************************************
    185          *
    186          *       _SetClipRectUserIntersect
    187          */
    188          static void _SetClipRectUserIntersect(const GUI_RECT * prSrc) {
    189            if (GUI_Context.WM__pUserClipRect == NULL) {
    190              LCD_SetClipRectEx(prSrc);
    191            } else {
    192              GUI_RECT r;
    193              r = *GUI_Context.WM__pUserClipRect;             
    194              WM__Client2Screen(WM_H2P(_GethDrawWin()), &r);     /* Convert User ClipRect into screen coordinates */
    195              /* Set intersection as clip rect */    
    196              GUI__IntersectRect(&r, prSrc);
    197              LCD_SetClipRectEx(&r);
    198            }
    199          }
    200          
    201          /*********************************************************************
    202          *
    203          *       Public routines
    204          *
    205          **********************************************************************
    206          */
    207          /*********************************************************************
    208          *
    209          *       WM__InvalidateParent
    210          */

   \                                 In section .text, align 4, keep-with-next
    211          void WM__InvalidateParent(const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop) {
   \                     WM__InvalidateParent:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
    212            WM_Obj * pWin;
    213            U16 Flags;
    214          
    215            pWin = WM_HANDLE2PTR(hParent);
    216            Flags = (pWin->Status & WM_CF_STATIC) ? WM_SF_INVALID_DRAW : WM_SF_INVALID;
   \   00000010   0500A0E1           MOV      R0,R5
   \   00000014   ........           BL       GUI_ALLOC_h2p
   \   00000018   280090E5           LDR      R0,[R0, #+40]
    217            WM__InvalidateRect(pInvalidRect, hParent, hStop, Flags);
   \   0000001C   0620A0E1           MOV      R2,R6
   \   00000020   400B10E3           TST      R0,#0x10000
   \   00000024   403CA013           MOVNE    R3,#+16384
   \   00000028   2030A003           MOVEQ    R3,#+32
   \   0000002C   0510A0E1           MOV      R1,R5
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       WM__InvalidateRect
    218          }
   \   00000038   7080BDE8           POP      {R4-R6,PC}       ;; return
    219          
    220          /*********************************************************************
    221          *
    222          *       _Invalidate1Abs
    223          *
    224          *  Invalidate given window, using absolute coordinates
    225          */

   \                                 In section .text, align 4, keep-with-next
    226          static void _Invalidate1Abs(WM_HWIN hWin, const GUI_RECT * pRect, U16 Flags) {
   \                     _Invalidate1Abs:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
    227            GUI_RECT r;
    228            WM_Obj * pWin;
    229            int Status;
    230          
    231            pWin = WM_H2P(hWin);
   \   00000010   ........           BL       GUI_ALLOC_h2p
   \   00000014   0060A0E1           MOV      R6,R0
    232            Status = pWin->Status;
   \   00000018   280096E5           LDR      R0,[R6, #+40]
    233            if ((Status & WM_SF_ISVIS) == 0) {
   \   0000001C   020010E3           TST      R0,#0x2
   \   00000020   2D00000A           BEQ      ??_Invalidate1Abs_0
    234              return;   /* Window is not visible... we are done */
    235            }
    236            if (WM__RectIsNZ(pRect) == 0) {
   \   00000024   F410D4E1           LDRSH    R1,[R4, #+4]
   \   00000028   F020D4E1           LDRSH    R2,[R4, #+0]
   \   0000002C   020051E1           CMP      R1,R2
   \   00000030   290000BA           BLT      ??_Invalidate1Abs_0
   \   00000034   F610D4E1           LDRSH    R1,[R4, #+6]
   \   00000038   F220D4E1           LDRSH    R2,[R4, #+2]
   \   0000003C   020051E1           CMP      R1,R2
   \   00000040   250000BA           BLT      ??_Invalidate1Abs_0
    237              return;   /* Nothing to do ... */
    238            }
    239            if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
   \   00000044   0110A0E3           MOV      R1,#+1
   \   00000048   801E81E3           ORR      R1,R1,#0x800
   \   0000004C   000001E0           AND      R0,R1,R0
   \   00000050   010050E3           CMP      R0,#+1
   \   00000054   2000000A           BEQ      ??_Invalidate1Abs_0
    240              return;   /* Window is transparent; transparency may change... we are done, since background will be invalidated */
    241            }
    242            /* Calc affected area */
    243            GUI__IntersectRects(&r, pRect, &pWin->Rect);
   \   00000058   0620A0E1           MOV      R2,R6
   \   0000005C   0410A0E1           MOV      R1,R4
   \   00000060   0D00A0E1           MOV      R0,SP
   \   00000064   ........           BL       GUI__IntersectRects
    244            if (WM__RectIsNZ(&r)) {
   \   00000068   F400DDE1           LDRSH    R0,[SP, #+4]
   \   0000006C   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000070   010050E1           CMP      R0,R1
   \   00000074   180000BA           BLT      ??_Invalidate1Abs_0
   \   00000078   F600DDE1           LDRSH    R0,[SP, #+6]
   \   0000007C   F210DDE1           LDRSH    R1,[SP, #+2]
   \   00000080   010050E1           CMP      R0,R1
   \   00000084   140000BA           BLT      ??_Invalidate1Abs_0
    245              #if WM_SUPPORT_NOTIFY_VIS_CHANGED
    246                WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
    247              #endif
    248              if (pWin->Status & (WM_SF_INVALID | WM_SF_INVALID_DRAW)) {
   \   00000088   B802D6E1           LDRH     R0,[R6, #+40]
   \   0000008C   2010A0E3           MOV      R1,#+32
   \   00000090   401C81E3           ORR      R1,R1,#0x4000
   \   00000094   000011E1           TST      R1,R0
   \   00000098   0400000A           BEQ      ??_Invalidate1Abs_1
    249                GUI_MergeRect(&pWin->InvalidRect, &pWin->InvalidRect, &r);
   \   0000009C   0D20A0E1           MOV      R2,SP
   \   000000A0   081086E2           ADD      R1,R6,#+8
   \   000000A4   080086E2           ADD      R0,R6,#+8
   \   000000A8   ........           BL       GUI_MergeRect
   \   000000AC   0A0000EA           B        ??_Invalidate1Abs_0
    250              } else {
    251                pWin->InvalidRect = r;
   \                     ??_Invalidate1Abs_1:
   \   000000B0   080086E2           ADD      R0,R6,#+8
   \   000000B4   0D10A0E1           MOV      R1,SP
   \   000000B8   0820A0E3           MOV      R2,#+8
   \   000000BC   ........           BL       __aeabi_memcpy
    252                pWin->Status |= Flags;
   \   000000C0   280096E5           LDR      R0,[R6, #+40]
   \   000000C4   000085E1           ORR      R0,R5,R0
   \   000000C8   280086E5           STR      R0,[R6, #+40]
    253                WM__NumInvalidWindows++;
   \   000000CC   ........           LDR      R0,??DataTable7
   \   000000D0   BA11D0E1           LDRH     R1,[R0, #+26]
   \   000000D4   011081E2           ADD      R1,R1,#+1
   \   000000D8   BA11C0E1           STRH     R1,[R0, #+26]
   \                     ??_Invalidate1Abs_0:
   \   000000DC   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   000000E0   7080BDE8           POP      {R4-R6,PC}       ;; return
    254                /* Optional code: Call external routine to notify that drawing is required */
    255                #ifdef GUI_X_REDRAW
    256                if (_IsInited) {
    257                  r = pWin->Rect;
    258                  if (WM__ClipAtParentBorders(&r,  hWin)) {
    259                    GUI_X_REDRAW(); /* Call hook function to signal an invalidation */
    260                  }
    261                }
    262                #endif
    263                GUI_X_SIGNAL_EVENT();
    264              }
    265              /* Debug code: shows invalid areas */
    266              #if (WM_SUPPORT_DIAG)
    267                if (WM__pfShowInvalid) {
    268                  (WM__pfShowInvalid)(hWin);
    269                }
    270              #endif
    271            }
    272          }
    273          
    274          /*********************************************************************
    275          *
    276          *       WM__Invalidate1Abs
    277          *
    278          *  Invalidate given window, using absolute coordinates
    279          */

   \                                 In section .text, align 4, keep-with-next
    280          void WM__Invalidate1Abs(WM_HWIN hWin, const GUI_RECT * pRect) {
    281            _Invalidate1Abs(hWin, pRect, WM_SF_INVALID);
   \                     WM__Invalidate1Abs:
   \   00000000   2020A0E3           MOV      R2,#+32
   \   00000004   ........           B        _Invalidate1Abs  ;; tailcall
    282          }
    283          
    284          /*********************************************************************
    285          *
    286          *       WM__ClipAtParentBorders
    287          *
    288          * Function:
    289          *   Iterates over the window itself and all its ancestors.
    290          *   Intersects all rectangles to
    291          *   find out which part is actually visible.
    292          *   Reduces the rectangle to the visible area.
    293          *   This routines takes into account both the rectangles of the
    294          *   ancestors as well as the WM_SF_ISVIS flag.
    295          *
    296          * Parameters
    297          *   hWin    Obvious
    298          *   pRect   Pointer to the rectangle to be clipped. May not be NULL.
    299          *           The parameter is IN/OUT.
    300          *           Note that the rectangle is clipped only if the return
    301          *           value indicates a valid rectangle remains.
    302          *
    303          * Return value:
    304          *   1: Something is or may be visible.
    305          *   0: Nothing is visible (outside of ancestors, no desktop, hidden)
    306          */

   \                                 In section .text, align 4, keep-with-next
    307          int WM__ClipAtParentBorders(GUI_RECT * pRect, WM_HWIN hWin) {
   \                     WM__ClipAtParentBorders:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   000000EA           B        ??WM__ClipAtParentBorders_0
    308            WM_Obj * pWin;
    309          
    310            /* Iterate up the window hierarchy.
    311               If the window is invisible, we are done.
    312               Clip at parent boarders.
    313               We are done with iterating if hWin has no parent.
    314            */
    315            do {
    316              pWin = WM_H2P(hWin);
    317              if ((pWin->Status & WM_SF_ISVIS) == 0) {
    318                return 0;                     /* Invisible */
    319              }
    320              GUI__IntersectRect(pRect, &pWin->Rect);  /* And clip on borders */
    321              if (pWin->hParent == 0) {
    322                break;   /* hWin is now the top level window which has no parent */
    323              }
    324              hWin = pWin->hParent;                    /* Go one level up (parent)*/
   \                     ??WM__ClipAtParentBorders_1:
   \   00000010   0040A0E1           MOV      R4,R0
    325            } while (1);                               /* Only way out is in the loop. Required for efficiency, no bug, even though some compilers may complain. */
   \                     ??WM__ClipAtParentBorders_0:
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   ........           BL       GUI_ALLOC_h2p
   \   0000001C   0060A0E1           MOV      R6,R0
   \   00000020   2800D6E5           LDRB     R0,[R6, #+40]
   \   00000024   020010E3           TST      R0,#0x2
   \   00000028   0100001A           BNE      ??WM__ClipAtParentBorders_2
   \                     ??WM__ClipAtParentBorders_3:
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   7080BDE8           POP      {R4-R6,PC}
   \                     ??WM__ClipAtParentBorders_2:
   \   00000034   0610A0E1           MOV      R1,R6
   \   00000038   0500A0E1           MOV      R0,R5
   \   0000003C   ........           BL       GUI__IntersectRect
   \   00000040   180096E5           LDR      R0,[R6, #+24]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   F0FFFF1A           BNE      ??WM__ClipAtParentBorders_1
    326            
    327            /* Now check if the top level window is a desktop window. If it is not,
    328              then the window is not visible.
    329            */
    330            if (_DesktopHandle2Index(hWin) < 0) {
   \   0000004C   ........           LDR      R0,??DataTable7
   \   00000050   283090E5           LDR      R3,[R0, #+40]
   \   00000054   2C1080E2           ADD      R1,R0,#+44
   \   00000058   030054E1           CMP      R4,R3
   \   0000005C   1100000A           BEQ      ??WM__ClipAtParentBorders_4
   \   00000060   003091E5           LDR      R3,[R1, #+0]
   \   00000064   040080E2           ADD      R0,R0,#+4
   \   00000068   0120A0E3           MOV      R2,#+1
   \   0000006C   2C0080E2           ADD      R0,R0,#+44
   \   00000070   0710A0E3           MOV      R1,#+7
   \                     ??WM__ClipAtParentBorders_5:
   \   00000074   030054E1           CMP      R4,R3
   \   00000078   04C09014           LDRNE    R12,[R0], #+4
   \   0000007C   01208212           ADDNE    R2,R2,#+1
   \   00000080   0C005411           CMPNE    R4,R12
   \   00000084   0500000A           BEQ      ??WM__ClipAtParentBorders_6
   \   00000088   012082E2           ADD      R2,R2,#+1
   \   0000008C   043090E4           LDR      R3,[R0], #+4
   \   00000090   011051E2           SUBS     R1,R1,#+1
   \   00000094   F6FFFF1A           BNE      ??WM__ClipAtParentBorders_5
   \   00000098   030054E1           CMP      R4,R3
   \   0000009C   E2FFFF1A           BNE      ??WM__ClipAtParentBorders_3
   \                     ??WM__ClipAtParentBorders_6:
   \   000000A0   000052E3           CMP      R2,#+0
   \   000000A4   E0FFFF4A           BMI      ??WM__ClipAtParentBorders_3
    331              return 0;           /* No desktop - (unattached) - Nothing to draw */
    332            }
    333            return 1;               /* Something may be visible */
   \                     ??WM__ClipAtParentBorders_4:
   \   000000A8   0100A0E3           MOV      R0,#+1
   \   000000AC   7080BDE8           POP      {R4-R6,PC}       ;; return
    334          }
    335          
    336          /*********************************************************************
    337          *
    338          *       WM__ActivateClipRect
    339          */

   \                                 In section .text, align 4, keep-with-next
    340          void  WM__ActivateClipRect(void) {
   \                     WM__ActivateClipRect:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
    341            GUI_RECT r;
    342            WM_Obj * pAWin;
    343          
    344            if (WM_IsActive) {
   \   00000004   ........           LDR      R5,??DataTable7
   \   00000008   14D04DE2           SUB      SP,SP,#+20
   \   0000000C   4001D5E5           LDRB     R0,[R5, #+320]
   \   00000010   ........           LDR      R4,??DataTable9
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   1500000A           BEQ      ??WM__ActivateClipRect_0
    345              _SetClipRectUserIntersect(&_ClipContext.CurRect);
   \   0000001C   381094E5           LDR      R1,[R4, #+56]
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0F00000A           BEQ      ??WM__ActivateClipRect_1
   \   00000028   0D00A0E1           MOV      R0,SP
   \   0000002C   0820A0E3           MOV      R2,#+8
   \   00000030   ........           BL       __aeabi_memcpy
   \   00000034   340195E5           LDR      R0,[R5, #+308]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   3C009405           LDREQ    R0,[R4, #+60]
   \   00000040   ........           BL       GUI_ALLOC_h2p
   \   00000044   F220D0E1           LDRSH    R2,[R0, #+2]
   \   00000048   F010D0E1           LDRSH    R1,[R0, #+0]
   \   0000004C   0D00A0E1           MOV      R0,SP
   \   00000050   ........           BL       GUI_MoveRect
   \   00000054   081085E2           ADD      R1,R5,#+8
   \                     ??WM__ActivateClipRect_2:
   \   00000058   0D00A0E1           MOV      R0,SP
   \   0000005C   ........           BL       GUI__IntersectRect
   \   00000060   0D00A0E1           MOV      R0,SP
   \   00000064   380000EA           B        ??WM__ActivateClipRect_3
   \                     ??WM__ActivateClipRect_1:
   \   00000068   080085E2           ADD      R0,R5,#+8
   \   0000006C   ........           BL       LCD_SetClipRectEx
   \   00000070   360000EA           B        ??WM__ActivateClipRect_4
    346            } else {    /* Window manager disabled, typically because meory device is active */
    347              pAWin = WM_H2P(GUI_Context.hAWin);
    348              r = pAWin->Rect;
   \                     ??WM__ActivateClipRect_0:
   \   00000074   08608DE2           ADD      R6,SP,#+8
   \   00000078   3C0094E5           LDR      R0,[R4, #+60]
   \   0000007C   ........           BL       GUI_ALLOC_h2p
   \   00000080   0010A0E1           MOV      R1,R0
   \   00000084   0600A0E1           MOV      R0,R6
   \   00000088   0820A0E3           MOV      R2,#+8
   \   0000008C   ........           BL       __aeabi_memcpy
    349              #if WM_SUPPORT_TRANSPARENCY
    350                if (WM__hATransWindow) {
   \   00000090   346195E5           LDR      R6,[R5, #+308]
   \   00000094   000056E3           CMP      R6,#+0
   \   00000098   1A00000A           BEQ      ??WM__ActivateClipRect_5
    351                  WM__ClipAtParentBorders(&r, WM__hATransWindow);
   \   0000009C   000000EA           B        ??WM__ActivateClipRect_6
   \                     ??WM__ActivateClipRect_7:
   \   000000A0   0060A0E1           MOV      R6,R0
   \                     ??WM__ActivateClipRect_6:
   \   000000A4   0600A0E1           MOV      R0,R6
   \   000000A8   ........           BL       GUI_ALLOC_h2p
   \   000000AC   0070A0E1           MOV      R7,R0
   \   000000B0   2800D7E5           LDRB     R0,[R7, #+40]
   \   000000B4   020010E3           TST      R0,#0x2
   \   000000B8   1200000A           BEQ      ??WM__ActivateClipRect_5
   \   000000BC   0710A0E1           MOV      R1,R7
   \   000000C0   08008DE2           ADD      R0,SP,#+8
   \   000000C4   ........           BL       GUI__IntersectRect
   \   000000C8   180097E5           LDR      R0,[R7, #+24]
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   F2FFFF1A           BNE      ??WM__ActivateClipRect_7
   \   000000D4   282095E5           LDR      R2,[R5, #+40]
   \   000000D8   2C0085E2           ADD      R0,R5,#+44
   \   000000DC   020056E1           CMP      R6,R2
   \   000000E0   0800000A           BEQ      ??WM__ActivateClipRect_5
   \   000000E4   002090E5           LDR      R2,[R0, #+0]
   \   000000E8   300085E2           ADD      R0,R5,#+48
   \   000000EC   0710A0E3           MOV      R1,#+7
   \                     ??WM__ActivateClipRect_8:
   \   000000F0   020056E1           CMP      R6,R2
   \   000000F4   04309014           LDRNE    R3,[R0], #+4
   \   000000F8   03005611           CMPNE    R6,R3
   \   000000FC   04209014           LDRNE    R2,[R0], #+4
   \   00000100   01105112           SUBSNE   R1,R1,#+1
   \   00000104   F9FFFF1A           BNE      ??WM__ActivateClipRect_8
    352                }
    353              #endif
    354              /* Take UserClipRect into account */
    355              _SetClipRectUserIntersect(&r);
   \                     ??WM__ActivateClipRect_5:
   \   00000108   381094E5           LDR      R1,[R4, #+56]
   \   0000010C   000051E3           CMP      R1,#+0
   \   00000110   0C00000A           BEQ      ??WM__ActivateClipRect_9
   \   00000114   0D00A0E1           MOV      R0,SP
   \   00000118   0820A0E3           MOV      R2,#+8
   \   0000011C   ........           BL       __aeabi_memcpy
   \   00000120   340195E5           LDR      R0,[R5, #+308]
   \   00000124   000050E3           CMP      R0,#+0
   \   00000128   3C009405           LDREQ    R0,[R4, #+60]
   \   0000012C   ........           BL       GUI_ALLOC_h2p
   \   00000130   F220D0E1           LDRSH    R2,[R0, #+2]
   \   00000134   F010D0E1           LDRSH    R1,[R0, #+0]
   \   00000138   0D00A0E1           MOV      R0,SP
   \   0000013C   ........           BL       GUI_MoveRect
   \   00000140   08108DE2           ADD      R1,SP,#+8
   \   00000144   C3FFFFEA           B        ??WM__ActivateClipRect_2
   \                     ??WM__ActivateClipRect_9:
   \   00000148   08008DE2           ADD      R0,SP,#+8
   \                     ??WM__ActivateClipRect_3:
   \   0000014C   ........           BL       LCD_SetClipRectEx
    356            }
    357          }
   \                     ??WM__ActivateClipRect_4:
   \   00000150   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000154   F080BDE8           POP      {R4-R7,PC}       ;; return
    358          
    359          /*********************************************************************
    360          *
    361          *       WM__InsertWindowIntoList
    362          *
    363          * Routine describtion
    364          *   This routine inserts the window in the list of child windows for
    365          *   a particular parent window.
    366          *   The window is placed on top of all siblings with the same level.
    367          */

   \                                 In section .text, align 4, keep-with-next
    368          void WM__InsertWindowIntoList(WM_HWIN hWin, WM_HWIN hParent) {
   \                     WM__InsertWindowIntoList:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0160B0E1           MOVS     R6,R1
    369            int OnTop;
    370            WM_HWIN hi;
    371            WM_HWIN hNext;
    372            WM_Obj * pWin;
    373            WM_Obj * pParent;
    374            WM_Obj * pi;
    375            WM_Obj * pNext;
    376          
    377            if (hParent) {
   \   00000010   2600000A           BEQ      ??WM__InsertWindowIntoList_0
    378              pWin = WM_H2P(hWin);
   \   00000014   ........           BL       GUI_ALLOC_h2p
   \   00000018   0050A0E1           MOV      R5,R0
    379              pWin->hNext = 0;
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   200085E5           STR      R0,[R5, #+32]
    380              pWin->hParent = hParent;
   \   00000024   186085E5           STR      R6,[R5, #+24]
    381              pParent = WM_H2P(hParent);
   \   00000028   0600A0E1           MOV      R0,R6
   \   0000002C   ........           BL       GUI_ALLOC_h2p
   \   00000030   0080A0E1           MOV      R8,R0
    382              OnTop   = pWin->Status & WM_CF_STAYONTOP;
   \   00000034   2800D5E5           LDRB     R0,[R5, #+40]
    383              hi = pParent->hFirstChild;
   \   00000038   1C9098E5           LDR      R9,[R8, #+28]
   \   0000003C   086000E2           AND      R6,R0,#0x8
    384              /* Put it at beginning of the list if there is no child */
    385              if (hi == 0) {   /* No child yet ... Makes things easy ! */
   \   00000040   000059E3           CMP      R9,#+0
   \   00000044   0100001A           BNE      ??WM__InsertWindowIntoList_1
    386                pParent->hFirstChild = hWin;
   \                     ??WM__InsertWindowIntoList_2:
   \   00000048   1C4088E5           STR      R4,[R8, #+28]
    387                return;                         /* Early out ... We are done */
   \   0000004C   170000EA           B        ??WM__InsertWindowIntoList_0
    388              }
    389              /* Put it at beginning of the list if first child is a TOP window and new one is not */
    390              pi = WM_H2P(hi);
   \                     ??WM__InsertWindowIntoList_1:
   \   00000050   0900A0E1           MOV      R0,R9
   \   00000054   ........           BL       GUI_ALLOC_h2p
   \   00000058   0070A0E1           MOV      R7,R0
    391              if (!OnTop) {
   \   0000005C   000056E3           CMP      R6,#+0
   \   00000060   0500001A           BNE      ??WM__InsertWindowIntoList_3
    392                if (pi->Status & WM_SF_STAYONTOP) {
   \   00000064   2800D7E5           LDRB     R0,[R7, #+40]
   \   00000068   080010E3           TST      R0,#0x8
   \   0000006C   0200000A           BEQ      ??WM__InsertWindowIntoList_3
    393                  pWin->hNext = hi;
   \   00000070   209085E5           STR      R9,[R5, #+32]
    394                  pParent->hFirstChild = hWin;
   \   00000074   F3FFFFEA           B        ??WM__InsertWindowIntoList_2
    395                  return;                         /* Early out ... We are done */
    396                }
    397              }
    398              /* Put it at the end of the list or before the last non "STAY-ON-TOP" child */
    399              do {
    400                if ((hNext = pi->hNext) == 0) {   /* End of sibling list ? */
    401                  pi->hNext = hWin;             /* Then modify this last element to point to new one and we are done */
    402                  break;
    403                }
    404                pNext = WM_H2P(hNext);
    405                if (!OnTop) {
    406                  if (pNext->Status & WM_SF_STAYONTOP) {
    407                    pi->hNext = hWin;
    408                    pWin->hNext = hNext;
    409                    break;
    410                  }
    411                }
    412                pi = pNext;
   \                     ??WM__InsertWindowIntoList_4:
   \   00000078   0070A0E1           MOV      R7,R0
    413              }  while (1);
   \                     ??WM__InsertWindowIntoList_3:
   \   0000007C   208097E5           LDR      R8,[R7, #+32]
   \   00000080   000058E3           CMP      R8,#+0
   \   00000084   20408705           STREQ    R4,[R7, #+32]
   \   00000088   0800000A           BEQ      ??WM__InsertWindowIntoList_0
   \   0000008C   0800A0E1           MOV      R0,R8
   \   00000090   ........           BL       GUI_ALLOC_h2p
   \   00000094   000056E3           CMP      R6,#+0
   \   00000098   F6FFFF1A           BNE      ??WM__InsertWindowIntoList_4
   \   0000009C   2810D0E5           LDRB     R1,[R0, #+40]
   \   000000A0   080011E3           TST      R1,#0x8
   \   000000A4   F3FFFF0A           BEQ      ??WM__InsertWindowIntoList_4
   \   000000A8   204087E5           STR      R4,[R7, #+32]
   \   000000AC   208085E5           STR      R8,[R5, #+32]
   \                     ??WM__InsertWindowIntoList_0:
   \   000000B0   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000B4   F083BDE8           POP      {R4-R9,PC}       ;; return
    414              #if WM_SUPPORT_NOTIFY_VIS_CHANGED
    415                WM__NotifyVisChanged(hWin, &pWin->Rect);
    416              #endif
    417            }
    418          }
    419          
    420          /*********************************************************************
    421          *
    422          *       WM__RemoveWindowFromList
    423          */

   \                                 In section .text, align 4, keep-with-next
    424          void WM__RemoveWindowFromList(WM_HWIN hWin) {
   \                     WM__RemoveWindowFromList:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    425            WM_HWIN hi, hParent;
    426            WM_Obj * pWin;
    427            WM_Obj * pParent;
    428            WM_Obj * pi;
    429            
    430            pWin = WM_H2P(hWin);
   \   00000008   ........           BL       GUI_ALLOC_h2p
   \   0000000C   0050A0E1           MOV      R5,R0
    431            hParent = pWin->hParent;
   \   00000010   180095E5           LDR      R0,[R5, #+24]
    432            if (hParent) {
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   1200000A           BEQ      ??WM__RemoveWindowFromList_0
    433              pParent = WM_H2P(hParent);
   \   0000001C   ........           BL       GUI_ALLOC_h2p
   \   00000020   0060A0E1           MOV      R6,R0
    434              hi = pParent->hFirstChild;
   \   00000024   1C1096E5           LDR      R1,[R6, #+28]
    435              if (hi == hWin) {
   \   00000028   040051E1           CMP      R1,R4
   \   0000002C   0400001A           BNE      ??WM__RemoveWindowFromList_1
    436                pi = WM_H2P(hi);
    437                pParent->hFirstChild = pi->hNext;
   \   00000030   0100A0E1           MOV      R0,R1
   \   00000034   ........           BL       GUI_ALLOC_h2p
   \   00000038   200090E5           LDR      R0,[R0, #+32]
   \   0000003C   1C0086E5           STR      R0,[R6, #+28]
   \   00000040   7080BDE8           POP      {R4-R6,PC}
    438              } else {
    439                while (hi) {
    440                  pi = WM_H2P(hi);
    441                  if (pi->hNext == hWin) {
    442                    pi->hNext = pWin->hNext;
    443                    break;
    444                  }
    445                  hi = pi->hNext;
   \                     ??WM__RemoveWindowFromList_1:
   \   00000044   000051E3           CMP      R1,#+0
   \   00000048   0600000A           BEQ      ??WM__RemoveWindowFromList_0
   \   0000004C   0100A0E1           MOV      R0,R1
   \   00000050   ........           BL       GUI_ALLOC_h2p
   \   00000054   201090E5           LDR      R1,[R0, #+32]
   \   00000058   040051E1           CMP      R1,R4
   \   0000005C   F8FFFF1A           BNE      ??WM__RemoveWindowFromList_1
   \   00000060   201095E5           LDR      R1,[R5, #+32]
   \   00000064   201080E5           STR      R1,[R0, #+32]
    446                }
    447              }
    448            }
    449          }
   \                     ??WM__RemoveWindowFromList_0:
   \   00000068   7080BDE8           POP      {R4-R6,PC}       ;; return
    450          
    451          /*********************************************************************
    452          *
    453          *       WM__DetachWindow
    454          *
    455          * Detaches the given window. The window still exists, it keeps all
    456          * children, but it is no longer visible since it is taken out of
    457          * the tree of the desktop window.
    458          */

   \                                 In section .text, align 4, keep-with-next
    459          void WM__DetachWindow(WM_HWIN hWin) {
   \                     WM__DetachWindow:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0050A0E1           MOV      R5,R0
    460            WM_Obj* pWin;
    461            WM_HWIN hParent;
    462            pWin = WM_H2P(hWin);
   \   0000000C   ........           BL       GUI_ALLOC_h2p
   \   00000010   0040A0E1           MOV      R4,R0
    463            hParent = pWin->hParent;
    464            if (hParent) {
   \   00000014   181094E5           LDR      R1,[R4, #+24]
   \   00000018   000051E3           CMP      R1,#+0
   \   0000001C   1300000A           BEQ      ??WM__DetachWindow_0
    465              WM__InvalidateRectEx(&pWin->Rect, pWin->hParent, pWin->hNext);
   \   00000020   2030A0E3           MOV      R3,#+32
   \   00000024   202094E5           LDR      R2,[R4, #+32]
   \   00000028   ........           BL       WM__InvalidateRect
    466              WM__RemoveWindowFromList(hWin);
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   ........           BL       GUI_ALLOC_h2p
   \   00000034   0060A0E1           MOV      R6,R0
   \   00000038   180096E5           LDR      R0,[R6, #+24]
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0900000A           BEQ      ??WM__DetachWindow_1
   \   00000044   ........           BL       GUI_ALLOC_h2p
   \   00000048   0070A0E1           MOV      R7,R0
   \   0000004C   1C1097E5           LDR      R1,[R7, #+28]
   \   00000050   050051E1           CMP      R1,R5
   \   00000054   0700001A           BNE      ??WM__DetachWindow_2
   \   00000058   0100A0E1           MOV      R0,R1
   \   0000005C   ........           BL       GUI_ALLOC_h2p
   \   00000060   200090E5           LDR      R0,[R0, #+32]
   \   00000064   1C0087E5           STR      R0,[R7, #+28]
    467              pWin->hParent = 0;
   \                     ??WM__DetachWindow_3:
   \   00000068   0000A0E3           MOV      R0,#+0
   \                     ??WM__DetachWindow_1:
   \   0000006C   180084E5           STR      R0,[R4, #+24]
    468            }
    469          }
   \                     ??WM__DetachWindow_0:
   \   00000070   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000074   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??WM__DetachWindow_2:
   \   00000078   000051E3           CMP      R1,#+0
   \   0000007C   F9FFFF0A           BEQ      ??WM__DetachWindow_3
   \   00000080   0100A0E1           MOV      R0,R1
   \   00000084   ........           BL       GUI_ALLOC_h2p
   \   00000088   201090E5           LDR      R1,[R0, #+32]
   \   0000008C   050051E1           CMP      R1,R5
   \   00000090   F8FFFF1A           BNE      ??WM__DetachWindow_2
   \   00000094   201096E5           LDR      R1,[R6, #+32]
   \   00000098   201080E5           STR      R1,[R0, #+32]
   \   0000009C   F1FFFFEA           B        ??WM__DetachWindow_3
    470          
    471          /*********************************************************************
    472          *
    473          *       _DeleteAllChildren
    474          */
    475          static void _DeleteAllChildren(WM_Obj * pParent) {
    476            do {
    477              WM_DeleteWindow(pParent->hFirstChild);
    478            } while (pParent->hFirstChild);
    479          }
    480          
    481          /*********************************************************************
    482          *
    483          *             Module internal routines
    484          *
    485          **********************************************************************
    486          */
    487          /*********************************************************************
    488          *
    489          *       WM__Client2Screen
    490          */

   \                                 In section .text, align 4, keep-with-next
    491          void WM__Client2Screen(const WM_Obj * pWin, GUI_RECT * pRect) {
   \                     WM__Client2Screen:
   \   00000000   0130A0E1           MOV      R3,R1
    492            GUI_MoveRect(pRect, pWin->Rect.x0, pWin->Rect.y0);
   \   00000004   F220D0E1           LDRSH    R2,[R0, #+2]
   \   00000008   F010D0E1           LDRSH    R1,[R0, #+0]
   \   0000000C   0300A0E1           MOV      R0,R3
   \   00000010   ........           B        GUI_MoveRect     ;; tailcall
    493          }
    494          
    495          /*********************************************************************
    496          *
    497          *       WM__IsWindow
    498          */

   \                                 In section .text, align 4, keep-with-next
    499          int WM__IsWindow(WM_HWIN hWin) {
   \                     WM__IsWindow:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    500            WM_HWIN iWin;
    501            for (iWin = WM__FirstWin; iWin; iWin = WM_H2P(iWin)->hNextLin) {
   \   00000008   ........           LDR      R0,??DataTable9_1
   \   0000000C   200090E5           LDR      R0,[R0, #+32]
   \   00000010   010000EA           B        ??WM__IsWindow_0
   \                     ??WM__IsWindow_1:
   \   00000014   ........           BL       GUI_ALLOC_h2p
   \   00000018   140090E5           LDR      R0,[R0, #+20]
   \                     ??WM__IsWindow_0:
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0200000A           BEQ      ??WM__IsWindow_2
    502              if (iWin == hWin) {
   \   00000024   040050E1           CMP      R0,R4
   \   00000028   F9FFFF1A           BNE      ??WM__IsWindow_1
    503                return 1;
   \   0000002C   0100A0E3           MOV      R0,#+1
    504              }
    505            }
    506            return 0;
   \                     ??WM__IsWindow_2:
   \   00000030   1080BDE8           POP      {R4,PC}          ;; return
    507          }
    508          
    509          /*********************************************************************
    510          *
    511          *       WM__InvalidateDrawAndDescs
    512          */
    513          #if WM_SUPPORT_STATIC_MEMDEV

   \                                 In section .text, align 4, keep-with-next
    514          void WM__InvalidateDrawAndDescs(WM_HWIN hWin) {
   \                     WM__InvalidateDrawAndDescs:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
    515            WM_Obj * pWin;
    516            WM_Obj * pChild;
    517            WM_HWIN  hChild;
    518            int      Status;
    519          
    520            if (hWin) {
   \   0000000C   1500000A           BEQ      ??WM__InvalidateDrawAndDescs_0
    521              pWin = WM_H2P(hWin);
   \   00000010   ........           BL       GUI_ALLOC_h2p
   \   00000014   0050A0E1           MOV      R5,R0
    522              Status  = pWin->Status;
    523              if ((Status & WM_SF_ISVIS) == 0) {
   \   00000018   2800D5E5           LDRB     R0,[R5, #+40]
   \   0000001C   020010E3           TST      R0,#0x2
   \   00000020   1000000A           BEQ      ??WM__InvalidateDrawAndDescs_0
    524                return;
    525              }
    526              if (pWin->hMem) {
   \   00000024   240095E5           LDR      R0,[R5, #+36]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0200000A           BEQ      ??WM__InvalidateDrawAndDescs_1
    527                GUI_MEMDEV_Delete(pWin->hMem);
   \   00000030   ........           BL       GUI_MEMDEV_Delete
    528                pWin->hMem = 0;
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   240085E5           STR      R0,[R5, #+36]
    529              }
    530              for (hChild = WM_GetFirstChild(hWin); hChild; hChild = pChild->hNext) {
   \                     ??WM__InvalidateDrawAndDescs_1:
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       WM_GetFirstChild
   \   00000044   0040B0E1           MOVS     R4,R0
   \   00000048   0600000A           BEQ      ??WM__InvalidateDrawAndDescs_0
    531                WM__InvalidateDrawAndDescs(hChild);
   \                     ??WM__InvalidateDrawAndDescs_2:
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       WM__InvalidateDrawAndDescs
    532                pChild = WM_H2P(hChild);
    533              }
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       GUI_ALLOC_h2p
   \   0000005C   204090E5           LDR      R4,[R0, #+32]
   \   00000060   000054E3           CMP      R4,#+0
   \   00000064   F8FFFF1A           BNE      ??WM__InvalidateDrawAndDescs_2
   \                     ??WM__InvalidateDrawAndDescs_0:
   \   00000068   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000006C   3080BDE8           POP      {R4,R5,PC}       ;; return
    534            }
    535          }
    536          #endif
    537          
    538          /*********************************************************************
    539          *
    540          *       WM_InvalidateWindowAndDescs
    541          *
    542          * Parameters
    543          *   pInvalidRect  Rectangle to invalidate in desktop coordinates
    544          *
    545          * Function description
    546          *  Invalidate window and all descendants (children and grandchildren and ...
    547          */

   \                                 In section .text, align 4, keep-with-next
    548          void WM_InvalidateWindowAndDescsEx(WM_HWIN hWin, const GUI_RECT * pInvalidRect, U16 Flags) {
   \                     WM_InvalidateWindowAndDescsEx:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   08D04DE2           SUB      SP,SP,#+8
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
    549            GUI_RECT Rect;
    550            WM_Obj * pWin;
    551            WM_Obj * pChild;
    552            WM_HWIN hChild;
    553            int Status;
    554          
    555            if (hWin) {
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   1A00000A           BEQ      ??WM_InvalidateWindowAndDescsEx_0
    556              pWin = WM_H2P(hWin);
   \   0000001C   ........           BL       GUI_ALLOC_h2p
    557              Status  = pWin->Status;
    558              if ((Status & WM_SF_ISVIS) == 0) {
   \   00000020   2810D0E5           LDRB     R1,[R0, #+40]
   \   00000024   020011E3           TST      R1,#0x2
   \   00000028   1600000A           BEQ      ??WM_InvalidateWindowAndDescsEx_0
    559                return;                                                            /* Window is not visible... we are done */
    560              }
    561              if (GUI__IntersectRects(&Rect, pInvalidRect, &pWin->Rect) == 0) {  /* Limit the given rect to the area of the parent window */
   \   0000002C   0020A0E1           MOV      R2,R0
   \   00000030   0510A0E1           MOV      R1,R5
   \   00000034   0D00A0E1           MOV      R0,SP
   \   00000038   ........           BL       GUI__IntersectRects
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   1000000A           BEQ      ??WM_InvalidateWindowAndDescsEx_0
    562                return;                                                            /* No intersection, nothing to do */
    563              }
    564              _Invalidate1Abs(hWin, &Rect, Flags);    /* Invalidate window itself */
   \   00000044   0620A0E1           MOV      R2,R6
   \   00000048   0D10A0E1           MOV      R1,SP
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       _Invalidate1Abs
    565              for (hChild = WM_GetFirstChild(hWin); hChild; hChild = pChild->hNext) {
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       WM_GetFirstChild
   \   0000005C   0040B0E1           MOVS     R4,R0
   \   00000060   0800000A           BEQ      ??WM_InvalidateWindowAndDescsEx_0
    566                WM_InvalidateWindowAndDescsEx(hChild, &Rect, Flags);
   \                     ??WM_InvalidateWindowAndDescsEx_1:
   \   00000064   0620A0E1           MOV      R2,R6
   \   00000068   0D10A0E1           MOV      R1,SP
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   ........           BL       WM_InvalidateWindowAndDescsEx
    567                pChild = WM_H2P(hChild);
    568              }
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   ........           BL       GUI_ALLOC_h2p
   \   0000007C   204090E5           LDR      R4,[R0, #+32]
   \   00000080   000054E3           CMP      R4,#+0
   \   00000084   F6FFFF1A           BNE      ??WM_InvalidateWindowAndDescsEx_1
   \                     ??WM_InvalidateWindowAndDescsEx_0:
   \   00000088   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   0000008C   7080BDE8           POP      {R4-R6,PC}       ;; return
    569            }
    570          }
    571          
    572          /*********************************************************************
    573          *
    574          *         WM__InvalidateRect
    575          *
    576          * Parameters
    577          *   pInvalidRect  Rectangle to invalidate in desktop coordinates
    578          *   hWin          Handle of window to be invalidated.
    579          *   hParent       Handle of parent window.
    580          *                 Can be a valid window handle, 0 or WM_UNATTACHED
    581          *   hStop         Handle of window to stop invalidation at.
    582          *                 Can be a valid window handle or 0.
    583          *                 If valid, hParent needs to be the parent of hStop
    584          *
    585          * Function description
    586          *   Invalidates a window (hParent) as well as its children up to the
    587          *   hStop window.
    588          *   If the Parent is transparent, the function calls it self (recursively)
    589          *   to move up one level in the hierarchy and invalidate the "older generation"
    590          *   
    591          */

   \                                 In section .text, align 4, keep-with-next
    592          void WM__InvalidateRect(const GUI_RECT* pInvalidRect, WM_HWIN hParent, WM_HWIN hStop, U16 Flags) {
   \                     WM__InvalidateRect:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0170A0E1           MOV      R7,R1
   \   00000008   14D04DE2           SUB      SP,SP,#+20
   \   0000000C   0060A0E1           MOV      R6,R0
   \   00000010   0240A0E1           MOV      R4,R2
   \   00000014   0350A0E1           MOV      R5,R3
    593            GUI_RECT Rect;
    594            WM_Obj * pParent;
    595            WM_Obj * pi;
    596            WM_HWIN  hi;
    597            int Status;
    598          
    599            /* Perform some parameter checks and check for "early out" conditions. */
    600            if (hParent == 0) {
   \   00000018   000057E3           CMP      R7,#+0
   \   0000001C   3E00000A           BEQ      ??WM__InvalidateRect_0
    601              return;                                                            /* Desktop window or unattached wind. Nothing to do. */
    602            }
    603            pParent = WM_H2P(hParent);
   \   00000020   0700A0E1           MOV      R0,R7
   \   00000024   ........           BL       GUI_ALLOC_h2p
   \   00000028   0080A0E1           MOV      R8,R0
    604            Status  = pParent->Status;
   \   0000002C   289098E5           LDR      R9,[R8, #+40]
    605            if ((Status & WM_SF_ISVIS) == 0) {
   \   00000030   020019E3           TST      R9,#0x2
   \   00000034   3800000A           BEQ      ??WM__InvalidateRect_0
    606              return;                                                            /* Window is not visible... we are done */
    607            }
    608            if (GUI__IntersectRects(&Rect, pInvalidRect, &pParent->Rect) == 0) {  /* Limit the given rect to the area of the parent window */
   \   00000038   0820A0E1           MOV      R2,R8
   \   0000003C   0610A0E1           MOV      R1,R6
   \   00000040   0D00A0E1           MOV      R0,SP
   \   00000044   ........           BL       GUI__IntersectRects
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   3200000A           BEQ      ??WM__InvalidateRect_0
    609              return;                                                            /* No intersection, nothing to do */
    610            }
    611            /* Invalidate the rectangle in the parent */
    612            /* If the parent is (partially) transparent, we need to move up in the hierarchy */
    613            if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
   \   00000050   0100A0E3           MOV      R0,#+1
   \   00000054   800E80E3           ORR      R0,R0,#0x800
   \   00000058   090000E0           AND      R0,R0,R9
   \   0000005C   010050E3           CMP      R0,#+1
   \   00000060   0500001A           BNE      ??WM__InvalidateRect_1
    614              WM__InvalidateRect(&Rect, pParent->hParent, pParent->hNext, Flags);
   \   00000064   0530A0E1           MOV      R3,R5
   \   00000068   202098E5           LDR      R2,[R8, #+32]
   \   0000006C   181098E5           LDR      R1,[R8, #+24]
   \   00000070   0D00A0E1           MOV      R0,SP
   \   00000074   ........           BL       WM__InvalidateRect
   \   00000078   030000EA           B        ??WM__InvalidateRect_2
    615            } else {
    616              _Invalidate1Abs(hParent, &Rect, Flags);
   \                     ??WM__InvalidateRect_1:
   \   0000007C   0520A0E1           MOV      R2,R5
   \   00000080   0D10A0E1           MOV      R1,SP
   \   00000084   0700A0E1           MOV      R0,R7
   \   00000088   ........           BL       _Invalidate1Abs
    617            }
    618            /* Invalidate siblings up to hStop */
    619            for (hi = pParent->hFirstChild; hi; hi = pi->hNext) {
   \                     ??WM__InvalidateRect_2:
   \   0000008C   1C6098E5           LDR      R6,[R8, #+28]
   \   00000090   1E0000EA           B        ??WM__InvalidateRect_3
    620              if (hi == hStop) {
    621                break;
    622              }
    623              WM_InvalidateWindowAndDescsEx(hi, &Rect, Flags);
   \                     ??WM__InvalidateRect_4:
   \   00000094   0600A0E1           MOV      R0,R6
   \   00000098   ........           BL       GUI_ALLOC_h2p
   \   0000009C   2810D0E5           LDRB     R1,[R0, #+40]
   \   000000A0   020011E3           TST      R1,#0x2
   \   000000A4   1600000A           BEQ      ??WM__InvalidateRect_5
   \   000000A8   0020A0E1           MOV      R2,R0
   \   000000AC   0D10A0E1           MOV      R1,SP
   \   000000B0   08008DE2           ADD      R0,SP,#+8
   \   000000B4   ........           BL       GUI__IntersectRects
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   1000000A           BEQ      ??WM__InvalidateRect_5
   \   000000C0   0520A0E1           MOV      R2,R5
   \   000000C4   08108DE2           ADD      R1,SP,#+8
   \   000000C8   0600A0E1           MOV      R0,R6
   \   000000CC   ........           BL       _Invalidate1Abs
   \   000000D0   0600A0E1           MOV      R0,R6
   \   000000D4   ........           BL       WM_GetFirstChild
   \   000000D8   0070B0E1           MOVS     R7,R0
   \   000000DC   0800000A           BEQ      ??WM__InvalidateRect_5
   \                     ??WM__InvalidateRect_6:
   \   000000E0   0520A0E1           MOV      R2,R5
   \   000000E4   08108DE2           ADD      R1,SP,#+8
   \   000000E8   0700A0E1           MOV      R0,R7
   \   000000EC   ........           BL       WM_InvalidateWindowAndDescsEx
   \   000000F0   0700A0E1           MOV      R0,R7
   \   000000F4   ........           BL       GUI_ALLOC_h2p
   \   000000F8   207090E5           LDR      R7,[R0, #+32]
   \   000000FC   000057E3           CMP      R7,#+0
   \   00000100   F6FFFF1A           BNE      ??WM__InvalidateRect_6
    624              pi = WM_H2P(hi);
   \                     ??WM__InvalidateRect_5:
   \   00000104   0600A0E1           MOV      R0,R6
   \   00000108   ........           BL       GUI_ALLOC_h2p
   \   0000010C   206090E5           LDR      R6,[R0, #+32]
   \                     ??WM__InvalidateRect_3:
   \   00000110   000056E3           CMP      R6,#+0
   \   00000114   04005611           CMPNE    R6,R4
   \   00000118   DDFFFF1A           BNE      ??WM__InvalidateRect_4
   \                     ??WM__InvalidateRect_0:
   \   0000011C   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000120   F083BDE8           POP      {R4-R9,PC}       ;; return
    625            }
    626          }
    627          
    628          /*********************************************************************
    629          *
    630          *         WM__InvalidateRectEx
    631          */

   \                                 In section .text, align 4, keep-with-next
    632          void WM__InvalidateRectEx(const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop) {
    633            WM__InvalidateRect(pInvalidRect, hParent, hStop, WM_SF_INVALID);
   \                     WM__InvalidateRectEx:
   \   00000000   2030A0E3           MOV      R3,#+32
   \   00000004   ........           B        WM__InvalidateRect  ;; tailcall
    634          }
    635          
    636          /*********************************************************************
    637          *
    638          *       WM_RemoveFromLinList
    639          */

   \                                 In section .text, align 4, keep-with-next
    640          void WM__RemoveFromLinList(WM_HWIN hWin) {
   \                     WM__RemoveFromLinList:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    641            WM_Obj * piWin;
    642            WM_HWIN hiWin;
    643            WM_HWIN hNext;
    644          
    645            for (hiWin = WM__FirstWin; hiWin; ) {
   \   00000008   ........           LDR      R0,??DataTable9_1
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   200090E5           LDR      R0,[R0, #+32]
    646              piWin = WM_H2P(hiWin);
    647              hNext = piWin->hNextLin;
    648              if (hNext == hWin) {
    649                piWin->hNextLin = WM_H2P(hWin)->hNextLin;
    650                break;
    651              }
    652              hiWin = hNext;
   \                     ??WM__RemoveFromLinList_0:
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0800000A           BEQ      ??WM__RemoveFromLinList_1
   \   0000001C   ........           BL       GUI_ALLOC_h2p
   \   00000020   0050A0E1           MOV      R5,R0
   \   00000024   140095E5           LDR      R0,[R5, #+20]
   \   00000028   040050E1           CMP      R0,R4
   \   0000002C   F8FFFF1A           BNE      ??WM__RemoveFromLinList_0
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       GUI_ALLOC_h2p
   \   00000038   140090E5           LDR      R0,[R0, #+20]
   \   0000003C   140085E5           STR      R0,[R5, #+20]
    653            }
    654          }
   \                     ??WM__RemoveFromLinList_1:
   \   00000040   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000044   3080BDE8           POP      {R4,R5,PC}       ;; return
    655          
    656          /*********************************************************************
    657          *
    658          *       _AddToLinList
    659          */
    660          static void _AddToLinList(WM_HWIN hNew) {
    661            WM_Obj* pFirst;
    662            WM_Obj* pNew;
    663          
    664            if (WM__FirstWin) {
    665              pFirst = WM_H2P(WM__FirstWin);
    666              pNew   = WM_H2P(hNew);
    667              pNew->hNextLin = pFirst->hNextLin;
    668              pFirst->hNextLin = hNew;
    669            } else {
    670              WM__FirstWin = hNew;
    671            }
    672          }
    673          
    674          /*********************************************************************
    675          *
    676          *       WM__RectIsNZ
    677          *
    678             Check if the rectangle has some content (is non-zero)
    679             Returns 0 if the Rectangle has no content, else 1.
    680          */

   \                                 In section .text, align 4, keep-with-next
    681          int WM__RectIsNZ(const GUI_RECT * pr) {
    682            if (pr->x0 > pr->x1)
   \                     WM__RectIsNZ:
   \   00000000   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000004   F020D0E1           LDRSH    R2,[R0, #+0]
   \   00000008   020051E1           CMP      R1,R2
   \   0000000C   010000AA           BGE      ??WM__RectIsNZ_0
    683              return 0;
   \                     ??WM__RectIsNZ_1:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR
    684            if (pr->y0 > pr->y1)
   \                     ??WM__RectIsNZ_0:
   \   00000018   F610D0E1           LDRSH    R1,[R0, #+6]
   \   0000001C   F200D0E1           LDRSH    R0,[R0, #+2]
   \   00000020   000051E1           CMP      R1,R0
   \   00000024   F9FFFFBA           BLT      ??WM__RectIsNZ_1
    685              return 0;
    686            return 1;
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    687          }
    688          
    689          /*********************************************************************
    690          *
    691          *        _Findy1
    692          *
    693          */

   \                                 In section .text, align 4, keep-with-next
    694          static void _Findy1(WM_HWIN iWin, GUI_RECT * pRect, GUI_RECT * pParentRect) {
   \                     _Findy1:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
    695            WM_Obj * pWin;
    696            WM_Obj * pChild;
    697            WM_HWIN hChild;
    698            int Status;
    699            GUI_RECT rWinClipped; /* Window rect, clipped to part inside of ancestors */
    700          
    701            for (; iWin; iWin = pWin->hNext) { 
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   3700000A           BEQ      ??_Findy1_0
    702              Status = (pWin = WM_H2P(iWin))->Status;
   \                     ??_Findy1_1:
   \   00000018   ........           BL       GUI_ALLOC_h2p
   \   0000001C   0060A0E1           MOV      R6,R0
   \   00000020   287096E5           LDR      R7,[R6, #+40]
    703              /* Check if this window affects us at all */    
    704              if (Status & WM_SF_ISVIS) {
   \   00000024   020017E3           TST      R7,#0x2
   \   00000028   2F00000A           BEQ      ??_Findy1_2
    705                if (pParentRect) {
   \   0000002C   000055E3           CMP      R5,#+0
   \   00000030   0400000A           BEQ      ??_Findy1_3
    706                  GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
   \   00000034   0520A0E1           MOV      R2,R5
   \   00000038   0610A0E1           MOV      R1,R6
   \   0000003C   0D00A0E1           MOV      R0,SP
   \   00000040   ........           BL       GUI__IntersectRects
   \   00000044   030000EA           B        ??_Findy1_4
    707                } else {
    708                  rWinClipped = pWin->Rect;
   \                     ??_Findy1_3:
   \   00000048   0D00A0E1           MOV      R0,SP
   \   0000004C   0610A0E1           MOV      R1,R6
   \   00000050   0820A0E3           MOV      R2,#+8
   \   00000054   ........           BL       __aeabi_memcpy
    709                }
    710                /* Check if this window affects us at all */    
    711                if (GUI_RectsIntersect(pRect, &rWinClipped)) {
   \                     ??_Findy1_4:
   \   00000058   0D10A0E1           MOV      R1,SP
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           BL       GUI_RectsIntersect
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   1F00000A           BEQ      ??_Findy1_2
    712                  if ((Status & WM_SF_HASTRANS) == 0) {
   \   0000006C   010017E3           TST      R7,#0x1
   \   00000070   1000001A           BNE      ??_Findy1_5
    713                    if (pWin->Rect.y0 > pRect->y0) {
   \   00000074   F210D4E1           LDRSH    R1,[R4, #+2]
   \   00000078   F220D6E1           LDRSH    R2,[R6, #+2]
   \   0000007C   F600D4E1           LDRSH    R0,[R4, #+6]
   \   00000080   020051E1           CMP      R1,R2
   \   00000084   060000AA           BGE      ??_Findy1_6
    714                      ASSIGN_IF_LESS(pRect->y1, rWinClipped.y0 - 1);      /* Check upper border of window */
   \   00000088   F210DDE1           LDRSH    R1,[SP, #+2]
   \   0000008C   012041E2           SUB      R2,R1,#+1
   \   00000090   000052E1           CMP      R2,R0
   \   00000094   140000AA           BGE      ??_Findy1_2
   \   00000098   010041E2           SUB      R0,R1,#+1
   \   0000009C   B600C4E1           STRH     R0,[R4, #+6]
   \   000000A0   110000EA           B        ??_Findy1_2
    715                    } else {
    716                      ASSIGN_IF_LESS(pRect->y1, rWinClipped.y1);        /* Check lower border of window */
   \                     ??_Findy1_6:
   \   000000A4   F610DDE1           LDRSH    R1,[SP, #+6]
   \   000000A8   000051E1           CMP      R1,R0
   \   000000AC   0E0000AA           BGE      ??_Findy1_2
   \   000000B0   B610C4E1           STRH     R1,[R4, #+6]
   \   000000B4   0C0000EA           B        ??_Findy1_2
    717                    }
    718                  } else {
    719                    /* Check all children*/ 
    720                    for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
   \                     ??_Findy1_5:
   \   000000B8   1C7096E5           LDR      R7,[R6, #+28]
   \   000000BC   000057E3           CMP      R7,#+0
   \   000000C0   0900000A           BEQ      ??_Findy1_2
    721                      pChild = WM_H2P(hChild);
   \                     ??_Findy1_7:
   \   000000C4   0700A0E1           MOV      R0,R7
   \   000000C8   ........           BL       GUI_ALLOC_h2p
   \   000000CC   0080A0E1           MOV      R8,R0
    722                      _Findy1(hChild, pRect, &rWinClipped);
   \   000000D0   0D20A0E1           MOV      R2,SP
   \   000000D4   0410A0E1           MOV      R1,R4
   \   000000D8   0700A0E1           MOV      R0,R7
   \   000000DC   ........           BL       _Findy1
    723                    }
   \   000000E0   207098E5           LDR      R7,[R8, #+32]
   \   000000E4   000057E3           CMP      R7,#+0
   \   000000E8   F5FFFF1A           BNE      ??_Findy1_7
    724                  }
    725                }
    726              }
    727            }
   \                     ??_Findy1_2:
   \   000000EC   200096E5           LDR      R0,[R6, #+32]
   \   000000F0   000050E3           CMP      R0,#+0
   \   000000F4   C7FFFF1A           BNE      ??_Findy1_1
    728          }
   \                     ??_Findy1_0:
   \   000000F8   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   000000FC   F081BDE8           POP      {R4-R8,PC}       ;; return
    729          
    730          /*********************************************************************
    731          *
    732          *        _Findx0
    733          */

   \                                 In section .text, align 4, keep-with-next
    734          static int _Findx0(WM_HWIN hWin, GUI_RECT * pRect, GUI_RECT * pParentRect) {
   \                     _Findx0:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
    735            WM_Obj * pWin;
    736            WM_Obj * pChild;
    737            WM_HWIN hChild;
    738            int Status;
    739            int r = 0;
   \   00000010   0070A0E3           MOV      R7,#+0
    740            GUI_RECT rWinClipped; /* Window rect, clipped to part inside of ancestors */
    741          
    742            for (; hWin; hWin = pWin->hNext) { 
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   2D00000A           BEQ      ??_Findx0_0
    743              Status = (pWin = WM_H2P(hWin))->Status;
   \                     ??_Findx0_1:
   \   0000001C   ........           BL       GUI_ALLOC_h2p
   \   00000020   0060A0E1           MOV      R6,R0
   \   00000024   288096E5           LDR      R8,[R6, #+40]
    744              if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
   \   00000028   020018E3           TST      R8,#0x2
   \   0000002C   2500000A           BEQ      ??_Findx0_2
    745                if (pParentRect) {
   \   00000030   000055E3           CMP      R5,#+0
   \   00000034   0400000A           BEQ      ??_Findx0_3
    746                  GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
   \   00000038   0520A0E1           MOV      R2,R5
   \   0000003C   0610A0E1           MOV      R1,R6
   \   00000040   0D00A0E1           MOV      R0,SP
   \   00000044   ........           BL       GUI__IntersectRects
   \   00000048   030000EA           B        ??_Findx0_4
    747                } else {
    748                  rWinClipped = pWin->Rect;
   \                     ??_Findx0_3:
   \   0000004C   0D00A0E1           MOV      R0,SP
   \   00000050   0610A0E1           MOV      R1,R6
   \   00000054   0820A0E3           MOV      R2,#+8
   \   00000058   ........           BL       __aeabi_memcpy
    749                }
    750                /* Check if this window affects us at all */    
    751                if (GUI_RectsIntersect(pRect, &rWinClipped)) {
   \                     ??_Findx0_4:
   \   0000005C   0D10A0E1           MOV      R1,SP
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       GUI_RectsIntersect
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   1500000A           BEQ      ??_Findx0_2
    752                  if ((Status & WM_SF_HASTRANS) == 0) {
   \   00000070   010018E3           TST      R8,#0x1
   \   00000074   0400001A           BNE      ??_Findx0_5
    753                    pRect->x0 = rWinClipped.x1 + 1;
   \   00000078   F400DDE1           LDRSH    R0,[SP, #+4]
    754                    r = 1;
   \   0000007C   0170A0E3           MOV      R7,#+1
   \   00000080   010080E2           ADD      R0,R0,#+1
   \   00000084   B000C4E1           STRH     R0,[R4, #+0]
   \   00000088   0E0000EA           B        ??_Findx0_2
    755                  } else {
    756                    /* Check all children */
    757                    for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
   \                     ??_Findx0_5:
   \   0000008C   1C8096E5           LDR      R8,[R6, #+28]
   \   00000090   000058E3           CMP      R8,#+0
   \   00000094   0B00000A           BEQ      ??_Findx0_2
    758                      pChild = WM_H2P(hChild);
   \                     ??_Findx0_6:
   \   00000098   0800A0E1           MOV      R0,R8
   \   0000009C   ........           BL       GUI_ALLOC_h2p
   \   000000A0   0090A0E1           MOV      R9,R0
    759                      if (_Findx0(hChild, pRect, &rWinClipped)) {
   \   000000A4   0D20A0E1           MOV      R2,SP
   \   000000A8   0410A0E1           MOV      R1,R4
   \   000000AC   0800A0E1           MOV      R0,R8
   \   000000B0   ........           BL       _Findx0
   \   000000B4   000050E3           CMP      R0,#+0
    760                        r = 1;
    761                      }
    762                    }
   \   000000B8   208099E5           LDR      R8,[R9, #+32]
   \   000000BC   0170A013           MOVNE    R7,#+1
   \   000000C0   000058E3           CMP      R8,#+0
   \   000000C4   F3FFFF1A           BNE      ??_Findx0_6
    763                  }
    764                }
    765              }
    766            }
   \                     ??_Findx0_2:
   \   000000C8   200096E5           LDR      R0,[R6, #+32]
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   D1FFFF1A           BNE      ??_Findx0_1
    767            return r;
   \                     ??_Findx0_0:
   \   000000D4   0700A0E1           MOV      R0,R7
   \   000000D8   0CD08DE2           ADD      SP,SP,#+12
   \   000000DC   F083BDE8           POP      {R4-R9,PC}       ;; return
    768          }
    769          
    770          /*********************************************************************
    771          *
    772          *        _Findx1
    773          */

   \                                 In section .text, align 4, keep-with-next
    774          static void _Findx1(WM_HWIN hWin, GUI_RECT * pRect, GUI_RECT * pParentRect) {
   \                     _Findx1:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
    775            WM_Obj * pWin;
    776            WM_Obj * pChild;
    777            WM_HWIN hChild;
    778            int Status;
    779          
    780            for (; hWin; hWin = pWin->hNext) { 
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   2A00000A           BEQ      ??_Findx1_0
    781              Status = (pWin = WM_H2P(hWin))->Status;
   \                     ??_Findx1_1:
   \   00000018   ........           BL       GUI_ALLOC_h2p
   \   0000001C   0060A0E1           MOV      R6,R0
   \   00000020   287096E5           LDR      R7,[R6, #+40]
    782              if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
   \   00000024   020017E3           TST      R7,#0x2
   \   00000028   2200000A           BEQ      ??_Findx1_2
    783                GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
    784                if (pParentRect) {
   \   0000002C   000055E3           CMP      R5,#+0
   \   00000030   0400000A           BEQ      ??_Findx1_3
    785                  GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
   \   00000034   0520A0E1           MOV      R2,R5
   \   00000038   0610A0E1           MOV      R1,R6
   \   0000003C   0D00A0E1           MOV      R0,SP
   \   00000040   ........           BL       GUI__IntersectRects
   \   00000044   030000EA           B        ??_Findx1_4
    786                } else {
    787                  rWinClipped = pWin->Rect;
   \                     ??_Findx1_3:
   \   00000048   0D00A0E1           MOV      R0,SP
   \   0000004C   0610A0E1           MOV      R1,R6
   \   00000050   0820A0E3           MOV      R2,#+8
   \   00000054   ........           BL       __aeabi_memcpy
    788                }
    789                /* Check if this window affects us at all */    
    790                if (GUI_RectsIntersect(pRect, &rWinClipped)) {
   \                     ??_Findx1_4:
   \   00000058   0D10A0E1           MOV      R1,SP
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           BL       GUI_RectsIntersect
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   1200000A           BEQ      ??_Findx1_2
    791                  if ((Status & WM_SF_HASTRANS) == 0) {
   \   0000006C   010017E3           TST      R7,#0x1
   \   00000070   0300001A           BNE      ??_Findx1_5
    792                    pRect->x1 = rWinClipped.x0 - 1;
   \   00000074   F000DDE1           LDRSH    R0,[SP, #+0]
   \   00000078   010040E2           SUB      R0,R0,#+1
   \   0000007C   B400C4E1           STRH     R0,[R4, #+4]
   \   00000080   0C0000EA           B        ??_Findx1_2
    793                  } else {
    794                    /* Check all children */
    795                    for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
   \                     ??_Findx1_5:
   \   00000084   1C7096E5           LDR      R7,[R6, #+28]
   \   00000088   000057E3           CMP      R7,#+0
   \   0000008C   0900000A           BEQ      ??_Findx1_2
    796                      pChild = WM_H2P(hChild);
   \                     ??_Findx1_6:
   \   00000090   0700A0E1           MOV      R0,R7
   \   00000094   ........           BL       GUI_ALLOC_h2p
   \   00000098   0080A0E1           MOV      R8,R0
    797                      _Findx1(hChild, pRect, &rWinClipped);
   \   0000009C   0D20A0E1           MOV      R2,SP
   \   000000A0   0410A0E1           MOV      R1,R4
   \   000000A4   0700A0E1           MOV      R0,R7
   \   000000A8   ........           BL       _Findx1
    798                    }
   \   000000AC   207098E5           LDR      R7,[R8, #+32]
   \   000000B0   000057E3           CMP      R7,#+0
   \   000000B4   F5FFFF1A           BNE      ??_Findx1_6
    799                  }
    800                }
    801              }
    802            }
   \                     ??_Findx1_2:
   \   000000B8   200096E5           LDR      R0,[R6, #+32]
   \   000000BC   000050E3           CMP      R0,#+0
   \   000000C0   D4FFFF1A           BNE      ??_Findx1_1
    803          }
   \                     ??_Findx1_0:
   \   000000C4   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   000000C8   F081BDE8           POP      {R4-R8,PC}       ;; return
    804          
    805          /*********************************************************************
    806          *
    807          *       Sending messages
    808          *
    809          **********************************************************************
    810          */
    811          /*********************************************************************
    812          *
    813          *       WM_SendMessage
    814          */

   \                                 In section .text, align 4, keep-with-next
    815          void WM_SendMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
   \                     WM_SendMessage:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
    816            if (hWin) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0400000A           BEQ      ??WM_SendMessage_0
    817              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
    818              WM__SendMessage(hWin, pMsg);
   \   0000001C   0510A0E1           MOV      R1,R5
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       WM__SendMessage
    819              WM_UNLOCK();
   \   00000028   ........           BL       GUI_Unlock
    820            }  
    821          }
   \                     ??WM_SendMessage_0:
   \   0000002C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000030   3080BDE8           POP      {R4,R5,PC}       ;; return
    822          
    823          /*********************************************************************
    824          *
    825          *       WM__SendMsgNoData
    826          */

   \                                 In section .text, align 4, keep-with-next
    827          void WM__SendMsgNoData(WM_HWIN hWin, U8 MsgId) {
   \                     WM__SendMsgNoData:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
    828            WM_MESSAGE Msg;
    829          
    830            Msg.hWin  = hWin;
    831            Msg.MsgId = MsgId;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
   \   0000000C   04008DE5           STR      R0,[SP, #+4]
    832            WM__SendMessage(hWin, &Msg);
   \   00000010   0D10A0E1           MOV      R1,SP
   \   00000014   ........           BL       WM__SendMessage
    833          }
   \   00000018   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   0000001C   0080BDE8           POP      {PC}             ;; return
    834          
    835          /*********************************************************************
    836          *
    837          *       WM__GetClientRectWin
    838          *
    839            Get client rectangle in windows coordinates. This means that the
    840            upper left corner is always at (0,0). 
    841          */

   \                                 In section .text, align 4, keep-with-next
    842          void WM__GetClientRectWin(const WM_Obj * pWin, GUI_RECT * pRect) {
    843            pRect->x0 = pRect->y0 = 0;
   \                     WM__GetClientRectWin:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   B220C1E1           STRH     R2,[R1, #+2]
   \   00000008   B020C1E1           STRH     R2,[R1, #+0]
    844            pRect->x1 = pWin->Rect.x1 - pWin->Rect.x0;
   \   0000000C   F420D0E1           LDRSH    R2,[R0, #+4]
   \   00000010   F030D0E1           LDRSH    R3,[R0, #+0]
   \   00000014   032042E0           SUB      R2,R2,R3
   \   00000018   B420C1E1           STRH     R2,[R1, #+4]
    845            pRect->y1 = pWin->Rect.y1 - pWin->Rect.y0;
   \   0000001C   F620D0E1           LDRSH    R2,[R0, #+6]
   \   00000020   F200D0E1           LDRSH    R0,[R0, #+2]
   \   00000024   000042E0           SUB      R0,R2,R0
   \   00000028   B600C1E1           STRH     R0,[R1, #+6]
    846          }
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    847          
    848          /*********************************************************************
    849          *
    850          *       WM__GetInvalidRectAbs
    851          */
    852          static void WM__GetInvalidRectAbs(WM_Obj * pWin, GUI_RECT * pRect) {
    853            *pRect = pWin->InvalidRect;
    854          }
    855          
    856          /*********************************************************************
    857          *
    858          *       Invalidation functions
    859          *
    860          **********************************************************************
    861          */
    862          /*********************************************************************
    863          *
    864          *       WM_InvalidateRect
    865          *
    866          *  Invalidate a section of the window. The optional rectangle
    867          *  contains client coordinates, which are independent of the
    868          *  position of the window on the logical desktop area.
    869          */

   \                                 In section .text, align 4, keep-with-next
    870          void WM_InvalidateRect(WM_HWIN hWin, const GUI_RECT * pRect) {
   \                     WM_InvalidateRect:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   10D04DE2           SUB      SP,SP,#+16
   \   0000000C   0170A0E1           MOV      R7,R1
    871            GUI_RECT rPara;
    872            GUI_RECT r;
    873            WM_Obj * pWin;
    874            int Status;
    875          
    876            if (hWin) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   6600000A           BEQ      ??WM_InvalidateRect_0
    877              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
    878              pWin = WM_H2P(hWin);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_h2p
   \   00000024   0050A0E1           MOV      R5,R0
    879              Status = pWin->Status;
   \   00000028   286095E5           LDR      R6,[R5, #+40]
    880              if (Status & WM_SF_ISVIS) {
   \   0000002C   020016E3           TST      R6,#0x2
   \   00000030   5E00000A           BEQ      ??WM_InvalidateRect_1
    881                r = pWin->Rect;
   \   00000034   0D00A0E1           MOV      R0,SP
   \   00000038   0510A0E1           MOV      R1,R5
   \   0000003C   0820A0E3           MOV      R2,#+8
   \   00000040   ........           BL       __aeabi_memcpy
    882                if (Status & WM_CF_STATIC) {
   \   00000044   400B16E3           TST      R6,#0x10000
   \   00000048   1600000A           BEQ      ??WM_InvalidateRect_2
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       GUI_ALLOC_h2p
   \   00000054   0080A0E1           MOV      R8,R0
   \   00000058   2800D8E5           LDRB     R0,[R8, #+40]
   \   0000005C   020010E3           TST      R0,#0x2
   \   00000060   1000000A           BEQ      ??WM_InvalidateRect_2
   \   00000064   240098E5           LDR      R0,[R8, #+36]
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   0200000A           BEQ      ??WM_InvalidateRect_3
   \   00000070   ........           BL       GUI_MEMDEV_Delete
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   240088E5           STR      R0,[R8, #+36]
   \                     ??WM_InvalidateRect_3:
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   ........           BL       WM_GetFirstChild
   \   00000084   0080B0E1           MOVS     R8,R0
   \   00000088   0600000A           BEQ      ??WM_InvalidateRect_2
   \                     ??WM_InvalidateRect_4:
   \   0000008C   0800A0E1           MOV      R0,R8
   \   00000090   ........           BL       WM__InvalidateDrawAndDescs
   \   00000094   0800A0E1           MOV      R0,R8
   \   00000098   ........           BL       GUI_ALLOC_h2p
   \   0000009C   208090E5           LDR      R8,[R0, #+32]
   \   000000A0   000058E3           CMP      R8,#+0
   \   000000A4   F8FFFF1A           BNE      ??WM_InvalidateRect_4
    883                  WM__InvalidateDrawAndDescs(hWin); /* Delete static memory devices */
    884                }
    885                if (pRect) {
   \                     ??WM_InvalidateRect_2:
   \   000000A8   000057E3           CMP      R7,#+0
   \   000000AC   0A00000A           BEQ      ??WM_InvalidateRect_5
    886                  rPara = *pRect;
   \   000000B0   08008DE2           ADD      R0,SP,#+8
   \   000000B4   0710A0E1           MOV      R1,R7
   \   000000B8   0820A0E3           MOV      R2,#+8
   \   000000BC   ........           BL       __aeabi_memcpy
    887                  WM__Client2Screen(pWin, &rPara);
   \   000000C0   F220D5E1           LDRSH    R2,[R5, #+2]
   \   000000C4   F010D5E1           LDRSH    R1,[R5, #+0]
   \   000000C8   08008DE2           ADD      R0,SP,#+8
   \   000000CC   ........           BL       GUI_MoveRect
    888                  GUI__IntersectRect(&r, &rPara);
   \   000000D0   08108DE2           ADD      R1,SP,#+8
   \   000000D4   0D00A0E1           MOV      R0,SP
   \   000000D8   ........           BL       GUI__IntersectRect
    889                }
    890                if (WM__ClipAtParentBorders(&r, hWin)) {      /* Optimization that saves invalidation if window area is not visible ... Not required */
   \                     ??WM_InvalidateRect_5:
   \   000000DC   0470A0E1           MOV      R7,R4
   \   000000E0   000000EA           B        ??WM_InvalidateRect_6
   \                     ??WM_InvalidateRect_7:
   \   000000E4   0070A0E1           MOV      R7,R0
   \                     ??WM_InvalidateRect_6:
   \   000000E8   0700A0E1           MOV      R0,R7
   \   000000EC   ........           BL       GUI_ALLOC_h2p
   \   000000F0   0080A0E1           MOV      R8,R0
   \   000000F4   2800D8E5           LDRB     R0,[R8, #+40]
   \   000000F8   020010E3           TST      R0,#0x2
   \   000000FC   2B00000A           BEQ      ??WM_InvalidateRect_1
   \   00000100   0810A0E1           MOV      R1,R8
   \   00000104   0D00A0E1           MOV      R0,SP
   \   00000108   ........           BL       GUI__IntersectRect
   \   0000010C   180098E5           LDR      R0,[R8, #+24]
   \   00000110   000050E3           CMP      R0,#+0
   \   00000114   F2FFFF1A           BNE      ??WM_InvalidateRect_7
   \   00000118   ........           LDR      R0,??DataTable9_1
   \   0000011C   283090E5           LDR      R3,[R0, #+40]
   \   00000120   2C1080E2           ADD      R1,R0,#+44
   \   00000124   030057E1           CMP      R7,R3
   \   00000128   1100000A           BEQ      ??WM_InvalidateRect_8
   \   0000012C   003091E5           LDR      R3,[R1, #+0]
   \   00000130   040080E2           ADD      R0,R0,#+4
   \   00000134   0120A0E3           MOV      R2,#+1
   \   00000138   2C0080E2           ADD      R0,R0,#+44
   \   0000013C   0710A0E3           MOV      R1,#+7
   \                     ??WM_InvalidateRect_9:
   \   00000140   030057E1           CMP      R7,R3
   \   00000144   04C09014           LDRNE    R12,[R0], #+4
   \   00000148   01208212           ADDNE    R2,R2,#+1
   \   0000014C   0C005711           CMPNE    R7,R12
   \   00000150   0500000A           BEQ      ??WM_InvalidateRect_10
   \   00000154   012082E2           ADD      R2,R2,#+1
   \   00000158   043090E4           LDR      R3,[R0], #+4
   \   0000015C   011051E2           SUBS     R1,R1,#+1
   \   00000160   F6FFFF1A           BNE      ??WM_InvalidateRect_9
   \   00000164   030057E1           CMP      R7,R3
   \   00000168   1000001A           BNE      ??WM_InvalidateRect_1
   \                     ??WM_InvalidateRect_10:
   \   0000016C   000052E3           CMP      R2,#+0
   \   00000170   0E00004A           BMI      ??WM_InvalidateRect_1
    891                  if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
   \                     ??WM_InvalidateRect_8:
   \   00000174   0100A0E3           MOV      R0,#+1
   \   00000178   800E80E3           ORR      R0,R0,#0x800
   \   0000017C   060000E0           AND      R0,R0,R6
   \   00000180   010050E3           CMP      R0,#+1
   \   00000184   0500001A           BNE      ??WM_InvalidateRect_11
    892                    WM__InvalidateRectEx(&r, pWin->hParent, pWin->hNext);
   \   00000188   2030A0E3           MOV      R3,#+32
   \   0000018C   202095E5           LDR      R2,[R5, #+32]
   \   00000190   181095E5           LDR      R1,[R5, #+24]
   \   00000194   0D00A0E1           MOV      R0,SP
   \   00000198   ........           BL       WM__InvalidateRect
    893                  } else {
   \   0000019C   030000EA           B        ??WM_InvalidateRect_1
    894                    WM__Invalidate1Abs(hWin, &r);
   \                     ??WM_InvalidateRect_11:
   \   000001A0   2020A0E3           MOV      R2,#+32
   \   000001A4   0D10A0E1           MOV      R1,SP
   \   000001A8   0400A0E1           MOV      R0,R4
   \   000001AC   ........           BL       _Invalidate1Abs
    895                  }
    896                }
    897              }
    898              WM_UNLOCK();
   \                     ??WM_InvalidateRect_1:
   \   000001B0   ........           BL       GUI_Unlock
    899            }
    900          }
   \                     ??WM_InvalidateRect_0:
   \   000001B4   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   000001B8   F081BDE8           POP      {R4-R8,PC}       ;; return
    901          
    902          /*********************************************************************
    903          *
    904          *        WM_InvalidateWindow
    905          *
    906            Invalidates an entire window.
    907          */

   \                                 In section .text, align 4, keep-with-next
    908          void WM_InvalidateWindow(WM_HWIN hWin) {
    909            WM_InvalidateRect(hWin, NULL);
   \                     WM_InvalidateWindow:
   \   00000000   0010A0E3           MOV      R1,#+0
   \   00000004   ........           B        WM_InvalidateRect  ;; tailcall
    910          }
    911          
    912          /*********************************************************************
    913          *
    914          *       Manage windows stack
    915          *
    916          **********************************************************************
    917          */
    918          /*********************************************************************
    919          *
    920          *       WM_CreateWindowAsChild
    921          */

   \                                 In section .text, align 4, keep-with-next
    922          WM_HWIN WM_CreateWindowAsChild( int x0, int y0, int width, int height
    923                                         ,WM_HWIN hParent, U32 Style, WM_CALLBACK * cb
    924                                         ,int NumExtraBytes) {
   \                     WM_CreateWindowAsChild:
   \   00000000   F44F2DE9           PUSH     {R2,R4-R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0080A0E1           MOV      R8,R0
   \   0000000C   0190A0E1           MOV      R9,R1
   \   00000010   03A0A0E1           MOV      R10,R3
   \   00000014   38709DE5           LDR      R7,[SP, #+56]
   \   00000018   3C609DE5           LDR      R6,[SP, #+60]
   \   0000001C   44409DE5           LDR      R4,[SP, #+68]
    925            WM_Obj * pWin;
    926            WM_Obj * pParent;
    927            WM_HWIN hWin;
    928          
    929            WM_ASSERT_NOT_IN_PAINT();
    930            WM_LOCK();
   \   00000020   ........           BL       GUI_Lock
    931            Style |= WM__CreateFlags;
   \   00000024   ........           LDR      R5,??DataTable7
    932            /* Default parent is Desktop 0 */
    933            if (!hParent) {
   \   00000028   000057E3           CMP      R7,#+0
   \   0000002C   A80095E5           LDR      R0,[R5, #+168]
   \   00000030   066080E1           ORR      R6,R0,R6
   \   00000034   0600001A           BNE      ??WM_CreateWindowAsChild_0
    934              if (WM__NumWindows) {
   \   00000038   B801D5E1           LDRH     R0,[R5, #+24]
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   1800000A           BEQ      ??WM_CreateWindowAsChild_1
    935              #if GUI_NUM_LAYERS == 1
    936                hParent = WM__ahDesktopWin[0];
    937              #else
    938                hParent = WM__ahDesktopWin[GUI_Context.SelLayer];
   \   00000044   ........           LDR      R0,??DataTable9
   \   00000048   1100D0E5           LDRB     R0,[R0, #+17]
   \   0000004C   000185E0           ADD      R0,R5,R0, LSL #+2
   \   00000050   287090E5           LDR      R7,[R0, #+40]
    939              #endif
    940              }
    941            }
    942            if (hParent == WM_UNATTACHED) {
   \                     ??WM_CreateWindowAsChild_0:
   \   00000054   010077E3           CMN      R7,#+1
    943              hParent = WM_HWIN_NULL;
   \   00000058   0070A003           MOVEQ    R7,#+0
    944            }  
    945            if (hParent) {
   \   0000005C   00005713           CMPNE    R7,#+0
   \   00000060   1000000A           BEQ      ??WM_CreateWindowAsChild_1
    946              pParent = WM_H2P(hParent);
   \   00000064   0700A0E1           MOV      R0,R7
   \   00000068   ........           BL       GUI_ALLOC_h2p
    947              x0 += pParent->Rect.x0;
   \   0000006C   F020D0E1           LDRSH    R2,[R0, #+0]
   \   00000070   F210D0E1           LDRSH    R1,[R0, #+2]
    948              y0 += pParent->Rect.y0;
    949              if (width==0) {
   \   00000074   10309DE5           LDR      R3,[SP, #+16]
   \   00000078   088082E0           ADD      R8,R2,R8
   \   0000007C   099081E0           ADD      R9,R1,R9
   \   00000080   000053E3           CMP      R3,#+0
   \   00000084   0300001A           BNE      ??WM_CreateWindowAsChild_2
    950                width = pParent->Rect.x1 - pParent->Rect.x0+1;
   \   00000088   F4C0D0E1           LDRSH    R12,[R0, #+4]
   \   0000008C   02204CE0           SUB      R2,R12,R2
   \   00000090   012082E2           ADD      R2,R2,#+1
   \   00000094   10208DE5           STR      R2,[SP, #+16]
    951              }
    952              if (height==0) {
   \                     ??WM_CreateWindowAsChild_2:
   \   00000098   00005AE3           CMP      R10,#+0
    953                height = pParent->Rect.y1 - pParent->Rect.y0+1;
   \   0000009C   F600D001           LDRSHEQ  R0,[R0, #+6]
   \   000000A0   01004000           SUBEQ    R0,R0,R1
   \   000000A4   01A08002           ADDEQ    R10,R0,#+1
    954              }
    955            }
    956            if ((hWin = (WM_HWIN) GUI_ALLOC_AllocZero(NumExtraBytes + sizeof(WM_Obj))) == 0) {
   \                     ??WM_CreateWindowAsChild_1:
   \   000000A8   2C0084E2           ADD      R0,R4,#+44
   \   000000AC   ........           BL       GUI_ALLOC_AllocZero
   \   000000B0   0040B0E1           MOVS     R4,R0
   \   000000B4   3E00000A           BEQ      ??WM_CreateWindowAsChild_3
    957              GUI_DEBUG_ERROROUT("WM_CreateWindow: No memory to create window");
    958            } else {
    959              WM__NumWindows++;
   \   000000B8   B801D5E1           LDRH     R0,[R5, #+24]
   \   000000BC   010080E2           ADD      R0,R0,#+1
   \   000000C0   B801C5E1           STRH     R0,[R5, #+24]
    960              pWin = WM_H2P(hWin);
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   ........           BL       GUI_ALLOC_h2p
   \   000000CC   00B0A0E1           MOV      R11,R0
    961              pWin->Rect.x0 = x0;
   \   000000D0   B080CBE1           STRH     R8,[R11, #+0]
    962              pWin->Rect.y0 = y0;
   \   000000D4   B290CBE1           STRH     R9,[R11, #+2]
    963              pWin->Rect.x1 = x0 + width - 1;
   \   000000D8   10009DE5           LDR      R0,[SP, #+16]
    964              pWin->Rect.y1 = y0 + height - 1;
    965              pWin->cb = cb;
    966              /* Copy the flags which can simply be accepted */
    967              pWin->Status |= (Style & (U32)(WM_CF_SHOW |
    968                                        WM_SF_MEMDEV |
    969                                        WM_CF_MEMDEV_ON_REDRAW |
    970                                        WM_SF_STAYONTOP |
    971                                        WM_CF_DISABLED |
    972                                        WM_SF_CONST_OUTLINE |
    973                                        WM_SF_HASTRANS |
    974                                        WM_CF_ANCHOR_RIGHT |
    975                                        WM_CF_ANCHOR_BOTTOM |
    976                                        WM_CF_ANCHOR_LEFT |
    977                                        WM_CF_ANCHOR_TOP |
    978                                        WM_CF_LATE_CLIP |
    979                                        WM_CF_STATIC));
   \   000000DC   ........           LDR      R1,??DataTable18  ;; 0x13f9f
   \   000000E0   080080E0           ADD      R0,R0,R8
   \   000000E4   010040E2           SUB      R0,R0,#+1
   \   000000E8   B400CBE1           STRH     R0,[R11, #+4]
   \   000000EC   09008AE0           ADD      R0,R10,R9
   \   000000F0   010040E2           SUB      R0,R0,#+1
   \   000000F4   B600CBE1           STRH     R0,[R11, #+6]
   \   000000F8   40009DE5           LDR      R0,[SP, #+64]
   \   000000FC   061001E0           AND      R1,R1,R6
   \   00000100   10008BE5           STR      R0,[R11, #+16]
   \   00000104   28009BE5           LDR      R0,[R11, #+40]
   \   00000108   000081E1           ORR      R0,R1,R0
   \   0000010C   28008BE5           STR      R0,[R11, #+40]
    980              /* Add to linked lists */
    981              _AddToLinList(hWin);
   \   00000110   200095E5           LDR      R0,[R5, #+32]
   \   00000114   000050E3           CMP      R0,#+0
   \   00000118   0700000A           BEQ      ??WM_CreateWindowAsChild_4
   \   0000011C   ........           BL       GUI_ALLOC_h2p
   \   00000120   0080A0E1           MOV      R8,R0
   \   00000124   0400A0E1           MOV      R0,R4
   \   00000128   ........           BL       GUI_ALLOC_h2p
   \   0000012C   141098E5           LDR      R1,[R8, #+20]
   \   00000130   141080E5           STR      R1,[R0, #+20]
   \   00000134   144088E5           STR      R4,[R8, #+20]
   \   00000138   000000EA           B        ??WM_CreateWindowAsChild_5
   \                     ??WM_CreateWindowAsChild_4:
   \   0000013C   204085E5           STR      R4,[R5, #+32]
    982              WM__InsertWindowIntoList(hWin, hParent);
   \                     ??WM_CreateWindowAsChild_5:
   \   00000140   0710A0E1           MOV      R1,R7
   \   00000144   0400A0E1           MOV      R0,R4
   \   00000148   ........           BL       WM__InsertWindowIntoList
    983              /* Activate window if WM_CF_ACTIVATE is specified */
    984              if (Style & WM_CF_ACTIVATE) {
   \   0000014C   200016E3           TST      R6,#0x20
   \   00000150   0100000A           BEQ      ??WM_CreateWindowAsChild_6
    985                WM_SelectWindow(hWin);  /* This is not needed if callbacks are being used, but it does not cost a lot and makes life easier ... */
   \   00000154   0400A0E1           MOV      R0,R4
   \   00000158   ........           BL       WM_SelectWindow
    986              }
    987              /* Handle the Style flags, one at a time */
    988              #if WM_SUPPORT_TRANSPARENCY
    989                if (Style & WM_SF_HASTRANS) {
   \                     ??WM_CreateWindowAsChild_6:
   \   0000015C   010016E3           TST      R6,#0x1
    990                  WM__TransWindowCnt++;          /* Increment counter for transparency windows */
   \   00000160   30019515           LDRNE    R0,[R5, #+304]
   \   00000164   01008012           ADDNE    R0,R0,#+1
   \   00000168   30018515           STRNE    R0,[R5, #+304]
    991                }
    992              #endif
    993              if (Style & WM_CF_BGND) {
   \   0000016C   400016E3           TST      R6,#0x40
   \   00000170   0100000A           BEQ      ??WM_CreateWindowAsChild_7
    994                WM_BringToBottom(hWin);
   \   00000174   0400A0E1           MOV      R0,R4
   \   00000178   ........           BL       WM_BringToBottom
    995              }
    996              if (Style & WM_CF_SHOW) {
   \                     ??WM_CreateWindowAsChild_7:
   \   0000017C   020016E3           TST      R6,#0x2
   \   00000180   0500000A           BEQ      ??WM_CreateWindowAsChild_8
    997                pWin->Status |= WM_SF_ISVIS;  /* Set Visibility flag */
   \   00000184   28009BE5           LDR      R0,[R11, #+40]
    998                WM_InvalidateWindow(hWin);    /* Mark content as invalid */
   \   00000188   0010A0E3           MOV      R1,#+0
   \   0000018C   020080E3           ORR      R0,R0,#0x2
   \   00000190   28008BE5           STR      R0,[R11, #+40]
   \   00000194   0400A0E1           MOV      R0,R4
   \   00000198   ........           BL       WM_InvalidateRect
    999              }
   1000              #if WM_SUPPORT_NOTIFY_VIS_CHANGED
   1001                if (hParent) {
   1002                  WM__SendMsgNoData(hParent, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
   1003                }
   1004              #endif
   1005              WM__SendMsgNoData(hWin, WM_CREATE);
   \                     ??WM_CreateWindowAsChild_8:
   \   0000019C   0110A0E3           MOV      R1,#+1
   \   000001A0   00108DE5           STR      R1,[SP, #+0]
   \   000001A4   04408DE5           STR      R4,[SP, #+4]
   \   000001A8   0D10A0E1           MOV      R1,SP
   \   000001AC   0400A0E1           MOV      R0,R4
   \   000001B0   ........           BL       WM__SendMessage
   1006            }
   1007            WM_UNLOCK();
   \                     ??WM_CreateWindowAsChild_3:
   \   000001B4   ........           BL       GUI_Unlock
   1008            return hWin;
   \   000001B8   0400A0E1           MOV      R0,R4
   \   000001BC   14D08DE2           ADD      SP,SP,#+20
   \   000001C0   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1009          }
   1010          
   1011          /*********************************************************************
   1012          *
   1013          *       WM_CreateWindow
   1014          */

   \                                 In section .text, align 4, keep-with-next
   1015          WM_HWIN WM_CreateWindow(int x0, int y0, int width, int height, U32 Style, WM_CALLBACK * cb, int NumExtraBytes) {
   \                     WM_CreateWindow:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   18C09DE5           LDR      R12,[SP, #+24]
   \   0000000C   1CE09DE5           LDR      LR,[SP, #+28]
   \   00000010   20409DE5           LDR      R4,[SP, #+32]
   1016            return WM_CreateWindowAsChild(x0,y0,width,height, 0 /* No parent */,  Style, cb, NumExtraBytes);
   \   00000014   04C08DE5           STR      R12,[SP, #+4]
   \   00000018   00C0A0E3           MOV      R12,#+0
   \   0000001C   0C408DE5           STR      R4,[SP, #+12]
   \   00000020   08E08DE5           STR      LR,[SP, #+8]
   \   00000024   00C08DE5           STR      R12,[SP, #+0]
   \   00000028   ........           BL       WM_CreateWindowAsChild
   \   0000002C   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   00000030   1080BDE8           POP      {R4,PC}          ;; return
   1017          }
   1018          
   1019          /*********************************************************************
   1020          *
   1021          *       Delete window
   1022          *
   1023          **********************************************************************
   1024          */
   1025          /*********************************************************************
   1026          *
   1027          *       WM_DeleteWindow
   1028          */

   \                                 In section .text, align 4, keep-with-next
   1029          void WM_DeleteWindow (WM_HWIN hWin) {
   \                     WM_DeleteWindow:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0040B0E1           MOVS     R4,R0
   1030            WM_Obj * pWin;
   1031          
   1032            if (!hWin) {
   \   0000000C   5800000A           BEQ      ??WM_DeleteWindow_0
   1033              return;
   1034            }
   1035            WM_ASSERT_NOT_IN_PAINT();
   1036            WM_LOCK();
   \   00000010   ........           BL       GUI_Lock
   1037            if (WM__IsWindow(hWin)) {
   \   00000014   ........           LDR      R5,??DataTable7
   \   00000018   200095E5           LDR      R0,[R5, #+32]
   \   0000001C   010000EA           B        ??WM_DeleteWindow_1
   \                     ??WM_DeleteWindow_2:
   \   00000020   ........           BL       GUI_ALLOC_h2p
   \   00000024   140090E5           LDR      R0,[R0, #+20]
   \                     ??WM_DeleteWindow_1:
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   4F00000A           BEQ      ??WM_DeleteWindow_3
   \   00000030   040050E1           CMP      R0,R4
   \   00000034   F9FFFF1A           BNE      ??WM_DeleteWindow_2
   1038              /* Send WM_DELETE message to window in order to inform window itself */
   1039              WM__SendMsgNoData(hWin, WM_DELETE);     /* tell window about it */
   \   00000038   0B10A0E3           MOV      R1,#+11
   \   0000003C   00108DE5           STR      R1,[SP, #+0]
   \   00000040   04408DE5           STR      R4,[SP, #+4]
   \   00000044   0D10A0E1           MOV      R1,SP
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   ........           BL       WM__SendMessage
   1040              /* Delete associated timers */
   1041              WM__DeleteAssocTimer(hWin);
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           BL       WM__DeleteAssocTimer
   1042              pWin = WM_H2P(hWin);
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           BL       GUI_ALLOC_h2p
   \   00000060   0060A0E1           MOV      R6,R0
   1043              /* Delete static memory device */
   1044              #if (WM_SUPPORT_STATIC_MEMDEV && GUI_SUPPORT_MEMDEV)
   1045                if (pWin->hMem) {
   \   00000064   240096E5           LDR      R0,[R6, #+36]
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   0100000A           BEQ      ??WM_DeleteWindow_4
   1046                  GUI_MEMDEV_Delete(pWin->hMem);
   \   00000070   ........           BL       GUI_MEMDEV_Delete
   1047                }
   1048              #endif
   1049              ResetNextDrawWin();              /* Make sure the window will no longer receive drawing messages */
   \   00000074   0000A0E3           MOV      R0,#+0
   \                     ??WM_DeleteWindow_4:
   \   00000078   1C1095E5           LDR      R1,[R5, #+28]
   \   0000007C   380185E5           STR      R0,[R5, #+312]
   \   00000080   011185E0           ADD      R1,R5,R1, LSL #+2
   \   00000084   EC2091E5           LDR      R2,[R1, #+236]
   \   00000088   040052E1           CMP      R2,R4
   1050              /* Make sure that focus is set to an existing window */
   1051              if (WM__ahWinFocus[WM__TOUCHED_LAYER] == hWin) {
   1052                WM__ahWinFocus[WM__TOUCHED_LAYER] = 0;
   \   0000008C   EC008105           STREQ    R0,[R1, #+236]
   1053              }
   1054              if (WM__ahCapture[WM__TOUCHED_LAYER] == hWin) {
   \   00000090   AC2091E5           LDR      R2,[R1, #+172]
   \   00000094   040052E1           CMP      R2,R4
   1055                WM__ahCapture[WM__TOUCHED_LAYER] = 0;
   \   00000098   AC008105           STREQ    R0,[R1, #+172]
   1056              }
   1057              /* check if critical handles are affected. If so, reset the window handle to 0 */
   1058              _CheckCriticalHandles(hWin);
   \   0000009C   241095E5           LDR      R1,[R5, #+36]
   \   000000A0   000051E3           CMP      R1,#+0
   \   000000A4   0B00001A           BNE      ??WM_DeleteWindow_5
   1059              /* Inform parent */
   1060              WM_NotifyParent(hWin, WM_NOTIFICATION_CHILD_DELETED);
   \                     ??WM_DeleteWindow_6:
   \   000000A8   0710A0E3           MOV      R1,#+7
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   ........           BL       WM_NotifyParent
   1061              /* Delete all children */
   1062              _DeleteAllChildren(pWin);
   \                     ??WM_DeleteWindow_7:
   \   000000B4   1C0096E5           LDR      R0,[R6, #+28]
   \   000000B8   ........           BL       WM_DeleteWindow
   \   000000BC   1C0096E5           LDR      R0,[R6, #+28]
   \   000000C0   000050E3           CMP      R0,#+0
   \   000000C4   FAFFFF1A           BNE      ??WM_DeleteWindow_7
   1063              #if WM_SUPPORT_NOTIFY_VIS_CHANGED
   1064                WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
   1065              #endif
   1066              WM__DetachWindow(hWin);
   \   000000C8   0400A0E1           MOV      R0,R4
   \   000000CC   ........           BL       WM__DetachWindow
   1067              /* Remove window from window stack */
   1068              WM__RemoveFromLinList(hWin);
   \   000000D0   200095E5           LDR      R0,[R5, #+32]
   \   000000D4   060000EA           B        ??WM_DeleteWindow_8
   \                     ??WM_DeleteWindow_5:
   \   000000D8   042091E5           LDR      R2,[R1, #+4]
   \   000000DC   040052E1           CMP      R2,R4
   \   000000E0   04008105           STREQ    R0,[R1, #+4]
   \   000000E4   001091E5           LDR      R1,[R1, #+0]
   \   000000E8   000051E3           CMP      R1,#+0
   \   000000EC   F9FFFF1A           BNE      ??WM_DeleteWindow_5
   \   000000F0   ECFFFFEA           B        ??WM_DeleteWindow_6
   \                     ??WM_DeleteWindow_8:
   \   000000F4   000050E3           CMP      R0,#+0
   \   000000F8   0800000A           BEQ      ??WM_DeleteWindow_9
   \   000000FC   ........           BL       GUI_ALLOC_h2p
   \   00000100   0070A0E1           MOV      R7,R0
   \   00000104   140097E5           LDR      R0,[R7, #+20]
   \   00000108   040050E1           CMP      R0,R4
   \   0000010C   F8FFFF1A           BNE      ??WM_DeleteWindow_8
   \   00000110   0400A0E1           MOV      R0,R4
   \   00000114   ........           BL       GUI_ALLOC_h2p
   \   00000118   140090E5           LDR      R0,[R0, #+20]
   \   0000011C   140087E5           STR      R0,[R7, #+20]
   1069              /* Handle transparency counter if necessary */
   1070              #if WM_SUPPORT_TRANSPARENCY
   1071                if (pWin->Status & WM_SF_HASTRANS) {
   \                     ??WM_DeleteWindow_9:
   \   00000120   280096E5           LDR      R0,[R6, #+40]
   \   00000124   010010E3           TST      R0,#0x1
   1072                  WM__TransWindowCnt--;
   \   00000128   30119515           LDRNE    R1,[R5, #+304]
   \   0000012C   01104112           SUBNE    R1,R1,#+1
   \   00000130   30118515           STRNE    R1,[R5, #+304]
   1073                }
   1074              #endif
   1075              /* Make sure window is no longer counted as invalid */
   1076              if (pWin->Status & WM_SF_INVALID) {
   \   00000134   200010E3           TST      R0,#0x20
   1077                WM__NumInvalidWindows--;
   \   00000138   BA01D511           LDRHNE   R0,[R5, #+26]
   \   0000013C   FF10A0E3           MOV      R1,#+255
   \   00000140   FF1C81E3           ORR      R1,R1,#0xFF00
   \   00000144   00008110           ADDNE    R0,R1,R0
   \   00000148   BA01C511           STRHNE   R0,[R5, #+26]
   1078              }
   1079              /* Free window memory */
   1080              WM__NumWindows--;
   \   0000014C   B801D5E1           LDRH     R0,[R5, #+24]
   \   00000150   000081E0           ADD      R0,R1,R0
   \   00000154   B801C5E1           STRH     R0,[R5, #+24]
   1081              GUI_ALLOC_Free(hWin);
   \   00000158   0400A0E1           MOV      R0,R4
   \   0000015C   ........           BL       GUI_ALLOC_Free
   1082              /* Select a valid window */
   1083              #if GUI_NUM_LAYERS == 1
   1084                WM_SelectWindow(WM__ahDesktopWin[0]);
   1085              #else
   1086                WM_SelectWindow(WM__ahDesktopWin[WM__TOUCHED_LAYER]);
   \   00000160   1C0095E5           LDR      R0,[R5, #+28]
   \   00000164   000185E0           ADD      R0,R5,R0, LSL #+2
   \   00000168   280090E5           LDR      R0,[R0, #+40]
   \   0000016C   ........           BL       WM_SelectWindow
   1087              #endif
   1088            } else {
   1089              GUI_DEBUG_WARN("WM_DeleteWindow: Invalid handle");
   1090            }
   1091            WM_UNLOCK();
   \                     ??WM_DeleteWindow_3:
   \   00000170   ........           BL       GUI_Unlock
   1092          }
   \                     ??WM_DeleteWindow_0:
   \   00000174   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000178   F080BDE8           POP      {R4-R7,PC}       ;; return
   1093          
   1094          /*********************************************************************
   1095          *
   1096          *       WM__GetTopLevelLayer
   1097          *
   1098          *  Purpose:
   1099          *    Returns the layer of the top level window
   1100          */
   1101          #if GUI_NUM_LAYERS > 1

   \                                 In section .text, align 4, keep-with-next
   1102          int WM__GetTopLevelLayer(WM_HWIN  hWin) {
   \                     WM__GetTopLevelLayer:
   \   00000000   10402DE9           PUSH     {R4,LR}
   1103            WM_HWIN hTop;
   1104            int Layer;
   1105          
   1106            hTop = _GetTopLevelWindow(hWin);
   \                     ??WM__GetTopLevelLayer_0:
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   ........           BL       GUI_ALLOC_h2p
   \   0000000C   180090E5           LDR      R0,[R0, #+24]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   FAFFFF1A           BNE      ??WM__GetTopLevelLayer_0
   1107            Layer = _DesktopHandle2Index(hTop);
   \   00000018   ........           LDR      R1,??DataTable9_1
   \   0000001C   283091E5           LDR      R3,[R1, #+40]
   \   00000020   2C2081E2           ADD      R2,R1,#+44
   \   00000024   030054E1           CMP      R4,R3
   \   00000028   0F00000A           BEQ      ??WM__GetTopLevelLayer_1
   \   0000002C   003092E5           LDR      R3,[R2, #+0]
   \   00000030   041081E2           ADD      R1,R1,#+4
   \   00000034   0100A0E3           MOV      R0,#+1
   \   00000038   2C1081E2           ADD      R1,R1,#+44
   \   0000003C   0720A0E3           MOV      R2,#+7
   \                     ??WM__GetTopLevelLayer_2:
   \   00000040   030054E1           CMP      R4,R3
   \   00000044   04C09114           LDRNE    R12,[R1], #+4
   \   00000048   01008012           ADDNE    R0,R0,#+1
   \   0000004C   0C005411           CMPNE    R4,R12
   \   00000050   0500000A           BEQ      ??WM__GetTopLevelLayer_1
   \   00000054   010080E2           ADD      R0,R0,#+1
   \   00000058   043091E4           LDR      R3,[R1], #+4
   \   0000005C   012052E2           SUBS     R2,R2,#+1
   \   00000060   F6FFFF1A           BNE      ??WM__GetTopLevelLayer_2
   \   00000064   030054E1           CMP      R4,R3
   \   00000068   0000E013           MVNNE    R0,#+0
   1108            return Layer;
   \                     ??WM__GetTopLevelLayer_1:
   \   0000006C   1080BDE8           POP      {R4,PC}          ;; return
   1109          }
   1110          #endif
   1111          
   1112          /*********************************************************************
   1113          *
   1114          *       WM__SelectTopLevelLayer
   1115          *
   1116          *  Purpose:
   1117          *    Selects the layer of the top level window
   1118          */
   1119          #if GUI_NUM_LAYERS > 1

   \                                 In section .text, align 4, keep-with-next
   1120          void WM__SelectTopLevelLayer(WM_HWIN  hWin) {
   \                     WM__SelectTopLevelLayer:
   \   00000000   10402DE9           PUSH     {R4,LR}
   1121            int Layer;
   1122          
   1123            Layer = WM__GetTopLevelLayer(hWin);
   \                     ??WM__SelectTopLevelLayer_0:
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   ........           BL       GUI_ALLOC_h2p
   \   0000000C   180090E5           LDR      R0,[R0, #+24]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   FAFFFF1A           BNE      ??WM__SelectTopLevelLayer_0
   \   00000018   ........           LDR      R1,??DataTable9_1
   \   0000001C   283091E5           LDR      R3,[R1, #+40]
   \   00000020   2C2081E2           ADD      R2,R1,#+44
   \   00000024   030054E1           CMP      R4,R3
   \   00000028   0F00000A           BEQ      ??WM__SelectTopLevelLayer_1
   \   0000002C   003092E5           LDR      R3,[R2, #+0]
   \   00000030   041081E2           ADD      R1,R1,#+4
   \   00000034   0100A0E3           MOV      R0,#+1
   \   00000038   2C1081E2           ADD      R1,R1,#+44
   \   0000003C   0720A0E3           MOV      R2,#+7
   \                     ??WM__SelectTopLevelLayer_2:
   \   00000040   030054E1           CMP      R4,R3
   \   00000044   04C09114           LDRNE    R12,[R1], #+4
   \   00000048   01008012           ADDNE    R0,R0,#+1
   \   0000004C   0C005411           CMPNE    R4,R12
   \   00000050   0500000A           BEQ      ??WM__SelectTopLevelLayer_1
   \   00000054   010080E2           ADD      R0,R0,#+1
   \   00000058   043091E4           LDR      R3,[R1], #+4
   \   0000005C   012052E2           SUBS     R2,R2,#+1
   \   00000060   F6FFFF1A           BNE      ??WM__SelectTopLevelLayer_2
   \   00000064   030054E1           CMP      R4,R3
   \   00000068   0200001A           BNE      ??WM__SelectTopLevelLayer_3
   1124            if (Layer >= 0) {
   \                     ??WM__SelectTopLevelLayer_1:
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   0000004A           BMI      ??WM__SelectTopLevelLayer_3
   1125              GUI_SelectLayer(Layer);
   \   00000074   ........           BL       GUI_SelectLayer
   1126            }
   1127          }
   \                     ??WM__SelectTopLevelLayer_3:
   \   00000078   1080BDE8           POP      {R4,PC}          ;; return
   1128          #endif
   1129          
   1130          /*********************************************************************
   1131          *
   1132          *       WM_SelectWindow
   1133          *
   1134          *  Sets the active Window. The active Window is the one that is used for all
   1135          *  drawing (and text) operations.
   1136          */

   \                                 In section .text, align 4, keep-with-next
   1137          WM_HWIN WM_SelectWindow(WM_HWIN  hWin) {
   \                     WM_SelectWindow:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0060A0E1           MOV      R6,R0
   1138            WM_HWIN hWinPrev;
   1139            WM_Obj* pObj;
   1140          
   1141            WM_ASSERT_NOT_IN_PAINT();
   1142            WM_LOCK();
   \   0000000C   ........           BL       GUI_Lock
   1143            hWinPrev = GUI_Context.hAWin;
   1144            if (hWin == 0) {
   \   00000010   000056E3           CMP      R6,#+0
   1145              hWin = WM__FirstWin;
   \   00000014   ........           LDREQ    R0,??DataTable23
   \   00000018   ........           LDR      R4,??DataTable17
   \   0000001C   20609005           LDREQ    R6,[R0, #+32]
   \   00000020   3C5094E5           LDR      R5,[R4, #+60]
   1146            }
   1147            /* Select new window */
   1148            GUI_Context.hAWin = hWin;
   \   00000024   3C6084E5           STR      R6,[R4, #+60]
   1149            #if GUI_NUM_LAYERS > 1
   1150              WM__SelectTopLevelLayer(hWin);
   \   00000028   0600A0E1           MOV      R0,R6
   \                     ??WM_SelectWindow_0:
   \   0000002C   0070A0E1           MOV      R7,R0
   \   00000030   ........           BL       GUI_ALLOC_h2p
   \   00000034   180090E5           LDR      R0,[R0, #+24]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   FAFFFF1A           BNE      ??WM_SelectWindow_0
   \   00000040   ........           LDR      R1,??DataTable23
   \   00000044   283091E5           LDR      R3,[R1, #+40]
   \   00000048   2C2081E2           ADD      R2,R1,#+44
   \   0000004C   030057E1           CMP      R7,R3
   \   00000050   0F00000A           BEQ      ??WM_SelectWindow_1
   \   00000054   003092E5           LDR      R3,[R2, #+0]
   \   00000058   041081E2           ADD      R1,R1,#+4
   \   0000005C   0100A0E3           MOV      R0,#+1
   \   00000060   2C1081E2           ADD      R1,R1,#+44
   \   00000064   0720A0E3           MOV      R2,#+7
   \                     ??WM_SelectWindow_2:
   \   00000068   030057E1           CMP      R7,R3
   \   0000006C   04C09114           LDRNE    R12,[R1], #+4
   \   00000070   01008012           ADDNE    R0,R0,#+1
   \   00000074   0C005711           CMPNE    R7,R12
   \   00000078   0500000A           BEQ      ??WM_SelectWindow_1
   \   0000007C   010080E2           ADD      R0,R0,#+1
   \   00000080   043091E4           LDR      R3,[R1], #+4
   \   00000084   012052E2           SUBS     R2,R2,#+1
   \   00000088   F6FFFF1A           BNE      ??WM_SelectWindow_2
   \   0000008C   030057E1           CMP      R7,R3
   \   00000090   0200001A           BNE      ??WM_SelectWindow_3
   \                     ??WM_SelectWindow_1:
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   0000004A           BMI      ??WM_SelectWindow_3
   \   0000009C   ........           BL       GUI_SelectLayer
   1151            #endif
   1152            pObj = WM_H2P(hWin);
   \                     ??WM_SelectWindow_3:
   \   000000A0   0600A0E1           MOV      R0,R6
   \   000000A4   ........           BL       GUI_ALLOC_h2p
   \   000000A8   0060A0E1           MOV      R6,R0
   1153            LCD_SetClipRectMax();             /* Drawing operations will clip ... If WM is deactivated, allow all */
   \   000000AC   ........           BL       LCD_SetClipRectMax
   1154            GUI_Context.xOff = pObj->Rect.x0;
   \   000000B0   F000D6E1           LDRSH    R0,[R6, #+0]
   \   000000B4   400084E5           STR      R0,[R4, #+64]
   1155            GUI_Context.yOff = pObj->Rect.y0;
   \   000000B8   F200D6E1           LDRSH    R0,[R6, #+2]
   \   000000BC   440084E5           STR      R0,[R4, #+68]
   1156            WM_UNLOCK();
   \   000000C0   ........           BL       GUI_Unlock
   1157            return hWinPrev;
   \   000000C4   0500A0E1           MOV      R0,R5
   \   000000C8   04D08DE2           ADD      SP,SP,#+4
   \   000000CC   F080BDE8           POP      {R4-R7,PC}       ;; return
   1158          }
   1159          
   1160          /*********************************************************************
   1161          *
   1162          *       WM_GetActiveWindow
   1163          */

   \                                 In section .text, align 4, keep-with-next
   1164          WM_HWIN WM_GetActiveWindow(void) {
   1165            return GUI_Context.hAWin;
   \                     WM_GetActiveWindow:
   \   00000000   ........           LDR      R0,??DataTable17
   \   00000004   3C0090E5           LDR      R0,[R0, #+60]
   \   00000008   1EFF2FE1           BX       LR               ;; return
   1166          }
   1167          
   1168          
   1169          /*********************************************************************
   1170          *
   1171          *       IVR calculation
   1172          *
   1173          **********************************************************************
   1174          
   1175          IVRs are invalid rectangles. When redrawing, only the portion of the
   1176          window which is
   1177            a) within the window-rectangle
   1178            b) not covered by an other window
   1179            c) marked as invalid
   1180            is actually redrawn. Unfortunately, this section is not always
   1181            rectangular. If the window is partially covered by an other window,
   1182            it consists of the sum of multiple rectangles. In all drawing
   1183            operations, we have to iterate over every one of these rectangles in
   1184            order to make sure the window is drawn completly.
   1185          Function works as follows:
   1186            STEP 1: - Set upper left coordinates to next pixel. If end of line (right border), goto next line -> (r.x0, r.y0)
   1187            STEP 2: - Check if we are done, return if we are.
   1188            STEP 3: - If we are at the left border, find max. heigtht (r.y1) by iterating over windows above
   1189            STEP 4: - Find x0 for the given y0, y1 by iterating over windows above
   1190            STEP 5: - If r.x0 out of right border, this stripe is done. Set next stripe and goto STEP 2
   1191            STEP 6: - Find r.x1. We have to Iterate over all windows which are above
   1192          */
   1193          
   1194          /*********************************************************************
   1195          *
   1196          *       _FindNext_IVR
   1197          */
   1198          #if WM_SUPPORT_OBSTRUCT

   \                                 In section .text, align 4, keep-with-next
   1199          static int _FindNext_IVR(void) {
   \                     _FindNext_IVR:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   1200            WM_HMEM hParent;
   1201            GUI_RECT r;
   1202            WM_Obj * pAWin;
   1203            WM_Obj * pParent;
   1204          
   1205            r = _ClipContext.CurRect;  /* temps  so we do not have to work with pointers too much */
   \   00000004   ........           LDR      R4,??DataTable23
   \   00000008   14D04DE2           SUB      SP,SP,#+20
   \   0000000C   080094E5           LDR      R0,[R4, #+8]
   \   00000010   0C1094E5           LDR      R1,[R4, #+12]
   \   00000014   0D20A0E1           MOV      R2,SP
   \   00000018   030082E8           STM      R2,{R0,R1}
   1206            /*
   1207               STEP 1:
   1208                 Set the next position which could be part of the next IVR
   1209                 This will be the first unhandle pixel in reading order, i.e. next one to the right
   1210                 or next one down if we are at the right border.
   1211            */
   1212            if (_ClipContext.Cnt == 0) {       /* First IVR starts in upper left */
   \   0000001C   100094E5           LDR      R0,[R4, #+16]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0400001A           BNE      ??_FindNext_IVR_0
   1213              r.x0 = _ClipContext.ClientRect.x0;
   \   00000028   F010D4E1           LDRSH    R1,[R4, #+0]
   \   0000002C   B010CDE1           STRH     R1,[SP, #+0]
   1214              r.y0 = _ClipContext.ClientRect.y0;
   \   00000030   F210D4E1           LDRSH    R1,[R4, #+2]
   \   00000034   B210CDE1           STRH     R1,[SP, #+2]
   \   00000038   0D0000EA           B        ??_FindNext_IVR_1
   1215            } else {
   1216              r.x0 = _ClipContext.CurRect.x1+1;
   \                     ??_FindNext_IVR_0:
   \   0000003C   FC00D4E1           LDRSH    R0,[R4, #+12]
   1217              r.y0 = _ClipContext.CurRect.y0;
   \   00000040   FA10D4E1           LDRSH    R1,[R4, #+10]
   \   00000044   010080E2           ADD      R0,R0,#+1
   \   00000048   B000CDE1           STRH     R0,[SP, #+0]
   \   0000004C   B210CDE1           STRH     R1,[SP, #+2]
   1218              if (r.x0 > _ClipContext.ClientRect.x1) {
   \   00000050   F400D4E1           LDRSH    R0,[R4, #+4]
   \   00000054   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000058   010050E1           CMP      R0,R1
   \   0000005C   040000AA           BGE      ??_FindNext_IVR_1
   1219          NextStripe:  /* go down to next stripe */
   1220                r.x0 = _ClipContext.ClientRect.x0;
   1221                r.y0 = _ClipContext.CurRect.y1+1;
   \                     ??_FindNext_IVR_2:
   \   00000060   FE00D4E1           LDRSH    R0,[R4, #+14]
   \   00000064   F010D4E1           LDRSH    R1,[R4, #+0]
   \   00000068   010080E2           ADD      R0,R0,#+1
   \   0000006C   B010CDE1           STRH     R1,[SP, #+0]
   \   00000070   B200CDE1           STRH     R0,[SP, #+2]
   1222              }
   1223            }
   1224            /*
   1225               STEP 2:
   1226                 Check if we are done completely.
   1227            */
   1228            if (r.y0 >_ClipContext.ClientRect.y1) {
   \                     ??_FindNext_IVR_1:
   \   00000074   F600D4E1           LDRSH    R0,[R4, #+6]
   \   00000078   F210DDE1           LDRSH    R1,[SP, #+2]
   \   0000007C   010050E1           CMP      R0,R1
   \   00000080   010000AA           BGE      ??_FindNext_IVR_3
   1229              return 0;
   \                     ??_FindNext_IVR_4:
   \   00000084   0000A0E3           MOV      R0,#+0
   \   00000088   E60000EA           B        ??_FindNext_IVR_5
   1230            }
   1231            /* STEP 3:
   1232                 Find out the max. height (r.y1) if we are at the left border.
   1233                 Since we are using the same height for all IVRs at the same y0,
   1234                 we do this only for the leftmost one.
   1235            */
   1236            pAWin = WM_H2P(GUI_Context.hAWin);
   \                     ??_FindNext_IVR_3:
   \   0000008C   ........           LDR      R6,??DataTable17
   \   00000090   3C0096E5           LDR      R0,[R6, #+60]
   \   00000094   ........           BL       GUI_ALLOC_h2p
   \   00000098   0050A0E1           MOV      R5,R0
   1237            if (r.x0 == _ClipContext.ClientRect.x0) {
   \   0000009C   F000DDE1           LDRSH    R0,[SP, #+0]
   \   000000A0   F010D4E1           LDRSH    R1,[R4, #+0]
   \   000000A4   010050E1           CMP      R0,R1
   \   000000A8   1300001A           BNE      ??_FindNext_IVR_6
   1238              r.y1 = _ClipContext.ClientRect.y1;
   \   000000AC   F610D4E1           LDRSH    R1,[R4, #+6]
   1239              r.x1 = _ClipContext.ClientRect.x1;
   1240              /* Iterate over all windows which are above */
   1241              /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
   1242              for (hParent = GUI_Context.hAWin; hParent; hParent = pParent->hParent) {
   \   000000B0   3C0096E5           LDR      R0,[R6, #+60]
   \   000000B4   B610CDE1           STRH     R1,[SP, #+6]
   \   000000B8   F410D4E1           LDRSH    R1,[R4, #+4]
   \   000000BC   000050E3           CMP      R0,#+0
   \   000000C0   B410CDE1           STRH     R1,[SP, #+4]
   \   000000C4   0800000A           BEQ      ??_FindNext_IVR_7
   1243                pParent = WM_H2P(hParent);
   \                     ??_FindNext_IVR_8:
   \   000000C8   ........           BL       GUI_ALLOC_h2p
   \   000000CC   0070A0E1           MOV      R7,R0
   1244                _Findy1(pParent->hNext, &r, NULL);
   \   000000D0   0020A0E3           MOV      R2,#+0
   \   000000D4   0D10A0E1           MOV      R1,SP
   \   000000D8   200097E5           LDR      R0,[R7, #+32]
   \   000000DC   ........           BL       _Findy1
   1245              }
   \   000000E0   180097E5           LDR      R0,[R7, #+24]
   \   000000E4   000050E3           CMP      R0,#+0
   \   000000E8   F6FFFF1A           BNE      ??_FindNext_IVR_8
   1246              /* Check all children */
   1247              _Findy1(pAWin->hFirstChild, &r, NULL);
   \                     ??_FindNext_IVR_7:
   \   000000EC   0020A0E3           MOV      R2,#+0
   \   000000F0   0D10A0E1           MOV      R1,SP
   \   000000F4   1C0095E5           LDR      R0,[R5, #+28]
   \   000000F8   ........           BL       _Findy1
   1248            }
   1249            /* 
   1250              STEP 4
   1251                Find out x0 for the given y0, y1 by iterating over windows above.
   1252                if we find one that intersects, adjust x0 to the right.
   1253            */
   1254          Find_x0:
   1255            r.x1 = r.x0;
   \                     ??_FindNext_IVR_6:
   \   000000FC   F010DDE1           LDRSH    R1,[SP, #+0]
   1256            /* Iterate over all windows which are above */
   1257            /* Check all siblings above (siblings of window, siblings of parents, etc ...) */
   1258            #if 0   /* This is a planned, but not yet released optimization */
   1259              if (Status & WM_SF_DONT_CLIP_SIBLINGS)
   1260              {
   1261                hParent = pAWin->hParent;
   1262              } else
   1263            #endif
   1264            {
   1265              hParent = GUI_Context.hAWin;
   \   00000100   3C0096E5           LDR      R0,[R6, #+60]
   \   00000104   B410CDE1           STRH     R1,[SP, #+4]
   \   00000108   090000EA           B        ??_FindNext_IVR_9
   1266            }
   1267            for (; hParent; hParent = pParent->hParent) {
   \                     ??_FindNext_IVR_10:
   \   0000010C   FC00DDE1           LDRSH    R0,[SP, #+12]
   \   00000110   0180A0E3           MOV      R8,#+1
   \   00000114   010080E2           ADD      R0,R0,#+1
   \   00000118   B000CDE1           STRH     R0,[SP, #+0]
   \                     ??_FindNext_IVR_11:
   \   0000011C   200099E5           LDR      R0,[R9, #+32]
   \   00000120   000050E3           CMP      R0,#+0
   \   00000124   0A00001A           BNE      ??_FindNext_IVR_12
   1268              pParent = WM_H2P(hParent);
   1269              if (_Findx0(pParent->hNext, &r, NULL)) {
   \   00000128   000058E3           CMP      R8,#+0
   \   0000012C   F2FFFF1A           BNE      ??_FindNext_IVR_6
   \                     ??_FindNext_IVR_13:
   \   00000130   180097E5           LDR      R0,[R7, #+24]
   \                     ??_FindNext_IVR_9:
   \   00000134   000050E3           CMP      R0,#+0
   \   00000138   2500000A           BEQ      ??_FindNext_IVR_14
   \   0000013C   ........           BL       GUI_ALLOC_h2p
   \   00000140   0070A0E1           MOV      R7,R0
   \   00000144   200097E5           LDR      R0,[R7, #+32]
   \   00000148   0080A0E3           MOV      R8,#+0
   \   0000014C   000050E3           CMP      R0,#+0
   \   00000150   F6FFFF0A           BEQ      ??_FindNext_IVR_13
   \                     ??_FindNext_IVR_12:
   \   00000154   ........           BL       GUI_ALLOC_h2p
   \   00000158   0090A0E1           MOV      R9,R0
   \   0000015C   28A099E5           LDR      R10,[R9, #+40]
   \   00000160   02001AE3           TST      R10,#0x2
   \   00000164   ECFFFF0A           BEQ      ??_FindNext_IVR_11
   \   00000168   08008DE2           ADD      R0,SP,#+8
   \   0000016C   0910A0E1           MOV      R1,R9
   \   00000170   0820A0E3           MOV      R2,#+8
   \   00000174   ........           BL       __aeabi_memcpy
   \   00000178   08108DE2           ADD      R1,SP,#+8
   \   0000017C   0D00A0E1           MOV      R0,SP
   \   00000180   ........           BL       GUI_RectsIntersect
   \   00000184   000050E3           CMP      R0,#+0
   \   00000188   E3FFFF0A           BEQ      ??_FindNext_IVR_11
   \   0000018C   01001AE3           TST      R10,#0x1
   \   00000190   DDFFFF0A           BEQ      ??_FindNext_IVR_10
   \   00000194   1CA099E5           LDR      R10,[R9, #+28]
   \   00000198   00005AE3           CMP      R10,#+0
   \   0000019C   DEFFFF0A           BEQ      ??_FindNext_IVR_11
   \                     ??_FindNext_IVR_15:
   \   000001A0   0A00A0E1           MOV      R0,R10
   \   000001A4   ........           BL       GUI_ALLOC_h2p
   \   000001A8   00B0A0E1           MOV      R11,R0
   \   000001AC   08208DE2           ADD      R2,SP,#+8
   \   000001B0   0D10A0E1           MOV      R1,SP
   \   000001B4   0A00A0E1           MOV      R0,R10
   \   000001B8   ........           BL       _Findx0
   \   000001BC   000050E3           CMP      R0,#+0
   \   000001C0   20A09BE5           LDR      R10,[R11, #+32]
   \   000001C4   0180A013           MOVNE    R8,#+1
   \   000001C8   00005AE3           CMP      R10,#+0
   \   000001CC   F3FFFF1A           BNE      ??_FindNext_IVR_15
   \   000001D0   D1FFFFEA           B        ??_FindNext_IVR_11
   1270                goto Find_x0;
   1271              }
   1272            }
   1273            /* Check all children */
   1274            if (_Findx0(pAWin->hFirstChild, &r, NULL)) {
   \                     ??_FindNext_IVR_14:
   \   000001D4   1C0095E5           LDR      R0,[R5, #+28]
   \   000001D8   0070A0E3           MOV      R7,#+0
   \   000001DC   000050E3           CMP      R0,#+0
   \   000001E0   2800000A           BEQ      ??_FindNext_IVR_16
   \                     ??_FindNext_IVR_17:
   \   000001E4   ........           BL       GUI_ALLOC_h2p
   \   000001E8   0080A0E1           MOV      R8,R0
   \   000001EC   289098E5           LDR      R9,[R8, #+40]
   \   000001F0   020019E3           TST      R9,#0x2
   \   000001F4   1E00000A           BEQ      ??_FindNext_IVR_18
   \   000001F8   08008DE2           ADD      R0,SP,#+8
   \   000001FC   0810A0E1           MOV      R1,R8
   \   00000200   0820A0E3           MOV      R2,#+8
   \   00000204   ........           BL       __aeabi_memcpy
   \   00000208   08108DE2           ADD      R1,SP,#+8
   \   0000020C   0D00A0E1           MOV      R0,SP
   \   00000210   ........           BL       GUI_RectsIntersect
   \   00000214   000050E3           CMP      R0,#+0
   \   00000218   1500000A           BEQ      ??_FindNext_IVR_18
   \   0000021C   010019E3           TST      R9,#0x1
   \   00000220   0F00000A           BEQ      ??_FindNext_IVR_19
   \   00000224   1C9098E5           LDR      R9,[R8, #+28]
   \   00000228   000059E3           CMP      R9,#+0
   \   0000022C   1000000A           BEQ      ??_FindNext_IVR_18
   \                     ??_FindNext_IVR_20:
   \   00000230   0900A0E1           MOV      R0,R9
   \   00000234   ........           BL       GUI_ALLOC_h2p
   \   00000238   00A0A0E1           MOV      R10,R0
   \   0000023C   08208DE2           ADD      R2,SP,#+8
   \   00000240   0D10A0E1           MOV      R1,SP
   \   00000244   0900A0E1           MOV      R0,R9
   \   00000248   ........           BL       _Findx0
   \   0000024C   000050E3           CMP      R0,#+0
   \   00000250   20909AE5           LDR      R9,[R10, #+32]
   \   00000254   0170A013           MOVNE    R7,#+1
   \   00000258   000059E3           CMP      R9,#+0
   \   0000025C   F3FFFF1A           BNE      ??_FindNext_IVR_20
   \   00000260   030000EA           B        ??_FindNext_IVR_18
   \                     ??_FindNext_IVR_19:
   \   00000264   FC00DDE1           LDRSH    R0,[SP, #+12]
   \   00000268   0170A0E3           MOV      R7,#+1
   \   0000026C   010080E2           ADD      R0,R0,#+1
   \   00000270   B000CDE1           STRH     R0,[SP, #+0]
   \                     ??_FindNext_IVR_18:
   \   00000274   200098E5           LDR      R0,[R8, #+32]
   \   00000278   000050E3           CMP      R0,#+0
   \   0000027C   D8FFFF1A           BNE      ??_FindNext_IVR_17
   \   00000280   000057E3           CMP      R7,#+0
   \   00000284   9CFFFF1A           BNE      ??_FindNext_IVR_6
   1275              goto Find_x0;
   1276            }
   1277            /* 
   1278             STEP 5:
   1279               If r.x0 out of right border, this stripe is done. Set next stripe and goto STEP 2
   1280               Find out x1 for the given x0, y0, y1
   1281            */
   1282            r.x1 = _ClipContext.ClientRect.x1;
   \                     ??_FindNext_IVR_16:
   \   00000288   F400D4E1           LDRSH    R0,[R4, #+4]
   1283            if (r.x1 < r.x0) {/* horizontal border reached ? */
   \   0000028C   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000290   B400CDE1           STRH     R0,[SP, #+4]
   \   00000294   010050E1           CMP      R0,R1
   \   00000298   040000AA           BGE      ??_FindNext_IVR_21
   1284              _ClipContext.CurRect = r;
   \   0000029C   00209DE5           LDR      R2,[SP, #+0]
   \   000002A0   04309DE5           LDR      R3,[SP, #+4]
   \   000002A4   082084E5           STR      R2,[R4, #+8]
   \   000002A8   0C3084E5           STR      R3,[R4, #+12]
   1285              goto NextStripe;
   \   000002AC   6BFFFFEA           B        ??_FindNext_IVR_2
   1286            }    
   1287            /* 
   1288             STEP 6:
   1289               Find r.x1. We have to Iterate over all windows which are above
   1290            */
   1291            /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
   1292            #if 0   /* This is a planned, but not yet released optimization */
   1293              if (Status & WM_SF_DONT_CLIP_SIBLINGS)
   1294              {
   1295                hParent = pAWin->hParent;
   1296              } else
   1297            #endif
   1298            {
   1299              hParent = GUI_Context.hAWin;
   \                     ??_FindNext_IVR_21:
   \   000002B0   3C0096E5           LDR      R0,[R6, #+60]
   1300            }
   1301            for (; hParent; hParent = pParent->hParent) {
   \   000002B4   000050E3           CMP      R0,#+0
   \   000002B8   2B00000A           BEQ      ??_FindNext_IVR_22
   1302              pParent = WM_H2P(hParent);
   \                     ??_FindNext_IVR_23:
   \   000002BC   ........           BL       GUI_ALLOC_h2p
   \   000002C0   0070A0E1           MOV      R7,R0
   1303              _Findx1(pParent->hNext, &r, NULL);
   \   000002C4   200097E5           LDR      R0,[R7, #+32]
   \   000002C8   000050E3           CMP      R0,#+0
   \   000002CC   2300000A           BEQ      ??_FindNext_IVR_24
   \                     ??_FindNext_IVR_25:
   \   000002D0   ........           BL       GUI_ALLOC_h2p
   \   000002D4   0060A0E1           MOV      R6,R0
   \   000002D8   288096E5           LDR      R8,[R6, #+40]
   \   000002DC   020018E3           TST      R8,#0x2
   \   000002E0   1B00000A           BEQ      ??_FindNext_IVR_26
   \   000002E4   08008DE2           ADD      R0,SP,#+8
   \   000002E8   0610A0E1           MOV      R1,R6
   \   000002EC   0820A0E3           MOV      R2,#+8
   \   000002F0   ........           BL       __aeabi_memcpy
   \   000002F4   08108DE2           ADD      R1,SP,#+8
   \   000002F8   0D00A0E1           MOV      R0,SP
   \   000002FC   ........           BL       GUI_RectsIntersect
   \   00000300   000050E3           CMP      R0,#+0
   \   00000304   1200000A           BEQ      ??_FindNext_IVR_26
   \   00000308   010018E3           TST      R8,#0x1
   \   0000030C   0D00000A           BEQ      ??_FindNext_IVR_27
   \   00000310   1C8096E5           LDR      R8,[R6, #+28]
   \   00000314   000058E3           CMP      R8,#+0
   \   00000318   0D00000A           BEQ      ??_FindNext_IVR_26
   \                     ??_FindNext_IVR_28:
   \   0000031C   0800A0E1           MOV      R0,R8
   \   00000320   ........           BL       GUI_ALLOC_h2p
   \   00000324   0090A0E1           MOV      R9,R0
   \   00000328   08208DE2           ADD      R2,SP,#+8
   \   0000032C   0D10A0E1           MOV      R1,SP
   \   00000330   0800A0E1           MOV      R0,R8
   \   00000334   ........           BL       _Findx1
   \   00000338   208099E5           LDR      R8,[R9, #+32]
   \   0000033C   000058E3           CMP      R8,#+0
   \   00000340   F5FFFF1A           BNE      ??_FindNext_IVR_28
   \   00000344   020000EA           B        ??_FindNext_IVR_26
   \                     ??_FindNext_IVR_27:
   \   00000348   F810DDE1           LDRSH    R1,[SP, #+8]
   \   0000034C   011041E2           SUB      R1,R1,#+1
   \   00000350   B410CDE1           STRH     R1,[SP, #+4]
   \                     ??_FindNext_IVR_26:
   \   00000354   200096E5           LDR      R0,[R6, #+32]
   \   00000358   000050E3           CMP      R0,#+0
   \   0000035C   DBFFFF1A           BNE      ??_FindNext_IVR_25
   1304            }
   \                     ??_FindNext_IVR_24:
   \   00000360   180097E5           LDR      R0,[R7, #+24]
   \   00000364   000050E3           CMP      R0,#+0
   \   00000368   D3FFFF1A           BNE      ??_FindNext_IVR_23
   1305            /* Check all children */
   1306            _Findx1(pAWin->hFirstChild, &r, NULL);
   \                     ??_FindNext_IVR_22:
   \   0000036C   1C0095E5           LDR      R0,[R5, #+28]
   \   00000370   000050E3           CMP      R0,#+0
   \   00000374   2300000A           BEQ      ??_FindNext_IVR_29
   \                     ??_FindNext_IVR_30:
   \   00000378   ........           BL       GUI_ALLOC_h2p
   \   0000037C   0050A0E1           MOV      R5,R0
   \   00000380   286095E5           LDR      R6,[R5, #+40]
   \   00000384   020016E3           TST      R6,#0x2
   \   00000388   1B00000A           BEQ      ??_FindNext_IVR_31
   \   0000038C   08008DE2           ADD      R0,SP,#+8
   \   00000390   0510A0E1           MOV      R1,R5
   \   00000394   0820A0E3           MOV      R2,#+8
   \   00000398   ........           BL       __aeabi_memcpy
   \   0000039C   08108DE2           ADD      R1,SP,#+8
   \   000003A0   0D00A0E1           MOV      R0,SP
   \   000003A4   ........           BL       GUI_RectsIntersect
   \   000003A8   000050E3           CMP      R0,#+0
   \   000003AC   1200000A           BEQ      ??_FindNext_IVR_31
   \   000003B0   010016E3           TST      R6,#0x1
   \   000003B4   0D00000A           BEQ      ??_FindNext_IVR_32
   \   000003B8   1C6095E5           LDR      R6,[R5, #+28]
   \   000003BC   000056E3           CMP      R6,#+0
   \   000003C0   0D00000A           BEQ      ??_FindNext_IVR_31
   \                     ??_FindNext_IVR_33:
   \   000003C4   0600A0E1           MOV      R0,R6
   \   000003C8   ........           BL       GUI_ALLOC_h2p
   \   000003CC   0070A0E1           MOV      R7,R0
   \   000003D0   08208DE2           ADD      R2,SP,#+8
   \   000003D4   0D10A0E1           MOV      R1,SP
   \   000003D8   0600A0E1           MOV      R0,R6
   \   000003DC   ........           BL       _Findx1
   \   000003E0   206097E5           LDR      R6,[R7, #+32]
   \   000003E4   000056E3           CMP      R6,#+0
   \   000003E8   F5FFFF1A           BNE      ??_FindNext_IVR_33
   \   000003EC   020000EA           B        ??_FindNext_IVR_31
   \                     ??_FindNext_IVR_32:
   \   000003F0   F810DDE1           LDRSH    R1,[SP, #+8]
   \   000003F4   011041E2           SUB      R1,R1,#+1
   \   000003F8   B410CDE1           STRH     R1,[SP, #+4]
   \                     ??_FindNext_IVR_31:
   \   000003FC   200095E5           LDR      R0,[R5, #+32]
   \   00000400   000050E3           CMP      R0,#+0
   \   00000404   DBFFFF1A           BNE      ??_FindNext_IVR_30
   1307            /* We are done. Return the rectangle we found in the _ClipContext. */
   1308            if (_ClipContext.Cnt >200) {
   \                     ??_FindNext_IVR_29:
   \   00000408   100094E5           LDR      R0,[R4, #+16]
   \   0000040C   C90050E3           CMP      R0,#+201
   \   00000410   1BFFFFAA           BGE      ??_FindNext_IVR_4
   1309              return 0;  /* error !!! This should not happen !*/
   1310            }
   1311            _ClipContext.CurRect = r;
   \   00000414   00209DE5           LDR      R2,[SP, #+0]
   \   00000418   04309DE5           LDR      R3,[SP, #+4]
   \   0000041C   082084E5           STR      R2,[R4, #+8]
   \   00000420   0C3084E5           STR      R3,[R4, #+12]
   1312            return 1;  /* IVR is valid ! */
   \   00000424   0100A0E3           MOV      R0,#+1
   \                     ??_FindNext_IVR_5:
   \   00000428   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   0000042C   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1313          }
   1314          
   1315          #else
   1316          
   1317          static int _FindNext_IVR(void) {
   1318            if (_ClipContext.Cnt ==0) {
   1319              _ClipContext.CurRect = GUI_Context.pAWin->Rect;
   1320              return 1;  /* IVR is valid ! */
   1321            }
   1322            return 0;  /* Nothing left to draw */
   1323          }
   1324          #endif
   1325          
   1326          /*********************************************************************
   1327          *
   1328          *       WM_GetNextIVR
   1329          
   1330            Sets the next clipping rectangle. If a valid one has
   1331            been found (and set), 1 is returned in order to indicate
   1332            that the drawing operation needs to be executed.
   1333            Returning 0 signals that we have iterated over all
   1334            rectangles.
   1335          
   1336            Returns: 0 if no valid rectangle is found
   1337                     1 if rectangle has been found
   1338          */

   \                                 In section .text, align 4, keep-with-next
   1339          int  WM__GetNextIVR(void) {
   \                     WM__GetNextIVR:
   \   00000000   10402DE9           PUSH     {R4,LR}
   1340            /* If WM is not active, we have no rectangles to return */
   1341            if (WM_IsActive==0) {
   \   00000004   ........           LDR      R4,??DataTable27
   \   00000008   4001D4E5           LDRB     R0,[R4, #+320]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0F00000A           BEQ      ??WM__GetNextIVR_0
   1342              return 0;
   1343            }
   1344            if (_ClipContext.EntranceCnt > 1) {
   \   00000014   140094E5           LDR      R0,[R4, #+20]
   \   00000018   020050E3           CMP      R0,#+2
   \   0000001C   040000BA           BLT      ??WM__GetNextIVR_1
   1345              _ClipContext.EntranceCnt--;
   \                     ??WM__GetNextIVR_2:
   \   00000020   140094E5           LDR      R0,[R4, #+20]
   \   00000024   010040E2           SUB      R0,R0,#+1
   \   00000028   140084E5           STR      R0,[R4, #+20]
   1346              return 0;
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   1080BDE8           POP      {R4,PC}
   1347            }
   1348            ++_ClipContext.Cnt;
   \                     ??WM__GetNextIVR_1:
   \   00000034   100094E5           LDR      R0,[R4, #+16]
   \   00000038   010080E2           ADD      R0,R0,#+1
   \   0000003C   100084E5           STR      R0,[R4, #+16]
   1349            /* Find next rectangle and use it as ClipRect */
   1350            if (!_FindNext_IVR()) {
   \   00000040   ........           BL       _FindNext_IVR
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   F4FFFF0A           BEQ      ??WM__GetNextIVR_2
   1351              _ClipContext.EntranceCnt--;  /* This search is over ! */
   1352              return 0;        /* Could not find an other one ! */
   1353            }
   1354            WM__ActivateClipRect();
   \   0000004C   ........           BL       WM__ActivateClipRect
   1355            /* Hide cursor if necessary */
   1356            return 1;
   \   00000050   0100A0E3           MOV      R0,#+1
   \                     ??WM__GetNextIVR_0:
   \   00000054   1080BDE8           POP      {R4,PC}          ;; return
   1357          }
   1358          
   1359          /*********************************************************************
   1360          *
   1361          *       WM__InitIVRSearch
   1362          
   1363            This routine is called from the clipping level
   1364            (the WM_ITERATE_START macro) when starting an iteration over the
   1365            visible rectangles.
   1366          
   1367            Return value:
   1368              0 : There is no valid rectangle (nothing to do ...)
   1369              1 : There is a valid rectangle
   1370          */

   \                                 In section .text, align 4, keep-with-next
   1371          int WM__InitIVRSearch(const GUI_RECT* pMaxRect) {
   \                     WM__InitIVRSearch:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   1372            GUI_RECT r;
   1373            GUI_RECT rUser;
   1374            WM_Obj * pAWin;
   1375            WM_Obj * pWin;
   1376          
   1377            GUI_ASSERT_LOCK();   /* GUI_LOCK must have been "called" before entering this (normally done indrawing routine) */
   1378             /* If WM is not active -> nothing to do, leave cliprect alone */
   1379            if (WM_IsActive==0) {
   \   00000004   ........           LDR      R4,??DataTable23
   \   00000008   0060A0E1           MOV      R6,R0
   \   0000000C   4001D4E5           LDRB     R0,[R4, #+320]
   \   00000010   14D04DE2           SUB      SP,SP,#+20
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0200001A           BNE      ??WM__InitIVRSearch_0
   1380              WM__ActivateClipRect();
   \                     ??WM__InitIVRSearch_1:
   \   0000001C   ........           BL       WM__ActivateClipRect
   1381              return 1;
   \                     ??WM__InitIVRSearch_2:
   \   00000020   0100A0E3           MOV      R0,#+1
   \   00000024   8B0000EA           B        ??WM__InitIVRSearch_3
   1382            }
   1383            /* If we entered multiple times, leave Cliprect alone */
   1384            if (++_ClipContext.EntranceCnt > 1) {
   \                     ??WM__InitIVRSearch_0:
   \   00000028   140094E5           LDR      R0,[R4, #+20]
   \   0000002C   010080E2           ADD      R0,R0,#+1
   \   00000030   140084E5           STR      R0,[R4, #+20]
   \   00000034   020050E3           CMP      R0,#+2
   \   00000038   F8FFFFAA           BGE      ??WM__InitIVRSearch_2
   1385              return 1;
   1386            }
   1387            pAWin = WM_H2P(GUI_Context.hAWin);
   \   0000003C   ........           LDR      R5,??DataTable27_1
   \   00000040   3C0095E5           LDR      R0,[R5, #+60]
   \   00000044   ........           BL       GUI_ALLOC_h2p
   \   00000048   0070A0E1           MOV      R7,R0
   1388            _ClipContext.Cnt        = -1;
   \   0000004C   0000E0E3           MVN      R0,#+0
   \   00000050   100084E5           STR      R0,[R4, #+16]
   1389           /* When using callback mechanism, it is legal to reduce drawing
   1390              area to the invalid area ! */
   1391            if (WM__PaintCallbackCnt) {
   \   00000054   4101D4E5           LDRB     R0,[R4, #+321]
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   1E00000A           BEQ      ??WM__InitIVRSearch_4
   1392              WM__GetInvalidRectAbs(pAWin, &r);
   \   00000060   0D00A0E1           MOV      R0,SP
   \   00000064   081087E2           ADD      R1,R7,#+8
   \                     ??WM__InitIVRSearch_5:
   \   00000068   0820A0E3           MOV      R2,#+8
   \   0000006C   ........           BL       __aeabi_memcpy
   1393            } else {  /* Not using callback mechanism, therefor allow entire rectangle */
   1394              if (pAWin->Status & WM_SF_ISVIS) {
   1395                r = pAWin->Rect;
   1396              } else {
   1397                --_ClipContext.EntranceCnt;
   1398                return 0;  /* window is not even visible ! */
   1399              }
   1400            }
   1401            /* If the drawing routine has specified a rectangle, use it to reduce the rectangle */
   1402            if (pMaxRect) {
   \   00000070   000056E3           CMP      R6,#+0
   \   00000074   0200000A           BEQ      ??WM__InitIVRSearch_6
   1403              GUI__IntersectRect(&r, pMaxRect);
   \   00000078   0610A0E1           MOV      R1,R6
   \   0000007C   0D00A0E1           MOV      R0,SP
   \   00000080   ........           BL       GUI__IntersectRect
   1404            }
   1405            /* If user has reduced the cliprect size, reduce the rectangle */
   1406            if (GUI_Context.WM__pUserClipRect) {
   \                     ??WM__InitIVRSearch_6:
   \   00000084   381095E5           LDR      R1,[R5, #+56]
   \   00000088   000051E3           CMP      R1,#+0
   \   0000008C   0E00000A           BEQ      ??WM__InitIVRSearch_7
   1407              pWin  = pAWin;
   1408              rUser = *(GUI_Context.WM__pUserClipRect);
   \   00000090   08008DE2           ADD      R0,SP,#+8
   \   00000094   0820A0E3           MOV      R2,#+8
   \   00000098   ........           BL       __aeabi_memcpy
   1409              #if WM_SUPPORT_TRANSPARENCY
   1410                if (WM__hATransWindow) {
   \   0000009C   340194E5           LDR      R0,[R4, #+308]
   \   000000A0   000050E3           CMP      R0,#+0
   \   000000A4   0100000A           BEQ      ??WM__InitIVRSearch_8
   1411                  pWin = WM_H2P(WM__hATransWindow);
   \   000000A8   ........           BL       GUI_ALLOC_h2p
   \   000000AC   0070A0E1           MOV      R7,R0
   1412                }   
   1413              #endif
   1414              WM__Client2Screen(pWin, &rUser);
   \                     ??WM__InitIVRSearch_8:
   \   000000B0   F220D7E1           LDRSH    R2,[R7, #+2]
   \   000000B4   F010D7E1           LDRSH    R1,[R7, #+0]
   \   000000B8   08008DE2           ADD      R0,SP,#+8
   \   000000BC   ........           BL       GUI_MoveRect
   1415              GUI__IntersectRect(&r, &rUser);
   \   000000C0   08108DE2           ADD      R1,SP,#+8
   \   000000C4   0D00A0E1           MOV      R0,SP
   \   000000C8   ........           BL       GUI__IntersectRect
   1416            }
   1417            /* For transparent windows, we need to further reduce the rectangle */
   1418            #if WM_SUPPORT_TRANSPARENCY
   1419              if (WM__hATransWindow) {
   \                     ??WM__InitIVRSearch_7:
   \   000000CC   346194E5           LDR      R6,[R4, #+308]
   \   000000D0   000056E3           CMP      R6,#+0
   \   000000D4   2800000A           BEQ      ??WM__InitIVRSearch_9
   1420                if (WM__ClipAtParentBorders(&r, WM__hATransWindow) == 0) {
   \   000000D8   060000EA           B        ??WM__InitIVRSearch_10
   1421                  --_ClipContext.EntranceCnt;
   1422                  return 0;           /* Nothing to draw */
   1423                }
   1424              }
   \                     ??WM__InitIVRSearch_4:
   \   000000DC   2800D7E5           LDRB     R0,[R7, #+40]
   \   000000E0   020010E3           TST      R0,#0x2
   \   000000E4   5700000A           BEQ      ??WM__InitIVRSearch_11
   \   000000E8   0D00A0E1           MOV      R0,SP
   \   000000EC   0710A0E1           MOV      R1,R7
   \   000000F0   DCFFFFEA           B        ??WM__InitIVRSearch_5
   \                     ??WM__InitIVRSearch_12:
   \   000000F4   0060A0E1           MOV      R6,R0
   \                     ??WM__InitIVRSearch_10:
   \   000000F8   0600A0E1           MOV      R0,R6
   \   000000FC   ........           BL       GUI_ALLOC_h2p
   \   00000100   0070A0E1           MOV      R7,R0
   \   00000104   2800D7E5           LDRB     R0,[R7, #+40]
   \   00000108   020010E3           TST      R0,#0x2
   \   0000010C   4D00000A           BEQ      ??WM__InitIVRSearch_11
   \   00000110   0710A0E1           MOV      R1,R7
   \   00000114   0D00A0E1           MOV      R0,SP
   \   00000118   ........           BL       GUI__IntersectRect
   \   0000011C   180097E5           LDR      R0,[R7, #+24]
   \   00000120   000050E3           CMP      R0,#+0
   \   00000124   F2FFFF1A           BNE      ??WM__InitIVRSearch_12
   \   00000128   283094E5           LDR      R3,[R4, #+40]
   \   0000012C   2C0084E2           ADD      R0,R4,#+44
   \   00000130   030056E1           CMP      R6,R3
   \   00000134   1000000A           BEQ      ??WM__InitIVRSearch_9
   \   00000138   003090E5           LDR      R3,[R0, #+0]
   \   0000013C   0110A0E3           MOV      R1,#+1
   \   00000140   300084E2           ADD      R0,R4,#+48
   \   00000144   0720A0E3           MOV      R2,#+7
   \                     ??WM__InitIVRSearch_13:
   \   00000148   030056E1           CMP      R6,R3
   \   0000014C   04C09014           LDRNE    R12,[R0], #+4
   \   00000150   01108112           ADDNE    R1,R1,#+1
   \   00000154   0C005611           CMPNE    R6,R12
   \   00000158   0500000A           BEQ      ??WM__InitIVRSearch_14
   \   0000015C   011081E2           ADD      R1,R1,#+1
   \   00000160   043090E4           LDR      R3,[R0], #+4
   \   00000164   012052E2           SUBS     R2,R2,#+1
   \   00000168   F6FFFF1A           BNE      ??WM__InitIVRSearch_13
   \   0000016C   030056E1           CMP      R6,R3
   \   00000170   3400001A           BNE      ??WM__InitIVRSearch_11
   \                     ??WM__InitIVRSearch_14:
   \   00000174   000051E3           CMP      R1,#+0
   \   00000178   3200004A           BMI      ??WM__InitIVRSearch_11
   1425            #endif
   1426            /* Iterate over all ancestors and clip at their borders. If there is no visible part, we are done */
   1427            if (WM__ClipAtParentBorders(&r, GUI_Context.hAWin) == 0) {
   \                     ??WM__InitIVRSearch_9:
   \   0000017C   3C5095E5           LDR      R5,[R5, #+60]
   \   00000180   000000EA           B        ??WM__InitIVRSearch_15
   \                     ??WM__InitIVRSearch_16:
   \   00000184   0050A0E1           MOV      R5,R0
   \                     ??WM__InitIVRSearch_15:
   \   00000188   0500A0E1           MOV      R0,R5
   \   0000018C   ........           BL       GUI_ALLOC_h2p
   \   00000190   0060A0E1           MOV      R6,R0
   \   00000194   2800D6E5           LDRB     R0,[R6, #+40]
   \   00000198   020010E3           TST      R0,#0x2
   \   0000019C   2900000A           BEQ      ??WM__InitIVRSearch_11
   \   000001A0   0610A0E1           MOV      R1,R6
   \   000001A4   0D00A0E1           MOV      R0,SP
   \   000001A8   ........           BL       GUI__IntersectRect
   \   000001AC   180096E5           LDR      R0,[R6, #+24]
   \   000001B0   000050E3           CMP      R0,#+0
   \   000001B4   F2FFFF1A           BNE      ??WM__InitIVRSearch_16
   \   000001B8   283094E5           LDR      R3,[R4, #+40]
   \   000001BC   2C0084E2           ADD      R0,R4,#+44
   \   000001C0   030055E1           CMP      R5,R3
   \   000001C4   1000000A           BEQ      ??WM__InitIVRSearch_17
   \   000001C8   003090E5           LDR      R3,[R0, #+0]
   \   000001CC   0110A0E3           MOV      R1,#+1
   \   000001D0   300084E2           ADD      R0,R4,#+48
   \   000001D4   0720A0E3           MOV      R2,#+7
   \                     ??WM__InitIVRSearch_18:
   \   000001D8   030055E1           CMP      R5,R3
   \   000001DC   04C09014           LDRNE    R12,[R0], #+4
   \   000001E0   01108112           ADDNE    R1,R1,#+1
   \   000001E4   0C005511           CMPNE    R5,R12
   \   000001E8   0500000A           BEQ      ??WM__InitIVRSearch_19
   \   000001EC   011081E2           ADD      R1,R1,#+1
   \   000001F0   043090E4           LDR      R3,[R0], #+4
   \   000001F4   012052E2           SUBS     R2,R2,#+1
   \   000001F8   F6FFFF1A           BNE      ??WM__InitIVRSearch_18
   \   000001FC   030055E1           CMP      R5,R3
   \   00000200   1000001A           BNE      ??WM__InitIVRSearch_11
   \                     ??WM__InitIVRSearch_19:
   \   00000204   000051E3           CMP      R1,#+0
   \   00000208   0E00004A           BMI      ??WM__InitIVRSearch_11
   1428              --_ClipContext.EntranceCnt;
   1429              return 0;           /* Nothing to draw */
   1430            }
   1431            /* Store the rectangle and find the first rectangle of the area */
   1432            _ClipContext.ClientRect = r;
   \                     ??WM__InitIVRSearch_17:
   \   0000020C   00209DE5           LDR      R2,[SP, #+0]
   \   00000210   04309DE5           LDR      R3,[SP, #+4]
   \   00000214   0C0084E8           STM      R4,{R2,R3}
   1433            return WM__GetNextIVR();
   \   00000218   4001D4E5           LDRB     R0,[R4, #+320]
   \   0000021C   000050E3           CMP      R0,#+0
   \   00000220   0C00000A           BEQ      ??WM__InitIVRSearch_3
   \   00000224   140094E5           LDR      R0,[R4, #+20]
   \   00000228   020050E3           CMP      R0,#+2
   \   0000022C   050000AA           BGE      ??WM__InitIVRSearch_11
   \   00000230   100094E5           LDR      R0,[R4, #+16]
   \   00000234   010080E2           ADD      R0,R0,#+1
   \   00000238   100084E5           STR      R0,[R4, #+16]
   \   0000023C   ........           BL       _FindNext_IVR
   \   00000240   000050E3           CMP      R0,#+0
   \   00000244   74FFFF1A           BNE      ??WM__InitIVRSearch_1
   \                     ??WM__InitIVRSearch_11:
   \   00000248   140094E5           LDR      R0,[R4, #+20]
   \   0000024C   010040E2           SUB      R0,R0,#+1
   \   00000250   140084E5           STR      R0,[R4, #+20]
   \   00000254   0000A0E3           MOV      R0,#+0
   \                     ??WM__InitIVRSearch_3:
   \   00000258   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   0000025C   F080BDE8           POP      {R4-R7,PC}       ;; return
   1434          }
   1435          
   1436          /*********************************************************************
   1437          *
   1438          *       WM_SetDefault
   1439          *
   1440            This routine sets the defaults for WM and the layers below.
   1441            It is used before a drawing routine is called in order to
   1442            make sure that defaults are set (in case the default settings
   1443            had been altered before by the application)
   1444          */

   \                                 In section .text, align 4, keep-with-next
   1445          void WM_SetDefault(void) {
   \                     WM_SetDefault:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1446            GL_SetDefault();
   \   00000008   ........           BL       GL_SetDefault
   1447            GUI_Context.WM__pUserClipRect = NULL;   /* No add. clipping */
   \   0000000C   ........           LDR      R0,??DataTable27_1
   \   00000010   0010A0E3           MOV      R1,#+0
   \   00000014   381080E5           STR      R1,[R0, #+56]
   1448          }
   \   00000018   04D08DE2           ADD      SP,SP,#+4
   \   0000001C   0080BDE8           POP      {PC}             ;; return
   1449          
   1450          /*********************************************************************
   1451          *
   1452          *       WM__Paint1
   1453          */

   \                                 In section .text, align 4, keep-with-next
   1454          void WM__Paint1(WM_HWIN hWin, WM_Obj * pWin) {
   \                     WM__Paint1:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1455            WM_MESSAGE Msg;
   1456            int Status;
   1457            GUI_RECT InvalidRect;
   1458            
   1459            Status = pWin->Status;
   1460            /* Send WM_PAINT if window is visible and a callback is defined */
   1461            if ((pWin->cb != NULL)  && (Status & WM_SF_ISVIS)) {
   \   00000008   102091E5           LDR      R2,[R1, #+16]
   \   0000000C   280091E5           LDR      R0,[R1, #+40]
   \   00000010   000052E3           CMP      R2,#+0
   \   00000014   1CD04DE2           SUB      SP,SP,#+28
   \   00000018   02001013           TSTNE    R0,#0x2
   \   0000001C   3900000A           BEQ      ??WM__Paint1_0
   1462              WM__PaintCallbackCnt++;
   \   00000020   ........           LDR      R5,??DataTable23
   1463              if (Status & WM_SF_LATE_CLIP) {
   \   00000024   400D10E3           TST      R0,#0x1000
   \   00000028   4121D5E5           LDRB     R2,[R5, #+321]
   \   0000002C   012082E2           ADD      R2,R2,#+1
   \   00000030   4121C5E5           STRB     R2,[R5, #+321]
   \   00000034   0C00000A           BEQ      ??WM__Paint1_1
   1464                /* Late clipping: Only one WM_PAINT message is send. We iterate over visible rectangles in the drawing routines */
   1465                Msg.hWin   = hWin;
   1466                Msg.MsgId  = WM_PAINT;
   \   00000038   0F20A0E3           MOV      R2,#+15
   1467                Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
   \   0000003C   081081E2           ADD      R1,R1,#+8
   \   00000040   0C408DE5           STR      R4,[SP, #+12]
   \   00000044   08208DE5           STR      R2,[SP, #+8]
   \   00000048   14108DE5           STR      R1,[SP, #+20]
   1468                WM_SetDefault();
   \   0000004C   ........           BL       GL_SetDefault
   \   00000050   ........           LDR      R0,??DataTable27_1
   \   00000054   0010A0E3           MOV      R1,#+0
   \   00000058   381080E5           STR      R1,[R0, #+56]
   1469                WM__SendMessage(hWin, &Msg);
   \   0000005C   08108DE2           ADD      R1,SP,#+8
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       WM__SendMessage
   \   00000068   230000EA           B        ??WM__Paint1_2
   1470              } else {
   1471                /* Early clipping: One WM_PAINT message is send for every visible rectangle; Iteration is done at this level. */
   1472                /* Drawing routines do not iterate */
   1473                InvalidRect = pWin->InvalidRect;
   \                     ??WM__Paint1_1:
   \   0000006C   0D00A0E1           MOV      R0,SP
   \   00000070   081081E2           ADD      R1,R1,#+8
   \   00000074   0820A0E3           MOV      R2,#+8
   \   00000078   ........           BL       __aeabi_memcpy
   1474                WM_ITERATE_START(&InvalidRect) {
   \   0000007C   0D00A0E1           MOV      R0,SP
   \   00000080   ........           BL       WM__InitIVRSearch
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0100001A           BNE      ??WM__Paint1_3
   \   0000008C   1A0000EA           B        ??WM__Paint1_2
   1475                  Msg.hWin   = hWin;
   1476                  Msg.MsgId  = WM_PAINT;
   1477                  Msg.Data.p = (GUI_RECT*)&InvalidRect;
   1478                  WM_SetDefault();
   1479                  WM__SendMessage(hWin, &Msg);
   1480                } WM_ITERATE_END();
   \                     ??WM__Paint1_4:
   \   00000090   ........           BL       WM__ActivateClipRect
   \                     ??WM__Paint1_3:
   \   00000094   0F10A0E3           MOV      R1,#+15
   \   00000098   0C408DE5           STR      R4,[SP, #+12]
   \   0000009C   08108DE5           STR      R1,[SP, #+8]
   \   000000A0   14D08DE5           STR      SP,[SP, #+20]
   \   000000A4   ........           BL       GL_SetDefault
   \   000000A8   ........           LDR      R0,??DataTable27_1
   \   000000AC   0010A0E3           MOV      R1,#+0
   \   000000B0   381080E5           STR      R1,[R0, #+56]
   \   000000B4   08108DE2           ADD      R1,SP,#+8
   \   000000B8   0400A0E1           MOV      R0,R4
   \   000000BC   ........           BL       WM__SendMessage
   \   000000C0   4001D5E5           LDRB     R0,[R5, #+320]
   \   000000C4   000050E3           CMP      R0,#+0
   \   000000C8   0B00000A           BEQ      ??WM__Paint1_2
   \   000000CC   140095E5           LDR      R0,[R5, #+20]
   \   000000D0   020050E3           CMP      R0,#+2
   \   000000D4   050000AA           BGE      ??WM__Paint1_5
   \   000000D8   100095E5           LDR      R0,[R5, #+16]
   \   000000DC   010080E2           ADD      R0,R0,#+1
   \   000000E0   100085E5           STR      R0,[R5, #+16]
   \   000000E4   ........           BL       _FindNext_IVR
   \   000000E8   000050E3           CMP      R0,#+0
   \   000000EC   E7FFFF1A           BNE      ??WM__Paint1_4
   \                     ??WM__Paint1_5:
   \   000000F0   140095E5           LDR      R0,[R5, #+20]
   \   000000F4   010040E2           SUB      R0,R0,#+1
   \   000000F8   140085E5           STR      R0,[R5, #+20]
   1481              }
   1482              WM__PaintCallbackCnt--;
   \                     ??WM__Paint1_2:
   \   000000FC   4101D5E5           LDRB     R0,[R5, #+321]
   \   00000100   010040E2           SUB      R0,R0,#+1
   \   00000104   4101C5E5           STRB     R0,[R5, #+321]
   1483            }
   1484          }
   \                     ??WM__Paint1_0:
   \   00000108   1CD08DE2           ADD      SP,SP,#+28       ;; stack cleaning
   \   0000010C   3080BDE8           POP      {R4,R5,PC}       ;; return
   1485          
   1486          /*********************************************************************
   1487          *
   1488          *       _Paint1
   1489          */
   1490          static void _Paint1(WM_HWIN hWin, WM_Obj * pWin) {
   1491            WM_tfPaint1Func pfPaint1Func;
   1492          
   1493            #if WM_SUPPORT_STATIC_MEMDEV
   1494              pfPaint1Func = (pWin->Status & WM_CF_STATIC) ? GUI_MEMDEV_Paint1Static : WM__Paint1;
   1495            #else
   1496              pfPaint1Func = WM__Paint1;
   1497            #endif
   1498            pfPaint1Func(hWin, pWin);
   1499          }
   1500          
   1501          /*********************************************************************
   1502          *
   1503          *       _Paint1Trans
   1504          *
   1505          * Purpose:
   1506          *   Draw a transparent window as part of an other one (the active window: pAWin).
   1507          *   This is required because transparent windows are drawn as part of their
   1508          *   non-transparent parents.
   1509          * Return value:
   1510          *   0 if nothing was drawn (no invalid rect)
   1511          *   1 if something was drawn (invalid rect exists)
   1512          * Add. info:
   1513          *   It is important to restore the modified settings, especially the invalid rectangle
   1514          *   of the window. The invalid rectangle needs to be set, as it is passed as add. info
   1515          *   to the callback on WM_PAINT.
   1516          *   On traditional transparent windows, the transparent window is never drawn on its own,
   1517          *   so there is no need to restore the invalid rectangle.
   1518          *   However, with WM_SF_CONST_OUTLINE, the window itself may need to be redrawn because it
   1519          *   can be invalid. Modifying the invalid rectangle would lead to not updating the window
   1520          *   in the worst case.
   1521          */
   1522          
   1523          #if WM_SUPPORT_TRANSPARENCY
   1524          static int _Paint1Trans(WM_HWIN hWin, WM_Obj * pWin) {
   1525            int xPrev, yPrev;
   1526            WM_Obj * pAWin;
   1527            
   1528            pAWin = WM_H2P(GUI_Context.hAWin);
   1529            /* Check if we need to do any drawing */
   1530            if (GUI_RectsIntersect(&pAWin->InvalidRect, &pWin->Rect)) {
   1531              /* Save old values */
   1532              xPrev = GUI_Context.xOff;
   1533              yPrev = GUI_Context.yOff;
   1534              /* Set values for the current (transparent) window, rather than the one below */
   1535              GUI__IntersectRects(&pWin->InvalidRect, &pWin->Rect, &pAWin->InvalidRect);
   1536              WM__hATransWindow = hWin;
   1537              GUI_Context.xOff = pWin->Rect.x0;
   1538              GUI_Context.yOff = pWin->Rect.y0;
   1539              /* Do the actual drawing ... */
   1540              _Paint1(hWin, pWin);
   1541              /* Restore settings */
   1542              WM__hATransWindow = 0;
   1543              GUI_Context.xOff = xPrev;
   1544              GUI_Context.yOff = yPrev;
   1545              return 1;                       /* Some drawing took place */
   1546            }
   1547            return 0;                         /* No invalid area, so nothing was drawn */
   1548          }
   1549          #endif
   1550          
   1551          /*********************************************************************
   1552          *
   1553          *       _PaintTransChildren
   1554          *
   1555          * Purpose:
   1556          *   Paint transparent children. This function is obviously required
   1557          *   only if there are transparent windows.
   1558          * Function:  Obvious
   1559          * Parameter: Obvious
   1560          * Returns:   ---
   1561          */
   1562          #if WM_SUPPORT_TRANSPARENCY

   \                                 In section .text, align 4, keep-with-next
   1563          static void _PaintTransChildren(WM_HWIN hWin, WM_Obj * pWin) {
   \                     _PaintTransChildren:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0190A0E1           MOV      R9,R1
   1564            WM_HWIN hChild;
   1565            WM_Obj * pChild;
   1566          
   1567            if (pWin->Status & WM_SF_ISVIS) {
   \   0000000C   2800D9E5           LDRB     R0,[R9, #+40]
   \   00000010   0CD04DE2           SUB      SP,SP,#+12
   \   00000014   020010E3           TST      R0,#0x2
   \   00000018   4400000A           BEQ      ??_PaintTransChildren_0
   1568              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
   \   0000001C   1C5099E5           LDR      R5,[R9, #+28]
   \   00000020   ........           LDR      R6,??DataTable17
   \   00000024   0070A0E3           MOV      R7,#+0
   \   00000028   000055E3           CMP      R5,#+0
   \   0000002C   3F00000A           BEQ      ??_PaintTransChildren_0
   1569                pChild = WM_H2P(hChild);
   \                     ??_PaintTransChildren_1:
   \   00000030   0500A0E1           MOV      R0,R5
   \   00000034   ........           BL       GUI_ALLOC_h2p
   \   00000038   0080A0E1           MOV      R8,R0
   1570                if ((pChild->Status & (WM_SF_HASTRANS | WM_SF_ISVIS))   /* Transparent & visible ? */
   1571          		                ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
   \   0000003C   2800D8E5           LDRB     R0,[R8, #+40]
   \   00000040   030000E2           AND      R0,R0,#0x3
   \   00000044   030050E3           CMP      R0,#+3
   \   00000048   3500001A           BNE      ??_PaintTransChildren_2
   1572                  /* Set invalid area of the window to draw */
   1573                  if (GUI_RectsIntersect(&pChild->Rect, &pWin->InvalidRect)) {
   \   0000004C   081089E2           ADD      R1,R9,#+8
   \   00000050   0800A0E1           MOV      R0,R8
   \   00000054   ........           BL       GUI_RectsIntersect
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   3000000A           BEQ      ??_PaintTransChildren_2
   1574                    GUI_RECT InvalidRectPrev;
   1575                    InvalidRectPrev = pWin->InvalidRect;
   \   00000060   0D00A0E1           MOV      R0,SP
   \   00000064   081089E2           ADD      R1,R9,#+8
   \   00000068   0820A0E3           MOV      R2,#+8
   \   0000006C   ........           BL       __aeabi_memcpy
   1576                    if(_Paint1Trans(hChild, pChild)) {
   \   00000070   3C0096E5           LDR      R0,[R6, #+60]
   \   00000074   ........           BL       GUI_ALLOC_h2p
   \   00000078   00B0A0E1           MOV      R11,R0
   \   0000007C   0810A0E1           MOV      R1,R8
   \   00000080   08008BE2           ADD      R0,R11,#+8
   \   00000084   ........           BL       GUI_RectsIntersect
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   2000000A           BEQ      ??_PaintTransChildren_3
   \   00000090   409096E5           LDR      R9,[R6, #+64]
   \   00000094   44A096E5           LDR      R10,[R6, #+68]
   \   00000098   08208BE2           ADD      R2,R11,#+8
   \   0000009C   0810A0E1           MOV      R1,R8
   \   000000A0   080088E2           ADD      R0,R8,#+8
   \   000000A4   ........           BL       GUI__IntersectRects
   \   000000A8   ........           LDR      R11,??DataTable23
   \   000000AC   0810A0E1           MOV      R1,R8
   \   000000B0   34518BE5           STR      R5,[R11, #+308]
   \   000000B4   F000D8E1           LDRSH    R0,[R8, #+0]
   \   000000B8   400086E5           STR      R0,[R6, #+64]
   \   000000BC   F200D8E1           LDRSH    R0,[R8, #+2]
   \   000000C0   440086E5           STR      R0,[R6, #+68]
   \   000000C4   280098E5           LDR      R0,[R8, #+40]
   \   000000C8   400B10E3           TST      R0,#0x10000
   \   000000CC   ........           LDRNE    R2,??DataTable27_2
   \   000000D0   ........           LDREQ    R2,??DataTable27_3
   \   000000D4   0500A0E1           MOV      R0,R5
   \   000000D8   32FF2FE1           BLX      R2
   \   000000DC   34718BE5           STR      R7,[R11, #+308]
   \   000000E0   409086E5           STR      R9,[R6, #+64]
   \   000000E4   44A086E5           STR      R10,[R6, #+68]
   1577                      /* Within the paint event the application is allowed to deal with memory devices.
   1578                         So the pointer(s) could be invalid after the last function call and needs
   1579                         to be restored.
   1580                      */
   1581                      pChild = WM_H2P(hChild);
   \   000000E8   0500A0E1           MOV      R0,R5
   \   000000EC   ........           BL       GUI_ALLOC_h2p
   1582                      _PaintTransChildren(hChild, pChild);
   \   000000F0   0010A0E1           MOV      R1,R0
   \   000000F4   0500A0E1           MOV      R0,R5
   \   000000F8   ........           BL       _PaintTransChildren
   1583                      /* Within the paint event the application is allowed to deal with memory devices.
   1584                         So the pointer(s) could be invalid after the last function call and needs
   1585                         to be restored.
   1586                      */
   1587                      pChild = WM_H2P(hChild);
   \   000000FC   0500A0E1           MOV      R0,R5
   \   00000100   ........           BL       GUI_ALLOC_h2p
   \   00000104   0080A0E1           MOV      R8,R0
   1588                      pWin   = WM_H2P(hWin);
   \   00000108   0400A0E1           MOV      R0,R4
   \   0000010C   ........           BL       GUI_ALLOC_h2p
   \   00000110   0090A0E1           MOV      R9,R0
   1589                    }
   1590                    pWin->InvalidRect = InvalidRectPrev;
   \                     ??_PaintTransChildren_3:
   \   00000114   080089E2           ADD      R0,R9,#+8
   \   00000118   0D10A0E1           MOV      R1,SP
   \   0000011C   0820A0E3           MOV      R2,#+8
   \   00000120   ........           BL       __aeabi_memcpy
   1591                  }
   1592                }
   1593              }
   \                     ??_PaintTransChildren_2:
   \   00000124   205098E5           LDR      R5,[R8, #+32]
   \   00000128   000055E3           CMP      R5,#+0
   \   0000012C   BFFFFF1A           BNE      ??_PaintTransChildren_1
   1594            }
   1595          }
   \                     ??_PaintTransChildren_0:
   \   00000130   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000134   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1596          #endif
   1597          
   1598          /*********************************************************************
   1599          *
   1600          *       _PaintTransTopSiblings
   1601          *
   1602          * Purpose:
   1603          *   Paint transparent top siblings. This function is obviously required
   1604          *   only if there are transparent windows.
   1605          * Function:  Obvious
   1606          * Parameter: Obvious
   1607          * Returns:   ---
   1608          */
   1609          #if WM_SUPPORT_TRANSPARENCY

   \                                 In section .text, align 4, keep-with-next
   1610          static void _PaintTransTopSiblings(WM_HWIN hWin, WM_Obj * pWin) {
   \                     _PaintTransTopSiblings:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   1611            WM_HWIN hParent;
   1612            WM_Obj * pParent;
   1613          
   1614            hParent = pWin->hParent;
   \   00000004   184091E5           LDR      R4,[R1, #+24]
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   1615            hWin = pWin->hNext;
   \   0000000C   205091E5           LDR      R5,[R1, #+32]
   \   00000010   ........           LDR      R6,??DataTable27_1
   \   00000014   0070A0E3           MOV      R7,#+0
   1616            while (hParent) { /* Go hierarchy up to desktop window */
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   3700000A           BEQ      ??_PaintTransTopSiblings_0
   1617              for (; hWin; hWin = pWin->hNext) {
   \                     ??_PaintTransTopSiblings_1:
   \   00000020   000055E3           CMP      R5,#+0
   \   00000024   2F00000A           BEQ      ??_PaintTransTopSiblings_2
   1618                pWin = WM_H2P(hWin);
   \                     ??_PaintTransTopSiblings_3:
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   ........           BL       GUI_ALLOC_h2p
   \   00000030   0080A0E1           MOV      R8,R0
   1619                /* paint window if it is transparent & visible */
   1620                if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_ISVIS)) ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
   \   00000034   2800D8E5           LDRB     R0,[R8, #+40]
   \   00000038   030000E2           AND      R0,R0,#0x3
   \   0000003C   030050E3           CMP      R0,#+3
   \   00000040   2000001A           BNE      ??_PaintTransTopSiblings_4
   1621                  _Paint1Trans(hWin, pWin);
   \   00000044   3C0096E5           LDR      R0,[R6, #+60]
   \   00000048   ........           BL       GUI_ALLOC_h2p
   \   0000004C   00B0A0E1           MOV      R11,R0
   \   00000050   0810A0E1           MOV      R1,R8
   \   00000054   08008BE2           ADD      R0,R11,#+8
   \   00000058   ........           BL       GUI_RectsIntersect
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   1500000A           BEQ      ??_PaintTransTopSiblings_5
   \   00000064   409096E5           LDR      R9,[R6, #+64]
   \   00000068   44A096E5           LDR      R10,[R6, #+68]
   \   0000006C   08208BE2           ADD      R2,R11,#+8
   \   00000070   0810A0E1           MOV      R1,R8
   \   00000074   080088E2           ADD      R0,R8,#+8
   \   00000078   ........           BL       GUI__IntersectRects
   \   0000007C   ........           LDR      R11,??DataTable23
   \   00000080   0810A0E1           MOV      R1,R8
   \   00000084   34518BE5           STR      R5,[R11, #+308]
   \   00000088   F000D8E1           LDRSH    R0,[R8, #+0]
   \   0000008C   400086E5           STR      R0,[R6, #+64]
   \   00000090   F200D8E1           LDRSH    R0,[R8, #+2]
   \   00000094   440086E5           STR      R0,[R6, #+68]
   \   00000098   280098E5           LDR      R0,[R8, #+40]
   \   0000009C   400B10E3           TST      R0,#0x10000
   \   000000A0   ........           LDRNE    R2,??DataTable27_2
   \   000000A4   ........           LDREQ    R2,??DataTable27_3
   \   000000A8   0500A0E1           MOV      R0,R5
   \   000000AC   32FF2FE1           BLX      R2
   \   000000B0   34718BE5           STR      R7,[R11, #+308]
   \   000000B4   409086E5           STR      R9,[R6, #+64]
   \   000000B8   44A086E5           STR      R10,[R6, #+68]
   1622                  /* Within the paint event the application is allowed to deal with memory devices.
   1623                     So the pointer(s) could be invalid after the last function call and needs
   1624                     to be restored.
   1625                  */
   1626                  pWin   = WM_H2P(hWin);
   \                     ??_PaintTransTopSiblings_5:
   \   000000BC   0500A0E1           MOV      R0,R5
   \   000000C0   ........           BL       GUI_ALLOC_h2p
   \   000000C4   0080A0E1           MOV      R8,R0
   1627                }
   1628                /* paint transparent & visible children */
   1629                _PaintTransChildren(hWin, pWin);
   \                     ??_PaintTransTopSiblings_4:
   \   000000C8   0810A0E1           MOV      R1,R8
   \   000000CC   0500A0E1           MOV      R0,R5
   \   000000D0   ........           BL       _PaintTransChildren
   1630                /* Within the paint event the application is allowed to deal with memory devices.
   1631                   So the pointer(s) could be invalid after the last function call and needs
   1632                   to be restored.
   1633                */
   1634                pWin   = WM_H2P(hWin);
   1635              }
   \   000000D4   0500A0E1           MOV      R0,R5
   \   000000D8   ........           BL       GUI_ALLOC_h2p
   \   000000DC   205090E5           LDR      R5,[R0, #+32]
   \   000000E0   000055E3           CMP      R5,#+0
   \   000000E4   CFFFFF1A           BNE      ??_PaintTransTopSiblings_3
   1636              pParent = WM_H2P(hParent);
   \                     ??_PaintTransTopSiblings_2:
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       GUI_ALLOC_h2p
   1637              hWin = pParent->hNext;
   1638              hParent = pParent->hParent;
   \   000000F0   184090E5           LDR      R4,[R0, #+24]
   \   000000F4   205090E5           LDR      R5,[R0, #+32]
   \   000000F8   000054E3           CMP      R4,#+0
   \   000000FC   C7FFFF1A           BNE      ??_PaintTransTopSiblings_1
   1639            }
   1640          }
   \                     ??_PaintTransTopSiblings_0:
   \   00000100   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000104   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1641          #endif
   1642          
   1643          /*********************************************************************
   1644          *
   1645          *       Callback for Paint message
   1646          *
   1647          * This callback is used by the window manger in conjunction with
   1648          * banding memory devices. A pointer to this routine is given to
   1649          * the banding memory device. This callback in turn will send the
   1650          * paint message to the window.
   1651          *
   1652          **********************************************************************
   1653          */
   1654          
   1655          /*********************************************************************
   1656          *
   1657          *       WM__PaintWinAndOverlays
   1658          *
   1659          * Purpose
   1660          *   Paint the given window and all overlaying windows
   1661          *   (transparent children and transparent top siblings)
   1662          */
   1663          static void WM__PaintWinAndOverlays(WM_HWIN hWin) {
   1664            WM_Obj * pWin;
   1665          
   1666            pWin = WM_H2P(hWin);
   1667            #if WM_SUPPORT_TRANSPARENCY
   1668              /* Transparent windows without const outline are drawn as part of the background and can be skipped. */
   1669              if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) != WM_SF_HASTRANS) {
   1670            #endif
   1671            _Paint1(hWin, pWin);    /* Draw the window itself */
   1672            pWin = WM_H2P(hWin);
   1673            #if WM_SUPPORT_TRANSPARENCY
   1674              }
   1675              if (WM__TransWindowCnt != 0) {
   1676                _PaintTransChildren(hWin, pWin);             /* Draw all transparent children */
   1677                /* Within the paint event the application is allowed to deal with memory devices.
   1678                   So the pointer(s) could be invalid after the last function call and needs
   1679                   to be restored.
   1680                */
   1681                pWin = WM_H2P(hWin);
   1682                _PaintTransTopSiblings(hWin, pWin);    /* Draw all transparent top level siblings */
   1683              }
   1684            #endif
   1685          }
   1686          
   1687          /*********************************************************************
   1688          *
   1689          *       _cbPaintMemDev
   1690          *
   1691          * Purpose:
   1692          *   This is the routine called by the banding memory device. It calls
   1693          *   the same _cbPaint Routine which is also used when drawing directly;
   1694          *   the only add. work done is adjustment of the invalid rectangle.
   1695          *   This way the invalid rectangle visible by the window callback function
   1696          *   is limited to the current band, allowing the callback to optimize
   1697          *   better.
   1698          */
   1699          #if GUI_SUPPORT_MEMDEV

   \                                 In section .text, align 4, keep-with-next
   1700          static void _cbPaintMemDev(void * p) {
   \                     _cbPaintMemDev:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   1701            GUI_RECT Rect;
   1702            WM_Obj * pWin;
   1703          
   1704            pWin = WM_H2P(GUI_Context.hAWin);
   \   00000004   ........           LDR      R4,??DataTable27_1
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   08D04DE2           SUB      SP,SP,#+8
   \   00000010   3C0094E5           LDR      R0,[R4, #+60]
   \   00000014   ........           BL       GUI_ALLOC_h2p
   \   00000018   0060A0E1           MOV      R6,R0
   1705            Rect = pWin->InvalidRect;
   \   0000001C   0D00A0E1           MOV      R0,SP
   \   00000020   081086E2           ADD      R1,R6,#+8
   \   00000024   0820A0E3           MOV      R2,#+8
   \   00000028   ........           BL       __aeabi_memcpy
   1706            pWin->InvalidRect = GUI_Context.ClipRect;
   \   0000002C   080086E2           ADD      R0,R6,#+8
   \   00000030   081084E2           ADD      R1,R4,#+8
   \   00000034   0820A0E3           MOV      R2,#+8
   \   00000038   ........           BL       __aeabi_memcpy
   1707            WM__PaintWinAndOverlays(*(WM_HWIN *)p);
   \   0000003C   005095E5           LDR      R5,[R5, #+0]
   \   00000040   0500A0E1           MOV      R0,R5
   \   00000044   ........           BL       GUI_ALLOC_h2p
   \   00000048   281090E5           LDR      R1,[R0, #+40]
   \   0000004C   0120A0E3           MOV      R2,#+1
   \   00000050   802E82E3           ORR      R2,R2,#0x800
   \   00000054   012002E0           AND      R2,R2,R1
   \   00000058   010052E3           CMP      R2,#+1
   \   0000005C   0700000A           BEQ      ??_cbPaintMemDev_0
   \   00000060   400B11E3           TST      R1,#0x10000
   \   00000064   0010A0E1           MOV      R1,R0
   \   00000068   ........           LDRNE    R2,??DataTable27_2
   \   0000006C   ........           LDREQ    R2,??DataTable27_3
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   32FF2FE1           BLX      R2
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           BL       GUI_ALLOC_h2p
   \                     ??_cbPaintMemDev_0:
   \   00000080   ........           LDR      R1,??DataTable27
   \   00000084   301191E5           LDR      R1,[R1, #+304]
   \   00000088   000051E3           CMP      R1,#+0
   \   0000008C   0700000A           BEQ      ??_cbPaintMemDev_1
   \   00000090   0010A0E1           MOV      R1,R0
   \   00000094   0500A0E1           MOV      R0,R5
   \   00000098   ........           BL       _PaintTransChildren
   \   0000009C   0500A0E1           MOV      R0,R5
   \   000000A0   ........           BL       GUI_ALLOC_h2p
   \   000000A4   0010A0E1           MOV      R1,R0
   \   000000A8   0500A0E1           MOV      R0,R5
   \   000000AC   ........           BL       _PaintTransTopSiblings
   1708            /* Within the paint event the application is allowed to deal with memory devices.
   1709               So the pointer(s) could be invalid after the last function call and needs
   1710               to be restored.
   1711            */
   1712            pWin = WM_H2P(GUI_Context.hAWin);
   1713            pWin->InvalidRect = Rect;
   \                     ??_cbPaintMemDev_1:
   \   000000B0   3C0094E5           LDR      R0,[R4, #+60]
   \   000000B4   ........           BL       GUI_ALLOC_h2p
   \   000000B8   080080E2           ADD      R0,R0,#+8
   \   000000BC   0D10A0E1           MOV      R1,SP
   \   000000C0   0820A0E3           MOV      R2,#+8
   \   000000C4   ........           BL       __aeabi_memcpy
   1714          }
   \   000000C8   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   000000CC   7080BDE8           POP      {R4-R6,PC}       ;; return
   1715          #endif
   1716          
   1717          /*********************************************************************
   1718          *
   1719          *       WM__Paint
   1720          *
   1721          * Purpose:
   1722          *   Draws the given window
   1723          *
   1724          * Return value:
   1725          *   1: A window has been redrawn
   1726          *   0: No window has been drawn  
   1727          */

   \                                 In section .text, align 4, keep-with-next
   1728          int WM__Paint(WM_HWIN hWin) {
   \                     WM__Paint:
   \   00000000   F1412DE9           PUSH     {R0,R4-R8,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1729            WM_Obj * pWin;
   1730            int Ret = 0;
   \   00000008   0040A0E3           MOV      R4,#+0
   1731            #if GUI_SUPPORT_MEMDEV
   1732              int Flags;
   1733            #endif
   1734          
   1735            pWin = WM_H2P(hWin);
   \   0000000C   ........           BL       GUI_ALLOC_h2p
   \   00000010   0050A0E1           MOV      R5,R0
   1736            if (pWin->Status & (WM_SF_INVALID | WM_SF_INVALID_DRAW)) {
   \   00000014   B802D5E1           LDRH     R0,[R5, #+40]
   \   00000018   2010A0E3           MOV      R1,#+32
   \   0000001C   401C81E3           ORR      R1,R1,#0x4000
   \   00000020   000011E1           TST      R1,R0
   \   00000024   6600000A           BEQ      ??WM__Paint_0
   1737              if (pWin->cb) {
   \   00000028   100095E5           LDR      R0,[R5, #+16]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   5400000A           BEQ      ??WM__Paint_1
   1738                if (WM__ClipAtParentBorders(&pWin->InvalidRect, hWin)) {
   \   00000034   04609DE5           LDR      R6,[SP, #+4]
   \   00000038   087085E2           ADD      R7,R5,#+8
   \   0000003C   000000EA           B        ??WM__Paint_2
   \                     ??WM__Paint_3:
   \   00000040   0060A0E1           MOV      R6,R0
   \                     ??WM__Paint_2:
   \   00000044   0600A0E1           MOV      R0,R6
   \   00000048   ........           BL       GUI_ALLOC_h2p
   \   0000004C   0080A0E1           MOV      R8,R0
   \   00000050   2800D8E5           LDRB     R0,[R8, #+40]
   \   00000054   020010E3           TST      R0,#0x2
   \   00000058   4A00000A           BEQ      ??WM__Paint_1
   \   0000005C   0810A0E1           MOV      R1,R8
   \   00000060   0700A0E1           MOV      R0,R7
   \   00000064   ........           BL       GUI__IntersectRect
   \   00000068   180098E5           LDR      R0,[R8, #+24]
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   F2FFFF1A           BNE      ??WM__Paint_3
   \   00000074   ........           LDR      R7,??DataTable27
   \   00000078   283097E5           LDR      R3,[R7, #+40]
   \   0000007C   2C0087E2           ADD      R0,R7,#+44
   \   00000080   030056E1           CMP      R6,R3
   \   00000084   1100000A           BEQ      ??WM__Paint_4
   \   00000088   003090E5           LDR      R3,[R0, #+0]
   \   0000008C   040087E2           ADD      R0,R7,#+4
   \   00000090   0110A0E3           MOV      R1,#+1
   \   00000094   2C0080E2           ADD      R0,R0,#+44
   \   00000098   0720A0E3           MOV      R2,#+7
   \                     ??WM__Paint_5:
   \   0000009C   030056E1           CMP      R6,R3
   \   000000A0   04C09014           LDRNE    R12,[R0], #+4
   \   000000A4   01108112           ADDNE    R1,R1,#+1
   \   000000A8   0C005611           CMPNE    R6,R12
   \   000000AC   0500000A           BEQ      ??WM__Paint_6
   \   000000B0   011081E2           ADD      R1,R1,#+1
   \   000000B4   043090E4           LDR      R3,[R0], #+4
   \   000000B8   012052E2           SUBS     R2,R2,#+1
   \   000000BC   F6FFFF1A           BNE      ??WM__Paint_5
   \   000000C0   030056E1           CMP      R6,R3
   \   000000C4   2F00001A           BNE      ??WM__Paint_1
   \                     ??WM__Paint_6:
   \   000000C8   000051E3           CMP      R1,#+0
   \   000000CC   2D00004A           BMI      ??WM__Paint_1
   1739                  WM_SelectWindow(hWin);
   \                     ??WM__Paint_4:
   \   000000D0   04009DE5           LDR      R0,[SP, #+4]
   \   000000D4   ........           BL       WM_SelectWindow
   1740                  #if GUI_SUPPORT_MEMDEV
   1741                    if (pWin->Status & WM_SF_MEMDEV) {
   \   000000D8   280095E5           LDR      R0,[R5, #+40]
   \   000000DC   040010E3           TST      R0,#0x4
   \   000000E0   0B00000A           BEQ      ??WM__Paint_7
   1742                      if (pWin->hParent == 0) {
   \   000000E4   181095E5           LDR      R1,[R5, #+24]
   1743                        //
   1744                        // Desktop windows do not have transparency
   1745                        //
   1746                        Flags = GUI_MEMDEV_NOTRANS;
   1747                      } else {
   1748                        //
   1749                        // Translate WM_SF_HASTRANS to GUI_MEMDEV_HASTRANS or GUI_MEMDEV_NOTRANS
   1750                        //
   1751                        Flags = (pWin->Status & WM_SF_HASTRANS) ? GUI_MEMDEV_HASTRANS : GUI_MEMDEV_NOTRANS;
   1752                      }
   1753                      GUI_MEMDEV_Draw(&pWin->InvalidRect, _cbPaintMemDev, &hWin, 0, Flags);
   \   000000E8   0030A0E3           MOV      R3,#+0
   \   000000EC   000051E3           CMP      R1,#+0
   \   000000F0   01000012           ANDNE    R0,R0,#0x1
   \   000000F4   0100A003           MOVEQ    R0,#+1
   \   000000F8   01002012           EORNE    R0,R0,#0x1
   \   000000FC   00008DE5           STR      R0,[SP, #+0]
   \   00000100   04208DE2           ADD      R2,SP,#+4
   \   00000104   ........           LDR      R1,??DataTable27_4
   \   00000108   080085E2           ADD      R0,R5,#+8
   \   0000010C   ........           BL       GUI_MEMDEV_Draw
   \   00000110   1C0000EA           B        ??WM__Paint_1
   1754                    } else
   1755                  #endif
   1756                  {
   1757                    WM__PaintWinAndOverlays(hWin);
   \                     ??WM__Paint_7:
   \   00000114   04409DE5           LDR      R4,[SP, #+4]
   \   00000118   0400A0E1           MOV      R0,R4
   \   0000011C   ........           BL       GUI_ALLOC_h2p
   \   00000120   281090E5           LDR      R1,[R0, #+40]
   \   00000124   0120A0E3           MOV      R2,#+1
   \   00000128   802E82E3           ORR      R2,R2,#0x800
   \   0000012C   012002E0           AND      R2,R2,R1
   \   00000130   010052E3           CMP      R2,#+1
   \   00000134   0700000A           BEQ      ??WM__Paint_8
   \   00000138   400B11E3           TST      R1,#0x10000
   \   0000013C   0010A0E1           MOV      R1,R0
   \   00000140   ........           LDRNE    R2,??DataTable27_2
   \   00000144   ........           LDREQ    R2,??DataTable27_3
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   32FF2FE1           BLX      R2
   \   00000150   0400A0E1           MOV      R0,R4
   \   00000154   ........           BL       GUI_ALLOC_h2p
   \                     ??WM__Paint_8:
   \   00000158   301197E5           LDR      R1,[R7, #+304]
   \   0000015C   000051E3           CMP      R1,#+0
   \   00000160   0700000A           BEQ      ??WM__Paint_9
   \   00000164   0010A0E1           MOV      R1,R0
   \   00000168   0400A0E1           MOV      R0,R4
   \   0000016C   ........           BL       _PaintTransChildren
   \   00000170   0400A0E1           MOV      R0,R4
   \   00000174   ........           BL       GUI_ALLOC_h2p
   \   00000178   0010A0E1           MOV      R1,R0
   \   0000017C   0400A0E1           MOV      R0,R4
   \   00000180   ........           BL       _PaintTransTopSiblings
   1758                    Ret = 1;    // Something has been done
   \                     ??WM__Paint_9:
   \   00000184   0140A0E3           MOV      R4,#+1
   1759                  }
   1760                }
   1761              }
   1762              //
   1763              // We purposely clear the invalid flag after painting so we can still query the invalid rectangle while painting
   1764              //
   1765              pWin = WM_H2P(hWin);
   \                     ??WM__Paint_1:
   \   00000188   04009DE5           LDR      R0,[SP, #+4]
   \   0000018C   ........           BL       GUI_ALLOC_h2p
   \   00000190   0050A0E1           MOV      R5,R0
   1766              pWin->Status &= ~(WM_SF_INVALID | WM_SF_INVALID_DRAW); // Clear invalid flag
   \   00000194   280095E5           LDR      R0,[R5, #+40]
   \   00000198   2010E0E3           MVN      R1,#+32
   \   0000019C   401CC1E3           BIC      R1,R1,#0x4000
   \   000001A0   000001E0           AND      R0,R1,R0
   \   000001A4   280085E5           STR      R0,[R5, #+40]
   1767              if (pWin->Status & WM_CF_MEMDEV_ON_REDRAW) {
   \   000001A8   800D10E3           TST      R0,#0x2000
   1768                pWin->Status |= WM_CF_MEMDEV;
   \   000001AC   04008013           ORRNE    R0,R0,#0x4
   1769              }
   1770              WM__NumInvalidWindows--;
   \   000001B0   ........           LDR      R7,??DataTable27
   \   000001B4   28008515           STRNE    R0,[R5, #+40]
   \   000001B8   BA01D7E1           LDRH     R0,[R7, #+26]
   \   000001BC   010040E2           SUB      R0,R0,#+1
   \   000001C0   BA01C7E1           STRH     R0,[R7, #+26]
   1771            }
   1772            return Ret;
   \                     ??WM__Paint_0:
   \   000001C4   0400A0E1           MOV      R0,R4
   \   000001C8   08D08DE2           ADD      SP,SP,#+8
   \   000001CC   F081BDE8           POP      {R4-R8,PC}       ;; return
   1773          }
   1774          
   1775          /*********************************************************************
   1776          *
   1777          *       _DrawNext
   1778          */

   \                                 In section .text, align 4, keep-with-next
   1779          static void _DrawNext(void) {
   \                     _DrawNext:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   1780            WM_Obj * pWin;
   1781            int UpdateRem = 1;
   1782            WM_HWIN iWin;
   1783            GUI_CONTEXT ContextOld;
   1784            GUI_COLOR ColorOld, BkColorOld;
   1785          
   1786            iWin = (_NextDrawWin == WM_HWIN_NULL) ? WM__FirstWin : _NextDrawWin;
   \   00000004   ........           LDR      R5,??DataTable23
   \   00000008   A0D04DE2           SUB      SP,SP,#+160
   \   0000000C   386195E5           LDR      R6,[R5, #+312]
   \   00000010   0140A0E3           MOV      R4,#+1
   \   00000014   000056E3           CMP      R6,#+0
   \   00000018   20609505           LDREQ    R6,[R5, #+32]
   1787            /* Save context */
   1788            GUI_SaveContext(&ContextOld);
   \   0000001C   0D00A0E1           MOV      R0,SP
   \   00000020   ........           BL       GUI_SaveContext_W
   1789            ColorOld   = GUI_Context.Color;
   \   00000024   ........           LDR      R0,??DataTable27_1
   \   00000028   307090E5           LDR      R7,[R0, #+48]
   1790            BkColorOld = GUI_Context.BkColor;
   \   0000002C   348090E5           LDR      R8,[R0, #+52]
   \   00000030   060000EA           B        ??_DrawNext_0
   1791            /* Make sure the next window to redraw is valid */
   1792            for (; iWin && UpdateRem; ) {
   1793              if (WM__Paint(iWin)) {
   \                     ??_DrawNext_1:
   \   00000034   0600A0E1           MOV      R0,R6
   \   00000038   ........           BL       WM__Paint
   \   0000003C   000050E3           CMP      R0,#+0
   1794                UpdateRem--;  /* Only the given number of windows at a time ... */
   \   00000040   01404412           SUBNE    R4,R4,#+1
   1795              }
   1796              pWin = WM_H2P(iWin);
   1797              iWin = pWin->hNextLin;
   \   00000044   0600A0E1           MOV      R0,R6
   \   00000048   ........           BL       GUI_ALLOC_h2p
   \   0000004C   146090E5           LDR      R6,[R0, #+20]
   1798            }  
   \                     ??_DrawNext_0:
   \   00000050   000056E3           CMP      R6,#+0
   \   00000054   00005413           CMPNE    R4,#+0
   \   00000058   F5FFFF1A           BNE      ??_DrawNext_1
   1799            _NextDrawWin = iWin;   /* Remember the window */
   \   0000005C   386185E5           STR      R6,[R5, #+312]
   1800            /* Make sure alpha blending device settings matches color settings of context */
   1801            GUI_SetColor(ColorOld);
   \   00000060   0700A0E1           MOV      R0,R7
   \   00000064   ........           BL       GUI_SetColor
   1802            GUI_SetBkColor(BkColorOld);
   \   00000068   0800A0E1           MOV      R0,R8
   \   0000006C   ........           BL       GUI_SetBkColor
   1803            /* Restore context */
   1804            GUI_RestoreContext(&ContextOld);
   \   00000070   0D00A0E1           MOV      R0,SP
   \   00000074   ........           BL       GUI_RestoreContext
   1805          }
   \   00000078   A0D08DE2           ADD      SP,SP,#+160      ;; stack cleaning
   \   0000007C   F081BDE8           POP      {R4-R8,PC}       ;; return
   1806          
   1807          /*********************************************************************
   1808          *
   1809          *       WM__DeleteSecure
   1810          */

   \                                 In section .text, align 4, keep-with-next
   1811          void WM__DeleteSecure(WM_HWIN hWin) {
   \                     WM__DeleteSecure:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1812            WM_Obj * pWin;
   1813          
   1814            pWin = WM_H2P(hWin);
   \   00000008   ........           BL       GUI_ALLOC_h2p
   1815            pWin->Status |= WM_SF_DELETE;
   \   0000000C   281090E5           LDR      R1,[R0, #+40]
   1816            _DeleteWindows = 1;
   1817          }
   \   00000010   04D08DE2           ADD      SP,SP,#+4
   \   00000014   801C81E3           ORR      R1,R1,#0x8000
   \   00000018   281080E5           STR      R1,[R0, #+40]
   \   0000001C   ........           LDR      R0,??DataTable23
   \   00000020   0110A0E3           MOV      R1,#+1
   \   00000024   3C1180E5           STR      R1,[R0, #+316]
   \   00000028   0080BDE8           POP      {PC}             ;; return
   1818          
   1819          /*********************************************************************
   1820          *
   1821          *       _DeleteDelayed
   1822          */
   1823          static void _DeleteDelayed(void) {
   1824            WM_HWIN  hWin, hWinDelete;
   1825            WM_Obj * pWin;
   1826          
   1827            WM_LOCK();
   1828            for (hWin = WM__FirstWin; hWin;) {
   1829              pWin = WM_H2P(hWin);
   1830              if (pWin->Status & WM_SF_DELETE) {
   1831                hWinDelete = hWin;
   1832                hWin = pWin->hNextLin;
   1833                WM_DeleteWindow(hWinDelete);
   1834              } else {
   1835                hWin = pWin->hNextLin;
   1836              }
   1837            }
   1838            _DeleteWindows = 0;
   1839            WM_UNLOCK();
   1840          }
   1841          
   1842          /*********************************************************************
   1843          *
   1844          *       WM_Exec1
   1845          */

   \                                 In section .text, align 4, keep-with-next
   1846          int WM_Exec1(void) {
   \                     WM_Exec1:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1847            /* Delete windows if required */
   1848            if (_DeleteWindows) {
   \   00000004   ........           LDR      R4,??DataTable23
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   3C0194E5           LDR      R0,[R4, #+316]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   1300000A           BEQ      ??WM_Exec1_0
   1849              _DeleteDelayed();
   \   00000018   ........           BL       GUI_Lock
   \   0000001C   205094E5           LDR      R5,[R4, #+32]
   \   00000020   000055E3           CMP      R5,#+0
   \   00000024   0C00000A           BEQ      ??WM_Exec1_1
   \                     ??WM_Exec1_2:
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   ........           BL       GUI_ALLOC_h2p
   \   00000030   141090E5           LDR      R1,[R0, #+20]
   \   00000034   B802D0E1           LDRH     R0,[R0, #+40]
   \   00000038   800C10E3           TST      R0,#0x8000
   \   0000003C   0300000A           BEQ      ??WM_Exec1_3
   \   00000040   0500A0E1           MOV      R0,R5
   \   00000044   0150A0E1           MOV      R5,R1
   \   00000048   ........           BL       WM_DeleteWindow
   \   0000004C   000000EA           B        ??WM_Exec1_4
   \                     ??WM_Exec1_3:
   \   00000050   0150A0E1           MOV      R5,R1
   \                     ??WM_Exec1_4:
   \   00000054   000055E3           CMP      R5,#+0
   \   00000058   F2FFFF1A           BNE      ??WM_Exec1_2
   \                     ??WM_Exec1_1:
   \   0000005C   0000A0E3           MOV      R0,#+0
   \   00000060   3C0184E5           STR      R0,[R4, #+316]
   \   00000064   ........           BL       GUI_Unlock
   1850            }
   1851            /* Poll PID if necessary */
   1852            if (WM_pfPollPID) {
   \                     ??WM_Exec1_0:
   \   00000068   2C0194E5           LDR      R0,[R4, #+300]
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   0000000A           BEQ      ??WM_Exec1_5
   1853              WM_pfPollPID();
   \   00000074   30FF2FE1           BLX      R0
   1854            }
   1855            if (WM_pfHandlePID) {
   \                     ??WM_Exec1_5:
   \   00000078   ........           LDR      R0,??DataTable27_5
   \   0000007C   000090E5           LDR      R0,[R0, #+0]
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   0200000A           BEQ      ??WM_Exec1_6
   1856              if (WM_pfHandlePID())
   \   00000088   30FF2FE1           BLX      R0
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   0D00001A           BNE      ??WM_Exec1_7
   1857                return 1;               /* We have done something ... */
   1858            }
   1859            if (WM_IsActive) {
   \                     ??WM_Exec1_6:
   \   00000094   4001D4E5           LDRB     R0,[R4, #+320]
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   0B00000A           BEQ      ??WM_Exec1_8
   1860              if (GUI_PollKeyMsg()) {
   \   000000A0   ........           BL       GUI_PollKeyMsg
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   0700001A           BNE      ??WM_Exec1_7
   1861                return 1;               /* We have done something ... */
   1862              }
   1863            }
   1864          #ifdef WIN32
   1865            if (WM_PollSimMsg()) {
   1866              return 1;               /* We have done something ... */
   1867            }
   1868          #endif
   1869            if (WM_IsActive && WM__NumInvalidWindows) {
   \   000000AC   4001D4E5           LDRB     R0,[R4, #+320]
   \   000000B0   000050E3           CMP      R0,#+0
   \   000000B4   BA01D411           LDRHNE   R0,[R4, #+26]
   \   000000B8   00005013           CMPNE    R0,#+0
   \   000000BC   0300000A           BEQ      ??WM_Exec1_8
   1870              WM_LOCK();
   \   000000C0   ........           BL       GUI_Lock
   1871              _DrawNext();
   \   000000C4   ........           BL       _DrawNext
   1872              WM_UNLOCK();
   \   000000C8   ........           BL       GUI_Unlock
   1873              return 1;               /* We have done something ... */
   \                     ??WM_Exec1_7:
   \   000000CC   0100A0E3           MOV      R0,#+1
   \                     ??WM_Exec1_8:
   \   000000D0   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000D4   3080BDE8           POP      {R4,R5,PC}       ;; return
   1874            }
   1875            return 0;                  /* There was nothing to do ... */
   1876          }
   1877          
   1878          /*********************************************************************
   1879          *
   1880          *       WM_Exec
   1881          */

   \                                 In section .text, align 4, keep-with-next
   1882          int WM_Exec(void) {
   \                     WM_Exec:
   \   00000000   10402DE9           PUSH     {R4,LR}
   1883            int r = 0;
   \   00000004   0040A0E3           MOV      R4,#+0
   \   00000008   000000EA           B        ??WM_Exec_0
   1884            while (WM_Exec1()) {
   1885              r = 1;                  /* We have done something */
   \                     ??WM_Exec_1:
   \   0000000C   0140A0E3           MOV      R4,#+1
   1886            }
   \                     ??WM_Exec_0:
   \   00000010   ........           BL       WM_Exec1
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   FBFFFF1A           BNE      ??WM_Exec_1
   1887            return r;
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   1080BDE8           POP      {R4,PC}          ;; return
   1888          }
   1889          
   1890          /*********************************************************************
   1891          *
   1892          *       cbBackWin
   1893          *
   1894          * Purpose
   1895          *   Callback for background window
   1896          *
   1897          */

   \                                 In section .text, align 4, keep-with-next
   1898          static void cbBackWin( WM_MESSAGE* pMsg) {
   \                     cbBackWin:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1899            const WM_KEY_INFO* pKeyInfo;
   1900            switch (pMsg->MsgId) {
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0E0050E3           CMP      R0,#+14
   \   00000014   0300000A           BEQ      ??cbBackWin_0
   \   00000018   2700003A           BCC      ??cbBackWin_1
   \   0000001C   0F0050E3           CMP      R0,#+15
   \   00000020   0700000A           BEQ      ??cbBackWin_2
   \   00000024   240000EA           B        ??cbBackWin_1
   1901            case WM_KEY:
   1902              pKeyInfo = (const WM_KEY_INFO*)pMsg->Data.p;
   \                     ??cbBackWin_0:
   \   00000028   0C0094E5           LDR      R0,[R4, #+12]
   1903              if (pKeyInfo->PressedCnt == 1) {
   \   0000002C   041090E5           LDR      R1,[R0, #+4]
   \   00000030   010051E3           CMP      R1,#+1
   \   00000034   2200001A           BNE      ??cbBackWin_3
   1904                GUI_StoreKey(pKeyInfo->Key);
   \   00000038   000090E5           LDR      R0,[R0, #+0]
   \   0000003C   ........           BL       GUI_StoreKey
   \   00000040   1F0000EA           B        ??cbBackWin_3
   1905              }
   1906              break;
   1907            case WM_PAINT:
   1908              {
   1909                int LayerIndex;
   1910                #if GUI_NUM_LAYERS > 1
   1911                  LayerIndex = _DesktopHandle2Index(pMsg->hWin);
   \                     ??cbBackWin_2:
   \   00000044   ........           LDR      R2,??DataTable27
   \   00000048   040094E5           LDR      R0,[R4, #+4]
   \   0000004C   28E092E5           LDR      LR,[R2, #+40]
   \   00000050   0010A0E3           MOV      R1,#+0
   \   00000054   2C3082E2           ADD      R3,R2,#+44
   \   00000058   0E0050E1           CMP      R0,LR
   \   0000005C   0F00000A           BEQ      ??cbBackWin_4
   \   00000060   00E093E5           LDR      LR,[R3, #+0]
   \   00000064   043082E2           ADD      R3,R2,#+4
   \   00000068   0110A0E3           MOV      R1,#+1
   \   0000006C   2C3083E2           ADD      R3,R3,#+44
   \   00000070   07C0A0E3           MOV      R12,#+7
   \                     ??cbBackWin_5:
   \   00000074   0E0050E1           CMP      R0,LR
   \   00000078   04509314           LDRNE    R5,[R3], #+4
   \   0000007C   01108112           ADDNE    R1,R1,#+1
   \   00000080   05005011           CMPNE    R0,R5
   \   00000084   0500000A           BEQ      ??cbBackWin_4
   \   00000088   011081E2           ADD      R1,R1,#+1
   \   0000008C   04E093E4           LDR      LR,[R3], #+4
   \   00000090   01C05CE2           SUBS     R12,R12,#+1
   \   00000094   F6FFFF1A           BNE      ??cbBackWin_5
   \   00000098   0E0050E1           CMP      R0,LR
   \   0000009C   0010E013           MVNNE    R1,#+0
   \                     ??cbBackWin_4:
   \   000000A0   010182E0           ADD      R0,R2,R1, LSL #+2
   \   000000A4   680090E5           LDR      R0,[R0, #+104]
   \   000000A8   F014E0E3           MVN      R1,#-268435456
   \   000000AC   010050E1           CMP      R0,R1
   \   000000B0   0100000A           BEQ      ??cbBackWin_1
   1912                #else
   1913                  LayerIndex = 0;
   1914                #endif
   1915                if (WM__aBkColor[LayerIndex] != GUI_INVALID_COLOR) {
   1916                  GUI_SetBkColor(WM__aBkColor[LayerIndex]);
   \   000000B4   ........           BL       GUI_SetBkColor
   1917                  GUI_Clear();
   \   000000B8   ........           BL       GUI_Clear
   1918                }
   1919              }
   1920            default:
   1921              WM_DefaultProc(pMsg);
   \                     ??cbBackWin_1:
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   ........           BL       WM_DefaultProc
   1922            }
   1923          }
   \                     ??cbBackWin_3:
   \   000000C4   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000C8   3080BDE8           POP      {R4,R5,PC}       ;; return
   1924          
   1925          /*********************************************************************
   1926          *
   1927          *       WM_Activate
   1928          */

   \                                 In section .text, align 4, keep-with-next
   1929          void WM_Activate(void) {
   1930            WM_IsActive = 1;       /* Running */
   \                     WM_Activate:
   \   00000000   ........           LDR      R0,??DataTable27
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   4011C0E5           STRB     R1,[R0, #+320]
   1931          }
   \   0000000C   1EFF2FE1           BX       LR               ;; return
   1932          
   1933          /*********************************************************************
   1934          *
   1935          *       WM_Deactivate
   1936          */

   \                                 In section .text, align 4, keep-with-next
   1937          void WM_Deactivate(void) {
   \                     WM_Deactivate:
   \   00000000   00402DE9           PUSH     {LR}
   1938            WM_IsActive = 0;       /* No clipping performed by WM */
   \   00000004   ........           LDR      R0,??DataTable27
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   4011C0E5           STRB     R1,[R0, #+320]
   1939            WM_LOCK();
   \   00000014   ........           BL       GUI_Lock
   1940            LCD_SetClipRectMax();
   \   00000018   ........           BL       LCD_SetClipRectMax
   1941            WM_UNLOCK();
   \   0000001C   04D08DE2           ADD      SP,SP,#+4
   \   00000020   0040BDE8           POP      {LR}
   \   00000024   ........           B        GUI_Unlock       ;; tailcall
   1942          }
   1943          
   1944          /*********************************************************************
   1945          *
   1946          *       WM_DefaultProc
   1947          *
   1948          * Purpose
   1949          *   Default callback for windows
   1950          *   Any window should call this routine in the "default" part of the
   1951          *   its callback function for messages it does not handle itself.
   1952          *
   1953          */

   \                                 In section .text, align 4, keep-with-next
   1954          void WM_DefaultProc(WM_MESSAGE * pMsg) {
   \                     WM_DefaultProc:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1955            WM_HWIN hWin;
   1956            const void * p;
   1957            WM_Obj * pWin;
   1958          
   1959            hWin = pMsg->hWin;
   \   00000008   046094E5           LDR      R6,[R4, #+4]
   1960            p = pMsg->Data.p;
   \   0000000C   0C5094E5           LDR      R5,[R4, #+12]
   1961            pWin = WM_H2P(hWin);
   \   00000010   0600A0E1           MOV      R0,R6
   \   00000014   ........           BL       GUI_ALLOC_h2p
   1962            /* Exec message */
   1963            switch (pMsg->MsgId) {
   \   00000018   001094E5           LDR      R1,[R4, #+0]
   \   0000001C   0E1041E2           SUB      R1,R1,#+14
   \   00000020   1A0051E3           CMP      R1,#+26
   \   00000024   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??WM_DefaultProc_0:
   \   00000028   2500008A           BHI      ??WM_DefaultProc_1
   \   0000002C   2A0000EA           B        ??WM_DefaultProc_2
   \   00000030   230000EA           B        ??WM_DefaultProc_1
   \   00000034   220000EA           B        ??WM_DefaultProc_1
   \   00000038   210000EA           B        ??WM_DefaultProc_1
   \   0000003C   200000EA           B        ??WM_DefaultProc_1
   \   00000040   1F0000EA           B        ??WM_DefaultProc_1
   \   00000044   130000EA           B        ??WM_DefaultProc_3
   \   00000048   1D0000EA           B        ??WM_DefaultProc_1
   \   0000004C   1C0000EA           B        ??WM_DefaultProc_1
   \   00000050   1F0000EA           B        ??WM_DefaultProc_4
   \   00000054   1A0000EA           B        ??WM_DefaultProc_1
   \   00000058   190000EA           B        ??WM_DefaultProc_1
   \   0000005C   180000EA           B        ??WM_DefaultProc_1
   \   00000060   170000EA           B        ??WM_DefaultProc_1
   \   00000064   160000EA           B        ??WM_DefaultProc_1
   \   00000068   150000EA           B        ??WM_DefaultProc_1
   \   0000006C   140000EA           B        ??WM_DefaultProc_1
   \   00000070   130000EA           B        ??WM_DefaultProc_1
   \   00000074   120000EA           B        ??WM_DefaultProc_1
   \   00000078   110000EA           B        ??WM_DefaultProc_1
   \   0000007C   1A0000EA           B        ??WM_DefaultProc_5
   \   00000080   0F0000EA           B        ??WM_DefaultProc_1
   \   00000084   0E0000EA           B        ??WM_DefaultProc_1
   \   00000088   0D0000EA           B        ??WM_DefaultProc_1
   \   0000008C   0C0000EA           B        ??WM_DefaultProc_1
   \   00000090   0B0000EA           B        ??WM_DefaultProc_1
   \   00000094   160000EA           B        ??WM_DefaultProc_6
   1964            case WM_GET_INSIDE_RECT:      /* return client window in absolute (screen) coordinates */
   1965              WM__GetClientRectWin(pWin, (GUI_RECT*)p);
   \                     ??WM_DefaultProc_3:
   \   00000098   0010A0E3           MOV      R1,#+0
   \   0000009C   B210C5E1           STRH     R1,[R5, #+2]
   \   000000A0   B010C5E1           STRH     R1,[R5, #+0]
   \   000000A4   F410D0E1           LDRSH    R1,[R0, #+4]
   \   000000A8   F020D0E1           LDRSH    R2,[R0, #+0]
   \   000000AC   021041E0           SUB      R1,R1,R2
   \   000000B0   B410C5E1           STRH     R1,[R5, #+4]
   \   000000B4   F610D0E1           LDRSH    R1,[R0, #+6]
   \   000000B8   F200D0E1           LDRSH    R0,[R0, #+2]
   \   000000BC   000041E0           SUB      R0,R1,R0
   \   000000C0   B600C5E1           STRH     R0,[R5, #+6]
   1966              break;
   1967            case WM_GET_CLIENT_WINDOW:      /* return handle to client window. For most windows, there is no seperate client window, so it is the same handle */
   1968              pMsg->Data.v = (int)hWin;
   1969              return;                       /* Message handled */
   1970            case WM_KEY:
   1971              WM_SendToParent(hWin, pMsg);
   1972              return;                       /* Message handled */
   1973             case WM_GET_BKCOLOR:
   1974              pMsg->Data.Color = GUI_INVALID_COLOR;
   1975              return;                       /* Message handled */
   1976            case WM_NOTIFY_ENABLE:
   1977              WM_InvalidateWindow(hWin);    
   1978              return;                       /* Message handled */
   1979            }
   1980            /* Message not handled. If it queries something, we return 0 to be on the safe side. */
   1981            pMsg->Data.v = 0;
   \                     ??WM_DefaultProc_1:
   \   000000C4   0000A0E3           MOV      R0,#+0
   \   000000C8   0C0084E5           STR      R0,[R4, #+12]
   1982            pMsg->Data.p = 0;
   \                     ??WM_DefaultProc_7:
   \   000000CC   0C0084E5           STR      R0,[R4, #+12]
   1983          }
   \   000000D0   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??WM_DefaultProc_4:
   \   000000D4   0C6084E5           STR      R6,[R4, #+12]
   \   000000D8   7080BDE8           POP      {R4-R6,PC}
   \                     ??WM_DefaultProc_2:
   \   000000DC   0410A0E1           MOV      R1,R4
   \   000000E0   0600A0E1           MOV      R0,R6
   \   000000E4   7040BDE8           POP      {R4-R6,LR}
   \   000000E8   ........           B        WM_SendToParent  ;; tailcall
   \                     ??WM_DefaultProc_5:
   \   000000EC   F004E0E3           MVN      R0,#-268435456
   \   000000F0   F5FFFFEA           B        ??WM_DefaultProc_7
   \                     ??WM_DefaultProc_6:
   \   000000F4   0600A0E1           MOV      R0,R6
   \   000000F8   7040BDE8           POP      {R4-R6,LR}
   \   000000FC   0010A0E3           MOV      R1,#+0
   \   00000100   ........           B        WM_InvalidateRect  ;; tailcall
   1984          
   1985          /*********************************************************************
   1986          *
   1987          *       WM_Init
   1988          */

   \                                 In section .text, align 4, keep-with-next
   1989          void WM_Init(void) {
   \                     WM_Init:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   1990            int i;
   1991          
   1992          	if (!_IsInited) {
   \   00000004   ........           LDR      R4,??DataTable27
   \   00000008   10D04DE2           SUB      SP,SP,#+16
   \   0000000C   4201D4E5           LDRB     R0,[R4, #+322]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   3700001A           BNE      ??WM_Init_0
   1993          	  _NextDrawWin = WM__FirstWin = WM_HWIN_NULL;
   1994          	  GUI_Context.WM__pUserClipRect = NULL;
   \   00000018   ........           LDR      R0,??DataTable27_1
   \   0000001C   0050A0E3           MOV      R5,#+0
   1995          	  WM__NumWindows = WM__NumInvalidWindows = 0;
   1996          	  /* Make sure we have at least one window. This greatly simplifies the
   1997          		  drawing routines as they do not have to check if the window is valid.
   1998          	  */
   1999              #if GUI_NUM_LAYERS == 1
   2000                WM__ahDesktopWin[0] = WM_CreateWindow(0, 0, GUI_XMAX, GUI_YMAX, WM_CF_SHOW, cbBackWin, 0);
   2001                WM__aBkColor[0] = GUI_INVALID_COLOR;
   2002                WM_InvalidateWindow(WM__ahDesktopWin[0]); /* Required because a desktop window has no parent. */
   2003              #else
   2004              {
   2005                for (i = 0; i < GUI_NUM_LAYERS; i++) {
   \   00000020   F084E0E3           MVN      R8,#-268435456
   \   00000024   205084E5           STR      R5,[R4, #+32]
   \   00000028   385184E5           STR      R5,[R4, #+312]
   \   0000002C   385080E5           STR      R5,[R0, #+56]
   \   00000030   185084E5           STR      R5,[R4, #+24]
   \   00000034   286084E2           ADD      R6,R4,#+40
   \   00000038   687084E2           ADD      R7,R4,#+104
   \   0000003C   2898A0E1           MOV      R9,R8, LSR #+16
   \   00000040   ........           LDR      R10,??DataTable27_6
   2006                  if (GUI_DEVICE__GetpDriver(i)) {
   \                     ??WM_Init_1:
   \   00000044   0500A0E1           MOV      R0,R5
   \   00000048   ........           BL       GUI_DEVICE__GetpDriver
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0F00000A           BEQ      ??WM_Init_2
   2007                    WM__ahDesktopWin[i] = WM_CreateWindowAsChild(0, 0, GUI_XMAX, GUI_YMAX, WM_UNATTACHED, WM_CF_SHOW, cbBackWin, 0);
   \   00000054   0000A0E3           MOV      R0,#+0
   \   00000058   0C008DE5           STR      R0,[SP, #+12]
   \   0000005C   0200A0E3           MOV      R0,#+2
   \   00000060   04008DE5           STR      R0,[SP, #+4]
   \   00000064   F00488E3           ORR      R0,R8,#0xF0000000
   \   00000068   00008DE5           STR      R0,[SP, #+0]
   \   0000006C   08A08DE5           STR      R10,[SP, #+8]
   \   00000070   0930A0E1           MOV      R3,R9
   \   00000074   0920A0E1           MOV      R2,R9
   \   00000078   0010A0E3           MOV      R1,#+0
   \   0000007C   0000A0E3           MOV      R0,#+0
   \   00000080   ........           BL       WM_CreateWindowAsChild
   \   00000084   000086E5           STR      R0,[R6, #+0]
   2008                    WM__aBkColor[i] = GUI_INVALID_COLOR;
   \   00000088   008087E5           STR      R8,[R7, #+0]
   2009                    WM_InvalidateWindow(WM__ahDesktopWin[i]); /* Required because a desktop window has no parent. */
   \   0000008C   0010A0E3           MOV      R1,#+0
   \   00000090   ........           BL       WM_InvalidateRect
   2010                  }
   2011                }
   \                     ??WM_Init_2:
   \   00000094   015085E2           ADD      R5,R5,#+1
   \   00000098   047087E2           ADD      R7,R7,#+4
   \   0000009C   046086E2           ADD      R6,R6,#+4
   \   000000A0   100055E3           CMP      R5,#+16
   \   000000A4   E6FFFFBA           BLT      ??WM_Init_1
   2012              }
   2013              #endif
   2014              /* Register the critical handles ... Note: This could be moved into the module setting the Window handle */
   2015              for (i = 0; i < GUI_NUM_LAYERS; i++) {
   \   000000A8   ........           LDR      R5,??DataTable27_7
   \   000000AC   ........           LDR      R6,??DataTable27_8
   \   000000B0   ........           LDR      R7,??DataTable27_9
   \   000000B4   1080A0E3           MOV      R8,#+16
   2016                WM__AddCriticalHandle(&WM__aCHWinModal[i]);
   \                     ??WM_Init_3:
   \   000000B8   0500A0E1           MOV      R0,R5
   \   000000BC   ........           BL       WM__AddCriticalHandle
   2017                WM__AddCriticalHandle(&WM__aCHWinLast[i]);
   \   000000C0   0600A0E1           MOV      R0,R6
   \   000000C4   ........           BL       WM__AddCriticalHandle
   2018                #if GUI_SUPPORT_MOUSE
   2019                  WM__AddCriticalHandle(&WM__aCHWinMouseOver[i]);
   \   000000C8   0700A0E1           MOV      R0,R7
   \   000000CC   ........           BL       WM__AddCriticalHandle
   2020                #endif
   2021              }
   \   000000D0   087087E2           ADD      R7,R7,#+8
   \   000000D4   086086E2           ADD      R6,R6,#+8
   \   000000D8   085085E2           ADD      R5,R5,#+8
   \   000000DC   018058E2           SUBS     R8,R8,#+1
   \   000000E0   F4FFFF1A           BNE      ??WM_Init_3
   2022          
   2023              WM_SelectWindow(WM__ahDesktopWin[0]);
   \   000000E4   280094E5           LDR      R0,[R4, #+40]
   \   000000E8   ........           BL       WM_SelectWindow
   2024          	  WM_Activate();
   \   000000EC   0100A0E3           MOV      R0,#+1
   \   000000F0   4001C4E5           STRB     R0,[R4, #+320]
   2025              _IsInited =1;
   \   000000F4   4201C4E5           STRB     R0,[R4, #+322]
   2026          	}
   2027          }
   \                     ??WM_Init_0:
   \   000000F8   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   000000FC   F087BDE8           POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     _ClipContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   ........           DC32     _ClipContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   9F3F0100           DC32     0x13f9f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   ........           DC32     _ClipContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   ........           DC32     _ClipContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \   00000000   ........           DC32     GUI_MEMDEV_Paint1Static

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \   00000000   ........           DC32     WM__Paint1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_4:
   \   00000000   ........           DC32     _cbPaintMemDev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_5:
   \   00000000   ........           DC32     WM_pfHandlePID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_6:
   \   00000000   ........           DC32     cbBackWin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_7:
   \   00000000   ........           DC32     WM__aCHWinModal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_8:
   \   00000000   ........           DC32     WM__aCHWinLast

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_9:
   \   00000000   ........           DC32     WM__aCHWinMouseOver
   2028          
   2029          
   2030          #else
   2031            void WM(void) {} /* avoid empty object files */
   2032          #endif   /* GUI_WINSUPPORT */
   2033          
   2034          /*************************** End of file ****************************/
   2035          

   Maximum stack usage in bytes:

     Function                      .cstack
     --------                      -------
     WM_Activate                        0
     WM_CreateWindow                   24
     WM_CreateWindowAsChild            56
     WM_Deactivate                      8
     WM_DefaultProc                    16
     WM_DeleteWindow                   40
     WM_Exec                            8
     WM_Exec1                          16
     WM_GetActiveWindow                 0
     WM_Init                           48
     WM_InvalidateRect                 40
     WM_InvalidateWindow                8
     WM_InvalidateWindowAndDescsEx     24
     WM_SelectWindow                   24
     WM_SendMessage                    16
     WM_SetDefault                      8
     WM__ActivateClipRect              40
     WM__Client2Screen                  8
     WM__ClipAtParentBorders           16
     WM__DeleteSecure                   8
     WM__DetachWindow                  24
     WM__GetClientRectWin               0
     WM__GetNextIVR                     8
     WM__GetTopLevelLayer               8
     WM__InitIVRSearch                 40
     WM__InsertWindowIntoList          32
     WM__Invalidate1Abs                 8
     WM__InvalidateDrawAndDescs        16
     WM__InvalidateParent              16
     WM__InvalidateRect                48
     WM__InvalidateRectEx               8
     WM__IsWindow                       8
     WM__Paint                         32
     WM__Paint1                        40
     WM__RectIsNZ                       0
     WM__RemoveFromLinList             16
     WM__RemoveWindowFromList          16
     WM__SelectTopLevelLayer            8
     WM__SendMsgNoData                 24
     _DrawNext                        184
     _FindNext_IVR                     56
     _Findx0                           40
     _Findx1                           32
     _Findy1                           32
     _Invalidate1Abs                   24
     _PaintTransChildren               48
     _PaintTransTopSiblings            40
     _cbPaintMemDev                    24
     cbBackWin                         16


   Section sizes:

     Function/Label                Bytes
     --------------                -----
     _ClipContext                   323
     WM__NumWindows
     WM__NumInvalidWindows
     WM__TouchedLayer
     WM__FirstWin
     WM__pFirstCriticalHandle
     WM__ahDesktopWin
     WM__aBkColor
     WM__CreateFlags
     WM__ahCapture
     WM__ahWinFocus
     WM_pfPollPID
     WM__TransWindowCnt
     WM__hATransWindow
     _NextDrawWin
     _DeleteWindows
     WM_IsActive
     WM__PaintCallbackCnt
     _IsInited
     WM__CaptureReleaseAuto           1
     WM__InvalidateParent            60
     _Invalidate1Abs                228
     WM__Invalidate1Abs               8
     WM__ClipAtParentBorders        176
     WM__ActivateClipRect           344
     WM__InsertWindowIntoList       184
     WM__RemoveWindowFromList       108
     WM__DetachWindow               160
     WM__Client2Screen               20
     WM__IsWindow                    52
     WM__InvalidateDrawAndDescs     112
     WM_InvalidateWindowAndDescsEx  144
     WM__InvalidateRect             292
     WM__InvalidateRectEx             8
     WM__RemoveFromLinList           72
     WM__RectIsNZ                    48
     _Findy1                        256
     _Findx0                        224
     _Findx1                        204
     WM_SendMessage                  52
     WM__SendMsgNoData               32
     WM__GetClientRectWin            48
     WM_InvalidateRect              444
     WM_InvalidateWindow              8
     WM_CreateWindowAsChild         452
     WM_CreateWindow                 52
     WM_DeleteWindow                380
     WM__GetTopLevelLayer           112
     WM__SelectTopLevelLayer        124
     WM_SelectWindow                208
     WM_GetActiveWindow              12
     _FindNext_IVR                 1072
     WM__GetNextIVR                  88
     WM__InitIVRSearch              608
     WM_SetDefault                   32
     WM__Paint1                     272
     _PaintTransChildren            312
     _PaintTransTopSiblings         264
     _cbPaintMemDev                 208
     WM__Paint                      464
     _DrawNext                      128
     WM__DeleteSecure                44
     WM_Exec1                       216
     WM_Exec                         36
     cbBackWin                      204
     WM_Activate                     16
     WM_Deactivate                   40
     WM_DefaultProc                 260
     WM_Init                        256
     ??DataTable7                     4
     ??DataTable9                     4
     ??DataTable9_1                   4
     ??DataTable17                    4
     ??DataTable18                    4
     ??DataTable23                    4
     ??DataTable27                    4
     ??DataTable27_1                  4
     ??DataTable27_2                  4
     ??DataTable27_3                  4
     ??DataTable27_4                  4
     ??DataTable27_5                  4
     ??DataTable27_6                  4
     ??DataTable27_7                  4
     ??DataTable27_8                  4
     ??DataTable27_9                  4

 
   324 bytes in section .bss
 9 208 bytes in section .text
 
 9 208 bytes of CODE memory
   324 bytes of DATA memory

Errors: none
Warnings: none
