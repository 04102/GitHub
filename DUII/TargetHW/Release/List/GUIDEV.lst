###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:13:28 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDEV.c                            #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDEV.c -D DEBUG=1 -D              #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUIDEV.lst                 #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUIDEV.o                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDEV.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDEV.c
     19          Purpose     : Implementation of memory devices
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          
     24          #include <string.h>
     25          
     26          #include "GUI_Private.h"
     27          
     28          #if GUI_WINSUPPORT
     29            #include "WM.h"
     30          #endif
     31          
     32          //
     33          // Memory device capabilities are compiled only if support for them is enabled.
     34          //
     35          #if GUI_SUPPORT_MEMDEV
     36          
     37          /*********************************************************************
     38          *
     39          *       Private code
     40          *
     41          **********************************************************************
     42          */
     43          /*********************************************************************
     44          *
     45          *       GUI_MEMDEV__WriteToActiveAt
     46          */

   \                                 In section .text, align 4, keep-with-next
     47          void GUI_MEMDEV__WriteToActiveAt(GUI_MEMDEV_Handle hMem,int x, int y) {
   \                     GUI_MEMDEV__WriteToActiveAt:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
     48            GUI_MEMDEV * pDev;
     49            void (* pFunc)(GUI_MEMDEV_Handle,int, int);
     50          
     51            pDev  = GUI_MEMDEV_H2P(hMem);
   \   00000010   ........           BL       GUI_ALLOC_h2p
   \   00000014   0020A0E1           MOV      R2,R0
     52            pFunc = (void (*)(GUI_MEMDEV_Handle,int, int))pDev->pDevice->pDeviceAPI->pfGetDevFunc(NULL, MEMDEV_DEVFUNC_WRITETOACTIVE);
   \   00000018   002092E5           LDR      R2,[R2, #+0]
   \   0000001C   1610A0E3           MOV      R1,#+22
   \   00000020   0C2092E5           LDR      R2,[R2, #+12]
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   242092E5           LDR      R2,[R2, #+36]
   \   0000002C   32FF2FE1           BLX      R2
   \   00000030   0030B0E1           MOVS     R3,R0
     53            if (pFunc) {
   \   00000034   0300000A           BEQ      ??GUI_MEMDEV__WriteToActiveAt_0
     54              pFunc(hMem, x, y);
   \   00000038   0620A0E1           MOV      R2,R6
   \   0000003C   0510A0E1           MOV      R1,R5
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   33FF2FE1           BLX      R3
     55            }
     56          }
   \                     ??GUI_MEMDEV__WriteToActiveAt_0:
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
     57          
     58          /*********************************************************************
     59          *
     60          *       GUI_MEMDEV__CreateFixed
     61          */

   \                                 In section .text, align 4, keep-with-next
     62          GUI_MEMDEV_Handle GUI_MEMDEV__CreateFixed(int x0, int y0, int xSize, int ySize, int Flags,
     63                                        const GUI_DEVICE_API     * pDeviceAPI,
     64                                        const LCD_API_COLOR_CONV * pColorConvAPI) {
   \                     GUI_MEMDEV__CreateFixed:
   \   00000000   F34F2DE9           PUSH     {R0,R1,R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
     65            GUI_ALLOC_DATATYPE MaxLines;
     66            GUI_MEMDEV_Handle hMemDev;
     67            I32 MemSize;
     68            unsigned BitsPerPixel;
     69            unsigned BytesPerLine;
     70            GUI_USAGE_Handle hUsage = 0;
   \   00000008   ........           LDR      R1,??DataTable5
   \   0000000C   0350A0E1           MOV      R5,R3
   \   00000010   38709DE5           LDR      R7,[SP, #+56]
   \   00000014   0240A0E1           MOV      R4,R2
   \   00000018   1130D1E5           LDRB     R3,[R1, #+17]
   \   0000001C   30609DE5           LDR      R6,[SP, #+48]
   \   00000020   34009DE5           LDR      R0,[SP, #+52]
   \   00000024   0080A0E3           MOV      R8,#+0
   \   00000028   0020A0E3           MOV      R2,#+0
   \   0000002C   0710A0E1           MOV      R1,R7
     71            GUI_MEMDEV * pDevData;
     72            GUI_DEVICE * pDevice;
     73          
     74            //
     75            // Create device object
     76            //
     77            pDevice = GUI_DEVICE_Create(pDeviceAPI, pColorConvAPI, 0, GUI_Context.SelLayer);
   \   00000030   ........           BL       GUI_DEVICE_Create
   \   00000034   0090B0E1           MOVS     R9,R0
     78            if (pDevice == NULL) {
   \   00000038   0100001A           BNE      ??GUI_MEMDEV__CreateFixed_0
     79              return 0; // Error on creating device object
   \                     ??GUI_MEMDEV__CreateFixed_1:
   \   0000003C   0000A0E3           MOV      R0,#+0
   \   00000040   450000EA           B        ??GUI_MEMDEV__CreateFixed_2
     80            }
     81            //
     82            // Calculate BitsPerPixel and BytesPerLine
     83            //
     84            BitsPerPixel = LCD__GetBPPDevice(pDevice->pColorConvAPI->pfGetIndexMask());
   \                     ??GUI_MEMDEV__CreateFixed_0:
   \   00000044   100099E5           LDR      R0,[R9, #+16]
   \   00000048   080090E5           LDR      R0,[R0, #+8]
   \   0000004C   30FF2FE1           BLX      R0
   \   00000050   ........           BL       LCD__GetBPPDevice
   \   00000054   00A0A0E1           MOV      R10,R0
     85            BytesPerLine = (xSize * BitsPerPixel + 7) >> 3;
   \   00000058   9A0400E0           MUL      R0,R10,R4
   \   0000005C   070080E2           ADD      R0,R0,#+7
   \   00000060   A0B1A0E1           LSR      R11,R0,#+3
     86            //
     87            // Calc available MemSize
     88            //
     89            MemSize = GUI_ALLOC_RequestSize();
   \   00000064   ........           BL       GUI_ALLOC_RequestSize
     90            if (!(Flags & GUI_MEMDEV_NOTRANS)) {
   \   00000068   010016E3           TST      R6,#0x1
   \   0000006C   0300001A           BNE      ??GUI_MEMDEV__CreateFixed_3
     91              MemSize = (MemSize / 4) * 3;   // We need to reserve some memory for usage object ... TBD: This can be optimized as we do not use memory perfectly.
   \   00000070   C010A0E1           ASR      R1,R0,#+1
   \   00000074   210F80E0           ADD      R0,R0,R1, LSR #+30
   \   00000078   4001A0E1           ASR      R0,R0,#+2
   \   0000007C   800080E0           ADD      R0,R0,R0, LSL #+1
     92            }
     93            if (ySize<=0) {
   \                     ??GUI_MEMDEV__CreateFixed_3:
   \   00000080   010055E3           CMP      R5,#+1
   \   00000084   060000AA           BGE      ??GUI_MEMDEV__CreateFixed_4
     94              MaxLines = (MemSize - sizeof(GUI_MEMDEV)) / BytesPerLine;
   \   00000088   180040E2           SUB      R0,R0,#+24
   \   0000008C   0B10A0E1           MOV      R1,R11
   \   00000090   ........           BL       __aeabi_uidiv
     95              ySize = (MaxLines > -ySize) ? -ySize : MaxLines;
   \   00000094   001065E2           RSB      R1,R5,#+0
   \   00000098   0150A0E1           MOV      R5,R1
   \   0000009C   000055E1           CMP      R5,R0
   \   000000A0   0050A0C1           MOVGT    R5,R0
     96            }
     97            if (!(Flags & GUI_MEMDEV_NOTRANS)) {
   \                     ??GUI_MEMDEV__CreateFixed_4:
   \   000000A4   010016E3           TST      R6,#0x1
   \   000000A8   0600001A           BNE      ??GUI_MEMDEV__CreateFixed_5
     98              //
     99              // Create the usage map
    100              //
    101              hUsage = GUI_USAGE_BM_Create(x0, y0, xSize, ySize, 0);
   \   000000AC   00808DE5           STR      R8,[SP, #+0]
   \   000000B0   0530A0E1           MOV      R3,R5
   \   000000B4   0420A0E1           MOV      R2,R4
   \   000000B8   08109DE5           LDR      R1,[SP, #+8]
   \   000000BC   04009DE5           LDR      R0,[SP, #+4]
   \   000000C0   ........           BL       GUI_USAGE_BM_Create
   \   000000C4   0080A0E1           MOV      R8,R0
    102            }
    103            //
    104            // Check if we can alloc sufficient memory
    105            //
    106            if (ySize <= 0) {
   \                     ??GUI_MEMDEV__CreateFixed_5:
   \   000000C8   010055E3           CMP      R5,#+1
   \   000000CC   020000AA           BGE      ??GUI_MEMDEV__CreateFixed_6
    107              GUI_DEBUG_WARN("GUI_MEMDEV_Create: Too little memory");
    108              GUI_DEVICE_Delete(pDevice);
   \   000000D0   0900A0E1           MOV      R0,R9
   \   000000D4   ........           BL       GUI_DEVICE_Delete
    109              return 0;    
   \   000000D8   D7FFFFEA           B        ??GUI_MEMDEV__CreateFixed_1
    110            }
    111            MemSize = (I32)ySize * BytesPerLine + sizeof(GUI_MEMDEV);
   \                     ??GUI_MEMDEV__CreateFixed_6:
   \   000000DC   9B0500E0           MUL      R0,R11,R5
    112            //
    113            // Allocate memory device object
    114            //
    115            if (Flags & GUI_MEMDEV_NOTRANS) {
   \   000000E0   010016E3           TST      R6,#0x1
   \   000000E4   180080E2           ADD      R0,R0,#+24
   \   000000E8   0100000A           BEQ      ??GUI_MEMDEV__CreateFixed_7
    116              hMemDev = GUI_ALLOC_AllocNoInit(MemSize);
   \   000000EC   ........           BL       GUI_ALLOC_AllocNoInit
   \   000000F0   000000EA           B        ??GUI_MEMDEV__CreateFixed_8
    117            } else {
    118              hMemDev = GUI_ALLOC_AllocZero(MemSize);
   \                     ??GUI_MEMDEV__CreateFixed_7:
   \   000000F4   ........           BL       GUI_ALLOC_AllocZero
   \                     ??GUI_MEMDEV__CreateFixed_8:
   \   000000F8   0060A0E1           MOV      R6,R0
    119            }
    120            //
    121            // Return on error
    122            //
    123            if (hMemDev == 0) {
   \   000000FC   000056E3           CMP      R6,#+0
   \   00000100   0400001A           BNE      ??GUI_MEMDEV__CreateFixed_9
    124              if (hUsage) {
   \   00000104   000058E3           CMP      R8,#+0
   \   00000108   CBFFFF0A           BEQ      ??GUI_MEMDEV__CreateFixed_1
    125                GUI_ALLOC_Free(hUsage);
   \   0000010C   0800A0E1           MOV      R0,R8
   \   00000110   ........           BL       GUI_ALLOC_Free
   \   00000114   C8FFFFEA           B        ??GUI_MEMDEV__CreateFixed_1
    126              }
    127              GUI_DEBUG_WARN("GUI_MEMDEV_Create: Alloc failed");
    128              return 0; // Error on creating memory device object
    129            }
    130            //
    131            // Set memory device properties
    132            //
    133            pDevData = GUI_MEMDEV_H2P(hMemDev);
   \                     ??GUI_MEMDEV__CreateFixed_9:
   \   00000118   ........           BL       GUI_ALLOC_h2p
    134            pDevData->pDevice      = pDevice;
   \   0000011C   009080E5           STR      R9,[R0, #+0]
    135            pDevData->x0           = x0;
   \   00000120   04109DE5           LDR      R1,[SP, #+4]
   \   00000124   B410C0E1           STRH     R1,[R0, #+4]
    136            pDevData->y0           = y0;
   \   00000128   08109DE5           LDR      R1,[SP, #+8]
   \   0000012C   B610C0E1           STRH     R1,[R0, #+6]
    137            pDevData->XSize        = xSize;
   \   00000130   B840C0E1           STRH     R4,[R0, #+8]
    138            pDevData->YSize        = ySize;
   \   00000134   BA50C0E1           STRH     R5,[R0, #+10]
    139            pDevData->BytesPerLine = BytesPerLine;
   \   00000138   0CB080E5           STR      R11,[R0, #+12]
    140            pDevData->BitsPerPixel = BitsPerPixel;
   \   0000013C   10A080E5           STR      R10,[R0, #+16]
    141            pDevData->hUsage       = hUsage;
   \   00000140   148080E5           STR      R8,[R0, #+20]
    142            //
    143            // Set device object properties
    144            //
    145            pDevice->pColorConvAPI = pColorConvAPI;
   \   00000144   107089E5           STR      R7,[R9, #+16]
    146            pDevice->u.hContext    = hMemDev;
    147            pDevice->LayerIndex    = GUI_Context.SelLayer;
   \   00000148   ........           LDR      R0,??DataTable5
   \   0000014C   086089E5           STR      R6,[R9, #+8]
   \   00000150   1100D0E5           LDRB     R0,[R0, #+17]
   \   00000154   180089E5           STR      R0,[R9, #+24]
    148            return hMemDev;
   \   00000158   0600A0E1           MOV      R0,R6
   \                     ??GUI_MEMDEV__CreateFixed_2:
   \   0000015C   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000160   F08FBDE8           POP      {R4-R11,PC}      ;; return
    149          }
    150          
    151          /*********************************************************************
    152          *
    153          *       Public code
    154          *
    155          **********************************************************************
    156          */
    157          /*********************************************************************
    158          *
    159          *       GUI_MEMDEV_GetBitsPerPixel
    160          */

   \                                 In section .text, align 4, keep-with-next
    161          int GUI_MEMDEV_GetBitsPerPixel(GUI_MEMDEV_Handle hMemDev) {
   \                     GUI_MEMDEV_GetBitsPerPixel:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
    162            int r = 0;
   \   0000000C   0050A0E3           MOV      R5,#+0
    163            GUI_MEMDEV * pDev;
    164          
    165            if (hMemDev) {
   \   00000010   0900000A           BEQ      ??GUI_MEMDEV_GetBitsPerPixel_0
    166              GUI_LOCK();
   \   00000014   ........           BL       GUI_Lock
    167              pDev = GUI_MEMDEV_H2P(hMemDev);
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           BL       GUI_ALLOC_h2p
    168              r = LCD__GetBPPDevice(pDev->pDevice->pColorConvAPI->pfGetIndexMask());
   \   00000020   000090E5           LDR      R0,[R0, #+0]
   \   00000024   100090E5           LDR      R0,[R0, #+16]
   \   00000028   080090E5           LDR      R0,[R0, #+8]
   \   0000002C   30FF2FE1           BLX      R0
   \   00000030   ........           BL       LCD__GetBPPDevice
   \   00000034   0050A0E1           MOV      R5,R0
    169              GUI_UNLOCK();
   \   00000038   ........           BL       GUI_Unlock
    170            }
    171            return r;
   \                     ??GUI_MEMDEV_GetBitsPerPixel_0:
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   04D08DE2           ADD      SP,SP,#+4
   \   00000044   3080BDE8           POP      {R4,R5,PC}       ;; return
    172          }
    173          
    174          /*********************************************************************
    175          *
    176          *       GUI_MEMDEV_Delete
    177          */

   \                                 In section .text, align 4, keep-with-next
    178          void GUI_MEMDEV_Delete(GUI_MEMDEV_Handle hMemDev) {
   \                     GUI_MEMDEV_Delete:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
    179            GUI_MEMDEV * pMemDev;
    180          
    181            if (hMemDev) {
   \   0000000C   1100000A           BEQ      ??GUI_MEMDEV_Delete_0
    182              GUI_LOCK();
   \   00000010   ........           BL       GUI_Lock
    183              if (GUI_Context.hDevData == hMemDev) {
   \   00000014   ........           LDR      R0,??DataTable5
   \   00000018   880090E5           LDR      R0,[R0, #+136]
   \   0000001C   040050E1           CMP      R0,R4
   \   00000020   0000001A           BNE      ??GUI_MEMDEV_Delete_1
    184                GUI_SelectLCD();
   \   00000024   ........           BL       GUI_SelectLCD
    185              }
    186              pMemDev = GUI_MEMDEV_H2P(hMemDev);
   \                     ??GUI_MEMDEV_Delete_1:
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       GUI_ALLOC_h2p
   \   00000030   0050A0E1           MOV      R5,R0
    187              //
    188              // Delete the associated usage device
    189              //
    190              if (pMemDev->hUsage) {
   \   00000034   140095E5           LDR      R0,[R5, #+20]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0000000A           BEQ      ??GUI_MEMDEV_Delete_2
    191                GUI_USAGE_DecUseCnt(pMemDev->hUsage);
   \   00000040   ........           BL       GUI_USAGE_DecUseCnt
    192              }
    193              //
    194              // Delete the device object
    195              //
    196              GUI_DEVICE_Delete(pMemDev->pDevice);
   \                     ??GUI_MEMDEV_Delete_2:
   \   00000044   000095E5           LDR      R0,[R5, #+0]
   \   00000048   ........           BL       GUI_DEVICE_Delete
    197              //
    198              // Delete the memory device object
    199              //
    200              GUI_ALLOC_Free(hMemDev);
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       GUI_ALLOC_Free
    201              GUI_UNLOCK();
   \   00000054   ........           BL       GUI_Unlock
    202            }
    203          }
   \                     ??GUI_MEMDEV_Delete_0:
   \   00000058   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000005C   3080BDE8           POP      {R4,R5,PC}       ;; return
    204          
    205          /*********************************************************************
    206          *
    207          *       GUI_MEMDEV_CreateEx
    208          */

   \                                 In section .text, align 4, keep-with-next
    209          GUI_MEMDEV_Handle GUI_MEMDEV_CreateEx(int x0, int y0, int xSize, int ySize, int Flags) {
   \                     GUI_MEMDEV_CreateEx:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   0370A0E1           MOV      R7,R3
   \   00000018   30809DE5           LDR      R8,[SP, #+48]
    210            GUI_DEVICE * pDevice;
    211            GUI_MEMDEV_Handle hMemDev = 0;
   \   0000001C   0090A0E3           MOV      R9,#+0
    212            const GUI_DEVICE_API * pDeviceMemdev;
    213          
    214            GUI_LOCK();
   \   00000020   ........           BL       GUI_Lock
    215            //
    216            // Check if there is a memory device in the device chain
    217            //
    218            pDevice = GUI_Context.apDevice[GUI_Context.SelLayer];
   \   00000024   ........           LDR      R1,??DataTable5
   \   00000028   1100D1E5           LDRB     R0,[R1, #+17]
   \   0000002C   001181E0           ADD      R1,R1,R0, LSL #+2
   \   00000030   48A091E5           LDR      R10,[R1, #+72]
    219            do {
    220              if (pDevice->pDeviceAPI->DeviceClassIndex == DEVICE_CLASS_MEMDEV) {
   \                     ??GUI_MEMDEV_CreateEx_0:
   \   00000034   0C109AE5           LDR      R1,[R10, #+12]
   \   00000038   001091E5           LDR      R1,[R1, #+0]
   \   0000003C   040051E3           CMP      R1,#+4
   \   00000040   0300000A           BEQ      ??GUI_MEMDEV_CreateEx_1
    221                break; // Found memory device, so stop here
    222              }
    223              pDevice = pDevice->pNext;
   \   00000044   00A09AE5           LDR      R10,[R10, #+0]
    224            } while (pDevice);
   \   00000048   00005AE3           CMP      R10,#+0
   \   0000004C   F8FFFF1A           BNE      ??GUI_MEMDEV_CreateEx_0
   \   00000050   010000EA           B        ??GUI_MEMDEV_CreateEx_2
    225            //
    226            // If no memory device has been found, create a device compatible to the display
    227            //
    228            if (pDevice == NULL) {
   \                     ??GUI_MEMDEV_CreateEx_1:
   \   00000054   00005AE3           CMP      R10,#+0
   \   00000058   0100001A           BNE      ??GUI_MEMDEV_CreateEx_3
    229              pDevice = GUI_DEVICE__GetpDriver(GUI_Context.SelLayer);
   \                     ??GUI_MEMDEV_CreateEx_2:
   \   0000005C   ........           BL       GUI_DEVICE__GetpDriver
   \   00000060   00A0A0E1           MOV      R10,R0
    230            }
    231            //
    232            // Use device data for creating a compatible device
    233            //
    234            pDeviceMemdev = (const GUI_DEVICE_API *)pDevice->pDeviceAPI->pfGetDevData(pDevice, LCD_DEVDATA_MEMDEV);
   \                     ??GUI_MEMDEV_CreateEx_3:
   \   00000064   0C209AE5           LDR      R2,[R10, #+12]
   \   00000068   0110A0E3           MOV      R1,#+1
   \   0000006C   0A00A0E1           MOV      R0,R10
   \   00000070   2C2092E5           LDR      R2,[R2, #+44]
   \   00000074   32FF2FE1           BLX      R2
    235            if (pDeviceMemdev) {
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   0900000A           BEQ      ??GUI_MEMDEV_CreateEx_4
    236              hMemDev = GUI_MEMDEV__CreateFixed(x0, y0, xSize, ySize, Flags, pDeviceMemdev, pDevice->pColorConvAPI);
   \   00000080   10109AE5           LDR      R1,[R10, #+16]
   \   00000084   04008DE5           STR      R0,[SP, #+4]
   \   00000088   08108DE5           STR      R1,[SP, #+8]
   \   0000008C   00808DE5           STR      R8,[SP, #+0]
   \   00000090   0730A0E1           MOV      R3,R7
   \   00000094   0620A0E1           MOV      R2,R6
   \   00000098   0510A0E1           MOV      R1,R5
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   ........           BL       GUI_MEMDEV__CreateFixed
   \   000000A4   0090A0E1           MOV      R9,R0
    237            }
    238            GUI_UNLOCK();
   \                     ??GUI_MEMDEV_CreateEx_4:
   \   000000A8   ........           BL       GUI_Unlock
    239            return hMemDev;
   \   000000AC   0900A0E1           MOV      R0,R9
   \   000000B0   10D08DE2           ADD      SP,SP,#+16
   \   000000B4   F087BDE8           POP      {R4-R10,PC}      ;; return
    240          }
    241          
    242          /*********************************************************************
    243          *
    244          *       GUI_MEMDEV_Create
    245          */

   \                                 In section .text, align 4, keep-with-next
    246          GUI_MEMDEV_Handle GUI_MEMDEV_Create(int x0, int y0, int xSize, int ySize) {
   \                     GUI_MEMDEV_Create:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   0370A0E1           MOV      R7,R3
    247            return GUI_MEMDEV_CreateEx(x0, y0, xSize, ySize, GUI_MEMDEV_HASTRANS);
   \   00000018   0080A0E3           MOV      R8,#+0
   \   0000001C   ........           BL       GUI_Lock
   \   00000020   ........           LDR      R1,??DataTable5
   \   00000024   1100D1E5           LDRB     R0,[R1, #+17]
   \   00000028   001181E0           ADD      R1,R1,R0, LSL #+2
   \   0000002C   489091E5           LDR      R9,[R1, #+72]
   \                     ??GUI_MEMDEV_Create_0:
   \   00000030   0C1099E5           LDR      R1,[R9, #+12]
   \   00000034   001091E5           LDR      R1,[R1, #+0]
   \   00000038   040051E3           CMP      R1,#+4
   \   0000003C   0300000A           BEQ      ??GUI_MEMDEV_Create_1
   \   00000040   009099E5           LDR      R9,[R9, #+0]
   \   00000044   000059E3           CMP      R9,#+0
   \   00000048   F8FFFF1A           BNE      ??GUI_MEMDEV_Create_0
   \   0000004C   010000EA           B        ??GUI_MEMDEV_Create_2
   \                     ??GUI_MEMDEV_Create_1:
   \   00000050   000059E3           CMP      R9,#+0
   \   00000054   0100001A           BNE      ??GUI_MEMDEV_Create_3
   \                     ??GUI_MEMDEV_Create_2:
   \   00000058   ........           BL       GUI_DEVICE__GetpDriver
   \   0000005C   0090A0E1           MOV      R9,R0
   \                     ??GUI_MEMDEV_Create_3:
   \   00000060   0C2099E5           LDR      R2,[R9, #+12]
   \   00000064   0110A0E3           MOV      R1,#+1
   \   00000068   0900A0E1           MOV      R0,R9
   \   0000006C   2C2092E5           LDR      R2,[R2, #+44]
   \   00000070   32FF2FE1           BLX      R2
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   0900000A           BEQ      ??GUI_MEMDEV_Create_4
   \   0000007C   101099E5           LDR      R1,[R9, #+16]
   \   00000080   04008DE5           STR      R0,[SP, #+4]
   \   00000084   08108DE5           STR      R1,[SP, #+8]
   \   00000088   00808DE5           STR      R8,[SP, #+0]
   \   0000008C   0730A0E1           MOV      R3,R7
   \   00000090   0620A0E1           MOV      R2,R6
   \   00000094   0510A0E1           MOV      R1,R5
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   ........           BL       GUI_MEMDEV__CreateFixed
   \   000000A0   0080A0E1           MOV      R8,R0
   \                     ??GUI_MEMDEV_Create_4:
   \   000000A4   ........           BL       GUI_Unlock
   \   000000A8   0800A0E1           MOV      R0,R8
   \   000000AC   0CD08DE2           ADD      SP,SP,#+12
   \   000000B0   F083BDE8           POP      {R4-R9,PC}       ;; return
    248          }
    249          
    250          /*********************************************************************
    251          *
    252          *       GUI_MEMDEV_Select
    253          */

   \                                 In section .text, align 4, keep-with-next
    254          GUI_MEMDEV_Handle GUI_MEMDEV_Select(GUI_MEMDEV_Handle hMemDev) {
   \                     GUI_MEMDEV_Select:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
    255            GUI_MEMDEV * pMemDev;
    256            GUI_MEMDEV_Handle r;
    257          
    258            GUI_LOCK();
   \   0000000C   ........           BL       GUI_Lock
    259            r = GUI_Context.hDevData;
   \   00000010   ........           LDR      R5,??DataTable5
    260            if (hMemDev == 0) {
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   886095E5           LDR      R6,[R5, #+136]
   \   0000001C   0100001A           BNE      ??GUI_MEMDEV_Select_0
    261              GUI_SelectLCD();
   \   00000020   ........           BL       GUI_SelectLCD
   \   00000024   120000EA           B        ??GUI_MEMDEV_Select_1
    262            } else {
    263              if (r) {
   \                     ??GUI_MEMDEV_Select_0:
   \   00000028   000056E3           CMP      R6,#+0
   \   0000002C   0000000A           BEQ      ??GUI_MEMDEV_Select_2
    264                GUI_SelectLCD();
   \   00000030   ........           BL       GUI_SelectLCD
    265              }
    266              pMemDev = GUI_MEMDEV_H2P(hMemDev);
   \                     ??GUI_MEMDEV_Select_2:
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       GUI_ALLOC_h2p
   \   0000003C   0070A0E1           MOV      R7,R0
    267              #if GUI_WINSUPPORT
    268                WM_Deactivate();
   \   00000040   ........           BL       WM_Deactivate
    269              #endif
    270              //
    271              // If LCD was selected save cliprect
    272              //
    273              if (GUI_Context.hDevData == 0) {
   \   00000044   880095E5           LDR      R0,[R5, #+136]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0300001A           BNE      ??GUI_MEMDEV_Select_3
    274                GUI_Context.ClipRectPrev = GUI_Context.ClipRect;
   \   00000050   080095E5           LDR      R0,[R5, #+8]
   \   00000054   0C1095E5           LDR      R1,[R5, #+12]
   \   00000058   8C0085E5           STR      R0,[R5, #+140]
   \   0000005C   901085E5           STR      R1,[R5, #+144]
    275              }
    276              GUI_Context.hDevData = hMemDev;
   \                     ??GUI_MEMDEV_Select_3:
   \   00000060   884085E5           STR      R4,[R5, #+136]
    277              GUI_DEVICE_Link(pMemDev->pDevice);
   \   00000064   000097E5           LDR      R0,[R7, #+0]
   \   00000068   ........           BL       GUI_DEVICE_Link
    278              LCD_UpdateColorIndices();
   \   0000006C   ........           BL       LCD_UpdateColorIndices
    279              LCD_SetClipRectMax();
   \   00000070   ........           BL       LCD_SetClipRectMax
    280            }
    281            GUI_UNLOCK();
   \                     ??GUI_MEMDEV_Select_1:
   \   00000074   ........           BL       GUI_Unlock
    282            return r;
   \   00000078   0600A0E1           MOV      R0,R6
   \   0000007C   04D08DE2           ADD      SP,SP,#+4
   \   00000080   F080BDE8           POP      {R4-R7,PC}       ;; return
    283          }
    284          
    285          /*********************************************************************
    286          *
    287          *       GUI_MEMDEV_CopyToLCDAt
    288          */

   \                                 In section .text, align 4, keep-with-next
    289          void GUI_MEMDEV_CopyToLCDAt(GUI_MEMDEV_Handle hMem, int x, int y) {
   \                     GUI_MEMDEV_CopyToLCDAt:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0070A0E1           MOV      R7,R0
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   0180A0E1           MOV      R8,R1
   \   00000010   0290A0E1           MOV      R9,R2
    290            if (hMem) {
   \   00000014   000057E3           CMP      R7,#+0
   \   00000018   4800000A           BEQ      ??GUI_MEMDEV_CopyToLCDAt_0
    291              GUI_DRAWMODE DrawModeOld;
    292              GUI_MEMDEV_Handle hMemPrev;
    293              GUI_MEMDEV* pDevData;
    294            #if (GUI_WINSUPPORT)
    295              GUI_RECT r;
    296            #endif
    297            #if GUI_NUM_LAYERS > 1
    298              int PrevLayer;
    299            #endif
    300              GUI_LOCK();
   \   0000001C   ........           BL       GUI_Lock
    301              DrawModeOld = GUI_SetDrawMode(GUI_DM_NORMAL);
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   ........           BL       GUI_SetDrawMode
    302              hMemPrev = GUI_Context.hDevData;
   \   00000028   ........           LDR      R5,??DataTable5
   \   0000002C   0040A0E1           MOV      R4,R0
   \   00000030   886095E5           LDR      R6,[R5, #+136]
    303              pDevData = (GUI_MEMDEV*) GUI_ALLOC_h2p(hMem);  // Convert to pointer
   \   00000034   0700A0E1           MOV      R0,R7
   \   00000038   ........           BL       GUI_ALLOC_h2p
   \   0000003C   00A0A0E1           MOV      R10,R0
    304              //
    305              // Make sure LCD is selected as device
    306              //
    307            #if GUI_NUM_LAYERS > 1
    308              PrevLayer = GUI_SelectLayer(pDevData->pDevice->LayerIndex);
   \   00000040   00009AE5           LDR      R0,[R10, #+0]
   \   00000044   180090E5           LDR      R0,[R0, #+24]
   \   00000048   ........           BL       GUI_SelectLayer
   \   0000004C   00B0A0E1           MOV      R11,R0
    309            #else
    310              GUI_SelectLCD();  // Activate LCD
    311            #endif
    312              if (x == GUI_POS_AUTO) {
   \   00000050   FE00E0E3           MVN      R0,#+254
   \   00000054   F00EC0E3           BIC      R0,R0,#0xF00
   \   00000058   000058E1           CMP      R8,R0
    313                x = pDevData->x0;
   \   0000005C   F480DA01           LDRSHEQ  R8,[R10, #+4]
    314                y = pDevData->y0;
   \   00000060   F690DA01           LDRSHEQ  R9,[R10, #+6]
    315              }
    316            #if (GUI_WINSUPPORT)
    317              //
    318              // Calculate rectangle
    319              //
    320              r.x1 = (r.x0 = x) + pDevData->XSize-1;
   \   00000064   B080CDE1           STRH     R8,[SP, #+0]
   \   00000068   F000DDE1           LDRSH    R0,[SP, #+0]
   \   0000006C   F810DAE1           LDRSH    R1,[R10, #+8]
    321              r.y1 = (r.y0 = y) + pDevData->YSize-1;;
   \   00000070   B290CDE1           STRH     R9,[SP, #+2]
   \   00000074   000081E0           ADD      R0,R1,R0
   \   00000078   010040E2           SUB      R0,R0,#+1
   \   0000007C   B400CDE1           STRH     R0,[SP, #+4]
   \   00000080   F200DDE1           LDRSH    R0,[SP, #+2]
   \   00000084   FA10DAE1           LDRSH    R1,[R10, #+10]
   \   00000088   000081E0           ADD      R0,R1,R0
   \   0000008C   010040E2           SUB      R0,R0,#+1
   \   00000090   B600CDE1           STRH     R0,[SP, #+6]
    322              //
    323              // Do the drawing. Window manager has to be on
    324              //
    325              WM_Activate();
   \   00000094   ........           BL       WM_Activate
    326              WM_ITERATE_START(&r) {
   \   00000098   0D00A0E1           MOV      R0,SP
   \   0000009C   ........           BL       WM__InitIVRSearch
   \   000000A0   000050E3           CMP      R0,#+0
   \   000000A4   0600000A           BEQ      ??GUI_MEMDEV_CopyToLCDAt_1
    327            #endif
    328              GUI_MEMDEV__WriteToActiveOpaque(hMem, x, y);
   \                     ??GUI_MEMDEV_CopyToLCDAt_2:
   \   000000A8   0920A0E1           MOV      R2,R9
   \   000000AC   0810A0E1           MOV      R1,R8
   \   000000B0   0700A0E1           MOV      R0,R7
   \   000000B4   ........           BL       GUI_MEMDEV__WriteToActiveOpaque
    329              //GUI_MEMDEV__WriteToActiveAt(hMem, x, y);
    330            #if (GUI_WINSUPPORT)
    331              } WM_ITERATE_END();
   \   000000B8   ........           BL       WM__GetNextIVR
   \   000000BC   000050E3           CMP      R0,#+0
   \   000000C0   F8FFFF1A           BNE      ??GUI_MEMDEV_CopyToLCDAt_2
    332            #endif
    333            #if GUI_NUM_LAYERS > 1
    334              GUI_SelectLayer(PrevLayer);
   \                     ??GUI_MEMDEV_CopyToLCDAt_1:
   \   000000C4   0B00A0E1           MOV      R0,R11
   \   000000C8   ........           BL       GUI_SelectLayer
    335            #endif
    336              //
    337              // Reactivate previously used device
    338              //
    339              GUI_MEMDEV_Select(hMemPrev);
   \   000000CC   ........           BL       GUI_Lock
   \   000000D0   000056E3           CMP      R6,#+0
   \   000000D4   1400000A           BEQ      ??GUI_MEMDEV_CopyToLCDAt_3
   \   000000D8   880095E5           LDR      R0,[R5, #+136]
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   0000000A           BEQ      ??GUI_MEMDEV_CopyToLCDAt_4
   \   000000E4   ........           BL       GUI_SelectLCD
   \                     ??GUI_MEMDEV_CopyToLCDAt_4:
   \   000000E8   0600A0E1           MOV      R0,R6
   \   000000EC   ........           BL       GUI_ALLOC_h2p
   \   000000F0   0070A0E1           MOV      R7,R0
   \   000000F4   ........           BL       WM_Deactivate
   \   000000F8   880095E5           LDR      R0,[R5, #+136]
   \   000000FC   000050E3           CMP      R0,#+0
   \   00000100   0300001A           BNE      ??GUI_MEMDEV_CopyToLCDAt_5
   \   00000104   080095E5           LDR      R0,[R5, #+8]
   \   00000108   0C1095E5           LDR      R1,[R5, #+12]
   \   0000010C   8C0085E5           STR      R0,[R5, #+140]
   \   00000110   901085E5           STR      R1,[R5, #+144]
   \                     ??GUI_MEMDEV_CopyToLCDAt_5:
   \   00000114   886085E5           STR      R6,[R5, #+136]
   \   00000118   000097E5           LDR      R0,[R7, #+0]
   \   0000011C   ........           BL       GUI_DEVICE_Link
   \   00000120   ........           BL       LCD_UpdateColorIndices
   \   00000124   ........           BL       LCD_SetClipRectMax
   \   00000128   000000EA           B        ??GUI_MEMDEV_CopyToLCDAt_6
   \                     ??GUI_MEMDEV_CopyToLCDAt_3:
   \   0000012C   ........           BL       GUI_SelectLCD
   \                     ??GUI_MEMDEV_CopyToLCDAt_6:
   \   00000130   ........           BL       GUI_Unlock
    340              GUI_SetDrawMode(DrawModeOld);
   \   00000134   0400A0E1           MOV      R0,R4
   \   00000138   ........           BL       GUI_SetDrawMode
    341              GUI_UNLOCK();
   \   0000013C   ........           BL       GUI_Unlock
    342            }
    343          }
   \                     ??GUI_MEMDEV_CopyToLCDAt_0:
   \   00000140   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000144   F08FBDE8           POP      {R4-R11,PC}      ;; return
    344          
    345          /*********************************************************************
    346          *
    347          *       GUI_MEMDEV_CopyToLCD
    348          */

   \                                 In section .text, align 4, keep-with-next
    349          void GUI_MEMDEV_CopyToLCD(GUI_MEMDEV_Handle hMem) {
    350            GUI_MEMDEV_CopyToLCDAt(hMem, GUI_POS_AUTO, GUI_POS_AUTO);
   \                     GUI_MEMDEV_CopyToLCD:
   \   00000000   FE20E0E3           MVN      R2,#+254
   \   00000004   F02EC2E3           BIC      R2,R2,#0xF00
   \   00000008   0210A0E1           MOV      R1,R2
   \   0000000C   ........           B        GUI_MEMDEV_CopyToLCDAt  ;; tailcall
    351          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     GUI_Context
    352          
    353          #else
    354          
    355          void GUIDEV_C(void);
    356          void GUIDEV_C(void) {}
    357          
    358          #endif /* GUI_SUPPORT_MEMDEV */
    359          
    360          /*************************** end of file ****************************/

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     GUI_MEMDEV_CopyToLCD             8
     GUI_MEMDEV_CopyToLCDAt          48
     GUI_MEMDEV_Create               40
     GUI_MEMDEV_CreateEx             48
     GUI_MEMDEV_Delete               16
     GUI_MEMDEV_GetBitsPerPixel      16
     GUI_MEMDEV_Select               24
     GUI_MEMDEV__CreateFixed         48
     GUI_MEMDEV__WriteToActiveAt     16


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     GUI_MEMDEV__WriteToActiveAt   76
     GUI_MEMDEV__CreateFixed      356
     GUI_MEMDEV_GetBitsPerPixel    72
     GUI_MEMDEV_Delete             96
     GUI_MEMDEV_CreateEx          184
     GUI_MEMDEV_Create            180
     GUI_MEMDEV_Select            132
     GUI_MEMDEV_CopyToLCDAt       328
     GUI_MEMDEV_CopyToLCD          16
     ??DataTable5                   4

 
 1 444 bytes in section .text
 
 1 444 bytes of CODE memory

Errors: none
Warnings: none
