###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:09:47 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_8.c                      #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_8.c -D DEBUG=1 -D        #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUIDRV_Lin_8.lst           #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUIDRV_Lin_8.o              #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDRV_Lin_8.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDRV_Lin_8.c
     19          Purpose     : Driver for accessing linear video memory
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stddef.h>
     24          
     25          #include "LCD_Private.h"
     26          #include "GUI_Private.h"
     27          #include "LCD_SIM.h"
     28          #include "LCD_ConfDefaults.h"
     29          
     30          #include "GUIDRV_Lin.h"
     31          
     32          #if (!defined(WIN32) | defined(LCD_SIMCONTROLLER))
     33          
     34          /*********************************************************************
     35          *
     36          *       Defines
     37          *
     38          **********************************************************************
     39          */
     40          #ifdef WIN32
     41            //
     42            // Simulation prototypes
     43            //
     44            U16  SIM_Lin_ReadMem16  (unsigned int Off);
     45            U32  SIM_Lin_ReadMem32  (unsigned int Off);
     46            U32  SIM_Lin_ReadMem32p (U32 * p);
     47            void SIM_Lin_WriteMem16 (unsigned int Off, U16 Data);
     48            void SIM_Lin_WriteMem32 (unsigned int Off, U32 Data);
     49            void SIM_Lin_WriteMem16p(U16 * p, U16 Data);
     50            void SIM_Lin_WriteMem32p(U32 * p, U32 Data);
     51            void SIM_Lin_memcpy     (void * pDst, const void * pSrc, int Len);
     52            void SIM_Lin_SetVRAMAddr(int LayerIndex, void * pVRAM);
     53            void SIM_Lin_SetVRAMSize(int LayerIndex, int xSize, int ySize);
     54            //
     55            // Access macro definition for internal simulation
     56            //
     57            #define LCD_READ_MEM16(VRAMAddr, Off)        SIM_Lin_ReadMem16(Off)
     58            #define LCD_READ_MEM32(VRAMAddr, Off)        SIM_Lin_ReadMem32(Off)
     59            #define LCD_READ_MEM32P(p)                   SIM_Lin_ReadMem32p(p)
     60            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) SIM_Lin_WriteMem16(Off, Data)
     61            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) SIM_Lin_WriteMem32(Off, Data)
     62            #define LCD_WRITE_MEM16P(p, Data)            SIM_Lin_WriteMem16p(p, Data)
     63            #define LCD_WRITE_MEM32P(p, Data)            SIM_Lin_WriteMem32p(p, Data)
     64            #undef  GUI_MEMCPY
     65            #define GUI_MEMCPY(pDst, pSrc, Len) SIM_Lin_memcpy(pDst, pSrc, Len)
     66          #else
     67            //
     68            // Access macro definition for hardware
     69            //
     70            #define LCD_READ_MEM16(VRAMAddr, Off)        (*((U16 *)VRAMAddr + (U32)Off))
     71            #define LCD_READ_MEM32(VRAMAddr, Off)        (*((U32 *)VRAMAddr + (U32)Off))
     72            #define LCD_READ_MEM32P(p)                   (*((U32 *)p))
     73            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) *((U16 *)VRAMAddr + (U32)Off) = Data
     74            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) *((U32 *)VRAMAddr + (U32)Off) = Data
     75            #define LCD_WRITE_MEM16P(p, Data)            *((U16 *)p) = Data
     76            #define LCD_WRITE_MEM32P(p, Data)            *((U32 *)p) = Data
     77          #endif
     78          
     79          #define WRITE_MEM16(VRAMAddr, Off, Data) LCD_WRITE_MEM16(VRAMAddr, Off, Data)
     80          #define WRITE_MEM32(VRAMAddr, Off, Data) LCD_WRITE_MEM32(VRAMAddr, Off, Data)
     81          #define READ_MEM16(VRAMAddr, Off)        LCD_READ_MEM16(VRAMAddr, Off)
     82          #define READ_MEM32(VRAMAddr, Off)        LCD_READ_MEM32(VRAMAddr, Off)
     83          #define READ_MEM32P(p)                   LCD_READ_MEM32P(p)
     84          #define WRITE_MEM16P(p, Data)            LCD_WRITE_MEM16P(p, Data)
     85          #define WRITE_MEM32P(p, Data)            LCD_WRITE_MEM32P(p, Data)
     86          
     87          #define OFF2PTR16(VRAMAddr, Off)     (U16 *)((U8 *)VRAMAddr + (Off << 1))
     88          #define OFF2PTR32(VRAMAddr, Off)     (U32 *)((U8 *)VRAMAddr + (Off << 2))
     89          
     90          #define XY2OFF16(vxSizePhys, x, y)    ((U32)y * (vxSizePhys >> 1) + ((U32)x >> 1))
     91          #define XY2OFF32(vxSizePhys, x, y)    ((U32)y * (vxSizePhys >> 2) + ((U32)x >> 2))
     92          
     93          #define MIRROR(x) x = ((x & 0x000000ff) << 24) \
     94                              | ((x & 0x0000ff00) <<  8) \
     95                              | ((x & 0x00ff0000) >>  8) \
     96                              | ((x & 0xff000000) >> 24)
     97          
     98          /*********************************************************************
     99          *
    100          *       Types
    101          *
    102          **********************************************************************
    103          */
    104          typedef struct {
    105            U32 VRAMAddr;
    106            int xSize, ySize;
    107            int vxSize, vySize;
    108            int vxSizePhys;
    109            int xPos, yPos;
    110            int Alpha;
    111            int IsVisible;
    112            void (* pfFillRect)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex);
    113            LCD_COLOR aColor[256];
    114          } DRIVER_CONTEXT;
    115          
    116          /*********************************************************************
    117          *
    118          *       Static functions
    119          *
    120          **********************************************************************
    121          */
    122          /*********************************************************************
    123          *
    124          *       _SetPixelIndex
    125          *
    126          * Purpose:
    127          *   Sets the index of the given pixel. The upper layers
    128          *   calling this routine make sure that the coordinates are in range, so
    129          *   that no check on the parameters needs to be performed.
    130          */

   \                                 In section .text, align 4, keep-with-next
    131          static void _SetPixelIndex(GUI_DEVICE * pDevice, int x, int y, int PixelIndex) {
   \                     _SetPixelIndex:
   \   00000000   00402DE9           PUSH     {LR}
    132            DRIVER_CONTEXT * pContext;
    133            U32 Off;
    134            U16 Data;
    135            int Shift;
    136          
    137            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000004   080090E5           LDR      R0,[R0, #+8]
    138            Off      = XY2OFF16(pContext->vxSizePhys, x, y);
    139            Data     = READ_MEM16(pContext->VRAMAddr, Off);
    140            Shift    = ((x & 1) ^ LCD_ENDIAN_BIG) << 3;
    141            Data    &= ~(0xFF << Shift);
    142            Data    |= PixelIndex << Shift;
    143            WRITE_MEM16(pContext->VRAMAddr, Off, Data);
   \   00000008   FFE0A0E3           MOV      LR,#+255
   \   0000000C   14C090E5           LDR      R12,[R0, #+20]
   \   00000010   000090E5           LDR      R0,[R0, #+0]
   \   00000014   CCC0A0E1           ASR      R12,R12,#+1
   \   00000018   9C0202E0           MUL      R2,R12,R2
   \   0000001C   A12082E0           ADD      R2,R2,R1, LSR #+1
   \   00000020   8220A0E1           LSL      R2,R2,#+1
   \   00000024   011001E2           AND      R1,R1,#0x1
   \   00000028   B0C092E1           LDRH     R12,[R2, +R0]
   \   0000002C   8111A0E1           LSL      R1,R1,#+3
   \   00000030   1EE1A0E1           LSL      LR,LR,R1
   \   00000034   0EC0CCE1           BIC      R12,R12,LR
   \   00000038   13118CE1           ORR      R1,R12,R3, LSL R1
   \   0000003C   B01082E1           STRH     R1,[R2, +R0]
    144          }
   \   00000040   0080BDE8           POP      {PC}             ;; return
    145          
    146          /*********************************************************************
    147          *
    148          *       _GetPixelIndex
    149          *
    150          * Purpose:
    151          *   Returns the index of the given pixel. The upper layers
    152          *   calling this routine make sure that the coordinates are in range, so
    153          *   that no check on the parameters needs to be performed.
    154          */

   \                                 In section .text, align 4, keep-with-next
    155          static unsigned int _GetPixelIndex(GUI_DEVICE * pDevice, int x, int y) {
    156            DRIVER_CONTEXT * pContext;
    157            U32 Off;
    158            U16 Data;
    159            int Shift;
    160            LCD_PIXELINDEX PixelIndex;
    161          
    162            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetPixelIndex:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    163            Off      = XY2OFF16(pContext->vxSizePhys, x, y);
    164            Data     = READ_MEM16(pContext->VRAMAddr, Off);
    165            Shift    = ((x & 1) ^ LCD_ENDIAN_BIG) << 3;
   \   00000004   013001E2           AND      R3,R1,#0x1
    166            PixelIndex = (Data & (0xFF << Shift)) >> Shift;
    167            return PixelIndex;
   \   00000008   14C090E5           LDR      R12,[R0, #+20]
   \   0000000C   000090E5           LDR      R0,[R0, #+0]
   \   00000010   CCC0A0E1           ASR      R12,R12,#+1
   \   00000014   9C0202E0           MUL      R2,R12,R2
   \   00000018   8331A0E1           LSL      R3,R3,#+3
   \   0000001C   A11082E0           ADD      R1,R2,R1, LSR #+1
   \   00000020   810080E0           ADD      R0,R0,R1, LSL #+1
   \   00000024   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000028   FF10A0E3           MOV      R1,#+255
   \   0000002C   110300E0           AND      R0,R0,R1, LSL R3
   \   00000030   5003A0E1           ASR      R0,R0,R3
   \   00000034   1EFF2FE1           BX       LR               ;; return
    168          }
    169          
    170          /*********************************************************************
    171          *
    172          *       _XorPixel
    173          */

   \                                 In section .text, align 4, keep-with-next
    174          static void _XorPixel(GUI_DEVICE * pDevice, int x, int y) {
   \                     _XorPixel:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0080A0E1           MOV      R8,R0
   \   00000008   0240A0E1           MOV      R4,R2
    175            LCD_PIXELINDEX PixelIndex;
    176            LCD_PIXELINDEX IndexMask;
    177            
    178            PixelIndex = _GetPixelIndex(pDevice, x, y);
   \   0000000C   080098E5           LDR      R0,[R8, #+8]
   \   00000010   012001E2           AND      R2,R1,#0x1
   \   00000014   A190A0E1           LSR      R9,R1,#+1
   \   00000018   8251A0E1           LSL      R5,R2,#+3
   \   0000001C   141090E5           LDR      R1,[R0, #+20]
   \   00000020   FF20A0E3           MOV      R2,#+255
   \   00000024   1265A0E1           LSL      R6,R2,R5
   \   00000028   C110A0E1           ASR      R1,R1,#+1
   \   0000002C   919422E0           MLA      R2,R1,R4,R9
   \   00000030   000090E5           LDR      R0,[R0, #+0]
   \   00000034   04D04DE2           SUB      SP,SP,#+4
   \   00000038   820080E0           ADD      R0,R0,R2, LSL #+1
   \   0000003C   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000040   000006E0           AND      R0,R6,R0
   \   00000044   5075A0E1           ASR      R7,R0,R5
    179            IndexMask  = pDevice->pColorConvAPI->pfGetIndexMask();
   \   00000048   100098E5           LDR      R0,[R8, #+16]
   \   0000004C   080090E5           LDR      R0,[R0, #+8]
   \   00000050   30FF2FE1           BLX      R0
    180            _SetPixelIndex(pDevice, x, y, PixelIndex ^ IndexMask);
   \   00000054   081098E5           LDR      R1,[R8, #+8]
   \   00000058   070020E0           EOR      R0,R0,R7
   \   0000005C   142091E5           LDR      R2,[R1, #+20]
   \   00000060   001091E5           LDR      R1,[R1, #+0]
   \   00000064   C230A0E1           ASR      R3,R2,#+1
   \   00000068   939422E0           MLA      R2,R3,R4,R9
    181          }
   \   0000006C   04D08DE2           ADD      SP,SP,#+4
   \   00000070   8220A0E1           LSL      R2,R2,#+1
   \   00000074   B13092E1           LDRH     R3,[R2, +R1]
   \   00000078   0630C3E1           BIC      R3,R3,R6
   \   0000007C   100583E1           ORR      R0,R3,R0, LSL R5
   \   00000080   B10082E1           STRH     R0,[R2, +R1]
   \   00000084   F083BDE8           POP      {R4-R9,PC}       ;; return
    182          
    183          /*********************************************************************
    184          *
    185          *       _DrawHLine
    186          */

   \                                 In section .text, align 4, keep-with-next
    187          static void _DrawHLine(GUI_DEVICE * pDevice, int x0, int y,  int x1) {
   \                     _DrawHLine:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    188            DRIVER_CONTEXT * pContext;
    189            int Off, NumPixel_0, NumPixel_1, RemPixels;
    190            U32 Data, ColorMask, AndMask;
    191            LCD_PIXELINDEX ColorIndex;
    192          
    193            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable14
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0150A0E1           MOV      R5,R1
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   0370A0E1           MOV      R7,R3
   \   00000020   010010E3           TST      R0,#0x1
   \   00000024   2100000A           BEQ      ??_DrawHLine_0
   \   00000028   050057E1           CMP      R7,R5
   \   0000002C   590000BA           BLT      ??_DrawHLine_1
    194              for (; x0 <= x1; x0++) {
    195                _XorPixel(pDevice, x0, y);
   \                     ??_DrawHLine_2:
   \   00000030   011005E2           AND      R1,R5,#0x1
   \   00000034   8181A0E1           LSL      R8,R1,#+3
   \   00000038   080094E5           LDR      R0,[R4, #+8]
   \   0000003C   FF10A0E3           MOV      R1,#+255
   \   00000040   1198A0E1           LSL      R9,R1,R8
   \   00000044   141090E5           LDR      R1,[R0, #+20]
   \   00000048   A5A0A0E1           LSR      R10,R5,#+1
   \   0000004C   C110A0E1           ASR      R1,R1,#+1
   \   00000050   91A622E0           MLA      R2,R1,R6,R10
   \   00000054   000090E5           LDR      R0,[R0, #+0]
   \   00000058   820080E0           ADD      R0,R0,R2, LSL #+1
   \   0000005C   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000060   000009E0           AND      R0,R9,R0
   \   00000064   50B8A0E1           ASR      R11,R0,R8
   \   00000068   100094E5           LDR      R0,[R4, #+16]
   \   0000006C   080090E5           LDR      R0,[R0, #+8]
   \   00000070   30FF2FE1           BLX      R0
   \   00000074   081094E5           LDR      R1,[R4, #+8]
   \   00000078   0B0020E0           EOR      R0,R0,R11
   \   0000007C   142091E5           LDR      R2,[R1, #+20]
   \   00000080   001091E5           LDR      R1,[R1, #+0]
   \   00000084   C230A0E1           ASR      R3,R2,#+1
   \   00000088   93A622E0           MLA      R2,R3,R6,R10
    196              }
   \   0000008C   015085E2           ADD      R5,R5,#+1
   \   00000090   8220A0E1           LSL      R2,R2,#+1
   \   00000094   B13092E1           LDRH     R3,[R2, +R1]
   \   00000098   050057E1           CMP      R7,R5
   \   0000009C   0930C3E1           BIC      R3,R3,R9
   \   000000A0   100883E1           ORR      R0,R3,R0, LSL R8
   \   000000A4   B10082E1           STRH     R0,[R2, +R1]
   \   000000A8   E0FFFFAA           BGE      ??_DrawHLine_2
   \   000000AC   390000EA           B        ??_DrawHLine_1
    197            } else {
    198              ColorIndex = LCD__GetColorIndex();
   \                     ??_DrawHLine_0:
   \   000000B0   ........           LDR      R0,??DataTable14_1
    199              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    200              Off = XY2OFF32(pContext->vxSizePhys, x0, y);
    201              NumPixel_0 = x0 & 3;
   \   000000B4   03C005E2           AND      R12,R5,#0x3
   \   000000B8   000090E5           LDR      R0,[R0, #+0]
    202              NumPixel_1 = x1 & 3;
    203              RemPixels = x1 - x0 + 1;
   \   000000BC   05E047E0           SUB      LR,R7,R5
   \   000000C0   001090E5           LDR      R1,[R0, #+0]
   \   000000C4   080094E5           LDR      R0,[R4, #+8]
   \   000000C8   01E08EE2           ADD      LR,LR,#+1
   \   000000CC   142090E5           LDR      R2,[R0, #+20]
    204              //
    205              // First DWORD
    206              //
    207              if (NumPixel_0) {
   \   000000D0   00005CE3           CMP      R12,#+0
   \   000000D4   4221A0E1           ASR      R2,R2,#+2
   \   000000D8   920603E0           MUL      R3,R2,R6
   \   000000DC   252183E0           ADD      R2,R3,R5, LSR #+2
   \   000000E0   033007E2           AND      R3,R7,#0x3
   \   000000E4   1600000A           BEQ      ??_DrawHLine_3
    208                AndMask = ~(0xFFFFFFFF << (8 * NumPixel_0));
   \   000000E8   0050E0E3           MVN      R5,#+0
   \   000000EC   8C41A0E1           LSL      R4,R12,#+3
   \   000000F0   1544E0E1           MVN      R4,R5, LSL R4
    209                if ((RemPixels < 3) && (NumPixel_1)) {
   \   000000F4   03005EE3           CMP      LR,#+3
   \   000000F8   060000AA           BGE      ??_DrawHLine_4
   \   000000FC   000053E3           CMP      R3,#+0
   \   00000100   0400000A           BEQ      ??_DrawHLine_4
    210                  AndMask |= ~(0xFFFFFFFF >> (8 * (3 - NumPixel_1)));
   \   00000104   0360A0E1           MOV      R6,R3
   \   00000108   036066E2           RSB      R6,R6,#+3
   \   0000010C   8661A0E1           LSL      R6,R6,#+3
   \   00000110   3556E0E1           MVN      R5,R5, LSR R6
   \   00000114   044085E1           ORR      R4,R5,R4
    211                }
    212                ColorMask = (ColorIndex * 0x01010101) & ~AndMask;
    213                #if (LCD_ENDIAN_BIG == 1)
    214                  MIRROR(AndMask);
    215                  MIRROR(ColorMask);
    216                #endif
    217                Data = READ_MEM32(pContext->VRAMAddr, Off);
    218                Data &= AndMask;
    219                Data |= ColorMask;
    220                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_4:
   \   00000118   005090E5           LDR      R5,[R0, #+0]
   \   0000011C   ........           LDR      R7,??DataTable14_2  ;; 0x1010101
   \   00000120   026195E7           LDR      R6,[R5, +R2, LSL #+2]
   \   00000124   970108E0           MUL      R8,R7,R1
   \   00000128   066004E0           AND      R6,R4,R6
   \   0000012C   0440C8E1           BIC      R4,R8,R4
   \   00000130   064084E1           ORR      R4,R4,R6
   \   00000134   024185E7           STR      R4,[R5, +R2, LSL #+2]
    221                RemPixels -= (4 - NumPixel_0);
   \   00000138   04C04CE2           SUB      R12,R12,#+4
   \   0000013C   0EE08CE0           ADD      LR,R12,LR
    222                Off++;
   \   00000140   012082E2           ADD      R2,R2,#+1
   \                     ??_DrawHLine_3:
   \   00000144   ........           LDR      R12,??DataTable14_2  ;; 0x1010101
   \   00000148   04005EE3           CMP      LR,#+4
   \   0000014C   9C0101E0           MUL      R1,R12,R1
   \   00000150   050000BA           BLT      ??_DrawHLine_5
    223              }
    224              //
    225              // Complete DWORDS
    226              //
    227              ColorMask = ColorIndex * 0x01010101;
    228              while (RemPixels >= 4) {
    229                LCD_WRITE_MEM32(pContext->VRAMAddr, Off, ColorMask);
   \                     ??_DrawHLine_6:
   \   00000154   004090E5           LDR      R4,[R0, #+0]
    230                Off++;
    231                RemPixels -= 4;
   \   00000158   04E04EE2           SUB      LR,LR,#+4
   \   0000015C   021184E7           STR      R1,[R4, +R2, LSL #+2]
   \   00000160   012082E2           ADD      R2,R2,#+1
   \   00000164   04005EE3           CMP      LR,#+4
   \   00000168   F9FFFFAA           BGE      ??_DrawHLine_6
    232              }
    233              //
    234              // Last DWORD
    235              //
    236              if (RemPixels > 0) {
   \                     ??_DrawHLine_5:
   \   0000016C   01005EE3           CMP      LR,#+1
   \   00000170   080000BA           BLT      ??_DrawHLine_1
    237                AndMask = 0xFFFFFF00 << (8 * NumPixel_1);
   \   00000174   FFC0E0E3           MVN      R12,#+255
   \   00000178   8331A0E1           LSL      R3,R3,#+3
    238                ColorMask = (ColorIndex * 0x01010101) & ~AndMask;
    239                #if (LCD_ENDIAN_BIG == 1)
    240                  MIRROR(AndMask);
    241                  MIRROR(ColorMask);
    242                #endif
    243                Data = READ_MEM32(pContext->VRAMAddr, Off);
    244                Data &= AndMask;
    245                Data |= ColorMask;
    246                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   0000017C   000090E5           LDR      R0,[R0, #+0]
   \   00000180   1C43A0E1           LSL      R4,R12,R3
   \   00000184   023190E7           LDR      R3,[R0, +R2, LSL #+2]
   \   00000188   0410C1E1           BIC      R1,R1,R4
   \   0000018C   033004E0           AND      R3,R4,R3
   \   00000190   031081E1           ORR      R1,R1,R3
   \   00000194   021180E7           STR      R1,[R0, +R2, LSL #+2]
    247              }
    248            }
    249          }
   \                     ??_DrawHLine_1:
   \   00000198   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000019C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    250          
    251          /*********************************************************************
    252          *
    253          *       _DrawVLine, not optimized
    254          */

   \                                 In section .text, align 4, keep-with-next
    255          static void _DrawVLine  (GUI_DEVICE * pDevice, int x, int y0,  int y1) {
   \                     _DrawVLine:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    256            LCD_PIXELINDEX ColorIndex;
    257          
    258            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable14
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0360A0E1           MOV      R6,R3
   \   00000018   010010E3           TST      R0,#0x1
   \   0000001C   2100000A           BEQ      ??_DrawVLine_0
   \   00000020   050056E1           CMP      R6,R5
   \   00000024   350000BA           BLT      ??_DrawVLine_1
   \   00000028   010001E2           AND      R0,R1,#0x1
   \   0000002C   A170A0E1           LSR      R7,R1,#+1
   \   00000030   80A1A0E1           LSL      R10,R0,#+3
    259              for (; y0 <= y1; y0++) {
    260                _XorPixel(pDevice, x, y0);
   \                     ??_DrawVLine_2:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   FF10A0E3           MOV      R1,#+255
   \   0000003C   118AA0E1           LSL      R8,R1,R10
   \   00000040   141090E5           LDR      R1,[R0, #+20]
   \   00000044   000090E5           LDR      R0,[R0, #+0]
   \   00000048   C110A0E1           ASR      R1,R1,#+1
   \   0000004C   917522E0           MLA      R2,R1,R5,R7
   \   00000050   820080E0           ADD      R0,R0,R2, LSL #+1
   \   00000054   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000058   000008E0           AND      R0,R8,R0
   \   0000005C   509AA0E1           ASR      R9,R0,R10
   \   00000060   100094E5           LDR      R0,[R4, #+16]
   \   00000064   080090E5           LDR      R0,[R0, #+8]
   \   00000068   30FF2FE1           BLX      R0
   \   0000006C   082094E5           LDR      R2,[R4, #+8]
   \   00000070   090020E0           EOR      R0,R0,R9
   \   00000074   141092E5           LDR      R1,[R2, #+20]
   \   00000078   002092E5           LDR      R2,[R2, #+0]
   \   0000007C   C130A0E1           ASR      R3,R1,#+1
   \   00000080   937521E0           MLA      R1,R3,R5,R7
    261              }
   \   00000084   015085E2           ADD      R5,R5,#+1
   \   00000088   8110A0E1           LSL      R1,R1,#+1
   \   0000008C   B23091E1           LDRH     R3,[R1, +R2]
   \   00000090   050056E1           CMP      R6,R5
   \   00000094   0830C3E1           BIC      R3,R3,R8
   \   00000098   100A83E1           ORR      R0,R3,R0, LSL R10
   \   0000009C   B20081E1           STRH     R0,[R1, +R2]
   \   000000A0   E3FFFFAA           BGE      ??_DrawVLine_2
   \   000000A4   F087BDE8           POP      {R4-R10,PC}
    262            } else {
    263              ColorIndex = LCD__GetColorIndex();
   \                     ??_DrawVLine_0:
   \   000000A8   ........           LDR      R0,??DataTable14_1
   \   000000AC   050056E1           CMP      R6,R5
   \   000000B0   000090E5           LDR      R0,[R0, #+0]
   \   000000B4   000090E5           LDR      R0,[R0, #+0]
   \   000000B8   100000BA           BLT      ??_DrawVLine_1
   \   000000BC   A170A0E1           LSR      R7,R1,#+1
   \   000000C0   011001E2           AND      R1,R1,#0x1
   \   000000C4   81A1A0E1           LSL      R10,R1,#+3
    264              for (; y0 <= y1; y0++) {
    265                _SetPixelIndex(pDevice, x, y0, ColorIndex);
   \                     ??_DrawVLine_3:
   \   000000C8   082094E5           LDR      R2,[R4, #+8]
   \   000000CC   FFC0A0E3           MOV      R12,#+255
   \   000000D0   141092E5           LDR      R1,[R2, #+20]
   \   000000D4   002092E5           LDR      R2,[R2, #+0]
   \   000000D8   C130A0E1           ASR      R3,R1,#+1
   \   000000DC   937521E0           MLA      R1,R3,R5,R7
    266              }
   \   000000E0   015085E2           ADD      R5,R5,#+1
   \   000000E4   8110A0E1           LSL      R1,R1,#+1
   \   000000E8   B23091E1           LDRH     R3,[R1, +R2]
   \   000000EC   050056E1           CMP      R6,R5
   \   000000F0   1C3AC3E1           BIC      R3,R3,R12, LSL R10
   \   000000F4   103A83E1           ORR      R3,R3,R0, LSL R10
   \   000000F8   B23081E1           STRH     R3,[R1, +R2]
   \   000000FC   F1FFFFAA           BGE      ??_DrawVLine_3
    267            }
    268          }
   \                     ??_DrawVLine_1:
   \   00000100   F087BDE8           POP      {R4-R10,PC}      ;; return
    269          
    270          /*********************************************************************
    271          *
    272          *       _FillRect
    273          */

   \                                 In section .text, align 4, keep-with-next
    274          static void _FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   18809DE5           LDR      R8,[SP, #+24]
   \   00000008   0260A0E1           MOV      R6,R2
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0370A0E1           MOV      R7,R3
   \   00000018   060058E1           CMP      R8,R6
   \   0000001C   070000BA           BLT      ??_FillRect_0
    275            for (; y0 <= y1; y0++) {
    276              _DrawHLine(pDevice, x0, y0, x1);
   \                     ??_FillRect_1:
   \   00000020   0730A0E1           MOV      R3,R7
   \   00000024   0620A0E1           MOV      R2,R6
   \   00000028   0510A0E1           MOV      R1,R5
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       _DrawHLine
    277            }
   \   00000034   016086E2           ADD      R6,R6,#+1
   \   00000038   060058E1           CMP      R8,R6
   \   0000003C   F7FFFFAA           BGE      ??_FillRect_1
    278          }
   \                     ??_FillRect_0:
   \   00000040   F081BDE8           POP      {R4-R8,PC}       ;; return
    279          
    280          /*********************************************************************
    281          *
    282          *       Draw Bitmap 1 BPP
    283          */

   \                                 In section .text, align 4, keep-with-next
    284          static void _DrawBitLine1BPP(GUI_DEVICE * pDevice, unsigned x, unsigned y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine1BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0070A0E1           MOV      R7,R0
   \   0000000C   30009DE5           LDR      R0,[SP, #+48]
   \   00000010   0280A0E1           MOV      R8,R2
    285            DRIVER_CONTEXT * pContext;
    286            U8 Mode;
    287            LCD_PIXELINDEX Index0, Index1, IndexMask, ColorIndexOld;
    288          
    289            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    290            Index0 = *(pTrans + 0);
   \   00000014   00E090E5           LDR      LR,[R0, #+0]
    291            Index1 = *(pTrans + 1);
   \   00000018   042090E5           LDR      R2,[R0, #+4]
    292            x += Diff;
    293            Mode = GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR);
   \   0000001C   ........           LDR      R0,??DataTable14
   \   00000020   28509DE5           LDR      R5,[SP, #+40]
   \   00000024   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000028   0340A0E1           MOV      R4,R3
   \   0000002C   2C609DE5           LDR      R6,[SP, #+44]
   \   00000030   08C097E5           LDR      R12,[R7, #+8]
   \   00000034   019085E0           ADD      R9,R5,R1
   \   00000038   030010E2           ANDS     R0,R0,#0x3
    294            if (Mode == 0) {
   \   0000003C   7300001A           BNE      ??_DrawBitLine1BPP_0
   \   00000040   090086E0           ADD      R0,R6,R9
   \   00000044   013040E2           SUB      R3,R0,#+1
   \   00000048   02005EE1           CMP      LR,R2
   \   0000004C   0A00001A           BNE      ??_DrawBitLine1BPP_1
    295              //
    296              // Check if filling will do ...
    297              //
    298              if (Index0 == Index1) {
    299                ColorIndexOld = LCD__GetColorIndex();
   \   00000050   ........           LDR      R5,??DataTable14_1
    300                LCD__SetColorIndex(Index0);
    301                _DrawHLine(pDevice, x, y, x + xsize - 1);
   \   00000054   0820A0E1           MOV      R2,R8
   \   00000058   000095E5           LDR      R0,[R5, #+0]
   \   0000005C   0910A0E1           MOV      R1,R9
   \   00000060   004090E5           LDR      R4,[R0, #+0]
   \   00000064   00E080E5           STR      LR,[R0, #+0]
   \   00000068   0700A0E1           MOV      R0,R7
   \   0000006C   ........           BL       _DrawHLine
    302                LCD__SetColorIndex(ColorIndexOld);
   \   00000070   000095E5           LDR      R0,[R5, #+0]
   \   00000074   004080E5           STR      R4,[R0, #+0]
   \   00000078   AA0000EA           B        ??_DrawBitLine1BPP_2
    303              } else {
    304                //
    305                // O.K., we have to draw ...
    306                //
    307                int Off, NumPixel_0, NumPixel_1, i;
    308                U32 Data, ColorMask, AndMask;
    309          
    310                Off = XY2OFF32(pContext->vxSizePhys, x, y);
   \                     ??_DrawBitLine1BPP_1:
   \   0000007C   14009CE5           LDR      R0,[R12, #+20]
   \   00000080   4001A0E1           ASR      R0,R0,#+2
   \   00000084   900801E0           MUL      R1,R0,R8
    311                NumPixel_0 = x & 3;
    312                NumPixel_1 = (x + xsize - 1) & 3;
   \   00000088   038003E2           AND      R8,R3,#0x3
   \   0000008C   297181E0           ADD      R7,R1,R9, LSR #+2
   \   00000090   031009E2           AND      R1,R9,#0x3
    313                //
    314                // First DWORD
    315                //
    316                if (NumPixel_0) {
   \   00000094   000051E3           CMP      R1,#+0
   \   00000098   2700000A           BEQ      ??_DrawBitLine1BPP_3
    317                  ColorMask = 0;
   \   0000009C   0000A0E3           MOV      R0,#+0
    318                  AndMask = ~(0xFFFFFFFF << (8 * NumPixel_0));
   \   000000A0   0030E0E1           MVN      R3,R0
   \   000000A4   8191A0E1           LSL      R9,R1,#+3
   \   000000A8   1399E0E1           MVN      R9,R3, LSL R9
    319                  if ((xsize < 3) && (NumPixel_1)) {
   \   000000AC   030056E3           CMP      R6,#+3
   \   000000B0   060000AA           BGE      ??_DrawBitLine1BPP_4
   \   000000B4   000058E3           CMP      R8,#+0
   \   000000B8   0400000A           BEQ      ??_DrawBitLine1BPP_4
    320                    AndMask |= ~(0xFFFFFFFF >> (8 * (3 - NumPixel_1)));
   \   000000BC   08A0A0E1           MOV      R10,R8
   \   000000C0   03A06AE2           RSB      R10,R10,#+3
   \   000000C4   8AA1A0E1           LSL      R10,R10,#+3
   \   000000C8   333AE0E1           MVN      R3,R3, LSR R10
   \   000000CC   099083E1           ORR      R9,R3,R9
    321                  }
    322                  for (i = NumPixel_0; (i < 4) && xsize; i++, xsize--) {
   \                     ??_DrawBitLine1BPP_4:
   \   000000D0   0130A0E1           MOV      R3,R1
   \   000000D4   8010A0E3           MOV      R1,#+128
   \   000000D8   080000EA           B        ??_DrawBitLine1BPP_5
    323                    U8 Index = *p & (0x80 >> Diff) ? Index1 : Index0;
    324                    if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_6:
   \   000000DC   015085E2           ADD      R5,R5,#+1
    325                      Diff = 0;
    326                      p++;
    327                    }
    328                    ColorMask |= Index << (8 * i);
   \   000000E0   FFA00AE2           AND      R10,R10,#0xFF
   \   000000E4   83B1A0E1           LSL      R11,R3,#+3
   \   000000E8   080055E3           CMP      R5,#+8
   \   000000EC   1A0B80E1           ORR      R0,R0,R10, LSL R11
   \   000000F0   0050A003           MOVEQ    R5,#+0
   \   000000F4   01408402           ADDEQ    R4,R4,#+1
   \   000000F8   013083E2           ADD      R3,R3,#+1
   \   000000FC   016046E2           SUB      R6,R6,#+1
   \                     ??_DrawBitLine1BPP_5:
   \   00000100   040053E3           CMP      R3,#+4
   \   00000104   060000AA           BGE      ??_DrawBitLine1BPP_7
   \   00000108   000056E3           CMP      R6,#+0
   \   0000010C   0400000A           BEQ      ??_DrawBitLine1BPP_7
   \   00000110   00A0D4E5           LDRB     R10,[R4, #+0]
   \   00000114   51051AE1           TST      R10,R1, ASR R5
   \   00000118   02A0A011           MOVNE    R10,R2
   \   0000011C   0EA0A001           MOVEQ    R10,LR
   \   00000120   EDFFFFEA           B        ??_DrawBitLine1BPP_6
    329                  }
    330                  #if (LCD_ENDIAN_BIG == 1)
    331                    MIRROR(AndMask);
    332                    MIRROR(ColorMask);
    333                  #endif
    334                  Data = READ_MEM32(pContext->VRAMAddr, Off);
    335                  Data &= AndMask;
    336                  Data |= ColorMask;
    337                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_7:
   \   00000124   00109CE5           LDR      R1,[R12, #+0]
   \   00000128   073191E7           LDR      R3,[R1, +R7, LSL #+2]
   \   0000012C   033009E0           AND      R3,R9,R3
   \   00000130   030080E1           ORR      R0,R0,R3
   \   00000134   070181E7           STR      R0,[R1, +R7, LSL #+2]
    338                  Off++;
   \   00000138   017087E2           ADD      R7,R7,#+1
    339                }
    340                //
    341                // Complete DWORDS
    342                //
    343                while (xsize >= 4) {
   \                     ??_DrawBitLine1BPP_3:
   \   0000013C   040056E3           CMP      R6,#+4
   \   00000140   160000BA           BLT      ??_DrawBitLine1BPP_8
    344                  ColorMask = 0;
   \                     ??_DrawBitLine1BPP_9:
   \   00000144   0090A0E3           MOV      R9,#+0
   \   00000148   0000A0E3           MOV      R0,#+0
    345                  for (i = 0; i < 4; i++) {
   \   0000014C   0430A0E3           MOV      R3,#+4
   \   00000150   8010A0E3           MOV      R1,#+128
    346                    U8 Index = *p & (0x80 >> Diff) ? Index1 : Index0;
   \                     ??_DrawBitLine1BPP_10:
   \   00000154   00A0D4E5           LDRB     R10,[R4, #+0]
   \   00000158   51051AE1           TST      R10,R1, ASR R5
   \   0000015C   02A0A011           MOVNE    R10,R2
   \   00000160   0EA0A001           MOVEQ    R10,LR
    347                    if (++Diff == 8) {
   \   00000164   015085E2           ADD      R5,R5,#+1
    348                      Diff = 0;
    349                      p++;
    350                    }
    351                    ColorMask |= Index << (8 * i);
   \   00000168   FFA00AE2           AND      R10,R10,#0xFF
   \   0000016C   080055E3           CMP      R5,#+8
   \   00000170   1A0980E1           ORR      R0,R0,R10, LSL R9
   \   00000174   0050A003           MOVEQ    R5,#+0
   \   00000178   01408402           ADDEQ    R4,R4,#+1
    352                  }
   \   0000017C   089089E2           ADD      R9,R9,#+8
   \   00000180   013053E2           SUBS     R3,R3,#+1
   \   00000184   F2FFFF1A           BNE      ??_DrawBitLine1BPP_10
    353                  #if (LCD_ENDIAN_BIG == 1)
    354                    MIRROR(ColorMask);
    355                  #endif
    356                  WRITE_MEM32(pContext->VRAMAddr, Off, ColorMask);
   \   00000188   00109CE5           LDR      R1,[R12, #+0]
    357                  Off++;
    358                  xsize -= 4;
   \   0000018C   046046E2           SUB      R6,R6,#+4
   \   00000190   070181E7           STR      R0,[R1, +R7, LSL #+2]
   \   00000194   017087E2           ADD      R7,R7,#+1
   \   00000198   040056E3           CMP      R6,#+4
   \   0000019C   E8FFFFAA           BGE      ??_DrawBitLine1BPP_9
    359                }
    360                //
    361                // Last DWORD
    362                //
    363                if (xsize) {
   \                     ??_DrawBitLine1BPP_8:
   \   000001A0   000056E3           CMP      R6,#+0
   \   000001A4   5F00000A           BEQ      ??_DrawBitLine1BPP_2
    364                  ColorMask = i = 0;
    365                  AndMask = 0xFFFFFF00 << (8 * NumPixel_1);
   \   000001A8   FF10E0E3           MVN      R1,#+255
   \   000001AC   8881A0E1           LSL      R8,R8,#+3
   \   000001B0   1198A0E1           LSL      R9,R1,R8
   \   000001B4   0030A0E3           MOV      R3,#+0
   \   000001B8   0000A0E3           MOV      R0,#+0
   \   000001BC   8010A0E3           MOV      R1,#+128
    366                  while (xsize) {
    367                    U8 Index = *p & (0x80 >> Diff) ? Index1 : Index0;
   \                     ??_DrawBitLine1BPP_11:
   \   000001C0   0080D4E5           LDRB     R8,[R4, #+0]
    368                    if (++Diff == 8) {
    369                      Diff = 0;
    370                      p++;
    371                    }
    372                    ColorMask |= Index << (8 * i++);
   \   000001C4   83A1A0E1           LSL      R10,R3,#+3
   \   000001C8   013083E2           ADD      R3,R3,#+1
   \   000001CC   510518E1           TST      R8,R1, ASR R5
   \   000001D0   0280A011           MOVNE    R8,R2
   \   000001D4   0E80A001           MOVEQ    R8,LR
   \   000001D8   015085E2           ADD      R5,R5,#+1
   \   000001DC   080055E3           CMP      R5,#+8
   \   000001E0   FF8008E2           AND      R8,R8,#0xFF
   \   000001E4   0050A003           MOVEQ    R5,#+0
   \   000001E8   01408402           ADDEQ    R4,R4,#+1
   \   000001EC   180A80E1           ORR      R0,R0,R8, LSL R10
    373                    xsize--;
   \   000001F0   016056E2           SUBS     R6,R6,#+1
   \   000001F4   F1FFFF1A           BNE      ??_DrawBitLine1BPP_11
    374                  }
    375                  #if (LCD_ENDIAN_BIG == 1)
    376                    MIRROR(AndMask);
    377                    MIRROR(ColorMask);
    378                  #endif
    379                  Data = READ_MEM32(pContext->VRAMAddr, Off);
    380                  Data &= AndMask;
    381                  Data |= ColorMask;
    382                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000001F8   00109CE5           LDR      R1,[R12, #+0]
   \   000001FC   072191E7           LDR      R2,[R1, +R7, LSL #+2]
   \   00000200   022009E0           AND      R2,R9,R2
   \   00000204   020080E1           ORR      R0,R0,R2
   \   00000208   070181E7           STR      R0,[R1, +R7, LSL #+2]
   \   0000020C   450000EA           B        ??_DrawBitLine1BPP_2
    383                }
    384              }
    385            } else {
    386              switch (Mode) {
   \                     ??_DrawBitLine1BPP_0:
   \   00000210   010050E3           CMP      R0,#+1
   \   00000214   1E00000A           BEQ      ??_DrawBitLine1BPP_12
   \   00000218   4200003A           BCC      ??_DrawBitLine1BPP_2
   \   0000021C   030050E3           CMP      R0,#+3
   \   00000220   1B00000A           BEQ      ??_DrawBitLine1BPP_12
   \   00000224   3F00002A           BCS      ??_DrawBitLine1BPP_2
    387              case LCD_DRAWMODE_TRANS:
    388                do {
    389                  if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_13:
   \   00000228   0000D4E5           LDRB     R0,[R4, #+0]
   \   0000022C   8010A0E3           MOV      R1,#+128
   \   00000230   510510E1           TST      R0,R1, ASR R5
   \   00000234   0E00000A           BEQ      ??_DrawBitLine1BPP_14
    390                    _SetPixelIndex(pDevice, x, y, Index1);
   \   00000238   080097E5           LDR      R0,[R7, #+8]
   \   0000023C   FFE0A0E3           MOV      LR,#+255
   \   00000240   141090E5           LDR      R1,[R0, #+20]
   \   00000244   000090E5           LDR      R0,[R0, #+0]
   \   00000248   C110A0E1           ASR      R1,R1,#+1
   \   0000024C   910803E0           MUL      R3,R1,R8
   \   00000250   011009E2           AND      R1,R9,#0x1
   \   00000254   A93083E0           ADD      R3,R3,R9, LSR #+1
   \   00000258   8330A0E1           LSL      R3,R3,#+1
   \   0000025C   B0C093E1           LDRH     R12,[R3, +R0]
   \   00000260   8111A0E1           LSL      R1,R1,#+3
   \   00000264   1EE1A0E1           LSL      LR,LR,R1
   \   00000268   0EC0CCE1           BIC      R12,R12,LR
   \   0000026C   12118CE1           ORR      R1,R12,R2, LSL R1
   \   00000270   B01083E1           STRH     R1,[R3, +R0]
    391                  }
    392                  x++;
    393                  if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_14:
   \   00000274   015085E2           ADD      R5,R5,#+1
   \   00000278   080055E3           CMP      R5,#+8
    394                    Diff = 0;
   \   0000027C   0050A003           MOVEQ    R5,#+0
    395                    p++;
   \   00000280   01408402           ADDEQ    R4,R4,#+1
   \   00000284   019089E2           ADD      R9,R9,#+1
    396                  }
    397                } while (--xsize);
   \   00000288   016056E2           SUBS     R6,R6,#+1
   \   0000028C   E5FFFF1A           BNE      ??_DrawBitLine1BPP_13
   \   00000290   240000EA           B        ??_DrawBitLine1BPP_2
    398                break;
    399              case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    400              case LCD_DRAWMODE_XOR:
    401                IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \                     ??_DrawBitLine1BPP_12:
   \   00000294   100097E5           LDR      R0,[R7, #+16]
   \   00000298   080090E5           LDR      R0,[R0, #+8]
   \   0000029C   30FF2FE1           BLX      R0
   \   000002A0   00B0A0E1           MOV      R11,R0
   \   000002A4   8010A0E3           MOV      R1,#+128
    402                do {
    403                  if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_15:
   \   000002A8   0000D4E5           LDRB     R0,[R4, #+0]
   \   000002AC   510510E1           TST      R0,R1, ASR R5
   \   000002B0   1500000A           BEQ      ??_DrawBitLine1BPP_16
    404                    int Pixel = _GetPixelIndex(pDevice, x, y);
   \   000002B4   080097E5           LDR      R0,[R7, #+8]
   \   000002B8   A930A0E1           LSR      R3,R9,#+1
   \   000002BC   14C090E5           LDR      R12,[R0, #+20]
   \   000002C0   012009E2           AND      R2,R9,#0x1
   \   000002C4   CCC0A0E1           ASR      R12,R12,#+1
   \   000002C8   9C382EE0           MLA      LR,R12,R8,R3
   \   000002CC   00C090E5           LDR      R12,[R0, #+0]
   \   000002D0   82A1A0E1           LSL      R10,R2,#+3
   \   000002D4   8EC08CE0           ADD      R12,R12,LR, LSL #+1
    405                    _SetPixelIndex(pDevice, x, y, Pixel ^ IndexMask);
   \   000002D8   14E090E5           LDR      LR,[R0, #+20]
   \   000002DC   B0C0DCE1           LDRH     R12,[R12, #+0]
   \   000002E0   CEE0A0E1           ASR      LR,LR,#+1
   \   000002E4   9E3823E0           MLA      R3,LR,R8,R3
   \   000002E8   000090E5           LDR      R0,[R0, #+0]
   \   000002EC   8330A0E1           LSL      R3,R3,#+1
   \   000002F0   FF20A0E3           MOV      R2,#+255
   \   000002F4   B0E093E1           LDRH     LR,[R3, +R0]
   \   000002F8   12CA0CE0           AND      R12,R12,R2, LSL R10
   \   000002FC   122ACEE1           BIC      R2,LR,R2, LSL R10
   \   00000300   5CCA2BE0           EOR      R12,R11,R12, ASR R10
   \   00000304   1C2A82E1           ORR      R2,R2,R12, LSL R10
   \   00000308   B02083E1           STRH     R2,[R3, +R0]
    406                  }
    407                  x++;
    408                  if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_16:
   \   0000030C   015085E2           ADD      R5,R5,#+1
   \   00000310   080055E3           CMP      R5,#+8
    409                    Diff = 0;
   \   00000314   0050A003           MOVEQ    R5,#+0
    410                    p++;
   \   00000318   01408402           ADDEQ    R4,R4,#+1
   \   0000031C   019089E2           ADD      R9,R9,#+1
    411                  }
    412                } while (--xsize);
   \   00000320   016056E2           SUBS     R6,R6,#+1
   \   00000324   DFFFFF1A           BNE      ??_DrawBitLine1BPP_15
    413                break;
    414              }
    415            }
    416          }
   \                     ??_DrawBitLine1BPP_2:
   \   00000328   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000032C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    417          
    418          /*********************************************************************
    419          *
    420          *       Draw Bitmap 2 BPP, not optimized
    421          */

   \                                 In section .text, align 4, keep-with-next
    422          static void  _DrawBitLine2BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine2BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    423            LCD_PIXELINDEX Pixels = *p;
    424            int CurrentPixel = Diff;
    425            x += Diff;
    426            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000004   ........           LDR      R5,??DataTable14
   \   00000008   24C09DE5           LDR      R12,[SP, #+36]
   \   0000000C   1050D5E5           LDRB     R5,[R5, #+16]
   \   00000010   28E09DE5           LDR      LR,[SP, #+40]
   \   00000014   0040D3E5           LDRB     R4,[R3, #+0]
   \   00000018   01108CE0           ADD      R1,R12,R1
   \   0000001C   035015E2           ANDS     R5,R5,#0x3
   \   00000020   0200000A           BEQ      ??_DrawBitLine2BPP_0
   \   00000024   025055E2           SUBS     R5,R5,#+2
   \   00000028   3E00000A           BEQ      ??_DrawBitLine2BPP_1
   \   0000002C   F08FBDE8           POP      {R4-R11,PC}
   \                     ??_DrawBitLine2BPP_0:
   \   00000030   2C609DE5           LDR      R6,[SP, #+44]
   \   00000034   C050A0E3           MOV      R5,#+192
   \   00000038   000056E3           CMP      R6,#+0
   \   0000003C   1D00000A           BEQ      ??_DrawBitLine2BPP_2
    427            case 0:
    428              if (pTrans) {
    429                do {
    430                  int Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_3:
   \   00000040   03606CE2           RSB      R6,R12,#+3
   \   00000044   8660A0E1           LSL      R6,R6,#+1
    431                  int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    432                  LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
   \   00000048   0670A0E1           MOV      R7,R6
   \   0000004C   067067E2           RSB      R7,R7,#+6
   \   00000050   557704E0           AND      R7,R4,R5, ASR R7
   \   00000054   3766A0E1           LSR      R6,R7,R6
   \   00000058   2C709DE5           LDR      R7,[SP, #+44]
    433                  _SetPixelIndex(pDevice, x++, y, PixelIndex);
   \   0000005C   088090E5           LDR      R8,[R0, #+8]
   \   00000060   066197E7           LDR      R6,[R7, +R6, LSL #+2]
   \   00000064   147098E5           LDR      R7,[R8, #+20]
   \   00000068   008098E5           LDR      R8,[R8, #+0]
   \   0000006C   C770A0E1           ASR      R7,R7,#+1
   \   00000070   970209E0           MUL      R9,R7,R2
   \   00000074   017001E2           AND      R7,R1,#0x1
   \   00000078   A19089E0           ADD      R9,R9,R1, LSR #+1
   \   0000007C   8990A0E1           LSL      R9,R9,#+1
   \   00000080   B8A099E1           LDRH     R10,[R9, +R8]
   \   00000084   8771A0E1           LSL      R7,R7,#+3
   \   00000088   FFB0A0E3           MOV      R11,#+255
   \   0000008C   1BA7CAE1           BIC      R10,R10,R11, LSL R7
   \   00000090   16678AE1           ORR      R6,R10,R6, LSL R7
    434                  if (++CurrentPixel == 4) {
   \   00000094   01C08CE2           ADD      R12,R12,#+1
   \   00000098   B86089E1           STRH     R6,[R9, +R8]
   \   0000009C   04005CE3           CMP      R12,#+4
    435                    CurrentPixel = 0;
   \   000000A0   00C0A003           MOVEQ    R12,#+0
    436                    Pixels = *(++p);
   \   000000A4   0140F305           LDRBEQ   R4,[R3, #+1]!
   \   000000A8   011081E2           ADD      R1,R1,#+1
    437                  }
    438          		  } while (--xsize);
   \   000000AC   01E05EE2           SUBS     LR,LR,#+1
   \   000000B0   E2FFFF1A           BNE      ??_DrawBitLine2BPP_3
   \   000000B4   F08FBDE8           POP      {R4-R11,PC}
    439              } else {
    440                do {
    441                  int Shift = (3 - CurrentPixel) << 1;
    442                  int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    443                  _SetPixelIndex(pDevice, x++, y, Index);
   \                     ??_DrawBitLine2BPP_2:
   \   000000B8   089090E5           LDR      R9,[R0, #+8]
   \   000000BC   FFB0A0E3           MOV      R11,#+255
   \   000000C0   147099E5           LDR      R7,[R9, #+20]
   \   000000C4   009099E5           LDR      R9,[R9, #+0]
   \   000000C8   C770A0E1           ASR      R7,R7,#+1
   \   000000CC   970208E0           MUL      R8,R7,R2
   \   000000D0   017001E2           AND      R7,R1,#0x1
   \   000000D4   A18088E0           ADD      R8,R8,R1, LSR #+1
   \   000000D8   8880A0E1           LSL      R8,R8,#+1
   \   000000DC   B9A098E1           LDRH     R10,[R8, +R9]
   \   000000E0   8771A0E1           LSL      R7,R7,#+3
   \   000000E4   03606CE2           RSB      R6,R12,#+3
   \   000000E8   1BA7CAE1           BIC      R10,R10,R11, LSL R7
   \   000000EC   8660A0E1           LSL      R6,R6,#+1
   \   000000F0   06B0A0E1           MOV      R11,R6
   \   000000F4   06B06BE2           RSB      R11,R11,#+6
   \   000000F8   55BB04E0           AND      R11,R4,R5, ASR R11
   \   000000FC   3B66A0E1           LSR      R6,R11,R6
   \   00000100   16678AE1           ORR      R6,R10,R6, LSL R7
    444                  if (++CurrentPixel == 4) {
   \   00000104   01C08CE2           ADD      R12,R12,#+1
   \   00000108   B96088E1           STRH     R6,[R8, +R9]
   \   0000010C   04005CE3           CMP      R12,#+4
    445                    CurrentPixel = 0;
   \   00000110   00C0A003           MOVEQ    R12,#+0
    446                    Pixels = *(++p);
   \   00000114   0140F305           LDRBEQ   R4,[R3, #+1]!
   \   00000118   011081E2           ADD      R1,R1,#+1
    447                  }
    448          		  } while (--xsize);
   \   0000011C   01E05EE2           SUBS     LR,LR,#+1
   \   00000120   E4FFFF1A           BNE      ??_DrawBitLine2BPP_2
   \   00000124   F08FBDE8           POP      {R4-R11,PC}
    449              }
    450              break;
    451            case LCD_DRAWMODE_TRANS:
    452              if (pTrans) {
   \                     ??_DrawBitLine2BPP_1:
   \   00000128   2C609DE5           LDR      R6,[SP, #+44]
   \   0000012C   C050A0E3           MOV      R5,#+192
   \   00000130   000056E3           CMP      R6,#+0
   \   00000134   1E00000A           BEQ      ??_DrawBitLine2BPP_4
    453                do {
    454                  int Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_5:
   \   00000138   03606CE2           RSB      R6,R12,#+3
   \   0000013C   8660A0E1           LSL      R6,R6,#+1
    455                  int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000140   0670A0E1           MOV      R7,R6
   \   00000144   067067E2           RSB      R7,R7,#+6
   \   00000148   557704E0           AND      R7,R4,R5, ASR R7
   \   0000014C   3766B0E1           LSRS     R6,R7,R6
    456                  if (Index) {
   \   00000150   0F00000A           BEQ      ??_DrawBitLine2BPP_6
    457                    LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
   \   00000154   2C709DE5           LDR      R7,[SP, #+44]
    458                    _SetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000158   088090E5           LDR      R8,[R0, #+8]
   \   0000015C   066197E7           LDR      R6,[R7, +R6, LSL #+2]
   \   00000160   147098E5           LDR      R7,[R8, #+20]
   \   00000164   008098E5           LDR      R8,[R8, #+0]
   \   00000168   C770A0E1           ASR      R7,R7,#+1
   \   0000016C   970209E0           MUL      R9,R7,R2
   \   00000170   017001E2           AND      R7,R1,#0x1
   \   00000174   A19089E0           ADD      R9,R9,R1, LSR #+1
   \   00000178   8990A0E1           LSL      R9,R9,#+1
   \   0000017C   B8A099E1           LDRH     R10,[R9, +R8]
   \   00000180   8771A0E1           LSL      R7,R7,#+3
   \   00000184   FFB0A0E3           MOV      R11,#+255
   \   00000188   1BA7CAE1           BIC      R10,R10,R11, LSL R7
   \   0000018C   16678AE1           ORR      R6,R10,R6, LSL R7
   \   00000190   B86089E1           STRH     R6,[R9, +R8]
    459                  }
    460                  x++;
    461                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_6:
   \   00000194   01C08CE2           ADD      R12,R12,#+1
   \   00000198   04005CE3           CMP      R12,#+4
    462                    CurrentPixel = 0;
   \   0000019C   00C0A003           MOVEQ    R12,#+0
    463                    Pixels = *(++p);
   \   000001A0   0140F305           LDRBEQ   R4,[R3, #+1]!
   \   000001A4   011081E2           ADD      R1,R1,#+1
    464                  }
    465          		  } while (--xsize);
   \   000001A8   01E05EE2           SUBS     LR,LR,#+1
   \   000001AC   E1FFFF1A           BNE      ??_DrawBitLine2BPP_5
   \   000001B0   F08FBDE8           POP      {R4-R11,PC}
    466              } else {
    467                do {
    468                  int Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_4:
   \   000001B4   03606CE2           RSB      R6,R12,#+3
   \   000001B8   8660A0E1           LSL      R6,R6,#+1
    469                  int Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   000001BC   0670A0E1           MOV      R7,R6
   \   000001C0   067067E2           RSB      R7,R7,#+6
   \   000001C4   557704E0           AND      R7,R4,R5, ASR R7
   \   000001C8   3766B0E1           LSRS     R6,R7,R6
    470                  if (Index) {
   \   000001CC   0D00000A           BEQ      ??_DrawBitLine2BPP_7
    471                    _SetPixelIndex(pDevice, x, y, Index);
   \   000001D0   088090E5           LDR      R8,[R0, #+8]
   \   000001D4   FFB0A0E3           MOV      R11,#+255
   \   000001D8   147098E5           LDR      R7,[R8, #+20]
   \   000001DC   008098E5           LDR      R8,[R8, #+0]
   \   000001E0   C770A0E1           ASR      R7,R7,#+1
   \   000001E4   970209E0           MUL      R9,R7,R2
   \   000001E8   017001E2           AND      R7,R1,#0x1
   \   000001EC   A19089E0           ADD      R9,R9,R1, LSR #+1
   \   000001F0   8990A0E1           LSL      R9,R9,#+1
   \   000001F4   B8A099E1           LDRH     R10,[R9, +R8]
   \   000001F8   8771A0E1           LSL      R7,R7,#+3
   \   000001FC   1BA7CAE1           BIC      R10,R10,R11, LSL R7
   \   00000200   16678AE1           ORR      R6,R10,R6, LSL R7
   \   00000204   B86089E1           STRH     R6,[R9, +R8]
    472                  }
    473                  x++;
    474                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_7:
   \   00000208   01C08CE2           ADD      R12,R12,#+1
   \   0000020C   04005CE3           CMP      R12,#+4
    475                    CurrentPixel = 0;
   \   00000210   00C0A003           MOVEQ    R12,#+0
    476                    Pixels = *(++p);
   \   00000214   0140F305           LDRBEQ   R4,[R3, #+1]!
   \   00000218   011081E2           ADD      R1,R1,#+1
    477                  }
    478          		  } while (--xsize);
   \   0000021C   01E05EE2           SUBS     LR,LR,#+1
   \   00000220   E3FFFF1A           BNE      ??_DrawBitLine2BPP_4
    479              }
    480              break;
    481            }
    482          }
   \   00000224   F08FBDE8           POP      {R4-R11,PC}      ;; return
    483          
    484          /*********************************************************************
    485          *
    486          *       Draw Bitmap 4 BPP, not optimized
    487          */

   \                                 In section .text, align 4, keep-with-next
    488          static void  _DrawBitLine4BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine4BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    489            LCD_PIXELINDEX Pixels = *p;
    490            int CurrentPixel = Diff;
    491            x += Diff;
    492            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000004   ........           LDR      R5,??DataTable14
   \   00000008   24C09DE5           LDR      R12,[SP, #+36]
   \   0000000C   1050D5E5           LDRB     R5,[R5, #+16]
   \   00000010   28E09DE5           LDR      LR,[SP, #+40]
   \   00000014   0040D3E5           LDRB     R4,[R3, #+0]
   \   00000018   01108CE0           ADD      R1,R12,R1
   \   0000001C   035015E2           ANDS     R5,R5,#0x3
   \   00000020   0200000A           BEQ      ??_DrawBitLine4BPP_0
   \   00000024   025055E2           SUBS     R5,R5,#+2
   \   00000028   3E00000A           BEQ      ??_DrawBitLine4BPP_1
   \   0000002C   F08FBDE8           POP      {R4-R11,PC}
   \                     ??_DrawBitLine4BPP_0:
   \   00000030   2C609DE5           LDR      R6,[SP, #+44]
   \   00000034   F050A0E3           MOV      R5,#+240
   \   00000038   000056E3           CMP      R6,#+0
   \   0000003C   1D00000A           BEQ      ??_DrawBitLine4BPP_2
    493            case 0:
    494              if (pTrans) {
    495                do {
    496                  int Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_3:
   \   00000040   01606CE2           RSB      R6,R12,#+1
   \   00000044   0661A0E1           LSL      R6,R6,#+2
    497                  int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    498                  LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
   \   00000048   0670A0E1           MOV      R7,R6
   \   0000004C   047067E2           RSB      R7,R7,#+4
   \   00000050   557704E0           AND      R7,R4,R5, ASR R7
   \   00000054   3766A0E1           LSR      R6,R7,R6
   \   00000058   2C709DE5           LDR      R7,[SP, #+44]
    499                  _SetPixelIndex(pDevice, x++, y, PixelIndex);
   \   0000005C   088090E5           LDR      R8,[R0, #+8]
   \   00000060   066197E7           LDR      R6,[R7, +R6, LSL #+2]
   \   00000064   147098E5           LDR      R7,[R8, #+20]
   \   00000068   008098E5           LDR      R8,[R8, #+0]
   \   0000006C   C770A0E1           ASR      R7,R7,#+1
   \   00000070   970209E0           MUL      R9,R7,R2
   \   00000074   017001E2           AND      R7,R1,#0x1
   \   00000078   A19089E0           ADD      R9,R9,R1, LSR #+1
   \   0000007C   8990A0E1           LSL      R9,R9,#+1
   \   00000080   B8A099E1           LDRH     R10,[R9, +R8]
   \   00000084   8771A0E1           LSL      R7,R7,#+3
   \   00000088   FFB0A0E3           MOV      R11,#+255
   \   0000008C   1BA7CAE1           BIC      R10,R10,R11, LSL R7
   \   00000090   16678AE1           ORR      R6,R10,R6, LSL R7
    500                  if (++CurrentPixel == 2) {
   \   00000094   01C08CE2           ADD      R12,R12,#+1
   \   00000098   B86089E1           STRH     R6,[R9, +R8]
   \   0000009C   02005CE3           CMP      R12,#+2
    501                    CurrentPixel = 0;
   \   000000A0   00C0A003           MOVEQ    R12,#+0
    502                    Pixels = *(++p);
   \   000000A4   0140F305           LDRBEQ   R4,[R3, #+1]!
   \   000000A8   011081E2           ADD      R1,R1,#+1
    503                  }
    504          		  } while (--xsize);
   \   000000AC   01E05EE2           SUBS     LR,LR,#+1
   \   000000B0   E2FFFF1A           BNE      ??_DrawBitLine4BPP_3
   \   000000B4   F08FBDE8           POP      {R4-R11,PC}
    505              } else {
    506                do {
    507                  int Shift = (1 - CurrentPixel) << 2;
    508                  int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    509                  _SetPixelIndex(pDevice, x++, y, Index);
   \                     ??_DrawBitLine4BPP_2:
   \   000000B8   089090E5           LDR      R9,[R0, #+8]
   \   000000BC   FFB0A0E3           MOV      R11,#+255
   \   000000C0   147099E5           LDR      R7,[R9, #+20]
   \   000000C4   009099E5           LDR      R9,[R9, #+0]
   \   000000C8   C770A0E1           ASR      R7,R7,#+1
   \   000000CC   970208E0           MUL      R8,R7,R2
   \   000000D0   017001E2           AND      R7,R1,#0x1
   \   000000D4   A18088E0           ADD      R8,R8,R1, LSR #+1
   \   000000D8   8880A0E1           LSL      R8,R8,#+1
   \   000000DC   B9A098E1           LDRH     R10,[R8, +R9]
   \   000000E0   8771A0E1           LSL      R7,R7,#+3
   \   000000E4   01606CE2           RSB      R6,R12,#+1
   \   000000E8   1BA7CAE1           BIC      R10,R10,R11, LSL R7
   \   000000EC   0661A0E1           LSL      R6,R6,#+2
   \   000000F0   06B0A0E1           MOV      R11,R6
   \   000000F4   04B06BE2           RSB      R11,R11,#+4
   \   000000F8   55BB04E0           AND      R11,R4,R5, ASR R11
   \   000000FC   3B66A0E1           LSR      R6,R11,R6
   \   00000100   16678AE1           ORR      R6,R10,R6, LSL R7
    510                  if (++CurrentPixel == 2) {
   \   00000104   01C08CE2           ADD      R12,R12,#+1
   \   00000108   B96088E1           STRH     R6,[R8, +R9]
   \   0000010C   02005CE3           CMP      R12,#+2
    511                    CurrentPixel = 0;
   \   00000110   00C0A003           MOVEQ    R12,#+0
    512                    Pixels = *(++p);
   \   00000114   0140F305           LDRBEQ   R4,[R3, #+1]!
   \   00000118   011081E2           ADD      R1,R1,#+1
    513                  }
    514          		  } while (--xsize);
   \   0000011C   01E05EE2           SUBS     LR,LR,#+1
   \   00000120   E4FFFF1A           BNE      ??_DrawBitLine4BPP_2
   \   00000124   F08FBDE8           POP      {R4-R11,PC}
    515              }
    516              break;
    517            case LCD_DRAWMODE_TRANS:
    518              if (pTrans) {
   \                     ??_DrawBitLine4BPP_1:
   \   00000128   2C609DE5           LDR      R6,[SP, #+44]
   \   0000012C   F050A0E3           MOV      R5,#+240
   \   00000130   000056E3           CMP      R6,#+0
   \   00000134   1E00000A           BEQ      ??_DrawBitLine4BPP_4
    519                do {
    520                  int Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_5:
   \   00000138   01606CE2           RSB      R6,R12,#+1
   \   0000013C   0661A0E1           LSL      R6,R6,#+2
    521                  int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000140   0670A0E1           MOV      R7,R6
   \   00000144   047067E2           RSB      R7,R7,#+4
   \   00000148   557704E0           AND      R7,R4,R5, ASR R7
   \   0000014C   3766B0E1           LSRS     R6,R7,R6
    522                  if (Index) {
   \   00000150   0F00000A           BEQ      ??_DrawBitLine4BPP_6
    523                    LCD_PIXELINDEX PixelIndex = *(pTrans + Index);
   \   00000154   2C709DE5           LDR      R7,[SP, #+44]
    524                    _SetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000158   088090E5           LDR      R8,[R0, #+8]
   \   0000015C   066197E7           LDR      R6,[R7, +R6, LSL #+2]
   \   00000160   147098E5           LDR      R7,[R8, #+20]
   \   00000164   008098E5           LDR      R8,[R8, #+0]
   \   00000168   C770A0E1           ASR      R7,R7,#+1
   \   0000016C   970209E0           MUL      R9,R7,R2
   \   00000170   017001E2           AND      R7,R1,#0x1
   \   00000174   A19089E0           ADD      R9,R9,R1, LSR #+1
   \   00000178   8990A0E1           LSL      R9,R9,#+1
   \   0000017C   B8A099E1           LDRH     R10,[R9, +R8]
   \   00000180   8771A0E1           LSL      R7,R7,#+3
   \   00000184   FFB0A0E3           MOV      R11,#+255
   \   00000188   1BA7CAE1           BIC      R10,R10,R11, LSL R7
   \   0000018C   16678AE1           ORR      R6,R10,R6, LSL R7
   \   00000190   B86089E1           STRH     R6,[R9, +R8]
    525                  }
    526                  x++;
    527                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_6:
   \   00000194   01C08CE2           ADD      R12,R12,#+1
   \   00000198   02005CE3           CMP      R12,#+2
    528                    CurrentPixel = 0;
   \   0000019C   00C0A003           MOVEQ    R12,#+0
    529                    Pixels = *(++p);
   \   000001A0   0140F305           LDRBEQ   R4,[R3, #+1]!
   \   000001A4   011081E2           ADD      R1,R1,#+1
    530                  }
    531          		  } while (--xsize);
   \   000001A8   01E05EE2           SUBS     LR,LR,#+1
   \   000001AC   E1FFFF1A           BNE      ??_DrawBitLine4BPP_5
   \   000001B0   F08FBDE8           POP      {R4-R11,PC}
    532              } else {
    533                do {
    534                  int Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_4:
   \   000001B4   01606CE2           RSB      R6,R12,#+1
   \   000001B8   0661A0E1           LSL      R6,R6,#+2
    535                  int Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   000001BC   0670A0E1           MOV      R7,R6
   \   000001C0   047067E2           RSB      R7,R7,#+4
   \   000001C4   557704E0           AND      R7,R4,R5, ASR R7
   \   000001C8   3766B0E1           LSRS     R6,R7,R6
    536                  if (Index) {
   \   000001CC   0D00000A           BEQ      ??_DrawBitLine4BPP_7
    537                    _SetPixelIndex(pDevice, x, y, Index);
   \   000001D0   088090E5           LDR      R8,[R0, #+8]
   \   000001D4   FFB0A0E3           MOV      R11,#+255
   \   000001D8   147098E5           LDR      R7,[R8, #+20]
   \   000001DC   008098E5           LDR      R8,[R8, #+0]
   \   000001E0   C770A0E1           ASR      R7,R7,#+1
   \   000001E4   970209E0           MUL      R9,R7,R2
   \   000001E8   017001E2           AND      R7,R1,#0x1
   \   000001EC   A19089E0           ADD      R9,R9,R1, LSR #+1
   \   000001F0   8990A0E1           LSL      R9,R9,#+1
   \   000001F4   B8A099E1           LDRH     R10,[R9, +R8]
   \   000001F8   8771A0E1           LSL      R7,R7,#+3
   \   000001FC   1BA7CAE1           BIC      R10,R10,R11, LSL R7
   \   00000200   16678AE1           ORR      R6,R10,R6, LSL R7
   \   00000204   B86089E1           STRH     R6,[R9, +R8]
    538                  }
    539                  x++;
    540                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_7:
   \   00000208   01C08CE2           ADD      R12,R12,#+1
   \   0000020C   02005CE3           CMP      R12,#+2
    541                    CurrentPixel = 0;
   \   00000210   00C0A003           MOVEQ    R12,#+0
    542                    Pixels = *(++p);
   \   00000214   0140F305           LDRBEQ   R4,[R3, #+1]!
   \   00000218   011081E2           ADD      R1,R1,#+1
    543                  }
    544          		  } while (--xsize);
   \   0000021C   01E05EE2           SUBS     LR,LR,#+1
   \   00000220   E3FFFF1A           BNE      ??_DrawBitLine4BPP_4
    545              }
    546              break;
    547            }
    548          }
   \   00000224   F08FBDE8           POP      {R4-R11,PC}      ;; return
    549          
    550          /*********************************************************************
    551          *
    552          *       Draw Bitmap 8 BPP
    553          */

   \                                 In section .text, align 4, keep-with-next
    554          static void  _DrawBitLine8BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine8BPP:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
    555            DRIVER_CONTEXT * pContext;
    556            LCD_PIXELINDEX pixel;
    557            U32 Data, ColorMask, AndMask;
    558            U8 Index;
    559            int Off, NumPixel_0, NumPixel_1, i;
    560          
    561            if ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) == 0) {
   \   00000004   ........           LDR      R4,??DataTable14
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   1040D4E5           LDRB     R4,[R4, #+16]
   \   00000010   20C09DE5           LDR      R12,[SP, #+32]
   \   00000014   24E09DE5           LDR      LR,[SP, #+36]
   \   00000018   020014E3           TST      R4,#0x2
   \   0000001C   A000001A           BNE      ??_DrawBitLine8BPP_0
    562              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000020   080090E5           LDR      R0,[R0, #+8]
    563              Off = XY2OFF32(pContext->vxSizePhys, x, y);
    564              NumPixel_0 = x & 3;
    565              NumPixel_1 = (x + xsize - 1) & 3;
    566              if (pTrans) {
   \   00000024   00005EE3           CMP      LR,#+0
   \   00000028   144090E5           LDR      R4,[R0, #+20]
   \   0000002C   4441A0E1           ASR      R4,R4,#+2
   \   00000030   940202E0           MUL      R2,R4,R2
   \   00000034   034001E2           AND      R4,R1,#0x3
   \   00000038   212182E0           ADD      R2,R2,R1, LSR #+2
   \   0000003C   01108CE0           ADD      R1,R12,R1
   \   00000040   011041E2           SUB      R1,R1,#+1
   \   00000044   035001E2           AND      R5,R1,#0x3
   \   00000048   4A00000A           BEQ      ??_DrawBitLine8BPP_1
    567                //
    568                // First DWORD
    569                //
    570                if (NumPixel_0) {
   \   0000004C   000054E3           CMP      R4,#+0
   \   00000050   1E00000A           BEQ      ??_DrawBitLine8BPP_2
    571                  ColorMask = 0;
   \   00000054   0060A0E3           MOV      R6,#+0
    572                  AndMask = ~(0xFFFFFFFF << (8 * NumPixel_0));
   \   00000058   0670E0E1           MVN      R7,R6
   \   0000005C   8411A0E1           LSL      R1,R4,#+3
   \   00000060   1711E0E1           MVN      R1,R7, LSL R1
    573                  if ((xsize < 3) && (NumPixel_1)) {
   \   00000064   03005CE3           CMP      R12,#+3
   \   00000068   0E0000AA           BGE      ??_DrawBitLine8BPP_3
   \   0000006C   000055E3           CMP      R5,#+0
   \   00000070   0C00000A           BEQ      ??_DrawBitLine8BPP_3
    574                    AndMask |= ~(0xFFFFFFFF >> (8 * (3 - NumPixel_1)));
   \   00000074   0580A0E1           MOV      R8,R5
   \   00000078   038068E2           RSB      R8,R8,#+3
   \   0000007C   8881A0E1           LSL      R8,R8,#+3
   \   00000080   3778E0E1           MVN      R7,R7, LSR R8
   \   00000084   011087E1           ORR      R1,R7,R1
    575                  }
    576                  for (i = NumPixel_0; (i < 4) && xsize; i++, xsize--) {
   \   00000088   060000EA           B        ??_DrawBitLine8BPP_3
    577                    Index = *(pTrans + *p++);
   \                     ??_DrawBitLine8BPP_4:
   \   0000008C   0170D3E4           LDRB     R7,[R3], #+1
    578                    ColorMask |= Index << (8 * i);
   \   00000090   8481A0E1           LSL      R8,R4,#+3
    579                  }
   \   00000094   014084E2           ADD      R4,R4,#+1
   \   00000098   07719EE7           LDR      R7,[LR, +R7, LSL #+2]
   \   0000009C   01C04CE2           SUB      R12,R12,#+1
   \   000000A0   FF7007E2           AND      R7,R7,#0xFF
   \   000000A4   176886E1           ORR      R6,R6,R7, LSL R8
   \                     ??_DrawBitLine8BPP_3:
   \   000000A8   040054E3           CMP      R4,#+4
   \   000000AC   010000AA           BGE      ??_DrawBitLine8BPP_5
   \   000000B0   00005CE3           CMP      R12,#+0
   \   000000B4   F4FFFF1A           BNE      ??_DrawBitLine8BPP_4
    580                  #if (LCD_ENDIAN_BIG == 1)
    581                    MIRROR(AndMask);
    582                    MIRROR(ColorMask);
    583                  #endif
    584                  Data = READ_MEM32(pContext->VRAMAddr, Off);
    585                  Data &= AndMask;
    586                  Data |= ColorMask;
    587                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine8BPP_5:
   \   000000B8   004090E5           LDR      R4,[R0, #+0]
   \   000000BC   027194E7           LDR      R7,[R4, +R2, LSL #+2]
   \   000000C0   071001E0           AND      R1,R1,R7
   \   000000C4   011086E1           ORR      R1,R6,R1
   \   000000C8   021184E7           STR      R1,[R4, +R2, LSL #+2]
    588                  Off++;
   \   000000CC   012082E2           ADD      R2,R2,#+1
    589                }
    590                //
    591                // Complete DWORDS
    592                //
    593                while (xsize >= 4) {
   \                     ??_DrawBitLine8BPP_2:
   \   000000D0   04005CE3           CMP      R12,#+4
   \   000000D4   110000BA           BLT      ??_DrawBitLine8BPP_6
    594                  ColorMask =  *(pTrans + *p) |
    595                              (*(pTrans + *(p + 1)) << 8) |
    596                              (*(pTrans + *(p + 2)) << 16) |
    597                              (*(pTrans + *(p + 3)) << 24);
    598                  #if (LCD_ENDIAN_BIG == 1)
    599                    MIRROR(ColorMask);
    600                  #endif
    601                  WRITE_MEM32(pContext->VRAMAddr, Off, ColorMask);
   \                     ??_DrawBitLine8BPP_7:
   \   000000D8   0010D3E5           LDRB     R1,[R3, #+0]
   \   000000DC   0140D3E5           LDRB     R4,[R3, #+1]
   \   000000E0   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000E4   04419EE7           LDR      R4,[LR, +R4, LSL #+2]
    602                  p += 4;
    603                  Off++;
    604                  xsize -= 4;
   \   000000E8   04C04CE2           SUB      R12,R12,#+4
   \   000000EC   041481E1           ORR      R1,R1,R4, LSL #+8
   \   000000F0   0240D3E5           LDRB     R4,[R3, #+2]
   \   000000F4   04005CE3           CMP      R12,#+4
   \   000000F8   04419EE7           LDR      R4,[LR, +R4, LSL #+2]
   \   000000FC   041881E1           ORR      R1,R1,R4, LSL #+16
   \   00000100   0340D3E5           LDRB     R4,[R3, #+3]
   \   00000104   043083E2           ADD      R3,R3,#+4
   \   00000108   04419EE7           LDR      R4,[LR, +R4, LSL #+2]
   \   0000010C   041C81E1           ORR      R1,R1,R4, LSL #+24
   \   00000110   004090E5           LDR      R4,[R0, #+0]
   \   00000114   021184E7           STR      R1,[R4, +R2, LSL #+2]
   \   00000118   012082E2           ADD      R2,R2,#+1
   \   0000011C   EDFFFFAA           BGE      ??_DrawBitLine8BPP_7
    605                }
    606                //
    607                // Last DWORD
    608                //
    609                if (xsize) {
   \                     ??_DrawBitLine8BPP_6:
   \   00000120   00005CE3           CMP      R12,#+0
   \   00000124   9000000A           BEQ      ??_DrawBitLine8BPP_8
    610                  ColorMask = i = 0;
    611                  AndMask = 0xFFFFFF00 << (8 * NumPixel_1);
   \   00000128   FF10E0E3           MVN      R1,#+255
   \   0000012C   8551A0E1           LSL      R5,R5,#+3
   \   00000130   0040A0E3           MOV      R4,#+0
   \   00000134   0060A0E3           MOV      R6,#+0
   \   00000138   1115A0E1           LSL      R1,R1,R5
    612                  while (xsize) {
    613                    Index = *(pTrans + *p++);
   \                     ??_DrawBitLine8BPP_9:
   \   0000013C   0150D3E4           LDRB     R5,[R3], #+1
    614                    ColorMask |= Index << (8 * i++);
    615                    xsize--;
   \   00000140   01C05CE2           SUBS     R12,R12,#+1
   \   00000144   05719EE7           LDR      R7,[LR, +R5, LSL #+2]
   \   00000148   8451A0E1           LSL      R5,R4,#+3
   \   0000014C   FF7007E2           AND      R7,R7,#0xFF
   \   00000150   176586E1           ORR      R6,R6,R7, LSL R5
   \   00000154   014084E2           ADD      R4,R4,#+1
   \   00000158   F7FFFF1A           BNE      ??_DrawBitLine8BPP_9
    616                  }
    617                  #if (LCD_ENDIAN_BIG == 1)
    618                    MIRROR(AndMask);
    619                    MIRROR(ColorMask);
    620                  #endif
    621                  Data = READ_MEM32(pContext->VRAMAddr, Off);
    622                  Data &= AndMask;
    623                  Data |= ColorMask;
    624                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine8BPP_10:
   \   0000015C   000090E5           LDR      R0,[R0, #+0]
   \   00000160   04D08DE2           ADD      SP,SP,#+4
   \   00000164   023190E7           LDR      R3,[R0, +R2, LSL #+2]
   \   00000168   031001E0           AND      R1,R1,R3
   \   0000016C   011086E1           ORR      R1,R6,R1
   \   00000170   021180E7           STR      R1,[R0, +R2, LSL #+2]
   \   00000174   F083BDE8           POP      {R4-R9,PC}       ;; return
    625                }
    626              } else {
    627                //
    628                // First DWORD
    629                //
    630                if (NumPixel_0) {
   \                     ??_DrawBitLine8BPP_1:
   \   00000178   000054E3           CMP      R4,#+0
   \   0000017C   1C00000A           BEQ      ??_DrawBitLine8BPP_11
    631                  ColorMask = 0;
   \   00000180   0060A0E3           MOV      R6,#+0
    632                  AndMask = ~(0xFFFFFFFF << (8 * NumPixel_0));
   \   00000184   0670E0E1           MVN      R7,R6
   \   00000188   8411A0E1           LSL      R1,R4,#+3
   \   0000018C   1711E0E1           MVN      R1,R7, LSL R1
    633                  if ((xsize < 3) && (NumPixel_1)) {
   \   00000190   03005CE3           CMP      R12,#+3
   \   00000194   0C0000AA           BGE      ??_DrawBitLine8BPP_12
   \   00000198   000055E3           CMP      R5,#+0
   \   0000019C   0A00000A           BEQ      ??_DrawBitLine8BPP_12
    634                    AndMask |= ~(0xFFFFFFFF >> (8 * (3 - NumPixel_1)));
   \   000001A0   05E0A0E1           MOV      LR,R5
   \   000001A4   03E06EE2           RSB      LR,LR,#+3
   \   000001A8   8EE1A0E1           LSL      LR,LR,#+3
   \   000001AC   37EEE0E1           MVN      LR,R7, LSR LR
   \   000001B0   01108EE1           ORR      R1,LR,R1
    635                  }
    636                  for (i = NumPixel_0; (i < 4) && xsize; i++, xsize--) {
   \   000001B4   040000EA           B        ??_DrawBitLine8BPP_12
    637                    Index = *(p++);
   \                     ??_DrawBitLine8BPP_13:
   \   000001B8   0170D3E4           LDRB     R7,[R3], #+1
    638                    ColorMask |= Index << (8 * i);
   \   000001BC   84E1A0E1           LSL      LR,R4,#+3
    639                  }
   \   000001C0   014084E2           ADD      R4,R4,#+1
   \   000001C4   176E86E1           ORR      R6,R6,R7, LSL LR
   \   000001C8   01C04CE2           SUB      R12,R12,#+1
   \                     ??_DrawBitLine8BPP_12:
   \   000001CC   040054E3           CMP      R4,#+4
   \   000001D0   010000AA           BGE      ??_DrawBitLine8BPP_14
   \   000001D4   00005CE3           CMP      R12,#+0
   \   000001D8   F6FFFF1A           BNE      ??_DrawBitLine8BPP_13
    640                  #if (LCD_ENDIAN_BIG == 1)
    641                    MIRROR(AndMask);
    642                    MIRROR(ColorMask);
    643                  #endif
    644                  Data = READ_MEM32(pContext->VRAMAddr, Off);
    645                  Data &= AndMask;
    646                  Data |= ColorMask;
    647                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine8BPP_14:
   \   000001DC   004090E5           LDR      R4,[R0, #+0]
   \   000001E0   02E194E7           LDR      LR,[R4, +R2, LSL #+2]
   \   000001E4   0E1001E0           AND      R1,R1,LR
   \   000001E8   011086E1           ORR      R1,R6,R1
   \   000001EC   021184E7           STR      R1,[R4, +R2, LSL #+2]
    648                  Off++;
   \   000001F0   012082E2           ADD      R2,R2,#+1
    649                }
    650                //
    651                // Complete DWORDS
    652                //
    653                while (xsize >= 4) {
   \                     ??_DrawBitLine8BPP_11:
   \   000001F4   04005CE3           CMP      R12,#+4
   \   000001F8   0D0000BA           BLT      ??_DrawBitLine8BPP_15
    654                  ColorMask =  *(p) |
    655                              (*(p + 1) << 8) |
    656                              (*(p + 2) << 16) |
    657                              (*(p + 3) << 24);
    658                  #if (LCD_ENDIAN_BIG == 1)
    659                    MIRROR(ColorMask);
    660                  #endif
    661                  WRITE_MEM32(pContext->VRAMAddr, Off, ColorMask);
   \                     ??_DrawBitLine8BPP_16:
   \   000001FC   0010D3E5           LDRB     R1,[R3, #+0]
   \   00000200   01E0D3E5           LDRB     LR,[R3, #+1]
    662                  p += 4;
    663                  Off++;
    664                  xsize -= 4;
   \   00000204   04C04CE2           SUB      R12,R12,#+4
   \   00000208   04005CE3           CMP      R12,#+4
   \   0000020C   0E1481E1           ORR      R1,R1,LR, LSL #+8
   \   00000210   02E0D3E5           LDRB     LR,[R3, #+2]
   \   00000214   0E1881E1           ORR      R1,R1,LR, LSL #+16
   \   00000218   03E0D3E5           LDRB     LR,[R3, #+3]
   \   0000021C   043083E2           ADD      R3,R3,#+4
   \   00000220   0E1C81E1           ORR      R1,R1,LR, LSL #+24
   \   00000224   00E090E5           LDR      LR,[R0, #+0]
   \   00000228   02118EE7           STR      R1,[LR, +R2, LSL #+2]
   \   0000022C   012082E2           ADD      R2,R2,#+1
   \   00000230   F1FFFFAA           BGE      ??_DrawBitLine8BPP_16
    665                }
    666                //
    667                // Last DWORD
    668                //
    669                if (xsize) {
   \                     ??_DrawBitLine8BPP_15:
   \   00000234   00005CE3           CMP      R12,#+0
   \   00000238   4B00000A           BEQ      ??_DrawBitLine8BPP_8
    670                  ColorMask = i = 0;
    671                  AndMask = 0xFFFFFF00 << (8 * NumPixel_1);
   \   0000023C   FF10E0E3           MVN      R1,#+255
   \   00000240   8551A0E1           LSL      R5,R5,#+3
   \   00000244   1115A0E1           LSL      R1,R1,R5
   \   00000248   0050D3E5           LDRB     R5,[R3, #+0]
   \   0000024C   01C04CE2           SUB      R12,R12,#+1
   \   00000250   00E0A0E3           MOV      LR,#+0
   \   00000254   01001CE3           TST      R12,#0x1
   \   00000258   0040A0E3           MOV      R4,#+0
    672                  while (xsize) {
    673                    Index = *(p++);
    674                    ColorMask |= Index << (8 * i++);
   \   0000025C   05E0A011           MOVNE    LR,R5
   \   00000260   0140A013           MOVNE    R4,#+1
    675                    xsize--;
   \   00000264   0150F315           LDRBNE   R5,[R3, #+1]!
   \   00000268   ACC0B0E1           LSRS     R12,R12,#+1
   \   0000026C   0900000A           BEQ      ??_DrawBitLine8BPP_17
   \                     ??_DrawBitLine8BPP_18:
   \   00000270   8461A0E1           LSL      R6,R4,#+3
   \   00000274   15E68EE1           ORR      LR,LR,R5, LSL R6
   \   00000278   0160F3E5           LDRB     R6,[R3, #+1]!
   \   0000027C   014084E2           ADD      R4,R4,#+1
   \   00000280   8451A0E1           LSL      R5,R4,#+3
   \   00000284   16E58EE1           ORR      LR,LR,R6, LSL R5
   \   00000288   014084E2           ADD      R4,R4,#+1
   \   0000028C   0150F3E5           LDRB     R5,[R3, #+1]!
   \   00000290   01C05CE2           SUBS     R12,R12,#+1
   \   00000294   F5FFFF1A           BNE      ??_DrawBitLine8BPP_18
   \                     ??_DrawBitLine8BPP_17:
   \   00000298   8431A0E1           LSL      R3,R4,#+3
   \   0000029C   15638EE1           ORR      R6,LR,R5, LSL R3
   \   000002A0   ADFFFFEA           B        ??_DrawBitLine8BPP_10
    676                  }
    677                  #if (LCD_ENDIAN_BIG == 1)
    678                    MIRROR(AndMask);
    679                    MIRROR(ColorMask);
    680                  #endif
    681                  Data = READ_MEM32(pContext->VRAMAddr, Off);
    682                  Data &= AndMask;
    683                  Data |= ColorMask;
    684                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    685                }
    686              }
    687            } else {
    688              //
    689              // Handle transparent bitmap with palette
    690              //
    691              if (pTrans) {
   \                     ??_DrawBitLine8BPP_0:
   \   000002A4   00005EE3           CMP      LR,#+0
   \   000002A8   1800000A           BEQ      ??_DrawBitLine8BPP_19
   \   000002AC   01005CE3           CMP      R12,#+1
   \   000002B0   2D0000BA           BLT      ??_DrawBitLine8BPP_8
   \   000002B4   FF40A0E3           MOV      R4,#+255
    692                while (xsize > 0) {
    693                  pixel = *p;
   \                     ??_DrawBitLine8BPP_20:
   \   000002B8   0050D3E5           LDRB     R5,[R3, #+0]
    694                  if (pixel != 0) {
   \   000002BC   000055E3           CMP      R5,#+0
   \   000002C0   0D00000A           BEQ      ??_DrawBitLine8BPP_21
    695                    _SetPixelIndex(pDevice, x + 0, y, *(pTrans + pixel));
   \   000002C4   086090E5           LDR      R6,[R0, #+8]
   \   000002C8   05519EE7           LDR      R5,[LR, +R5, LSL #+2]
   \   000002CC   147096E5           LDR      R7,[R6, #+20]
   \   000002D0   006096E5           LDR      R6,[R6, #+0]
   \   000002D4   C770A0E1           ASR      R7,R7,#+1
   \   000002D8   970208E0           MUL      R8,R7,R2
   \   000002DC   017001E2           AND      R7,R1,#0x1
   \   000002E0   A18088E0           ADD      R8,R8,R1, LSR #+1
   \   000002E4   8880A0E1           LSL      R8,R8,#+1
   \   000002E8   B69098E1           LDRH     R9,[R8, +R6]
   \   000002EC   8771A0E1           LSL      R7,R7,#+3
   \   000002F0   1497C9E1           BIC      R9,R9,R4, LSL R7
   \   000002F4   155789E1           ORR      R5,R9,R5, LSL R7
   \   000002F8   B65088E1           STRH     R5,[R8, +R6]
    696                  }
    697                  xsize--;
    698                  x++;
   \                     ??_DrawBitLine8BPP_21:
   \   000002FC   011081E2           ADD      R1,R1,#+1
    699                  p++;
   \   00000300   013083E2           ADD      R3,R3,#+1
   \   00000304   01C05CE2           SUBS     R12,R12,#+1
    700                }
   \   00000308   EAFFFF1A           BNE      ??_DrawBitLine8BPP_20
   \   0000030C   160000EA           B        ??_DrawBitLine8BPP_8
    701              //
    702              // Handle transparent bitmap without palette
    703              //
    704              } else {
   \                     ??_DrawBitLine8BPP_19:
   \   00000310   01005CE3           CMP      R12,#+1
   \   00000314   140000BA           BLT      ??_DrawBitLine8BPP_8
   \   00000318   FF40A0E3           MOV      R4,#+255
    705                while (xsize > 0) {
    706                  pixel = *p;
   \                     ??_DrawBitLine8BPP_22:
   \   0000031C   0050D3E5           LDRB     R5,[R3, #+0]
    707                  if (pixel != 0) {
   \   00000320   000055E3           CMP      R5,#+0
   \   00000324   0C00000A           BEQ      ??_DrawBitLine8BPP_23
    708                    _SetPixelIndex(pDevice, x + 0, y, pixel);
   \   00000328   08E090E5           LDR      LR,[R0, #+8]
   \   0000032C   14609EE5           LDR      R6,[LR, #+20]
   \   00000330   00E09EE5           LDR      LR,[LR, #+0]
   \   00000334   C660A0E1           ASR      R6,R6,#+1
   \   00000338   960207E0           MUL      R7,R6,R2
   \   0000033C   016001E2           AND      R6,R1,#0x1
   \   00000340   A17087E0           ADD      R7,R7,R1, LSR #+1
   \   00000344   8770A0E1           LSL      R7,R7,#+1
   \   00000348   BE8097E1           LDRH     R8,[R7, +LR]
   \   0000034C   8661A0E1           LSL      R6,R6,#+3
   \   00000350   1486C8E1           BIC      R8,R8,R4, LSL R6
   \   00000354   155688E1           ORR      R5,R8,R5, LSL R6
   \   00000358   BE5087E1           STRH     R5,[R7, +LR]
    709                  }
    710                  xsize--;
    711                  x++;
   \                     ??_DrawBitLine8BPP_23:
   \   0000035C   011081E2           ADD      R1,R1,#+1
    712                  p++;
   \   00000360   013083E2           ADD      R3,R3,#+1
   \   00000364   01C05CE2           SUBS     R12,R12,#+1
    713                }
   \   00000368   EBFFFF1A           BNE      ??_DrawBitLine8BPP_22
    714              }
    715            }
    716          }
   \                     ??_DrawBitLine8BPP_8:
   \   0000036C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000370   F083BDE8           POP      {R4-R9,PC}       ;; return
    717          
    718          /*********************************************************************
    719          *
    720          *       _DrawBitmap
    721          */

   \                                 In section .text, align 4, keep-with-next
    722          static void _DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0,
    723                                 int xSize, int ySize,
    724                                 int BitsPerPixel, 
    725                                 int BytesPerLine,
    726                                 const U8 GUI_UNI_PTR * pData, int Diff,
    727                                 const LCD_PIXELINDEX* pTrans) {
   \                     _DrawBitmap:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   3C109DE5           LDR      R1,[SP, #+60]
   \   00000010   0040A0E1           MOV      R4,R0
    728            int i;
    729          
    730            switch (BitsPerPixel) {
   \   00000014   011041E2           SUB      R1,R1,#+1
   \   00000018   0360A0E1           MOV      R6,R3
   \   0000001C   38009DE5           LDR      R0,[SP, #+56]
   \   00000020   40709DE5           LDR      R7,[SP, #+64]
   \   00000024   44809DE5           LDR      R8,[SP, #+68]
   \   00000028   48909DE5           LDR      R9,[SP, #+72]
   \   0000002C   4CA09DE5           LDR      R10,[SP, #+76]
   \   00000030   070051E3           CMP      R1,#+7
   \   00000034   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitmap_0:
   \   00000038   B200008A           BHI      ??_DrawBitmap_1
   \   0000003C   060000EA           B        ??_DrawBitmap_2
   \   00000040   320000EA           B        ??_DrawBitmap_3
   \   00000044   AF0000EA           B        ??_DrawBitmap_1
   \   00000048   5D0000EA           B        ??_DrawBitmap_4
   \   0000004C   AD0000EA           B        ??_DrawBitmap_1
   \   00000050   AC0000EA           B        ??_DrawBitmap_1
   \   00000054   AB0000EA           B        ??_DrawBitmap_1
   \   00000058   860000EA           B        ??_DrawBitmap_5
    731            case 1:
    732              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_2:
   \   0000005C   010050E3           CMP      R0,#+1
   \   00000060   A80000BA           BLT      ??_DrawBitmap_1
   \   00000064   02B0A0E1           MOV      R11,R2
   \   00000068   10008DE5           STR      R0,[SP, #+16]
   \   0000006C   010010E3           TST      R0,#0x1
   \   00000070   0800000A           BEQ      ??_DrawBitmap_6
    733                _DrawBitLine1BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   00000074   08A08DE5           STR      R10,[SP, #+8]
   \   00000078   04608DE5           STR      R6,[SP, #+4]
   \   0000007C   00908DE5           STR      R9,[SP, #+0]
   \   00000080   0830A0E1           MOV      R3,R8
   \   00000084   0510A0E1           MOV      R1,R5
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   ........           BL       _DrawBitLine1BPP
    734                pData += BytesPerLine;
   \   00000090   088087E0           ADD      R8,R7,R8
   \   00000094   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_6:
   \   00000098   10109DE5           LDR      R1,[SP, #+16]
   \   0000009C   A110A0E1           LSR      R1,R1,#+1
   \   000000A0   0C108DE5           STR      R1,[SP, #+12]
   \   000000A4   000051E3           CMP      R1,#+0
   \   000000A8   9600000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_7:
   \   000000AC   08A08DE5           STR      R10,[SP, #+8]
   \   000000B0   04608DE5           STR      R6,[SP, #+4]
   \   000000B4   00908DE5           STR      R9,[SP, #+0]
   \   000000B8   0830A0E1           MOV      R3,R8
   \   000000BC   0B20A0E1           MOV      R2,R11
   \   000000C0   0510A0E1           MOV      R1,R5
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   ........           BL       _DrawBitLine1BPP
   \   000000CC   088087E0           ADD      R8,R7,R8
   \   000000D0   08A08DE5           STR      R10,[SP, #+8]
   \   000000D4   04608DE5           STR      R6,[SP, #+4]
   \   000000D8   00908DE5           STR      R9,[SP, #+0]
   \   000000DC   0830A0E1           MOV      R3,R8
   \   000000E0   01208BE2           ADD      R2,R11,#+1
   \   000000E4   0510A0E1           MOV      R1,R5
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       _DrawBitLine1BPP
    735              }
   \   000000F0   0C109DE5           LDR      R1,[SP, #+12]
   \   000000F4   088087E0           ADD      R8,R7,R8
   \   000000F8   011041E2           SUB      R1,R1,#+1
   \   000000FC   0C108DE5           STR      R1,[SP, #+12]
   \   00000100   02B08BE2           ADD      R11,R11,#+2
   \   00000104   000051E3           CMP      R1,#+0
   \   00000108   E7FFFF1A           BNE      ??_DrawBitmap_7
   \   0000010C   7D0000EA           B        ??_DrawBitmap_1
    736              break;
    737            case 2:
    738              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_3:
   \   00000110   010050E3           CMP      R0,#+1
   \   00000114   7B0000BA           BLT      ??_DrawBitmap_1
   \   00000118   02B0A0E1           MOV      R11,R2
   \   0000011C   10008DE5           STR      R0,[SP, #+16]
   \   00000120   010010E3           TST      R0,#0x1
   \   00000124   0800000A           BEQ      ??_DrawBitmap_8
    739                _DrawBitLine2BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   00000128   08A08DE5           STR      R10,[SP, #+8]
   \   0000012C   04608DE5           STR      R6,[SP, #+4]
   \   00000130   00908DE5           STR      R9,[SP, #+0]
   \   00000134   0830A0E1           MOV      R3,R8
   \   00000138   0510A0E1           MOV      R1,R5
   \   0000013C   0400A0E1           MOV      R0,R4
   \   00000140   ........           BL       _DrawBitLine2BPP
    740                pData += BytesPerLine;
   \   00000144   088087E0           ADD      R8,R7,R8
   \   00000148   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_8:
   \   0000014C   10109DE5           LDR      R1,[SP, #+16]
   \   00000150   A110A0E1           LSR      R1,R1,#+1
   \   00000154   0C108DE5           STR      R1,[SP, #+12]
   \   00000158   000051E3           CMP      R1,#+0
   \   0000015C   6900000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_9:
   \   00000160   08A08DE5           STR      R10,[SP, #+8]
   \   00000164   04608DE5           STR      R6,[SP, #+4]
   \   00000168   00908DE5           STR      R9,[SP, #+0]
   \   0000016C   0830A0E1           MOV      R3,R8
   \   00000170   0B20A0E1           MOV      R2,R11
   \   00000174   0510A0E1           MOV      R1,R5
   \   00000178   0400A0E1           MOV      R0,R4
   \   0000017C   ........           BL       _DrawBitLine2BPP
   \   00000180   088087E0           ADD      R8,R7,R8
   \   00000184   08A08DE5           STR      R10,[SP, #+8]
   \   00000188   04608DE5           STR      R6,[SP, #+4]
   \   0000018C   00908DE5           STR      R9,[SP, #+0]
   \   00000190   0830A0E1           MOV      R3,R8
   \   00000194   01208BE2           ADD      R2,R11,#+1
   \   00000198   0510A0E1           MOV      R1,R5
   \   0000019C   0400A0E1           MOV      R0,R4
   \   000001A0   ........           BL       _DrawBitLine2BPP
    741              }
   \   000001A4   0C109DE5           LDR      R1,[SP, #+12]
   \   000001A8   088087E0           ADD      R8,R7,R8
   \   000001AC   011041E2           SUB      R1,R1,#+1
   \   000001B0   0C108DE5           STR      R1,[SP, #+12]
   \   000001B4   02B08BE2           ADD      R11,R11,#+2
   \   000001B8   000051E3           CMP      R1,#+0
   \   000001BC   E7FFFF1A           BNE      ??_DrawBitmap_9
   \   000001C0   500000EA           B        ??_DrawBitmap_1
    742              break;
    743            case 4:
    744              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_4:
   \   000001C4   010050E3           CMP      R0,#+1
   \   000001C8   4E0000BA           BLT      ??_DrawBitmap_1
   \   000001CC   02B0A0E1           MOV      R11,R2
   \   000001D0   10008DE5           STR      R0,[SP, #+16]
   \   000001D4   010010E3           TST      R0,#0x1
   \   000001D8   0800000A           BEQ      ??_DrawBitmap_10
    745                _DrawBitLine4BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   000001DC   08A08DE5           STR      R10,[SP, #+8]
   \   000001E0   04608DE5           STR      R6,[SP, #+4]
   \   000001E4   00908DE5           STR      R9,[SP, #+0]
   \   000001E8   0830A0E1           MOV      R3,R8
   \   000001EC   0510A0E1           MOV      R1,R5
   \   000001F0   0400A0E1           MOV      R0,R4
   \   000001F4   ........           BL       _DrawBitLine4BPP
    746                pData += BytesPerLine;
   \   000001F8   088087E0           ADD      R8,R7,R8
   \   000001FC   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_10:
   \   00000200   10109DE5           LDR      R1,[SP, #+16]
   \   00000204   A110A0E1           LSR      R1,R1,#+1
   \   00000208   0C108DE5           STR      R1,[SP, #+12]
   \   0000020C   000051E3           CMP      R1,#+0
   \   00000210   3C00000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_11:
   \   00000214   08A08DE5           STR      R10,[SP, #+8]
   \   00000218   04608DE5           STR      R6,[SP, #+4]
   \   0000021C   00908DE5           STR      R9,[SP, #+0]
   \   00000220   0830A0E1           MOV      R3,R8
   \   00000224   0B20A0E1           MOV      R2,R11
   \   00000228   0510A0E1           MOV      R1,R5
   \   0000022C   0400A0E1           MOV      R0,R4
   \   00000230   ........           BL       _DrawBitLine4BPP
   \   00000234   088087E0           ADD      R8,R7,R8
   \   00000238   08A08DE5           STR      R10,[SP, #+8]
   \   0000023C   04608DE5           STR      R6,[SP, #+4]
   \   00000240   00908DE5           STR      R9,[SP, #+0]
   \   00000244   0830A0E1           MOV      R3,R8
   \   00000248   01208BE2           ADD      R2,R11,#+1
   \   0000024C   0510A0E1           MOV      R1,R5
   \   00000250   0400A0E1           MOV      R0,R4
   \   00000254   ........           BL       _DrawBitLine4BPP
    747              }
   \   00000258   0C109DE5           LDR      R1,[SP, #+12]
   \   0000025C   088087E0           ADD      R8,R7,R8
   \   00000260   011041E2           SUB      R1,R1,#+1
   \   00000264   0C108DE5           STR      R1,[SP, #+12]
   \   00000268   02B08BE2           ADD      R11,R11,#+2
   \   0000026C   000051E3           CMP      R1,#+0
   \   00000270   E7FFFF1A           BNE      ??_DrawBitmap_11
   \   00000274   230000EA           B        ??_DrawBitmap_1
    748              break;
    749            case 8:
    750              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_5:
   \   00000278   010050E3           CMP      R0,#+1
   \   0000027C   210000BA           BLT      ??_DrawBitmap_1
   \   00000280   00B0A0E1           MOV      R11,R0
   \   00000284   0290A0E1           MOV      R9,R2
   \   00000288   01001BE3           TST      R11,#0x1
   \   0000028C   0700000A           BEQ      ??_DrawBitmap_12
    751                _DrawBitLine8BPP(pDevice, x0, i + y0, pData, xSize, pTrans);
   \   00000290   04A08DE5           STR      R10,[SP, #+4]
   \   00000294   00608DE5           STR      R6,[SP, #+0]
   \   00000298   0830A0E1           MOV      R3,R8
   \   0000029C   0510A0E1           MOV      R1,R5
   \   000002A0   0400A0E1           MOV      R0,R4
   \   000002A4   ........           BL       _DrawBitLine8BPP
    752                pData += BytesPerLine;
   \   000002A8   088087E0           ADD      R8,R7,R8
   \   000002AC   019089E2           ADD      R9,R9,#+1
   \                     ??_DrawBitmap_12:
   \   000002B0   ABB0B0E1           LSRS     R11,R11,#+1
   \   000002B4   1300000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_13:
   \   000002B8   04A08DE5           STR      R10,[SP, #+4]
   \   000002BC   00608DE5           STR      R6,[SP, #+0]
   \   000002C0   0830A0E1           MOV      R3,R8
   \   000002C4   0920A0E1           MOV      R2,R9
   \   000002C8   0510A0E1           MOV      R1,R5
   \   000002CC   0400A0E1           MOV      R0,R4
   \   000002D0   ........           BL       _DrawBitLine8BPP
   \   000002D4   088087E0           ADD      R8,R7,R8
   \   000002D8   04A08DE5           STR      R10,[SP, #+4]
   \   000002DC   00608DE5           STR      R6,[SP, #+0]
   \   000002E0   0830A0E1           MOV      R3,R8
   \   000002E4   012089E2           ADD      R2,R9,#+1
   \   000002E8   0510A0E1           MOV      R1,R5
   \   000002EC   0400A0E1           MOV      R0,R4
   \   000002F0   ........           BL       _DrawBitLine8BPP
    753              }
   \   000002F4   01B04BE2           SUB      R11,R11,#+1
   \   000002F8   088087E0           ADD      R8,R7,R8
   \   000002FC   029089E2           ADD      R9,R9,#+2
   \   00000300   00005BE3           CMP      R11,#+0
   \   00000304   EBFFFF1A           BNE      ??_DrawBitmap_13
    754              break;
    755            }
    756          }
   \                     ??_DrawBitmap_1:
   \   00000308   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   0000030C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    757          
    758          /*********************************************************************
    759          *
    760          *       _SetOrg
    761          */

   \                                 In section .text, align 4, keep-with-next
    762          static void _SetOrg(GUI_DEVICE * pDevice, int x, int y) {
   \                     _SetOrg:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    763            LCD_X_SETORG_INFO Data = {0};
   \   00000004   ............       ADRL     R12,`?<Constant {0}>`
   \              ....        
   \   0000000C   0CD04DE2           SUB      SP,SP,#+12
   \   00000010   00409CE5           LDR      R4,[R12, #+0]
   \   00000014   04509CE5           LDR      R5,[R12, #+4]
   \   00000018   0D30A0E1           MOV      R3,SP
   \   0000001C   300083E8           STM      R3,{R4,R5}
    764          
    765            #ifdef WIN32
    766              LCDSIM_SetOrg(x, y, pDevice->LayerIndex);
    767            #else
    768              Data.xPos = x;
   \   00000020   00108DE5           STR      R1,[SP, #+0]
    769              Data.yPos = y;
   \   00000024   04208DE5           STR      R2,[SP, #+4]
    770              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETORG, (void *)&Data);
   \   00000028   0D20A0E1           MOV      R2,SP
   \   0000002C   0310A0E3           MOV      R1,#+3
   \   00000030   180090E5           LDR      R0,[R0, #+24]
   \   00000034   ........           BL       LCD_X_DisplayDriver
    771            #endif
    772          }
   \   00000038   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   0000003C   3080BDE8           POP      {R4,R5,PC}       ;; return
    773          
    774          /*********************************************************************
    775          *
    776          *       _InitOnce
    777          *
    778          * Purpose:
    779          *   Allocates a fixed block for the context of the driver
    780          *
    781          * Return value:
    782          *   0 on success, 1 on error
    783          */
    784          static int _InitOnce(GUI_DEVICE * pDevice) {
    785            if (pDevice->u.pContext == NULL) {
    786              pDevice->u.pContext = GUI_ALLOC_GetFixedBlock(sizeof(DRIVER_CONTEXT));
    787              GUI__memset((U8 *)pDevice->u.pContext, 0, sizeof(DRIVER_CONTEXT));
    788            }
    789            return pDevice->u.pContext ? 0 : 1;
    790          }
    791          
    792          /*********************************************************************
    793          *
    794          *       _GetRect
    795          */

   \                                 In section .text, align 4, keep-with-next
    796          static void _GetRect(GUI_DEVICE * pDevice, LCD_RECT * pRect) {
    797            DRIVER_CONTEXT * pContext;
    798          
    799            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetRect:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    800            pRect->x0 = 0;
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   B020C1E1           STRH     R2,[R1, #+0]
    801            pRect->y0 = 0;
   \   0000000C   B220C1E1           STRH     R2,[R1, #+2]
    802            pRect->x1 = pContext->vxSize - 1;
   \   00000010   0C2090E5           LDR      R2,[R0, #+12]
   \   00000014   012042E2           SUB      R2,R2,#+1
   \   00000018   B420C1E1           STRH     R2,[R1, #+4]
    803            pRect->y1 = pContext->vySize - 1;
   \   0000001C   100090E5           LDR      R0,[R0, #+16]
   \   00000020   010040E2           SUB      R0,R0,#+1
   \   00000024   B600C1E1           STRH     R0,[R1, #+6]
    804          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
    805          
    806          /*********************************************************************
    807          *
    808          *       _GetDevProp
    809          */

   \                                 In section .text, align 4, keep-with-next
    810          static I32 _GetDevProp(GUI_DEVICE * pDevice, int Index) {
    811            DRIVER_CONTEXT * pContext;
    812          
    813            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    814            switch (Index) {
   \                     _GetDevProp:
   \   00000000   011041E2           SUB      R1,R1,#+1
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   0D0051E3           CMP      R1,#+13
   \   0000000C   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevProp_0:
   \   00000010   1D00008A           BHI      ??_GetDevProp_1
   \   00000014   0C0000EA           B        ??_GetDevProp_2
   \   00000018   0D0000EA           B        ??_GetDevProp_3
   \   0000001C   0E0000EA           B        ??_GetDevProp_4
   \   00000020   0F0000EA           B        ??_GetDevProp_5
   \   00000024   180000EA           B        ??_GetDevProp_1
   \   00000028   170000EA           B        ??_GetDevProp_1
   \   0000002C   160000EA           B        ??_GetDevProp_1
   \   00000030   0D0000EA           B        ??_GetDevProp_6
   \   00000034   0E0000EA           B        ??_GetDevProp_7
   \   00000038   0F0000EA           B        ??_GetDevProp_8
   \   0000003C   0E0000EA           B        ??_GetDevProp_8
   \   00000040   0F0000EA           B        ??_GetDevProp_9
   \   00000044   0E0000EA           B        ??_GetDevProp_9
   \   00000048   0D0000EA           B        ??_GetDevProp_9
    815            case LCD_DEVCAP_XSIZE:
    816              return pContext->xSize;
   \                     ??_GetDevProp_2:
   \   0000004C   040090E5           LDR      R0,[R0, #+4]
   \   00000050   1EFF2FE1           BX       LR
    817            case LCD_DEVCAP_YSIZE:
    818              return pContext->ySize;
   \                     ??_GetDevProp_3:
   \   00000054   080090E5           LDR      R0,[R0, #+8]
   \   00000058   1EFF2FE1           BX       LR
    819            case LCD_DEVCAP_VXSIZE:
    820              return pContext->vxSize;
   \                     ??_GetDevProp_4:
   \   0000005C   0C0090E5           LDR      R0,[R0, #+12]
   \   00000060   1EFF2FE1           BX       LR
    821            case LCD_DEVCAP_VYSIZE:
    822              return pContext->vySize;
   \                     ??_GetDevProp_5:
   \   00000064   100090E5           LDR      R0,[R0, #+16]
   \   00000068   1EFF2FE1           BX       LR
    823            case LCD_DEVCAP_BITSPERPIXEL:
    824              return 8;
   \                     ??_GetDevProp_6:
   \   0000006C   0800A0E3           MOV      R0,#+8
   \   00000070   1EFF2FE1           BX       LR
    825            case LCD_DEVCAP_NUMCOLORS:
    826              return 256;
   \                     ??_GetDevProp_7:
   \   00000074   400FA0E3           MOV      R0,#+256
   \   00000078   1EFF2FE1           BX       LR
    827            case LCD_DEVCAP_XMAG:
    828              return 1;
   \                     ??_GetDevProp_8:
   \   0000007C   0100A0E3           MOV      R0,#+1
   \   00000080   1EFF2FE1           BX       LR
    829            case LCD_DEVCAP_YMAG:
    830              return 1;
    831            case LCD_DEVCAP_MIRROR_X:
    832              return 0;
   \                     ??_GetDevProp_9:
   \   00000084   0000A0E3           MOV      R0,#+0
   \   00000088   1EFF2FE1           BX       LR
    833            case LCD_DEVCAP_MIRROR_Y:
    834              return 0;
    835            case LCD_DEVCAP_SWAP_XY:
    836              return 0;
    837            }
    838            return -1;
   \                     ??_GetDevProp_1:
   \   0000008C   0000E0E3           MVN      R0,#+0
   \   00000090   1EFF2FE1           BX       LR               ;; return
    839          }
    840          
    841          /*********************************************************************
    842          *
    843          *       _GetDevData
    844          */

   \                                 In section .text, align 4, keep-with-next
    845          static void * _GetDevData(GUI_DEVICE * pDevice, int Index) {
    846            DRIVER_CONTEXT * pContext;
    847          
    848            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    849            switch (Index) {
   \                     _GetDevData:
   \   00000000   010051E3           CMP      R1,#+1
   \   00000004   0300000A           BEQ      ??_GetDevData_0
   \   00000008   0700003A           BCC      ??_GetDevData_1
   \   0000000C   020051E3           CMP      R1,#+2
   \   00000010   0200000A           BEQ      ??_GetDevData_2
   \   00000014   040000EA           B        ??_GetDevData_1
    850            #if GUI_SUPPORT_MEMDEV
    851              case LCD_DEVDATA_MEMDEV:
    852                return (void *)&GUI_MEMDEV_DEVICE_8;
   \                     ??_GetDevData_0:
   \   00000018   ........           LDR      R0,??DataTable16
   \   0000001C   1EFF2FE1           BX       LR
    853            #endif
    854            case LCD_DEVDATA_PHYSPAL:
    855              return  (void *)pContext->aColor;
   \                     ??_GetDevData_2:
   \   00000020   080090E5           LDR      R0,[R0, #+8]
   \   00000024   2C0080E2           ADD      R0,R0,#+44
   \   00000028   1EFF2FE1           BX       LR
    856            }
    857            return NULL;
   \                     ??_GetDevData_1:
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   1EFF2FE1           BX       LR               ;; return
    858          }
    859          
    860          /*********************************************************************
    861          *
    862          *       Static code: Functions available by _GetDevFunc()
    863          *
    864          **********************************************************************
    865          */
    866          /*********************************************************************
    867          *
    868          *       _SetVRAMAddr
    869          */

   \                                 In section .text, align 4, keep-with-next
    870          static void _SetVRAMAddr(GUI_DEVICE * pDevice, void * pVRAM) {
   \                     _SetVRAMAddr:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    871            DRIVER_CONTEXT * pContext;
    872            LCD_X_SETVRAMADDR_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {(void *)0}>`
   \              ....        
   \   00000010   08D04DE2           SUB      SP,SP,#+8
   \   00000014   001091E5           LDR      R1,[R1, #+0]
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
    873          
    874            _InitOnce(pDevice);
   \   00000020   080094E5           LDR      R0,[R4, #+8]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0700001A           BNE      ??_SetVRAMAddr_0
   \   0000002C   2C60A0E3           MOV      R6,#+44
   \   00000030   406E86E3           ORR      R6,R6,#0x400
   \   00000034   0600A0E1           MOV      R0,R6
   \   00000038   ........           BL       GUI_ALLOC_GetFixedBlock
   \   0000003C   080084E5           STR      R0,[R4, #+8]
   \   00000040   0620A0E1           MOV      R2,R6
   \   00000044   0010A0E3           MOV      R1,#+0
   \   00000048   ........           BL       GUI__memset
    875            if (pDevice->u.pContext) {
   \                     ??_SetVRAMAddr_0:
   \   0000004C   080094E5           LDR      R0,[R4, #+8]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0500000A           BEQ      ??_SetVRAMAddr_1
    876              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    877              pContext->VRAMAddr = (U32)pVRAM;
   \   00000058   005080E5           STR      R5,[R0, #+0]
    878              Data.pVRAM = pVRAM;
   \   0000005C   00508DE5           STR      R5,[SP, #+0]
    879              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVRAMADDR, (void *)&Data);
   \   00000060   0D20A0E1           MOV      R2,SP
   \   00000064   0210A0E3           MOV      R1,#+2
   \   00000068   180094E5           LDR      R0,[R4, #+24]
   \   0000006C   ........           BL       LCD_X_DisplayDriver
    880            }
    881            #ifdef WIN32
    882              SIM_Lin_SetVRAMAddr(pDevice->LayerIndex, pVRAM);
    883            #endif
    884          }
   \                     ??_SetVRAMAddr_1:
   \   00000070   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000074   7080BDE8           POP      {R4-R6,PC}       ;; return
    885          
    886          /*********************************************************************
    887          *
    888          *       _SetVSize
    889          */

   \                                 In section .text, align 4, keep-with-next
    890          static void _SetVSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetVSize:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    891            DRIVER_CONTEXT * pContext;
    892          
    893            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0700001A           BNE      ??_SetVSize_0
   \   00000020   2C70A0E3           MOV      R7,#+44
   \   00000024   407E87E3           ORR      R7,R7,#0x400
   \   00000028   0700A0E1           MOV      R0,R7
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   0720A0E1           MOV      R2,R7
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
    894            if (pDevice->u.pContext) {
   \                     ??_SetVSize_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
    895              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    896              pContext->vxSize = xSize;
    897              pContext->vySize = ySize;
    898              pContext->vxSizePhys = xSize;
    899            }
    900            #ifdef WIN32
    901              SIM_Lin_SetVRAMSize(pDevice->LayerIndex, xSize, ySize);
    902            #endif
    903          }
   \   00000044   04D08DE2           ADD      SP,SP,#+4
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0C508015           STRNE    R5,[R0, #+12]
   \   00000050   10608015           STRNE    R6,[R0, #+16]
   \   00000054   14508015           STRNE    R5,[R0, #+20]
   \   00000058   F080BDE8           POP      {R4-R7,PC}       ;; return
    904          
    905          /*********************************************************************
    906          *
    907          *       _SetSize
    908          */

   \                                 In section .text, align 4, keep-with-next
    909          static void _SetSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetSize:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    910            DRIVER_CONTEXT * pContext;
    911            LCD_X_SETSIZE_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_1`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   0CD04DE2           SUB      SP,SP,#+12
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
    912          
    913            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0700001A           BNE      ??_SetSize_0
   \   00000038   2C70A0E3           MOV      R7,#+44
   \   0000003C   407E87E3           ORR      R7,R7,#0x400
   \   00000040   0700A0E1           MOV      R0,R7
   \   00000044   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000048   080084E5           STR      R0,[R4, #+8]
   \   0000004C   0720A0E1           MOV      R2,R7
   \   00000050   0010A0E3           MOV      R1,#+0
   \   00000054   ........           BL       GUI__memset
    914            if (pDevice->u.pContext) {
   \                     ??_SetSize_0:
   \   00000058   080094E5           LDR      R0,[R4, #+8]
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   0A00000A           BEQ      ??_SetSize_1
    915              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    916              if (pContext->vxSizePhys == 0) {
   \   00000064   141090E5           LDR      R1,[R0, #+20]
    917                pContext->vxSizePhys = xSize;
    918              }
    919              pContext->xSize = xSize;
    920              pContext->ySize = ySize;
    921              Data.xSize = xSize;
    922              Data.ySize = ySize;
    923              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETSIZE, (void *)&Data);
   \   00000068   0D20A0E1           MOV      R2,SP
   \   0000006C   000051E3           CMP      R1,#+0
   \   00000070   14508005           STREQ    R5,[R0, #+20]
   \   00000074   045080E5           STR      R5,[R0, #+4]
   \   00000078   086080E5           STR      R6,[R0, #+8]
   \   0000007C   00508DE5           STR      R5,[SP, #+0]
   \   00000080   04608DE5           STR      R6,[SP, #+4]
   \   00000084   0710A0E3           MOV      R1,#+7
   \   00000088   180094E5           LDR      R0,[R4, #+24]
   \   0000008C   ........           BL       LCD_X_DisplayDriver
    924            }
    925          }
   \                     ??_SetSize_1:
   \   00000090   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000094   F080BDE8           POP      {R4-R7,PC}       ;; return
    926          
    927          /*********************************************************************
    928          *
    929          *       _SetPos
    930          */

   \                                 In section .text, align 4, keep-with-next
    931          static void _SetPos(GUI_DEVICE * pDevice, int xPos, int yPos) {
   \                     _SetPos:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    932            DRIVER_CONTEXT * pContext;
    933            LCD_X_SETPOS_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_2`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   0CD04DE2           SUB      SP,SP,#+12
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
    934          
    935            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0700001A           BNE      ??_SetPos_0
   \   00000038   2C70A0E3           MOV      R7,#+44
   \   0000003C   407E87E3           ORR      R7,R7,#0x400
   \   00000040   0700A0E1           MOV      R0,R7
   \   00000044   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000048   080084E5           STR      R0,[R4, #+8]
   \   0000004C   0720A0E1           MOV      R2,R7
   \   00000050   0010A0E3           MOV      R1,#+0
   \   00000054   ........           BL       GUI__memset
    936            if (pDevice->u.pContext) {
   \                     ??_SetPos_0:
   \   00000058   080094E5           LDR      R0,[R4, #+8]
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   0700000A           BEQ      ??_SetPos_1
    937              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    938              pContext->xPos = xPos;
   \   00000064   185080E5           STR      R5,[R0, #+24]
    939              pContext->yPos = yPos;
   \   00000068   1C6080E5           STR      R6,[R0, #+28]
    940              Data.xPos = xPos;
   \   0000006C   00508DE5           STR      R5,[SP, #+0]
    941              Data.yPos = yPos;
   \   00000070   04608DE5           STR      R6,[SP, #+4]
    942              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETPOS, (void *)&Data);
   \   00000074   0D20A0E1           MOV      R2,SP
   \   00000078   0810A0E3           MOV      R1,#+8
   \   0000007C   180094E5           LDR      R0,[R4, #+24]
   \   00000080   ........           BL       LCD_X_DisplayDriver
    943            }
    944          }
   \                     ??_SetPos_1:
   \   00000084   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000088   F080BDE8           POP      {R4-R7,PC}       ;; return
    945          
    946          /*********************************************************************
    947          *
    948          *       _GetPos
    949          */

   \                                 In section .text, align 4, keep-with-next
    950          static void _GetPos(GUI_DEVICE * pDevice, int * pxPos, int * pyPos) {
   \                     _GetPos:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    951            DRIVER_CONTEXT * pContext;
    952          
    953            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0700001A           BNE      ??_GetPos_0
   \   00000020   2C70A0E3           MOV      R7,#+44
   \   00000024   407E87E3           ORR      R7,R7,#0x400
   \   00000028   0700A0E1           MOV      R0,R7
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   0720A0E1           MOV      R2,R7
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
    954            if (pDevice->u.pContext) {
   \                     ??_GetPos_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0300000A           BEQ      ??_GetPos_1
    955              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    956              *pxPos = pContext->xPos;
   \   0000004C   181090E5           LDR      R1,[R0, #+24]
   \   00000050   001085E5           STR      R1,[R5, #+0]
    957              *pyPos = pContext->yPos;
   \   00000054   1C0090E5           LDR      R0,[R0, #+28]
   \   00000058   000086E5           STR      R0,[R6, #+0]
    958            }
    959          }
   \                     ??_GetPos_1:
   \   0000005C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000060   F080BDE8           POP      {R4-R7,PC}       ;; return
    960          
    961          /*********************************************************************
    962          *
    963          *       _SetAlpha
    964          */

   \                                 In section .text, align 4, keep-with-next
    965          static void _SetAlpha(GUI_DEVICE * pDevice, int Alpha) {
   \                     _SetAlpha:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    966            DRIVER_CONTEXT * pContext;
    967            LCD_X_SETALPHA_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_3`
   \              ....        
   \   00000010   08D04DE2           SUB      SP,SP,#+8
   \   00000014   001091E5           LDR      R1,[R1, #+0]
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
    968          
    969            _InitOnce(pDevice);
   \   00000020   080094E5           LDR      R0,[R4, #+8]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0700001A           BNE      ??_SetAlpha_0
   \   0000002C   2C60A0E3           MOV      R6,#+44
   \   00000030   406E86E3           ORR      R6,R6,#0x400
   \   00000034   0600A0E1           MOV      R0,R6
   \   00000038   ........           BL       GUI_ALLOC_GetFixedBlock
   \   0000003C   080084E5           STR      R0,[R4, #+8]
   \   00000040   0620A0E1           MOV      R2,R6
   \   00000044   0010A0E3           MOV      R1,#+0
   \   00000048   ........           BL       GUI__memset
    970            if (pDevice->u.pContext) {
   \                     ??_SetAlpha_0:
   \   0000004C   080094E5           LDR      R0,[R4, #+8]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0500000A           BEQ      ??_SetAlpha_1
    971              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    972              pContext->Alpha = Alpha;
   \   00000058   205080E5           STR      R5,[R0, #+32]
    973              Data.Alpha = Alpha;
   \   0000005C   00508DE5           STR      R5,[SP, #+0]
    974              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHA, (void *)&Data);
   \   00000060   0D20A0E1           MOV      R2,SP
   \   00000064   0A10A0E3           MOV      R1,#+10
   \   00000068   180094E5           LDR      R0,[R4, #+24]
   \   0000006C   ........           BL       LCD_X_DisplayDriver
    975            }
    976          }
   \                     ??_SetAlpha_1:
   \   00000070   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000074   7080BDE8           POP      {R4-R6,PC}       ;; return
    977          
    978          /*********************************************************************
    979          *
    980          *       _SetVis
    981          */

   \                                 In section .text, align 4, keep-with-next
    982          static void _SetVis(GUI_DEVICE * pDevice, int OnOff) {
   \                     _SetVis:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    983            DRIVER_CONTEXT * pContext;
    984            LCD_X_SETVIS_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_4`
   \   0000000C   08D04DE2           SUB      SP,SP,#+8
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
    985          
    986            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0700001A           BNE      ??_SetVis_0
   \   00000028   2C60A0E3           MOV      R6,#+44
   \   0000002C   406E86E3           ORR      R6,R6,#0x400
   \   00000030   0600A0E1           MOV      R0,R6
   \   00000034   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000038   080084E5           STR      R0,[R4, #+8]
   \   0000003C   0620A0E1           MOV      R2,R6
   \   00000040   0010A0E3           MOV      R1,#+0
   \   00000044   ........           BL       GUI__memset
    987            if (pDevice->u.pContext) {
   \                     ??_SetVis_0:
   \   00000048   080094E5           LDR      R0,[R4, #+8]
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0500000A           BEQ      ??_SetVis_1
    988              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    989              pContext->IsVisible = OnOff;
   \   00000054   245080E5           STR      R5,[R0, #+36]
    990              Data.OnOff = OnOff;
   \   00000058   00508DE5           STR      R5,[SP, #+0]
    991              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVIS, (void *)&Data);
   \   0000005C   0D20A0E1           MOV      R2,SP
   \   00000060   0910A0E3           MOV      R1,#+9
   \   00000064   180094E5           LDR      R0,[R4, #+24]
   \   00000068   ........           BL       LCD_X_DisplayDriver
    992            }
    993          }
   \                     ??_SetVis_1:
   \   0000006C   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000070   7080BDE8           POP      {R4-R6,PC}       ;; return
    994          
    995          /*********************************************************************
    996          *
    997          *       _Init
    998          */

   \                                 In section .text, align 4, keep-with-next
    999          static int  _Init(GUI_DEVICE * pDevice) {
   \                     _Init:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1000            int r;
   1001          
   1002            r = _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0700001A           BNE      ??_Init_0
   \   00000018   2C50A0E3           MOV      R5,#+44
   \   0000001C   405E85E3           ORR      R5,R5,#0x400
   \   00000020   0500A0E1           MOV      R0,R5
   \   00000024   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000028   080084E5           STR      R0,[R4, #+8]
   \   0000002C   0520A0E1           MOV      R2,R5
   \   00000030   0010A0E3           MOV      R1,#+0
   \   00000034   ........           BL       GUI__memset
   \                     ??_Init_0:
   \   00000038   080094E5           LDR      R0,[R4, #+8]
   1003            r |= LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_INITCONTROLLER, NULL);
   1004            return r;
   \   0000003C   0020A0E3           MOV      R2,#+0
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0150A003           MOVEQ    R5,#+1
   \   00000048   0050A013           MOVNE    R5,#+0
   \   0000004C   0110A0E3           MOV      R1,#+1
   \   00000050   180094E5           LDR      R0,[R4, #+24]
   \   00000054   ........           BL       LCD_X_DisplayDriver
   \   00000058   050080E1           ORR      R0,R0,R5
   \   0000005C   04D08DE2           ADD      SP,SP,#+4
   \   00000060   3080BDE8           POP      {R4,R5,PC}       ;; return
   1005          }
   1006          
   1007          /*********************************************************************
   1008          *
   1009          *       _On
   1010          */

   \                                 In section .text, align 4, keep-with-next
   1011          static void _On (GUI_DEVICE * pDevice) {
   1012            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_ON, NULL);
   \                     _On:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0510A0E3           MOV      R1,#+5
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
   1013          }
   1014          
   1015          /*********************************************************************
   1016          *
   1017          *       _Off
   1018          */

   \                                 In section .text, align 4, keep-with-next
   1019          static void _Off (GUI_DEVICE * pDevice) {
   1020            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_OFF, NULL);
   \                     _Off:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0610A0E3           MOV      R1,#+6
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
   1021          }
   1022          
   1023          /*********************************************************************
   1024          *
   1025          *       _SetLUTEntry
   1026          */

   \                                 In section .text, align 4, keep-with-next
   1027          static void _SetLUTEntry(GUI_DEVICE * pDevice, U8 Pos, LCD_COLOR Color) {
   \                     _SetLUTEntry:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1028            DRIVER_CONTEXT * pContext;
   1029            LCD_X_SETLUTENTRY_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0L}>`
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0CD04DE2           SUB      SP,SP,#+12
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   002091E5           LDR      R2,[R1, #+0]
   \   0000001C   043091E5           LDR      R3,[R1, #+4]
   \   00000020   0D00A0E1           MOV      R0,SP
   \   00000024   0C0080E8           STM      R0,{R2,R3}
   1030          
   1031            _InitOnce(pDevice);
   \   00000028   080094E5           LDR      R0,[R4, #+8]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0700001A           BNE      ??_SetLUTEntry_0
   \   00000034   2C70A0E3           MOV      R7,#+44
   \   00000038   407E87E3           ORR      R7,R7,#0x400
   \   0000003C   0700A0E1           MOV      R0,R7
   \   00000040   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000044   080084E5           STR      R0,[R4, #+8]
   \   00000048   0720A0E1           MOV      R2,R7
   \   0000004C   0010A0E3           MOV      R1,#+0
   \   00000050   ........           BL       GUI__memset
   1032            if (pDevice->u.pContext) {
   \                     ??_SetLUTEntry_0:
   \   00000054   080094E5           LDR      R0,[R4, #+8]
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0700000A           BEQ      ??_SetLUTEntry_1
   1033              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1034              Data.Pos   = Pos;
   \   00000060   0450CDE5           STRB     R5,[SP, #+4]
   1035              Data.Color = Color;
   \   00000064   00608DE5           STR      R6,[SP, #+0]
   1036              pContext->aColor[Pos] = Color;
   \   00000068   050180E0           ADD      R0,R0,R5, LSL #+2
   \   0000006C   2C6080E5           STR      R6,[R0, #+44]
   1037              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETLUTENTRY, (void *)&Data);
   \   00000070   0D20A0E1           MOV      R2,SP
   \   00000074   0410A0E3           MOV      R1,#+4
   \   00000078   180094E5           LDR      R0,[R4, #+24]
   \   0000007C   ........           BL       LCD_X_DisplayDriver
   1038            }
   1039          }
   \                     ??_SetLUTEntry_1:
   \   00000080   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000084   F080BDE8           POP      {R4-R7,PC}       ;; return
   1040          
   1041          /*********************************************************************
   1042          *
   1043          *       _SetAlphaMode
   1044          */

   \                                 In section .text, align 4, keep-with-next
   1045          static void _SetAlphaMode(GUI_DEVICE * pDevice, int AlphaMode) {
   \                     _SetAlphaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1046            LCD_X_SETALPHAMODE_INFO Data = {0};
   1047          
   1048            Data.AlphaMode = AlphaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
   1049            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0B10A0E3           MOV      R1,#+11
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
   1050          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1051          
   1052          /*********************************************************************
   1053          *
   1054          *       _SetChromaMode
   1055          */

   \                                 In section .text, align 4, keep-with-next
   1056          static void _SetChromaMode(GUI_DEVICE * pDevice, int ChromaMode) {
   \                     _SetChromaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1057            LCD_X_SETCHROMAMODE_INFO Data = {0};
   1058          
   1059            Data.ChromaMode = ChromaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
   1060            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0C10A0E3           MOV      R1,#+12
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
   1061          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1062          
   1063          /*********************************************************************
   1064          *
   1065          *       _SetChroma
   1066          */

   \                                 In section .text, align 4, keep-with-next
   1067          static void _SetChroma(GUI_DEVICE * pDevice, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax) {
   \                     _SetChroma:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1068            LCD_X_SETCHROMA_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>_1`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
   1069          
   1070            Data.ChromaMin = ChromaMin;
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
   1071            Data.ChromaMax = ChromaMax;
   \   00000020   04208DE5           STR      R2,[SP, #+4]
   1072            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMA, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0D10A0E3           MOV      R1,#+13
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
   1073          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
   1074          
   1075          /*********************************************************************
   1076          *
   1077          *       _SetFunc
   1078          */

   \                                 In section .text, align 4, keep-with-next
   1079          static void _SetFunc(GUI_DEVICE * pDevice, int Index, void (* pFunc)(void)) {
   \                     _SetFunc:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1080            DRIVER_CONTEXT * pContext;
   1081          
   1082            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0700001A           BNE      ??_SetFunc_0
   \   00000020   2C70A0E3           MOV      R7,#+44
   \   00000024   407E87E3           ORR      R7,R7,#0x400
   \   00000028   0700A0E1           MOV      R0,R7
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   0720A0E1           MOV      R2,R7
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
   1083            if (pDevice->u.pContext) {
   \                     ??_SetFunc_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0100000A           BEQ      ??_SetFunc_1
   1084              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1085              switch (Index) {
   \   0000004C   170055E3           CMP      R5,#+23
   1086              case LCD_DEVFUNC_FILLRECT:
   1087                pContext->pfFillRect = (void (*)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex))pFunc;
   \   00000050   28608005           STREQ    R6,[R0, #+40]
   1088                break;
   1089              }
   1090            }
   1091          }
   \                     ??_SetFunc_1:
   \   00000054   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000058   F080BDE8           POP      {R4-R7,PC}       ;; return
   1092          
   1093          /*********************************************************************
   1094          *
   1095          *       _GetDevFunc
   1096          */

   \                                 In section .text, align 4, keep-with-next
   1097          static void (* _GetDevFunc(GUI_DEVICE ** ppDevice, int Index))(void) {
   1098            GUI_USE_PARA(ppDevice);
   1099            switch (Index) {
   \                     _GetDevFunc:
   \   00000000   021041E2           SUB      R1,R1,#+2
   \   00000004   140051E3           CMP      R1,#+20
   \   00000008   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevFunc_0:
   \   0000000C   3200008A           BHI      ??_GetDevFunc_1
   \   00000010   1D0000EA           B        ??_GetDevFunc_2
   \   00000014   180000EA           B        ??_GetDevFunc_3
   \   00000018   190000EA           B        ??_GetDevFunc_4
   \   0000001C   2E0000EA           B        ??_GetDevFunc_1
   \   00000020   1B0000EA           B        ??_GetDevFunc_5
   \   00000024   2C0000EA           B        ??_GetDevFunc_1
   \   00000028   2B0000EA           B        ??_GetDevFunc_1
   \   0000002C   0C0000EA           B        ??_GetDevFunc_6
   \   00000030   0D0000EA           B        ??_GetDevFunc_7
   \   00000034   0E0000EA           B        ??_GetDevFunc_8
   \   00000038   170000EA           B        ??_GetDevFunc_9
   \   0000003C   260000EA           B        ??_GetDevFunc_1
   \   00000040   170000EA           B        ??_GetDevFunc_10
   \   00000044   180000EA           B        ??_GetDevFunc_11
   \   00000048   190000EA           B        ??_GetDevFunc_12
   \   0000004C   220000EA           B        ??_GetDevFunc_1
   \   00000050   210000EA           B        ??_GetDevFunc_1
   \   00000054   180000EA           B        ??_GetDevFunc_13
   \   00000058   190000EA           B        ??_GetDevFunc_14
   \   0000005C   1A0000EA           B        ??_GetDevFunc_15
   \   00000060   1B0000EA           B        ??_GetDevFunc_16
   1100            case LCD_DEVFUNC_SET_VRAM_ADDR:
   1101              return (void (*)(void))_SetVRAMAddr;
   \                     ??_GetDevFunc_6:
   \   00000064   ........           LDR      R0,??DataTable16_1
   \   00000068   1EFF2FE1           BX       LR
   1102            case LCD_DEVFUNC_SET_VSIZE:
   1103              return (void (*)(void))_SetVSize;
   \                     ??_GetDevFunc_7:
   \   0000006C   ........           LDR      R0,??DataTable16_2
   \   00000070   1EFF2FE1           BX       LR
   1104            case LCD_DEVFUNC_SET_SIZE:
   1105              return (void (*)(void))_SetSize;
   \                     ??_GetDevFunc_8:
   \   00000074   ........           LDR      R0,??DataTable16_3
   \   00000078   1EFF2FE1           BX       LR
   1106            case LCD_DEVFUNC_SETPOS:
   1107              return (void (*)(void))_SetPos;
   \                     ??_GetDevFunc_3:
   \   0000007C   ........           LDR      R0,??DataTable16_4
   \   00000080   1EFF2FE1           BX       LR
   1108            case LCD_DEVFUNC_GETPOS:
   1109              return (void (*)(void))_GetPos;
   \                     ??_GetDevFunc_4:
   \   00000084   ........           LDR      R0,??DataTable16_5
   \   00000088   1EFF2FE1           BX       LR
   1110            case LCD_DEVFUNC_SETALPHA:
   1111              return (void (*)(void))_SetAlpha;
   \                     ??_GetDevFunc_2:
   \   0000008C   ........           LDR      R0,??DataTable16_6
   \   00000090   1EFF2FE1           BX       LR
   1112            case LCD_DEVFUNC_SETVIS:
   1113              return (void (*)(void))_SetVis;
   \                     ??_GetDevFunc_5:
   \   00000094   ........           LDR      R0,??DataTable16_7
   \   00000098   1EFF2FE1           BX       LR
   1114            case LCD_DEVFUNC_INIT:
   1115              return (void (*)(void))_Init;
   \                     ??_GetDevFunc_9:
   \   0000009C   ........           LDR      R0,??DataTable16_8
   \   000000A0   1EFF2FE1           BX       LR
   1116            case LCD_DEVFUNC_ON:
   1117              return (void (*)(void))_On;
   \                     ??_GetDevFunc_10:
   \   000000A4   ........           LDR      R0,??DataTable16_9
   \   000000A8   1EFF2FE1           BX       LR
   1118            case LCD_DEVFUNC_OFF:
   1119              return (void (*)(void))_Off;
   \                     ??_GetDevFunc_11:
   \   000000AC   ........           LDR      R0,??DataTable16_10
   \   000000B0   1EFF2FE1           BX       LR
   1120            case LCD_DEVFUNC_SETLUTENTRY:
   1121              return (void (*)(void))_SetLUTEntry;
   \                     ??_GetDevFunc_12:
   \   000000B4   ........           LDR      R0,??DataTable16_11
   \   000000B8   1EFF2FE1           BX       LR
   1122          
   1123            case LCD_DEVFUNC_ALPHAMODE:
   1124              return (void (*)(void))_SetAlphaMode;
   \                     ??_GetDevFunc_13:
   \   000000BC   ........           LDR      R0,??DataTable16_12
   \   000000C0   1EFF2FE1           BX       LR
   1125            case LCD_DEVFUNC_CHROMAMODE:
   1126              return (void (*)(void))_SetChromaMode;
   \                     ??_GetDevFunc_14:
   \   000000C4   ........           LDR      R0,??DataTable16_13
   \   000000C8   1EFF2FE1           BX       LR
   1127            case LCD_DEVFUNC_CHROMA:
   1128              return (void (*)(void))_SetChroma;
   \                     ??_GetDevFunc_15:
   \   000000CC   ........           LDR      R0,??DataTable16_14
   \   000000D0   1EFF2FE1           BX       LR
   1129            
   1130            case LCD_DEVFUNC_SETFUNC:
   1131              return (void (*)(void))_SetFunc;
   \                     ??_GetDevFunc_16:
   \   000000D4   ........           LDR      R0,??DataTable16_15
   \   000000D8   1EFF2FE1           BX       LR
   1132            }
   1133            return NULL;
   \                     ??_GetDevFunc_1:
   \   000000DC   0000A0E3           MOV      R0,#+0
   \   000000E0   1EFF2FE1           BX       LR               ;; return
   1134          }
   1135          
   1136          /*********************************************************************
   1137          *
   1138          *       Public data
   1139          *
   1140          **********************************************************************
   1141          */
   1142          /*********************************************************************
   1143          *
   1144          *       GUI_DEVICE_API structure
   1145          */

   \                                 In section .rodata, align 4, keep-with-next
   1146          const GUI_DEVICE_API GUIDRV_Lin_8_API = {
   \                     GUIDRV_Lin_8_API:
   \   00000000                      ; Initializer data, 52 bytes
   \   00000000   00000000....       DC32 0, _DrawBitmap, _DrawHLine, _DrawVLine, _FillRect, _GetPixelIndex, _SetPixelIndex, _XorPixel, _SetOrg, _GetDevFunc
   \              ............
   \              ............
   \              ............
   \              ............
   \              ............
   \              ........    
   \   00000028   ............       DC32 _GetDevProp, _GetDevData, _GetRect
   \              ............

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   01010101           DC32     0x1010101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     GUI_MEMDEV_DEVICE_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   ........           DC32     _SetVRAMAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   ........           DC32     _SetVSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   ........           DC32     _SetSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   ........           DC32     _SetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   ........           DC32     _GetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   ........           DC32     _SetAlpha

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   ........           DC32     _SetVis

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   ........           DC32     _Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   ........           DC32     _On

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   ........           DC32     _Off

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   ........           DC32     _SetLUTEntry

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   ........           DC32     _SetAlphaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   ........           DC32     _SetChromaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   ........           DC32     _SetChroma

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   ........           DC32     _SetFunc

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {(void *)0}>`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_2`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_3`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_4`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0
   1147            //
   1148            // Data
   1149            //
   1150            DEVICE_CLASS_DRIVER,
   1151            //
   1152            // Drawing functions
   1153            //
   1154            _DrawBitmap,
   1155            _DrawHLine,
   1156            _DrawVLine,
   1157            _FillRect,
   1158            _GetPixelIndex,
   1159            _SetPixelIndex,
   1160            _XorPixel,
   1161            //
   1162            // Set origin
   1163            //
   1164            _SetOrg,
   1165            //
   1166            // Request information
   1167            //
   1168            _GetDevFunc,
   1169            _GetDevProp,
   1170            _GetDevData,
   1171            _GetRect,
   1172          };
   1173          
   1174          #else
   1175          
   1176          void GUIDRV_Lin_8_C(void);   // Avoid empty object files
   1177          void GUIDRV_Lin_8_C(void) {}
   1178          
   1179          #endif
   1180          
   1181          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     _DrawBitLine1BPP     40
     _DrawBitLine2BPP     36
     _DrawBitLine4BPP     36
     _DrawBitLine8BPP     32
     _DrawBitmap          56
     _DrawHLine           40
     _DrawVLine           32
     _FillRect            24
     _GetDevData           0
     _GetDevFunc           0
     _GetDevProp           0
     _GetPixelIndex        0
     _GetPos              24
     _GetRect              0
     _Init                16
     _Off                  8
     _On                   8
     _SetAlpha            24
     _SetAlphaMode         8
     _SetChroma           24
     _SetChromaMode        8
     _SetFunc             24
     _SetLUTEntry         32
     _SetOrg              24
     _SetPixelIndex        4
     _SetPos              32
     _SetSize             32
     _SetVRAMAddr         24
     _SetVSize            24
     _SetVis              24
     _XorPixel            32


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     _SetPixelIndex            68
     _GetPixelIndex            56
     _XorPixel                136
     _DrawHLine               416
     _DrawVLine               260
     _FillRect                 68
     _DrawBitLine1BPP         816
     _DrawBitLine2BPP         552
     _DrawBitLine4BPP         552
     _DrawBitLine8BPP         884
     _DrawBitmap              784
     _SetOrg                   64
     _GetRect                  44
     _GetDevProp              148
     _GetDevData               52
     _SetVRAMAddr             120
     _SetVSize                 92
     _SetSize                 152
     _SetPos                  140
     _GetPos                  100
     _SetAlpha                120
     _SetVis                  116
     _Init                    100
     _On                       16
     _Off                      16
     _SetLUTEntry             136
     _SetAlphaMode             36
     _SetChromaMode            36
     _SetChroma                60
     _SetFunc                  92
     _GetDevFunc              228
     GUIDRV_Lin_8_API          52
     ??DataTable14              4
     ??DataTable14_1            4
     ??DataTable14_2            4
     ??DataTable16              4
     ??DataTable16_1            4
     ??DataTable16_2            4
     ??DataTable16_3            4
     ??DataTable16_4            4
     ??DataTable16_5            4
     ??DataTable16_6            4
     ??DataTable16_7            4
     ??DataTable16_8            4
     ??DataTable16_9            4
     ??DataTable16_10           4
     ??DataTable16_11           4
     ??DataTable16_12           4
     ??DataTable16_13           4
     ??DataTable16_14           4
     ??DataTable16_15           4
     ?<Constant {0}>            8
     ?<Constant {(void *)0}>    4
     ?<Constant {0}>_1          8
     ?<Constant {0}>_2          8
     ?<Constant {0}>_3          4
     ?<Constant {0}>_4          4
     ?<Constant {0L}>           8
     ?<Constant {0L}>_1         8

 
    52 bytes in section .rodata
 6 588 bytes in section .text
 
 6 588 bytes of CODE  memory
    52 bytes of CONST memory

Errors: none
Warnings: none
