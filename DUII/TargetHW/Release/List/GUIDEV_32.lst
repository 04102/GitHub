###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:08:15 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDEV_32.c                         #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDEV_32.c -D DEBUG=1 -D           #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUIDEV_32.lst              #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUIDEV_32.o                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDEV_32.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDEV_32.c
     19          Purpose     : Implementation of memory devices
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          
     24          #include <string.h>
     25          
     26          #include "GUI_Private.h"
     27          
     28          #if GUI_WINSUPPORT
     29            #include "WM.h"
     30          #endif
     31          
     32          /* Memory device capabilities are compiled only if support for them is enabled.*/ 
     33          #if GUI_SUPPORT_MEMDEV
     34          
     35          /*********************************************************************
     36          *
     37          *       Macros
     38          *
     39          **********************************************************************
     40          */
     41          
     42          #define PIXELINDEX                      U32
     43          #define BITSPERPIXEL                     32
     44          #define API_LIST      GUI_MEMDEV__APIList32
     45          #define DEVICE_API     GUI_MEMDEV_DEVICE_32
     46          
     47          /*********************************************************************
     48          *
     49          *       _DrawBitLine32BPP_DDB
     50          */
     51          static int _GetDistToNextAlpha(const U32 * pSrc, int xsize) {
     52            int Dist = 0;
     53            U8 Alpha;
     54            do {
     55              Alpha = (*(pSrc++)) >> 24;
     56              if (Alpha == 0) {
     57                Dist++;
     58              }
     59            } while ((Alpha == 0) && (--xsize));
     60            return Dist;
     61          }
     62          
     63          /*********************************************************************
     64          *
     65          *       _DrawBitLine32BPP_DDB
     66          */

   \                                 In section .text, align 4, keep-with-next
     67          static void _DrawBitLine32BPP_DDB(GUI_DEVICE * pDevice, GUI_USAGE * pUsage, int x, int y, const U32 * pSrc, int xSize, U32 * pDest) {
   \                     _DrawBitLine32BPP_DDB:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0100A0E1           MOV      R0,R1
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0210A0E1           MOV      R1,R2
   \   00000010   0320A0E1           MOV      R2,R3
   \   00000014   18509DE5           LDR      R5,[SP, #+24]
   \   00000018   1C609DE5           LDR      R6,[SP, #+28]
   \   0000001C   20409DE5           LDR      R4,[SP, #+32]
     68            int Dist;
     69            U8 Alpha;
     70            U32 Color;
     71          
     72            GUI_USE_PARA(pDevice);
     73            if (pUsage) {
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0300000A           BEQ      ??_DrawBitLine32BPP_DDB_0
     74              GUI_USAGE_AddHLine(pUsage, x, y, xSize);
   \   00000028   08C090E5           LDR      R12,[R0, #+8]
   \   0000002C   0630A0E1           MOV      R3,R6
   \   00000030   04C09CE5           LDR      R12,[R12, #+4]
   \   00000034   3CFF2FE1           BLX      R12
     75            }
     76            do {
     77              Dist = _GetDistToNextAlpha(pSrc, xSize);
   \                     ??_DrawBitLine32BPP_DDB_0:
   \   00000038   0600A0E1           MOV      R0,R6
   \   0000003C   0510A0E1           MOV      R1,R5
   \   00000040   0070A0E3           MOV      R7,#+0
   \                     ??_DrawBitLine32BPP_DDB_1:
   \   00000044   042091E4           LDR      R2,[R1], #+4
   \   00000048   222CB0E1           LSRS     R2,R2,#+24
   \   0000004C   0200001A           BNE      ??_DrawBitLine32BPP_DDB_2
   \   00000050   017087E2           ADD      R7,R7,#+1
   \   00000054   010050E2           SUBS     R0,R0,#+1
   \   00000058   F9FFFF1A           BNE      ??_DrawBitLine32BPP_DDB_1
     78              if (Dist) {
   \                     ??_DrawBitLine32BPP_DDB_2:
   \   0000005C   000057E3           CMP      R7,#+0
   \   00000060   0700000A           BEQ      ??_DrawBitLine32BPP_DDB_3
     79                GUI_MEMCPY(pDest, pSrc, Dist * 4);
   \   00000064   0721A0E1           LSL      R2,R7,#+2
   \   00000068   0510A0E1           MOV      R1,R5
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   ........           BL       __aeabi_memcpy4
     80                pDest += Dist;
   \   00000074   074184E0           ADD      R4,R4,R7, LSL #+2
     81                pSrc  += Dist;
   \   00000078   075185E0           ADD      R5,R5,R7, LSL #+2
     82                xSize -= Dist;
   \   0000007C   076046E0           SUB      R6,R6,R7
   \   00000080   0B0000EA           B        ??_DrawBitLine32BPP_DDB_4
     83              } else {
     84                Color = *pSrc;
   \                     ??_DrawBitLine32BPP_DDB_3:
   \   00000084   000095E5           LDR      R0,[R5, #+0]
     85                Alpha = Color >> 24;
   \   00000088   201CA0E1           LSR      R1,R0,#+24
     86                if (Alpha < 255) {
   \   0000008C   FF0051E3           CMP      R1,#+255
   \   00000090   040000AA           BGE      ??_DrawBitLine32BPP_DDB_5
     87                  *pDest = GUI__MixColors(Color, *pDest, 255 - Alpha);
   \   00000094   FF2061E2           RSB      R2,R1,#+255
   \   00000098   FF2002E2           AND      R2,R2,#0xFF
   \   0000009C   001094E5           LDR      R1,[R4, #+0]
   \   000000A0   ........           BL       GUI__MixColors
   \   000000A4   000084E5           STR      R0,[R4, #+0]
     88                }
     89                pDest++;
   \                     ??_DrawBitLine32BPP_DDB_5:
   \   000000A8   044084E2           ADD      R4,R4,#+4
     90                pSrc++;
   \   000000AC   045085E2           ADD      R5,R5,#+4
     91                xSize--;
   \   000000B0   016046E2           SUB      R6,R6,#+1
     92              }
     93            } while (xSize);
   \                     ??_DrawBitLine32BPP_DDB_4:
   \   000000B4   000056E3           CMP      R6,#+0
   \   000000B8   DEFFFF1A           BNE      ??_DrawBitLine32BPP_DDB_0
     94          }
   \   000000BC   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000C0   F080BDE8           POP      {R4-R7,PC}       ;; return
     95          
     96          /*********************************************************************
     97          *
     98          *       _DrawBitLine16BPP
     99          */
    100          static void _DrawBitLine16BPP(GUI_DEVICE * pDevice, GUI_USAGE * pUsage, int x, int y, const U16 * pSrc, int xsize, PIXELINDEX * pDest) {
    101            if (pUsage) {
    102              GUI_USAGE_AddHLine(pUsage, x, y, xsize);
    103            }
    104            do {
    105              U32 Color;
    106              U16 Index;
    107              
    108              Index = *pSrc;
    109              Color = pDevice->pColorConvAPI->pfIndex2Color(Index);
    110              *pDest = Color;
    111              if (pUsage) {
    112                GUI_USAGE_AddPixel(pUsage, x, y);
    113              }
    114              x++;
    115              pDest++;
    116              pSrc++;
    117            } while (--xsize);
    118          }
    119          
    120          /*********************************************************************
    121          *
    122          *       static consts
    123          *
    124          **********************************************************************
    125          */
    126          /*********************************************************************
    127          *
    128          *       ID translation table
    129          *
    130          * This table serves as translation table for DDBs
    131          */

   \                                 In section .text, align 4, keep-with-next
    132          static const LCD_PIXELINDEX aID[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
   \                     aID:
   \   00000000                      ; Initializer data, 64 bytes
   \   00000000   000000000100       DC32 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
   \              000002000000
   \              030000000400
   \              000005000000
   \              060000000700
   \              000008000000
   \              09000000    
   \   00000028   0A0000000B00       DC32 10, 11, 12, 13, 14, 15
   \              00000C000000
   \              0D0000000E00
   \              00000F000000
    133          
    134          /*********************************************************************
    135          *
    136          *       static code
    137          *
    138          **********************************************************************
    139          */
    140          /*********************************************************************
    141          *
    142          *       _XY2PTR
    143          */
    144          static PIXELINDEX* _XY2PTR(int x, int y) {
    145            GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
    146            U8 *pData = (U8*)(pDev + 1);
    147            #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
    148              if ((x >= pDev->x0+pDev->XSize) | (x<pDev->x0) | (y >= pDev->y0+pDev->YSize) | (y<pDev->y0)) {
    149                GUI_DEBUG_ERROROUT2("_XY2PTR: parameters out of bounds",x,y);
    150              }
    151            #endif
    152            pData += (GUI_ALLOC_DATATYPE_U)(y - pDev->y0) * (GUI_ALLOC_DATATYPE_U)pDev->BytesPerLine;
    153            return ((PIXELINDEX*)pData) + x - pDev->x0;
    154          }
    155          
    156          /*********************************************************************
    157          *
    158          *       _DrawBitLine1BPP
    159          */

   \                                 In section .text, align 4, keep-with-next
    160          static void _DrawBitLine1BPP(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * p, int Diff, unsigned int xsize,
    161                                       const LCD_PIXELINDEX* pTrans, GUI_MEMDEV* pDev, PIXELINDEX* pDest)
    162          {
   \                     _DrawBitLine1BPP:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   28609DE5           LDR      R6,[SP, #+40]
    163            PIXELINDEX Index1;
    164            PIXELINDEX IndexMask;
    165            unsigned pixels;
    166            unsigned PixelCnt;
    167          
    168            GUI_USE_PARA(pDevice);
    169            PixelCnt = 8 - Diff;
   \   00000008   ........           LDR      R12,??DataTable11
   \   0000000C   0030D6E5           LDRB     R3,[R6, #+0]
   \   00000010   2C009DE5           LDR      R0,[SP, #+44]
   \   00000014   0140A0E1           MOV      R4,R1
   \   00000018   0C30D3E7           LDRB     R3,[R3, +R12]
   \   0000001C   089060E2           RSB      R9,R0,#+8
   \   00000020   0250A0E1           MOV      R5,R2
   \   00000024   53A0A0E1           ASR      R10,R3,R0
    170            pixels = LCD_aMirror[*p] >> Diff;
    171          
    172            GUI_DEBUG_ERROROUT3_IF( x < pDev->x0, "GUIDEV.c: DrawBitLine1BPP, Act= %d, Border= %d, Clip= %d", x,pDev->x0, GUI_Context.ClipRect.x0);
    173          
    174            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000028   ........           LDR      R0,??DataTable11_1
   \   0000002C   30709DE5           LDR      R7,[SP, #+48]
   \   00000030   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000034   34109DE5           LDR      R1,[SP, #+52]
   \   00000038   38209DE5           LDR      R2,[SP, #+56]
   \   0000003C   030000E2           AND      R0,R0,#0x3
   \   00000040   3C809DE5           LDR      R8,[SP, #+60]
   \   00000044   030050E3           CMP      R0,#+3
   \   00000048   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_DrawBitLine1BPP_0:
   \   0000004C   5300008A           BHI      ??_DrawBitLine1BPP_1
   \   00000050   020000EA           B        ??_DrawBitLine1BPP_2
   \   00000054   3B0000EA           B        ??_DrawBitLine1BPP_3
   \   00000058   0F0000EA           B        ??_DrawBitLine1BPP_4
   \   0000005C   390000EA           B        ??_DrawBitLine1BPP_3
    175            case 0:    /* Write mode */
    176              do {
    177                /* Prepare loop */
    178                if (PixelCnt > xsize) {
   \                     ??_DrawBitLine1BPP_2:
   \   00000060   090057E1           CMP      R7,R9
   \   00000064   0790A091           MOVLS    R9,R7
    179                  PixelCnt = xsize;
    180                }
    181                xsize -= PixelCnt;
   \   00000068   097047E0           SUB      R7,R7,R9
    182                /* Write as many pixels as we are allowed to and have loaded in this inner loop */
    183                do {
    184                  *pDest++ = *(pTrans + (pixels & 1));
   \                     ??_DrawBitLine1BPP_5:
   \   0000006C   01000AE2           AND      R0,R10,#0x1
   \   00000070   000191E7           LDR      R0,[R1, +R0, LSL #+2]
    185                  pixels >>= 1;
   \   00000074   AAA0A0E1           LSR      R10,R10,#+1
   \   00000078   040088E4           STR      R0,[R8], #+4
    186                } while (--PixelCnt);
   \   0000007C   019059E2           SUBS     R9,R9,#+1
   \   00000080   F9FFFF1A           BNE      ??_DrawBitLine1BPP_5
    187                /* Check if an other Source byte needs to be loaded */
    188                if (xsize == 0) {
   \   00000084   000057E3           CMP      R7,#+0
   \   00000088   4400000A           BEQ      ??_DrawBitLine1BPP_1
    189                  return;
    190                }
    191                PixelCnt = 8;
    192                pixels = LCD_aMirror[*++p];
   \   0000008C   0100F6E5           LDRB     R0,[R6, #+1]!
   \   00000090   0890A0E3           MOV      R9,#+8
   \   00000094   0CA0D0E7           LDRB     R10,[R0, +R12]
    193              } while (1);
   \   00000098   F0FFFFEA           B        ??_DrawBitLine1BPP_2
    194            case LCD_DRAWMODE_TRANS:
    195              Index1 = *(pTrans + 1);
   \                     ??_DrawBitLine1BPP_4:
   \   0000009C   04B091E5           LDR      R11,[R1, #+4]
   \   000000A0   0A0000EA           B        ??_DrawBitLine1BPP_6
    196              do {
    197                /* Prepare loop */
    198                if (PixelCnt > xsize) {
    199                  PixelCnt = xsize;
    200                }
    201                xsize -= PixelCnt;
    202                if (pUsage) {
    203                  do {
    204                    if (pixels == 0) {      /* Early out optimization; not required */
    205                      pDest += PixelCnt;
    206                      x     += PixelCnt;
    207                      break;
    208                    }
    209                    if ((pixels & 1)) {
    210                      GUI_USAGE_AddPixel(pUsage, x, y);
    211                      *pDest = Index1;
    212                    }
    213                    x++;
    214                    pDest++;
    215                    if (--PixelCnt == 0) {
    216                      break;
    217                    }
    218                    pixels >>= 1;
    219                  } while (1);
    220                } else {
    221                  do {
    222                    if (pixels == 0) {      /* Early out optimization; not required */
    223                      pDest += PixelCnt;
    224                      break;
    225                    }
    226                    if ((pixels & 1)) {
   \                     ??_DrawBitLine1BPP_7:
   \   000000A4   01001AE3           TST      R10,#0x1
    227                      *pDest = Index1;
   \   000000A8   00B08815           STRNE    R11,[R8, #+0]
    228                    }
    229                    pDest++;
   \   000000AC   048088E2           ADD      R8,R8,#+4
    230                    if (--PixelCnt == 0) {
   \   000000B0   019059E2           SUBS     R9,R9,#+1
   \   000000B4   1E00001A           BNE      ??_DrawBitLine1BPP_8
    231                      break;
    232                    }
    233                    pixels >>= 1;
    234                  } while (1);
    235                }
    236                /* Check if an other Source byte needs to be loaded */
    237                if (xsize == 0) {
   \                     ??_DrawBitLine1BPP_9:
   \   000000B8   000057E3           CMP      R7,#+0
   \   000000BC   3700000A           BEQ      ??_DrawBitLine1BPP_1
    238                  return;
    239                }
    240                PixelCnt = 8;
    241                pixels = LCD_aMirror[*(++p)];
   \   000000C0   0100F6E5           LDRB     R0,[R6, #+1]!
   \   000000C4   ........           LDR      R1,??DataTable11
   \   000000C8   0890A0E3           MOV      R9,#+8
   \   000000CC   01A0D0E7           LDRB     R10,[R0, +R1]
    242              } while (1);
   \                     ??_DrawBitLine1BPP_6:
   \   000000D0   090057E1           CMP      R7,R9
   \   000000D4   0790A091           MOVLS    R9,R7
   \   000000D8   097047E0           SUB      R7,R7,R9
   \   000000DC   000054E3           CMP      R4,#+0
   \   000000E0   1400000A           BEQ      ??_DrawBitLine1BPP_10
   \   000000E4   0D0000EA           B        ??_DrawBitLine1BPP_11
   \                     ??_DrawBitLine1BPP_12:
   \   000000E8   01001AE3           TST      R10,#0x1
   \   000000EC   0600000A           BEQ      ??_DrawBitLine1BPP_13
   \   000000F0   083094E5           LDR      R3,[R4, #+8]
   \   000000F4   00209DE5           LDR      R2,[SP, #+0]
   \   000000F8   0510A0E1           MOV      R1,R5
   \   000000FC   0400A0E1           MOV      R0,R4
   \   00000100   003093E5           LDR      R3,[R3, #+0]
   \   00000104   33FF2FE1           BLX      R3
   \   00000108   00B088E5           STR      R11,[R8, #+0]
   \                     ??_DrawBitLine1BPP_13:
   \   0000010C   015085E2           ADD      R5,R5,#+1
   \   00000110   048088E2           ADD      R8,R8,#+4
   \   00000114   019059E2           SUBS     R9,R9,#+1
   \   00000118   E6FFFF0A           BEQ      ??_DrawBitLine1BPP_9
   \   0000011C   AAA0A0E1           LSR      R10,R10,#+1
   \                     ??_DrawBitLine1BPP_11:
   \   00000120   00005AE3           CMP      R10,#+0
   \   00000124   EFFFFF1A           BNE      ??_DrawBitLine1BPP_12
   \   00000128   098188E0           ADD      R8,R8,R9, LSL #+2
   \   0000012C   055089E0           ADD      R5,R9,R5
   \   00000130   E0FFFFEA           B        ??_DrawBitLine1BPP_9
   \                     ??_DrawBitLine1BPP_8:
   \   00000134   AAA0A0E1           LSR      R10,R10,#+1
   \                     ??_DrawBitLine1BPP_10:
   \   00000138   00005AE3           CMP      R10,#+0
   \   0000013C   D8FFFF1A           BNE      ??_DrawBitLine1BPP_7
   \   00000140   098188E0           ADD      R8,R8,R9, LSL #+2
   \   00000144   DBFFFFEA           B        ??_DrawBitLine1BPP_9
    243            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    244            case LCD_DRAWMODE_XOR:
    245              IndexMask = pDev->pDevice->pColorConvAPI->pfGetIndexMask();
   \                     ??_DrawBitLine1BPP_3:
   \   00000148   000092E5           LDR      R0,[R2, #+0]
   \   0000014C   100090E5           LDR      R0,[R0, #+16]
   \   00000150   080090E5           LDR      R0,[R0, #+8]
   \   00000154   30FF2FE1           BLX      R0
   \   00000158   ........           LDR      R2,??DataTable11
   \   0000015C   020000EA           B        ??_DrawBitLine1BPP_14
    246              do {
    247                /* Prepare loop */
    248                if (PixelCnt > xsize) {
    249                  PixelCnt = xsize;
    250                }
    251                xsize -= PixelCnt;
    252                /* Write as many pixels as we are allowed to and have loaded in this inner loop */
    253                do {
    254                  if ((pixels & 1)) {
    255                    *pDest ^= IndexMask;
    256                  }
    257                  pDest++;
    258                  pixels >>= 1;
    259                } while (--PixelCnt);
    260                /* Check if an other Source byte needs to be loaded */
    261                if (xsize == 0) {
    262                  return;
    263                }
    264                PixelCnt = 8;
    265                pixels = LCD_aMirror[*(++p)];
   \                     ??_DrawBitLine1BPP_15:
   \   00000160   0110F6E5           LDRB     R1,[R6, #+1]!
   \   00000164   0890A0E3           MOV      R9,#+8
   \   00000168   02A0D1E7           LDRB     R10,[R1, +R2]
    266              } while (1);
   \                     ??_DrawBitLine1BPP_14:
   \   0000016C   090057E1           CMP      R7,R9
   \   00000170   0790A091           MOVLS    R9,R7
   \   00000174   097047E0           SUB      R7,R7,R9
   \                     ??_DrawBitLine1BPP_16:
   \   00000178   01001AE3           TST      R10,#0x1
   \   0000017C   00109815           LDRNE    R1,[R8, #+0]
   \   00000180   AAA0A0E1           LSR      R10,R10,#+1
   \   00000184   01102010           EORNE    R1,R0,R1
   \   00000188   00108815           STRNE    R1,[R8, #+0]
   \   0000018C   048088E2           ADD      R8,R8,#+4
   \   00000190   019059E2           SUBS     R9,R9,#+1
   \   00000194   F7FFFF1A           BNE      ??_DrawBitLine1BPP_16
   \   00000198   000057E3           CMP      R7,#+0
   \   0000019C   EFFFFF1A           BNE      ??_DrawBitLine1BPP_15
   \                     ??_DrawBitLine1BPP_1:
   \   000001A0   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000001A4   F08FBDE8           POP      {R4-R11,PC}      ;; return
    267            }
    268          }
    269          
    270          /*********************************************************************
    271          *
    272          *       _DrawBitLine2BPP
    273          */

   \                                 In section .text, align 4, keep-with-next
    274          static void _DrawBitLine2BPP(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * p, int Diff, int xsize,
    275                                       const LCD_PIXELINDEX* pTrans, PIXELINDEX* pDest)
    276          {
   \                     _DrawBitLine2BPP:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   28609DE5           LDR      R6,[SP, #+40]
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   2C009DE5           LDR      R0,[SP, #+44]
    277            U8 pixels;
    278            U8  PixelCnt;
    279          
    280            GUI_USE_PARA(pDevice);
    281            PixelCnt = 4 - Diff;
    282            pixels = (*p) << (Diff << 1);
   \   00000010   0010D6E5           LDRB     R1,[R6, #+0]
   \   00000014   04A060E2           RSB      R10,R0,#+4
   \   00000018   8000A0E1           LSL      R0,R0,#+1
   \   0000001C   11B0A0E1           LSL      R11,R1,R0
    283            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000020   ........           LDR      R0,??DataTable11_1
   \   00000024   0250A0E1           MOV      R5,R2
   \   00000028   1000D0E5           LDRB     R0,[R0, #+16]
   \   0000002C   30709DE5           LDR      R7,[SP, #+48]
   \   00000030   34809DE5           LDR      R8,[SP, #+52]
   \   00000034   38909DE5           LDR      R9,[SP, #+56]
   \   00000038   030010E2           ANDS     R0,R0,#0x3
   \   0000003C   0300000A           BEQ      ??_DrawBitLine2BPP_0
   \   00000040   020050E3           CMP      R0,#+2
   \   00000044   1300000A           BEQ      ??_DrawBitLine2BPP_1
   \   00000048   3200003A           BCC      ??_DrawBitLine2BPP_2
   \   0000004C   410000EA           B        ??_DrawBitLine2BPP_3
    284            case 0:    /* Write mode */
    285            PixelLoopWrite:
    286              if (PixelCnt > xsize) {
   \                     ??_DrawBitLine2BPP_0:
   \   00000050   0A0CA0E1           MOV      R0,R10, LSL #+24
   \   00000054   200C57E1           CMP      R7,R0, LSR #+24
    287                PixelCnt = xsize;
   \   00000058   07A0A0B1           MOVLT    R10,R7
    288              }
    289              xsize -= PixelCnt;
   \   0000005C   FF000AE2           AND      R0,R10,#0xFF
   \   00000060   007047E0           SUB      R7,R7,R0
    290              do {
    291                *pDest++ = *(pTrans + (pixels >> 6));
   \                     ??_DrawBitLine2BPP_4:
   \   00000064   FF000BE2           AND      R0,R11,#0xFF
   \   00000068   4003A0E1           ASR      R0,R0,#+6
   \   0000006C   000198E7           LDR      R0,[R8, +R0, LSL #+2]
    292                pixels <<= 2;
    293              } while (--PixelCnt);
   \   00000070   01A04AE2           SUB      R10,R10,#+1
   \   00000074   040089E4           STR      R0,[R9], #+4
   \   00000078   0BB1A0E1           LSL      R11,R11,#+2
   \   0000007C   FFA01AE2           ANDS     R10,R10,#0xFF
   \   00000080   F7FFFF1A           BNE      ??_DrawBitLine2BPP_4
    294              if (xsize) {
   \   00000084   000057E3           CMP      R7,#+0
   \   00000088   3200000A           BEQ      ??_DrawBitLine2BPP_3
    295                PixelCnt = 4;
   \   0000008C   04A0A0E3           MOV      R10,#+4
    296                pixels = *(++p);
   \   00000090   01B0F6E5           LDRB     R11,[R6, #+1]!
    297                goto PixelLoopWrite;
   \   00000094   EDFFFFEA           B        ??_DrawBitLine2BPP_0
    298              }
    299              break;
    300            case LCD_DRAWMODE_TRANS:
    301            PixelLoopTrans:
    302              if (PixelCnt > xsize)
   \                     ??_DrawBitLine2BPP_1:
   \   00000098   0A0CA0E1           MOV      R0,R10, LSL #+24
   \   0000009C   200C57E1           CMP      R7,R0, LSR #+24
    303                PixelCnt = xsize;
   \   000000A0   07A0A0B1           MOVLT    R10,R7
    304              xsize -= PixelCnt;
   \   000000A4   FF000AE2           AND      R0,R10,#0xFF
   \   000000A8   007047E0           SUB      R7,R7,R0
    305              do {
    306                if (pixels & 0xc0) {
   \                     ??_DrawBitLine2BPP_5:
   \   000000AC   C0001BE3           TST      R11,#0xC0
   \   000000B0   0B00000A           BEQ      ??_DrawBitLine2BPP_6
    307                  *pDest = *(pTrans + (pixels >> 6));
   \   000000B4   FF000BE2           AND      R0,R11,#0xFF
   \   000000B8   4003A0E1           ASR      R0,R0,#+6
   \   000000BC   000198E7           LDR      R0,[R8, +R0, LSL #+2]
    308                  if (pUsage) {
   \   000000C0   000054E3           CMP      R4,#+0
   \   000000C4   000089E5           STR      R0,[R9, #+0]
   \   000000C8   0500000A           BEQ      ??_DrawBitLine2BPP_6
    309                    GUI_USAGE_AddPixel(pUsage, x, y);
   \   000000CC   083094E5           LDR      R3,[R4, #+8]
   \   000000D0   00209DE5           LDR      R2,[SP, #+0]
   \   000000D4   0510A0E1           MOV      R1,R5
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   003093E5           LDR      R3,[R3, #+0]
   \   000000E0   33FF2FE1           BLX      R3
    310                  }
    311                }
    312                pDest++;
    313                x++;
    314                pixels <<= 2;
    315              } while (--PixelCnt);
   \                     ??_DrawBitLine2BPP_6:
   \   000000E4   01A04AE2           SUB      R10,R10,#+1
   \   000000E8   049089E2           ADD      R9,R9,#+4
   \   000000EC   015085E2           ADD      R5,R5,#+1
   \   000000F0   0BB1A0E1           LSL      R11,R11,#+2
   \   000000F4   FFA01AE2           ANDS     R10,R10,#0xFF
   \   000000F8   EBFFFF1A           BNE      ??_DrawBitLine2BPP_5
    316              if (xsize) {
   \   000000FC   000057E3           CMP      R7,#+0
   \   00000100   1400000A           BEQ      ??_DrawBitLine2BPP_3
    317                PixelCnt = 4;
   \   00000104   04A0A0E3           MOV      R10,#+4
    318                pixels = *(++p);
   \   00000108   01B0F6E5           LDRB     R11,[R6, #+1]!
    319                goto PixelLoopTrans;
   \   0000010C   E1FFFFEA           B        ??_DrawBitLine2BPP_1
    320              }
    321              break;
    322            case LCD_DRAWMODE_XOR:;
    323            PixelLoopXor:
    324              if (PixelCnt > xsize)
    325                PixelCnt = xsize;
    326              xsize -= PixelCnt;
    327              do {
    328                if ((pixels & 0xc0))
    329                  *pDest ^= 255;
    330                pDest++;
    331                pixels <<= 2;
    332              } while (--PixelCnt);
    333              if (xsize) {
    334                PixelCnt = 4;
   \                     ??_DrawBitLine2BPP_7:
   \   00000110   04A0A0E3           MOV      R10,#+4
    335                pixels = *(++p);
   \   00000114   01B0F6E5           LDRB     R11,[R6, #+1]!
    336                goto PixelLoopXor;
    337              }
   \                     ??_DrawBitLine2BPP_2:
   \   00000118   0A0CA0E1           MOV      R0,R10, LSL #+24
   \   0000011C   200C57E1           CMP      R7,R0, LSR #+24
   \   00000120   07A0A0B1           MOVLT    R10,R7
   \   00000124   FF000AE2           AND      R0,R10,#0xFF
   \   00000128   007047E0           SUB      R7,R7,R0
   \                     ??_DrawBitLine2BPP_8:
   \   0000012C   C0001BE3           TST      R11,#0xC0
   \   00000130   00009915           LDRNE    R0,[R9, #+0]
   \   00000134   01A04AE2           SUB      R10,R10,#+1
   \   00000138   FF002012           EORNE    R0,R0,#0xFF
   \   0000013C   00008915           STRNE    R0,[R9, #+0]
   \   00000140   049089E2           ADD      R9,R9,#+4
   \   00000144   0BB1A0E1           LSL      R11,R11,#+2
   \   00000148   FFA01AE2           ANDS     R10,R10,#0xFF
   \   0000014C   F6FFFF1A           BNE      ??_DrawBitLine2BPP_8
   \   00000150   000057E3           CMP      R7,#+0
   \   00000154   EDFFFF1A           BNE      ??_DrawBitLine2BPP_7
    338              break;
    339            }
    340          }
   \                     ??_DrawBitLine2BPP_3:
   \   00000158   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000015C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    341          
    342          /*********************************************************************
    343          *
    344          *       _DrawBitLine4BPP
    345          */

   \                                 In section .text, align 4, keep-with-next
    346          static void _DrawBitLine4BPP(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * p, int Diff, int xsize,
    347                                       const LCD_PIXELINDEX* pTrans, PIXELINDEX* pDest)
    348          {
   \                     _DrawBitLine4BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   28509DE5           LDR      R5,[SP, #+40]
   \   0000000C   02A0A0E1           MOV      R10,R2
   \   00000010   2C009DE5           LDR      R0,[SP, #+44]
    349            U8 pixels;
    350            U8 PixelCnt;
    351          
    352            GUI_USE_PARA(pDevice);
    353            PixelCnt = 2 - Diff;
    354            pixels = (*p) << (Diff << 2);
   \   00000014   0020D5E5           LDRB     R2,[R5, #+0]
   \   00000018   03B0A0E1           MOV      R11,R3
   \   0000001C   0031A0E1           LSL      R3,R0,#+2
   \   00000020   1243A0E1           LSL      R4,R2,R3
    355            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000024   ........           LDR      R2,??DataTable11_1
   \   00000028   0190A0E1           MOV      R9,R1
   \   0000002C   1020D2E5           LDRB     R2,[R2, #+16]
   \   00000030   0010A0E1           MOV      R1,R0
   \   00000034   30609DE5           LDR      R6,[SP, #+48]
   \   00000038   34709DE5           LDR      R7,[SP, #+52]
   \   0000003C   38809DE5           LDR      R8,[SP, #+56]
   \   00000040   021061E2           RSB      R1,R1,#+2
   \   00000044   032012E2           ANDS     R2,R2,#0x3
   \   00000048   0300000A           BEQ      ??_DrawBitLine4BPP_0
   \   0000004C   020052E3           CMP      R2,#+2
   \   00000050   1E00000A           BEQ      ??_DrawBitLine4BPP_1
   \   00000054   6400003A           BCC      ??_DrawBitLine4BPP_2
   \   00000058   730000EA           B        ??_DrawBitLine4BPP_3
    356          /*
    357                    * Write mode *
    358          */
    359            case 0:
    360              /* Draw incomplete bytes to the left of center area */
    361              if (Diff) {
   \                     ??_DrawBitLine4BPP_0:
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   0500000A           BEQ      ??_DrawBitLine4BPP_4
    362                *pDest = *(pTrans + (pixels >> 4));
   \   00000064   FF4004E2           AND      R4,R4,#0xFF
   \   00000068   4402A0E1           ASR      R0,R4,#+4
   \   0000006C   000197E7           LDR      R0,[R7, +R0, LSL #+2]
    363                pDest++;
    364                xsize--;
   \   00000070   016046E2           SUB      R6,R6,#+1
   \   00000074   040088E4           STR      R0,[R8], #+4
    365                pixels = *++p;
   \   00000078   0140F5E5           LDRB     R4,[R5, #+1]!
    366              }
    367              /* Draw center area (2 pixels in one byte) */
    368              if (xsize >= 2) {
   \                     ??_DrawBitLine4BPP_4:
   \   0000007C   020056E3           CMP      R6,#+2
   \   00000080   0B0000BA           BLT      ??_DrawBitLine4BPP_5
    369                int i = xsize >> 1;
   \   00000084   C600A0E1           ASR      R0,R6,#+1
    370                xsize &= 1;
   \   00000088   016006E2           AND      R6,R6,#0x1
    371                do {
    372                  *pDest     = *(pTrans + (pixels >> 4));   /* Draw 1. (left) pixel */
   \                     ??_DrawBitLine4BPP_6:
   \   0000008C   FF4004E2           AND      R4,R4,#0xFF
   \   00000090   4412A0E1           ASR      R1,R4,#+4
   \   00000094   011197E7           LDR      R1,[R7, +R1, LSL #+2]
    373                  *(pDest+1) = *(pTrans + (pixels & 15));   /* Draw 2. (right) pixel */
    374                  pDest += 2;
    375                  pixels = *++p;
    376                } while (--i);
   \   00000098   010050E2           SUBS     R0,R0,#+1
   \   0000009C   041088E4           STR      R1,[R8], #+4
   \   000000A0   0F1004E2           AND      R1,R4,#0xF
   \   000000A4   011197E7           LDR      R1,[R7, +R1, LSL #+2]
   \   000000A8   041088E4           STR      R1,[R8], #+4
   \   000000AC   0140F5E5           LDRB     R4,[R5, #+1]!
   \   000000B0   F5FFFF1A           BNE      ??_DrawBitLine4BPP_6
    377              }
    378              /* Draw incomplete bytes to the right of center area */
    379              if (xsize) {
   \                     ??_DrawBitLine4BPP_5:
   \   000000B4   000056E3           CMP      R6,#+0
   \   000000B8   5B00000A           BEQ      ??_DrawBitLine4BPP_3
    380                *pDest = * (pTrans + (pixels >> 4));
   \   000000BC   FF4004E2           AND      R4,R4,#0xFF
   \   000000C0   4402A0E1           ASR      R0,R4,#+4
   \   000000C4   000197E7           LDR      R0,[R7, +R0, LSL #+2]
   \   000000C8   000088E5           STR      R0,[R8, #+0]
   \   000000CC   560000EA           B        ??_DrawBitLine4BPP_3
    381              }
    382              break;
    383          /*
    384                    * Transparent draw mode *
    385          */
    386            case LCD_DRAWMODE_TRANS:
    387              /* Draw incomplete bytes to the left of center area */
    388              if (Diff) {
   \                     ??_DrawBitLine4BPP_1:
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   1100000A           BEQ      ??_DrawBitLine4BPP_7
    389                if (pixels & 0xF0) {
   \   000000D8   F00014E3           TST      R4,#0xF0
   \   000000DC   0B00000A           BEQ      ??_DrawBitLine4BPP_8
    390                  *pDest = *(pTrans + (pixels >> 4));
   \   000000E0   FF4004E2           AND      R4,R4,#0xFF
   \   000000E4   4402A0E1           ASR      R0,R4,#+4
   \   000000E8   000197E7           LDR      R0,[R7, +R0, LSL #+2]
    391                  if (pUsage) {
   \   000000EC   000059E3           CMP      R9,#+0
   \   000000F0   000088E5           STR      R0,[R8, #+0]
   \   000000F4   0500000A           BEQ      ??_DrawBitLine4BPP_8
    392                    GUI_USAGE_AddPixel(pUsage, x, y);
   \   000000F8   083099E5           LDR      R3,[R9, #+8]
   \   000000FC   0B20A0E1           MOV      R2,R11
   \   00000100   0A10A0E1           MOV      R1,R10
   \   00000104   0900A0E1           MOV      R0,R9
   \   00000108   003093E5           LDR      R3,[R3, #+0]
   \   0000010C   33FF2FE1           BLX      R3
    393                  }
    394                }
    395                pDest++;
   \                     ??_DrawBitLine4BPP_8:
   \   00000110   048088E2           ADD      R8,R8,#+4
    396                x++;
   \   00000114   01A08AE2           ADD      R10,R10,#+1
    397                xsize--;
   \   00000118   016046E2           SUB      R6,R6,#+1
    398                pixels = *++p;
   \   0000011C   0140F5E5           LDRB     R4,[R5, #+1]!
    399              }
    400              /* Draw center area (2 pixels in one byte) */
    401              while (xsize >= 2) {
   \                     ??_DrawBitLine4BPP_7:
   \   00000120   020056E3           CMP      R6,#+2
   \   00000124   1F0000BA           BLT      ??_DrawBitLine4BPP_9
    402                /* Draw 1. (left) pixel */
    403                if (pixels & 0xF0) {
   \                     ??_DrawBitLine4BPP_10:
   \   00000128   F00014E3           TST      R4,#0xF0
   \   0000012C   0B00000A           BEQ      ??_DrawBitLine4BPP_11
    404                  *pDest = *(pTrans + (pixels >> 4));
   \   00000130   FF0004E2           AND      R0,R4,#0xFF
   \   00000134   4002A0E1           ASR      R0,R0,#+4
   \   00000138   000197E7           LDR      R0,[R7, +R0, LSL #+2]
    405                  if (pUsage) {
   \   0000013C   000059E3           CMP      R9,#+0
   \   00000140   000088E5           STR      R0,[R8, #+0]
   \   00000144   0500000A           BEQ      ??_DrawBitLine4BPP_11
    406                    GUI_USAGE_AddPixel(pUsage, x, y);
   \   00000148   083099E5           LDR      R3,[R9, #+8]
   \   0000014C   0B20A0E1           MOV      R2,R11
   \   00000150   0A10A0E1           MOV      R1,R10
   \   00000154   0900A0E1           MOV      R0,R9
   \   00000158   003093E5           LDR      R3,[R3, #+0]
   \   0000015C   33FF2FE1           BLX      R3
    407                  }
    408                }
    409                /* Draw 2. (right) pixel */
    410                if (pixels &= 15) {
   \                     ??_DrawBitLine4BPP_11:
   \   00000160   0F0014E2           ANDS     R0,R4,#0xF
   \   00000164   0900000A           BEQ      ??_DrawBitLine4BPP_12
    411                  *(pDest + 1) = *(pTrans + pixels);
   \   00000168   000197E7           LDR      R0,[R7, +R0, LSL #+2]
    412                  if (pUsage) {
   \   0000016C   000059E3           CMP      R9,#+0
   \   00000170   040088E5           STR      R0,[R8, #+4]
   \   00000174   0500000A           BEQ      ??_DrawBitLine4BPP_12
    413                    GUI_USAGE_AddPixel(pUsage, x + 1, y);
   \   00000178   083099E5           LDR      R3,[R9, #+8]
   \   0000017C   0B20A0E1           MOV      R2,R11
   \   00000180   01108AE2           ADD      R1,R10,#+1
   \   00000184   0900A0E1           MOV      R0,R9
   \   00000188   003093E5           LDR      R3,[R3, #+0]
   \   0000018C   33FF2FE1           BLX      R3
    414                  }
    415                }
    416                pDest += 2;
    417                x += 2;
    418                xsize -= 2;
   \                     ??_DrawBitLine4BPP_12:
   \   00000190   026046E2           SUB      R6,R6,#+2
   \   00000194   088088E2           ADD      R8,R8,#+8
   \   00000198   02A08AE2           ADD      R10,R10,#+2
    419                pixels = *++p;
   \   0000019C   0140F5E5           LDRB     R4,[R5, #+1]!
   \   000001A0   020056E3           CMP      R6,#+2
   \   000001A4   DFFFFFAA           BGE      ??_DrawBitLine4BPP_10
    420              }
    421              /* Draw incomplete bytes to the right of center area */
    422              if (xsize) {
   \                     ??_DrawBitLine4BPP_9:
   \   000001A8   000056E3           CMP      R6,#+0
    423                if (pixels >>= 4) {
   \   000001AC   044CA011           LSLNE    R4,R4,#+24
   \   000001B0   244EB011           LSRSNE   R4,R4,#+28
   \   000001B4   1C00000A           BEQ      ??_DrawBitLine4BPP_3
    424                  *pDest = *(pTrans + pixels);
   \   000001B8   040197E7           LDR      R0,[R7, +R4, LSL #+2]
    425                  if (pUsage) {
   \   000001BC   000059E3           CMP      R9,#+0
   \   000001C0   000088E5           STR      R0,[R8, #+0]
   \   000001C4   1800000A           BEQ      ??_DrawBitLine4BPP_3
    426                    GUI_USAGE_AddPixel(pUsage, x, y);
   \   000001C8   083099E5           LDR      R3,[R9, #+8]
   \   000001CC   0B20A0E1           MOV      R2,R11
   \   000001D0   0A10A0E1           MOV      R1,R10
   \   000001D4   0900A0E1           MOV      R0,R9
   \   000001D8   003093E5           LDR      R3,[R3, #+0]
   \   000001DC   33FF2FE1           BLX      R3
   \   000001E0   110000EA           B        ??_DrawBitLine4BPP_3
    427                  }
    428                }
    429              }
    430              break;
    431            case LCD_DRAWMODE_XOR:;
    432            PixelLoopXor:
    433              if (PixelCnt > xsize)
    434                PixelCnt = xsize;
    435              xsize -= PixelCnt;
    436              do {
    437                if ((pixels & 0xc0)) {
    438                  *pDest ^= 255;
    439                }
    440                pDest++;
    441                pixels <<= 4;
    442              } while (--PixelCnt);
    443              if (xsize) {
    444                PixelCnt = 2;
   \                     ??_DrawBitLine4BPP_13:
   \   000001E4   0210A0E3           MOV      R1,#+2
    445                pixels = *(++p);
   \   000001E8   0140F5E5           LDRB     R4,[R5, #+1]!
    446                goto PixelLoopXor;
    447              }
   \                     ??_DrawBitLine4BPP_2:
   \   000001EC   010CA0E1           MOV      R0,R1, LSL #+24
   \   000001F0   200C56E1           CMP      R6,R0, LSR #+24
   \   000001F4   0610A0B1           MOVLT    R1,R6
   \   000001F8   FF0001E2           AND      R0,R1,#0xFF
   \   000001FC   006046E0           SUB      R6,R6,R0
   \                     ??_DrawBitLine4BPP_14:
   \   00000200   C00014E3           TST      R4,#0xC0
   \   00000204   00009815           LDRNE    R0,[R8, #+0]
   \   00000208   011041E2           SUB      R1,R1,#+1
   \   0000020C   FF002012           EORNE    R0,R0,#0xFF
   \   00000210   00008815           STRNE    R0,[R8, #+0]
   \   00000214   048088E2           ADD      R8,R8,#+4
   \   00000218   0442A0E1           LSL      R4,R4,#+4
   \   0000021C   FF1011E2           ANDS     R1,R1,#0xFF
   \   00000220   F6FFFF1A           BNE      ??_DrawBitLine4BPP_14
   \   00000224   000056E3           CMP      R6,#+0
   \   00000228   EDFFFF1A           BNE      ??_DrawBitLine4BPP_13
    448              break;
    449            }
    450          }
   \                     ??_DrawBitLine4BPP_3:
   \   0000022C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000230   F08FBDE8           POP      {R4-R11,PC}      ;; return
    451          
    452          /*********************************************************************
    453          *
    454          *       _DrawBitLine8BPP
    455          */
    456          static void _DrawBitLine8BPP(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * pSrc, int xsize,
    457                                       const LCD_PIXELINDEX* pTrans, PIXELINDEX* pDest) {
    458            GUI_USE_PARA(pDevice);
    459            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    460            case 0:    /* Write mode */
    461              do {
    462                *pDest = *(pTrans + *pSrc);
    463                pDest++;
    464                pSrc++;
    465              } while (--xsize);
    466              break;
    467            case LCD_DRAWMODE_TRANS:
    468              do {
    469                if (*pSrc) {
    470                  *pDest = *(pTrans + *pSrc);
    471                  if (pUsage) {
    472                    GUI_USAGE_AddPixel(pUsage, x, y);
    473                  }
    474                }
    475                x++;
    476                pDest++;
    477                pSrc++;
    478              } while (--xsize);
    479              break;
    480            }
    481          }
    482          
    483          #if GUI_UNI_PTR_USED
    484          /*********************************************************************
    485          *
    486          *       _Memcopy
    487          */
    488          static void _Memcopy(PIXELINDEX * pDest, const U8 GUI_UNI_PTR * pSrc, int NumBytes) {
    489            while(NumBytes--) {
    490              *pDest++ = *pSrc++;
    491            }
    492          }
    493          #endif
    494          
    495          /*********************************************************************
    496          *
    497          *       _DrawBitLine8BPP_DDB
    498          */
    499          static void _DrawBitLine8BPP_DDB(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * pSrc, int xsize, PIXELINDEX* pDest) {
    500            GUI_USE_PARA(pDevice);
    501            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    502            case 0:    /* Write mode */
    503              #if GUI_UNI_PTR_USED
    504                _Memcopy(pDest, pSrc, xsize);
    505              #else
    506                GUI_MEMCPY(pDest, pSrc, xsize);
    507              #endif
    508              break;
    509            case LCD_DRAWMODE_TRANS:
    510              do {
    511                if (*pSrc) {
    512                  *pDest = *pSrc;
    513                  if (pUsage) {
    514                    GUI_USAGE_AddPixel(pUsage, x, y);
    515                  }
    516                }
    517                x++;
    518                pDest++;
    519                pSrc++;
    520              } while (--xsize);
    521              break;
    522            }
    523          }
    524          
    525          /*********************************************************************
    526          *
    527          *       _DrawBitmap
    528          */

   \                                 In section .text, align 4, keep-with-next
    529          static void _DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize,
    530                                  int BitsPerPixel, int BytesPerLine,
    531                                  const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX* pTrans)
    532          {
   \                     _DrawBitmap:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   ........           LDR      R0,??DataTable11_1
   \   0000000C   20D04DE2           SUB      SP,SP,#+32
   \   00000010   0160A0E1           MOV      R6,R1
   \   00000014   0290A0E1           MOV      R9,R2
   \   00000018   54709DE5           LDR      R7,[SP, #+84]
   \   0000001C   58A09DE5           LDR      R10,[SP, #+88]
   \   00000020   880090E5           LDR      R0,[R0, #+136]
    533            int i;
    534            GUI_MEMDEV* pDev   = GUI_MEMDEV_H2P(GUI_Context.hDevData);
   \   00000024   ........           BL       GUI_ALLOC_h2p
   \   00000028   1C008DE5           STR      R0,[SP, #+28]
    535            GUI_USAGE*  pUsage = (pDev->hUsage) ? GUI_USAGE_H2P(pDev->hUsage) : 0;
   \   0000002C   140090E5           LDR      R0,[R0, #+20]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0200000A           BEQ      ??_DrawBitmap_0
   \   00000038   ........           BL       GUI_ALLOC_h2p
   \   0000003C   0050A0E1           MOV      R5,R0
   \   00000040   000000EA           B        ??_DrawBitmap_1
   \                     ??_DrawBitmap_0:
   \   00000044   0050A0E3           MOV      R5,#+0
    536            unsigned    BytesPerLineDest;
    537            PIXELINDEX* pDest;
    538            BytesPerLineDest = pDev->BytesPerLine;
   \                     ??_DrawBitmap_1:
   \   00000048   1C009DE5           LDR      R0,[SP, #+28]
    539            x0 += Diff;
   \   0000004C   06608AE0           ADD      R6,R10,R6
   \   00000050   0C0090E5           LDR      R0,[R0, #+12]
    540            /* Mark all affected pixels dirty unless transparency is set */
    541            if (pUsage) {
   \   00000054   000055E3           CMP      R5,#+0
   \   00000058   18008DE5           STR      R0,[SP, #+24]
   \   0000005C   0A00000A           BEQ      ??_DrawBitmap_2
    542              if ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) == 0) {
   \   00000060   ........           LDR      R0,??DataTable11_1
   \   00000064   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000068   020010E3           TST      R0,#0x2
   \   0000006C   0600001A           BNE      ??_DrawBitmap_2
    543                GUI_USAGE_AddRect(pUsage, x0, y0 , xsize, ysize);
   \   00000070   48009DE5           LDR      R0,[SP, #+72]
   \   00000074   20309DE5           LDR      R3,[SP, #+32]
   \   00000078   00008DE5           STR      R0,[SP, #+0]
   \   0000007C   0920A0E1           MOV      R2,R9
   \   00000080   0610A0E1           MOV      R1,R6
   \   00000084   0500A0E1           MOV      R0,R5
   \   00000088   ........           BL       GUI_USAGE_AddRect
    544              }
    545            }
    546            pDest = _XY2PTR(x0, y0);
   \                     ??_DrawBitmap_2:
   \   0000008C   ........           LDR      R0,??DataTable11_1
   \   00000090   880090E5           LDR      R0,[R0, #+136]
   \   00000094   ........           BL       GUI_ALLOC_h2p
   \   00000098   F620D0E1           LDRSH    R2,[R0, #+6]
   \   0000009C   0C3090E5           LDR      R3,[R0, #+12]
   \   000000A0   F410D0E1           LDRSH    R1,[R0, #+4]
   \   000000A4   022049E0           SUB      R2,R9,R2
   \   000000A8   930220E0           MLA      R0,R3,R2,R0
   \   000000AC   0111A0E1           LSL      R1,R1,#+2
   \   000000B0   001061E2           RSB      R1,R1,#+0
   \   000000B4   060180E0           ADD      R0,R0,R6, LSL #+2
   \   000000B8   000081E0           ADD      R0,R1,R0
   \   000000BC   188080E2           ADD      R8,R0,#+24
    547          #if BITSPERPIXEL == 16
    548            /* handle 16 bpp bitmaps in high color modes, but only without palette */
    549            if (BitsPerPixel == 16) {
    550              for (i = 0; i < ysize; i++) {
    551                _DrawBitLine16BPP_DDB(pDevice, pUsage, x0, i + y0, (const U16*)pData, xsize, pDest);
    552                pData += BytesPerLine;
    553                pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
    554              }
    555              return;
    556            } else if (BitsPerPixel >= 24) {
    557              for (i = 0; i < ysize; i++) {
    558                _DrawBitLine32BPP(pDevice, pUsage, x0, i + y0, (const U32 *)pData, xsize, pDest);
    559                pData += BytesPerLine;
    560                pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
    561              }
    562              return;
    563            }
    564          #endif
    565          #if BITSPERPIXEL == 32
    566            /* handle 32 bpp bitmaps in high color modes, but only without palette */
    567            if (BitsPerPixel >= 24) {
   \   000000C0   4C009DE5           LDR      R0,[SP, #+76]
   \   000000C4   180050E3           CMP      R0,#+24
   \   000000C8   340000BA           BLT      ??_DrawBitmap_3
    568              for (i = 0; i < ysize; i++) {
   \   000000CC   48009DE5           LDR      R0,[SP, #+72]
   \   000000D0   010050E3           CMP      R0,#+1
   \   000000D4   060100BA           BLT      ??_DrawBitmap_4
   \   000000D8   00A0A0E1           MOV      R10,R0
   \   000000DC   01001AE3           TST      R10,#0x1
   \   000000E0   0D00000A           BEQ      ??_DrawBitmap_5
    569                _DrawBitLine32BPP_DDB(pDevice, pUsage, x0, i + y0, (const U32*)pData, xsize, pDest);
   \   000000E4   20009DE5           LDR      R0,[SP, #+32]
   \   000000E8   08808DE5           STR      R8,[SP, #+8]
   \   000000EC   04008DE5           STR      R0,[SP, #+4]
   \   000000F0   00708DE5           STR      R7,[SP, #+0]
   \   000000F4   0930A0E1           MOV      R3,R9
   \   000000F8   0620A0E1           MOV      R2,R6
   \   000000FC   0510A0E1           MOV      R1,R5
   \   00000100   0400A0E1           MOV      R0,R4
   \   00000104   ........           BL       _DrawBitLine32BPP_DDB
    570                pData += BytesPerLine;
   \   00000108   50009DE5           LDR      R0,[SP, #+80]
    571                pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
   \   0000010C   019089E2           ADD      R9,R9,#+1
   \   00000110   077080E0           ADD      R7,R0,R7
   \   00000114   18009DE5           LDR      R0,[SP, #+24]
   \   00000118   088080E0           ADD      R8,R0,R8
   \                     ??_DrawBitmap_5:
   \   0000011C   AAA0B0E1           LSRS     R10,R10,#+1
   \   00000120   F300000A           BEQ      ??_DrawBitmap_4
   \                     ??_DrawBitmap_6:
   \   00000124   20009DE5           LDR      R0,[SP, #+32]
   \   00000128   08808DE5           STR      R8,[SP, #+8]
   \   0000012C   04008DE5           STR      R0,[SP, #+4]
   \   00000130   00708DE5           STR      R7,[SP, #+0]
   \   00000134   0930A0E1           MOV      R3,R9
   \   00000138   0620A0E1           MOV      R2,R6
   \   0000013C   0510A0E1           MOV      R1,R5
   \   00000140   0400A0E1           MOV      R0,R4
   \   00000144   ........           BL       _DrawBitLine32BPP_DDB
   \   00000148   50009DE5           LDR      R0,[SP, #+80]
   \   0000014C   013089E2           ADD      R3,R9,#+1
   \   00000150   077080E0           ADD      R7,R0,R7
   \   00000154   18009DE5           LDR      R0,[SP, #+24]
   \   00000158   00708DE5           STR      R7,[SP, #+0]
   \   0000015C   088080E0           ADD      R8,R0,R8
   \   00000160   20009DE5           LDR      R0,[SP, #+32]
   \   00000164   08808DE5           STR      R8,[SP, #+8]
   \   00000168   04008DE5           STR      R0,[SP, #+4]
   \   0000016C   0620A0E1           MOV      R2,R6
   \   00000170   0510A0E1           MOV      R1,R5
   \   00000174   0400A0E1           MOV      R0,R4
   \   00000178   ........           BL       _DrawBitLine32BPP_DDB
   \   0000017C   50009DE5           LDR      R0,[SP, #+80]
    572              }
   \   00000180   01A04AE2           SUB      R10,R10,#+1
   \   00000184   077080E0           ADD      R7,R0,R7
   \   00000188   18009DE5           LDR      R0,[SP, #+24]
   \   0000018C   029089E2           ADD      R9,R9,#+2
   \   00000190   088080E0           ADD      R8,R0,R8
   \   00000194   00005AE3           CMP      R10,#+0
   \   00000198   E1FFFF1A           BNE      ??_DrawBitmap_6
   \   0000019C   D40000EA           B        ??_DrawBitmap_4
    573              return;
    574            } else if (BitsPerPixel == 16) {
   \                     ??_DrawBitmap_3:
   \   000001A0   100050E3           CMP      R0,#+16
   \   000001A4   3800001A           BNE      ??_DrawBitmap_7
    575              for (i = 0; i < ysize; i++) {
   \   000001A8   48009DE5           LDR      R0,[SP, #+72]
   \   000001AC   0010A0E3           MOV      R1,#+0
   \   000001B0   00108DE5           STR      R1,[SP, #+0]
   \   000001B4   010050E3           CMP      R0,#+1
   \   000001B8   CD0000BA           BLT      ??_DrawBitmap_4
   \   000001BC   08908DE5           STR      R9,[SP, #+8]
    576                _DrawBitLine16BPP(pDevice, pUsage, x0, i + y0, (const U16 *)pData, xsize, pDest);
   \                     ??_DrawBitmap_8:
   \   000001C0   08109DE5           LDR      R1,[SP, #+8]
   \   000001C4   04808DE5           STR      R8,[SP, #+4]
   \   000001C8   20909DE5           LDR      R9,[SP, #+32]
   \   000001CC   07A0A0E1           MOV      R10,R7
   \   000001D0   0C108DE5           STR      R1,[SP, #+12]
   \   000001D4   06B0A0E1           MOV      R11,R6
   \   000001D8   000055E3           CMP      R5,#+0
   \   000001DC   0600000A           BEQ      ??_DrawBitmap_9
   \   000001E0   08C095E5           LDR      R12,[R5, #+8]
   \   000001E4   0120A0E1           MOV      R2,R1
   \   000001E8   0930A0E1           MOV      R3,R9
   \   000001EC   0B10A0E1           MOV      R1,R11
   \   000001F0   0500A0E1           MOV      R0,R5
   \   000001F4   04C09CE5           LDR      R12,[R12, #+4]
   \   000001F8   3CFF2FE1           BLX      R12
   \                     ??_DrawBitmap_9:
   \   000001FC   101094E5           LDR      R1,[R4, #+16]
   \   00000200   B000DAE1           LDRH     R0,[R10, #+0]
   \   00000204   041091E5           LDR      R1,[R1, #+4]
   \   00000208   31FF2FE1           BLX      R1
   \   0000020C   04109DE5           LDR      R1,[SP, #+4]
   \   00000210   000055E3           CMP      R5,#+0
   \   00000214   000081E5           STR      R0,[R1, #+0]
   \   00000218   0500000A           BEQ      ??_DrawBitmap_10
   \   0000021C   083095E5           LDR      R3,[R5, #+8]
   \   00000220   0C209DE5           LDR      R2,[SP, #+12]
   \   00000224   0B10A0E1           MOV      R1,R11
   \   00000228   0500A0E1           MOV      R0,R5
   \   0000022C   003093E5           LDR      R3,[R3, #+0]
   \   00000230   33FF2FE1           BLX      R3
   \                     ??_DrawBitmap_10:
   \   00000234   04009DE5           LDR      R0,[SP, #+4]
   \   00000238   01B08BE2           ADD      R11,R11,#+1
   \   0000023C   040080E2           ADD      R0,R0,#+4
   \   00000240   04008DE5           STR      R0,[SP, #+4]
   \   00000244   02A08AE2           ADD      R10,R10,#+2
   \   00000248   019059E2           SUBS     R9,R9,#+1
   \   0000024C   EAFFFF1A           BNE      ??_DrawBitmap_9
    577                pData += BytesPerLine;
   \   00000250   50009DE5           LDR      R0,[SP, #+80]
    578                pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
    579              }
   \   00000254   48109DE5           LDR      R1,[SP, #+72]
   \   00000258   077080E0           ADD      R7,R0,R7
   \   0000025C   18009DE5           LDR      R0,[SP, #+24]
   \   00000260   088080E0           ADD      R8,R0,R8
   \   00000264   00009DE5           LDR      R0,[SP, #+0]
   \   00000268   010080E2           ADD      R0,R0,#+1
   \   0000026C   00008DE5           STR      R0,[SP, #+0]
   \   00000270   08009DE5           LDR      R0,[SP, #+8]
   \   00000274   010080E2           ADD      R0,R0,#+1
   \   00000278   08008DE5           STR      R0,[SP, #+8]
   \   0000027C   00009DE5           LDR      R0,[SP, #+0]
   \   00000280   010050E1           CMP      R0,R1
   \   00000284   9A0000AA           BGE      ??_DrawBitmap_4
   \   00000288   CCFFFFEA           B        ??_DrawBitmap_8
    580              return;
    581            }
    582          #endif
    583            /* Handle 8 bpp bitmaps seperately as we have different routine bitmaps with or without palette */
    584            if (BitsPerPixel == 8) {
   \                     ??_DrawBitmap_7:
   \   0000028C   080050E3           CMP      R0,#+8
   \   00000290   5700001A           BNE      ??_DrawBitmap_11
    585              for (i = 0; i < ysize; i++) {
   \   00000294   48009DE5           LDR      R0,[SP, #+72]
   \   00000298   0010A0E3           MOV      R1,#+0
   \   0000029C   00108DE5           STR      R1,[SP, #+0]
   \   000002A0   010050E3           CMP      R0,#+1
   \   000002A4   920000BA           BLT      ??_DrawBitmap_4
   \   000002A8   04908DE5           STR      R9,[SP, #+4]
    586                if (pTrans) {
   \                     ??_DrawBitmap_12:
   \   000002AC   5C009DE5           LDR      R0,[SP, #+92]
   \   000002B0   04109DE5           LDR      R1,[SP, #+4]
   \   000002B4   000050E3           CMP      R0,#+0
   \   000002B8   ........           LDR      R0,??DataTable11_1
   \   000002BC   0840A0E1           MOV      R4,R8
   \   000002C0   20909DE5           LDR      R9,[SP, #+32]
   \   000002C4   07A0A0E1           MOV      R10,R7
   \   000002C8   08108DE5           STR      R1,[SP, #+8]
   \   000002CC   06B0A0E1           MOV      R11,R6
   \   000002D0   1000D0E5           LDRB     R0,[R0, #+16]
   \   000002D4   1E00000A           BEQ      ??_DrawBitmap_13
    587                  _DrawBitLine8BPP(pDevice, pUsage, x0, i + y0, pData, xsize, pTrans, pDest);
   \   000002D8   030010E2           ANDS     R0,R0,#0x3
   \   000002DC   1500000A           BEQ      ??_DrawBitmap_14
   \   000002E0   020050E2           SUBS     R0,R0,#+2
   \   000002E4   3300001A           BNE      ??_DrawBitmap_15
   \                     ??_DrawBitmap_16:
   \   000002E8   0000DAE5           LDRB     R0,[R10, #+0]
   \   000002EC   000050E3           CMP      R0,#+0
   \   000002F0   0A00000A           BEQ      ??_DrawBitmap_17
   \   000002F4   5C109DE5           LDR      R1,[SP, #+92]
   \   000002F8   000055E3           CMP      R5,#+0
   \   000002FC   000191E7           LDR      R0,[R1, +R0, LSL #+2]
   \   00000300   000084E5           STR      R0,[R4, #+0]
   \   00000304   0500000A           BEQ      ??_DrawBitmap_17
   \   00000308   083095E5           LDR      R3,[R5, #+8]
   \   0000030C   08209DE5           LDR      R2,[SP, #+8]
   \   00000310   0B10A0E1           MOV      R1,R11
   \   00000314   0500A0E1           MOV      R0,R5
   \   00000318   003093E5           LDR      R3,[R3, #+0]
   \   0000031C   33FF2FE1           BLX      R3
   \                     ??_DrawBitmap_17:
   \   00000320   01B08BE2           ADD      R11,R11,#+1
   \   00000324   044084E2           ADD      R4,R4,#+4
   \   00000328   01A08AE2           ADD      R10,R10,#+1
   \   0000032C   019059E2           SUBS     R9,R9,#+1
   \   00000330   ECFFFF1A           BNE      ??_DrawBitmap_16
   \   00000334   1F0000EA           B        ??_DrawBitmap_15
   \                     ??_DrawBitmap_14:
   \   00000338   0100DAE4           LDRB     R0,[R10], #+1
   \   0000033C   5C109DE5           LDR      R1,[SP, #+92]
   \   00000340   019059E2           SUBS     R9,R9,#+1
   \   00000344   000191E7           LDR      R0,[R1, +R0, LSL #+2]
   \   00000348   040084E4           STR      R0,[R4], #+4
   \   0000034C   F9FFFF1A           BNE      ??_DrawBitmap_14
   \   00000350   180000EA           B        ??_DrawBitmap_15
    588                } else {
    589                  _DrawBitLine8BPP_DDB(pDevice, pUsage, x0, i + y0, pData, xsize, pDest);
   \                     ??_DrawBitmap_13:
   \   00000354   030010E2           ANDS     R0,R0,#0x3
   \   00000358   1200000A           BEQ      ??_DrawBitmap_18
   \   0000035C   020050E2           SUBS     R0,R0,#+2
   \   00000360   1400001A           BNE      ??_DrawBitmap_15
   \                     ??_DrawBitmap_19:
   \   00000364   0000DAE5           LDRB     R0,[R10, #+0]
   \   00000368   000050E3           CMP      R0,#+0
   \   0000036C   00008415           STRNE    R0,[R4, #+0]
   \   00000370   00005513           CMPNE    R5,#+0
   \   00000374   0500000A           BEQ      ??_DrawBitmap_20
   \   00000378   083095E5           LDR      R3,[R5, #+8]
   \   0000037C   08209DE5           LDR      R2,[SP, #+8]
   \   00000380   0B10A0E1           MOV      R1,R11
   \   00000384   0500A0E1           MOV      R0,R5
   \   00000388   003093E5           LDR      R3,[R3, #+0]
   \   0000038C   33FF2FE1           BLX      R3
   \                     ??_DrawBitmap_20:
   \   00000390   01B08BE2           ADD      R11,R11,#+1
   \   00000394   044084E2           ADD      R4,R4,#+4
   \   00000398   01A08AE2           ADD      R10,R10,#+1
   \   0000039C   019059E2           SUBS     R9,R9,#+1
   \   000003A0   EFFFFF1A           BNE      ??_DrawBitmap_19
   \   000003A4   030000EA           B        ??_DrawBitmap_15
   \                     ??_DrawBitmap_18:
   \   000003A8   0920A0E1           MOV      R2,R9
   \   000003AC   0A10A0E1           MOV      R1,R10
   \   000003B0   0400A0E1           MOV      R0,R4
   \   000003B4   ........           BL       __aeabi_memcpy
    590                }
    591                pData += BytesPerLine;
   \                     ??_DrawBitmap_15:
   \   000003B8   50009DE5           LDR      R0,[SP, #+80]
    592                pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
    593              }
   \   000003BC   48109DE5           LDR      R1,[SP, #+72]
   \   000003C0   077080E0           ADD      R7,R0,R7
   \   000003C4   18009DE5           LDR      R0,[SP, #+24]
   \   000003C8   088080E0           ADD      R8,R0,R8
   \   000003CC   00009DE5           LDR      R0,[SP, #+0]
   \   000003D0   010080E2           ADD      R0,R0,#+1
   \   000003D4   00008DE5           STR      R0,[SP, #+0]
   \   000003D8   04009DE5           LDR      R0,[SP, #+4]
   \   000003DC   010080E2           ADD      R0,R0,#+1
   \   000003E0   04008DE5           STR      R0,[SP, #+4]
   \   000003E4   00009DE5           LDR      R0,[SP, #+0]
   \   000003E8   010050E1           CMP      R0,R1
   \   000003EC   400000AA           BGE      ??_DrawBitmap_4
   \   000003F0   ADFFFFEA           B        ??_DrawBitmap_12
    594              return;
    595            }
    596            /* Use aID for bitmaps without palette */
    597            if (!pTrans) {
   \                     ??_DrawBitmap_11:
   \   000003F4   5C009DE5           LDR      R0,[SP, #+92]
   \   000003F8   000050E3           CMP      R0,#+0
    598              pTrans = aID;
   \   000003FC   ............       ADRLEQ   R1,aID
   \              ....        
    599            }
    600            for (i = 0; i < ysize; i++) {
   \   00000404   48009DE5           LDR      R0,[SP, #+72]
   \   00000408   5C108D05           STREQ    R1,[SP, #+92]
   \   0000040C   010050E3           CMP      R0,#+1
   \   00000410   370000BA           BLT      ??_DrawBitmap_4
   \   00000414   00B0A0E1           MOV      R11,R0
    601              switch (BitsPerPixel) {
   \                     ??_DrawBitmap_21:
   \   00000418   4C009DE5           LDR      R0,[SP, #+76]
   \   0000041C   010050E2           SUBS     R0,R0,#+1
   \   00000420   0400000A           BEQ      ??_DrawBitmap_22
   \   00000424   010050E2           SUBS     R0,R0,#+1
   \   00000428   1100000A           BEQ      ??_DrawBitmap_23
   \   0000042C   020050E2           SUBS     R0,R0,#+2
   \   00000430   1C00000A           BEQ      ??_DrawBitmap_24
   \   00000434   270000EA           B        ??_DrawBitmap_25
    602              case 1:
    603                _DrawBitLine1BPP(pDevice, pUsage, x0, i + y0, pData, Diff, xsize, pTrans, pDev, pDest);
   \                     ??_DrawBitmap_22:
   \   00000438   1C009DE5           LDR      R0,[SP, #+28]
   \   0000043C   14808DE5           STR      R8,[SP, #+20]
   \   00000440   10008DE5           STR      R0,[SP, #+16]
   \   00000444   5C009DE5           LDR      R0,[SP, #+92]
   \   00000448   04A08DE5           STR      R10,[SP, #+4]
   \   0000044C   0C008DE5           STR      R0,[SP, #+12]
   \   00000450   20009DE5           LDR      R0,[SP, #+32]
   \   00000454   00708DE5           STR      R7,[SP, #+0]
   \   00000458   08008DE5           STR      R0,[SP, #+8]
   \   0000045C   0930A0E1           MOV      R3,R9
   \   00000460   0620A0E1           MOV      R2,R6
   \   00000464   0510A0E1           MOV      R1,R5
   \   00000468   0400A0E1           MOV      R0,R4
   \   0000046C   ........           BL       _DrawBitLine1BPP
    604                break;
   \   00000470   180000EA           B        ??_DrawBitmap_25
    605              case 2:
    606                _DrawBitLine2BPP(pDevice, pUsage, x0, i + y0, pData, Diff, xsize, pTrans, pDest);
   \                     ??_DrawBitmap_23:
   \   00000474   5C009DE5           LDR      R0,[SP, #+92]
   \   00000478   10808DE5           STR      R8,[SP, #+16]
   \   0000047C   0C008DE5           STR      R0,[SP, #+12]
   \   00000480   20009DE5           LDR      R0,[SP, #+32]
   \   00000484   04A08DE5           STR      R10,[SP, #+4]
   \   00000488   08008DE5           STR      R0,[SP, #+8]
   \   0000048C   00708DE5           STR      R7,[SP, #+0]
   \   00000490   0930A0E1           MOV      R3,R9
   \   00000494   0620A0E1           MOV      R2,R6
   \   00000498   0510A0E1           MOV      R1,R5
   \   0000049C   0400A0E1           MOV      R0,R4
   \   000004A0   ........           BL       _DrawBitLine2BPP
    607                break;
   \   000004A4   0B0000EA           B        ??_DrawBitmap_25
    608              case 4:
    609                _DrawBitLine4BPP(pDevice, pUsage, x0, i + y0, pData, Diff, xsize, pTrans, pDest);
   \                     ??_DrawBitmap_24:
   \   000004A8   5C009DE5           LDR      R0,[SP, #+92]
   \   000004AC   10808DE5           STR      R8,[SP, #+16]
   \   000004B0   0C008DE5           STR      R0,[SP, #+12]
   \   000004B4   20009DE5           LDR      R0,[SP, #+32]
   \   000004B8   04A08DE5           STR      R10,[SP, #+4]
   \   000004BC   08008DE5           STR      R0,[SP, #+8]
   \   000004C0   00708DE5           STR      R7,[SP, #+0]
   \   000004C4   0930A0E1           MOV      R3,R9
   \   000004C8   0620A0E1           MOV      R2,R6
   \   000004CC   0510A0E1           MOV      R1,R5
   \   000004D0   0400A0E1           MOV      R0,R4
   \   000004D4   ........           BL       _DrawBitLine4BPP
    610                break;
    611              }
    612              pData += BytesPerLine;
   \                     ??_DrawBitmap_25:
   \   000004D8   50009DE5           LDR      R0,[SP, #+80]
    613              pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
    614            }
   \   000004DC   019089E2           ADD      R9,R9,#+1
   \   000004E0   077080E0           ADD      R7,R0,R7
   \   000004E4   18009DE5           LDR      R0,[SP, #+24]
   \   000004E8   01B05BE2           SUBS     R11,R11,#+1
   \   000004EC   088080E0           ADD      R8,R0,R8
   \   000004F0   C8FFFF1A           BNE      ??_DrawBitmap_21
   \                     ??_DrawBitmap_4:
   \   000004F4   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   000004F8   F08FBDE8           POP      {R4-R11,PC}      ;; return
    615          }
    616          
    617          /*********************************************************************
    618          *
    619          *       _FillRect
    620          */

   \                                 In section .text, align 4, keep-with-next
    621          static void _FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    622            unsigned BytesPerLine, Cnt;
    623            int Len, RemPixels;
    624            GUI_MEMDEV * pDev;
    625            PIXELINDEX * pData;
    626            PIXELINDEX * pDest;
    627            PIXELINDEX IndexMask;
    628            LCD_PIXELINDEX ColorIndex;
    629          
    630            GUI_USE_PARA(pDevice);
    631            pDev         = GUI_MEMDEV_H2P(GUI_Context.hDevData);
   \   00000004   ........           LDR      R6,??DataTable11_1
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   0390A0E1           MOV      R9,R3
   \   00000018   880096E5           LDR      R0,[R6, #+136]
   \   0000001C   ........           BL       GUI_ALLOC_h2p
   \   00000020   0070A0E1           MOV      R7,R0
    632            pData        = _XY2PTR(x0, y0);
   \   00000024   880096E5           LDR      R0,[R6, #+136]
   \   00000028   ........           BL       GUI_ALLOC_h2p
   \   0000002C   F620D0E1           LDRSH    R2,[R0, #+6]
   \   00000030   0C3090E5           LDR      R3,[R0, #+12]
   \   00000034   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000038   022045E0           SUB      R2,R5,R2
   \   0000003C   930220E0           MLA      R0,R3,R2,R0
   \   00000040   0111A0E1           LSL      R1,R1,#+2
   \   00000044   001061E2           RSB      R1,R1,#+0
   \   00000048   040180E0           ADD      R0,R0,R4, LSL #+2
   \   0000004C   000081E0           ADD      R0,R1,R0
   \   00000050   188080E2           ADD      R8,R0,#+24
    633            BytesPerLine = pDev->BytesPerLine;
    634            Len          = x1 - x0 + 1;
   \   00000054   040049E0           SUB      R0,R9,R4
   \   00000058   019080E2           ADD      R9,R0,#+1
    635            ColorIndex   = LCD__GetColorIndex();
   \   0000005C   ........           LDR      R0,??DataTable11_2
   \   00000060   0C1097E5           LDR      R1,[R7, #+12]
   \   00000064   000090E5           LDR      R0,[R0, #+0]
   \   00000068   04108DE5           STR      R1,[SP, #+4]
   \   0000006C   00A090E5           LDR      R10,[R0, #+0]
    636            /* Mark rectangle as modified */
    637            if (pDev->hUsage) {
   \   00000070   140097E5           LDR      R0,[R7, #+20]
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   0800000A           BEQ      ??_FillRect_0
    638              GUI_USAGE_AddRect(GUI_USAGE_H2P(pDev->hUsage), x0, y0, Len, y1 - y0 + 1);
   \   0000007C   ........           BL       GUI_ALLOC_h2p
   \   00000080   30109DE5           LDR      R1,[SP, #+48]
   \   00000084   0930A0E1           MOV      R3,R9
   \   00000088   051041E0           SUB      R1,R1,R5
   \   0000008C   011081E2           ADD      R1,R1,#+1
   \   00000090   00108DE5           STR      R1,[SP, #+0]
   \   00000094   0520A0E1           MOV      R2,R5
   \   00000098   0410A0E1           MOV      R1,R4
   \   0000009C   ........           BL       GUI_USAGE_AddRect
    639            }
    640            /* Do the drawing */
    641            for (; y0 <= y1; y0++) {
   \                     ??_FillRect_0:
   \   000000A0   30009DE5           LDR      R0,[SP, #+48]
   \   000000A4   050050E1           CMP      R0,R5
   \   000000A8   1B0000BA           BLT      ??_FillRect_1
    642              if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \                     ??_FillRect_2:
   \   000000AC   1000D6E5           LDRB     R0,[R6, #+16]
   \   000000B0   010010E3           TST      R0,#0x1
   \   000000B4   0B00000A           BEQ      ??_FillRect_3
    643                RemPixels = Len;
    644                pDest  = pData;
    645                IndexMask = pDev->pDevice->pColorConvAPI->pfGetIndexMask();
   \   000000B8   000097E5           LDR      R0,[R7, #+0]
   \   000000BC   09B0A0E1           MOV      R11,R9
   \   000000C0   100090E5           LDR      R0,[R0, #+16]
   \   000000C4   0840A0E1           MOV      R4,R8
   \   000000C8   080090E5           LDR      R0,[R0, #+8]
   \   000000CC   30FF2FE1           BLX      R0
    646                do {
    647                  *pDest = *pDest ^ IndexMask;
   \                     ??_FillRect_4:
   \   000000D0   001094E5           LDR      R1,[R4, #+0]
    648                  pDest++;
    649                } while (--RemPixels);
   \   000000D4   01B05BE2           SUBS     R11,R11,#+1
   \   000000D8   011020E0           EOR      R1,R0,R1
   \   000000DC   041084E4           STR      R1,[R4], #+4
   \   000000E0   FAFFFF1A           BNE      ??_FillRect_4
   \   000000E4   060000EA           B        ??_FillRect_5
    650              } else {  /* Fill */
    651                #if BITSPERPIXEL == 8
    652                  GUI_MEMSET(pData, ColorIndex, Len);
    653                #elif BITSPERPIXEL == 16
    654                  GUI__memset16(pData, ColorIndex, Len);
    655                #elif (BITSPERPIXEL == 24) || (BITSPERPIXEL == 32)
    656                  if (Len > 0) {
   \                     ??_FillRect_3:
   \   000000E8   010059E3           CMP      R9,#+1
   \   000000EC   040000BA           BLT      ??_FillRect_5
    657                    Cnt = Len;
   \   000000F0   0900A0E1           MOV      R0,R9
    658                    pDest = pData;
   \   000000F4   0840A0E1           MOV      R4,R8
    659                    do {
    660                      *pDest++ = ColorIndex;
   \                     ??_FillRect_6:
   \   000000F8   04A084E4           STR      R10,[R4], #+4
    661                    } while (--Cnt);
   \   000000FC   010050E2           SUBS     R0,R0,#+1
   \   00000100   FCFFFF1A           BNE      ??_FillRect_6
    662                  }
    663                #else
    664                  #error Unsupported
    665                #endif
    666              }
    667              pData = (PIXELINDEX*)((U8*)pData + BytesPerLine); 
   \                     ??_FillRect_5:
   \   00000104   04009DE5           LDR      R0,[SP, #+4]
    668            }
   \   00000108   015085E2           ADD      R5,R5,#+1
   \   0000010C   088080E0           ADD      R8,R0,R8
   \   00000110   30009DE5           LDR      R0,[SP, #+48]
   \   00000114   050050E1           CMP      R0,R5
   \   00000118   E3FFFFAA           BGE      ??_FillRect_2
    669          }
   \                     ??_FillRect_1:
   \   0000011C   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000120   F08FBDE8           POP      {R4-R11,PC}      ;; return
    670          
    671          /*********************************************************************
    672          *
    673          *       _DrawHLine
    674          */

   \                                 In section .text, align 4, keep-with-next
    675          static void _DrawHLine(GUI_DEVICE * pDevice, int x0, int y, int x1) {
   \                     _DrawHLine:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
    676            _FillRect(pDevice, x0, y, x1, y);
   \   00000008   00208DE5           STR      R2,[SP, #+0]
   \   0000000C   ........           BL       _FillRect
    677          }
   \   00000010   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000014   0080BDE8           POP      {PC}             ;; return
    678          
    679          /*********************************************************************
    680          *
    681          *       _DrawVLine
    682          */

   \                                 In section .text, align 4, keep-with-next
    683          static void _DrawVLine(GUI_DEVICE * pDevice, int x , int y0, int y1) {
   \                     _DrawVLine:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   ........           LDR      R0,??DataTable11_1
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   880090E5           LDR      R0,[R0, #+136]
    684            GUI_MEMDEV * pDev;
    685            GUI_USAGE_h hUsage; 
    686            GUI_USAGE  * pUsage;
    687            PIXELINDEX * pData;
    688            unsigned BytesPerLine;
    689            LCD_PIXELINDEX ColorIndex;
    690          
    691            GUI_USE_PARA(pDevice);
    692            pDev   = GUI_MEMDEV_H2P(GUI_Context.hDevData);
   \   00000014   ........           BL       GUI_ALLOC_h2p
   \   00000018   0060A0E1           MOV      R6,R0
    693            hUsage = pDev->hUsage; 
   \   0000001C   147096E5           LDR      R7,[R6, #+20]
    694            pUsage = hUsage ? GUI_USAGE_H2P(hUsage) : NULL;
   \   00000020   000057E3           CMP      R7,#+0
   \   00000024   0300000A           BEQ      ??_DrawVLine_0
   \   00000028   0700A0E1           MOV      R0,R7
   \   0000002C   ........           BL       GUI_ALLOC_h2p
   \   00000030   0080A0E1           MOV      R8,R0
   \   00000034   000000EA           B        ??_DrawVLine_1
   \                     ??_DrawVLine_0:
   \   00000038   0080A0E3           MOV      R8,#+0
    695            pData  = _XY2PTR(x, y0);
   \                     ??_DrawVLine_1:
   \   0000003C   ........           LDR      R0,??DataTable11_1
   \   00000040   880090E5           LDR      R0,[R0, #+136]
   \   00000044   ........           BL       GUI_ALLOC_h2p
   \   00000048   F620D0E1           LDRSH    R2,[R0, #+6]
   \   0000004C   0C3090E5           LDR      R3,[R0, #+12]
   \   00000050   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000054   022045E0           SUB      R2,R5,R2
   \   00000058   930220E0           MLA      R0,R3,R2,R0
   \   0000005C   0111A0E1           LSL      R1,R1,#+2
   \   00000060   001061E2           RSB      R1,R1,#+0
   \   00000064   040180E0           ADD      R0,R0,R4, LSL #+2
   \   00000068   000081E0           ADD      R0,R1,R0
   \   0000006C   189080E2           ADD      R9,R0,#+24
    696            BytesPerLine = pDev->BytesPerLine;
    697            ColorIndex = LCD__GetColorIndex();
   \   00000070   ........           LDR      R0,??DataTable11_2
   \   00000074   0CA096E5           LDR      R10,[R6, #+12]
   \   00000078   000090E5           LDR      R0,[R0, #+0]
   \   0000007C   00B090E5           LDR      R11,[R0, #+0]
    698            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000080   ........           LDR      R0,??DataTable11_1
   \   00000084   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000088   010010E3           TST      R0,#0x1
   \   0000008C   1600000A           BEQ      ??_DrawVLine_2
    699              PIXELINDEX IndexMask;
    700              IndexMask = pDev->pDevice->pColorConvAPI->pfGetIndexMask();
   \   00000090   000096E5           LDR      R0,[R6, #+0]
   \   00000094   100090E5           LDR      R0,[R0, #+16]
   \   00000098   080090E5           LDR      R0,[R0, #+8]
   \   0000009C   30FF2FE1           BLX      R0
   \   000000A0   00A0A0E1           MOV      R10,R0
    701              do {
    702                if (hUsage) {
   \                     ??_DrawVLine_3:
   \   000000A4   000057E3           CMP      R7,#+0
   \   000000A8   0500000A           BEQ      ??_DrawVLine_4
    703                  GUI_USAGE_AddPixel(pUsage, x, y0);
   \   000000AC   083098E5           LDR      R3,[R8, #+8]
   \   000000B0   0520A0E1           MOV      R2,R5
   \   000000B4   0410A0E1           MOV      R1,R4
   \   000000B8   0800A0E1           MOV      R0,R8
   \   000000BC   003093E5           LDR      R3,[R3, #+0]
   \   000000C0   33FF2FE1           BLX      R3
    704                }
    705                *pData = *pData ^ IndexMask;
   \                     ??_DrawVLine_4:
   \   000000C4   000099E5           LDR      R0,[R9, #+0]
    706                pData = (PIXELINDEX*)((U8*)pData + pDev->BytesPerLine); /* Same as "pData += pDev->BytesPerLine >> 1;", Just more efficient */
    707              } while (++y0 <= y1);
   \   000000C8   015085E2           ADD      R5,R5,#+1
   \   000000CC   00002AE0           EOR      R0,R10,R0
   \   000000D0   000089E5           STR      R0,[R9, #+0]
   \   000000D4   0C0096E5           LDR      R0,[R6, #+12]
   \   000000D8   099080E0           ADD      R9,R0,R9
   \   000000DC   00009DE5           LDR      R0,[SP, #+0]
   \   000000E0   050050E1           CMP      R0,R5
   \   000000E4   EEFFFFAA           BGE      ??_DrawVLine_3
   \   000000E8   150000EA           B        ??_DrawVLine_5
    708            } else {
    709              if (hUsage) {
   \                     ??_DrawVLine_2:
   \   000000EC   000057E3           CMP      R7,#+0
   \   000000F0   0C00000A           BEQ      ??_DrawVLine_6
    710                do {
    711                  GUI_USAGE_AddPixel(pUsage, x, y0);
   \                     ??_DrawVLine_7:
   \   000000F4   083098E5           LDR      R3,[R8, #+8]
   \   000000F8   0520A0E1           MOV      R2,R5
   \   000000FC   0410A0E1           MOV      R1,R4
   \   00000100   0800A0E1           MOV      R0,R8
   \   00000104   003093E5           LDR      R3,[R3, #+0]
   \   00000108   33FF2FE1           BLX      R3
    712                  *pData = ColorIndex;
   \   0000010C   00B089E5           STR      R11,[R9, #+0]
    713                  pData = (PIXELINDEX*)((U8*)pData + BytesPerLine); /* Same as "pData += pDev->BytesPerLine >> 1;", Just more efficient */
    714                } while (++y0 <= y1);
   \   00000110   00009DE5           LDR      R0,[SP, #+0]
   \   00000114   015085E2           ADD      R5,R5,#+1
   \   00000118   09908AE0           ADD      R9,R10,R9
   \   0000011C   050050E1           CMP      R0,R5
   \   00000120   F3FFFFAA           BGE      ??_DrawVLine_7
   \   00000124   060000EA           B        ??_DrawVLine_5
    715              } else {
    716                unsigned NumPixels;
    717                NumPixels = y1 - y0 + 1;
   \                     ??_DrawVLine_6:
   \   00000128   00009DE5           LDR      R0,[SP, #+0]
   \   0000012C   050040E0           SUB      R0,R0,R5
   \   00000130   010080E2           ADD      R0,R0,#+1
    718                do {
    719                  *pData = ColorIndex;
   \                     ??_DrawVLine_8:
   \   00000134   00B089E5           STR      R11,[R9, #+0]
    720                  pData = (PIXELINDEX*)((U8*)pData + BytesPerLine); /* Same as "pData += pDev->BytesPerLine >> 1;", Just more efficient */
   \   00000138   09908AE0           ADD      R9,R10,R9
    721                } while (--NumPixels);
   \   0000013C   010050E2           SUBS     R0,R0,#+1
   \   00000140   FBFFFF1A           BNE      ??_DrawVLine_8
    722              }
    723            }
    724          }
   \                     ??_DrawVLine_5:
   \   00000144   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000148   F08FBDE8           POP      {R4-R11,PC}      ;; return
    725          
    726          /*********************************************************************
    727          *
    728          *       _SetPixelIndex
    729          */

   \                                 In section .text, align 4, keep-with-next
    730          static void _SetPixelIndex(GUI_DEVICE * pDevice, int x, int y, int Index) {
   \                     _SetPixelIndex:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    731            GUI_MEMDEV * pDev;
    732            GUI_USAGE_h hUsage; 
    733            PIXELINDEX * pData;
    734          
    735            GUI_USE_PARA(pDevice);
    736            pDev   = GUI_MEMDEV_H2P(GUI_Context.hDevData);
    737            hUsage = pDev->hUsage; 
   \   00000004   ........           LDR      R8,??DataTable11_1
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   0370A0E1           MOV      R7,R3
   \   00000014   880098E5           LDR      R0,[R8, #+136]
   \   00000018   ........           BL       GUI_ALLOC_h2p
   \   0000001C   146090E5           LDR      R6,[R0, #+20]
    738            pData  = _XY2PTR(x, y);
   \   00000020   880098E5           LDR      R0,[R8, #+136]
   \   00000024   ........           BL       GUI_ALLOC_h2p
    739            *pData = Index;
   \   00000028   F620D0E1           LDRSH    R2,[R0, #+6]
   \   0000002C   0C3090E5           LDR      R3,[R0, #+12]
   \   00000030   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000034   022045E0           SUB      R2,R5,R2
   \   00000038   930220E0           MLA      R0,R3,R2,R0
   \   0000003C   0111A0E1           LSL      R1,R1,#+2
   \   00000040   001061E2           RSB      R1,R1,#+0
   \   00000044   040180E0           ADD      R0,R0,R4, LSL #+2
   \   00000048   000081E0           ADD      R0,R1,R0
   \   0000004C   187080E5           STR      R7,[R0, #+24]
    740            if (hUsage) {
   \   00000050   000056E3           CMP      R6,#+0
   \   00000054   0B00000A           BEQ      ??_SetPixelIndex_0
    741              GUI_USAGE_AddPixel(GUI_USAGE_H2P(hUsage), x, y);
   \   00000058   0600A0E1           MOV      R0,R6
   \   0000005C   ........           BL       GUI_ALLOC_h2p
   \   00000060   0070A0E1           MOV      R7,R0
   \   00000064   0600A0E1           MOV      R0,R6
   \   00000068   ........           BL       GUI_ALLOC_h2p
   \   0000006C   0030A0E1           MOV      R3,R0
   \   00000070   083093E5           LDR      R3,[R3, #+8]
   \   00000074   0520A0E1           MOV      R2,R5
   \   00000078   0410A0E1           MOV      R1,R4
   \   0000007C   0700A0E1           MOV      R0,R7
   \   00000080   003093E5           LDR      R3,[R3, #+0]
   \   00000084   33FF2FE1           BLX      R3
    742            }
    743          }
   \                     ??_SetPixelIndex_0:
   \   00000088   F081BDE8           POP      {R4-R8,PC}       ;; return
    744          
    745          /*********************************************************************
    746          *
    747          *       _XorPixel
    748          */

   \                                 In section .text, align 4, keep-with-next
    749          static void _XorPixel(GUI_DEVICE * pDevice, int x, int y) {
   \                     _XorPixel:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    750            PIXELINDEX IndexMask;
    751            GUI_MEMDEV * pDev;
    752            GUI_USAGE_h hUsage; 
    753            PIXELINDEX * pData;
    754          
    755            GUI_USE_PARA(pDevice);
    756            pDev      = GUI_MEMDEV_H2P(GUI_Context.hDevData);
   \   00000004   ........           LDR      R8,??DataTable11_1
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   880098E5           LDR      R0,[R8, #+136]
   \   00000014   ........           BL       GUI_ALLOC_h2p
   \   00000018   0070A0E1           MOV      R7,R0
    757            hUsage    = pDev->hUsage; 
   \   0000001C   146097E5           LDR      R6,[R7, #+20]
    758            pData     = _XY2PTR(x, y);
   \   00000020   880098E5           LDR      R0,[R8, #+136]
   \   00000024   ........           BL       GUI_ALLOC_h2p
   \   00000028   F620D0E1           LDRSH    R2,[R0, #+6]
   \   0000002C   0C3090E5           LDR      R3,[R0, #+12]
   \   00000030   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000034   022045E0           SUB      R2,R5,R2
   \   00000038   930220E0           MLA      R0,R3,R2,R0
   \   0000003C   0111A0E1           LSL      R1,R1,#+2
   \   00000040   001061E2           RSB      R1,R1,#+0
   \   00000044   040180E0           ADD      R0,R0,R4, LSL #+2
   \   00000048   000081E0           ADD      R0,R1,R0
   \   0000004C   188080E2           ADD      R8,R0,#+24
    759            IndexMask = pDev->pDevice->pColorConvAPI->pfGetIndexMask();
   \   00000050   000097E5           LDR      R0,[R7, #+0]
   \   00000054   100090E5           LDR      R0,[R0, #+16]
   \   00000058   080090E5           LDR      R0,[R0, #+8]
   \   0000005C   30FF2FE1           BLX      R0
    760            *pData    = *pData ^ IndexMask;
   \   00000060   001098E5           LDR      R1,[R8, #+0]
    761            if (hUsage) {
   \   00000064   000056E3           CMP      R6,#+0
   \   00000068   010020E0           EOR      R0,R0,R1
   \   0000006C   000088E5           STR      R0,[R8, #+0]
   \   00000070   0B00000A           BEQ      ??_XorPixel_0
    762              GUI_USAGE_AddPixel(GUI_USAGE_H2P(hUsage), x, y);
   \   00000074   0600A0E1           MOV      R0,R6
   \   00000078   ........           BL       GUI_ALLOC_h2p
   \   0000007C   0070A0E1           MOV      R7,R0
   \   00000080   0600A0E1           MOV      R0,R6
   \   00000084   ........           BL       GUI_ALLOC_h2p
   \   00000088   0030A0E1           MOV      R3,R0
   \   0000008C   083093E5           LDR      R3,[R3, #+8]
   \   00000090   0520A0E1           MOV      R2,R5
   \   00000094   0410A0E1           MOV      R1,R4
   \   00000098   0700A0E1           MOV      R0,R7
   \   0000009C   003093E5           LDR      R3,[R3, #+0]
   \   000000A0   33FF2FE1           BLX      R3
    763            }
    764          }
   \                     ??_XorPixel_0:
   \   000000A4   F081BDE8           POP      {R4-R8,PC}       ;; return
    765          
    766          /*********************************************************************
    767          *
    768          *       _GetPixelIndex
    769          */

   \                                 In section .text, align 4, keep-with-next
    770          static unsigned int _GetPixelIndex(GUI_DEVICE * pDevice, int x, int y) {
   \                     _GetPixelIndex:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    771            PIXELINDEX * pData;
    772            
    773            GUI_USE_PARA(pDevice);
    774            pData = _XY2PTR(x, y);
   \   00000004   ........           LDR      R0,??DataTable11_1
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   880090E5           LDR      R0,[R0, #+136]
   \   00000018   ........           BL       GUI_ALLOC_h2p
    775            return *pData;
   \   0000001C   F620D0E1           LDRSH    R2,[R0, #+6]
   \   00000020   0C3090E5           LDR      R3,[R0, #+12]
   \   00000024   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000028   022045E0           SUB      R2,R5,R2
   \   0000002C   930220E0           MLA      R0,R3,R2,R0
   \   00000030   0111A0E1           LSL      R1,R1,#+2
   \   00000034   001061E2           RSB      R1,R1,#+0
   \   00000038   040180E0           ADD      R0,R0,R4, LSL #+2
   \   0000003C   000081E0           ADD      R0,R1,R0
   \   00000040   180090E5           LDR      R0,[R0, #+24]
   \   00000044   04D08DE2           ADD      SP,SP,#+4
   \   00000048   3080BDE8           POP      {R4,R5,PC}       ;; return
    776          }
    777          
    778          /*********************************************************************
    779          *
    780          *       _GetRect
    781          */

   \                                 In section .text, align 4, keep-with-next
    782          static void _GetRect(GUI_DEVICE * pDevice, LCD_RECT * pRect) {
   \                     _GetRect:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0140A0E1           MOV      R4,R1
    783            GUI_MEMDEV * pDev = GUI_MEMDEV_H2P(pDevice->u.hContext);
   \   00000008   080090E5           LDR      R0,[R0, #+8]
   \   0000000C   ........           BL       GUI_ALLOC_h2p
    784            pRect->x0 = pDev->x0;
   \   00000010   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000014   B010C4E1           STRH     R1,[R4, #+0]
    785            pRect->y0 = pDev->y0;
   \   00000018   F610D0E1           LDRSH    R1,[R0, #+6]
   \   0000001C   B210C4E1           STRH     R1,[R4, #+2]
    786            pRect->x1 = pDev->x0 + pDev->XSize-1;
   \   00000020   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000024   F820D0E1           LDRSH    R2,[R0, #+8]
   \   00000028   011082E0           ADD      R1,R2,R1
   \   0000002C   011041E2           SUB      R1,R1,#+1
   \   00000030   B410C4E1           STRH     R1,[R4, #+4]
    787            pRect->y1 = pDev->y0 + pDev->YSize-1;
   \   00000034   F610D0E1           LDRSH    R1,[R0, #+6]
   \   00000038   FA00D0E1           LDRSH    R0,[R0, #+10]
   \   0000003C   010080E0           ADD      R0,R0,R1
   \   00000040   010040E2           SUB      R0,R0,#+1
   \   00000044   B600C4E1           STRH     R0,[R4, #+6]
    788          }
   \   00000048   1080BDE8           POP      {R4,PC}          ;; return
    789          
    790          /*********************************************************************
    791          *
    792          *       _GetDevData
    793          */

   \                                 In section .text, align 4, keep-with-next
    794          static void * _GetDevData(GUI_DEVICE * pDevice, int Index) {
    795            GUI_USE_PARA(pDevice);
    796            switch (Index) {
   \                     _GetDevData:
   \   00000000   010051E3           CMP      R1,#+1
   \   00000004   0100001A           BNE      ??_GetDevData_0
    797            case LCD_DEVDATA_MEMDEV:
    798              return (void *)&DEVICE_API;
   \   00000008   ........           ADR      R0,GUI_MEMDEV_DEVICE_32
   \   0000000C   1EFF2FE1           BX       LR
    799            }
    800            return NULL;
   \                     ??_GetDevData_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
    801          }
    802          
    803          /*********************************************************************
    804          *
    805          *       _GetDevFunc
    806          */

   \                                 In section .text, align 4, keep-with-next
    807          static void (* _GetDevFunc(GUI_DEVICE ** ppDevice, int Index))(void) {
    808            GUI_USE_PARA(ppDevice);
    809            switch (Index) {
   \                     _GetDevFunc:
   \   00000000   160051E3           CMP      R1,#+22
   \   00000004   0100001A           BNE      ??_GetDevFunc_0
    810            case MEMDEV_DEVFUNC_WRITETOACTIVE:
    811              return (void (*)(void))GUI_MEMDEV__WriteToActiveAlpha;
   \   00000008   ........           LDR      R0,??DataTable11_3
   \   0000000C   1EFF2FE1           BX       LR
    812              //return (void (*)(void))GUI_MEMDEV__WriteToActiveOpaque;
    813            }
    814            return NULL;
   \                     ??_GetDevFunc_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
    815          }
    816          
    817          /*********************************************************************
    818          *
    819          *       _GetDevProp
    820          */

   \                                 In section .text, align 4, keep-with-next
    821          static I32 _GetDevProp(GUI_DEVICE * pDevice, int Index) {
    822            GUI_USE_PARA(pDevice);
    823            switch(Index) {
   \                     _GetDevProp:
   \   00000000   080051E3           CMP      R1,#+8
   \   00000004   0100001A           BNE      ??_GetDevProp_0
    824            case LCD_DEVCAP_BITSPERPIXEL:
    825              return 32;
   \   00000008   2000A0E3           MOV      R0,#+32
   \   0000000C   1EFF2FE1           BX       LR
    826            }
    827            return 0;
   \                     ??_GetDevProp_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
    828          }
    829          
    830          /*********************************************************************
    831          *
    832          *       GUI_DEVICE_API functions: From here there is nothing to do except routing...
    833          */

   \                                 In section .text, align 4, keep-with-next
    834          static void _SetOrg(GUI_DEVICE * pDevice, int x, int y) {
    835            pDevice = pDevice->pNext;
   \                     _SetOrg:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    836            pDevice->pDeviceAPI->pfSetOrg(pDevice, x, y);
   \   00000004   0C3090E5           LDR      R3,[R0, #+12]
   \   00000008   203093E5           LDR      R3,[R3, #+32]
   \   0000000C   13FF2FE1           BX       R3               ;; tailcall
    837          }
    838          
    839          /*********************************************************************
    840          *
    841          *       GUI_DEVICE_API structure
    842          */

   \                                 In section .text, align 4, keep-with-next
    843          const GUI_DEVICE_API DEVICE_API = {
   \                     GUI_MEMDEV_DEVICE_32:
   \   00000000                      ; Initializer data, 52 bytes
   \   00000000   04000000....       DC32 4, _DrawBitmap, _DrawHLine, _DrawVLine, _FillRect, _GetPixelIndex, _SetPixelIndex, _XorPixel, _SetOrg, _GetDevFunc
   \              ............
   \              ............
   \              ............
   \              ............
   \              ............
   \              ........    
   \   00000028   ............       DC32 _GetDevProp, _GetDevData, _GetRect
   \              ............

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     LCD_aMirror

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   ........           DC32     GUI_MEMDEV__WriteToActiveAlpha
    844            //
    845            // Data
    846            //
    847            DEVICE_CLASS_MEMDEV,
    848            //
    849            // Drawing functions
    850            //
    851            _DrawBitmap   ,
    852            _DrawHLine    ,
    853            _DrawVLine    ,
    854            _FillRect     ,
    855            _GetPixelIndex,
    856            _SetPixelIndex,
    857            _XorPixel     ,
    858            //
    859            // Set origin
    860            //
    861            _SetOrg       ,
    862            //
    863            // Initialization
    864            //
    865            //
    866            // Request information
    867            //
    868            _GetDevFunc   ,
    869            _GetDevProp   ,
    870            _GetDevData,
    871            _GetRect      ,
    872          };
    873          
    874          #else
    875          
    876          void GUIDEV_32_C(void);
    877          void GUIDEV_32_C(void) {}
    878          
    879          #endif /* GUI_SUPPORT_MEMDEV */
    880          
    881          /*************************** end of file ****************************/

   Maximum stack usage in bytes:

     Function              .cstack
     --------              -------
     _DrawBitLine1BPP          40
     _DrawBitLine2BPP          40
     _DrawBitLine32BPP_DDB     24
     _DrawBitLine4BPP          40
     _DrawBitmap               72
     _DrawHLine                 8
     _DrawVLine                40
     _FillRect                 48
     _GetDevData                0
     _GetDevFunc                0
     _GetDevProp                0
     _GetPixelIndex            16
     _GetRect                   8
     _SetOrg                    8
     _SetPixelIndex            24
     _XorPixel                 24


   Section sizes:

     Function/Label        Bytes
     --------------        -----
     _DrawBitLine32BPP_DDB  196
     aID                     64
     _DrawBitLine1BPP       424
     _DrawBitLine2BPP       352
     _DrawBitLine4BPP       564
     _DrawBitmap           1276
     _FillRect              292
     _DrawHLine              24
     _DrawVLine             332
     _SetPixelIndex         140
     _XorPixel              168
     _GetPixelIndex          76
     _GetRect                76
     _GetDevData             24
     _GetDevFunc             24
     _GetDevProp             24
     _SetOrg                 16
     GUI_MEMDEV_DEVICE_32    52
     ??DataTable11            4
     ??DataTable11_1          4
     ??DataTable11_2          4
     ??DataTable11_3          4

 
 4 140 bytes in section .text
 
 4 140 bytes of CODE memory

Errors: none
Warnings: none
