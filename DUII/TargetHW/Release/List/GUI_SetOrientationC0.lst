###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:15:47 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUI_SetOrientationC0.c              #
#    Command line =  C:\DUII\TargetHW\GUI\GUI_SetOrientationC0.c -D DEBUG=1   #
#                    -D SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D  #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUI_SetOrientationC0.lst   #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUI_SetOrientationC0.o      #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUI_SetOrientationC0.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUI_SetOrientationC0.c
     19          Purpose     : Runtime display orientation without cache
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include "GUI_SetOrientation.h"
     24          
     25          /*********************************************************************
     26          *
     27          *       Static code
     28          *
     29          **********************************************************************
     30          */
     31          /*********************************************************************
     32          *
     33          *       _Sort
     34          *
     35          * Purpose:
     36          *   Sorts the values pointed by the given pointers. Please note that
     37          *   the same static function is also in GUI_SetOrientationCX.h
     38          *   to enable better compiler optimization.
     39          */
     40          static void _Sort(int * p0, int * p1) {
     41            int temp;
     42          
     43            if (*p0 > *p1) {
     44              temp = *p0;
     45              *p0 = *p1;
     46              *p1 = temp;
     47            }
     48          }
     49          
     50          /*********************************************************************
     51          *
     52          *       Static code: Bitmap drawing routines
     53          *
     54          **********************************************************************
     55          */
     56          /*********************************************************************
     57          *
     58          *       Draw Bitmap 1 BPP
     59          */

   \                                 In section .text, align 4, keep-with-next
     60          static void _DrawBitLine1BPP(GUI_DEVICE * pDevice, unsigned x, unsigned y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine1BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   28709DE5           LDR      R7,[SP, #+40]
   \   0000000C   0250A0E1           MOV      R5,R2
     61            LCD_PIXELINDEX IndexMask, Index0, Index1, Pixel;
     62            unsigned (* pfGetPixelIndex)(GUI_DEVICE * pDevice, int x, int y);
     63            void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
     64          
     65            pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
     66            Index0 = *(pTrans + 0);
     67            Index1 = *(pTrans + 1);
     68            x += Diff;
   \   00000010   01B087E0           ADD      R11,R7,R1
     69            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000014   ........           LDR      R1,??DataTable4
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   30209DE5           LDR      R2,[SP, #+48]
   \   00000020   0C0094E5           LDR      R0,[R4, #+12]
   \   00000024   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000028   00C092E5           LDR      R12,[R2, #+0]
   \   0000002C   189090E5           LDR      R9,[R0, #+24]
   \   00000030   00C08DE5           STR      R12,[SP, #+0]
   \   00000034   031001E2           AND      R1,R1,#0x3
   \   00000038   0360A0E1           MOV      R6,R3
   \   0000003C   2C809DE5           LDR      R8,[SP, #+44]
   \   00000040   04A092E5           LDR      R10,[R2, #+4]
   \   00000044   030051E3           CMP      R1,#+3
   \   00000048   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitLine1BPP_0:
   \   0000004C   3F00008A           BHI      ??_DrawBitLine1BPP_1
   \   00000050   020000EA           B        ??_DrawBitLine1BPP_2
   \   00000054   230000EA           B        ??_DrawBitLine1BPP_3
   \   00000058   110000EA           B        ??_DrawBitLine1BPP_4
   \   0000005C   210000EA           B        ??_DrawBitLine1BPP_3
     70            case 0:
     71              do {
     72                pfSetPixelIndex(pDevice, x++, y, (*p & (0x80 >> Diff)) ? Index1 : Index0);
   \                     ??_DrawBitLine1BPP_2:
   \   00000060   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000064   8010A0E3           MOV      R1,#+128
   \   00000068   0520A0E1           MOV      R2,R5
   \   0000006C   510710E1           TST      R0,R1, ASR R7
   \   00000070   0A30A011           MOVNE    R3,R10
   \   00000074   00309D05           LDREQ    R3,[SP, #+0]
   \   00000078   0B10A0E1           MOV      R1,R11
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   39FF2FE1           BLX      R9
     73                if (++Diff == 8) {
   \   00000084   017087E2           ADD      R7,R7,#+1
   \   00000088   080057E3           CMP      R7,#+8
     74                  Diff = 0;
   \   0000008C   0070A003           MOVEQ    R7,#+0
     75                  p++;
   \   00000090   01608602           ADDEQ    R6,R6,#+1
   \   00000094   01B08BE2           ADD      R11,R11,#+1
     76                }
     77              } while (--xsize);
   \   00000098   018058E2           SUBS     R8,R8,#+1
   \   0000009C   EFFFFF1A           BNE      ??_DrawBitLine1BPP_2
   \   000000A0   2A0000EA           B        ??_DrawBitLine1BPP_1
     78              break;
     79            case LCD_DRAWMODE_TRANS:
     80              do {
     81                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_4:
   \   000000A4   0000D6E5           LDRB     R0,[R6, #+0]
   \   000000A8   8010A0E3           MOV      R1,#+128
   \   000000AC   510710E1           TST      R0,R1, ASR R7
   \   000000B0   0400000A           BEQ      ??_DrawBitLine1BPP_5
     82                  pfSetPixelIndex(pDevice, x, y, Index1);
   \   000000B4   0A30A0E1           MOV      R3,R10
   \   000000B8   0520A0E1           MOV      R2,R5
   \   000000BC   0B10A0E1           MOV      R1,R11
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   39FF2FE1           BLX      R9
     83                }
     84                x++;
     85                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_5:
   \   000000C8   017087E2           ADD      R7,R7,#+1
   \   000000CC   080057E3           CMP      R7,#+8
     86                  Diff = 0;
   \   000000D0   0070A003           MOVEQ    R7,#+0
     87                  p++;
   \   000000D4   01608602           ADDEQ    R6,R6,#+1
   \   000000D8   01B08BE2           ADD      R11,R11,#+1
     88                }
     89              } while (--xsize);
   \   000000DC   018058E2           SUBS     R8,R8,#+1
   \   000000E0   EFFFFF1A           BNE      ??_DrawBitLine1BPP_4
   \   000000E4   190000EA           B        ??_DrawBitLine1BPP_1
     90              break;
     91            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
     92            case LCD_DRAWMODE_XOR:
     93              pfGetPixelIndex = pDevice->pDeviceAPI->pfGetPixelIndex;
   \                     ??_DrawBitLine1BPP_3:
   \   000000E8   14A090E5           LDR      R10,[R0, #+20]
     94              IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \   000000EC   100094E5           LDR      R0,[R4, #+16]
   \   000000F0   080090E5           LDR      R0,[R0, #+8]
   \   000000F4   30FF2FE1           BLX      R0
   \   000000F8   00008DE5           STR      R0,[SP, #+0]
     95              do {
     96                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_6:
   \   000000FC   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000100   8010A0E3           MOV      R1,#+128
   \   00000104   510710E1           TST      R0,R1, ASR R7
   \   00000108   0900000A           BEQ      ??_DrawBitLine1BPP_7
     97                  Pixel = pfGetPixelIndex(pDevice, x, y);
   \   0000010C   0520A0E1           MOV      R2,R5
   \   00000110   0B10A0E1           MOV      R1,R11
   \   00000114   0400A0E1           MOV      R0,R4
   \   00000118   3AFF2FE1           BLX      R10
     98                  pfSetPixelIndex(pDevice, x, y, Pixel ^ IndexMask);
   \   0000011C   00109DE5           LDR      R1,[SP, #+0]
   \   00000120   0520A0E1           MOV      R2,R5
   \   00000124   003021E0           EOR      R3,R1,R0
   \   00000128   0B10A0E1           MOV      R1,R11
   \   0000012C   0400A0E1           MOV      R0,R4
   \   00000130   39FF2FE1           BLX      R9
     99                }
    100                x++;
    101                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_7:
   \   00000134   017087E2           ADD      R7,R7,#+1
   \   00000138   080057E3           CMP      R7,#+8
    102                  Diff = 0;
   \   0000013C   0070A003           MOVEQ    R7,#+0
    103                  p++;
   \   00000140   01608602           ADDEQ    R6,R6,#+1
   \   00000144   01B08BE2           ADD      R11,R11,#+1
    104                }
    105              } while (--xsize);
   \   00000148   018058E2           SUBS     R8,R8,#+1
   \   0000014C   EAFFFF1A           BNE      ??_DrawBitLine1BPP_6
    106              break;
    107            }
    108          }
   \                     ??_DrawBitLine1BPP_1:
   \   00000150   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000154   F08FBDE8           POP      {R4-R11,PC}      ;; return
    109          
    110          /*********************************************************************
    111          *
    112          *       Draw Bitmap 2 BPP
    113          */

   \                                 In section .text, align 4, keep-with-next
    114          static void _DrawBitLine2BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine2BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    115            LCD_PIXELINDEX Pixels, PixelIndex;
    116            int CurrentPixel, Shift, Index;
    117            void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
    118          
    119            pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
   \   00000008   0C0095E5           LDR      R0,[R5, #+12]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   189090E5           LDR      R9,[R0, #+24]
    120            Pixels = *p;
    121            CurrentPixel = Diff;
    122            x += Diff;
    123            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000014   ........           LDR      R0,??DataTable4
   \   00000018   28409DE5           LDR      R4,[SP, #+40]
   \   0000001C   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000020   0370A0E1           MOV      R7,R3
   \   00000024   0260A0E1           MOV      R6,R2
   \   00000028   2C809DE5           LDR      R8,[SP, #+44]
   \   0000002C   00A0D7E5           LDRB     R10,[R7, #+0]
   \   00000030   01B084E0           ADD      R11,R4,R1
   \   00000034   030010E2           ANDS     R0,R0,#0x3
   \   00000038   0200000A           BEQ      ??_DrawBitLine2BPP_0
   \   0000003C   020050E2           SUBS     R0,R0,#+2
   \   00000040   2B00000A           BEQ      ??_DrawBitLine2BPP_1
   \   00000044   560000EA           B        ??_DrawBitLine2BPP_2
   \                     ??_DrawBitLine2BPP_0:
   \   00000048   30009DE5           LDR      R0,[SP, #+48]
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   1400000A           BEQ      ??_DrawBitLine2BPP_3
    124            case 0:
    125              if (pTrans) {
    126                do {
    127                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_4:
   \   00000054   030064E2           RSB      R0,R4,#+3
   \   00000058   8000A0E1           LSL      R0,R0,#+1
    128                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    129                  PixelIndex = *(pTrans + Index);
    130                  pfSetPixelIndex(pDevice, x++, y, PixelIndex);
   \   0000005C   0020A0E1           MOV      R2,R0
   \   00000060   C010A0E3           MOV      R1,#+192
   \   00000064   062062E2           RSB      R2,R2,#+6
   \   00000068   51120AE0           AND      R1,R10,R1, ASR R2
   \   0000006C   3100A0E1           LSR      R0,R1,R0
   \   00000070   30109DE5           LDR      R1,[SP, #+48]
   \   00000074   0620A0E1           MOV      R2,R6
   \   00000078   003191E7           LDR      R3,[R1, +R0, LSL #+2]
   \   0000007C   0B10A0E1           MOV      R1,R11
   \   00000080   0500A0E1           MOV      R0,R5
   \   00000084   39FF2FE1           BLX      R9
    131                  if (++CurrentPixel == 4) {
   \   00000088   014084E2           ADD      R4,R4,#+1
   \   0000008C   040054E3           CMP      R4,#+4
    132                    CurrentPixel = 0;
   \   00000090   0040A003           MOVEQ    R4,#+0
    133                    Pixels = *(++p);
   \   00000094   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   00000098   01B08BE2           ADD      R11,R11,#+1
    134                  }
    135                } while (--xsize);
   \   0000009C   018058E2           SUBS     R8,R8,#+1
   \   000000A0   EBFFFF1A           BNE      ??_DrawBitLine2BPP_4
   \   000000A4   3E0000EA           B        ??_DrawBitLine2BPP_2
    136              } else {
    137                do {
    138                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_3:
   \   000000A8   030064E2           RSB      R0,R4,#+3
   \   000000AC   8000A0E1           LSL      R0,R0,#+1
    139                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    140                  pfSetPixelIndex(pDevice, x++, y, Index);
   \   000000B0   0020A0E1           MOV      R2,R0
   \   000000B4   C010A0E3           MOV      R1,#+192
   \   000000B8   062062E2           RSB      R2,R2,#+6
   \   000000BC   51120AE0           AND      R1,R10,R1, ASR R2
   \   000000C0   3130A0E1           LSR      R3,R1,R0
   \   000000C4   0620A0E1           MOV      R2,R6
   \   000000C8   0B10A0E1           MOV      R1,R11
   \   000000CC   0500A0E1           MOV      R0,R5
   \   000000D0   39FF2FE1           BLX      R9
    141                  if (++CurrentPixel == 4) {
   \   000000D4   014084E2           ADD      R4,R4,#+1
   \   000000D8   040054E3           CMP      R4,#+4
    142                    CurrentPixel = 0;
   \   000000DC   0040A003           MOVEQ    R4,#+0
    143                    Pixels = *(++p);
   \   000000E0   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   000000E4   01B08BE2           ADD      R11,R11,#+1
    144                  }
    145                } while (--xsize);
   \   000000E8   018058E2           SUBS     R8,R8,#+1
   \   000000EC   EDFFFF1A           BNE      ??_DrawBitLine2BPP_3
   \   000000F0   2B0000EA           B        ??_DrawBitLine2BPP_2
    146              }
   \                     ??_DrawBitLine2BPP_1:
   \   000000F4   30009DE5           LDR      R0,[SP, #+48]
   \   000000F8   000050E3           CMP      R0,#+0
   \   000000FC   1500000A           BEQ      ??_DrawBitLine2BPP_5
    147              break;
    148            case LCD_DRAWMODE_TRANS:
    149              if (pTrans) {
    150                do {
    151                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_6:
   \   00000100   030064E2           RSB      R0,R4,#+3
   \   00000104   8000A0E1           LSL      R0,R0,#+1
    152                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000108   0020A0E1           MOV      R2,R0
   \   0000010C   C010A0E3           MOV      R1,#+192
   \   00000110   062062E2           RSB      R2,R2,#+6
   \   00000114   51120AE0           AND      R1,R10,R1, ASR R2
   \   00000118   3130B0E1           LSRS     R3,R1,R0
    153                  if (Index) {
   \   0000011C   0500000A           BEQ      ??_DrawBitLine2BPP_7
    154                    PixelIndex = *(pTrans + Index);
    155                    pfSetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000120   30009DE5           LDR      R0,[SP, #+48]
   \   00000124   0620A0E1           MOV      R2,R6
   \   00000128   033190E7           LDR      R3,[R0, +R3, LSL #+2]
   \   0000012C   0B10A0E1           MOV      R1,R11
   \   00000130   0500A0E1           MOV      R0,R5
   \   00000134   39FF2FE1           BLX      R9
    156                  }
    157                  x++;
    158                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_7:
   \   00000138   014084E2           ADD      R4,R4,#+1
   \   0000013C   040054E3           CMP      R4,#+4
    159                    CurrentPixel = 0;
   \   00000140   0040A003           MOVEQ    R4,#+0
    160                    Pixels = *(++p);
   \   00000144   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   00000148   01B08BE2           ADD      R11,R11,#+1
    161                  }
    162                } while (--xsize);
   \   0000014C   018058E2           SUBS     R8,R8,#+1
   \   00000150   EAFFFF1A           BNE      ??_DrawBitLine2BPP_6
   \   00000154   120000EA           B        ??_DrawBitLine2BPP_2
    163              } else {
    164                do {
    165                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_5:
   \   00000158   030064E2           RSB      R0,R4,#+3
   \   0000015C   8000A0E1           LSL      R0,R0,#+1
    166                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000160   0020A0E1           MOV      R2,R0
   \   00000164   C010A0E3           MOV      R1,#+192
   \   00000168   062062E2           RSB      R2,R2,#+6
   \   0000016C   51120AE0           AND      R1,R10,R1, ASR R2
   \   00000170   3130B0E1           LSRS     R3,R1,R0
    167                  if (Index) {
   \   00000174   0300000A           BEQ      ??_DrawBitLine2BPP_8
    168                    pfSetPixelIndex(pDevice, x, y, Index);
   \   00000178   0620A0E1           MOV      R2,R6
   \   0000017C   0B10A0E1           MOV      R1,R11
   \   00000180   0500A0E1           MOV      R0,R5
   \   00000184   39FF2FE1           BLX      R9
    169                  }
    170                  x++;
    171                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_8:
   \   00000188   014084E2           ADD      R4,R4,#+1
   \   0000018C   040054E3           CMP      R4,#+4
    172                    CurrentPixel = 0;
   \   00000190   0040A003           MOVEQ    R4,#+0
    173                    Pixels = *(++p);
   \   00000194   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   00000198   01B08BE2           ADD      R11,R11,#+1
    174                  }
    175                } while (--xsize);
   \   0000019C   018058E2           SUBS     R8,R8,#+1
   \   000001A0   ECFFFF1A           BNE      ??_DrawBitLine2BPP_5
    176              }
    177              break;
    178            }
    179          }
   \                     ??_DrawBitLine2BPP_2:
   \   000001A4   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000001A8   F08FBDE8           POP      {R4-R11,PC}      ;; return
    180          
    181          /*********************************************************************
    182          *
    183          *       Draw Bitmap 4 BPP
    184          */

   \                                 In section .text, align 4, keep-with-next
    185          static void _DrawBitLine4BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine4BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    186            LCD_PIXELINDEX Pixels, PixelIndex;
    187            int CurrentPixel, Shift, Index;
    188            void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
    189          
    190            pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
   \   00000008   0C0095E5           LDR      R0,[R5, #+12]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   189090E5           LDR      R9,[R0, #+24]
    191            Pixels = *p;
    192            CurrentPixel = Diff;
    193            x += Diff;
    194            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000014   ........           LDR      R0,??DataTable4
   \   00000018   28409DE5           LDR      R4,[SP, #+40]
   \   0000001C   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000020   0370A0E1           MOV      R7,R3
   \   00000024   0260A0E1           MOV      R6,R2
   \   00000028   2C809DE5           LDR      R8,[SP, #+44]
   \   0000002C   00A0D7E5           LDRB     R10,[R7, #+0]
   \   00000030   01B084E0           ADD      R11,R4,R1
   \   00000034   030010E2           ANDS     R0,R0,#0x3
   \   00000038   0200000A           BEQ      ??_DrawBitLine4BPP_0
   \   0000003C   020050E2           SUBS     R0,R0,#+2
   \   00000040   2B00000A           BEQ      ??_DrawBitLine4BPP_1
   \   00000044   560000EA           B        ??_DrawBitLine4BPP_2
   \                     ??_DrawBitLine4BPP_0:
   \   00000048   30009DE5           LDR      R0,[SP, #+48]
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   1400000A           BEQ      ??_DrawBitLine4BPP_3
    195            case 0:
    196              if (pTrans) {
    197                do {
    198                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_4:
   \   00000054   010064E2           RSB      R0,R4,#+1
   \   00000058   0001A0E1           LSL      R0,R0,#+2
    199                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    200                  PixelIndex = *(pTrans + Index);
    201                  pfSetPixelIndex(pDevice, x++, y, PixelIndex);
   \   0000005C   0020A0E1           MOV      R2,R0
   \   00000060   F010A0E3           MOV      R1,#+240
   \   00000064   042062E2           RSB      R2,R2,#+4
   \   00000068   51120AE0           AND      R1,R10,R1, ASR R2
   \   0000006C   3100A0E1           LSR      R0,R1,R0
   \   00000070   30109DE5           LDR      R1,[SP, #+48]
   \   00000074   0620A0E1           MOV      R2,R6
   \   00000078   003191E7           LDR      R3,[R1, +R0, LSL #+2]
   \   0000007C   0B10A0E1           MOV      R1,R11
   \   00000080   0500A0E1           MOV      R0,R5
   \   00000084   39FF2FE1           BLX      R9
    202                  if (++CurrentPixel == 2) {
   \   00000088   014084E2           ADD      R4,R4,#+1
   \   0000008C   020054E3           CMP      R4,#+2
    203                    CurrentPixel = 0;
   \   00000090   0040A003           MOVEQ    R4,#+0
    204                    Pixels = *(++p);
   \   00000094   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   00000098   01B08BE2           ADD      R11,R11,#+1
    205                  }
    206                } while (--xsize);
   \   0000009C   018058E2           SUBS     R8,R8,#+1
   \   000000A0   EBFFFF1A           BNE      ??_DrawBitLine4BPP_4
   \   000000A4   3E0000EA           B        ??_DrawBitLine4BPP_2
    207              } else {
    208                do {
    209                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_3:
   \   000000A8   010064E2           RSB      R0,R4,#+1
   \   000000AC   0001A0E1           LSL      R0,R0,#+2
    210                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    211                  pfSetPixelIndex(pDevice, x++, y, Index);
   \   000000B0   0020A0E1           MOV      R2,R0
   \   000000B4   F010A0E3           MOV      R1,#+240
   \   000000B8   042062E2           RSB      R2,R2,#+4
   \   000000BC   51120AE0           AND      R1,R10,R1, ASR R2
   \   000000C0   3130A0E1           LSR      R3,R1,R0
   \   000000C4   0620A0E1           MOV      R2,R6
   \   000000C8   0B10A0E1           MOV      R1,R11
   \   000000CC   0500A0E1           MOV      R0,R5
   \   000000D0   39FF2FE1           BLX      R9
    212                  if (++CurrentPixel == 2) {
   \   000000D4   014084E2           ADD      R4,R4,#+1
   \   000000D8   020054E3           CMP      R4,#+2
    213                    CurrentPixel = 0;
   \   000000DC   0040A003           MOVEQ    R4,#+0
    214                    Pixels = *(++p);
   \   000000E0   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   000000E4   01B08BE2           ADD      R11,R11,#+1
    215                  }
    216                } while (--xsize);
   \   000000E8   018058E2           SUBS     R8,R8,#+1
   \   000000EC   EDFFFF1A           BNE      ??_DrawBitLine4BPP_3
   \   000000F0   2B0000EA           B        ??_DrawBitLine4BPP_2
    217              }
   \                     ??_DrawBitLine4BPP_1:
   \   000000F4   30009DE5           LDR      R0,[SP, #+48]
   \   000000F8   000050E3           CMP      R0,#+0
   \   000000FC   1500000A           BEQ      ??_DrawBitLine4BPP_5
    218              break;
    219            case LCD_DRAWMODE_TRANS:
    220              if (pTrans) {
    221                do {
    222                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_6:
   \   00000100   010064E2           RSB      R0,R4,#+1
   \   00000104   0001A0E1           LSL      R0,R0,#+2
    223                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000108   0020A0E1           MOV      R2,R0
   \   0000010C   F010A0E3           MOV      R1,#+240
   \   00000110   042062E2           RSB      R2,R2,#+4
   \   00000114   51120AE0           AND      R1,R10,R1, ASR R2
   \   00000118   3130B0E1           LSRS     R3,R1,R0
    224                  if (Index) {
   \   0000011C   0500000A           BEQ      ??_DrawBitLine4BPP_7
    225                    PixelIndex = *(pTrans + Index);
    226                    pfSetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000120   30009DE5           LDR      R0,[SP, #+48]
   \   00000124   0620A0E1           MOV      R2,R6
   \   00000128   033190E7           LDR      R3,[R0, +R3, LSL #+2]
   \   0000012C   0B10A0E1           MOV      R1,R11
   \   00000130   0500A0E1           MOV      R0,R5
   \   00000134   39FF2FE1           BLX      R9
    227                  }
    228                  x++;
    229                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_7:
   \   00000138   014084E2           ADD      R4,R4,#+1
   \   0000013C   020054E3           CMP      R4,#+2
    230                    CurrentPixel = 0;
   \   00000140   0040A003           MOVEQ    R4,#+0
    231                    Pixels = *(++p);
   \   00000144   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   00000148   01B08BE2           ADD      R11,R11,#+1
    232                  }
    233                } while (--xsize);
   \   0000014C   018058E2           SUBS     R8,R8,#+1
   \   00000150   EAFFFF1A           BNE      ??_DrawBitLine4BPP_6
   \   00000154   120000EA           B        ??_DrawBitLine4BPP_2
    234              } else {
    235                do {
    236                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_5:
   \   00000158   010064E2           RSB      R0,R4,#+1
   \   0000015C   0001A0E1           LSL      R0,R0,#+2
    237                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000160   0020A0E1           MOV      R2,R0
   \   00000164   F010A0E3           MOV      R1,#+240
   \   00000168   042062E2           RSB      R2,R2,#+4
   \   0000016C   51120AE0           AND      R1,R10,R1, ASR R2
   \   00000170   3130B0E1           LSRS     R3,R1,R0
    238                  if (Index) {
   \   00000174   0300000A           BEQ      ??_DrawBitLine4BPP_8
    239                    pfSetPixelIndex(pDevice, x, y, Index);
   \   00000178   0620A0E1           MOV      R2,R6
   \   0000017C   0B10A0E1           MOV      R1,R11
   \   00000180   0500A0E1           MOV      R0,R5
   \   00000184   39FF2FE1           BLX      R9
    240                  }
    241                  x++;
    242                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_8:
   \   00000188   014084E2           ADD      R4,R4,#+1
   \   0000018C   020054E3           CMP      R4,#+2
    243                    CurrentPixel = 0;
   \   00000190   0040A003           MOVEQ    R4,#+0
    244                    Pixels = *(++p);
   \   00000194   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   00000198   01B08BE2           ADD      R11,R11,#+1
    245                  }
    246                } while (--xsize);
   \   0000019C   018058E2           SUBS     R8,R8,#+1
   \   000001A0   ECFFFF1A           BNE      ??_DrawBitLine4BPP_5
    247              }
    248              break;
    249            }
    250          }
   \                     ??_DrawBitLine4BPP_2:
   \   000001A4   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000001A8   F08FBDE8           POP      {R4-R11,PC}      ;; return
    251          
    252          /*********************************************************************
    253          *
    254          *       Draw Bitmap 8 BPP
    255          */

   \                                 In section .text, align 4, keep-with-next
    256          static void _DrawBitLine8BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine8BPP:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    257            LCD_PIXELINDEX Pixel;
    258            void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
    259          
    260            pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
   \   00000008   0C0094E5           LDR      R0,[R4, #+12]
   \   0000000C   0190A0E1           MOV      R9,R1
   \   00000010   188090E5           LDR      R8,[R0, #+24]
    261            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000014   ........           LDR      R0,??DataTable4
   \   00000018   0250A0E1           MOV      R5,R2
   \   0000001C   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000020   0360A0E1           MOV      R6,R3
   \   00000024   20A09DE5           LDR      R10,[SP, #+32]
   \   00000028   24709DE5           LDR      R7,[SP, #+36]
   \   0000002C   030010E2           ANDS     R0,R0,#0x3
   \   00000030   0200000A           BEQ      ??_DrawBitLine8BPP_0
   \   00000034   020050E2           SUBS     R0,R0,#+2
   \   00000038   3700000A           BEQ      ??_DrawBitLine8BPP_1
   \   0000003C   F087BDE8           POP      {R4-R10,PC}
    262            case 0:
    263              if (pTrans) {
   \                     ??_DrawBitLine8BPP_0:
   \   00000040   000057E3           CMP      R7,#+0
   \   00000044   1B00000A           BEQ      ??_DrawBitLine8BPP_2
   \   00000048   01005AE3           CMP      R10,#+1
   \   0000004C   810000BA           BLT      ??_DrawBitLine8BPP_3
   \   00000050   01001AE3           TST      R10,#0x1
   \   00000054   0400000A           BEQ      ??_DrawBitLine8BPP_4
    264                for (; xsize > 0; xsize--, x++, p++) {
    265                  Pixel = *p;
    266                  pfSetPixelIndex(pDevice, x, y, *(pTrans + Pixel));
   \   00000058   0100D6E4           LDRB     R0,[R6], #+1
   \   0000005C   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   38FF2FE1           BLX      R8
   \   00000068   019089E2           ADD      R9,R9,#+1
   \                     ??_DrawBitLine8BPP_4:
   \   0000006C   AAA0B0E1           LSRS     R10,R10,#+1
   \   00000070   7800000A           BEQ      ??_DrawBitLine8BPP_3
   \                     ??_DrawBitLine8BPP_5:
   \   00000074   0100D6E4           LDRB     R0,[R6], #+1
   \   00000078   0520A0E1           MOV      R2,R5
   \   0000007C   0910A0E1           MOV      R1,R9
   \   00000080   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   38FF2FE1           BLX      R8
   \   0000008C   0100D6E4           LDRB     R0,[R6], #+1
   \   00000090   019089E2           ADD      R9,R9,#+1
   \   00000094   0520A0E1           MOV      R2,R5
   \   00000098   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   0000009C   0910A0E1           MOV      R1,R9
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   38FF2FE1           BLX      R8
    267                }
   \   000000A8   019089E2           ADD      R9,R9,#+1
   \   000000AC   01A05AE2           SUBS     R10,R10,#+1
   \   000000B0   EFFFFF1A           BNE      ??_DrawBitLine8BPP_5
   \   000000B4   F087BDE8           POP      {R4-R10,PC}
    268              } else {
   \                     ??_DrawBitLine8BPP_2:
   \   000000B8   01005AE3           CMP      R10,#+1
   \   000000BC   650000BA           BLT      ??_DrawBitLine8BPP_3
   \   000000C0   01001AE3           TST      R10,#0x1
   \   000000C4   0300000A           BEQ      ??_DrawBitLine8BPP_6
    269                for (; xsize > 0; xsize--, x++, p++) {
    270                  pfSetPixelIndex(pDevice, x, y, *p);
   \   000000C8   0130D6E4           LDRB     R3,[R6], #+1
   \   000000CC   0400A0E1           MOV      R0,R4
   \   000000D0   38FF2FE1           BLX      R8
   \   000000D4   019089E2           ADD      R9,R9,#+1
   \                     ??_DrawBitLine8BPP_6:
   \   000000D8   AA70B0E1           LSRS     R7,R10,#+1
   \   000000DC   5D00000A           BEQ      ??_DrawBitLine8BPP_3
   \                     ??_DrawBitLine8BPP_7:
   \   000000E0   0130D6E4           LDRB     R3,[R6], #+1
   \   000000E4   0520A0E1           MOV      R2,R5
   \   000000E8   0910A0E1           MOV      R1,R9
   \   000000EC   0400A0E1           MOV      R0,R4
   \   000000F0   38FF2FE1           BLX      R8
   \   000000F4   019089E2           ADD      R9,R9,#+1
   \   000000F8   0130D6E4           LDRB     R3,[R6], #+1
   \   000000FC   0520A0E1           MOV      R2,R5
   \   00000100   0910A0E1           MOV      R1,R9
   \   00000104   0400A0E1           MOV      R0,R4
   \   00000108   38FF2FE1           BLX      R8
    271                }
   \   0000010C   019089E2           ADD      R9,R9,#+1
   \   00000110   017057E2           SUBS     R7,R7,#+1
   \   00000114   F1FFFF1A           BNE      ??_DrawBitLine8BPP_7
   \   00000118   F087BDE8           POP      {R4-R10,PC}
    272              }
    273              break;
    274            case LCD_DRAWMODE_TRANS:
    275              if (pTrans) {
   \                     ??_DrawBitLine8BPP_1:
   \   0000011C   000057E3           CMP      R7,#+0
   \   00000120   2600000A           BEQ      ??_DrawBitLine8BPP_8
   \   00000124   01005AE3           CMP      R10,#+1
   \   00000128   4A0000BA           BLT      ??_DrawBitLine8BPP_3
   \   0000012C   01A04AE2           SUB      R10,R10,#+1
   \   00000130   0030D6E5           LDRB     R3,[R6, #+0]
   \   00000134   01001AE3           TST      R10,#0x1
   \   00000138   0600000A           BEQ      ??_DrawBitLine8BPP_9
    276                for (; xsize > 0; xsize--, x++, p++) {
    277                  Pixel = *p;
    278                  if (Pixel) {
   \   0000013C   000053E3           CMP      R3,#+0
   \   00000140   0200000A           BEQ      ??_DrawBitLine8BPP_10
    279                    pfSetPixelIndex(pDevice, x, y, *(pTrans + Pixel));
   \   00000144   033197E7           LDR      R3,[R7, +R3, LSL #+2]
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   38FF2FE1           BLX      R8
   \                     ??_DrawBitLine8BPP_10:
   \   00000150   019089E2           ADD      R9,R9,#+1
   \   00000154   0130F6E5           LDRB     R3,[R6, #+1]!
   \                     ??_DrawBitLine8BPP_9:
   \   00000158   AAA0B0E1           LSRS     R10,R10,#+1
   \   0000015C   1300000A           BEQ      ??_DrawBitLine8BPP_11
   \                     ??_DrawBitLine8BPP_12:
   \   00000160   000053E3           CMP      R3,#+0
   \   00000164   0400000A           BEQ      ??_DrawBitLine8BPP_13
   \   00000168   033197E7           LDR      R3,[R7, +R3, LSL #+2]
   \   0000016C   0520A0E1           MOV      R2,R5
   \   00000170   0910A0E1           MOV      R1,R9
   \   00000174   0400A0E1           MOV      R0,R4
   \   00000178   38FF2FE1           BLX      R8
   \                     ??_DrawBitLine8BPP_13:
   \   0000017C   0130F6E5           LDRB     R3,[R6, #+1]!
   \   00000180   019089E2           ADD      R9,R9,#+1
   \   00000184   000053E3           CMP      R3,#+0
   \   00000188   0400000A           BEQ      ??_DrawBitLine8BPP_14
   \   0000018C   033197E7           LDR      R3,[R7, +R3, LSL #+2]
   \   00000190   0520A0E1           MOV      R2,R5
   \   00000194   0910A0E1           MOV      R1,R9
   \   00000198   0400A0E1           MOV      R0,R4
   \   0000019C   38FF2FE1           BLX      R8
   \                     ??_DrawBitLine8BPP_14:
   \   000001A0   019089E2           ADD      R9,R9,#+1
   \   000001A4   0130F6E5           LDRB     R3,[R6, #+1]!
   \   000001A8   01A05AE2           SUBS     R10,R10,#+1
   \   000001AC   EBFFFF1A           BNE      ??_DrawBitLine8BPP_12
   \                     ??_DrawBitLine8BPP_11:
   \   000001B0   000053E3           CMP      R3,#+0
   \   000001B4   2700000A           BEQ      ??_DrawBitLine8BPP_3
   \   000001B8   033197E7           LDR      R3,[R7, +R3, LSL #+2]
   \   000001BC   210000EA           B        ??_DrawBitLine8BPP_15
    280                  }
    281                }
    282              } else {
   \                     ??_DrawBitLine8BPP_8:
   \   000001C0   01005AE3           CMP      R10,#+1
   \   000001C4   230000BA           BLT      ??_DrawBitLine8BPP_3
   \   000001C8   01704AE2           SUB      R7,R10,#+1
   \   000001CC   0030D6E5           LDRB     R3,[R6, #+0]
   \   000001D0   010017E3           TST      R7,#0x1
   \   000001D4   0500000A           BEQ      ??_DrawBitLine8BPP_16
    283                for (; xsize > 0; xsize--, x++, p++) {
    284                  Pixel = *p;
    285                  if (Pixel) {
   \   000001D8   000053E3           CMP      R3,#+0
   \   000001DC   0100000A           BEQ      ??_DrawBitLine8BPP_17
    286                    pfSetPixelIndex(pDevice, x, y, Pixel);
   \   000001E0   0400A0E1           MOV      R0,R4
   \   000001E4   38FF2FE1           BLX      R8
   \                     ??_DrawBitLine8BPP_17:
   \   000001E8   019089E2           ADD      R9,R9,#+1
   \   000001EC   0130F6E5           LDRB     R3,[R6, #+1]!
   \                     ??_DrawBitLine8BPP_16:
   \   000001F0   A770B0E1           LSRS     R7,R7,#+1
   \   000001F4   1100000A           BEQ      ??_DrawBitLine8BPP_18
   \                     ??_DrawBitLine8BPP_19:
   \   000001F8   000053E3           CMP      R3,#+0
   \   000001FC   0300000A           BEQ      ??_DrawBitLine8BPP_20
   \   00000200   0520A0E1           MOV      R2,R5
   \   00000204   0910A0E1           MOV      R1,R9
   \   00000208   0400A0E1           MOV      R0,R4
   \   0000020C   38FF2FE1           BLX      R8
   \                     ??_DrawBitLine8BPP_20:
   \   00000210   0130F6E5           LDRB     R3,[R6, #+1]!
   \   00000214   019089E2           ADD      R9,R9,#+1
   \   00000218   000053E3           CMP      R3,#+0
   \   0000021C   0300000A           BEQ      ??_DrawBitLine8BPP_21
   \   00000220   0520A0E1           MOV      R2,R5
   \   00000224   0910A0E1           MOV      R1,R9
   \   00000228   0400A0E1           MOV      R0,R4
   \   0000022C   38FF2FE1           BLX      R8
   \                     ??_DrawBitLine8BPP_21:
   \   00000230   019089E2           ADD      R9,R9,#+1
   \   00000234   0130F6E5           LDRB     R3,[R6, #+1]!
   \   00000238   017057E2           SUBS     R7,R7,#+1
   \   0000023C   EDFFFF1A           BNE      ??_DrawBitLine8BPP_19
   \                     ??_DrawBitLine8BPP_18:
   \   00000240   000053E3           CMP      R3,#+0
   \   00000244   0300000A           BEQ      ??_DrawBitLine8BPP_3
   \                     ??_DrawBitLine8BPP_15:
   \   00000248   0520A0E1           MOV      R2,R5
   \   0000024C   0910A0E1           MOV      R1,R9
   \   00000250   0400A0E1           MOV      R0,R4
   \   00000254   38FF2FE1           BLX      R8
    287                  }
    288                }
    289              }
    290              break;
    291            }
    292          }
   \                     ??_DrawBitLine8BPP_3:
   \   00000258   F087BDE8           POP      {R4-R10,PC}      ;; return
    293          
    294          /*********************************************************************
    295          *
    296          *       Draw Bitmap 16 BPP
    297          */
    298          static void _DrawBitLine16BPP(GUI_DEVICE * pDevice, int x, int y, U16 const GUI_UNI_PTR * p, int xsize) {
    299            LCD_PIXELINDEX Pixel;
    300            void (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
    301          
    302            pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
    303            for (; xsize > 0; xsize--, x++, p++) {
    304              Pixel = *p;
    305              pfSetPixelIndex(pDevice, x, y, Pixel);
    306            }
    307          }
    308          
    309          /*********************************************************************
    310          *
    311          *       Draw Bitmap 32 BPP
    312          */
    313          static void _DrawBitLine32BPP(GUI_DEVICE * pDevice, int x, int y, U32 const GUI_UNI_PTR * p, int xsize) {
    314            LCD_PIXELINDEX Pixel;
    315            void (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
    316          
    317            pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
    318            for (; xsize > 0; xsize--, x++, p++) {
    319              Pixel = *p;
    320              pfSetPixelIndex(pDevice, x, y, Pixel);
    321            }
    322          }
    323          
    324          /*********************************************************************
    325          *
    326          *       Static code: API functions for drawing operations, no cache
    327          *
    328          **********************************************************************
    329          */
    330          /*********************************************************************
    331          *
    332          *       _DrawBitmap_C0
    333          */

   \                                 In section .text, align 4, keep-with-next
    334          static void _DrawBitmap_C0(GUI_DEVICE * pDevice, int x0, int y0,
    335                                 int xSize, int ySize,
    336                                 int BitsPerPixel, 
    337                                 int BytesPerLine,
    338                                 const U8 GUI_UNI_PTR * pData, int Diff,
    339                                 const LCD_PIXELINDEX* pTrans) {
   \                     _DrawBitmap_C0:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   3C009DE5           LDR      R0,[SP, #+60]
   \   00000010   0160A0E1           MOV      R6,R1
    340            int i;
    341          
    342            switch (BitsPerPixel) {
   \   00000014   010040E2           SUB      R0,R0,#+1
   \   00000018   0240A0E1           MOV      R4,R2
   \   0000001C   44909DE5           LDR      R9,[SP, #+68]
   \   00000020   48709DE5           LDR      R7,[SP, #+72]
   \   00000024   4C809DE5           LDR      R8,[SP, #+76]
   \   00000028   1F0050E3           CMP      R0,#+31
   \   0000002C   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_DrawBitmap_C0_0:
   \   00000030   3701008A           BHI      ??_DrawBitmap_C0_1
   \   00000034   1E0000EA           B        ??_DrawBitmap_C0_2
   \   00000038   4A0000EA           B        ??_DrawBitmap_C0_3
   \   0000003C   340100EA           B        ??_DrawBitmap_C0_1
   \   00000040   750000EA           B        ??_DrawBitmap_C0_4
   \   00000044   320100EA           B        ??_DrawBitmap_C0_1
   \   00000048   310100EA           B        ??_DrawBitmap_C0_1
   \   0000004C   300100EA           B        ??_DrawBitmap_C0_1
   \   00000050   9E0000EA           B        ??_DrawBitmap_C0_5
   \   00000054   2E0100EA           B        ??_DrawBitmap_C0_1
   \   00000058   2D0100EA           B        ??_DrawBitmap_C0_1
   \   0000005C   2C0100EA           B        ??_DrawBitmap_C0_1
   \   00000060   2B0100EA           B        ??_DrawBitmap_C0_1
   \   00000064   2A0100EA           B        ??_DrawBitmap_C0_1
   \   00000068   290100EA           B        ??_DrawBitmap_C0_1
   \   0000006C   280100EA           B        ??_DrawBitmap_C0_1
   \   00000070   C00000EA           B        ??_DrawBitmap_C0_6
   \   00000074   260100EA           B        ??_DrawBitmap_C0_1
   \   00000078   250100EA           B        ??_DrawBitmap_C0_1
   \   0000007C   240100EA           B        ??_DrawBitmap_C0_1
   \   00000080   230100EA           B        ??_DrawBitmap_C0_1
   \   00000084   220100EA           B        ??_DrawBitmap_C0_1
   \   00000088   210100EA           B        ??_DrawBitmap_C0_1
   \   0000008C   200100EA           B        ??_DrawBitmap_C0_1
   \   00000090   1F0100EA           B        ??_DrawBitmap_C0_1
   \   00000094   1E0100EA           B        ??_DrawBitmap_C0_1
   \   00000098   1D0100EA           B        ??_DrawBitmap_C0_1
   \   0000009C   1C0100EA           B        ??_DrawBitmap_C0_1
   \   000000A0   1B0100EA           B        ??_DrawBitmap_C0_1
   \   000000A4   1A0100EA           B        ??_DrawBitmap_C0_1
   \   000000A8   190100EA           B        ??_DrawBitmap_C0_1
   \   000000AC   180100EA           B        ??_DrawBitmap_C0_1
   \   000000B0   E40000EA           B        ??_DrawBitmap_C0_7
    343            case 1:
    344              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_C0_2:
   \   000000B4   38009DE5           LDR      R0,[SP, #+56]
   \   000000B8   010050E3           CMP      R0,#+1
   \   000000BC   140100BA           BLT      ??_DrawBitmap_C0_1
   \   000000C0   00A0A0E1           MOV      R10,R0
   \   000000C4   01001AE3           TST      R10,#0x1
   \   000000C8   0900000A           BEQ      ??_DrawBitmap_C0_8
    345                _DrawBitLine1BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   000000CC   10009DE5           LDR      R0,[SP, #+16]
   \   000000D0   08808DE5           STR      R8,[SP, #+8]
   \   000000D4   04008DE5           STR      R0,[SP, #+4]
   \   000000D8   00708DE5           STR      R7,[SP, #+0]
   \   000000DC   0930A0E1           MOV      R3,R9
   \   000000E0   0500A0E1           MOV      R0,R5
   \   000000E4   ........           BL       _DrawBitLine1BPP
    346                pData += BytesPerLine;
   \   000000E8   40009DE5           LDR      R0,[SP, #+64]
   \   000000EC   014084E2           ADD      R4,R4,#+1
   \   000000F0   099080E0           ADD      R9,R0,R9
   \                     ??_DrawBitmap_C0_8:
   \   000000F4   AAA0B0E1           LSRS     R10,R10,#+1
   \   000000F8   0501000A           BEQ      ??_DrawBitmap_C0_1
   \                     ??_DrawBitmap_C0_9:
   \   000000FC   10009DE5           LDR      R0,[SP, #+16]
   \   00000100   08808DE5           STR      R8,[SP, #+8]
   \   00000104   04008DE5           STR      R0,[SP, #+4]
   \   00000108   00708DE5           STR      R7,[SP, #+0]
   \   0000010C   0930A0E1           MOV      R3,R9
   \   00000110   0420A0E1           MOV      R2,R4
   \   00000114   0610A0E1           MOV      R1,R6
   \   00000118   0500A0E1           MOV      R0,R5
   \   0000011C   ........           BL       _DrawBitLine1BPP
   \   00000120   40009DE5           LDR      R0,[SP, #+64]
   \   00000124   08808DE5           STR      R8,[SP, #+8]
   \   00000128   099080E0           ADD      R9,R0,R9
   \   0000012C   10009DE5           LDR      R0,[SP, #+16]
   \   00000130   00708DE5           STR      R7,[SP, #+0]
   \   00000134   04008DE5           STR      R0,[SP, #+4]
   \   00000138   0930A0E1           MOV      R3,R9
   \   0000013C   012084E2           ADD      R2,R4,#+1
   \   00000140   0610A0E1           MOV      R1,R6
   \   00000144   0500A0E1           MOV      R0,R5
   \   00000148   ........           BL       _DrawBitLine1BPP
   \   0000014C   40009DE5           LDR      R0,[SP, #+64]
    347              }
   \   00000150   01A04AE2           SUB      R10,R10,#+1
   \   00000154   099080E0           ADD      R9,R0,R9
   \   00000158   024084E2           ADD      R4,R4,#+2
   \   0000015C   00005AE3           CMP      R10,#+0
   \   00000160   E5FFFF1A           BNE      ??_DrawBitmap_C0_9
   \   00000164   EA0000EA           B        ??_DrawBitmap_C0_1
    348              break;
    349            case 2:
    350              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_C0_3:
   \   00000168   38009DE5           LDR      R0,[SP, #+56]
   \   0000016C   010050E3           CMP      R0,#+1
   \   00000170   E70000BA           BLT      ??_DrawBitmap_C0_1
   \   00000174   00A0A0E1           MOV      R10,R0
   \   00000178   01001AE3           TST      R10,#0x1
   \   0000017C   0900000A           BEQ      ??_DrawBitmap_C0_10
    351                _DrawBitLine2BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   00000180   10009DE5           LDR      R0,[SP, #+16]
   \   00000184   08808DE5           STR      R8,[SP, #+8]
   \   00000188   04008DE5           STR      R0,[SP, #+4]
   \   0000018C   00708DE5           STR      R7,[SP, #+0]
   \   00000190   0930A0E1           MOV      R3,R9
   \   00000194   0500A0E1           MOV      R0,R5
   \   00000198   ........           BL       _DrawBitLine2BPP
    352                pData += BytesPerLine;
   \   0000019C   40009DE5           LDR      R0,[SP, #+64]
   \   000001A0   014084E2           ADD      R4,R4,#+1
   \   000001A4   099080E0           ADD      R9,R0,R9
   \                     ??_DrawBitmap_C0_10:
   \   000001A8   AAA0B0E1           LSRS     R10,R10,#+1
   \   000001AC   D800000A           BEQ      ??_DrawBitmap_C0_1
   \                     ??_DrawBitmap_C0_11:
   \   000001B0   10009DE5           LDR      R0,[SP, #+16]
   \   000001B4   08808DE5           STR      R8,[SP, #+8]
   \   000001B8   04008DE5           STR      R0,[SP, #+4]
   \   000001BC   00708DE5           STR      R7,[SP, #+0]
   \   000001C0   0930A0E1           MOV      R3,R9
   \   000001C4   0420A0E1           MOV      R2,R4
   \   000001C8   0610A0E1           MOV      R1,R6
   \   000001CC   0500A0E1           MOV      R0,R5
   \   000001D0   ........           BL       _DrawBitLine2BPP
   \   000001D4   40009DE5           LDR      R0,[SP, #+64]
   \   000001D8   08808DE5           STR      R8,[SP, #+8]
   \   000001DC   099080E0           ADD      R9,R0,R9
   \   000001E0   10009DE5           LDR      R0,[SP, #+16]
   \   000001E4   00708DE5           STR      R7,[SP, #+0]
   \   000001E8   04008DE5           STR      R0,[SP, #+4]
   \   000001EC   0930A0E1           MOV      R3,R9
   \   000001F0   012084E2           ADD      R2,R4,#+1
   \   000001F4   0610A0E1           MOV      R1,R6
   \   000001F8   0500A0E1           MOV      R0,R5
   \   000001FC   ........           BL       _DrawBitLine2BPP
   \   00000200   40009DE5           LDR      R0,[SP, #+64]
    353              }
   \   00000204   01A04AE2           SUB      R10,R10,#+1
   \   00000208   099080E0           ADD      R9,R0,R9
   \   0000020C   024084E2           ADD      R4,R4,#+2
   \   00000210   00005AE3           CMP      R10,#+0
   \   00000214   E5FFFF1A           BNE      ??_DrawBitmap_C0_11
   \   00000218   BD0000EA           B        ??_DrawBitmap_C0_1
    354              break;
    355            case 4:
    356              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_C0_4:
   \   0000021C   38009DE5           LDR      R0,[SP, #+56]
   \   00000220   010050E3           CMP      R0,#+1
   \   00000224   BA0000BA           BLT      ??_DrawBitmap_C0_1
   \   00000228   00A0A0E1           MOV      R10,R0
   \   0000022C   01001AE3           TST      R10,#0x1
   \   00000230   0900000A           BEQ      ??_DrawBitmap_C0_12
    357                _DrawBitLine4BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   00000234   10009DE5           LDR      R0,[SP, #+16]
   \   00000238   08808DE5           STR      R8,[SP, #+8]
   \   0000023C   04008DE5           STR      R0,[SP, #+4]
   \   00000240   00708DE5           STR      R7,[SP, #+0]
   \   00000244   0930A0E1           MOV      R3,R9
   \   00000248   0500A0E1           MOV      R0,R5
   \   0000024C   ........           BL       _DrawBitLine4BPP
    358                pData += BytesPerLine;
   \   00000250   40009DE5           LDR      R0,[SP, #+64]
   \   00000254   014084E2           ADD      R4,R4,#+1
   \   00000258   099080E0           ADD      R9,R0,R9
   \                     ??_DrawBitmap_C0_12:
   \   0000025C   AAA0B0E1           LSRS     R10,R10,#+1
   \   00000260   AB00000A           BEQ      ??_DrawBitmap_C0_1
   \                     ??_DrawBitmap_C0_13:
   \   00000264   10009DE5           LDR      R0,[SP, #+16]
   \   00000268   08808DE5           STR      R8,[SP, #+8]
   \   0000026C   04008DE5           STR      R0,[SP, #+4]
   \   00000270   00708DE5           STR      R7,[SP, #+0]
   \   00000274   0930A0E1           MOV      R3,R9
   \   00000278   0420A0E1           MOV      R2,R4
   \   0000027C   0610A0E1           MOV      R1,R6
   \   00000280   0500A0E1           MOV      R0,R5
   \   00000284   ........           BL       _DrawBitLine4BPP
   \   00000288   40009DE5           LDR      R0,[SP, #+64]
   \   0000028C   08808DE5           STR      R8,[SP, #+8]
   \   00000290   099080E0           ADD      R9,R0,R9
   \   00000294   10009DE5           LDR      R0,[SP, #+16]
   \   00000298   00708DE5           STR      R7,[SP, #+0]
   \   0000029C   04008DE5           STR      R0,[SP, #+4]
   \   000002A0   0930A0E1           MOV      R3,R9
   \   000002A4   012084E2           ADD      R2,R4,#+1
   \   000002A8   0610A0E1           MOV      R1,R6
   \   000002AC   0500A0E1           MOV      R0,R5
   \   000002B0   ........           BL       _DrawBitLine4BPP
   \   000002B4   40009DE5           LDR      R0,[SP, #+64]
    359              }
   \   000002B8   01A04AE2           SUB      R10,R10,#+1
   \   000002BC   099080E0           ADD      R9,R0,R9
   \   000002C0   024084E2           ADD      R4,R4,#+2
   \   000002C4   00005AE3           CMP      R10,#+0
   \   000002C8   E5FFFF1A           BNE      ??_DrawBitmap_C0_13
   \   000002CC   900000EA           B        ??_DrawBitmap_C0_1
    360              break;
    361            case 8:
    362              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_C0_5:
   \   000002D0   38009DE5           LDR      R0,[SP, #+56]
   \   000002D4   010050E3           CMP      R0,#+1
   \   000002D8   8D0000BA           BLT      ??_DrawBitmap_C0_1
   \   000002DC   0070A0E1           MOV      R7,R0
   \   000002E0   010017E3           TST      R7,#0x1
   \   000002E4   0800000A           BEQ      ??_DrawBitmap_C0_14
    363                _DrawBitLine8BPP(pDevice, x0, i + y0, pData, xSize, pTrans);
   \   000002E8   10009DE5           LDR      R0,[SP, #+16]
   \   000002EC   04808DE5           STR      R8,[SP, #+4]
   \   000002F0   00008DE5           STR      R0,[SP, #+0]
   \   000002F4   0930A0E1           MOV      R3,R9
   \   000002F8   0500A0E1           MOV      R0,R5
   \   000002FC   ........           BL       _DrawBitLine8BPP
    364                pData += BytesPerLine;
   \   00000300   40009DE5           LDR      R0,[SP, #+64]
   \   00000304   014084E2           ADD      R4,R4,#+1
   \   00000308   099080E0           ADD      R9,R0,R9
   \                     ??_DrawBitmap_C0_14:
   \   0000030C   A770B0E1           LSRS     R7,R7,#+1
   \   00000310   7F00000A           BEQ      ??_DrawBitmap_C0_1
   \                     ??_DrawBitmap_C0_15:
   \   00000314   10009DE5           LDR      R0,[SP, #+16]
   \   00000318   04808DE5           STR      R8,[SP, #+4]
   \   0000031C   00008DE5           STR      R0,[SP, #+0]
   \   00000320   0930A0E1           MOV      R3,R9
   \   00000324   0420A0E1           MOV      R2,R4
   \   00000328   0610A0E1           MOV      R1,R6
   \   0000032C   0500A0E1           MOV      R0,R5
   \   00000330   ........           BL       _DrawBitLine8BPP
   \   00000334   40009DE5           LDR      R0,[SP, #+64]
   \   00000338   04808DE5           STR      R8,[SP, #+4]
   \   0000033C   099080E0           ADD      R9,R0,R9
   \   00000340   10009DE5           LDR      R0,[SP, #+16]
   \   00000344   0930A0E1           MOV      R3,R9
   \   00000348   00008DE5           STR      R0,[SP, #+0]
   \   0000034C   012084E2           ADD      R2,R4,#+1
   \   00000350   0610A0E1           MOV      R1,R6
   \   00000354   0500A0E1           MOV      R0,R5
   \   00000358   ........           BL       _DrawBitLine8BPP
   \   0000035C   40009DE5           LDR      R0,[SP, #+64]
    365              }
   \   00000360   017047E2           SUB      R7,R7,#+1
   \   00000364   099080E0           ADD      R9,R0,R9
   \   00000368   024084E2           ADD      R4,R4,#+2
   \   0000036C   000057E3           CMP      R7,#+0
   \   00000370   E7FFFF1A           BNE      ??_DrawBitmap_C0_15
   \   00000374   660000EA           B        ??_DrawBitmap_C0_1
    366              break;
    367            case 16:
    368              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_C0_6:
   \   00000378   38009DE5           LDR      R0,[SP, #+56]
   \   0000037C   0010A0E3           MOV      R1,#+0
   \   00000380   00108DE5           STR      R1,[SP, #+0]
   \   00000384   010050E3           CMP      R0,#+1
   \   00000388   610000BA           BLT      ??_DrawBitmap_C0_1
   \   0000038C   04408DE5           STR      R4,[SP, #+4]
    369                _DrawBitLine16BPP(pDevice, x0, i + y0, (U16 *)pData, xSize);
   \                     ??_DrawBitmap_C0_16:
   \   00000390   0C0095E5           LDR      R0,[R5, #+12]
   \   00000394   0940A0E1           MOV      R4,R9
   \   00000398   18A090E5           LDR      R10,[R0, #+24]
   \   0000039C   10009DE5           LDR      R0,[SP, #+16]
   \   000003A0   04709DE5           LDR      R7,[SP, #+4]
   \   000003A4   0680A0E1           MOV      R8,R6
   \   000003A8   010050E3           CMP      R0,#+1
   \   000003AC   180000BA           BLT      ??_DrawBitmap_C0_17
   \   000003B0   00B0A0E1           MOV      R11,R0
   \   000003B4   01001BE3           TST      R11,#0x1
   \   000003B8   0500000A           BEQ      ??_DrawBitmap_C0_18
   \   000003BC   B230D4E0           LDRH     R3,[R4], #+2
   \   000003C0   0720A0E1           MOV      R2,R7
   \   000003C4   0810A0E1           MOV      R1,R8
   \   000003C8   0500A0E1           MOV      R0,R5
   \   000003CC   3AFF2FE1           BLX      R10
   \   000003D0   018088E2           ADD      R8,R8,#+1
   \                     ??_DrawBitmap_C0_18:
   \   000003D4   ABB0B0E1           LSRS     R11,R11,#+1
   \   000003D8   0D00000A           BEQ      ??_DrawBitmap_C0_17
   \                     ??_DrawBitmap_C0_19:
   \   000003DC   B230D4E0           LDRH     R3,[R4], #+2
   \   000003E0   0720A0E1           MOV      R2,R7
   \   000003E4   0810A0E1           MOV      R1,R8
   \   000003E8   0500A0E1           MOV      R0,R5
   \   000003EC   3AFF2FE1           BLX      R10
   \   000003F0   018088E2           ADD      R8,R8,#+1
   \   000003F4   B230D4E0           LDRH     R3,[R4], #+2
   \   000003F8   0720A0E1           MOV      R2,R7
   \   000003FC   0810A0E1           MOV      R1,R8
   \   00000400   0500A0E1           MOV      R0,R5
   \   00000404   3AFF2FE1           BLX      R10
   \   00000408   018088E2           ADD      R8,R8,#+1
   \   0000040C   01B05BE2           SUBS     R11,R11,#+1
   \   00000410   F1FFFF1A           BNE      ??_DrawBitmap_C0_19
    370                pData += BytesPerLine;
    371              }
   \                     ??_DrawBitmap_C0_17:
   \   00000414   00109DE5           LDR      R1,[SP, #+0]
   \   00000418   40009DE5           LDR      R0,[SP, #+64]
   \   0000041C   011081E2           ADD      R1,R1,#+1
   \   00000420   00108DE5           STR      R1,[SP, #+0]
   \   00000424   04109DE5           LDR      R1,[SP, #+4]
   \   00000428   099080E0           ADD      R9,R0,R9
   \   0000042C   011081E2           ADD      R1,R1,#+1
   \   00000430   04108DE5           STR      R1,[SP, #+4]
   \   00000434   00009DE5           LDR      R0,[SP, #+0]
   \   00000438   38109DE5           LDR      R1,[SP, #+56]
   \   0000043C   010050E1           CMP      R0,R1
   \   00000440   330000AA           BGE      ??_DrawBitmap_C0_1
   \   00000444   D1FFFFEA           B        ??_DrawBitmap_C0_16
    372              break;
    373            case 32:
    374              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_C0_7:
   \   00000448   38009DE5           LDR      R0,[SP, #+56]
   \   0000044C   0010A0E3           MOV      R1,#+0
   \   00000450   00108DE5           STR      R1,[SP, #+0]
   \   00000454   010050E3           CMP      R0,#+1
   \   00000458   2D0000BA           BLT      ??_DrawBitmap_C0_1
   \   0000045C   04408DE5           STR      R4,[SP, #+4]
    375                _DrawBitLine32BPP(pDevice, x0, i + y0, (U32 *)pData, xSize);
   \                     ??_DrawBitmap_C0_20:
   \   00000460   0C0095E5           LDR      R0,[R5, #+12]
   \   00000464   0940A0E1           MOV      R4,R9
   \   00000468   18A090E5           LDR      R10,[R0, #+24]
   \   0000046C   10009DE5           LDR      R0,[SP, #+16]
   \   00000470   04709DE5           LDR      R7,[SP, #+4]
   \   00000474   0680A0E1           MOV      R8,R6
   \   00000478   010050E3           CMP      R0,#+1
   \   0000047C   180000BA           BLT      ??_DrawBitmap_C0_21
   \   00000480   00B0A0E1           MOV      R11,R0
   \   00000484   01001BE3           TST      R11,#0x1
   \   00000488   0500000A           BEQ      ??_DrawBitmap_C0_22
   \   0000048C   043094E4           LDR      R3,[R4], #+4
   \   00000490   0720A0E1           MOV      R2,R7
   \   00000494   0810A0E1           MOV      R1,R8
   \   00000498   0500A0E1           MOV      R0,R5
   \   0000049C   3AFF2FE1           BLX      R10
   \   000004A0   018088E2           ADD      R8,R8,#+1
   \                     ??_DrawBitmap_C0_22:
   \   000004A4   ABB0B0E1           LSRS     R11,R11,#+1
   \   000004A8   0D00000A           BEQ      ??_DrawBitmap_C0_21
   \                     ??_DrawBitmap_C0_23:
   \   000004AC   043094E4           LDR      R3,[R4], #+4
   \   000004B0   0720A0E1           MOV      R2,R7
   \   000004B4   0810A0E1           MOV      R1,R8
   \   000004B8   0500A0E1           MOV      R0,R5
   \   000004BC   3AFF2FE1           BLX      R10
   \   000004C0   018088E2           ADD      R8,R8,#+1
   \   000004C4   043094E4           LDR      R3,[R4], #+4
   \   000004C8   0720A0E1           MOV      R2,R7
   \   000004CC   0810A0E1           MOV      R1,R8
   \   000004D0   0500A0E1           MOV      R0,R5
   \   000004D4   3AFF2FE1           BLX      R10
   \   000004D8   018088E2           ADD      R8,R8,#+1
   \   000004DC   01B05BE2           SUBS     R11,R11,#+1
   \   000004E0   F1FFFF1A           BNE      ??_DrawBitmap_C0_23
    376                pData += BytesPerLine;
    377              }
   \                     ??_DrawBitmap_C0_21:
   \   000004E4   00109DE5           LDR      R1,[SP, #+0]
   \   000004E8   40009DE5           LDR      R0,[SP, #+64]
   \   000004EC   011081E2           ADD      R1,R1,#+1
   \   000004F0   00108DE5           STR      R1,[SP, #+0]
   \   000004F4   04109DE5           LDR      R1,[SP, #+4]
   \   000004F8   099080E0           ADD      R9,R0,R9
   \   000004FC   011081E2           ADD      R1,R1,#+1
   \   00000500   04108DE5           STR      R1,[SP, #+4]
   \   00000504   00009DE5           LDR      R0,[SP, #+0]
   \   00000508   38109DE5           LDR      R1,[SP, #+56]
   \   0000050C   010050E1           CMP      R0,R1
   \   00000510   D2FFFFBA           BLT      ??_DrawBitmap_C0_20
    378              break;
    379            }
    380          }
   \                     ??_DrawBitmap_C0_1:
   \   00000514   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000518   F08FBDE8           POP      {R4-R11,PC}      ;; return
    381          
    382          /*********************************************************************
    383          *
    384          *       _GetPixelIndex_C0
    385          */

   \                                 In section .text, align 4, keep-with-next
    386          static unsigned int _GetPixelIndex_C0(GUI_DEVICE * pDevice, int x, int y) {
   \                     _GetPixelIndex_C0:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0040A0E1           MOV      R4,R0
    387            int x_phys, y_phys;
    388            unsigned int PixelIndex;
    389            DRIVER_CONTEXT * pContext;
    390          
    391            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   0000000C   080094E5           LDR      R0,[R4, #+8]
    392            pContext->pfLog2Phys(pContext, x, y, &x_phys, &y_phys);
   \   00000010   04308DE2           ADD      R3,SP,#+4
   \   00000014   00308DE5           STR      R3,[SP, #+0]
   \   00000018   08308DE2           ADD      R3,SP,#+8
   \   0000001C   24C090E5           LDR      R12,[R0, #+36]
   \   00000020   3CFF2FE1           BLX      R12
    393            pDevice = pDevice->pNext;
   \   00000024   000094E5           LDR      R0,[R4, #+0]
    394            PixelIndex = pDevice->pDeviceAPI->pfGetPixelIndex(pDevice, x_phys, y_phys);
    395            return PixelIndex;
   \   00000028   04209DE5           LDR      R2,[SP, #+4]
   \   0000002C   0C3090E5           LDR      R3,[R0, #+12]
   \   00000030   08109DE5           LDR      R1,[SP, #+8]
   \   00000034   143093E5           LDR      R3,[R3, #+20]
   \   00000038   33FF2FE1           BLX      R3
   \   0000003C   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   00000040   1080BDE8           POP      {R4,PC}          ;; return
    396          }
    397          
    398          /*********************************************************************
    399          *
    400          *       _SetPixelIndex
    401          */

   \                                 In section .text, align 4, keep-with-next
    402          static void _SetPixelIndex_C0(GUI_DEVICE * pDevice, int x, int y, int PixelIndex) {
   \                     _SetPixelIndex_C0:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0350A0E1           MOV      R5,R3
    403            int x_phys, y_phys;
    404            DRIVER_CONTEXT * pContext;
    405          
    406            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000010   080094E5           LDR      R0,[R4, #+8]
    407            pContext->pfLog2Phys(pContext, x, y, &x_phys, &y_phys);
   \   00000014   04308DE2           ADD      R3,SP,#+4
   \   00000018   00308DE5           STR      R3,[SP, #+0]
   \   0000001C   08308DE2           ADD      R3,SP,#+8
   \   00000020   24C090E5           LDR      R12,[R0, #+36]
   \   00000024   3CFF2FE1           BLX      R12
    408            pDevice = pDevice->pNext;
   \   00000028   000094E5           LDR      R0,[R4, #+0]
    409            pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x_phys, y_phys, PixelIndex);
   \   0000002C   0530A0E1           MOV      R3,R5
   \   00000030   0CC090E5           LDR      R12,[R0, #+12]
   \   00000034   04209DE5           LDR      R2,[SP, #+4]
   \   00000038   08109DE5           LDR      R1,[SP, #+8]
   \   0000003C   18C09CE5           LDR      R12,[R12, #+24]
   \   00000040   3CFF2FE1           BLX      R12
    410          }
   \   00000044   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000048   3080BDE8           POP      {R4,R5,PC}       ;; return
    411          
    412          /*********************************************************************
    413          *
    414          *       _XorPixel_C0
    415          */

   \                                 In section .text, align 4, keep-with-next
    416          static void _XorPixel_C0(GUI_DEVICE * pDevice, int x, int y) {
   \                     _XorPixel_C0:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0040A0E1           MOV      R4,R0
    417            int x_phys, y_phys;
    418            DRIVER_CONTEXT * pContext;
    419          
    420            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   0000000C   080094E5           LDR      R0,[R4, #+8]
    421            pContext->pfLog2Phys(pContext, x, y, &x_phys, &y_phys);
   \   00000010   04308DE2           ADD      R3,SP,#+4
   \   00000014   00308DE5           STR      R3,[SP, #+0]
   \   00000018   08308DE2           ADD      R3,SP,#+8
   \   0000001C   24C090E5           LDR      R12,[R0, #+36]
   \   00000020   3CFF2FE1           BLX      R12
    422            pDevice = pDevice->pNext;
   \   00000024   000094E5           LDR      R0,[R4, #+0]
    423            pDevice->pDeviceAPI->pfXorPixel(pDevice, x_phys, y_phys);
   \   00000028   04209DE5           LDR      R2,[SP, #+4]
   \   0000002C   0C3090E5           LDR      R3,[R0, #+12]
   \   00000030   08109DE5           LDR      R1,[SP, #+8]
   \   00000034   1C3093E5           LDR      R3,[R3, #+28]
   \   00000038   33FF2FE1           BLX      R3
    424          }
   \   0000003C   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   00000040   1080BDE8           POP      {R4,PC}          ;; return
    425          
    426          /*********************************************************************
    427          *
    428          *       _DrawHLine_C0
    429          */

   \                                 In section .text, align 4, keep-with-next
    430          static void _DrawHLine_C0(GUI_DEVICE * pDevice, int x0, int y, int x1) {
   \                     _DrawHLine_C0:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0050A0E1           MOV      R5,R0
    431            int x0_phys, y0_phys, x1_phys, y1_phys;
    432            DRIVER_CONTEXT * pContext;
    433          
    434            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   0000000C   084095E5           LDR      R4,[R5, #+8]
    435            pContext->pfLog2Phys(pContext, x0, y, &x0_phys, &y0_phys);
   \   00000010   04008DE2           ADD      R0,SP,#+4
   \   00000014   0370A0E1           MOV      R7,R3
   \   00000018   00008DE5           STR      R0,[SP, #+0]
   \   0000001C   0260A0E1           MOV      R6,R2
   \   00000020   08308DE2           ADD      R3,SP,#+8
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   24C094E5           LDR      R12,[R4, #+36]
   \   0000002C   3CFF2FE1           BLX      R12
    436            pContext->pfLog2Phys(pContext, x1, y, &x1_phys, &y1_phys);
   \   00000030   0C008DE2           ADD      R0,SP,#+12
   \   00000034   00008DE5           STR      R0,[SP, #+0]
   \   00000038   10308DE2           ADD      R3,SP,#+16
   \   0000003C   0620A0E1           MOV      R2,R6
   \   00000040   0710A0E1           MOV      R1,R7
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   24C094E5           LDR      R12,[R4, #+36]
   \   0000004C   3CFF2FE1           BLX      R12
    437            _Sort(&x0_phys, &x1_phys);
   \   00000050   10009DE5           LDR      R0,[SP, #+16]
   \   00000054   08109DE5           LDR      R1,[SP, #+8]
   \   00000058   010050E1           CMP      R0,R1
   \   0000005C   10209DB5           LDRLT    R2,[SP, #+16]
   \   00000060   10108DB5           STRLT    R1,[SP, #+16]
    438            _Sort(&y0_phys, &y1_phys);
   \   00000064   0C009DE5           LDR      R0,[SP, #+12]
   \   00000068   04109DE5           LDR      R1,[SP, #+4]
   \   0000006C   08208DB5           STRLT    R2,[SP, #+8]
   \   00000070   010050E1           CMP      R0,R1
   \   00000074   0C209DB5           LDRLT    R2,[SP, #+12]
   \   00000078   0C108DB5           STRLT    R1,[SP, #+12]
   \   0000007C   04208DB5           STRLT    R2,[SP, #+4]
    439            pDevice = pDevice->pNext;
    440            if (pContext->Orientation & GUI_SWAP_XY) {
   \   00000080   0C10D4E5           LDRB     R1,[R4, #+12]
   \   00000084   000095E5           LDR      R0,[R5, #+0]
   \   00000088   0CC090E5           LDR      R12,[R0, #+12]
   \   0000008C   040011E3           TST      R1,#0x4
   \   00000090   0500000A           BEQ      ??_DrawHLine_C0_0
    441              pDevice->pDeviceAPI->pfDrawVLine(pDevice, x0_phys, y0_phys, y1_phys);
   \   00000094   0C309DE5           LDR      R3,[SP, #+12]
   \   00000098   04209DE5           LDR      R2,[SP, #+4]
   \   0000009C   08109DE5           LDR      R1,[SP, #+8]
   \   000000A0   0CC09CE5           LDR      R12,[R12, #+12]
   \   000000A4   3CFF2FE1           BLX      R12
   \   000000A8   040000EA           B        ??_DrawHLine_C0_1
    442            } else {
    443              pDevice->pDeviceAPI->pfDrawHLine(pDevice, x0_phys, y0_phys, x1_phys);
   \                     ??_DrawHLine_C0_0:
   \   000000AC   10309DE5           LDR      R3,[SP, #+16]
   \   000000B0   04209DE5           LDR      R2,[SP, #+4]
   \   000000B4   08109DE5           LDR      R1,[SP, #+8]
   \   000000B8   08C09CE5           LDR      R12,[R12, #+8]
   \   000000BC   3CFF2FE1           BLX      R12
    444            }
    445          }
   \                     ??_DrawHLine_C0_1:
   \   000000C0   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000000C4   F080BDE8           POP      {R4-R7,PC}       ;; return
    446          
    447          /*********************************************************************
    448          *
    449          *       _DrawVLine_C0
    450          */

   \                                 In section .text, align 4, keep-with-next
    451          static void _DrawVLine_C0(GUI_DEVICE * pDevice, int x, int y0, int y1) {
   \                     _DrawVLine_C0:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0050A0E1           MOV      R5,R0
    452            int x0_phys, y0_phys, x1_phys, y1_phys;
    453            DRIVER_CONTEXT * pContext;
    454          
    455            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   0000000C   084095E5           LDR      R4,[R5, #+8]
    456            pContext->pfLog2Phys(pContext, x, y0, &x0_phys, &y0_phys);
   \   00000010   04008DE2           ADD      R0,SP,#+4
   \   00000014   0370A0E1           MOV      R7,R3
   \   00000018   00008DE5           STR      R0,[SP, #+0]
   \   0000001C   0160A0E1           MOV      R6,R1
   \   00000020   08308DE2           ADD      R3,SP,#+8
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   24C094E5           LDR      R12,[R4, #+36]
   \   0000002C   3CFF2FE1           BLX      R12
    457            pContext->pfLog2Phys(pContext, x, y1, &x1_phys, &y1_phys);
   \   00000030   0C008DE2           ADD      R0,SP,#+12
   \   00000034   00008DE5           STR      R0,[SP, #+0]
   \   00000038   10308DE2           ADD      R3,SP,#+16
   \   0000003C   0720A0E1           MOV      R2,R7
   \   00000040   0610A0E1           MOV      R1,R6
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   24C094E5           LDR      R12,[R4, #+36]
   \   0000004C   3CFF2FE1           BLX      R12
    458            _Sort(&x0_phys, &x1_phys);
   \   00000050   10009DE5           LDR      R0,[SP, #+16]
   \   00000054   08109DE5           LDR      R1,[SP, #+8]
   \   00000058   010050E1           CMP      R0,R1
   \   0000005C   10209DB5           LDRLT    R2,[SP, #+16]
   \   00000060   10108DB5           STRLT    R1,[SP, #+16]
    459            _Sort(&y0_phys, &y1_phys);
   \   00000064   0C009DE5           LDR      R0,[SP, #+12]
   \   00000068   04109DE5           LDR      R1,[SP, #+4]
   \   0000006C   08208DB5           STRLT    R2,[SP, #+8]
   \   00000070   010050E1           CMP      R0,R1
   \   00000074   0C209DB5           LDRLT    R2,[SP, #+12]
   \   00000078   0C108DB5           STRLT    R1,[SP, #+12]
   \   0000007C   04208DB5           STRLT    R2,[SP, #+4]
    460            pDevice = pDevice->pNext;
    461            if (pContext->Orientation & GUI_SWAP_XY) {
   \   00000080   0C10D4E5           LDRB     R1,[R4, #+12]
   \   00000084   000095E5           LDR      R0,[R5, #+0]
   \   00000088   0CC090E5           LDR      R12,[R0, #+12]
   \   0000008C   040011E3           TST      R1,#0x4
   \   00000090   0500000A           BEQ      ??_DrawVLine_C0_0
    462              pDevice->pDeviceAPI->pfDrawHLine(pDevice, x0_phys, y0_phys, x1_phys);
   \   00000094   10309DE5           LDR      R3,[SP, #+16]
   \   00000098   04209DE5           LDR      R2,[SP, #+4]
   \   0000009C   08109DE5           LDR      R1,[SP, #+8]
   \   000000A0   08C09CE5           LDR      R12,[R12, #+8]
   \   000000A4   3CFF2FE1           BLX      R12
   \   000000A8   040000EA           B        ??_DrawVLine_C0_1
    463            } else {
    464              pDevice->pDeviceAPI->pfDrawVLine(pDevice, x0_phys, y0_phys, y1_phys);
   \                     ??_DrawVLine_C0_0:
   \   000000AC   0C309DE5           LDR      R3,[SP, #+12]
   \   000000B0   04209DE5           LDR      R2,[SP, #+4]
   \   000000B4   08109DE5           LDR      R1,[SP, #+8]
   \   000000B8   0CC09CE5           LDR      R12,[R12, #+12]
   \   000000BC   3CFF2FE1           BLX      R12
    465            }
    466          }
   \                     ??_DrawVLine_C0_1:
   \   000000C0   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000000C4   F080BDE8           POP      {R4-R7,PC}       ;; return
    467          
    468          /*********************************************************************
    469          *
    470          *       _FillRect_C0
    471          */

   \                                 In section .text, align 4, keep-with-next
    472          static void _FillRect_C0(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect_C0:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0040A0E1           MOV      R4,R0
    473            int x0_phys, y0_phys, x1_phys, y1_phys;
    474            int temp;
    475            DRIVER_CONTEXT * pContext;
    476          
    477            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   0000000C   087094E5           LDR      R7,[R4, #+8]
    478            pContext->pfLog2Phys(pContext, x0, y0, &x0_phys, &y0_phys);
   \   00000010   0C008DE2           ADD      R0,SP,#+12
   \   00000014   0350A0E1           MOV      R5,R3
   \   00000018   00008DE5           STR      R0,[SP, #+0]
   \   0000001C   28609DE5           LDR      R6,[SP, #+40]
   \   00000020   10308DE2           ADD      R3,SP,#+16
   \   00000024   0700A0E1           MOV      R0,R7
   \   00000028   24C097E5           LDR      R12,[R7, #+36]
   \   0000002C   3CFF2FE1           BLX      R12
    479            pContext->pfLog2Phys(pContext, x1, y1, &x1_phys, &y1_phys);
   \   00000030   04008DE2           ADD      R0,SP,#+4
   \   00000034   00008DE5           STR      R0,[SP, #+0]
   \   00000038   08308DE2           ADD      R3,SP,#+8
   \   0000003C   0620A0E1           MOV      R2,R6
   \   00000040   0510A0E1           MOV      R1,R5
   \   00000044   0700A0E1           MOV      R0,R7
   \   00000048   24C097E5           LDR      R12,[R7, #+36]
   \   0000004C   3CFF2FE1           BLX      R12
    480            if (x0_phys > x1_phys) {
   \   00000050   08009DE5           LDR      R0,[SP, #+8]
   \   00000054   10109DE5           LDR      R1,[SP, #+16]
   \   00000058   010050E1           CMP      R0,R1
    481              temp = x0_phys;
    482              x0_phys = x1_phys;
   \   0000005C   08209DB5           LDRLT    R2,[SP, #+8]
    483              x1_phys = temp;
   \   00000060   08108DB5           STRLT    R1,[SP, #+8]
    484            }
    485            if (y0_phys > y1_phys) {
   \   00000064   04009DE5           LDR      R0,[SP, #+4]
   \   00000068   0C109DE5           LDR      R1,[SP, #+12]
   \   0000006C   10208DB5           STRLT    R2,[SP, #+16]
   \   00000070   010050E1           CMP      R0,R1
    486              temp = y0_phys;
    487              y0_phys = y1_phys;
   \   00000074   04209DB5           LDRLT    R2,[SP, #+4]
    488              y1_phys = temp;
   \   00000078   04108DB5           STRLT    R1,[SP, #+4]
   \   0000007C   0C208DB5           STRLT    R2,[SP, #+12]
    489            }
    490            pDevice = pDevice->pNext;
    491            pDevice->pDeviceAPI->pfFillRect(pDevice, x0_phys, y0_phys, x1_phys, y1_phys);
   \   00000080   04109DE5           LDR      R1,[SP, #+4]
   \   00000084   000094E5           LDR      R0,[R4, #+0]
   \   00000088   00108DE5           STR      R1,[SP, #+0]
   \   0000008C   0CC090E5           LDR      R12,[R0, #+12]
   \   00000090   08309DE5           LDR      R3,[SP, #+8]
   \   00000094   0C209DE5           LDR      R2,[SP, #+12]
   \   00000098   10109DE5           LDR      R1,[SP, #+16]
   \   0000009C   10C09CE5           LDR      R12,[R12, #+16]
   \   000000A0   3CFF2FE1           BLX      R12
    492          }
   \   000000A4   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000000A8   F080BDE8           POP      {R4-R7,PC}       ;; return
    493          
    494          /*********************************************************************
    495          *
    496          *       Static data: Drawing API(s)
    497          *
    498          **********************************************************************
    499          */
    500          /*********************************************************************
    501          *
    502          *       GUI_OrientationAPI_C0
    503          */

   \                                 In section .rodata, align 4, keep-with-next
    504          const GUI_ORIENTATION_API GUI_OrientationAPI_C0 = {
   \                     GUI_OrientationAPI_C0:
   \   00000000                      ; Initializer data, 32 bytes
   \   00000000   ............       DC32 _DrawBitmap_C0, _DrawHLine_C0, _DrawVLine_C0, _FillRect_C0, _GetPixelIndex_C0, _SetPixelIndex_C0, _XorPixel_C0, 0
   \              ............
   \              ............
   \              ............
   \              ........0000
   \              0000        

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     GUI_Context
    505            _DrawBitmap_C0,
    506            _DrawHLine_C0,
    507            _DrawVLine_C0,
    508            _FillRect_C0,
    509            _GetPixelIndex_C0,
    510            _SetPixelIndex_C0,
    511            _XorPixel_C0,
    512            0
    513          };
    514          
    515          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function          .cstack
     --------          -------
     _DrawBitLine1BPP      40
     _DrawBitLine2BPP      40
     _DrawBitLine4BPP      40
     _DrawBitLine8BPP      32
     _DrawBitmap_C0        56
     _DrawHLine_C0         40
     _DrawVLine_C0         40
     _FillRect_C0          40
     _GetPixelIndex_C0     24
     _SetPixelIndex_C0     24
     _XorPixel_C0          24


   Section sizes:

     Function/Label        Bytes
     --------------        -----
     _DrawBitLine1BPP       344
     _DrawBitLine2BPP       428
     _DrawBitLine4BPP       428
     _DrawBitLine8BPP       604
     _DrawBitmap_C0        1308
     _GetPixelIndex_C0       68
     _SetPixelIndex_C0       76
     _XorPixel_C0            68
     _DrawHLine_C0          200
     _DrawVLine_C0          200
     _FillRect_C0           172
     GUI_OrientationAPI_C0   32
     ??DataTable4             4

 
    32 bytes in section .rodata
 3 900 bytes in section .text
 
 3 900 bytes of CODE  memory
    32 bytes of CONST memory

Errors: none
Warnings: none
