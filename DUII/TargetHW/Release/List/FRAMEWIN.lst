###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:11:44 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\FRAMEWIN.c                          #
#    Command line =  C:\DUII\TargetHW\GUI\FRAMEWIN.c -D DEBUG=1 -D            #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\FRAMEWIN.lst               #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\FRAMEWIN.o                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\FRAMEWIN.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : FRAMEWIN.c
     19          Purpose     : Implementation of framewindow widget
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stdlib.h>
     24          #include <string.h>
     25          #include "FRAMEWIN_Private.h"
     26          #include "GUI_Private.h"
     27          #include "WM_Intern.h"
     28          
     29          #if GUI_WINSUPPORT
     30          
     31          #ifndef   FRAMEWIN_DRAW_SKIN_DEFAULT
     32            #define FRAMEWIN_DRAW_SKIN_DEFAULT NULL
     33          #endif
     34          
     35          /*********************************************************************
     36          *
     37          *       Private data
     38          *
     39          **********************************************************************
     40          */

   \                                 In section .data, align 4
     41          FRAMEWIN_PROPS FRAMEWIN__DefaultProps = {
   \                     FRAMEWIN__DefaultProps:
   \   00000000   ........4040       DC32 GUI_Font8_1, 4210752, 16711680, 16777215, 16777215, 12632256
   \              40000000FF00
   \              FFFFFF00FFFF
   \              FF00C0C0C000
   \   00000018   ........0000       DC32 FRAMEWIN__GetBorderSize, 0H
   \              0000        
   \   00000020   000003000100       DC16 0, 3, 1, 0
   \              0000        
     42            FRAMEWIN_DEFAULT_FONT,
     43            { FRAMEWIN_BARCOLOR_INACTIVE_DEFAULT,
     44              FRAMEWIN_BARCOLOR_ACTIVE_DEFAULT,
     45            },
     46            { FRAMEWIN_TEXTCOLOR0_DEFAULT,
     47              FRAMEWIN_TEXTCOLOR1_DEFAULT,
     48            },
     49            FRAMEWIN_CLIENTCOLOR_DEFAULT,
     50            {
     51              FRAMEWIN__GetBorderSize,
     52              FRAMEWIN_DRAW_SKIN_DEFAULT
     53            },
     54            FRAMEWIN_TITLEHEIGHT_DEFAULT,
     55            FRAMEWIN_BORDER_DEFAULT,
     56            FRAMEWIN_IBORDER_DEFAULT,
     57            FRAMEWIN_TEXTALIGN_DEFAULT,
     58          };
     59          
     60          WIDGET_SKIN const * FRAMEWIN__pSkinDefault = &FRAMEWIN__SkinClassic;
   \                     FRAMEWIN__pSkinDefault:
   \   00000028   ........           DC32 FRAMEWIN__SkinClassic
     61          
     62          /*********************************************************************
     63          *
     64          *       Static data
     65          *
     66          **********************************************************************
     67          */

   \                                 In section .data, align 2
   \   00000000   0500               DC16 5
     68          static I16 FRAMEWIN__MinVisibility = 5;
     69          
     70          /*********************************************************************
     71          *
     72          *       Static routines
     73          *
     74          **********************************************************************
     75          */
     76          /*********************************************************************
     77          *
     78          *       _SetActive
     79          */
     80          static void _SetActive(FRAMEWIN_Handle hObj, int State) {
     81            FRAMEWIN_Obj * pObj;
     82            pObj = FRAMEWIN_LOCK_H(hObj);
     83            if        (State && !(pObj->Flags & FRAMEWIN_SF_ACTIVE)) {
     84              pObj->Flags |= FRAMEWIN_CF_ACTIVE;
     85              FRAMEWIN_Invalidate(hObj);
     86            } else if (!State && (pObj->Flags & FRAMEWIN_SF_ACTIVE)) {
     87              pObj->Flags &= ~FRAMEWIN_CF_ACTIVE;
     88              FRAMEWIN_Invalidate(hObj);
     89            }
     90            GUI_UNLOCK_H(pObj);
     91          }
     92          
     93          /*********************************************************************
     94          *
     95          *       _OnTouch
     96          */
     97          static void _OnTouch(FRAMEWIN_Handle hObj, WM_MESSAGE * pMsg) {
     98            FRAMEWIN_Obj * pObj;
     99            const GUI_PID_STATE * pState;
    100            U16 Flags;
    101            #if (FRAMEWIN_ALLOW_DRAG_ON_FRAME == 0)
    102            I16 BorderSize;
    103            I16 IBorderSize;
    104            #endif
    105          
    106            pState = (const GUI_PID_STATE *)pMsg->Data.p;
    107            pObj = FRAMEWIN_LOCK_H(hObj);
    108            Flags = pObj->Flags;
    109            #if (FRAMEWIN_ALLOW_DRAG_ON_FRAME == 0)
    110            BorderSize = pObj->Props.BorderSize;
    111            IBorderSize = pObj->Props.IBorderSize;
    112            #endif
    113            GUI_UNLOCK_H(pObj);
    114            if (pMsg->Data.p) {  // Something happened in our area (pressed or released)
    115              if (pState->Pressed) {
    116                if (!(Flags & FRAMEWIN_SF_ACTIVE)) {
    117                  WM_SetFocus(hObj);
    118                }
    119                WM_BringToTop(hObj);
    120                if ((Flags & FRAMEWIN_SF_MOVEABLE) && (Flags & FRAMEWIN_SF_DRAGGING)) {
    121                  int LimitTop;
    122                  #if (FRAMEWIN_ALLOW_DRAG_ON_FRAME)
    123                    LimitTop = 0;
    124                  #else
    125                    FRAMEWIN_POSITIONS Pos;
    126                    FRAMEWIN__CalcPositions(hObj, &Pos);
    127                    LimitTop = BorderSize + Pos.TitleHeight - 1 + IBorderSize;
    128                    if ((pState->y <= LimitTop) || WM_HasCaptured(hObj))
    129                  #endif
    130                  {
    131                    if ((Flags & FRAMEWIN_SF_MAXIMIZED) == 0) {
    132                      WM_SetCaptureMove(hObj, pState, FRAMEWIN__MinVisibility, LimitTop);
    133                    }
    134                  }
    135                }
    136              } else {
    137                pObj = FRAMEWIN_LOCK_H(hObj);
    138                pObj->Flags &= ~FRAMEWIN_SF_DRAGGING;
    139                GUI_UNLOCK_H(pObj);
    140              }
    141            }
    142          }
    143          
    144          /*********************************************************************
    145          *
    146          *       _OnChildHasFocus
    147          *
    148          * Function:
    149          *   A child has received or lost the focus.
    150          *   The basic idea is to make sure the framewindow is active if a
    151          *   descendant has the focus.
    152          *   If the focus travels from one desc. to an other, there is no need
    153          *   to make the framewindow inactive and active again.
    154          *   Avoiding this complicates the code a litlle, but avoids flicker
    155          *   and waste of CPU load.
    156          *   
    157          */
    158          static void _OnChildHasFocus(FRAMEWIN_Handle hObj, WM_MESSAGE *pMsg) {
    159            FRAMEWIN_Obj * pObj;
    160            if (pMsg->Data.p) {
    161              const WM_NOTIFY_CHILD_HAS_FOCUS_INFO * pInfo = (const WM_NOTIFY_CHILD_HAS_FOCUS_INFO *)pMsg->Data.p;
    162              int IsDesc = WM__IsAncestorOrSelf(pInfo->hNew, hObj);
    163              if (IsDesc) {                         // A child has received the focus, Framewindow needs to be activated
    164                _SetActive(hObj, 1);
    165              } else {                  // A child has lost the focus, we need to deactivate
    166                _SetActive(hObj, 0);
    167                //
    168                // Remember the child which had the focus so we can reactive this child
    169                //
    170                if (WM__IsAncestor(pInfo->hOld, hObj)) {
    171                  pObj = FRAMEWIN_LOCK_H(hObj);
    172                  pObj->hFocussedChild = pInfo->hOld;
    173                  GUI_UNLOCK_H(pObj);
    174                }
    175              }
    176            }
    177          }
    178          
    179          /*********************************************************************
    180          *
    181          *       Client Callback
    182          */

   \                                 In section .text, align 4, keep-with-next
    183          static void FRAMEWIN__cbClient(WM_MESSAGE * pMsg) {
   \                     FRAMEWIN__cbClient:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    184            WM_HWIN hWin, hParent;
    185            FRAMEWIN_Obj * pObj;
    186            WM_CALLBACK * cb;
    187            GUI_COLOR ClientColor;
    188            WM_HWIN hFocussedChild;
    189          
    190            hWin    = pMsg->hWin;
   \   00000008   047094E5           LDR      R7,[R4, #+4]
   \   0000000C   14D04DE2           SUB      SP,SP,#+20
    191            hParent = WM_GetParent(pMsg->hWin);
   \   00000010   0700A0E1           MOV      R0,R7
   \   00000014   ........           BL       WM_GetParent
   \   00000018   0050A0E1           MOV      R5,R0
    192            pObj = (FRAMEWIN_Obj *)GUI_LOCK_H(hParent); // Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point
   \   0000001C   ........           BL       GUI_ALLOC_LockH
    193            cb = pObj->cb;
   \   00000020   646090E5           LDR      R6,[R0, #+100]
    194            ClientColor = pObj->Props.ClientColor;
   \   00000024   488090E5           LDR      R8,[R0, #+72]
    195            hFocussedChild = pObj->hFocussedChild;
   \   00000028   809090E5           LDR      R9,[R0, #+128]
    196            GUI_UNLOCK_H(pObj);
   \   0000002C   ........           BL       GUI_ALLOC_UnlockH
    197            switch (pMsg->MsgId) {
   \   00000030   000094E5           LDR      R0,[R4, #+0]
   \   00000034   0E0040E2           SUB      R0,R0,#+14
   \   00000038   140050E3           CMP      R0,#+20
   \   0000003C   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??FRAMEWIN__cbClient_0:
   \   00000040   5100008A           BHI      ??FRAMEWIN__cbClient_1
   \   00000044   390000EA           B        ??FRAMEWIN__cbClient_2
   \   00000048   120000EA           B        ??FRAMEWIN__cbClient_3
   \   0000004C   4E0000EA           B        ??FRAMEWIN__cbClient_1
   \   00000050   4D0000EA           B        ??FRAMEWIN__cbClient_1
   \   00000054   4C0000EA           B        ??FRAMEWIN__cbClient_1
   \   00000058   4B0000EA           B        ??FRAMEWIN__cbClient_1
   \   0000005C   500000EA           B        ??FRAMEWIN__cbClient_4
   \   00000060   4F0000EA           B        ??FRAMEWIN__cbClient_4
   \   00000064   480000EA           B        ??FRAMEWIN__cbClient_1
   \   00000068   4D0000EA           B        ??FRAMEWIN__cbClient_4
   \   0000006C   460000EA           B        ??FRAMEWIN__cbClient_1
   \   00000070   450000EA           B        ??FRAMEWIN__cbClient_1
   \   00000074   440000EA           B        ??FRAMEWIN__cbClient_1
   \   00000078   430000EA           B        ??FRAMEWIN__cbClient_1
   \   0000007C   420000EA           B        ??FRAMEWIN__cbClient_1
   \   00000080   410000EA           B        ??FRAMEWIN__cbClient_1
   \   00000084   120000EA           B        ??FRAMEWIN__cbClient_5
   \   00000088   240000EA           B        ??FRAMEWIN__cbClient_6
   \   0000008C   3E0000EA           B        ??FRAMEWIN__cbClient_1
   \   00000090   3D0000EA           B        ??FRAMEWIN__cbClient_1
   \   00000094   3A0000EA           B        ??FRAMEWIN__cbClient_7
    198            case WM_PAINT:
    199              if (ClientColor != GUI_INVALID_COLOR) {
   \                     ??FRAMEWIN__cbClient_3:
   \   00000098   F004E0E3           MVN      R0,#-268435456
   \   0000009C   000058E1           CMP      R8,R0
   \   000000A0   0200000A           BEQ      ??FRAMEWIN__cbClient_8
    200                LCD_SetBkColor(ClientColor);
   \   000000A4   0800A0E1           MOV      R0,R8
   \   000000A8   ........           BL       LCD_SetBkColor
    201                GUI_Clear();
   \   000000AC   ........           BL       GUI_Clear
    202              }
    203              //
    204              // Give the user callback  a chance to draw.
    205              // Note that we can not run into the bottom part, as this passes the parents handle
    206              //
    207              if (cb) {
   \                     ??FRAMEWIN__cbClient_8:
   \   000000B0   000056E3           CMP      R6,#+0
   \   000000B4   3C00000A           BEQ      ??FRAMEWIN__cbClient_9
    208          	    WM_MESSAGE Msg;
    209                Msg      = *pMsg;
   \   000000B8   0E10B4E8           LDM      R4!,{R1-R3,R12}
   \   000000BC   0D00A0E1           MOV      R0,SP
   \   000000C0   0E10A0E8           STM      R0!,{R1-R3,R12}
    210                Msg.hWin = hWin;
   \   000000C4   04708DE5           STR      R7,[SP, #+4]
    211                (*cb)(&Msg);
   \   000000C8   0D00A0E1           MOV      R0,SP
   \   000000CC   36FF2FE1           BLX      R6
   \   000000D0   350000EA           B        ??FRAMEWIN__cbClient_9
    212              }
    213              return;
    214            case WM_SET_FOCUS:
    215              if (pMsg->Data.v) {     // Focus received
   \                     ??FRAMEWIN__cbClient_5:
   \   000000D4   0C0094E5           LDR      R0,[R4, #+12]
   \   000000D8   000050E3           CMP      R0,#+0
   \   000000DC   3200000A           BEQ      ??FRAMEWIN__cbClient_9
    216                if (hFocussedChild && (hFocussedChild != hWin)) {
   \   000000E0   000059E3           CMP      R9,#+0
   \   000000E4   07005911           CMPNE    R9,R7
   \   000000E8   0200000A           BEQ      ??FRAMEWIN__cbClient_10
    217                  WM_SetFocus(hFocussedChild);
   \   000000EC   0900A0E1           MOV      R0,R9
   \   000000F0   ........           BL       WM_SetFocus
   \   000000F4   060000EA           B        ??FRAMEWIN__cbClient_11
    218                } else {
    219                  hFocussedChild = WM_SetFocusOnNextChild(hWin);
   \                     ??FRAMEWIN__cbClient_10:
   \   000000F8   0700A0E1           MOV      R0,R7
   \   000000FC   ........           BL       WM_SetFocusOnNextChild
   \   00000100   0090A0E1           MOV      R9,R0
    220                  pObj = FRAMEWIN_LOCK_H(hParent);
    221                  pObj->hFocussedChild = hFocussedChild;
   \   00000104   0500A0E1           MOV      R0,R5
   \   00000108   ........           BL       GUI_ALLOC_LockH
   \   0000010C   809080E5           STR      R9,[R0, #+128]
    222                  GUI_UNLOCK_H(pObj);
   \   00000110   ........           BL       GUI_ALLOC_UnlockH
    223                }
    224                pMsg->Data.v = 0;     // Focus change accepted
   \                     ??FRAMEWIN__cbClient_11:
   \   00000114   0000A0E3           MOV      R0,#+0
   \   00000118   0C0084E5           STR      R0,[R4, #+12]
   \   0000011C   220000EA           B        ??FRAMEWIN__cbClient_9
    225              }
    226              return;
    227            case WM_GET_ACCEPT_FOCUS:
    228              WIDGET_HandleActive(hParent, pMsg);
   \                     ??FRAMEWIN__cbClient_6:
   \   00000120   0410A0E1           MOV      R1,R4
   \   00000124   0500A0E1           MOV      R0,R5
   \   00000128   ........           BL       WIDGET_HandleActive
    229              return;
   \   0000012C   1E0000EA           B        ??FRAMEWIN__cbClient_9
    230            case WM_KEY:
    231              if (((const WM_KEY_INFO*)(pMsg->Data.p))->PressedCnt > 0) {
   \                     ??FRAMEWIN__cbClient_2:
   \   00000130   0C0094E5           LDR      R0,[R4, #+12]
   \   00000134   041090E5           LDR      R1,[R0, #+4]
   \   00000138   010051E3           CMP      R1,#+1
   \   0000013C   120000BA           BLT      ??FRAMEWIN__cbClient_1
    232                int Key = ((const WM_KEY_INFO*)(pMsg->Data.p))->Key;
    233                switch (Key) {
   \   00000140   000090E5           LDR      R0,[R0, #+0]
   \   00000144   090050E3           CMP      R0,#+9
   \   00000148   0A00000A           BEQ      ??FRAMEWIN__cbClient_12
   \   0000014C   0E00003A           BCC      ??FRAMEWIN__cbClient_1
   \   00000150   0A0050E3           CMP      R0,#+10
   \   00000154   0C00001A           BNE      ??FRAMEWIN__cbClient_1
    234                case GUI_KEY_BACKTAB:
    235                  hFocussedChild = WM_SetFocusOnPrevChild(hWin);
   \   00000158   0700A0E1           MOV      R0,R7
   \   0000015C   ........           BL       WM_SetFocusOnPrevChild
   \                     ??FRAMEWIN__cbClient_13:
   \   00000160   0090A0E1           MOV      R9,R0
    236                  pObj = FRAMEWIN_LOCK_H(hParent);
    237                  pObj->hFocussedChild = hFocussedChild;
   \   00000164   0500A0E1           MOV      R0,R5
   \   00000168   ........           BL       GUI_ALLOC_LockH
   \   0000016C   809080E5           STR      R9,[R0, #+128]
    238                  GUI_UNLOCK_H(pObj);
   \   00000170   ........           BL       GUI_ALLOC_UnlockH
    239                  return;
   \   00000174   0C0000EA           B        ??FRAMEWIN__cbClient_9
    240                case GUI_KEY_TAB:
    241                  hFocussedChild = WM_SetFocusOnNextChild(hWin);
   \                     ??FRAMEWIN__cbClient_12:
   \   00000178   0700A0E1           MOV      R0,R7
   \   0000017C   ........           BL       WM_SetFocusOnNextChild
   \   00000180   F6FFFFEA           B        ??FRAMEWIN__cbClient_13
    242                  pObj = FRAMEWIN_LOCK_H(hParent);
    243                  pObj->hFocussedChild = hFocussedChild;
    244                  GUI_UNLOCK_H(pObj);
    245                  return;
    246                }
    247              }
    248              break;	                       // Send to parent by not doing anything
    249            case WM_GET_BKCOLOR:
    250              pMsg->Data.Color = ClientColor;
   \                     ??FRAMEWIN__cbClient_7:
   \   00000184   0C8084E5           STR      R8,[R4, #+12]
    251              return;                       // Message handled
   \   00000188   070000EA           B        ??FRAMEWIN__cbClient_9
    252            case WM_GET_INSIDE_RECT:        // This should not be passed to parent ... (We do not want parents coordinates
    253            case WM_GET_ID:                 // This should not be passed to parent ... (Possible recursion problem
    254            case WM_GET_CLIENT_WINDOW:      // return handle to client window. For most windows, there is no seperate client window, so it is the same handle
    255              WM_DefaultProc(pMsg);
    256              return;                       // We are done !
    257            }
    258            //
    259            // Call user callback. Note that the user callback gets the handle of the Framewindow itself, NOT the Client.
    260            //
    261            if (cb) {
   \                     ??FRAMEWIN__cbClient_1:
   \   0000018C   000056E3           CMP      R6,#+0
   \   00000190   0300000A           BEQ      ??FRAMEWIN__cbClient_4
    262              pMsg->hWin = hParent;
   \   00000194   045084E5           STR      R5,[R4, #+4]
    263              (*cb)(pMsg);
   \   00000198   0400A0E1           MOV      R0,R4
   \   0000019C   36FF2FE1           BLX      R6
   \   000001A0   010000EA           B        ??FRAMEWIN__cbClient_9
    264            } else {
    265              WM_DefaultProc(pMsg);
   \                     ??FRAMEWIN__cbClient_4:
   \   000001A4   0400A0E1           MOV      R0,R4
   \   000001A8   ........           BL       WM_DefaultProc
   \                     ??FRAMEWIN__cbClient_9:
   \   000001AC   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000001B0   F083BDE8           POP      {R4-R9,PC}       ;; return
    266            }
    267          }
    268          
    269          /*********************************************************************
    270          *
    271          *       Private routines
    272          *
    273          **********************************************************************
    274          */
    275          /*********************************************************************
    276          *
    277          *       FRAMEWIN_LockH
    278          */
    279          #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
    280          FRAMEWIN_Obj * FRAMEWIN_LockH(FRAMEWIN_Handle h) {
    281            FRAMEWIN_Obj * p = (FRAMEWIN_Obj *)GUI_LOCK_H(h);
    282            if (p) {
    283              if (p->DebugId != FRAMEWIN_ID) {
    284                GUI_DEBUG_ERROROUT("FRAMEWIN.c: Wrong handle type or Object not init'ed");
    285                return 0;
    286              }
    287            }
    288            return p;
    289          }
    290          #endif
    291          
    292          /*********************************************************************
    293          *
    294          *       FRAMEWIN__GetBorderSize
    295          */

   \                                 In section .text, align 4, keep-with-next
    296          unsigned FRAMEWIN__GetBorderSize(FRAMEWIN_Handle hObj, unsigned Index) {
   \                     FRAMEWIN__GetBorderSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   0160A0E1           MOV      R6,R1
    297            FRAMEWIN_Obj * pObj;
    298            FRAMEWIN_SKIN_PRIVATE * pSkinPrivate;
    299            WIDGET_ITEM_DRAW_INFO ItemInfo;
    300            
    301            pObj = FRAMEWIN_LOCK_H(hObj);
    302            pSkinPrivate = (FRAMEWIN_SKIN_PRIVATE *)pObj->pWidgetSkin->pSkinPrivate;
   \   00000010   ........           BL       GUI_ALLOC_LockH
   \   00000014   5C0090E5           LDR      R0,[R0, #+92]
   \   00000018   084090E5           LDR      R4,[R0, #+8]
    303            GUI_UNLOCK_H(pObj);
   \   0000001C   ........           BL       GUI_ALLOC_UnlockH
    304            ItemInfo.hWin = hObj;
   \   00000020   00508DE5           STR      R5,[SP, #+0]
    305            switch (Index) {
   \   00000024   030056E3           CMP      R6,#+3
   \   00000028   06F18F90           ADDLS    PC,PC,R6, LSL #+2
   \                     ??FRAMEWIN__GetBorderSize_0:
   \   0000002C   0B00008A           BHI      ??FRAMEWIN__GetBorderSize_1
   \   00000030   020000EA           B        ??FRAMEWIN__GetBorderSize_2
   \   00000034   030000EA           B        ??FRAMEWIN__GetBorderSize_3
   \   00000038   040000EA           B        ??FRAMEWIN__GetBorderSize_4
   \   0000003C   050000EA           B        ??FRAMEWIN__GetBorderSize_5
    306            case FRAMEWIN_GET_BORDERSIZE_T:
    307              ItemInfo.Cmd = WIDGET_ITEM_GET_BORDERSIZE_T;
   \                     ??FRAMEWIN__GetBorderSize_2:
   \   00000040   1610A0E3           MOV      R1,#+22
   \   00000044   040000EA           B        ??FRAMEWIN__GetBorderSize_6
    308              break;
    309            case FRAMEWIN_GET_BORDERSIZE_L:
    310              ItemInfo.Cmd = WIDGET_ITEM_GET_BORDERSIZE_L;
   \                     ??FRAMEWIN__GetBorderSize_3:
   \   00000048   1410A0E3           MOV      R1,#+20
   \   0000004C   020000EA           B        ??FRAMEWIN__GetBorderSize_6
    311              break;
    312            case FRAMEWIN_GET_BORDERSIZE_B:
    313              ItemInfo.Cmd = WIDGET_ITEM_GET_BORDERSIZE_B;
   \                     ??FRAMEWIN__GetBorderSize_4:
   \   00000050   1310A0E3           MOV      R1,#+19
   \   00000054   000000EA           B        ??FRAMEWIN__GetBorderSize_6
    314              break;
    315            case FRAMEWIN_GET_BORDERSIZE_R:
    316              ItemInfo.Cmd = WIDGET_ITEM_GET_BORDERSIZE_R;
   \                     ??FRAMEWIN__GetBorderSize_5:
   \   00000058   1510A0E3           MOV      R1,#+21
   \                     ??FRAMEWIN__GetBorderSize_6:
   \   0000005C   04108DE5           STR      R1,[SP, #+4]
    317              break;
    318            }
    319            return pSkinPrivate->pfDrawSkin(&ItemInfo);
   \                     ??FRAMEWIN__GetBorderSize_1:
   \   00000060   0D00A0E1           MOV      R0,SP
   \   00000064   041094E5           LDR      R1,[R4, #+4]
   \   00000068   31FF2FE1           BLX      R1
   \   0000006C   20D08DE2           ADD      SP,SP,#+32       ;; stack cleaning
   \   00000070   7080BDE8           POP      {R4-R6,PC}       ;; return
    320          }
    321          
    322          /*********************************************************************
    323          *
    324          *       FRAMEWIN__CalcTitleHeight
    325          */

   \                                 In section .text, align 4, keep-with-next
    326          int FRAMEWIN__CalcTitleHeight(FRAMEWIN_Obj * pObj) {
   \                     FRAMEWIN__CalcTitleHeight:
   \   00000000   00402DE9           PUSH     {LR}
    327            int r = 0;
    328            if (pObj->Widget.State & FRAMEWIN_SF_TITLEVIS) {
   \   00000004   3220D0E5           LDRB     R2,[R0, #+50]
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   200012E3           TST      R2,#0x20
   \   00000014   0500000A           BEQ      ??FRAMEWIN__CalcTitleHeight_0
    329              r = pObj->Props.TitleHeight;
   \   00000018   F415D0E1           LDRSH    R1,[R0, #+84]
    330              if (r == 0) {
   \   0000001C   000051E3           CMP      R1,#+0
   \   00000020   0200001A           BNE      ??FRAMEWIN__CalcTitleHeight_0
    331                r = 2 + GUI_GetYSizeOfFont(pObj->Props.pFont);
   \   00000024   340090E5           LDR      R0,[R0, #+52]
   \   00000028   ........           BL       GUI_GetYSizeOfFont
   \   0000002C   021080E2           ADD      R1,R0,#+2
    332              }
    333            }
    334            return r;
   \                     ??FRAMEWIN__CalcTitleHeight_0:
   \   00000030   0100A0E1           MOV      R0,R1
   \   00000034   04D08DE2           ADD      SP,SP,#+4
   \   00000038   0080BDE8           POP      {PC}             ;; return
    335          }
    336          
    337          /*********************************************************************
    338          *
    339          *       FRAMEWIN__GetTitleLimits
    340          */

   \                                 In section .text, align 4, keep-with-next
    341          void FRAMEWIN__GetTitleLimits(FRAMEWIN_Handle hObj, int * pxMin, int * pxMax) {
   \                     FRAMEWIN__GetTitleLimits:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0090A0E1           MOV      R9,R0
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
    342            FRAMEWIN_Obj * pObj;
    343            FRAMEWIN_SKIN_PRIVATE * pSkinPrivate;
    344            WM_HWIN hChild;
    345            WM_Obj * pChild;
    346            int x0, x1, y0, BorderSizeT;
    347            GUI_RECT Rect;
    348          
    349            //
    350            // Get properties
    351            //
    352            pObj = FRAMEWIN_LOCK_H(hObj);
   \   00000014   ........           BL       GUI_ALLOC_LockH
    353            pSkinPrivate = (FRAMEWIN_SKIN_PRIVATE *)pObj->pWidgetSkin->pSkinPrivate;
   \   00000018   5C1090E5           LDR      R1,[R0, #+92]
    354            Rect = pObj->Widget.Win.Rect;
   \   0000001C   F060D0E1           LDRSH    R6,[R0, #+0]
   \   00000020   088091E5           LDR      R8,[R1, #+8]
   \   00000024   F270D0E1           LDRSH    R7,[R0, #+2]
    355            GUI_UNLOCK_H(pObj);
   \   00000028   ........           BL       GUI_ALLOC_UnlockH
    356            BorderSizeT = pSkinPrivate->pfGetBordersize(hObj, FRAMEWIN_GET_BORDERSIZE_T);
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   0900A0E1           MOV      R0,R9
   \   00000034   002098E5           LDR      R2,[R8, #+0]
   \   00000038   32FF2FE1           BLX      R2
   \   0000003C   0080A0E1           MOV      R8,R0
    357            //
    358            // Iterate over child windows
    359            //
    360            hChild = WM_GetFirstChild(hObj);
   \   00000040   0900A0E1           MOV      R0,R9
   \   00000044   ........           BL       WM_GetFirstChild
   \   00000048   0090B0E1           MOVS     R9,R0
    361            while (hChild) {
   \   0000004C   1B00000A           BEQ      ??FRAMEWIN__GetTitleLimits_0
    362              pChild = (WM_Obj *)GUI_LOCK_H(hChild);
   \                     ??FRAMEWIN__GetTitleLimits_1:
   \   00000050   0900A0E1           MOV      R0,R9
   \   00000054   ........           BL       GUI_ALLOC_LockH
    363              x0 = pChild->Rect.x0 - Rect.x0;
    364              x1 = pChild->Rect.x1 - Rect.x0;
    365              y0 = pChild->Rect.y0 - Rect.y0;
    366              if (y0 == BorderSizeT) {
   \   00000058   F230D0E1           LDRSH    R3,[R0, #+2]
   \   0000005C   F010D0E1           LDRSH    R1,[R0, #+0]
   \   00000060   F420D0E1           LDRSH    R2,[R0, #+4]
   \   00000064   073043E0           SUB      R3,R3,R7
   \   00000068   061041E0           SUB      R1,R1,R6
   \   0000006C   062042E0           SUB      R2,R2,R6
   \   00000070   080053E1           CMP      R3,R8
   \   00000074   0C00001A           BNE      ??FRAMEWIN__GetTitleLimits_2
    367                if (pChild->Status & WM_SF_ANCHOR_RIGHT) {
   \   00000078   2800D0E5           LDRB     R0,[R0, #+40]
   \   0000007C   800010E3           TST      R0,#0x80
   \   00000080   0500000A           BEQ      ??FRAMEWIN__GetTitleLimits_3
    368                  if (x0 <= *pxMax) {
   \   00000084   000095E5           LDR      R0,[R5, #+0]
   \   00000088   010050E1           CMP      R0,R1
   \   0000008C   060000BA           BLT      ??FRAMEWIN__GetTitleLimits_2
    369                    *pxMax = x0 - 1;
   \   00000090   010041E2           SUB      R0,R1,#+1
   \   00000094   000085E5           STR      R0,[R5, #+0]
   \   00000098   030000EA           B        ??FRAMEWIN__GetTitleLimits_2
    370                  }
    371                } else {
    372                  if (x1 >= *pxMin) {
   \                     ??FRAMEWIN__GetTitleLimits_3:
   \   0000009C   000094E5           LDR      R0,[R4, #+0]
   \   000000A0   000052E1           CMP      R2,R0
    373                    *pxMin = x1 + 1;
   \   000000A4   010082A2           ADDGE    R0,R2,#+1
   \   000000A8   000084A5           STRGE    R0,[R4, #+0]
    374                  }
    375                }
    376              }
    377              GUI_UNLOCK_H(pChild);
   \                     ??FRAMEWIN__GetTitleLimits_2:
   \   000000AC   ........           BL       GUI_ALLOC_UnlockH
    378              hChild = WM_GetNextSibling(hChild);
   \   000000B0   0900A0E1           MOV      R0,R9
   \   000000B4   ........           BL       WM_GetNextSibling
   \   000000B8   0090B0E1           MOVS     R9,R0
   \   000000BC   E3FFFF1A           BNE      ??FRAMEWIN__GetTitleLimits_1
    379            }
    380          }
   \                     ??FRAMEWIN__GetTitleLimits_0:
   \   000000C0   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000C4   F083BDE8           POP      {R4-R9,PC}       ;; return
    381          
    382          /*********************************************************************
    383          *
    384          *       FRAMEWIN__CalcPositions
    385          */

   \                                 In section .text, align 4, keep-with-next
    386          void FRAMEWIN__CalcPositions(FRAMEWIN_Handle hObj, FRAMEWIN_POSITIONS * pPos) {
   \                     FRAMEWIN__CalcPositions:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
    387            FRAMEWIN_Obj * pObj;
    388            int TitleHeight;
    389            int MenuHeight = 0;
   \   00000008   0060A0E3           MOV      R6,#+0
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0150A0E1           MOV      R5,R1
    390            int IBorderSize = 0;
   \   00000014   04608DE5           STR      R6,[SP, #+4]
    391            int BorderSizeL;
    392            int BorderSizeR;
    393            int BorderSizeB;
    394            int BorderSizeT;
    395            int xsize, ysize;
    396            int x0, x1/*, y0*/;
    397            FRAMEWIN_SKIN_PRIVATE * pSkinPrivate;
    398          
    399            pObj = FRAMEWIN_LOCK_H(hObj);
   \   00000018   ........           BL       GUI_ALLOC_LockH
   \   0000001C   00B0A0E1           MOV      R11,R0
    400            pSkinPrivate = (FRAMEWIN_SKIN_PRIVATE *)pObj->pWidgetSkin->pSkinPrivate;
   \   00000020   5C009BE5           LDR      R0,[R11, #+92]
    401            BorderSizeL = pSkinPrivate->pfGetBordersize(hObj, FRAMEWIN_GET_BORDERSIZE_L);
   \   00000024   0110A0E3           MOV      R1,#+1
   \   00000028   087090E5           LDR      R7,[R0, #+8]
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   002097E5           LDR      R2,[R7, #+0]
   \   00000034   32FF2FE1           BLX      R2
   \   00000038   00008DE5           STR      R0,[SP, #+0]
    402            BorderSizeR = pSkinPrivate->pfGetBordersize(hObj, FRAMEWIN_GET_BORDERSIZE_R);
   \   0000003C   0310A0E3           MOV      R1,#+3
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   002097E5           LDR      R2,[R7, #+0]
   \   00000048   32FF2FE1           BLX      R2
   \   0000004C   0C008DE5           STR      R0,[SP, #+12]
    403            BorderSizeB = pSkinPrivate->pfGetBordersize(hObj, FRAMEWIN_GET_BORDERSIZE_B);
   \   00000050   0210A0E3           MOV      R1,#+2
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   002097E5           LDR      R2,[R7, #+0]
   \   0000005C   32FF2FE1           BLX      R2
   \   00000060   08008DE5           STR      R0,[SP, #+8]
    404            BorderSizeT = pSkinPrivate->pfGetBordersize(hObj, FRAMEWIN_GET_BORDERSIZE_T);
   \   00000064   0010A0E3           MOV      R1,#+0
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   002097E5           LDR      R2,[R7, #+0]
   \   00000070   32FF2FE1           BLX      R2
   \   00000074   0070A0E1           MOV      R7,R0
    405            xsize = WM__GetWindowSizeX(&pObj->Widget.Win);
   \   00000078   0B00A0E1           MOV      R0,R11
   \   0000007C   ........           BL       WM__GetWindowSizeX
   \   00000080   0080A0E1           MOV      R8,R0
    406            ysize = WM__GetWindowSizeY(&pObj->Widget.Win);
   \   00000084   0B00A0E1           MOV      R0,R11
   \   00000088   ........           BL       WM__GetWindowSizeY
   \   0000008C   0090A0E1           MOV      R9,R0
    407            if (pObj->Widget.State & FRAMEWIN_SF_TITLEVIS) {
   \   00000090   3200DBE5           LDRB     R0,[R11, #+50]
   \   00000094   200010E3           TST      R0,#0x20
   \   00000098   4800000A           BEQ      ??FRAMEWIN__CalcPositions_0
    408              IBorderSize = pObj->Props.IBorderSize;
   \   0000009C   F815DBE1           LDRSH    R1,[R11, #+88]
   \   000000A0   04108DE5           STR      R1,[SP, #+4]
   \   000000A4   F4A5DBE1           LDRSH    R10,[R11, #+84]
   \   000000A8   00005AE3           CMP      R10,#+0
   \   000000AC   0200001A           BNE      ??FRAMEWIN__CalcPositions_1
   \   000000B0   34009BE5           LDR      R0,[R11, #+52]
   \   000000B4   ........           BL       GUI_GetYSizeOfFont
   \   000000B8   02A080E2           ADD      R10,R0,#+2
    409            }
    410            TitleHeight = FRAMEWIN__CalcTitleHeight(pObj);
    411            if (pObj->hMenu) {
   \                     ??FRAMEWIN__CalcPositions_1:
   \   000000BC   6C009BE5           LDR      R0,[R11, #+108]
   \   000000C0   000050E3           CMP      R0,#+0
   \   000000C4   0100000A           BEQ      ??FRAMEWIN__CalcPositions_2
    412              MenuHeight = WM_GetWindowSizeY(pObj->hMenu);
   \   000000C8   ........           BL       WM_GetWindowSizeY
   \   000000CC   0060A0E1           MOV      R6,R0
    413            }
    414            pPos->TitleHeight = TitleHeight;
   \                     ??FRAMEWIN__CalcPositions_2:
   \   000000D0   B0A0C5E1           STRH     R10,[R5, #+0]
    415            pPos->MenuHeight  = MenuHeight;
   \   000000D4   B260C5E1           STRH     R6,[R5, #+2]
    416            //
    417            // Set object properties accordingly
    418            //
    419            pPos->rClient.x0  =         BorderSizeL;
   \   000000D8   00009DE5           LDR      R0,[SP, #+0]
   \   000000DC   B400C5E1           STRH     R0,[R5, #+4]
   \   000000E0   0C009DE5           LDR      R0,[SP, #+12]
   \   000000E4   000048E0           SUB      R0,R8,R0
   \   000000E8   010040E2           SUB      R0,R0,#+1
   \   000000EC   B800C5E1           STRH     R0,[R5, #+8]
    420            pPos->rClient.x1  = xsize - BorderSizeR - 1;
    421            pPos->rClient.y0  =         BorderSizeT + IBorderSize + TitleHeight + MenuHeight;
   \   000000F0   04209DE5           LDR      R2,[SP, #+4]
   \   000000F4   071082E0           ADD      R1,R2,R7
   \   000000F8   01108AE0           ADD      R1,R10,R1
   \   000000FC   011086E0           ADD      R1,R6,R1
   \   00000100   B610C5E1           STRH     R1,[R5, #+6]
    422            pPos->rClient.y1  = ysize - BorderSizeB - 1;
   \   00000104   08109DE5           LDR      R1,[SP, #+8]
   \   00000108   011049E0           SUB      R1,R9,R1
   \   0000010C   011041E2           SUB      R1,R1,#+1
   \   00000110   BA10C5E1           STRH     R1,[R5, #+10]
    423            //
    424            // Calculate title rect
    425            //
    426            pPos->rTitleText.x0 =         BorderSizeL;
   \   00000114   00109DE5           LDR      R1,[SP, #+0]
   \   00000118   BC10C5E1           STRH     R1,[R5, #+12]
    427            pPos->rTitleText.x1 = xsize - BorderSizeR - 1;
   \   0000011C   B001C5E1           STRH     R0,[R5, #+16]
    428            pPos->rTitleText.y0 =         BorderSizeT;
    429            pPos->rTitleText.y1 =         BorderSizeT + TitleHeight - 1;
   \   00000120   07008AE0           ADD      R0,R10,R7
   \   00000124   BE70C5E1           STRH     R7,[R5, #+14]
   \   00000128   010040E2           SUB      R0,R0,#+1
   \   0000012C   B201C5E1           STRH     R0,[R5, #+18]
    430            #if 1
    431              GUI_UNLOCK_H(pObj);
   \   00000130   ........           BL       GUI_ALLOC_UnlockH
    432              x0 = pPos->rTitleText.x0;
   \   00000134   FC60D5E1           LDRSH    R6,[R5, #+12]
    433              x1 = pPos->rTitleText.x1;
   \   00000138   F071D5E1           LDRSH    R7,[R5, #+16]
    434              FRAMEWIN__GetTitleLimits(hObj, &x0, &x1);
   \   0000013C   0400A0E1           MOV      R0,R4
   \   00000140   ........           BL       GUI_ALLOC_LockH
   \   00000144   5C1090E5           LDR      R1,[R0, #+92]
   \   00000148   F080D0E1           LDRSH    R8,[R0, #+0]
   \   0000014C   08A091E5           LDR      R10,[R1, #+8]
   \   00000150   F290D0E1           LDRSH    R9,[R0, #+2]
   \   00000154   ........           BL       GUI_ALLOC_UnlockH
   \   00000158   0010A0E3           MOV      R1,#+0
   \   0000015C   0400A0E1           MOV      R0,R4
   \   00000160   00209AE5           LDR      R2,[R10, #+0]
   \   00000164   32FF2FE1           BLX      R2
   \   00000168   00A0A0E1           MOV      R10,R0
   \   0000016C   0400A0E1           MOV      R0,R4
   \   00000170   ........           BL       WM_GetFirstChild
   \   00000174   0040B0E1           MOVS     R4,R0
   \   00000178   1900000A           BEQ      ??FRAMEWIN__CalcPositions_3
   \                     ??FRAMEWIN__CalcPositions_4:
   \   0000017C   0400A0E1           MOV      R0,R4
   \   00000180   ........           BL       GUI_ALLOC_LockH
   \   00000184   F230D0E1           LDRSH    R3,[R0, #+2]
   \   00000188   F010D0E1           LDRSH    R1,[R0, #+0]
   \   0000018C   F420D0E1           LDRSH    R2,[R0, #+4]
   \   00000190   093043E0           SUB      R3,R3,R9
   \   00000194   081041E0           SUB      R1,R1,R8
   \   00000198   082042E0           SUB      R2,R2,R8
   \   0000019C   0A0053E1           CMP      R3,R10
   \   000001A0   0A00001A           BNE      ??FRAMEWIN__CalcPositions_5
   \   000001A4   2800D0E5           LDRB     R0,[R0, #+40]
   \   000001A8   800010E3           TST      R0,#0x80
   \   000001AC   0500000A           BEQ      ??FRAMEWIN__CalcPositions_6
   \   000001B0   010057E1           CMP      R7,R1
   \   000001B4   050000BA           BLT      ??FRAMEWIN__CalcPositions_5
   \   000001B8   017041E2           SUB      R7,R1,#+1
   \   000001BC   030000EA           B        ??FRAMEWIN__CalcPositions_5
   \                     ??FRAMEWIN__CalcPositions_0:
   \   000001C0   00A0A0E3           MOV      R10,#+0
   \   000001C4   BCFFFFEA           B        ??FRAMEWIN__CalcPositions_1
   \                     ??FRAMEWIN__CalcPositions_6:
   \   000001C8   060052E1           CMP      R2,R6
   \   000001CC   016082A2           ADDGE    R6,R2,#+1
   \                     ??FRAMEWIN__CalcPositions_5:
   \   000001D0   ........           BL       GUI_ALLOC_UnlockH
   \   000001D4   0400A0E1           MOV      R0,R4
   \   000001D8   ........           BL       WM_GetNextSibling
   \   000001DC   0040B0E1           MOVS     R4,R0
   \   000001E0   E5FFFF1A           BNE      ??FRAMEWIN__CalcPositions_4
    435              pPos->rTitleText.x0 = x0;
   \                     ??FRAMEWIN__CalcPositions_3:
   \   000001E4   BC60C5E1           STRH     R6,[R5, #+12]
    436              pPos->rTitleText.x1 = x1;
   \   000001E8   B071C5E1           STRH     R7,[R5, #+16]
    437            #else
    438            {
    439              WM_HWIN hChild;
    440              WM_HWIN hNext;
    441              WM_Obj * pChild;
    442              int y0;
    443              //
    444              // Iterate over all children
    445              //
    446              for (hChild = pObj->Widget.Win.hFirstChild; hChild; hChild = hNext) {
    447                pChild = (WM_Obj *)GUI_LOCK_H(hChild);
    448                x0 = pChild->Rect.x0 - pObj->Widget.Win.Rect.x0;
    449                x1 = pChild->Rect.x1 - pObj->Widget.Win.Rect.x0;
    450                y0 = pChild->Rect.y0 - pObj->Widget.Win.Rect.y0;
    451                if (y0 == BorderSizeT) {
    452                  if (pChild->Status & WM_SF_ANCHOR_RIGHT) {
    453                    if (x0 <= pPos->rTitleText.x1) {
    454                      pPos->rTitleText.x1 = x0 - 1;
    455                    }
    456                  } else {
    457                    if (x1 >= pPos->rTitleText.x0) {
    458                      pPos->rTitleText.x0 = x1 + 1;
    459                    }
    460                  }
    461                }
    462                hNext = pChild->hNext;
    463                GUI_UNLOCK_H(pChild);
    464              }
    465              GUI_UNLOCK_H(pObj);
    466            }
    467            #endif
    468          }
   \   000001EC   14D08DE2           ADD      SP,SP,#+20
   \   000001F0   F08FBDE8           POP      {R4-R11,PC}      ;; return
    469          
    470          /*********************************************************************
    471          *
    472          *       FRAMEWIN__UpdatePositions
    473          */

   \                                 In section .text, align 4, keep-with-next
    474          void FRAMEWIN__UpdatePositions(FRAMEWIN_Handle hObj) {
   \                     FRAMEWIN__UpdatePositions:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   18D04DE2           SUB      SP,SP,#+24
   \   00000008   0060A0E1           MOV      R6,R0
    475            FRAMEWIN_Obj * pObj;
    476            FRAMEWIN_POSITIONS Pos;
    477            WM_HWIN hClient;
    478            WM_HWIN hMenu;
    479            pObj = FRAMEWIN_LOCK_H(hObj);
   \   0000000C   ........           BL       GUI_ALLOC_LockH
    480            hClient = pObj->hClient;
   \   00000010   684090E5           LDR      R4,[R0, #+104]
    481            hMenu = pObj->hMenu;
   \   00000014   6C5090E5           LDR      R5,[R0, #+108]
    482            GUI_UNLOCK_H(pObj);
   \   00000018   ........           BL       GUI_ALLOC_UnlockH
    483            //
    484            // Move client window accordingly
    485            //
    486            if (hClient || hMenu) {
   \   0000001C   040095E1           ORRS     R0,R5,R4
   \   00000020   1A00000A           BEQ      ??FRAMEWIN__UpdatePositions_0
    487              FRAMEWIN__CalcPositions(hObj, &Pos);
   \   00000024   0D10A0E1           MOV      R1,SP
   \   00000028   0600A0E1           MOV      R0,R6
   \   0000002C   ........           BL       FRAMEWIN__CalcPositions
    488              if (hClient) {
   \   00000030   000054E3           CMP      R4,#+0
   \   00000034   0D00000A           BEQ      ??FRAMEWIN__UpdatePositions_1
    489                WM_MoveChildTo(hClient, Pos.rClient.x0, Pos.rClient.y0);
   \   00000038   F620DDE1           LDRSH    R2,[SP, #+6]
   \   0000003C   F410DDE1           LDRSH    R1,[SP, #+4]
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   ........           BL       WM_MoveChildTo
    490                WM_SetSize(hClient, 
    491                           Pos.rClient.x1 - Pos.rClient.x0 + 1, 
    492                           Pos.rClient.y1 - Pos.rClient.y0 + 1);
   \   00000048   FA00DDE1           LDRSH    R0,[SP, #+10]
   \   0000004C   F610DDE1           LDRSH    R1,[SP, #+6]
   \   00000050   010040E0           SUB      R0,R0,R1
   \   00000054   012080E2           ADD      R2,R0,#+1
   \   00000058   F800DDE1           LDRSH    R0,[SP, #+8]
   \   0000005C   F410DDE1           LDRSH    R1,[SP, #+4]
   \   00000060   010040E0           SUB      R0,R0,R1
   \   00000064   011080E2           ADD      R1,R0,#+1
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   ........           BL       WM_SetSize
    493              }
    494              if (hMenu) {
   \                     ??FRAMEWIN__UpdatePositions_1:
   \   00000070   000055E3           CMP      R5,#+0
   \   00000074   0500000A           BEQ      ??FRAMEWIN__UpdatePositions_0
    495                WM_MoveChildTo(hMenu, Pos.rClient.x0, Pos.rClient.y0 - Pos.MenuHeight);
   \   00000078   F600DDE1           LDRSH    R0,[SP, #+6]
   \   0000007C   F210DDE1           LDRSH    R1,[SP, #+2]
   \   00000080   012040E0           SUB      R2,R0,R1
   \   00000084   F410DDE1           LDRSH    R1,[SP, #+4]
   \   00000088   0500A0E1           MOV      R0,R5
   \   0000008C   ........           BL       WM_MoveChildTo
    496              }
    497            }
    498          }
   \                     ??FRAMEWIN__UpdatePositions_0:
   \   00000090   18D08DE2           ADD      SP,SP,#+24       ;; stack cleaning
   \   00000094   7080BDE8           POP      {R4-R6,PC}       ;; return
    499          
    500          /*********************************************************************
    501          *
    502          *       _OnPidStateChange
    503          */
    504          static void _OnPidStateChange(FRAMEWIN_Handle hObj, WM_MESSAGE * pMsg) {
    505            FRAMEWIN_Obj * pObj;
    506            const WM_PID_STATE_CHANGED_INFO * pState = (const WM_PID_STATE_CHANGED_INFO *)pMsg->Data.p;
    507            pObj = FRAMEWIN_LOCK_H(hObj);
    508            if ((pState->StatePrev == 0) && (pState->State == 1)) {
    509              pObj->Flags |= FRAMEWIN_SF_DRAGGING;
    510            }
    511            GUI_UNLOCK_H(pObj);
    512          }
    513          
    514          /*********************************************************************
    515          *
    516          *       Exported API routines:  Callback
    517          *
    518          **********************************************************************
    519          */
    520          /*********************************************************************
    521          *
    522          *       Framewin Callback
    523          */

   \                                 In section .text, align 4, keep-with-next
    524          void FRAMEWIN_Callback (WM_MESSAGE * pMsg) {
   \                     FRAMEWIN_Callback:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    525            FRAMEWIN_Handle hObj;
    526            FRAMEWIN_Obj * pObj;
    527            GUI_RECT * pRect;
    528            FRAMEWIN_POSITIONS Pos;
    529            GUI_HOOK * pHook;
    530            WM_HWIN hFocussedChild;
    531            WM_HWIN hClient;
    532            U16 Flags;
    533            //void (* pfPaint)(FRAMEWIN_Handle hObj);
    534            WIDGET_PAINT * pfPaint;
    535          
    536            hObj = (FRAMEWIN_Handle)(pMsg->hWin);
   \   00000008   044095E5           LDR      R4,[R5, #+4]
   \   0000000C   28D04DE2           SUB      SP,SP,#+40
    537            pObj = (FRAMEWIN_Obj *)GUI_LOCK_H(hObj); // Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   ........           BL       GUI_ALLOC_LockH
    538            pHook = pObj->pFirstHook;
   \   00000018   886090E5           LDR      R6,[R0, #+136]
    539            hFocussedChild = pObj->hFocussedChild;
   \   0000001C   807090E5           LDR      R7,[R0, #+128]
    540            hClient = pObj->hClient;
   \   00000020   688090E5           LDR      R8,[R0, #+104]
    541            Flags = pObj->Flags;
   \   00000024   BC97D0E1           LDRH     R9,[R0, #+124]
    542            if (pObj->pWidgetSkin) {
   \   00000028   5C0090E5           LDR      R0,[R0, #+92]
   \   0000002C   000050E3           CMP      R0,#+0
    543              pfPaint = pObj->pWidgetSkin->pfPaint;
   \   00000030   00A09015           LDRNE    R10,[R0, #+0]
    544            }
    545            GUI_UNLOCK_H(pObj);
   \   00000034   ........           BL       GUI_ALLOC_UnlockH
   \   00000038   050000EA           B        ??FRAMEWIN_Callback_1
    546            
    547            //
    548            // Call hook functions
    549            //
    550            for (; pHook; pHook = pHook->pNext) {
    551              int r;
    552              r = (*pHook->pHookFunc)(pMsg);
    553              if (r) {
   \                     ??FRAMEWIN_Callback_2:
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   041096E5           LDR      R1,[R6, #+4]
   \   00000044   31FF2FE1           BLX      R1
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   E400001A           BNE      ??FRAMEWIN_Callback_3
    554                return;   // Message handled
    555              }
    556            }
   \   00000050   006096E5           LDR      R6,[R6, #+0]
   \                     ??FRAMEWIN_Callback_1:
   \   00000054   000056E3           CMP      R6,#+0
   \   00000058   F7FFFF1A           BNE      ??FRAMEWIN_Callback_2
    557            switch (pMsg->MsgId) {
   \   0000005C   000095E5           LDR      R0,[R5, #+0]
   \   00000060   0B0040E2           SUB      R0,R0,#+11
   \   00000064   1F0050E3           CMP      R0,#+31
   \   00000068   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??FRAMEWIN_Callback_0:
   \   0000006C   D500008A           BHI      ??FRAMEWIN_Callback_4
   \   00000070   CF0000EA           B        ??FRAMEWIN_Callback_5
   \   00000074   350000EA           B        ??FRAMEWIN_Callback_6
   \   00000078   9C0000EA           B        ??FRAMEWIN_Callback_7
   \   0000007C   D10000EA           B        ??FRAMEWIN_Callback_4
   \   00000080   2F0000EA           B        ??FRAMEWIN_Callback_8
   \   00000084   CF0000EA           B        ??FRAMEWIN_Callback_4
   \   00000088   180000EA           B        ??FRAMEWIN_Callback_9
   \   0000008C   CD0000EA           B        ??FRAMEWIN_Callback_4
   \   00000090   CC0000EA           B        ??FRAMEWIN_Callback_4
   \   00000094   4D0000EA           B        ??FRAMEWIN_Callback_10
   \   00000098   CA0000EA           B        ??FRAMEWIN_Callback_4
   \   0000009C   C90000EA           B        ??FRAMEWIN_Callback_4
   \   000000A0   520000EA           B        ??FRAMEWIN_Callback_11
   \   000000A4   C70000EA           B        ??FRAMEWIN_Callback_4
   \   000000A8   C60000EA           B        ??FRAMEWIN_Callback_4
   \   000000AC   C50000EA           B        ??FRAMEWIN_Callback_4
   \   000000B0   C40000EA           B        ??FRAMEWIN_Callback_4
   \   000000B4   C30000EA           B        ??FRAMEWIN_Callback_4
   \   000000B8   C20000EA           B        ??FRAMEWIN_Callback_4
   \   000000BC   590000EA           B        ??FRAMEWIN_Callback_12
   \   000000C0   C00000EA           B        ??FRAMEWIN_Callback_4
   \   000000C4   940000EA           B        ??FRAMEWIN_Callback_13
   \   000000C8   BE0000EA           B        ??FRAMEWIN_Callback_4
   \   000000CC   BD0000EA           B        ??FRAMEWIN_Callback_4
   \   000000D0   BC0000EA           B        ??FRAMEWIN_Callback_4
   \   000000D4   BB0000EA           B        ??FRAMEWIN_Callback_4
   \   000000D8   BA0000EA           B        ??FRAMEWIN_Callback_4
   \   000000DC   450000EA           B        ??FRAMEWIN_Callback_14
   \   000000E0   B80000EA           B        ??FRAMEWIN_Callback_4
   \   000000E4   B70000EA           B        ??FRAMEWIN_Callback_4
   \   000000E8   B60000EA           B        ??FRAMEWIN_Callback_4
   \   000000EC   0B0000EA           B        ??FRAMEWIN_Callback_15
    558            case WM_PID_STATE_CHANGED:
    559              _OnPidStateChange(hObj, pMsg);
   \                     ??FRAMEWIN_Callback_9:
   \   000000F0   0C6095E5           LDR      R6,[R5, #+12]
   \   000000F4   0400A0E1           MOV      R0,R4
   \   000000F8   ........           BL       GUI_ALLOC_LockH
   \   000000FC   0910D6E5           LDRB     R1,[R6, #+9]
   \   00000100   000051E3           CMP      R1,#+0
   \   00000104   0810D605           LDRBEQ   R1,[R6, #+8]
   \   00000108   01005103           CMPEQ    R1,#+1
   \   0000010C   AC00001A           BNE      ??FRAMEWIN_Callback_16
   \   00000110   BC17D0E1           LDRH     R1,[R0, #+124]
   \   00000114   401F81E3           ORR      R1,R1,#0x100
   \   00000118   BC17C0E1           STRH     R1,[R0, #+124]
   \   0000011C   A80000EA           B        ??FRAMEWIN_Callback_16
    560              break;
    561            case WM_HANDLE_DIALOG_STATUS:
    562              pObj = (FRAMEWIN_Obj *)GUI_LOCK_H(hObj);
   \                     ??FRAMEWIN_Callback_15:
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   ........           BL       GUI_ALLOC_LockH
    563              if (pMsg->Data.p) {                           // set pointer to Dialog status
   \   00000128   0C1095E5           LDR      R1,[R5, #+12]
   \   0000012C   000051E3           CMP      R1,#+0
    564                pObj->pDialogStatus = (WM_DIALOG_STATUS *)pMsg->Data.p;
    565              } else {                                      // return pointer to Dialog status
    566                pMsg->Data.p = pObj->pDialogStatus;      
   \   00000130   84009005           LDREQ    R0,[R0, #+132]
   \   00000134   84108015           STRNE    R1,[R0, #+132]
   \   00000138   0C008505           STREQ    R0,[R5, #+12]
    567              }
    568              GUI_UNLOCK_H(pObj);
   \                     ??FRAMEWIN_Callback_17:
   \   0000013C   ........           BL       GUI_ALLOC_UnlockH
    569              return;
   \   00000140   A70000EA           B        ??FRAMEWIN_Callback_3
    570            case WM_PAINT:
    571              pfPaint(hObj);
   \                     ??FRAMEWIN_Callback_8:
   \   00000144   0400A0E1           MOV      R0,R4
   \   00000148   3AFF2FE1           BLX      R10
    572              //_Paint(hObj);
    573              break;
   \   0000014C   9D0000EA           B        ??FRAMEWIN_Callback_4
    574            case WM_TOUCH:
    575              _OnTouch(hObj, pMsg);
   \                     ??FRAMEWIN_Callback_6:
   \   00000150   0C6095E5           LDR      R6,[R5, #+12]
   \   00000154   0400A0E1           MOV      R0,R4
   \   00000158   ........           BL       GUI_ALLOC_LockH
   \   0000015C   BC77D0E1           LDRH     R7,[R0, #+124]
   \   00000160   ........           BL       GUI_ALLOC_UnlockH
   \   00000164   0C0095E5           LDR      R0,[R5, #+12]
   \   00000168   000050E3           CMP      R0,#+0
   \   0000016C   9C00000A           BEQ      ??FRAMEWIN_Callback_3
   \   00000170   0800D6E5           LDRB     R0,[R6, #+8]
   \   00000174   000050E3           CMP      R0,#+0
   \   00000178   0E00000A           BEQ      ??FRAMEWIN_Callback_18
   \   0000017C   080017E3           TST      R7,#0x8
   \   00000180   0100001A           BNE      ??FRAMEWIN_Callback_19
   \   00000184   0400A0E1           MOV      R0,R4
   \   00000188   ........           BL       WM_SetFocus
   \                     ??FRAMEWIN_Callback_19:
   \   0000018C   0400A0E1           MOV      R0,R4
   \   00000190   ........           BL       WM_BringToTop
   \   00000194   640F07E2           AND      R0,R7,#0x190
   \   00000198   440F50E3           CMP      R0,#+272
   \   0000019C   9000001A           BNE      ??FRAMEWIN_Callback_3
   \   000001A0   0030A0E3           MOV      R3,#+0
   \   000001A4   0520A0E3           MOV      R2,#+5
   \   000001A8   0610A0E1           MOV      R1,R6
   \   000001AC   0400A0E1           MOV      R0,R4
   \   000001B0   ........           BL       WM_SetCaptureMove
   \   000001B4   8A0000EA           B        ??FRAMEWIN_Callback_3
   \                     ??FRAMEWIN_Callback_18:
   \   000001B8   0400A0E1           MOV      R0,R4
   \   000001BC   ........           BL       GUI_ALLOC_LockH
   \   000001C0   BC17D0E1           LDRH     R1,[R0, #+124]
   \   000001C4   401FC1E3           BIC      R1,R1,#0x100
   \   000001C8   BC17C0E1           STRH     R1,[R0, #+124]
   \   000001CC   DAFFFFEA           B        ??FRAMEWIN_Callback_17
    576              return;                       // Return here ... Message handled
    577            case WM_GET_INSIDE_RECT:
    578              FRAMEWIN__CalcPositions(hObj, &Pos);
   \                     ??FRAMEWIN_Callback_10:
   \   000001D0   10108DE2           ADD      R1,SP,#+16
   \   000001D4   0400A0E1           MOV      R0,R4
   \   000001D8   ........           BL       FRAMEWIN__CalcPositions
    579              pRect = (GUI_RECT *)(pMsg->Data.p);
    580          		*pRect = Pos.rClient;
   \   000001DC   0C0095E5           LDR      R0,[R5, #+12]
   \   000001E0   14108DE2           ADD      R1,SP,#+20
   \   000001E4   0820A0E3           MOV      R2,#+8
   \   000001E8   ........           BL       __aeabi_memcpy
    581              return;                       // Return here ... Message handled
   \   000001EC   7C0000EA           B        ??FRAMEWIN_Callback_3
    582            case WM_GET_CLIENT_WINDOW:      // return handle to client window. For most windows, there is no seperate client window, so it is the same handle
    583              pMsg->Data.v = (int)hClient;
   \                     ??FRAMEWIN_Callback_11:
   \   000001F0   0C8085E5           STR      R8,[R5, #+12]
    584              return;                       // Return here ... Message handled
   \   000001F4   7A0000EA           B        ??FRAMEWIN_Callback_3
    585            case WM_NOTIFY_PARENT:
    586              if (pMsg->Data.v == WM_NOTIFICATION_RELEASED) {
   \                     ??FRAMEWIN_Callback_14:
   \   000001F8   0C0095E5           LDR      R0,[R5, #+12]
   \   000001FC   020050E3           CMP      R0,#+2
   \   00000200   7700001A           BNE      ??FRAMEWIN_Callback_3
    587                WM_MESSAGE Msg;
    588                Msg.hWinSrc = hObj;
   \   00000204   08408DE5           STR      R4,[SP, #+8]
    589                Msg.Data    = pMsg->Data;
   \   00000208   0C1095E5           LDR      R1,[R5, #+12]
   \   0000020C   0C108DE5           STR      R1,[SP, #+12]
    590                Msg.MsgId   = WM_NOTIFY_PARENT_REFLECTION;
   \   00000210   2710A0E3           MOV      R1,#+39
   \   00000214   00108DE5           STR      R1,[SP, #+0]
    591                WM__SendMessage(pMsg->hWinSrc, &Msg);
   \   00000218   0D10A0E1           MOV      R1,SP
   \   0000021C   080095E5           LDR      R0,[R5, #+8]
   \   00000220   ........           BL       WM__SendMessage
   \   00000224   6E0000EA           B        ??FRAMEWIN_Callback_3
    592              }
    593              return;
    594            case WM_SET_FOCUS:                 // We have received or lost focus
    595              if (pMsg->Data.v == 1) {
   \                     ??FRAMEWIN_Callback_12:
   \   00000228   0C0095E5           LDR      R0,[R5, #+12]
   \   0000022C   010050E3           CMP      R0,#+1
   \   00000230   1E00001A           BNE      ??FRAMEWIN_Callback_20
    596                if (WM_IsWindow(hFocussedChild)) {
   \   00000234   0700A0E1           MOV      R0,R7
   \   00000238   ........           BL       WM_IsWindow
   \   0000023C   000050E3           CMP      R0,#+0
   \   00000240   0200000A           BEQ      ??FRAMEWIN_Callback_21
    597                  WM_SetFocus(hFocussedChild);
   \   00000244   0700A0E1           MOV      R0,R7
   \   00000248   ........           BL       WM_SetFocus
   \   0000024C   060000EA           B        ??FRAMEWIN_Callback_22
    598                } else {
    599                  hFocussedChild = WM_SetFocusOnNextChild(hClient);
   \                     ??FRAMEWIN_Callback_21:
   \   00000250   0800A0E1           MOV      R0,R8
   \   00000254   ........           BL       WM_SetFocusOnNextChild
   \   00000258   0070A0E1           MOV      R7,R0
    600                  pObj = FRAMEWIN_LOCK_H(hObj);
    601                  pObj->hFocussedChild = hFocussedChild;
   \   0000025C   0400A0E1           MOV      R0,R4
   \   00000260   ........           BL       GUI_ALLOC_LockH
   \   00000264   807080E5           STR      R7,[R0, #+128]
    602                  GUI_UNLOCK_H(pObj);
   \   00000268   ........           BL       GUI_ALLOC_UnlockH
    603                }
    604                FRAMEWIN_SetActive(hObj, 1);
   \                     ??FRAMEWIN_Callback_22:
   \   0000026C   000054E3           CMP      R4,#+0
   \   00000270   0B00000A           BEQ      ??FRAMEWIN_Callback_23
   \   00000274   ........           BL       GUI_Lock
   \   00000278   0400A0E1           MOV      R0,R4
   \   0000027C   ........           BL       GUI_ALLOC_LockH
   \   00000280   BC17D0E1           LDRH     R1,[R0, #+124]
   \   00000284   080011E3           TST      R1,#0x8
   \   00000288   0300001A           BNE      ??FRAMEWIN_Callback_24
   \   0000028C   081081E3           ORR      R1,R1,#0x8
   \   00000290   BC17C0E1           STRH     R1,[R0, #+124]
   \   00000294   0400A0E1           MOV      R0,R4
   \   00000298   ........           BL       WM_InvalidateWindow
   \                     ??FRAMEWIN_Callback_24:
   \   0000029C   ........           BL       GUI_ALLOC_UnlockH
   \   000002A0   ........           BL       GUI_Unlock
    605                pMsg->Data.v = 0;              // Focus could be accepted
   \                     ??FRAMEWIN_Callback_23:
   \   000002A4   0000A0E3           MOV      R0,#+0
   \   000002A8   0C0085E5           STR      R0,[R5, #+12]
   \   000002AC   4C0000EA           B        ??FRAMEWIN_Callback_3
    606              } else {
    607                FRAMEWIN_SetActive(hObj, 0);
   \                     ??FRAMEWIN_Callback_20:
   \   000002B0   000054E3           CMP      R4,#+0
   \   000002B4   4A00000A           BEQ      ??FRAMEWIN_Callback_3
   \   000002B8   ........           BL       GUI_Lock
   \   000002BC   0400A0E1           MOV      R0,R4
   \   000002C0   ........           BL       GUI_ALLOC_LockH
   \   000002C4   7C10D0E5           LDRB     R1,[R0, #+124]
   \   000002C8   080011E3           TST      R1,#0x8
   \   000002CC   0400000A           BEQ      ??FRAMEWIN_Callback_25
   \   000002D0   BC17D0E1           LDRH     R1,[R0, #+124]
   \   000002D4   0810C1E3           BIC      R1,R1,#0x8
   \   000002D8   BC17C0E1           STRH     R1,[R0, #+124]
   \   000002DC   0400A0E1           MOV      R0,R4
   \   000002E0   ........           BL       WM_InvalidateWindow
   \                     ??FRAMEWIN_Callback_25:
   \   000002E4   ........           BL       GUI_ALLOC_UnlockH
   \   000002E8   ........           BL       GUI_Unlock
   \   000002EC   3C0000EA           B        ??FRAMEWIN_Callback_3
    608              }
    609              return;
    610            case WM_TOUCH_CHILD:
    611              //
    612              // If a child of this framewindow has been touched and the frame window was not active,
    613              // the framewindow will receive the focus.
    614              //
    615              if (!(Flags & FRAMEWIN_SF_ACTIVE)) {
   \                     ??FRAMEWIN_Callback_7:
   \   000002F0   080019E3           TST      R9,#0x8
   \   000002F4   3300001A           BNE      ??FRAMEWIN_Callback_4
    616                const WM_MESSAGE * pMsgOrg;
    617                const GUI_PID_STATE * pState;
    618                pMsgOrg = (const WM_MESSAGE *)pMsg->Data.p;      // The original touch message
    619                pState = (const GUI_PID_STATE *)pMsgOrg->Data.p;
   \   000002F8   0C0095E5           LDR      R0,[R5, #+12]
   \   000002FC   0C0090E5           LDR      R0,[R0, #+12]
    620                if (pState) {          // Message may not have a valid pointer (moved out) !
   \   00000300   000050E3           CMP      R0,#+0
    621                  if (pState->Pressed) {
   \   00000304   0800D015           LDRBNE   R0,[R0, #+8]
   \   00000308   00005013           CMPNE    R0,#+0
   \   0000030C   2D00000A           BEQ      ??FRAMEWIN_Callback_4
    622                    WM_SetFocus(hObj);
   \   00000310   0400A0E1           MOV      R0,R4
   \   00000314   ........           BL       WM_SetFocus
   \   00000318   2A0000EA           B        ??FRAMEWIN_Callback_4
    623                  }
    624                }
    625              }
    626              break;
    627            case WM_NOTIFY_CHILD_HAS_FOCUS:
    628              _OnChildHasFocus(hObj, pMsg);
   \                     ??FRAMEWIN_Callback_13:
   \   0000031C   0C6095E5           LDR      R6,[R5, #+12]
   \   00000320   000056E3           CMP      R6,#+0
   \   00000324   2700000A           BEQ      ??FRAMEWIN_Callback_4
   \   00000328   0410A0E1           MOV      R1,R4
   \   0000032C   040096E5           LDR      R0,[R6, #+4]
   \   00000330   ........           BL       WM__IsAncestorOrSelf
   \   00000334   000050E3           CMP      R0,#+0
   \   00000338   0400A0E1           MOV      R0,R4
   \   0000033C   0800000A           BEQ      ??FRAMEWIN_Callback_26
   \   00000340   ........           BL       GUI_ALLOC_LockH
   \   00000344   BC17D0E1           LDRH     R1,[R0, #+124]
   \   00000348   080011E3           TST      R1,#0x8
   \   0000034C   1C00001A           BNE      ??FRAMEWIN_Callback_16
   \   00000350   081081E3           ORR      R1,R1,#0x8
   \   00000354   BC17C0E1           STRH     R1,[R0, #+124]
   \   00000358   0400A0E1           MOV      R0,R4
   \   0000035C   ........           BL       WM_InvalidateWindow
   \   00000360   170000EA           B        ??FRAMEWIN_Callback_16
   \                     ??FRAMEWIN_Callback_26:
   \   00000364   ........           BL       GUI_ALLOC_LockH
   \   00000368   7C10D0E5           LDRB     R1,[R0, #+124]
   \   0000036C   080011E3           TST      R1,#0x8
   \   00000370   0400000A           BEQ      ??FRAMEWIN_Callback_27
   \   00000374   BC17D0E1           LDRH     R1,[R0, #+124]
   \   00000378   0810C1E3           BIC      R1,R1,#0x8
   \   0000037C   BC17C0E1           STRH     R1,[R0, #+124]
   \   00000380   0400A0E1           MOV      R0,R4
   \   00000384   ........           BL       WM_InvalidateWindow
   \                     ??FRAMEWIN_Callback_27:
   \   00000388   ........           BL       GUI_ALLOC_UnlockH
   \   0000038C   0410A0E1           MOV      R1,R4
   \   00000390   000096E5           LDR      R0,[R6, #+0]
   \   00000394   ........           BL       WM__IsAncestor
   \   00000398   000050E3           CMP      R0,#+0
   \   0000039C   0900000A           BEQ      ??FRAMEWIN_Callback_4
   \   000003A0   0400A0E1           MOV      R0,R4
   \   000003A4   ........           BL       GUI_ALLOC_LockH
   \   000003A8   001096E5           LDR      R1,[R6, #+0]
   \   000003AC   801080E5           STR      R1,[R0, #+128]
   \   000003B0   030000EA           B        ??FRAMEWIN_Callback_16
    629              break;
    630            case WM_DELETE:
    631              GUI_DEBUG_LOG("FRAMEWIN: FRAMEWIN_Callback(WM_DELETE)\n");
    632              pObj = FRAMEWIN_LOCK_H(hObj);
   \                     ??FRAMEWIN_Callback_5:
   \   000003B4   0400A0E1           MOV      R0,R4
   \   000003B8   ........           BL       GUI_ALLOC_LockH
    633              GUI_ALLOC_FreePtr(&pObj->hText);
   \   000003BC   700080E2           ADD      R0,R0,#+112
   \   000003C0   ........           BL       GUI_ALLOC_FreePtr
    634              GUI_UNLOCK_H(pObj);
   \                     ??FRAMEWIN_Callback_16:
   \   000003C4   ........           BL       GUI_ALLOC_UnlockH
    635              break;
    636            }
    637            //
    638            // Let widget handle the standard messages
    639            //
    640            if (WIDGET_HandleActive(hObj, pMsg) == 0) {
   \                     ??FRAMEWIN_Callback_4:
   \   000003C8   0510A0E1           MOV      R1,R5
   \   000003CC   0400A0E1           MOV      R0,R4
   \   000003D0   ........           BL       WIDGET_HandleActive
   \   000003D4   000050E3           CMP      R0,#+0
   \   000003D8   0100000A           BEQ      ??FRAMEWIN_Callback_3
    641              return;
    642            }
    643            WM_DefaultProc(pMsg);
   \   000003DC   0500A0E1           MOV      R0,R5
   \   000003E0   ........           BL       WM_DefaultProc
    644          }
   \                     ??FRAMEWIN_Callback_3:
   \   000003E4   28D08DE2           ADD      SP,SP,#+40       ;; stack cleaning
   \   000003E8   F087BDE8           POP      {R4-R10,PC}      ;; return
    645          
    646          /*********************************************************************
    647          *
    648          *       Exported API routines:  Create
    649          *
    650          **********************************************************************
    651          */
    652          /*********************************************************************
    653          *
    654          *       FRAMEWIN_CreateEx
    655          */

   \                                 In section .text, align 4, keep-with-next
    656          FRAMEWIN_Handle FRAMEWIN_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
    657                                            int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK* cb)
    658          {
   \                     FRAMEWIN_CreateEx:
   \   00000000   F34F2DE9           PUSH     {R0,R1,R4-R11,LR}
   \   00000004   24D04DE2           SUB      SP,SP,#+36
   \   00000008   0290A0E1           MOV      R9,R2
   \   0000000C   03A0A0E1           MOV      R10,R3
   \   00000010   50B09DE5           LDR      R11,[SP, #+80]
   \   00000014   54509DE5           LDR      R5,[SP, #+84]
   \   00000018   58609DE5           LDR      R6,[SP, #+88]
   \   0000001C   5C709DE5           LDR      R7,[SP, #+92]
   \   00000020   60409DE5           LDR      R4,[SP, #+96]
   \   00000024   64809DE5           LDR      R8,[SP, #+100]
    659            FRAMEWIN_Handle hObj;
    660            FRAMEWIN_Obj * pObj;
    661            FRAMEWIN_POSITIONS Pos;
    662            WM_HWIN hClient;
    663          
    664            //
    665            // Create the window
    666            //
    667            GUI_LOCK();
   \   00000028   ........           BL       GUI_Lock
    668            WinFlags |= WM_CF_LATE_CLIP;    // Always use late clipping since widget is optimized for it.
    669            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, FRAMEWIN_Callback,
    670                                          sizeof(FRAMEWIN_Obj) - sizeof(WM_Obj));
   \   0000002C   6000A0E3           MOV      R0,#+96
   \   00000030   0C008DE5           STR      R0,[SP, #+12]
   \   00000034   ........           LDR      R0,??DataTable0
   \   00000038   405D85E3           ORR      R5,R5,#0x1000
   \   0000003C   08008DE5           STR      R0,[SP, #+8]
   \   00000040   04508DE5           STR      R5,[SP, #+4]
   \   00000044   00B08DE5           STR      R11,[SP, #+0]
   \   00000048   0A30A0E1           MOV      R3,R10
   \   0000004C   0920A0E1           MOV      R2,R9
   \   00000050   28109DE5           LDR      R1,[SP, #+40]
   \   00000054   24009DE5           LDR      R0,[SP, #+36]
   \   00000058   ........           BL       WM_CreateWindowAsChild
   \   0000005C   0090B0E1           MOVS     R9,R0
    671            if (hObj) {
   \   00000060   4A00000A           BEQ      ??FRAMEWIN_CreateEx_0
    672              pObj = (FRAMEWIN_Obj *)GUI_LOCK_H(hObj); // Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point
   \   00000064   ........           BL       GUI_ALLOC_LockH
   \   00000068   00A0A0E1           MOV      R10,R0
    673              //
    674              // Init widget specific variables
    675              //
    676              WIDGET__Init(&pObj->Widget, Id, WIDGET_STATE_FOCUSSABLE | FRAMEWIN_SF_TITLEVIS);
   \   0000006C   3020A0E3           MOV      R2,#+48
   \   00000070   0710A0E1           MOV      R1,R7
   \   00000074   ........           BL       WIDGET__Init
    677              //
    678              // Init member variables
    679              //
    680              FRAMEWIN_INIT_ID(pObj);
    681              pObj->Props = FRAMEWIN__DefaultProps;
   \   00000078   ........           LDR      R7,??DataTable0_1
   \   0000007C   34008AE2           ADD      R0,R10,#+52
   \   00000080   0E50B7E8           LDM      R7!,{R1-R3,R12,LR}
   \   00000084   0E50A0E8           STM      R0!,{R1-R3,R12,LR}
   \   00000088   0E50B7E8           LDM      R7!,{R1-R3,R12,LR}
   \   0000008C   287047E2           SUB      R7,R7,#+40
   \   00000090   0E50A0E8           STM      R0!,{R1-R3,R12,LR}
    682              pObj->cb             = cb;
   \   00000094   64808AE5           STR      R8,[R10, #+100]
    683              pObj->Flags          = ExFlags;
   \   00000098   BC67CAE1           STRH     R6,[R10, #+124]
    684              pObj->hFocussedChild = 0;
   \   0000009C   0000A0E3           MOV      R0,#+0
   \   000000A0   80008AE5           STR      R0,[R10, #+128]
    685              pObj->hMenu          = 0;
   \   000000A4   6C008AE5           STR      R0,[R10, #+108]
    686              pObj->pFirstHook     = NULL;
   \   000000A8   88008AE5           STR      R0,[R10, #+136]
    687              pObj->pWidgetSkin = FRAMEWIN__pSkinDefault;
   \   000000AC   280097E5           LDR      R0,[R7, #+40]
   \   000000B0   5C008AE5           STR      R0,[R10, #+92]
    688              GUI_UNLOCK_H(pObj);
   \   000000B4   ........           BL       GUI_ALLOC_UnlockH
    689              FRAMEWIN__CalcPositions(hObj, &Pos);
   \   000000B8   10108DE2           ADD      R1,SP,#+16
   \   000000BC   0900A0E1           MOV      R0,R9
   \   000000C0   ........           BL       FRAMEWIN__CalcPositions
    690              hClient = WM_CreateWindowAsChild(Pos.rClient.x0,Pos.rClient.y0,
    691                                               Pos.rClient.x1 - Pos.rClient.x0 +1,
    692                                               Pos.rClient.y1 - Pos.rClient.y0 +1,
    693                                               hObj, 
    694                                               WM_CF_ANCHOR_RIGHT | WM_CF_ANCHOR_LEFT | WM_CF_ANCHOR_TOP | WM_CF_ANCHOR_BOTTOM | WM_CF_SHOW | WM_CF_LATE_CLIP, 
    695                                               FRAMEWIN__cbClient, 0);
   \   000000C4   0020A0E3           MOV      R2,#+0
   \   000000C8   0C208DE5           STR      R2,[SP, #+12]
   \   000000CC   ........           LDR      R2,??DataTable0_2
   \   000000D0   F611DDE1           LDRSH    R1,[SP, #+22]
   \   000000D4   08208DE5           STR      R2,[SP, #+8]
   \   000000D8   8220A0E3           MOV      R2,#+130
   \   000000DC   5C2D82E3           ORR      R2,R2,#0x1700
   \   000000E0   04208DE5           STR      R2,[SP, #+4]
   \   000000E4   FA21DDE1           LDRSH    R2,[SP, #+26]
   \   000000E8   F401DDE1           LDRSH    R0,[SP, #+20]
   \   000000EC   00908DE5           STR      R9,[SP, #+0]
   \   000000F0   012042E0           SUB      R2,R2,R1
   \   000000F4   013082E2           ADD      R3,R2,#+1
   \   000000F8   F821DDE1           LDRSH    R2,[SP, #+24]
   \   000000FC   002042E0           SUB      R2,R2,R0
   \   00000100   012082E2           ADD      R2,R2,#+1
   \   00000104   ........           BL       WM_CreateWindowAsChild
    696              FRAMEWIN__pSkinDefault->pfCreate(hObj);
   \   00000108   281097E5           LDR      R1,[R7, #+40]
   \   0000010C   0060A0E1           MOV      R6,R0
   \   00000110   0900A0E1           MOV      R0,R9
   \   00000114   041091E5           LDR      R1,[R1, #+4]
   \   00000118   31FF2FE1           BLX      R1
    697              pObj = FRAMEWIN_LOCK_H(hObj);
    698              pObj->hClient = hClient;
   \   0000011C   0900A0E1           MOV      R0,R9
   \   00000120   ........           BL       GUI_ALLOC_LockH
   \   00000124   686080E5           STR      R6,[R0, #+104]
    699              GUI_UNLOCK_H(pObj);
   \   00000128   ........           BL       GUI_ALLOC_UnlockH
    700              //
    701              // Normally we disable memory devices for the frame window:
    702              // The frame window does not flicker, and not using memory devices is usually faster.
    703              // You can still use memory by explicitly specifying the flag
    704              //
    705              if ((WinFlags & (WM_CF_MEMDEV | (WM_CF_MEMDEV_ON_REDRAW))) == 0) {
   \   0000012C   0400A0E3           MOV      R0,#+4
   \   00000130   800D80E3           ORR      R0,R0,#0x2000
   \   00000134   050010E1           TST      R0,R5
   \   00000138   0100001A           BNE      ??FRAMEWIN_CreateEx_1
    706                WM_DisableMemdev(hObj);
   \   0000013C   0900A0E1           MOV      R0,R9
   \   00000140   ........           BL       WM_DisableMemdev
   \                     ??FRAMEWIN_CreateEx_1:
   \   00000144   ........           BL       GUI_Lock
   \   00000148   0900A0E1           MOV      R0,R9
   \   0000014C   ........           BL       GUI_ALLOC_LockH
   \   00000150   700090E5           LDR      R0,[R0, #+112]
   \   00000154   00008DE5           STR      R0,[SP, #+0]
   \   00000158   ........           BL       GUI_ALLOC_UnlockH
   \   0000015C   0410A0E1           MOV      R1,R4
   \   00000160   0D00A0E1           MOV      R0,SP
   \   00000164   ........           BL       GUI__SetText
   \   00000168   000050E3           CMP      R0,#+0
   \   0000016C   0600000A           BEQ      ??FRAMEWIN_CreateEx_2
   \   00000170   0900A0E1           MOV      R0,R9
   \   00000174   ........           BL       GUI_ALLOC_LockH
   \   00000178   00109DE5           LDR      R1,[SP, #+0]
   \   0000017C   701080E5           STR      R1,[R0, #+112]
   \   00000180   ........           BL       GUI_ALLOC_UnlockH
   \   00000184   0900A0E1           MOV      R0,R9
   \   00000188   ........           BL       WM_InvalidateWindow
   \                     ??FRAMEWIN_CreateEx_2:
   \   0000018C   ........           BL       GUI_Unlock
    707              }
    708              FRAMEWIN_SetText(hObj, pTitle);
    709            }
    710            GUI_UNLOCK();
   \                     ??FRAMEWIN_CreateEx_0:
   \   00000190   ........           BL       GUI_Unlock
    711            return hObj;
   \   00000194   0900A0E1           MOV      R0,R9
   \   00000198   2CD08DE2           ADD      SP,SP,#+44
   \   0000019C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    712          }
    713          
    714          /*********************************************************************
    715          *
    716          *       Exported routines:  Set Properties
    717          *
    718          **********************************************************************
    719          */
    720          /*********************************************************************
    721          *
    722          *       FRAMEWIN_SetText
    723          */

   \                                 In section .text, align 4, keep-with-next
    724          void FRAMEWIN_SetText(FRAMEWIN_Handle hObj, const char * s) {
   \                     FRAMEWIN_SetText:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
    725            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   1200000A           BEQ      ??FRAMEWIN_SetText_0
    726              FRAMEWIN_Obj * pObj;
    727              WM_HWIN hText;
    728              GUI_LOCK();
   \   00000018   ........           BL       GUI_Lock
    729              pObj = FRAMEWIN_LOCK_H(hObj);
    730              hText = pObj->hText;
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
   \   00000024   700090E5           LDR      R0,[R0, #+112]
   \   00000028   00008DE5           STR      R0,[SP, #+0]
    731              GUI_UNLOCK_H(pObj);
   \   0000002C   ........           BL       GUI_ALLOC_UnlockH
    732              if (GUI__SetText(&hText, s)) {
   \   00000030   0510A0E1           MOV      R1,R5
   \   00000034   0D00A0E1           MOV      R0,SP
   \   00000038   ........           BL       GUI__SetText
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0600000A           BEQ      ??FRAMEWIN_SetText_1
    733                pObj = FRAMEWIN_LOCK_H(hObj);
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       GUI_ALLOC_LockH
    734                pObj->hText = hText;
   \   0000004C   00109DE5           LDR      R1,[SP, #+0]
   \   00000050   701080E5           STR      R1,[R0, #+112]
    735                GUI_UNLOCK_H(pObj);
   \   00000054   ........           BL       GUI_ALLOC_UnlockH
    736                FRAMEWIN_Invalidate(hObj);
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           BL       WM_InvalidateWindow
    737              }
    738              GUI_UNLOCK();
   \                     ??FRAMEWIN_SetText_1:
   \   00000060   ........           BL       GUI_Unlock
    739            }
    740          }
   \                     ??FRAMEWIN_SetText_0:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
    741          
    742          /*********************************************************************
    743          *
    744          *       FRAMEWIN_SetTextAlign
    745          */

   \                                 In section .text, align 4, keep-with-next
    746          void FRAMEWIN_SetTextAlign(FRAMEWIN_Handle hObj, int Align) {
   \                     FRAMEWIN_SetTextAlign:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
    747            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0A00000A           BEQ      ??FRAMEWIN_SetTextAlign_0
    748              FRAMEWIN_Obj * pObj;
    749              GUI_LOCK();
   \   00000018   ........           BL       GUI_Lock
    750              pObj = FRAMEWIN_LOCK_H(hObj);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
    751              if (pObj->Props.TextAlign != Align) {
   \   00000024   FA15D0E1           LDRSH    R1,[R0, #+90]
   \   00000028   050051E1           CMP      R1,R5
   \   0000002C   0200000A           BEQ      ??FRAMEWIN_SetTextAlign_1
    752                pObj->Props.TextAlign = Align;
   \   00000030   BA55C0E1           STRH     R5,[R0, #+90]
    753                FRAMEWIN_Invalidate(hObj);
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       WM_InvalidateWindow
    754              }
    755              GUI_UNLOCK_H(pObj);
   \                     ??FRAMEWIN_SetTextAlign_1:
   \   0000003C   ........           BL       GUI_ALLOC_UnlockH
    756              GUI_UNLOCK();
   \   00000040   ........           BL       GUI_Unlock
    757            }
    758          }
   \                     ??FRAMEWIN_SetTextAlign_0:
   \   00000044   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000048   3080BDE8           POP      {R4,R5,PC}       ;; return
    759          
    760          /*********************************************************************
    761          *
    762          *       FRAMEWIN_SetMoveable
    763          */

   \                                 In section .text, align 4, keep-with-next
    764          void FRAMEWIN_SetMoveable(FRAMEWIN_Handle hObj, int State) {
   \                     FRAMEWIN_SetMoveable:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
    765            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0B00000A           BEQ      ??FRAMEWIN_SetMoveable_0
    766              FRAMEWIN_Obj * pObj;
    767              GUI_LOCK();
   \   00000018   ........           BL       GUI_Lock
    768              pObj = FRAMEWIN_LOCK_H(hObj);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
    769              if (State) {
   \   00000024   BC17D0E1           LDRH     R1,[R0, #+124]
   \   00000028   000055E3           CMP      R5,#+0
    770                pObj->Flags |= FRAMEWIN_CF_MOVEABLE;
    771              } else {
    772                pObj->Flags &= ~FRAMEWIN_CF_MOVEABLE;
   \   0000002C   EF20A003           MOVEQ    R2,#+239
   \   00000030   FF2C8203           ORREQ    R2,R2,#0xFF00
   \   00000034   10108113           ORRNE    R1,R1,#0x10
   \   00000038   01100200           ANDEQ    R1,R2,R1
   \   0000003C   BC17C0E1           STRH     R1,[R0, #+124]
    773              }
    774              GUI_UNLOCK_H(pObj);
   \   00000040   ........           BL       GUI_ALLOC_UnlockH
    775              GUI_UNLOCK();
   \   00000044   ........           BL       GUI_Unlock
    776            }
    777          }
   \                     ??FRAMEWIN_SetMoveable_0:
   \   00000048   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000004C   3080BDE8           POP      {R4,R5,PC}       ;; return
    778          
    779          /*********************************************************************
    780          *
    781          *       FRAMEWIN_SetActive
    782          */

   \                                 In section .text, align 4, keep-with-next
    783          void FRAMEWIN_SetActive(FRAMEWIN_Handle hObj, int State) {
   \                     FRAMEWIN_SetActive:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
    784            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   1200000A           BEQ      ??FRAMEWIN_SetActive_0
    785              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
    786              _SetActive(hObj, State);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
   \   00000024   BC17D0E1           LDRH     R1,[R0, #+124]
   \   00000028   000055E3           CMP      R5,#+0
   \   0000002C   082001E2           AND      R2,R1,#0x8
   \   00000030   0300000A           BEQ      ??FRAMEWIN_SetActive_1
   \   00000034   000052E3           CMP      R2,#+0
   \   00000038   0700001A           BNE      ??FRAMEWIN_SetActive_2
   \   0000003C   081081E3           ORR      R1,R1,#0x8
   \   00000040   020000EA           B        ??FRAMEWIN_SetActive_3
   \                     ??FRAMEWIN_SetActive_1:
   \   00000044   000052E3           CMP      R2,#+0
   \   00000048   0300000A           BEQ      ??FRAMEWIN_SetActive_2
   \   0000004C   0810C1E3           BIC      R1,R1,#0x8
   \                     ??FRAMEWIN_SetActive_3:
   \   00000050   BC17C0E1           STRH     R1,[R0, #+124]
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       WM_InvalidateWindow
   \                     ??FRAMEWIN_SetActive_2:
   \   0000005C   ........           BL       GUI_ALLOC_UnlockH
    787              WM_UNLOCK();
   \   00000060   ........           BL       GUI_Unlock
    788            }
    789          }
   \                     ??FRAMEWIN_SetActive_0:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   ........           DC32     FRAMEWIN_Callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   ........           DC32     FRAMEWIN__DefaultProps

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   ........           DC32     FRAMEWIN__cbClient
    790          
    791          #else
    792            void WIDGET_FrameWin(void) {} /* Avoid empty object files */
    793          #endif /* GUI_WINSUPPORT */

   Maximum stack usage in bytes:

     Function                  .cstack
     --------                  -------
     FRAMEWIN_Callback             72
     FRAMEWIN_CreateEx             80
     FRAMEWIN_SetActive            16
     FRAMEWIN_SetMoveable          16
     FRAMEWIN_SetText              16
     FRAMEWIN_SetTextAlign         16
     FRAMEWIN__CalcPositions       56
     FRAMEWIN__CalcTitleHeight      8
     FRAMEWIN__GetBorderSize       48
     FRAMEWIN__GetTitleLimits      32
     FRAMEWIN__UpdatePositions     40
     FRAMEWIN__cbClient            48


   Section sizes:

     Function/Label            Bytes
     --------------            -----
     FRAMEWIN__DefaultProps      44
     FRAMEWIN__pSkinDefault
     FRAMEWIN__MinVisibility      2
     FRAMEWIN__cbClient         436
     FRAMEWIN__GetBorderSize    116
     FRAMEWIN__CalcTitleHeight   60
     FRAMEWIN__GetTitleLimits   200
     FRAMEWIN__CalcPositions    500
     FRAMEWIN__UpdatePositions  152
     FRAMEWIN_Callback         1004
     FRAMEWIN_CreateEx          416
     FRAMEWIN_SetText           108
     FRAMEWIN_SetTextAlign       76
     FRAMEWIN_SetMoveable        80
     FRAMEWIN_SetActive         108
     ??DataTable0                 4
     ??DataTable0_1               4
     ??DataTable0_2               4

 
    46 bytes in section .data
 3 268 bytes in section .text
 
 3 268 bytes of CODE memory
    46 bytes of DATA memory

Errors: none
Warnings: none
