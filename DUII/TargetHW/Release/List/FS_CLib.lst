###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:12:14 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\FS\FS_CLib.c                            #
#    Command line =  C:\DUII\TargetHW\FS\FS_CLib.c -D DEBUG=1 -D              #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\FS_CLib.lst                #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\FS_CLib.o                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\FS\FS_CLib.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          **** emFile file system for embedded applications ****
     13          emFile is protected by international copyright laws. Knowledge of the
     14          source code may not be used to write a similar product. This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : FS_CLib.c
     19          Purpose     : File system's standard c-lib replacement routines
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          /*********************************************************************
     24          *
     25          *       #include Section
     26          *
     27          **********************************************************************
     28          */
     29          
     30          #include "FS_Int.h"
     31          
     32          
     33          /*********************************************************************
     34          *
     35          *       Public code
     36          *
     37          **********************************************************************
     38          */
     39          
     40          /*********************************************************************
     41          *
     42          *       FS__CLIB_atoi
     43          *
     44          *  Function description:
     45          *    Convert string to int. The function stops with
     46          *    the first character it cannot convert. It expects decimal numbers only.
     47          *    It can handle +/- at the beginning and leading 0. It cannot handle
     48          *    HEX or any other numbers.
     49          *
     50          *  Parameters:
     51          *    s           - Pointer to a zero terminated string.
     52          * 
     53          *  Return value:
     54          *    ==0         - In case of any problem or if the converted value is zero.
     55          *    !=0         - Integer value of the converted string.
     56          */

   \                                 In section .text, align 4, keep-with-next
     57          int FS__CLIB_atoi(const char *s) {
   \                     FS__CLIB_atoi:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
     58            unsigned int base;
     59            const char   *t;
     60            signed char  sign;
     61            char         c;
     62            int          value;
     63            int          len;
     64            int          i;
     65          
     66            value = 0;
     67            //
     68            // Check for +/-
     69            //
     70            sign = 1;
     71            len = FS__CLIB_strlen(s);
   \   00000004   00E0A0E1           MOV      LR,R0
   \   00000008   0050DEE5           LDRB     R5,[LR, #+0]
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   0130A0E3           MOV      R3,#+1
   \   00000014   0120A0E3           MOV      R2,#+1
   \   00000018   00C0A0E3           MOV      R12,#+0
   \   0000001C   0040A0E3           MOV      R4,#+0
   \   00000020   000055E3           CMP      R5,#+0
   \   00000024   0500000A           BEQ      ??FS__CLIB_atoi_0
   \                     ??FS__CLIB_atoi_1:
   \   00000028   0150FEE5           LDRB     R5,[LR, #+1]!
   \   0000002C   014084E2           ADD      R4,R4,#+1
   \   00000030   000055E3           CMP      R5,#+0
   \   00000034   FBFFFF1A           BNE      ??FS__CLIB_atoi_1
     72            if (len <= 0) {
   \   00000038   010054E3           CMP      R4,#+1
   \   0000003C   010000AA           BGE      ??FS__CLIB_atoi_2
     73              return 0;
   \                     ??FS__CLIB_atoi_0:
   \   00000040   0000A0E3           MOV      R0,#+0
   \   00000044   3080BDE8           POP      {R4,R5,PC}
     74            }
     75            t = s;
     76            if (*t == '-') {
   \                     ??FS__CLIB_atoi_2:
   \   00000048   00E0D0E5           LDRB     LR,[R0, #+0]
   \   0000004C   2D005EE3           CMP      LR,#+45
     77              t++;
   \   00000050   01008002           ADDEQ    R0,R0,#+1
     78              sign = -1;
   \   00000054   0120E001           MVNEQ    R2,R1
   \   00000058   0100000A           BEQ      ??FS__CLIB_atoi_3
     79            }
     80            else if (*t == '+') {
   \   0000005C   2B005EE3           CMP      LR,#+43
     81              t++;
   \   00000060   01008002           ADDEQ    R0,R0,#+1
     82            }
     83            //
     84            // Skip leading 0
     85            //
     86            len = FS__CLIB_strlen(t);
   \                     ??FS__CLIB_atoi_3:
   \   00000064   00E0A0E1           MOV      LR,R0
   \   00000068   0040DEE5           LDRB     R4,[LR, #+0]
   \   0000006C   000054E3           CMP      R4,#+0
   \   00000070   0300000A           BEQ      ??FS__CLIB_atoi_4
   \                     ??FS__CLIB_atoi_5:
   \   00000074   0140FEE5           LDRB     R4,[LR, #+1]!
   \   00000078   01C08CE2           ADD      R12,R12,#+1
   \   0000007C   000054E3           CMP      R4,#+0
   \   00000080   FBFFFF1A           BNE      ??FS__CLIB_atoi_5
     87            if (len <= 0) {
   \                     ??FS__CLIB_atoi_4:
   \   00000084   01005CE3           CMP      R12,#+1
   \   00000088   ECFFFFBA           BLT      ??FS__CLIB_atoi_0
     88              return 0;
     89            }
     90            while (*t == '0') {
   \                     ??FS__CLIB_atoi_6:
   \   0000008C   00E0D0E5           LDRB     LR,[R0, #+0]
   \   00000090   30005EE3           CMP      LR,#+48
   \   00000094   0300001A           BNE      ??FS__CLIB_atoi_7
     91              t++;
     92              len--;
   \   00000098   01C04CE2           SUB      R12,R12,#+1
   \   0000009C   010080E2           ADD      R0,R0,#+1
     93              if (len <= 0) {
   \   000000A0   01005CE3           CMP      R12,#+1
   \   000000A4   F8FFFFAA           BGE      ??FS__CLIB_atoi_6
     94                break;
     95              }
     96            }
     97            //
     98            // Find end of number
     99            //
    100            for (i = 0; i < len; i++) {
   \                     ??FS__CLIB_atoi_7:
   \   000000A8   00E0A0E3           MOV      LR,#+0
   \   000000AC   0040A0E1           MOV      R4,R0
   \   000000B0   000000EA           B        ??FS__CLIB_atoi_8
   \                     ??FS__CLIB_atoi_9:
   \   000000B4   01E08EE2           ADD      LR,LR,#+1
   \                     ??FS__CLIB_atoi_8:
   \   000000B8   0C005EE1           CMP      LR,R12
   \   000000BC   050000AA           BGE      ??FS__CLIB_atoi_10
    101              if (t[i] > '9') {
   \   000000C0   0050D4E5           LDRB     R5,[R4, #+0]
   \   000000C4   3A0055E3           CMP      R5,#+58
   \   000000C8   0200002A           BCS      ??FS__CLIB_atoi_10
    102                break;
    103              }
    104              if (t[i] < '0') {
   \   000000CC   0150D4E4           LDRB     R5,[R4], #+1
   \   000000D0   300055E3           CMP      R5,#+48
   \   000000D4   F6FFFF2A           BCS      ??FS__CLIB_atoi_9
    105                break;
    106              }
    107            }
    108            len = i;
    109            if (len <= 0) {
   \                     ??FS__CLIB_atoi_10:
   \   000000D8   01005EE3           CMP      LR,#+1
   \   000000DC   D7FFFFBA           BLT      ??FS__CLIB_atoi_0
    110                return 0;
    111            }
    112            //
    113            // Calculate base
    114            //
    115            base = 1;
    116            for (i = 1; i < len; i++) {
   \   000000E0   02005EE3           CMP      LR,#+2
   \   000000E4   080000BA           BLT      ??FS__CLIB_atoi_11
   \   000000E8   01C04EE2           SUB      R12,LR,#+1
   \   000000EC   01001CE3           TST      R12,#0x1
    117              base *= 10;
   \   000000F0   0A30A013           MOVNE    R3,#+10
   \   000000F4   ACC0B0E1           LSRS     R12,R12,#+1
   \   000000F8   6440A0E3           MOV      R4,#+100
   \   000000FC   0200000A           BEQ      ??FS__CLIB_atoi_11
   \                     ??FS__CLIB_atoi_12:
   \   00000100   940303E0           MUL      R3,R4,R3
    118            }
   \   00000104   01C05CE2           SUBS     R12,R12,#+1
   \   00000108   FCFFFF1A           BNE      ??FS__CLIB_atoi_12
   \                     ??FS__CLIB_atoi_11:
   \   0000010C   01C04EE2           SUB      R12,LR,#+1
   \   00000110   0140D0E4           LDRB     R4,[R0], #+1
   \   00000114   01001CE3           TST      R12,#0x1
   \   00000118   0A00000A           BEQ      ??FS__CLIB_atoi_13
    119            //
    120            // Get value
    121            //
    122            for (i = 0; i < len; i++) {
    123              c = t[i];
    124              if (c > '9') {
   \   0000011C   3A0054E3           CMP      R4,#+58
   \   00000120   280000AA           BGE      ??FS__CLIB_atoi_14
    125                break;
    126              }
    127              if (c < '0') {
   \   00000124   300054E3           CMP      R4,#+48
   \   00000128   260000BA           BLT      ??FS__CLIB_atoi_14
    128                break;
    129              }
    130              c -= '0';
    131              value += c*base;
   \   0000012C   301044E2           SUB      R1,R4,#+48
    132              base /= 10;
   \   00000130   ........           LDR      R4,??DataTable1  ;; 0xcccccccd
   \   00000134   FF1001E2           AND      R1,R1,#0xFF
   \   00000138   93448EE0           UMULL    R4,LR,R3,R4
   \   0000013C   930101E0           MUL      R1,R3,R1
   \   00000140   AE31A0E1           LSR      R3,LR,#+3
   \   00000144   0140D0E4           LDRB     R4,[R0], #+1
   \                     ??FS__CLIB_atoi_13:
   \   00000148   ACC0B0E1           LSRS     R12,R12,#+1
   \   0000014C   1700000A           BEQ      ??FS__CLIB_atoi_15
   \                     ??FS__CLIB_atoi_16:
   \   00000150   3A0054E3           CMP      R4,#+58
   \   00000154   1B0000AA           BGE      ??FS__CLIB_atoi_14
   \   00000158   300054E3           CMP      R4,#+48
   \   0000015C   190000BA           BLT      ??FS__CLIB_atoi_14
   \   00000160   30E044E2           SUB      LR,R4,#+48
   \   00000164   FFE00EE2           AND      LR,LR,#0xFF
   \   00000168   931E21E0           MLA      R1,R3,LR,R1
   \   0000016C   ........           LDR      R4,??DataTable1  ;; 0xcccccccd
   \   00000170   93448EE0           UMULL    R4,LR,R3,R4
   \   00000174   0140D0E4           LDRB     R4,[R0], #+1
   \   00000178   AE31A0E1           LSR      R3,LR,#+3
   \   0000017C   3A0054E3           CMP      R4,#+58
   \   00000180   100000AA           BGE      ??FS__CLIB_atoi_14
   \   00000184   300054E3           CMP      R4,#+48
   \   00000188   0E0000BA           BLT      ??FS__CLIB_atoi_14
   \   0000018C   30E044E2           SUB      LR,R4,#+48
   \   00000190   FFE00EE2           AND      LR,LR,#0xFF
   \   00000194   931E21E0           MLA      R1,R3,LR,R1
   \   00000198   ........           LDR      R4,??DataTable1  ;; 0xcccccccd
   \   0000019C   01C05CE2           SUBS     R12,R12,#+1
   \   000001A0   93448EE0           UMULL    R4,LR,R3,R4
   \   000001A4   0140D0E4           LDRB     R4,[R0], #+1
   \   000001A8   AE31A0E1           LSR      R3,LR,#+3
   \   000001AC   E7FFFF1A           BNE      ??FS__CLIB_atoi_16
   \                     ??FS__CLIB_atoi_15:
   \   000001B0   3A0054E3           CMP      R4,#+58
   \   000001B4   030000AA           BGE      ??FS__CLIB_atoi_14
   \   000001B8   300054E3           CMP      R4,#+48
   \   000001BC   300044A2           SUBGE    R0,R4,#+48
   \   000001C0   FF0000A2           ANDGE    R0,R0,#0xFF
   \   000001C4   931021A0           MLAGE    R1,R3,R0,R1
    133            }
    134            return sign * value;
   \                     ??FS__CLIB_atoi_14:
   \   000001C8   910200E0           MUL      R0,R1,R2
   \   000001CC   3080BDE8           POP      {R4,R5,PC}       ;; return
    135          }
    136          
    137          /*********************************************************************
    138          *
    139          *       FS__CLIB_memcmp
    140          *
    141          *  Function description:
    142          *    Compare bytes in two buffers
    143          *
    144          *  Parameters:
    145          *    s1          - Pointer to first buffer.
    146          *    s2          - Pointer to second buffer.
    147          *    NumBytes    - Number of bytes to compare
    148          * 
    149          *  Return value:
    150          *    0           - bytes are equal
    151          *    1           - bytes are different
    152          */
    153          

   \                                 In section .text, align 4, keep-with-next
    154          int FS__CLIB_memcmp(const void *s1, const void *s2, unsigned NumBytes) {	
    155            const U8 * p1;
    156            const U8 * p2;
    157          
    158            p1 = (const U8*) s1;
    159            p2 = (const U8*) s2;
    160          
    161            while (NumBytes--) {
   \                     FS__CLIB_memcmp:
   \                     ??FS__CLIB_memcmp_0:
   \   00000000   000052E3           CMP      R2,#+0
   \   00000004   0600000A           BEQ      ??FS__CLIB_memcmp_1
    162              if (*p1++ != *p2++) {
   \   00000008   0130D0E4           LDRB     R3,[R0], #+1
   \   0000000C   01C0D1E4           LDRB     R12,[R1], #+1
   \   00000010   012042E2           SUB      R2,R2,#+1
   \   00000014   0C0053E1           CMP      R3,R12
   \   00000018   F8FFFF0A           BEQ      ??FS__CLIB_memcmp_0
    163                return 1;             // Not equal
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   1EFF2FE1           BX       LR
    164              }
    165            }
    166            return 0;                 // Equal
   \                     ??FS__CLIB_memcmp_1:
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   1EFF2FE1           BX       LR               ;; return
    167          }
    168          
    169          /*********************************************************************
    170          *
    171          *       FS__CLIB_memset
    172          *
    173          *  Function description:
    174          *    FS internal function. Copy the value of c (converted to an unsigned
    175          *    char) into each of the first n characters of the object pointed to 
    176          *    by s.
    177          *
    178          *  Parameters:
    179          *    s           - Pointer to an object.
    180          *    c           - 'Character' value to be set.
    181          *    n           - Number of characters to be set.
    182          * 
    183          *  Return value:
    184          *    Value of s.
    185          */

   \                                 In section .text, align 4, keep-with-next
    186          void * FS__CLIB_memset(void *pData, int Fill, U32 NumBytes) {
   \                     FS__CLIB_memset:
   \   00000000   10402DE9           PUSH     {R4,LR}
    187            U8 * p;
    188            int  NumInts;
    189          
    190            p = (U8 *)pData;
   \   00000004   0030A0E1           MOV      R3,R0
   \   00000008   010000EA           B        ??FS__CLIB_memset_0
    191            //
    192            // Write bytes until we are done or have reached an int boundary
    193            //
    194            while (NumBytes && ((sizeof(int) - 1) & (U32)p)) {
    195              *p++ = (U8)Fill;
   \                     ??FS__CLIB_memset_1:
   \   0000000C   0110C3E4           STRB     R1,[R3], #+1
    196              NumBytes--;
   \   00000010   012042E2           SUB      R2,R2,#+1
    197            }
   \                     ??FS__CLIB_memset_0:
   \   00000014   000052E3           CMP      R2,#+0
   \   00000018   03001313           TSTNE    R3,#0x3
   \   0000001C   FAFFFF1A           BNE      ??FS__CLIB_memset_1
    198            //
    199            // Write Ints
    200            //
    201            NumInts = (unsigned)NumBytes / sizeof(int);
   \   00000020   22C1B0E1           LSRS     R12,R2,#+2
    202            if (NumInts) {
   \   00000024   2000000A           BEQ      ??FS__CLIB_memset_2
    203              int FillInt;
    204              int *pInt;
    205              NumBytes &= (sizeof(int) - 1);
    206              if (sizeof(int) == 2) {        // May some compilers generate a warning at this line: Condition is always true/false
    207                FillInt = Fill * 0x101;      // May some compilers generate a warning at this line: Unreachable code
    208              } else if (sizeof(int) == 4) { // May some compilers generate a warning at this line: Condition is always true/false
    209                FillInt = Fill * 0x1010101UL;  // May some compilers generate a warning at this line: Unreachable code
   \   00000028   ........           LDR      R4,??DataTable1_1  ;; 0x1010101
   \   0000002C   032002E2           AND      R2,R2,#0x3
   \   00000030   94010EE0           MUL      LR,R4,R1
    210              }
    211              pInt = (int*)p;
   \   00000034   04005CE3           CMP      R12,#+4
   \   00000038   180000BA           BLT      ??FS__CLIB_memset_3
   \   0000003C   CC40A0E1           ASR      R4,R12,#+1
   \   00000040   244F8CE0           ADD      R4,R12,R4, LSR #+30
   \   00000044   4441A0E1           ASR      R4,R4,#+2
   \   00000048   010014E3           TST      R4,#0x1
   \   0000004C   0400000A           BEQ      ??FS__CLIB_memset_4
    212              //
    213              // Fill large amount of data at a time
    214              //
    215              while (NumInts >= 4) { 
    216                *pInt++ = FillInt;
   \   00000050   04E083E4           STR      LR,[R3], #+4
    217                *pInt++ = FillInt;
   \   00000054   04E083E4           STR      LR,[R3], #+4
    218                *pInt++ = FillInt;
   \   00000058   04E083E4           STR      LR,[R3], #+4
    219                *pInt++ = FillInt;
   \   0000005C   04E083E4           STR      LR,[R3], #+4
    220                NumInts -= 4;
   \   00000060   04C04CE2           SUB      R12,R12,#+4
   \                     ??FS__CLIB_memset_4:
   \   00000064   A440B0E1           LSRS     R4,R4,#+1
   \   00000068   0A00000A           BEQ      ??FS__CLIB_memset_5
   \                     ??FS__CLIB_memset_6:
   \   0000006C   04E083E4           STR      LR,[R3], #+4
   \   00000070   04E083E4           STR      LR,[R3], #+4
   \   00000074   04E083E4           STR      LR,[R3], #+4
   \   00000078   04E083E4           STR      LR,[R3], #+4
   \   0000007C   04E083E4           STR      LR,[R3], #+4
   \   00000080   04E083E4           STR      LR,[R3], #+4
   \   00000084   04E083E4           STR      LR,[R3], #+4
   \   00000088   04E083E4           STR      LR,[R3], #+4
   \   0000008C   08C04CE2           SUB      R12,R12,#+8
   \   00000090   014054E2           SUBS     R4,R4,#+1
   \   00000094   F4FFFF1A           BNE      ??FS__CLIB_memset_6
    221              }
    222              //
    223              // Fill one int at a time
    224              //
    225              while (NumInts) {
   \                     ??FS__CLIB_memset_5:
   \   00000098   00005CE3           CMP      R12,#+0
   \   0000009C   0200000A           BEQ      ??FS__CLIB_memset_2
    226                *pInt++ = FillInt;
   \                     ??FS__CLIB_memset_3:
   \   000000A0   04E083E4           STR      LR,[R3], #+4
    227                NumInts--;
   \   000000A4   01C05CE2           SUBS     R12,R12,#+1
   \   000000A8   FCFFFF1A           BNE      ??FS__CLIB_memset_3
    228              }
    229              p = (U8*)pInt;
    230            }
    231            /* Fill the remainder byte wise */
    232            while (NumBytes) {
   \                     ??FS__CLIB_memset_2:
   \   000000AC   000052E3           CMP      R2,#+0
   \   000000B0   0200000A           BEQ      ??FS__CLIB_memset_7
    233              *p++ = (U8)Fill;
   \                     ??FS__CLIB_memset_8:
   \   000000B4   0110C3E4           STRB     R1,[R3], #+1
    234              NumBytes--;
   \   000000B8   012052E2           SUBS     R2,R2,#+1
   \   000000BC   FCFFFF1A           BNE      ??FS__CLIB_memset_8
    235            }
    236            return pData;
   \                     ??FS__CLIB_memset_7:
   \   000000C0   1080BDE8           POP      {R4,PC}          ;; return
    237          }
    238          
    239          /*********************************************************************
    240          *
    241          *             FS__CLIB_strncat
    242          *
    243          *  Function description:
    244          *    Appends n characters from the array
    245          *    pointed to by s2 to the array pointed to by s1.
    246          *
    247          *  Parameters:
    248          *    s1          - Pointer to a character array.
    249          *    s2          - Pointer to a character array.
    250          *    n           - Number of characters to append
    251          * 
    252          *  Return value:
    253          *    Value of s1.
    254          */

   \                                 In section .text, align 4, keep-with-next
    255          char * FS__CLIB_strncat(char *s1, const char *s2, U32 n)  {
    256            char *s;
    257          
    258            if (s1) {
   \                     FS__CLIB_strncat:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1200000A           BEQ      ??FS__CLIB_strncat_0
    259              for (s = s1; *s != '\0'; ++s);       // find end of s1[]
   \   00000008   0030A0E1           MOV      R3,R0
   \   0000000C   00C0D3E5           LDRB     R12,[R3, #+0]
   \   00000010   00005CE3           CMP      R12,#+0
   \   00000014   0200000A           BEQ      ??FS__CLIB_strncat_1
   \                     ??FS__CLIB_strncat_2:
   \   00000018   01C0F3E5           LDRB     R12,[R3, #+1]!
   \   0000001C   00005CE3           CMP      R12,#+0
   \   00000020   FCFFFF1A           BNE      ??FS__CLIB_strncat_2
    260              if (s2) {
   \                     ??FS__CLIB_strncat_1:
   \   00000024   000051E3           CMP      R1,#+0
   \   00000028   0900000A           BEQ      ??FS__CLIB_strncat_0
   \   0000002C   020000EA           B        ??FS__CLIB_strncat_3
    261                for (; (0 < n) && (*s2 != 0); --n) {  // copy at most n chars from s2[]
    262                  *s++ = *s2++;
   \                     ??FS__CLIB_strncat_4:
   \   00000030   01C0D1E4           LDRB     R12,[R1], #+1
    263                }
   \   00000034   012042E2           SUB      R2,R2,#+1
   \   00000038   01C0C3E4           STRB     R12,[R3], #+1
   \                     ??FS__CLIB_strncat_3:
   \   0000003C   000052E3           CMP      R2,#+0
   \   00000040   00C0D115           LDRBNE   R12,[R1, #+0]
   \   00000044   00005C13           CMPNE    R12,#+0
   \   00000048   F8FFFF1A           BNE      ??FS__CLIB_strncat_4
    264                *s = '\0';
   \   0000004C   0010A0E3           MOV      R1,#+0
   \   00000050   0010C3E5           STRB     R1,[R3, #+0]
    265              }
    266            }
    267            return s1;
   \                     ??FS__CLIB_strncat_0:
   \   00000054   1EFF2FE1           BX       LR               ;; return
    268          }
    269          
    270          
    271          /*********************************************************************
    272          *
    273          *             FS__CLIB_strcat
    274          *
    275          *  Function description:
    276          *    Adds characters from the array
    277          *    pointed to by s2 to the array pointed to by s1.
    278          *
    279          *  Parameters:
    280          *    s1          - Pointer to a character array.
    281          *    s2          - Pointer to a character array.
    282          * 
    283          *  Return value:
    284          *    Value of s1.
    285          */

   \                                 In section .text, align 4, keep-with-next
    286          char * FS__CLIB_strcat(char *s1, const char *s2) {
    287          	char * s;
    288          
    289            if (s1) {
   \                     FS__CLIB_strcat:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   0D00000A           BEQ      ??FS__CLIB_strcat_0
    290              for (s = s1; *s != '\0'; ++s);            // find end of s1[]
   \   00000008   0020A0E1           MOV      R2,R0
   \   0000000C   0030D2E5           LDRB     R3,[R2, #+0]
   \   00000010   000053E3           CMP      R3,#+0
   \   00000014   0200000A           BEQ      ??FS__CLIB_strcat_1
   \                     ??FS__CLIB_strcat_2:
   \   00000018   0130F2E5           LDRB     R3,[R2, #+1]!
   \   0000001C   000053E3           CMP      R3,#+0
   \   00000020   FCFFFF1A           BNE      ??FS__CLIB_strcat_2
    291              if (s2) {
   \                     ??FS__CLIB_strcat_1:
   \   00000024   000051E3           CMP      R1,#+0
   \   00000028   0400000A           BEQ      ??FS__CLIB_strcat_0
    292                for (; (*s = *s2) != '\0'; ++s, ++s2);    // copy s2[] to end
   \                     ??FS__CLIB_strcat_3:
   \   0000002C   0130D1E4           LDRB     R3,[R1], #+1
   \   00000030   0030C2E5           STRB     R3,[R2, #+0]
   \   00000034   0130D2E4           LDRB     R3,[R2], #+1
   \   00000038   000053E3           CMP      R3,#+0
   \   0000003C   FAFFFF1A           BNE      ??FS__CLIB_strcat_3
    293              }
    294            }
    295            return (s1);
   \                     ??FS__CLIB_strcat_0:
   \   00000040   1EFF2FE1           BX       LR               ;; return
    296          }
    297          
    298          /*********************************************************************
    299          *
    300          *       FS__CLIB_strcmp
    301          *
    302          *  Function description:
    303          *    Compare the sring pointed to by s1 with the 
    304          *    string pointed to by s2.
    305          *
    306          *  Parameters:
    307          *    s1          - Pointer to a zero terminated string.
    308          *    s2          - Pointer to a zero terminated string.
    309          * 
    310          *  Return value:
    311          *    0           - bytes are equal
    312          *    1           - bytes are different
    313          */

   \                                 In section .text, align 4, keep-with-next
    314          int FS__CLIB_strcmp(const char *s1, const char *s2)	{
    315            char c1, c2;
    316            do {
    317              c1 = *s1++;
   \                     FS__CLIB_strcmp:
   \                     ??FS__CLIB_strcmp_0:
   \   00000000   0120D0E4           LDRB     R2,[R0], #+1
    318              c2 = *s2++;
   \   00000004   0130D1E4           LDRB     R3,[R1], #+1
    319              if (c1 != c2) {
   \   00000008   030052E1           CMP      R2,R3
   \   0000000C   0100000A           BEQ      ??FS__CLIB_strcmp_1
    320                return 1;             // Different
   \   00000010   0100A0E3           MOV      R0,#+1
   \   00000014   1EFF2FE1           BX       LR
    321              }
    322            } while (c1);
   \                     ??FS__CLIB_strcmp_1:
   \   00000018   000052E3           CMP      R2,#+0
   \   0000001C   F7FFFF1A           BNE      ??FS__CLIB_strcmp_0
    323            return 0;                 // Equal
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   1EFF2FE1           BX       LR               ;; return
    324          }
    325          
    326          
    327          /*********************************************************************
    328          *
    329          *      FS__CLIB_strcpy
    330          *
    331          *  Description:
    332          *    Copy characters from the array
    333          *    pointed to by s2 to the array pointed to by s1.
    334          *
    335          *  Parameters:
    336          *    s1          - Pointer to a character array.
    337          *    s2          - Pointer to a character array.
    338          * 
    339          *  Return value:
    340          *    Value of s1.
    341          */

   \                                 In section .text, align 4, keep-with-next
    342          char * FS__CLIB_strcpy(char *s1, const char *s2) {
    343             char *p = NULL;
   \                     FS__CLIB_strcpy:
   \   00000000   0020A0E3           MOV      R2,#+0
    344             if (s1) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0800000A           BEQ      ??FS__CLIB_strcpy_0
    345               p = s1;
   \   0000000C   0020A0E1           MOV      R2,R0
   \   00000010   010000EA           B        ??FS__CLIB_strcpy_1
    346               while(*s2 != 0) {
    347                 *s1++  = *s2++;
   \                     ??FS__CLIB_strcpy_2:
   \   00000014   0130D1E4           LDRB     R3,[R1], #+1
   \   00000018   0130C0E4           STRB     R3,[R0], #+1
    348               }
   \                     ??FS__CLIB_strcpy_1:
   \   0000001C   0030D1E5           LDRB     R3,[R1, #+0]
   \   00000020   000053E3           CMP      R3,#+0
   \   00000024   FAFFFF1A           BNE      ??FS__CLIB_strcpy_2
    349               *s1 = 0;
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   0010C0E5           STRB     R1,[R0, #+0]
    350             }
    351             return p;
   \                     ??FS__CLIB_strcpy_0:
   \   00000030   0200A0E1           MOV      R0,R2
   \   00000034   1EFF2FE1           BX       LR               ;; return
    352          }
    353          
    354          
    355          /*********************************************************************
    356          *
    357          *       FS__CLIB_strlen
    358          *
    359          *  Function description:
    360          *    Compute the length of a string pointed to by s.
    361          *
    362          *  Parameters:
    363          *    s           - Pointer to a zero terminated string.
    364          * 
    365          *  Return value:
    366          *    Number of characters preceding the terminating 0.
    367          */

   \                                 In section .text, align 4, keep-with-next
    368          unsigned FS__CLIB_strlen(const char *s) {	
    369            unsigned Len;
    370          
    371            Len = 0;
    372            while (*s++) {
   \                     FS__CLIB_strlen:
   \   00000000   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   000052E3           CMP      R2,#+0
   \   0000000C   0300000A           BEQ      ??FS__CLIB_strlen_0
    373              Len++;
   \                     ??FS__CLIB_strlen_1:
   \   00000010   0120F0E5           LDRB     R2,[R0, #+1]!
   \   00000014   011081E2           ADD      R1,R1,#+1
   \   00000018   000052E3           CMP      R2,#+0
   \   0000001C   FBFFFF1A           BNE      ??FS__CLIB_strlen_1
    374            }
    375            return Len;
   \                     ??FS__CLIB_strlen_0:
   \   00000020   0100A0E1           MOV      R0,R1
   \   00000024   1EFF2FE1           BX       LR               ;; return
    376          }
    377          
    378          /*********************************************************************
    379          *
    380          *       FS__CLIB_strncmp
    381          *
    382          *  Function description:
    383          *    Compare no more than n characters from the
    384          *    array pointed to by s1 to the array pointed to by s2.
    385          *
    386          *  Parameters:
    387          *    s1          - Pointer to a character array.
    388          *    s2          - Pointer to a character array.
    389          *    n           - Number of characters to compare.
    390          * 
    391          *  Return value:
    392          *    0           - bytes are equal
    393          *    1           - bytes are different
    394          */

   \                                 In section .text, align 4, keep-with-next
    395          int FS__CLIB_strncmp(const char *s1, const char *s2, int n) {
   \                     FS__CLIB_strncmp:
   \   00000000   000000EA           B        ??FS__CLIB_strncmp_0
    396            for (; n > 0; n--) {
   \                     ??FS__CLIB_strncmp_1:
   \   00000004   012042E2           SUB      R2,R2,#+1
   \                     ??FS__CLIB_strncmp_0:
   \   00000008   010052E3           CMP      R2,#+1
   \   0000000C   080000BA           BLT      ??FS__CLIB_strncmp_2
    397              char c1, c2;
    398              c1 = *s1++;
   \   00000010   0130D0E4           LDRB     R3,[R0], #+1
    399              c2 = *s2++;
   \   00000014   01C0D1E4           LDRB     R12,[R1], #+1
    400              if (c1 != c2) {
   \   00000018   0C0053E1           CMP      R3,R12
   \   0000001C   0100000A           BEQ      ??FS__CLIB_strncmp_3
    401                return 1;             // Different
   \   00000020   0100A0E3           MOV      R0,#+1
   \   00000024   1EFF2FE1           BX       LR
    402              }
    403              if (*s1 == '\0') {
   \                     ??FS__CLIB_strncmp_3:
   \   00000028   0030D0E5           LDRB     R3,[R0, #+0]
   \   0000002C   000053E3           CMP      R3,#+0
   \   00000030   F3FFFF1A           BNE      ??FS__CLIB_strncmp_1
    404                return 0;             // Equal
   \                     ??FS__CLIB_strncmp_2:
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   1EFF2FE1           BX       LR               ;; return
    405              }
    406            }
    407            return 0;                 // Equal
    408          }
    409          
    410          
    411          /*********************************************************************
    412          *
    413          *       FS__CLIB_strncpy
    414          *
    415          *  Function description:
    416          *    Copy not more than n characters from the array
    417          *    pointed to by s2 to the array pointed to by s1.
    418          *
    419          *  Parameters:
    420          *    s1          - Pointer to a character array.
    421          *    s2          - Pointer to a character array.
    422          *    n           - Number of characters to copy.
    423          * 
    424          *  Return value:
    425          *    Value of s1.
    426          */

   \                                 In section .text, align 4, keep-with-next
    427          char *FS__CLIB_strncpy(char *s1, const char *s2, U32 n) {
    428            char *s;
    429            
    430            for (s = s1; (0 < n) && (*s2 != '\0'); --n) {
   \                     FS__CLIB_strncpy:
   \   00000000   0030A0E1           MOV      R3,R0
   \   00000004   020000EA           B        ??FS__CLIB_strncpy_0
    431              *s++ = *s2++;         // copy at most n chars from s2[]
   \                     ??FS__CLIB_strncpy_1:
   \   00000008   01C0D1E4           LDRB     R12,[R1], #+1
    432            }
   \   0000000C   012042E2           SUB      R2,R2,#+1
   \   00000010   01C0C3E4           STRB     R12,[R3], #+1
   \                     ??FS__CLIB_strncpy_0:
   \   00000014   000052E3           CMP      R2,#+0
   \   00000018   0600000A           BEQ      ??FS__CLIB_strncpy_2
   \   0000001C   00C0D1E5           LDRB     R12,[R1, #+0]
   \   00000020   00005CE3           CMP      R12,#+0
   \   00000024   F7FFFF1A           BNE      ??FS__CLIB_strncpy_1
    433            for (; 0 < n; --n) {
    434              *s++ = '\0';
   \                     ??FS__CLIB_strncpy_3:
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   0110C3E4           STRB     R1,[R3], #+1
    435            }
   \   00000030   012052E2           SUBS     R2,R2,#+1
   \   00000034   FBFFFF1A           BNE      ??FS__CLIB_strncpy_3
    436            return s1;
   \                     ??FS__CLIB_strncpy_2:
   \   00000038   1EFF2FE1           BX       LR               ;; return
    437          }
    438          
    439          /*********************************************************************
    440          *
    441          *       FS__CLIB_toupper
    442          *
    443          *  Function description:
    444          *    yConvert a lowecase letter to a corresponding
    445          *    uppercase letter. 
    446          *
    447          *  Parameters:
    448          *    c           - Letter to convert.
    449          * 
    450          *  Return value:
    451          *    Corresponding uppercase character.
    452          */

   \                                 In section .text, align 4, keep-with-next
    453          int FS__CLIB_toupper(int c) {
    454            if ((c >= 'a') && (c <= 'z')) {
   \                     FS__CLIB_toupper:
   \   00000000   611040E2           SUB      R1,R0,#+97
   \   00000004   1A0051E3           CMP      R1,#+26
    455              c &= 0xdf;
   \   00000008   DF000032           ANDCC    R0,R0,#0xDF
    456            }
    457            return c;
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    458          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   CDCCCCCC           DC32     0xcccccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   01010101           DC32     0x1010101
    459          
    460          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     FS__CLIB_atoi        12
     FS__CLIB_memcmp       0
     FS__CLIB_memset       8
     FS__CLIB_strcat       0
     FS__CLIB_strcmp       0
     FS__CLIB_strcpy       0
     FS__CLIB_strlen       0
     FS__CLIB_strncat      0
     FS__CLIB_strncmp      0
     FS__CLIB_strncpy      0
     FS__CLIB_toupper      0


   Section sizes:

     Function/Label   Bytes
     --------------   -----
     FS__CLIB_atoi     464
     FS__CLIB_memcmp    44
     FS__CLIB_memset   196
     FS__CLIB_strncat   88
     FS__CLIB_strcat    68
     FS__CLIB_strcmp    40
     FS__CLIB_strcpy    56
     FS__CLIB_strlen    40
     FS__CLIB_strncmp   60
     FS__CLIB_strncpy   60
     FS__CLIB_toupper   16
     ??DataTable1        4
     ??DataTable1_1      4

 
 1 140 bytes in section .text
 
 1 140 bytes of CODE memory

Errors: none
Warnings: none
