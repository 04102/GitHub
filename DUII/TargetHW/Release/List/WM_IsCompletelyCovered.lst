###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:11:43 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\WM_IsCompletelyCovered.c            #
#    Command line =  C:\DUII\TargetHW\GUI\WM_IsCompletelyCovered.c -D         #
#                    DEBUG=1 -D SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D        #
#                    NOPROFILER -D OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN        #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\WM_IsCompletelyCovered.lst #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\WM_IsCompletelyCovered.o    #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\WM_IsCompletelyCovered.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : WM_IsCompletelyCovered.c
     19          Purpose     : Windows manager, implementation of said function
     20          ----------------------------------------------------------------------
     21          */
     22          
     23          #include <stddef.h>
     24          #include "WM_Intern.h"
     25          
     26          #if GUI_WINSUPPORT    /* If 0, WM will not generate any code */
     27          
     28          /*********************************************************************
     29          *
     30          *       Defines
     31          *
     32          **********************************************************************
     33          */
     34          #define ASSIGN_IF_LESS(v0, v1) if (v1 < v0) v0 = v1
     35          
     36          /*********************************************************************
     37          *
     38          *       Types
     39          *
     40          **********************************************************************
     41          */
     42          typedef struct {
     43            WM_HWIN hWin;
     44            GUI_RECT ClientRect;
     45            GUI_RECT CurRect;
     46            int Cnt;
     47            int EntranceCnt;
     48          } CONTEXT;
     49          
     50          /*********************************************************************
     51          *
     52          *       Static data
     53          *
     54          **********************************************************************
     55          */

   \                                 In section .bss, align 4
     56          static CONTEXT _Context;
   \                     _Context:
   \   00000000                      DS8 28
     57          
     58          /*********************************************************************
     59          *
     60          *       Static code
     61          *
     62          **********************************************************************
     63          */
     64          /*********************************************************************
     65          *
     66          *       _Findy1
     67          *
     68          */

   \                                 In section .text, align 4, keep-with-next
     69          static void _Findy1(WM_HWIN iWin, GUI_RECT * pRect, GUI_RECT * pParentRect) {
   \                     _Findy1:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
     70            WM_Obj * pWin;
     71            for (; iWin; iWin = pWin->hNext) { 
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   3700000A           BEQ      ??_Findy1_0
     72              int Status;
     73              Status = (pWin = WM_H2P(iWin))->Status;
   \                     ??_Findy1_1:
   \   00000018   ........           BL       GUI_ALLOC_h2p
   \   0000001C   0060A0E1           MOV      R6,R0
   \   00000020   287096E5           LDR      R7,[R6, #+40]
     74              /* Check if this window affects us at all */    
     75              if (Status & WM_SF_ISVIS) {
   \   00000024   020017E3           TST      R7,#0x2
   \   00000028   2F00000A           BEQ      ??_Findy1_2
     76                GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
     77                if (pParentRect) {
   \   0000002C   000055E3           CMP      R5,#+0
   \   00000030   0400000A           BEQ      ??_Findy1_3
     78                  GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
   \   00000034   0520A0E1           MOV      R2,R5
   \   00000038   0610A0E1           MOV      R1,R6
   \   0000003C   0D00A0E1           MOV      R0,SP
   \   00000040   ........           BL       GUI__IntersectRects
   \   00000044   030000EA           B        ??_Findy1_4
     79                } else {
     80                  rWinClipped = pWin->Rect;
   \                     ??_Findy1_3:
   \   00000048   0D00A0E1           MOV      R0,SP
   \   0000004C   0610A0E1           MOV      R1,R6
   \   00000050   0820A0E3           MOV      R2,#+8
   \   00000054   ........           BL       __aeabi_memcpy
     81                }
     82                /* Check if this window affects us at all */    
     83                if (GUI_RectsIntersect(pRect, &rWinClipped)) {
   \                     ??_Findy1_4:
   \   00000058   0D10A0E1           MOV      R1,SP
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           BL       GUI_RectsIntersect
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   1F00000A           BEQ      ??_Findy1_2
     84                  if ((Status & WM_SF_HASTRANS) == 0) {
   \   0000006C   010017E3           TST      R7,#0x1
   \   00000070   1000001A           BNE      ??_Findy1_5
     85                    if (pWin->Rect.y0 > pRect->y0) {
   \   00000074   F210D4E1           LDRSH    R1,[R4, #+2]
   \   00000078   F220D6E1           LDRSH    R2,[R6, #+2]
   \   0000007C   F600D4E1           LDRSH    R0,[R4, #+6]
   \   00000080   020051E1           CMP      R1,R2
   \   00000084   060000AA           BGE      ??_Findy1_6
     86                      ASSIGN_IF_LESS(pRect->y1, rWinClipped.y0 - 1);    /* Check upper border of window */
   \   00000088   F210DDE1           LDRSH    R1,[SP, #+2]
   \   0000008C   012041E2           SUB      R2,R1,#+1
   \   00000090   000052E1           CMP      R2,R0
   \   00000094   140000AA           BGE      ??_Findy1_2
   \   00000098   010041E2           SUB      R0,R1,#+1
   \   0000009C   B600C4E1           STRH     R0,[R4, #+6]
   \   000000A0   110000EA           B        ??_Findy1_2
     87                    } else {
     88                      ASSIGN_IF_LESS(pRect->y1, rWinClipped.y1);        /* Check lower border of window */
   \                     ??_Findy1_6:
   \   000000A4   F610DDE1           LDRSH    R1,[SP, #+6]
   \   000000A8   000051E1           CMP      R1,R0
   \   000000AC   0E0000AA           BGE      ??_Findy1_2
   \   000000B0   B610C4E1           STRH     R1,[R4, #+6]
   \   000000B4   0C0000EA           B        ??_Findy1_2
     89                    }
     90                  } else {
     91                    /* Check all children */ 
     92                    WM_HWIN hChild;
     93                    WM_Obj* pChild;
     94                    for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
   \                     ??_Findy1_5:
   \   000000B8   1C7096E5           LDR      R7,[R6, #+28]
   \   000000BC   000057E3           CMP      R7,#+0
   \   000000C0   0900000A           BEQ      ??_Findy1_2
     95                      pChild = WM_H2P(hChild);
   \                     ??_Findy1_7:
   \   000000C4   0700A0E1           MOV      R0,R7
   \   000000C8   ........           BL       GUI_ALLOC_h2p
   \   000000CC   0080A0E1           MOV      R8,R0
     96                      _Findy1(hChild, pRect, &rWinClipped);
   \   000000D0   0D20A0E1           MOV      R2,SP
   \   000000D4   0410A0E1           MOV      R1,R4
   \   000000D8   0700A0E1           MOV      R0,R7
   \   000000DC   ........           BL       _Findy1
     97                    }
   \   000000E0   207098E5           LDR      R7,[R8, #+32]
   \   000000E4   000057E3           CMP      R7,#+0
   \   000000E8   F5FFFF1A           BNE      ??_Findy1_7
     98                  }
     99                }
    100              }
    101            }
   \                     ??_Findy1_2:
   \   000000EC   200096E5           LDR      R0,[R6, #+32]
   \   000000F0   000050E3           CMP      R0,#+0
   \   000000F4   C7FFFF1A           BNE      ??_Findy1_1
    102          }
   \                     ??_Findy1_0:
   \   000000F8   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   000000FC   F081BDE8           POP      {R4-R8,PC}       ;; return
    103          
    104          /*********************************************************************
    105          *
    106          *       _Findx0
    107          */

   \                                 In section .text, align 4, keep-with-next
    108          static int _Findx0(WM_HWIN hWin, GUI_RECT * pRect, GUI_RECT * pParentRect) {
   \                     _Findx0:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
    109            WM_Obj * pWin;
    110            int r = 0;
   \   00000010   0070A0E3           MOV      R7,#+0
    111            for (; hWin; hWin = pWin->hNext) { 
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   2D00000A           BEQ      ??_Findx0_0
    112              int Status;
    113              Status = (pWin = WM_H2P(hWin))->Status;
   \                     ??_Findx0_1:
   \   0000001C   ........           BL       GUI_ALLOC_h2p
   \   00000020   0060A0E1           MOV      R6,R0
   \   00000024   288096E5           LDR      R8,[R6, #+40]
    114              if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
   \   00000028   020018E3           TST      R8,#0x2
   \   0000002C   2500000A           BEQ      ??_Findx0_2
    115                GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
    116                if (pParentRect) {
   \   00000030   000055E3           CMP      R5,#+0
   \   00000034   0400000A           BEQ      ??_Findx0_3
    117                  GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
   \   00000038   0520A0E1           MOV      R2,R5
   \   0000003C   0610A0E1           MOV      R1,R6
   \   00000040   0D00A0E1           MOV      R0,SP
   \   00000044   ........           BL       GUI__IntersectRects
   \   00000048   030000EA           B        ??_Findx0_4
    118                } else {
    119                  rWinClipped = pWin->Rect;
   \                     ??_Findx0_3:
   \   0000004C   0D00A0E1           MOV      R0,SP
   \   00000050   0610A0E1           MOV      R1,R6
   \   00000054   0820A0E3           MOV      R2,#+8
   \   00000058   ........           BL       __aeabi_memcpy
    120                }
    121                /* Check if this window affects us at all */    
    122                if (GUI_RectsIntersect(pRect, &rWinClipped)) {
   \                     ??_Findx0_4:
   \   0000005C   0D10A0E1           MOV      R1,SP
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       GUI_RectsIntersect
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   1500000A           BEQ      ??_Findx0_2
    123                  if ((Status & WM_SF_HASTRANS) == 0) {
   \   00000070   010018E3           TST      R8,#0x1
   \   00000074   0400001A           BNE      ??_Findx0_5
    124                    pRect->x0 = rWinClipped.x1 + 1;
   \   00000078   F400DDE1           LDRSH    R0,[SP, #+4]
    125                    r = 1;
   \   0000007C   0170A0E3           MOV      R7,#+1
   \   00000080   010080E2           ADD      R0,R0,#+1
   \   00000084   B000C4E1           STRH     R0,[R4, #+0]
   \   00000088   0E0000EA           B        ??_Findx0_2
    126                  } else {
    127                    /* Check all children */
    128                    WM_HWIN hChild;
    129                    WM_Obj * pChild;
    130                    for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
   \                     ??_Findx0_5:
   \   0000008C   1C8096E5           LDR      R8,[R6, #+28]
   \   00000090   000058E3           CMP      R8,#+0
   \   00000094   0B00000A           BEQ      ??_Findx0_2
    131                      pChild = WM_H2P(hChild);
   \                     ??_Findx0_6:
   \   00000098   0800A0E1           MOV      R0,R8
   \   0000009C   ........           BL       GUI_ALLOC_h2p
   \   000000A0   0090A0E1           MOV      R9,R0
    132                      if (_Findx0(hChild, pRect, &rWinClipped)) {
   \   000000A4   0D20A0E1           MOV      R2,SP
   \   000000A8   0410A0E1           MOV      R1,R4
   \   000000AC   0800A0E1           MOV      R0,R8
   \   000000B0   ........           BL       _Findx0
   \   000000B4   000050E3           CMP      R0,#+0
    133                        r = 1;
    134                      }
    135                    }
   \   000000B8   208099E5           LDR      R8,[R9, #+32]
   \   000000BC   0170A013           MOVNE    R7,#+1
   \   000000C0   000058E3           CMP      R8,#+0
   \   000000C4   F3FFFF1A           BNE      ??_Findx0_6
    136                  }
    137                }
    138              }
    139            }
   \                     ??_Findx0_2:
   \   000000C8   200096E5           LDR      R0,[R6, #+32]
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   D1FFFF1A           BNE      ??_Findx0_1
    140            return r;
   \                     ??_Findx0_0:
   \   000000D4   0700A0E1           MOV      R0,R7
   \   000000D8   0CD08DE2           ADD      SP,SP,#+12
   \   000000DC   F083BDE8           POP      {R4-R9,PC}       ;; return
    141          }
    142          
    143          /*********************************************************************
    144          *
    145          *       _Findx1
    146          */

   \                                 In section .text, align 4, keep-with-next
    147          static void _Findx1(WM_HWIN hWin, GUI_RECT * pRect, GUI_RECT * pParentRect) {
   \                     _Findx1:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
    148            WM_Obj* pWin;
    149            for (; hWin; hWin = pWin->hNext) { 
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   2A00000A           BEQ      ??_Findx1_0
    150              int Status;
    151              Status = (pWin = WM_H2P(hWin))->Status;
   \                     ??_Findx1_1:
   \   00000018   ........           BL       GUI_ALLOC_h2p
   \   0000001C   0060A0E1           MOV      R6,R0
   \   00000020   287096E5           LDR      R7,[R6, #+40]
    152              if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
   \   00000024   020017E3           TST      R7,#0x2
   \   00000028   2200000A           BEQ      ??_Findx1_2
    153                GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
    154                if (pParentRect) {
   \   0000002C   000055E3           CMP      R5,#+0
   \   00000030   0400000A           BEQ      ??_Findx1_3
    155                  GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
   \   00000034   0520A0E1           MOV      R2,R5
   \   00000038   0610A0E1           MOV      R1,R6
   \   0000003C   0D00A0E1           MOV      R0,SP
   \   00000040   ........           BL       GUI__IntersectRects
   \   00000044   030000EA           B        ??_Findx1_4
    156                } else {
    157                  rWinClipped = pWin->Rect;
   \                     ??_Findx1_3:
   \   00000048   0D00A0E1           MOV      R0,SP
   \   0000004C   0610A0E1           MOV      R1,R6
   \   00000050   0820A0E3           MOV      R2,#+8
   \   00000054   ........           BL       __aeabi_memcpy
    158                }
    159                /* Check if this window affects us at all */    
    160                if (GUI_RectsIntersect(pRect, &rWinClipped)) {
   \                     ??_Findx1_4:
   \   00000058   0D10A0E1           MOV      R1,SP
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           BL       GUI_RectsIntersect
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   1200000A           BEQ      ??_Findx1_2
    161                  if ((Status & WM_SF_HASTRANS) == 0) {
   \   0000006C   010017E3           TST      R7,#0x1
   \   00000070   0300001A           BNE      ??_Findx1_5
    162                    pRect->x1 = rWinClipped.x0-1;
   \   00000074   F000DDE1           LDRSH    R0,[SP, #+0]
   \   00000078   010040E2           SUB      R0,R0,#+1
   \   0000007C   B400C4E1           STRH     R0,[R4, #+4]
   \   00000080   0C0000EA           B        ??_Findx1_2
    163                  } else {
    164                    /* Check all children */
    165                    WM_HWIN hChild;
    166                    WM_Obj * pChild;
    167                    for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
   \                     ??_Findx1_5:
   \   00000084   1C7096E5           LDR      R7,[R6, #+28]
   \   00000088   000057E3           CMP      R7,#+0
   \   0000008C   0900000A           BEQ      ??_Findx1_2
    168                      pChild = WM_H2P(hChild);
   \                     ??_Findx1_6:
   \   00000090   0700A0E1           MOV      R0,R7
   \   00000094   ........           BL       GUI_ALLOC_h2p
   \   00000098   0080A0E1           MOV      R8,R0
    169                      _Findx1(hChild, pRect, &rWinClipped);
   \   0000009C   0D20A0E1           MOV      R2,SP
   \   000000A0   0410A0E1           MOV      R1,R4
   \   000000A4   0700A0E1           MOV      R0,R7
   \   000000A8   ........           BL       _Findx1
    170                    }
   \   000000AC   207098E5           LDR      R7,[R8, #+32]
   \   000000B0   000057E3           CMP      R7,#+0
   \   000000B4   F5FFFF1A           BNE      ??_Findx1_6
    171                  }
    172                }
    173              }
    174            }
   \                     ??_Findx1_2:
   \   000000B8   200096E5           LDR      R0,[R6, #+32]
   \   000000BC   000050E3           CMP      R0,#+0
   \   000000C0   D4FFFF1A           BNE      ??_Findx1_1
    175          }
   \                     ??_Findx1_0:
   \   000000C4   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   000000C8   F081BDE8           POP      {R4-R8,PC}       ;; return
    176          
    177          /*********************************************************************
    178          *
    179          *       _FindNextRect
    180          */

   \                                 In section .text, align 4, keep-with-next
    181          static int _FindNextRect(void) {
   \                     _FindNextRect:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    182            WM_HMEM hParent;
    183            GUI_RECT r;
    184            WM_Obj * pAWin;
    185            WM_Obj * pParent;
    186            r = _Context.CurRect;  /* temps  so we do not have to work with pointers too much */
   \   00000004   ........           LDR      R4,??DataTable2
   \   00000008   10D04DE2           SUB      SP,SP,#+16
   \   0000000C   0C0094E5           LDR      R0,[R4, #+12]
   \   00000010   101094E5           LDR      R1,[R4, #+16]
   \   00000014   0D20A0E1           MOV      R2,SP
   \   00000018   030082E8           STM      R2,{R0,R1}
    187            /*
    188               STEP 1:
    189                 Set the next position which could be part of the next rectangle.
    190                 This will be the first unhandle pixel in reading order, i.e. next one to the right
    191                 or next one down if we are at the right border.
    192            */
    193            if (_Context.Cnt == 0) {       /* First rectangle starts in upper left */
   \   0000001C   140094E5           LDR      R0,[R4, #+20]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0400001A           BNE      ??_FindNextRect_0
    194              r.x0 = _Context.ClientRect.x0;
   \   00000028   F400D4E1           LDRSH    R0,[R4, #+4]
    195              r.y0 = _Context.ClientRect.y0;
   \   0000002C   F610D4E1           LDRSH    R1,[R4, #+6]
   \   00000030   B000CDE1           STRH     R0,[SP, #+0]
   \   00000034   B210CDE1           STRH     R1,[SP, #+2]
   \   00000038   0D0000EA           B        ??_FindNextRect_1
    196            } else {
    197              r.x0 = _Context.CurRect.x1 + 1;
   \                     ??_FindNextRect_0:
   \   0000003C   F001D4E1           LDRSH    R0,[R4, #+16]
    198              r.y0 = _Context.CurRect.y0;
   \   00000040   FE10D4E1           LDRSH    R1,[R4, #+14]
   \   00000044   010080E2           ADD      R0,R0,#+1
   \   00000048   B000CDE1           STRH     R0,[SP, #+0]
   \   0000004C   B210CDE1           STRH     R1,[SP, #+2]
    199              if (r.x0 > _Context.ClientRect.x1) {
   \   00000050   F800D4E1           LDRSH    R0,[R4, #+8]
   \   00000054   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000058   010050E1           CMP      R0,R1
   \   0000005C   040000AA           BGE      ??_FindNextRect_1
    200          NextStripe:  /* go down to next stripe */
    201                r.x0 = _Context.ClientRect.x0;
   \                     ??_FindNextRect_2:
   \   00000060   F400D4E1           LDRSH    R0,[R4, #+4]
   \   00000064   B000CDE1           STRH     R0,[SP, #+0]
    202                r.y0 = _Context.CurRect.y1 + 1;
   \   00000068   F201D4E1           LDRSH    R0,[R4, #+18]
   \   0000006C   010080E2           ADD      R0,R0,#+1
   \   00000070   B200CDE1           STRH     R0,[SP, #+2]
    203              }
    204            }
    205            /*
    206               STEP 2:
    207                 Check if we are done completely.
    208            */
    209            if (r.y0 >_Context.ClientRect.y1) {
   \                     ??_FindNextRect_1:
   \   00000074   FA00D4E1           LDRSH    R0,[R4, #+10]
   \   00000078   F210DDE1           LDRSH    R1,[SP, #+2]
   \   0000007C   010050E1           CMP      R0,R1
   \   00000080   010000AA           BGE      ??_FindNextRect_3
    210              return 0;
   \                     ??_FindNextRect_4:
   \   00000084   0000A0E3           MOV      R0,#+0
   \   00000088   E50000EA           B        ??_FindNextRect_5
    211            }
    212            /* STEP 3:
    213                 Find out the max. height (r.y1) if we are at the left border.
    214                 Since we are using the same height for all rectangles at the same y0,
    215                 we do this only for the leftmost one.
    216            */
    217            pAWin = WM_H2P(_Context.hWin);
   \                     ??_FindNextRect_3:
   \   0000008C   000094E5           LDR      R0,[R4, #+0]
   \   00000090   ........           BL       GUI_ALLOC_h2p
   \   00000094   0050A0E1           MOV      R5,R0
    218            if (r.x0 == _Context.ClientRect.x0) {
   \   00000098   F000DDE1           LDRSH    R0,[SP, #+0]
   \   0000009C   F410D4E1           LDRSH    R1,[R4, #+4]
   \   000000A0   010050E1           CMP      R0,R1
   \   000000A4   1300001A           BNE      ??_FindNextRect_6
    219              r.y1 = _Context.ClientRect.y1;
   \   000000A8   FA10D4E1           LDRSH    R1,[R4, #+10]
    220              r.x1 = _Context.ClientRect.x1;
    221              /* Iterate over all windows which are above */
    222              /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
    223              for (hParent = _Context.hWin; hParent; hParent = pParent->hParent) {
   \   000000AC   000094E5           LDR      R0,[R4, #+0]
   \   000000B0   B610CDE1           STRH     R1,[SP, #+6]
   \   000000B4   F810D4E1           LDRSH    R1,[R4, #+8]
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   B410CDE1           STRH     R1,[SP, #+4]
   \   000000C0   0800000A           BEQ      ??_FindNextRect_7
    224                pParent = WM_H2P(hParent);
   \                     ??_FindNextRect_8:
   \   000000C4   ........           BL       GUI_ALLOC_h2p
   \   000000C8   0060A0E1           MOV      R6,R0
    225                _Findy1(pParent->hNext, &r, NULL);
   \   000000CC   0020A0E3           MOV      R2,#+0
   \   000000D0   0D10A0E1           MOV      R1,SP
   \   000000D4   200096E5           LDR      R0,[R6, #+32]
   \   000000D8   ........           BL       _Findy1
    226              }
   \   000000DC   180096E5           LDR      R0,[R6, #+24]
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   F6FFFF1A           BNE      ??_FindNextRect_8
    227              /* Check all children */
    228              _Findy1(pAWin->hFirstChild, &r, NULL);
   \                     ??_FindNextRect_7:
   \   000000E8   0020A0E3           MOV      R2,#+0
   \   000000EC   0D10A0E1           MOV      R1,SP
   \   000000F0   1C0095E5           LDR      R0,[R5, #+28]
   \   000000F4   ........           BL       _Findy1
    229            }
    230            /* 
    231              STEP 4
    232                Find out x0 for the given y0, y1 by iterating over windows above.
    233                if we find one that intersects, adjust x0 to the right.
    234            */
    235          Find_x0:
    236            r.x1 = r.x0;
   \                     ??_FindNextRect_6:
   \   000000F8   F010DDE1           LDRSH    R1,[SP, #+0]
    237            /* Iterate over all windows which are above */
    238            /* Check all siblings above (siblings of window, siblings of parents, etc ...) */
    239            hParent = _Context.hWin;
   \   000000FC   000094E5           LDR      R0,[R4, #+0]
   \   00000100   B410CDE1           STRH     R1,[SP, #+4]
   \   00000104   090000EA           B        ??_FindNextRect_9
    240            for (; hParent; hParent = pParent->hParent) {
   \                     ??_FindNextRect_10:
   \   00000108   FC00DDE1           LDRSH    R0,[SP, #+12]
   \   0000010C   0180A0E3           MOV      R8,#+1
   \   00000110   010080E2           ADD      R0,R0,#+1
   \   00000114   B000CDE1           STRH     R0,[SP, #+0]
   \                     ??_FindNextRect_11:
   \   00000118   200097E5           LDR      R0,[R7, #+32]
   \   0000011C   000050E3           CMP      R0,#+0
   \   00000120   0A00001A           BNE      ??_FindNextRect_12
    241              pParent = WM_H2P(hParent);
    242              if (_Findx0(pParent->hNext, &r, NULL)) {
   \   00000124   000058E3           CMP      R8,#+0
   \   00000128   F2FFFF1A           BNE      ??_FindNextRect_6
   \                     ??_FindNextRect_13:
   \   0000012C   180096E5           LDR      R0,[R6, #+24]
   \                     ??_FindNextRect_9:
   \   00000130   000050E3           CMP      R0,#+0
   \   00000134   2500000A           BEQ      ??_FindNextRect_14
   \   00000138   ........           BL       GUI_ALLOC_h2p
   \   0000013C   0060A0E1           MOV      R6,R0
   \   00000140   200096E5           LDR      R0,[R6, #+32]
   \   00000144   0080A0E3           MOV      R8,#+0
   \   00000148   000050E3           CMP      R0,#+0
   \   0000014C   F6FFFF0A           BEQ      ??_FindNextRect_13
   \                     ??_FindNextRect_12:
   \   00000150   ........           BL       GUI_ALLOC_h2p
   \   00000154   0070A0E1           MOV      R7,R0
   \   00000158   289097E5           LDR      R9,[R7, #+40]
   \   0000015C   020019E3           TST      R9,#0x2
   \   00000160   ECFFFF0A           BEQ      ??_FindNextRect_11
   \   00000164   08008DE2           ADD      R0,SP,#+8
   \   00000168   0710A0E1           MOV      R1,R7
   \   0000016C   0820A0E3           MOV      R2,#+8
   \   00000170   ........           BL       __aeabi_memcpy
   \   00000174   08108DE2           ADD      R1,SP,#+8
   \   00000178   0D00A0E1           MOV      R0,SP
   \   0000017C   ........           BL       GUI_RectsIntersect
   \   00000180   000050E3           CMP      R0,#+0
   \   00000184   E3FFFF0A           BEQ      ??_FindNextRect_11
   \   00000188   010019E3           TST      R9,#0x1
   \   0000018C   DDFFFF0A           BEQ      ??_FindNextRect_10
   \   00000190   1C9097E5           LDR      R9,[R7, #+28]
   \   00000194   000059E3           CMP      R9,#+0
   \   00000198   DEFFFF0A           BEQ      ??_FindNextRect_11
   \                     ??_FindNextRect_15:
   \   0000019C   0900A0E1           MOV      R0,R9
   \   000001A0   ........           BL       GUI_ALLOC_h2p
   \   000001A4   00A0A0E1           MOV      R10,R0
   \   000001A8   08208DE2           ADD      R2,SP,#+8
   \   000001AC   0D10A0E1           MOV      R1,SP
   \   000001B0   0900A0E1           MOV      R0,R9
   \   000001B4   ........           BL       _Findx0
   \   000001B8   000050E3           CMP      R0,#+0
   \   000001BC   20909AE5           LDR      R9,[R10, #+32]
   \   000001C0   0180A013           MOVNE    R8,#+1
   \   000001C4   000059E3           CMP      R9,#+0
   \   000001C8   F3FFFF1A           BNE      ??_FindNextRect_15
   \   000001CC   D1FFFFEA           B        ??_FindNextRect_11
    243                goto Find_x0;
    244              }
    245            }
    246            /* Check all children */
    247            if (_Findx0(pAWin->hFirstChild, &r, NULL)) {
   \                     ??_FindNextRect_14:
   \   000001D0   1C0095E5           LDR      R0,[R5, #+28]
   \   000001D4   0070A0E3           MOV      R7,#+0
   \   000001D8   000050E3           CMP      R0,#+0
   \   000001DC   2800000A           BEQ      ??_FindNextRect_16
   \                     ??_FindNextRect_17:
   \   000001E0   ........           BL       GUI_ALLOC_h2p
   \   000001E4   0060A0E1           MOV      R6,R0
   \   000001E8   288096E5           LDR      R8,[R6, #+40]
   \   000001EC   020018E3           TST      R8,#0x2
   \   000001F0   1E00000A           BEQ      ??_FindNextRect_18
   \   000001F4   08008DE2           ADD      R0,SP,#+8
   \   000001F8   0610A0E1           MOV      R1,R6
   \   000001FC   0820A0E3           MOV      R2,#+8
   \   00000200   ........           BL       __aeabi_memcpy
   \   00000204   08108DE2           ADD      R1,SP,#+8
   \   00000208   0D00A0E1           MOV      R0,SP
   \   0000020C   ........           BL       GUI_RectsIntersect
   \   00000210   000050E3           CMP      R0,#+0
   \   00000214   1500000A           BEQ      ??_FindNextRect_18
   \   00000218   010018E3           TST      R8,#0x1
   \   0000021C   0F00000A           BEQ      ??_FindNextRect_19
   \   00000220   1C8096E5           LDR      R8,[R6, #+28]
   \   00000224   000058E3           CMP      R8,#+0
   \   00000228   1000000A           BEQ      ??_FindNextRect_18
   \                     ??_FindNextRect_20:
   \   0000022C   0800A0E1           MOV      R0,R8
   \   00000230   ........           BL       GUI_ALLOC_h2p
   \   00000234   0090A0E1           MOV      R9,R0
   \   00000238   08208DE2           ADD      R2,SP,#+8
   \   0000023C   0D10A0E1           MOV      R1,SP
   \   00000240   0800A0E1           MOV      R0,R8
   \   00000244   ........           BL       _Findx0
   \   00000248   000050E3           CMP      R0,#+0
   \   0000024C   208099E5           LDR      R8,[R9, #+32]
   \   00000250   0170A013           MOVNE    R7,#+1
   \   00000254   000058E3           CMP      R8,#+0
   \   00000258   F3FFFF1A           BNE      ??_FindNextRect_20
   \   0000025C   030000EA           B        ??_FindNextRect_18
   \                     ??_FindNextRect_19:
   \   00000260   FC00DDE1           LDRSH    R0,[SP, #+12]
   \   00000264   0170A0E3           MOV      R7,#+1
   \   00000268   010080E2           ADD      R0,R0,#+1
   \   0000026C   B000CDE1           STRH     R0,[SP, #+0]
   \                     ??_FindNextRect_18:
   \   00000270   200096E5           LDR      R0,[R6, #+32]
   \   00000274   000050E3           CMP      R0,#+0
   \   00000278   D8FFFF1A           BNE      ??_FindNextRect_17
   \   0000027C   000057E3           CMP      R7,#+0
   \   00000280   9CFFFF1A           BNE      ??_FindNextRect_6
    248              goto Find_x0;
    249            }
    250            /* 
    251             STEP 5:
    252               If r.x0 out of right border, this stripe is done. Set next stripe and goto STEP 2
    253               Find out x1 for the given x0, y0, y1
    254            */
    255            r.x1 = _Context.ClientRect.x1;
   \                     ??_FindNextRect_16:
   \   00000284   F800D4E1           LDRSH    R0,[R4, #+8]
    256            if (r.x1 < r.x0) {/* horizontal border reached ? */
   \   00000288   F010DDE1           LDRSH    R1,[SP, #+0]
   \   0000028C   B400CDE1           STRH     R0,[SP, #+4]
   \   00000290   010050E1           CMP      R0,R1
   \   00000294   040000AA           BGE      ??_FindNextRect_21
    257              _Context.CurRect = r;
   \   00000298   00209DE5           LDR      R2,[SP, #+0]
   \   0000029C   04309DE5           LDR      R3,[SP, #+4]
   \   000002A0   0C2084E5           STR      R2,[R4, #+12]
   \   000002A4   103084E5           STR      R3,[R4, #+16]
    258              goto NextStripe;
   \   000002A8   6CFFFFEA           B        ??_FindNextRect_2
    259            }    
    260            /* 
    261             STEP 6:
    262               Find r.x1. We have to Iterate over all windows which are above
    263            */
    264            hParent = _Context.hWin;
   \                     ??_FindNextRect_21:
   \   000002AC   000094E5           LDR      R0,[R4, #+0]
    265            for (; hParent; hParent = pParent->hParent) {
   \   000002B0   000050E3           CMP      R0,#+0
   \   000002B4   2B00000A           BEQ      ??_FindNextRect_22
    266              pParent = WM_H2P(hParent);
   \                     ??_FindNextRect_23:
   \   000002B8   ........           BL       GUI_ALLOC_h2p
   \   000002BC   0060A0E1           MOV      R6,R0
    267              _Findx1(pParent->hNext, &r, NULL);
   \   000002C0   200096E5           LDR      R0,[R6, #+32]
   \   000002C4   000050E3           CMP      R0,#+0
   \   000002C8   2300000A           BEQ      ??_FindNextRect_24
   \                     ??_FindNextRect_25:
   \   000002CC   ........           BL       GUI_ALLOC_h2p
   \   000002D0   0070A0E1           MOV      R7,R0
   \   000002D4   288097E5           LDR      R8,[R7, #+40]
   \   000002D8   020018E3           TST      R8,#0x2
   \   000002DC   1B00000A           BEQ      ??_FindNextRect_26
   \   000002E0   08008DE2           ADD      R0,SP,#+8
   \   000002E4   0710A0E1           MOV      R1,R7
   \   000002E8   0820A0E3           MOV      R2,#+8
   \   000002EC   ........           BL       __aeabi_memcpy
   \   000002F0   08108DE2           ADD      R1,SP,#+8
   \   000002F4   0D00A0E1           MOV      R0,SP
   \   000002F8   ........           BL       GUI_RectsIntersect
   \   000002FC   000050E3           CMP      R0,#+0
   \   00000300   1200000A           BEQ      ??_FindNextRect_26
   \   00000304   010018E3           TST      R8,#0x1
   \   00000308   0D00000A           BEQ      ??_FindNextRect_27
   \   0000030C   1C8097E5           LDR      R8,[R7, #+28]
   \   00000310   000058E3           CMP      R8,#+0
   \   00000314   0D00000A           BEQ      ??_FindNextRect_26
   \                     ??_FindNextRect_28:
   \   00000318   0800A0E1           MOV      R0,R8
   \   0000031C   ........           BL       GUI_ALLOC_h2p
   \   00000320   0090A0E1           MOV      R9,R0
   \   00000324   08208DE2           ADD      R2,SP,#+8
   \   00000328   0D10A0E1           MOV      R1,SP
   \   0000032C   0800A0E1           MOV      R0,R8
   \   00000330   ........           BL       _Findx1
   \   00000334   208099E5           LDR      R8,[R9, #+32]
   \   00000338   000058E3           CMP      R8,#+0
   \   0000033C   F5FFFF1A           BNE      ??_FindNextRect_28
   \   00000340   020000EA           B        ??_FindNextRect_26
   \                     ??_FindNextRect_27:
   \   00000344   F810DDE1           LDRSH    R1,[SP, #+8]
   \   00000348   011041E2           SUB      R1,R1,#+1
   \   0000034C   B410CDE1           STRH     R1,[SP, #+4]
   \                     ??_FindNextRect_26:
   \   00000350   200097E5           LDR      R0,[R7, #+32]
   \   00000354   000050E3           CMP      R0,#+0
   \   00000358   DBFFFF1A           BNE      ??_FindNextRect_25
    268            }
   \                     ??_FindNextRect_24:
   \   0000035C   180096E5           LDR      R0,[R6, #+24]
   \   00000360   000050E3           CMP      R0,#+0
   \   00000364   D3FFFF1A           BNE      ??_FindNextRect_23
    269            /* Check all children */
    270            _Findx1(pAWin->hFirstChild, &r, NULL);
   \                     ??_FindNextRect_22:
   \   00000368   1C0095E5           LDR      R0,[R5, #+28]
   \   0000036C   000050E3           CMP      R0,#+0
   \   00000370   2300000A           BEQ      ??_FindNextRect_29
   \                     ??_FindNextRect_30:
   \   00000374   ........           BL       GUI_ALLOC_h2p
   \   00000378   0050A0E1           MOV      R5,R0
   \   0000037C   286095E5           LDR      R6,[R5, #+40]
   \   00000380   020016E3           TST      R6,#0x2
   \   00000384   1B00000A           BEQ      ??_FindNextRect_31
   \   00000388   08008DE2           ADD      R0,SP,#+8
   \   0000038C   0510A0E1           MOV      R1,R5
   \   00000390   0820A0E3           MOV      R2,#+8
   \   00000394   ........           BL       __aeabi_memcpy
   \   00000398   08108DE2           ADD      R1,SP,#+8
   \   0000039C   0D00A0E1           MOV      R0,SP
   \   000003A0   ........           BL       GUI_RectsIntersect
   \   000003A4   000050E3           CMP      R0,#+0
   \   000003A8   1200000A           BEQ      ??_FindNextRect_31
   \   000003AC   010016E3           TST      R6,#0x1
   \   000003B0   0D00000A           BEQ      ??_FindNextRect_32
   \   000003B4   1C6095E5           LDR      R6,[R5, #+28]
   \   000003B8   000056E3           CMP      R6,#+0
   \   000003BC   0D00000A           BEQ      ??_FindNextRect_31
   \                     ??_FindNextRect_33:
   \   000003C0   0600A0E1           MOV      R0,R6
   \   000003C4   ........           BL       GUI_ALLOC_h2p
   \   000003C8   0070A0E1           MOV      R7,R0
   \   000003CC   08208DE2           ADD      R2,SP,#+8
   \   000003D0   0D10A0E1           MOV      R1,SP
   \   000003D4   0600A0E1           MOV      R0,R6
   \   000003D8   ........           BL       _Findx1
   \   000003DC   206097E5           LDR      R6,[R7, #+32]
   \   000003E0   000056E3           CMP      R6,#+0
   \   000003E4   F5FFFF1A           BNE      ??_FindNextRect_33
   \   000003E8   020000EA           B        ??_FindNextRect_31
   \                     ??_FindNextRect_32:
   \   000003EC   F810DDE1           LDRSH    R1,[SP, #+8]
   \   000003F0   011041E2           SUB      R1,R1,#+1
   \   000003F4   B410CDE1           STRH     R1,[SP, #+4]
   \                     ??_FindNextRect_31:
   \   000003F8   200095E5           LDR      R0,[R5, #+32]
   \   000003FC   000050E3           CMP      R0,#+0
   \   00000400   DBFFFF1A           BNE      ??_FindNextRect_30
    271            /* We are done. Return the rectangle we found in the _Context. */
    272            if (_Context.Cnt > 200) {
   \                     ??_FindNextRect_29:
   \   00000404   140094E5           LDR      R0,[R4, #+20]
   \   00000408   C90050E3           CMP      R0,#+201
   \   0000040C   1CFFFFAA           BGE      ??_FindNextRect_4
    273              return 0;  /* error !!! This should not happen !*/
    274            }
    275            _Context.CurRect = r;
   \   00000410   00209DE5           LDR      R2,[SP, #+0]
   \   00000414   04309DE5           LDR      R3,[SP, #+4]
   \   00000418   0C2084E5           STR      R2,[R4, #+12]
   \   0000041C   103084E5           STR      R3,[R4, #+16]
    276            return 1;
   \   00000420   0100A0E3           MOV      R0,#+1
   \                     ??_FindNextRect_5:
   \   00000424   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   00000428   F087BDE8           POP      {R4-R10,PC}      ;; return
    277          }
    278          
    279          /*********************************************************************
    280          *
    281          *       _GetNextRect
    282          */
    283          static int  _GetNextRect(void) {
    284            if (_Context.EntranceCnt > 1) {
    285              _Context.EntranceCnt--;
    286              return 0;
    287            }
    288            ++_Context.Cnt;
    289            /* Find next rectangle and use it as ClipRect */
    290            if (!_FindNextRect()) {
    291              _Context.EntranceCnt--;  /* This search is over ! */
    292              return 0;        /* Could not find an other one ! */
    293            }
    294            return 1;
    295          }
    296          
    297          /*********************************************************************
    298          *
    299          *       _InitRectSearch
    300          */
    301          static int _InitRectSearch(const GUI_RECT * pMaxRect) {
    302            GUI_RECT r;
    303            WM_Obj * pAWin;
    304            /* If we entered multiple times, leave Cliprect alone */
    305            if (++_Context.EntranceCnt > 1) {
    306              return 1;
    307            }
    308            pAWin = WM_H2P(_Context.hWin);
    309            _Context.Cnt        = -1;
    310            if (pAWin->Status & WM_SF_ISVIS) {
    311              r = pAWin->Rect;
    312            } else {
    313              --_Context.EntranceCnt;
    314              return 0;  /* window is not even visible ! */
    315            }
    316            /* If the drawing routine has specified a rectangle, use it to reduce the rectangle */
    317            if (pMaxRect) {
    318              GUI__IntersectRect(&r, pMaxRect);
    319            }
    320            /* Iterate over all ancestors and clip at their borders. If there is no visible part, we are done */
    321            if (WM__ClipAtParentBorders(&r, _Context.hWin) == 0) {
    322              --_Context.EntranceCnt;
    323              return 0;           /* Nothing to draw */
    324            }
    325            /* Store the rectangle and find the first rectangle of the area */
    326            _Context.ClientRect = r;
    327            return _GetNextRect();
    328          }
    329          
    330          /*********************************************************************
    331          *
    332          *       _IsCompletelyCovered
    333          *
    334          */
    335          static char _IsCompletelyCovered(WM_HWIN hWin) {
    336            GUI_RECT Rect = {0};
    337            Rect.x1 = LCD_GetVXSizeEx(GUI_Context.SelLayer);
    338            Rect.y1 = LCD_GetVYSizeEx(GUI_Context.SelLayer);
    339            _Context.hWin        = hWin;
    340            _Context.EntranceCnt = 0;
    341            if (_InitRectSearch(&Rect)) {
    342              return 0;                 /* Is not completely covered */
    343            }
    344            return 1;                   /* Is completely covered */
    345          }
    346          
    347          /*********************************************************************
    348          *
    349          *       Public code
    350          *
    351          **********************************************************************
    352          */
    353          /*********************************************************************
    354          *
    355          *       WM_IsCompletelyCovered
    356          *
    357          */

   \                                 In section .text, align 4, keep-with-next
    358          char WM_IsCompletelyCovered(WM_HWIN hWin) {
   \                     WM_IsCompletelyCovered:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0040B0E1           MOVS     R4,R0
    359            int r = 0;
   \   0000000C   0050A0E3           MOV      R5,#+0
    360            if (hWin) {
   \   00000010   3500000A           BEQ      ??WM_IsCompletelyCovered_0
    361              WM_LOCK();
   \   00000014   ........           BL       GUI_Lock
    362              r = _IsCompletelyCovered(hWin);
   \   00000018   ........           ADR      R1,`?<Constant {0}>`
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   08008DE2           ADD      R0,SP,#+8
   \   00000028   0C0080E8           STM      R0,{R2,R3}
   \   0000002C   ........           LDR      R6,??DataTable2_1
   \   00000030   1100D6E5           LDRB     R0,[R6, #+17]
   \   00000034   ........           BL       LCD_GetVXSizeEx
   \   00000038   BC00CDE1           STRH     R0,[SP, #+12]
   \   0000003C   1100D6E5           LDRB     R0,[R6, #+17]
   \   00000040   ........           BL       LCD_GetVYSizeEx
   \   00000044   BE00CDE1           STRH     R0,[SP, #+14]
   \   00000048   ........           LDR      R6,??DataTable2
   \   0000004C   0100A0E3           MOV      R0,#+1
   \   00000050   180086E5           STR      R0,[R6, #+24]
   \   00000054   004086E5           STR      R4,[R6, #+0]
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           BL       GUI_ALLOC_h2p
   \   00000060   0010A0E1           MOV      R1,R0
   \   00000064   0500E0E1           MVN      R0,R5
   \   00000068   140086E5           STR      R0,[R6, #+20]
   \   0000006C   2800D1E5           LDRB     R0,[R1, #+40]
   \   00000070   020010E3           TST      R0,#0x2
   \   00000074   1700000A           BEQ      ??WM_IsCompletelyCovered_1
   \   00000078   0D00A0E1           MOV      R0,SP
   \   0000007C   0820A0E3           MOV      R2,#+8
   \   00000080   ........           BL       __aeabi_memcpy
   \   00000084   08108DE2           ADD      R1,SP,#+8
   \   00000088   0D00A0E1           MOV      R0,SP
   \   0000008C   ........           BL       GUI__IntersectRect
   \   00000090   001096E5           LDR      R1,[R6, #+0]
   \   00000094   0D00A0E1           MOV      R0,SP
   \   00000098   ........           BL       WM__ClipAtParentBorders
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   0C00000A           BEQ      ??WM_IsCompletelyCovered_1
   \   000000A4   00209DE5           LDR      R2,[SP, #+0]
   \   000000A8   04309DE5           LDR      R3,[SP, #+4]
   \   000000AC   180096E5           LDR      R0,[R6, #+24]
   \   000000B0   042086E5           STR      R2,[R6, #+4]
   \   000000B4   083086E5           STR      R3,[R6, #+8]
   \   000000B8   020050E3           CMP      R0,#+2
   \   000000BC   050000AA           BGE      ??WM_IsCompletelyCovered_1
   \   000000C0   140096E5           LDR      R0,[R6, #+20]
   \   000000C4   010080E2           ADD      R0,R0,#+1
   \   000000C8   140086E5           STR      R0,[R6, #+20]
   \   000000CC   ........           BL       _FindNextRect
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   0300001A           BNE      ??WM_IsCompletelyCovered_2
   \                     ??WM_IsCompletelyCovered_1:
   \   000000D8   180096E5           LDR      R0,[R6, #+24]
   \   000000DC   0150A0E3           MOV      R5,#+1
   \   000000E0   010040E2           SUB      R0,R0,#+1
   \   000000E4   180086E5           STR      R0,[R6, #+24]
    363              WM_UNLOCK();
   \                     ??WM_IsCompletelyCovered_2:
   \   000000E8   ........           BL       GUI_Unlock
    364            }
    365            return r;
   \                     ??WM_IsCompletelyCovered_0:
   \   000000EC   0500A0E1           MOV      R0,R5
   \   000000F0   10D08DE2           ADD      SP,SP,#+16
   \   000000F4   7080BDE8           POP      {R4-R6,PC}       ;; return
    366          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     _Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   0000               DC16 0
   \   00000002   000000000000       DC8 0, 0, 0, 0, 0, 0
    367          
    368          #else
    369            void WM_IsCompletelyCovered_C(void) {} /* avoid empty object files */
    370          #endif
    371          
    372          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     WM_IsCompletelyCovered     32
     _FindNextRect              48
     _Findx0                    40
     _Findx1                    32
     _Findy1                    32


   Section sizes:

     Function/Label         Bytes
     --------------         -----
     _Context                 28
     _Findy1                 256
     _Findx0                 224
     _Findx1                 204
     _FindNextRect          1068
     WM_IsCompletelyCovered  248
     ??DataTable2              4
     ??DataTable2_1            4
     ?<Constant {0}>           8

 
    28 bytes in section .bss
 2 016 bytes in section .text
 
 2 016 bytes of CODE memory
    28 bytes of DATA memory

Errors: none
Warnings: none
