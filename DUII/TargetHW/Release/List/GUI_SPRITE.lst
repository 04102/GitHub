###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:12:27 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUI_SPRITE.c                        #
#    Command line =  C:\DUII\TargetHW\GUI\GUI_SPRITE.c -D DEBUG=1 -D          #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUI_SPRITE.lst             #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUI_SPRITE.o                #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUI_SPRITE.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUI_SPRITE.c
     19          Purpose     : Contains sprite support
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stddef.h>
     24          #include <string.h>
     25          
     26          #include "GUI_Private.h"
     27          
     28          /*********************************************************************
     29          *
     30          *       Defines
     31          *
     32          **********************************************************************
     33          */
     34          #define SPRITE_LOCK_H(h) (GUI_SPRITE_OBJ *)GUI_LOCK_H(h)
     35          
     36          #define SET_SPRITE_LAYER()           \
     37            Layer    = pDevice->LayerIndex;    \
     38            LayerOld = GUI_Context.SelLayer;   \
     39            if (Layer != LayerOld) {           \
     40              GUI_Context.SelLayer = Layer;    \
     41            }
     42          
     43          #define RESTORE_LAYER()              \
     44            if (Layer != LayerOld) {           \
     45              GUI_Context.SelLayer = LayerOld; \
     46            }
     47          
     48          /*********************************************************************
     49          *
     50          *       Types
     51          *
     52          **********************************************************************
     53          */
     54          // Context used by rectangle calculating
     55          typedef struct {
     56            GUI_RECT * pRectSprite;
     57            GUI_RECT RectDraw;
     58            GUI_RECT RectAll;
     59            int Cnt;
     60          } CLIP_CONTEXT;
     61          
     62          // The sprite object
     63          typedef struct {
     64            GUI_DEVICE * pDevice;
     65            GUI_RECT Rect;
     66            GUI_HMEM hColors;
     67            GUI_HSPRITE hNext;
     68            GUI_HSPRITE hPrev;
     69            U16 Flags;
     70            const GUI_BITMAP GUI_UNI_PTR * pBM;
     71          } GUI_SPRITE_OBJ;
     72          
     73          // Bitmap clipping context
     74          typedef struct {
     75            int Diff_;
     76            int x0_;
     77            int y0_;
     78            int xSize_;
     79            int ySize_;
     80            const U8 GUI_UNI_PTR * pData_;
     81          } CLIP_PARAM;
     82          
     83          /*********************************************************************
     84          *
     85          *       Static code
     86          *
     87          **********************************************************************
     88          */
     89          /*********************************************************************
     90          *
     91          *       _GetClipRect
     92          */

   \                                 In section .text, align 4, keep-with-next
     93          static int _GetClipRect(CLIP_CONTEXT * pContext) {
   \                     _GetClipRect:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
     94            GUI_RECT * pRectSprite;
     95            GUI_RECT * pRectDraw;
     96            int x0, y0, x1, y1;
     97          
     98            pRectSprite = pContext->pRectSprite;
     99            pRectDraw   = &pContext->RectDraw;
    100            x0 = pContext->RectAll.x0;
    101            y0 = pContext->RectAll.y0;
    102            x1 = pContext->RectAll.x1;
    103            y1 = pContext->RectAll.y1;
    104            if (pContext->Cnt == 0) {
   \   00000004   145090E5           LDR      R5,[R0, #+20]
   \   00000008   003090E5           LDR      R3,[R0, #+0]
   \   0000000C   041080E2           ADD      R1,R0,#+4
   \   00000010   FCC0D0E1           LDRSH    R12,[R0, #+12]
   \   00000014   FEE0D0E1           LDRSH    LR,[R0, #+14]
   \   00000018   F041D0E1           LDRSH    R4,[R0, #+16]
   \   0000001C   F221D0E1           LDRSH    R2,[R0, #+18]
   \   00000020   000055E3           CMP      R5,#+0
   \   00000024   1800001A           BNE      ??_GetClipRect_0
   \   00000028   F250D3E1           LDRSH    R5,[R3, #+2]
   \   0000002C   050052E1           CMP      R2,R5
   \   00000030   010000AA           BGE      ??_GetClipRect_1
    105              //
    106              // Check if sprite is completely outside
    107              //
    108              if (y1 < pRectSprite->y0) {
    109                return 0;
   \                     ??_GetClipRect_2:
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   7080BDE8           POP      {R4-R6,PC}       ;; return
    110              }
    111              if (x1 < pRectSprite->x0) {
   \                     ??_GetClipRect_1:
   \   0000003C   F060D3E1           LDRSH    R6,[R3, #+0]
   \   00000040   060054E1           CMP      R4,R6
    112                return 0;
    113              }
    114              if (y0 > pRectSprite->y1) {
   \   00000044   F660D3A1           LDRSHGE  R6,[R3, #+6]
   \   00000048   0E0056A1           CMPGE    R6,LR
    115                return 0;
    116              }
    117              if (x0 > pRectSprite->x1) {
   \   0000004C   F460D3A1           LDRSHGE  R6,[R3, #+4]
   \   00000050   0C0056A1           CMPGE    R6,R12
   \   00000054   F6FFFFBA           BLT      ??_GetClipRect_2
    118                return 0;
    119              }
    120              //
    121              // Part 1, above sprite
    122              //
    123              if (y0 < pRectSprite->y0) {
   \   00000058   0160A0E3           MOV      R6,#+1
   \   0000005C   05005EE1           CMP      LR,R5
   \   00000060   070000AA           BGE      ??_GetClipRect_3
    124                pRectDraw->y0 = y0;
   \   00000064   B2E0C1E1           STRH     LR,[R1, #+2]
    125                pRectDraw->y1 = pRectSprite->y0 - 1;
   \   00000068   F220D3E1           LDRSH    R2,[R3, #+2]
   \   0000006C   012042E2           SUB      R2,R2,#+1
   \   00000070   B620C1E1           STRH     R2,[R1, #+6]
    126                pRectDraw->x0 = x0;
   \   00000074   B0C0C1E1           STRH     R12,[R1, #+0]
    127                pRectDraw->x1 = x1;
   \   00000078   B440C1E1           STRH     R4,[R1, #+4]
    128                pContext->Cnt++;
   \   0000007C   146080E5           STR      R6,[R0, #+20]
    129                return 1;
   \   00000080   150000EA           B        ??_GetClipRect_4
    130              }
    131              pContext->Cnt++;
   \                     ??_GetClipRect_3:
   \   00000084   146080E5           STR      R6,[R0, #+20]
   \   00000088   010000EA           B        ??_GetClipRect_5
    132            }
    133            if (pContext->Cnt == 1) {
   \                     ??_GetClipRect_0:
   \   0000008C   010055E3           CMP      R5,#+1
   \   00000090   1600001A           BNE      ??_GetClipRect_6
    134              //
    135              // Part 2, left of sprite
    136              //
    137              if (x0 < pRectSprite->x0) {
   \                     ??_GetClipRect_5:
   \   00000094   F050D3E1           LDRSH    R5,[R3, #+0]
   \   00000098   05005CE1           CMP      R12,R5
   \   0000009C   100000AA           BGE      ??_GetClipRect_7
    138                pRectDraw->x0 = x0;
   \   000000A0   B0C0C1E1           STRH     R12,[R1, #+0]
    139                pRectDraw->x1 = pRectSprite->x0 - 1;
   \   000000A4   F0C0D3E1           LDRSH    R12,[R3, #+0]
   \   000000A8   01C04CE2           SUB      R12,R12,#+1
   \   000000AC   B4C0C1E1           STRH     R12,[R1, #+4]
    140                if (y0 < pRectSprite->y0) {
   \                     ??_GetClipRect_8:
   \   000000B0   F2C0D3E1           LDRSH    R12,[R3, #+2]
   \   000000B4   0C005EE1           CMP      LR,R12
    141                  pRectDraw->y0 = pRectSprite->y0;
   \   000000B8   0CE0A0B1           MOVLT    LR,R12
    142                } else {
    143                  pRectDraw->y0 = y0;
   \   000000BC   B2E0C1E1           STRH     LR,[R1, #+2]
    144                }
    145                if (y1 > pRectSprite->y1) {
   \   000000C0   F630D3E1           LDRSH    R3,[R3, #+6]
   \   000000C4   020053E1           CMP      R3,R2
    146                  pRectDraw->y1 = pRectSprite->y1;
   \   000000C8   0320A0B1           MOVLT    R2,R3
    147                } else {
    148                  pRectDraw->y1 = y1;
   \   000000CC   B620C1E1           STRH     R2,[R1, #+6]
    149                }
    150                pContext->Cnt++;
   \   000000D0   141090E5           LDR      R1,[R0, #+20]
   \   000000D4   011081E2           ADD      R1,R1,#+1
   \   000000D8   141080E5           STR      R1,[R0, #+20]
    151                return 1;
   \                     ??_GetClipRect_4:
   \   000000DC   0100A0E3           MOV      R0,#+1
   \   000000E0   7080BDE8           POP      {R4-R6,PC}
    152              }
    153              pContext->Cnt++;
   \                     ??_GetClipRect_7:
   \   000000E4   0250A0E3           MOV      R5,#+2
   \   000000E8   145080E5           STR      R5,[R0, #+20]
   \   000000EC   010000EA           B        ??_GetClipRect_9
    154            }
    155            if (pContext->Cnt == 2) {
   \                     ??_GetClipRect_6:
   \   000000F0   020055E3           CMP      R5,#+2
   \   000000F4   0A00001A           BNE      ??_GetClipRect_10
    156              //
    157              // Part 2, right of sprite
    158              //
    159              if (x1 > pRectSprite->x1) {
   \                     ??_GetClipRect_9:
   \   000000F8   F450D3E1           LDRSH    R5,[R3, #+4]
   \   000000FC   040055E1           CMP      R5,R4
   \   00000100   040000AA           BGE      ??_GetClipRect_11
    160                pRectDraw->x1 = x1;
   \   00000104   B440C1E1           STRH     R4,[R1, #+4]
    161                pRectDraw->x0 = pRectSprite->x1 + 1;
   \   00000108   F4C0D3E1           LDRSH    R12,[R3, #+4]
   \   0000010C   01C08CE2           ADD      R12,R12,#+1
   \   00000110   B0C0C1E1           STRH     R12,[R1, #+0]
    162                if (y0 < pRectSprite->y0) {
   \   00000114   E5FFFFEA           B        ??_GetClipRect_8
    163                  pRectDraw->y0 = pRectSprite->y0;
    164                } else {
    165                  pRectDraw->y0 = y0;
    166                }
    167                if (y1 > pRectSprite->y1) {
    168                  pRectDraw->y1 = pRectSprite->y1;
    169                } else {
    170                  pRectDraw->y1 = y1;
    171                }
    172                pContext->Cnt++;
    173                return 1;
    174              }
    175              pContext->Cnt++;
   \                     ??_GetClipRect_11:
   \   00000118   03E0A0E3           MOV      LR,#+3
   \   0000011C   14E080E5           STR      LR,[R0, #+20]
   \   00000120   010000EA           B        ??_GetClipRect_12
    176            }
    177            if (pContext->Cnt == 3) {
   \                     ??_GetClipRect_10:
   \   00000124   030055E3           CMP      R5,#+3
   \   00000128   C1FFFF1A           BNE      ??_GetClipRect_2
    178              //
    179              // Part 4, below sprite
    180              //
    181              if (y1 > pRectSprite->y1) {
   \                     ??_GetClipRect_12:
   \   0000012C   F630D3E1           LDRSH    R3,[R3, #+6]
   \   00000130   04E0A0E3           MOV      LR,#+4
   \   00000134   020053E1           CMP      R3,R2
   \   00000138   060000AA           BGE      ??_GetClipRect_13
    182                pRectDraw->y0 = pRectSprite->y1 + 1;
   \   0000013C   013083E2           ADD      R3,R3,#+1
   \   00000140   B230C1E1           STRH     R3,[R1, #+2]
    183                pRectDraw->y1 = y1;
   \   00000144   B620C1E1           STRH     R2,[R1, #+6]
    184                pRectDraw->x0 = x0;
   \   00000148   B0C0C1E1           STRH     R12,[R1, #+0]
    185                pRectDraw->x1 = x1;
   \   0000014C   B440C1E1           STRH     R4,[R1, #+4]
    186                pContext->Cnt++;
   \   00000150   14E080E5           STR      LR,[R0, #+20]
    187                return 1;
   \   00000154   E0FFFFEA           B        ??_GetClipRect_4
    188              }
    189              pContext->Cnt++;
   \                     ??_GetClipRect_13:
   \   00000158   14E080E5           STR      LR,[R0, #+20]
   \   0000015C   B4FFFFEA           B        ??_GetClipRect_2
    190            }
    191            return 0; // Nothing else to do...
    192          }
    193          
    194          /*********************************************************************
    195          *
    196          *       _GetClipParam
    197          */

   \                                 In section .text, align 4, keep-with-next
    198          static int _GetClipParam(int x0, int y0,
    199                                   int xSize, int ySize,
    200                                   int BitsPerPixel, 
    201                                   int BytesPerLine,
    202                                   const U8 GUI_UNI_PTR * pData, 
    203                                   int Diff,
    204                                   const GUI_RECT * pRect,
    205                                   CLIP_PARAM * p)
    206          {
   \                     _GetClipParam:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   28409DE5           LDR      R4,[SP, #+40]
   \   00000008   14C09DE5           LDR      R12,[SP, #+20]
   \   0000000C   18609DE5           LDR      R6,[SP, #+24]
   \   00000010   1C709DE5           LDR      R7,[SP, #+28]
   \   00000014   20509DE5           LDR      R5,[SP, #+32]
   \   00000018   24E09DE5           LDR      LR,[SP, #+36]
    207            int x1, y1;
    208            p->x0_    = x0;
   \   0000001C   040084E5           STR      R0,[R4, #+4]
    209            p->y0_    = y0;
   \   00000020   081084E5           STR      R1,[R4, #+8]
    210            p->xSize_ = xSize;
   \   00000024   0C2084E5           STR      R2,[R4, #+12]
    211            p->ySize_ = ySize;
   \   00000028   103084E5           STR      R3,[R4, #+16]
    212            p->pData_ = pData;
    213            y1 = y0 + ySize - 1;
    214            x1 = x0 + xSize - 1;
   \   0000002C   000082E0           ADD      R0,R2,R0
   \   00000030   147084E5           STR      R7,[R4, #+20]
   \   00000034   012040E2           SUB      R2,R0,#+1
   \   00000038   F200DEE1           LDRSH    R0,[LR, #+2]
   \   0000003C   013083E0           ADD      R3,R3,R1
   \   00000040   013043E2           SUB      R3,R3,#+1
   \   00000044   011040E0           SUB      R1,R0,R1
   \   00000048   001084E5           STR      R1,[R4, #+0]
    215            // Clip y0 (top)
    216            p->Diff_ = pRect->y0 - y0;
    217            if (p->Diff_ > 0) {
   \   0000004C   010051E3           CMP      R1,#+1
   \   00000050   080000BA           BLT      ??_GetClipParam_1
    218              p->ySize_ -= p->Diff_;
   \   00000054   107094E5           LDR      R7,[R4, #+16]
   \   00000058   017047E0           SUB      R7,R7,R1
   \   0000005C   107084E5           STR      R7,[R4, #+16]
    219              if (p->ySize_ <= 0) {
   \   00000060   010057E3           CMP      R7,#+1
   \   00000064   630000BA           BLT      ??_GetClipParam_2
    220          		  return 1;
    221              }
    222              p->y0_     = pRect->y0;
   \                     ??_GetClipParam_3:
   \   00000068   080084E5           STR      R0,[R4, #+8]
    223              #if GUI_SUPPORT_LARGE_BITMAPS // Required only for 16 bit CPUs if some bitmaps are >64kByte
    224                p->pData_ += (U32)     p->Diff_ * (U32)     BytesPerLine;
   \   0000006C   140094E5           LDR      R0,[R4, #+20]
   \   00000070   960120E0           MLA      R0,R6,R1,R0
   \   00000074   140084E5           STR      R0,[R4, #+20]
    225              #else
    226                p->pData_ += (unsigned)p->Diff_ * (unsigned)BytesPerLine;
    227              #endif
    228            }
    229            // Clip y1 (bottom)
    230            p->Diff_ = y1 - pRect->y1;
   \                     ??_GetClipParam_1:
   \   00000078   F600DEE1           LDRSH    R0,[LR, #+6]
   \   0000007C   000043E0           SUB      R0,R3,R0
   \   00000080   000084E5           STR      R0,[R4, #+0]
    231            if (p->Diff_ > 0) {
   \   00000084   010050E3           CMP      R0,#+1
   \   00000088   040000BA           BLT      ??_GetClipParam_4
    232              p->ySize_ -= p->Diff_;
   \   0000008C   101094E5           LDR      R1,[R4, #+16]
   \   00000090   000041E0           SUB      R0,R1,R0
   \   00000094   100084E5           STR      R0,[R4, #+16]
    233              if (p->ySize_ <= 0) {
   \   00000098   010050E3           CMP      R0,#+1
   \   0000009C   550000BA           BLT      ??_GetClipParam_2
   \                     ??_GetClipParam_4:
   \   000000A0   F400DEE1           LDRSH    R0,[LR, #+4]
    234          		  return 1;
    235              }
    236            }
    237            // Clip right side
    238            p->Diff_ = x1 - pRect->x1;
    239            if (p->Diff_ > 0) {
    240              p->xSize_ -= p->Diff_;
    241            }
    242            // Clip left side
    243            p->Diff_ = Diff;
   \   000000A4   0530A0E1           MOV      R3,R5
   \   000000A8   002042E0           SUB      R2,R2,R0
   \   000000AC   002084E5           STR      R2,[R4, #+0]
   \   000000B0   0C1094E5           LDR      R1,[R4, #+12]
    244            if (p->x0_ < pRect->x0) {
   \   000000B4   F0E0DEE1           LDRSH    LR,[LR, #+0]
   \   000000B8   010052E3           CMP      R2,#+1
   \   000000BC   046094E5           LDR      R6,[R4, #+4]
   \   000000C0   021041A0           SUBGE    R1,R1,R2
   \   000000C4   142094E5           LDR      R2,[R4, #+20]
   \   000000C8   0E0056E1           CMP      R6,LR
   \   000000CC   3C0000AA           BGE      ??_GetClipParam_5
    245              p->Diff_ = pRect->x0 - p->x0_;
   \   000000D0   06304EE0           SUB      R3,LR,R6
    246          		p->xSize_ += Diff;
    247          		p->xSize_ -= p->Diff_;
   \   000000D4   011085E0           ADD      R1,R5,R1
    248          		switch (BitsPerPixel) {
   \   000000D8   01C04CE2           SUB      R12,R12,#+1
   \   000000DC   031041E0           SUB      R1,R1,R3
   \   000000E0   1F005CE3           CMP      R12,#+31
   \   000000E4   0CF18F90           ADDLS    PC,PC,R12, LSL #+2
   \                     ??_GetClipParam_0:
   \   000000E8   3500008A           BHI      ??_GetClipParam_5
   \   000000EC   1E0000EA           B        ??_GetClipParam_6
   \   000000F0   220000EA           B        ??_GetClipParam_7
   \   000000F4   320000EA           B        ??_GetClipParam_5
   \   000000F8   250000EA           B        ??_GetClipParam_8
   \   000000FC   300000EA           B        ??_GetClipParam_5
   \   00000100   2F0000EA           B        ??_GetClipParam_5
   \   00000104   2E0000EA           B        ??_GetClipParam_5
   \   00000108   260000EA           B        ??_GetClipParam_9
   \   0000010C   2C0000EA           B        ??_GetClipParam_5
   \   00000110   2B0000EA           B        ??_GetClipParam_5
   \   00000114   2A0000EA           B        ??_GetClipParam_5
   \   00000118   290000EA           B        ??_GetClipParam_5
   \   0000011C   280000EA           B        ??_GetClipParam_5
   \   00000120   270000EA           B        ??_GetClipParam_5
   \   00000124   260000EA           B        ??_GetClipParam_5
   \   00000128   200000EA           B        ??_GetClipParam_10
   \   0000012C   240000EA           B        ??_GetClipParam_5
   \   00000130   230000EA           B        ??_GetClipParam_5
   \   00000134   220000EA           B        ??_GetClipParam_5
   \   00000138   210000EA           B        ??_GetClipParam_5
   \   0000013C   200000EA           B        ??_GetClipParam_5
   \   00000140   1F0000EA           B        ??_GetClipParam_5
   \   00000144   1E0000EA           B        ??_GetClipParam_5
   \   00000148   1A0000EA           B        ??_GetClipParam_11
   \   0000014C   1C0000EA           B        ??_GetClipParam_5
   \   00000150   1B0000EA           B        ??_GetClipParam_5
   \   00000154   1A0000EA           B        ??_GetClipParam_5
   \   00000158   190000EA           B        ??_GetClipParam_5
   \   0000015C   180000EA           B        ??_GetClipParam_5
   \   00000160   170000EA           B        ??_GetClipParam_5
   \   00000164   160000EA           B        ??_GetClipParam_5
   \   00000168   120000EA           B        ??_GetClipParam_11
    249          		case 1:
    250            		p->pData_ += (p->Diff_ >> 3); p->x0_ += (p->Diff_ >> 3) << 3; p->Diff_ &= 7;
   \                     ??_GetClipParam_6:
   \   0000016C   C3C1A0E1           ASR      R12,R3,#+3
   \   00000170   02208CE0           ADD      R2,R12,R2
   \   00000174   8C6186E0           ADD      R6,R6,R12, LSL #+3
   \   00000178   073003E2           AND      R3,R3,#0x7
    251          			break;
   \   0000017C   100000EA           B        ??_GetClipParam_5
    252          		case 2:
    253          	  	p->pData_ += (p->Diff_ >> 2); p->x0_ += (p->Diff_ >> 2) << 2; p->Diff_ &= 3;
   \                     ??_GetClipParam_7:
   \   00000180   43C1A0E1           ASR      R12,R3,#+2
   \   00000184   02208CE0           ADD      R2,R12,R2
   \   00000188   0C6186E0           ADD      R6,R6,R12, LSL #+2
   \   0000018C   033003E2           AND      R3,R3,#0x3
    254          			break;
   \   00000190   0B0000EA           B        ??_GetClipParam_5
    255          		case 4:
    256          			p->pData_ += (p->Diff_ >> 1); p->x0_ += (p->Diff_ >> 1) << 1; p->Diff_ &= 1;
   \                     ??_GetClipParam_8:
   \   00000194   C3C0A0E1           ASR      R12,R3,#+1
   \   00000198   02208CE0           ADD      R2,R12,R2
   \   0000019C   8C6086E0           ADD      R6,R6,R12, LSL #+1
   \   000001A0   013003E2           AND      R3,R3,#0x1
    257          			break;
   \   000001A4   060000EA           B        ??_GetClipParam_5
    258          		case 8:
    259          			p->pData_ +=  p->Diff_;       p->x0_ +=  p->Diff_; p->Diff_ = 0;
   \                     ??_GetClipParam_9:
   \   000001A8   022083E0           ADD      R2,R3,R2
   \   000001AC   020000EA           B        ??_GetClipParam_12
    260          			break;
    261          		case 16:
    262          			p->pData_ += (p->Diff_ << 1); p->x0_ +=  p->Diff_; p->Diff_ = 0;
   \                     ??_GetClipParam_10:
   \   000001B0   832082E0           ADD      R2,R2,R3, LSL #+1
   \   000001B4   000000EA           B        ??_GetClipParam_12
    263          			break;
    264          		case 24:
    265              case 32:
    266          			p->pData_ += (p->Diff_ << 2); p->x0_ +=  p->Diff_; p->Diff_ = 0;
   \                     ??_GetClipParam_11:
   \   000001B8   032182E0           ADD      R2,R2,R3, LSL #+2
   \                     ??_GetClipParam_12:
   \   000001BC   066083E0           ADD      R6,R3,R6
   \   000001C0   0030A0E3           MOV      R3,#+0
    267          			break;
   \                     ??_GetClipParam_5:
   \   000001C4   142084E5           STR      R2,[R4, #+20]
   \   000001C8   046084E5           STR      R6,[R4, #+4]
   \   000001CC   003084E5           STR      R3,[R4, #+0]
    268          		}
    269            }
    270            if ((p->x0_ + p->Diff_ + p->xSize_) > pRect->x1) {
   \   000001D0   042094E5           LDR      R2,[R4, #+4]
   \   000001D4   02C083E0           ADD      R12,R3,R2
   \   000001D8   0CC081E0           ADD      R12,R1,R12
   \   000001DC   0C0050E1           CMP      R0,R12
    271              p->xSize_ = pRect->x1 - (p->x0_ + p->Diff_) + 1;
   \   000001E0   020040B0           SUBLT    R0,R0,R2
   \   000001E4   030040B0           SUBLT    R0,R0,R3
   \   000001E8   011080B2           ADDLT    R1,R0,#+1
   \   000001EC   0C1084E5           STR      R1,[R4, #+12]
    272            }
    273            if (p->xSize_ <= 0) {
   \   000001F0   010051E3           CMP      R1,#+1
   \   000001F4   010000AA           BGE      ??_GetClipParam_13
    274          		return 1;
   \                     ??_GetClipParam_2:
   \   000001F8   0100A0E3           MOV      R0,#+1
   \   000001FC   F080BDE8           POP      {R4-R7,PC}
    275            }
    276            return 0;
   \                     ??_GetClipParam_13:
   \   00000200   0000A0E3           MOV      R0,#+0
   \   00000204   F080BDE8           POP      {R4-R7,PC}       ;; return
    277          }
    278          
    279          /*********************************************************************
    280          *
    281          *       _PixelExists
    282          */
    283          static int _PixelExists(int x, int y, GUI_SPRITE_OBJ * pSprite) {
    284            const GUI_BITMAP GUI_UNI_PTR * pBM;
    285            pBM = pSprite->pBM;
    286            if ((x >= pSprite->Rect.x0) && (y >= pSprite->Rect.y0)) {
    287              if (((x - pSprite->Rect.x0 + 1) <= pBM->XSize) && ((y - pSprite->Rect.y0 + 1) <= pBM->YSize)) {
    288                if (GUI_GetBitmapPixelIndex(pBM, x - pSprite->Rect.x0, y - pSprite->Rect.y0) != 0) {
    289                  return 1;
    290                }
    291              }
    292            }
    293            return 0;
    294          }
    295          
    296          /*********************************************************************
    297          *
    298          *       GUI_DEVICE_API functions: _DrawBitmap
    299          */

   \                                 In section .text, align 4, keep-with-next
    300          static void _DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0,
    301                                 int xSize, int ySize,
    302                                 int BitsPerPixel, 
    303                                 int BytesPerLine,
    304                                 const U8 * pData, int Diff,
    305                                 const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitmap:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   5CD04DE2           SUB      SP,SP,#+92
   \   00000008   00B0A0E1           MOV      R11,R0
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   0360A0E1           MOV      R6,R3
   \   00000018   80709DE5           LDR      R7,[SP, #+128]
   \   0000001C   88809DE5           LDR      R8,[SP, #+136]
   \   00000020   94909DE5           LDR      R9,[SP, #+148]
    306            CLIP_CONTEXT Context = {0};
   \   00000024   40008DE2           ADD      R0,SP,#+64
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   0020A0E3           MOV      R2,#+0
   \   00000030   0030A0E3           MOV      R3,#+0
   \   00000034   0E00A0E8           STM      R0!,{R1-R3}
   \   00000038   0E00A0E8           STM      R0!,{R1-R3}
    307            GUI_SPRITE_OBJ * pSprite;
    308            CLIP_PARAM Param;
    309            LCD_PIXELINDEX Index, IndexMask;
    310            const GUI_BITMAP GUI_UNI_PTR * pBM;
    311            LCD_PIXELINDEX * pSave;
    312            int x, y, xSizeSprite;
    313            GUI_RECT Rect;
    314            GUI_RECT * pRect;
    315          
    316            pSprite             = SPRITE_LOCK_H(pDevice->u.hContext);
   \   0000003C   08009BE5           LDR      R0,[R11, #+8]
   \   00000040   ........           BL       GUI_ALLOC_LockH
   \   00000044   00A0A0E1           MOV      R10,R0
    317            xSizeSprite         = pSprite->Rect.x1 - pSprite->Rect.x0 + 1;
   \   00000048   F800DAE1           LDRSH    R0,[R10, #+8]
   \   0000004C   F410DAE1           LDRSH    R1,[R10, #+4]
   \   00000050   010040E0           SUB      R0,R0,R1
   \   00000054   010080E2           ADD      R0,R0,#+1
   \   00000058   24008DE5           STR      R0,[SP, #+36]
    318            pBM                 = pSprite->pBM;
   \   0000005C   1C009AE5           LDR      R0,[R10, #+28]
    319            Context.pRectSprite = &pSprite->Rect;
    320            pDevice             = pDevice->pNext;
    321            Context.RectAll.x0  = x0 + Diff;
   \   00000060   90109DE5           LDR      R1,[SP, #+144]
   \   00000064   20008DE5           STR      R0,[SP, #+32]
   \   00000068   04008AE2           ADD      R0,R10,#+4
   \   0000006C   40008DE5           STR      R0,[SP, #+64]
   \   00000070   00B09BE5           LDR      R11,[R11, #+0]
   \   00000074   040081E0           ADD      R0,R1,R4
   \   00000078   BC04CDE1           STRH     R0,[SP, #+76]
    322            Context.RectAll.y0  = y0;
    323            Context.RectAll.x1  = x0 + Diff + xSize - 1 ;
   \   0000007C   000086E0           ADD      R0,R6,R0
   \   00000080   010040E2           SUB      R0,R0,#+1
   \   00000084   B005CDE1           STRH     R0,[SP, #+80]
    324            Context.RectAll.y1  = y0 + ySize - 1;
   \   00000088   050087E0           ADD      R0,R7,R5
   \   0000008C   010040E2           SUB      R0,R0,#+1
   \   00000090   B205CDE1           STRH     R0,[SP, #+82]
   \   00000094   BE54CDE1           STRH     R5,[SP, #+78]
    325            if (GUI_RectsIntersect(&Context.RectAll, Context.pRectSprite)) {
   \   00000098   40109DE5           LDR      R1,[SP, #+64]
   \   0000009C   4C008DE2           ADD      R0,SP,#+76
   \   000000A0   ........           BL       GUI_RectsIntersect
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   3500001A           BNE      ??_DrawBitmap_4
    326              //
    327              // Draw pixels outside of sprite
    328              //
    329              while (_GetClipRect(&Context)) {
    330                if (_GetClipParam(x0, y0, xSize, ySize, BitsPerPixel, BytesPerLine, pData, Diff, &Context.RectDraw, &Param)) {
    331                  continue;
    332                }
    333                pDevice->pDeviceAPI->pfDrawBitmap(pDevice, Param.x0_, Param.y0_, Param.xSize_, Param.ySize_, BitsPerPixel, BytesPerLine, Param.pData_, Param.Diff_, pTrans);
    334              }
    335              //
    336              // Draw pixels inside of sprite
    337              //
    338              Rect    = *Context.pRectSprite;
    339              if (GUI_RectsIntersect(&Rect, &Context.RectAll)) {
    340                GUI__IntersectRect(&Rect, &Context.RectAll);
    341                pRect  = &Rect;
    342                if (_GetClipParam(x0, y0, xSize, ySize, BitsPerPixel, BytesPerLine, pData, Diff, pRect, &Param) == 0) {
    343                  IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
    344                  for (y = pRect->y0; y <= pRect->y1; y++) {
    345                    for (x = pRect->x0; x <= pRect->x1; x++) {
    346                      //
    347                      // Get index value of pixel to be drawn
    348                      //
    349                      Index = GUI_GetBitmapPixelIndexEx(BitsPerPixel, BytesPerLine, Param.pData_, x - Param.x0_, y - Param.y0_);
    350                      //
    351                      // Check if sprite pixel exists
    352                      //
    353                      if (GUI_GetBitmapPixelIndex(pBM, x - pSprite->Rect.x0, y - pSprite->Rect.y0) != 0) {
    354                        //
    355                        // Sprite pixel exist on current position, so store output in sprite buffer
    356                        //
    357                        pSave = (LCD_PIXELINDEX *)((U8 *)pSprite + sizeof(GUI_SPRITE_OBJ));
    358                        pSave += xSizeSprite * (y - pSprite->Rect.y0) + (x - pSprite->Rect.x0);
    359                        if (pTrans) {
    360                          switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    361                          case 0:
    362                            *pSave = *(pTrans + Index);
    363                            break;
    364                          case LCD_DRAWMODE_TRANS:
    365                            if (Index) {
    366                              *pSave = *(pTrans + Index);
    367                            }
    368                            break;
    369                          case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    370                          case LCD_DRAWMODE_XOR:
    371                            *pSave = *(pTrans + Index) ^ IndexMask;
    372                            break;
    373                          }
    374                        } else {
    375                          switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    376                          case 0:
    377                            *pSave = Index;
    378                            break;
    379                          case LCD_DRAWMODE_TRANS:
    380                            if (Index) {
    381                              *pSave = Index;
    382                            }
    383                            break;
    384                          case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    385                          case LCD_DRAWMODE_XOR:
    386                            *pSave = Index ^ IndexMask;
    387                            break;
    388                          }
    389                        }
    390                      } else {
    391                        //
    392                        // No sprite pixel on current position, so draw it
    393                        //
    394                        if (pTrans) {
    395                          switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    396                          case 0:
    397                            pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x, y, *(pTrans + Index));
    398                            break;
    399                          case LCD_DRAWMODE_TRANS:
    400                            if (Index) {
    401                              pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x, y, *(pTrans + Index));
    402                            }
    403                            break;
    404                          case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    405                          case LCD_DRAWMODE_XOR:
    406                            pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x, y, *(pTrans + Index) ^ IndexMask);
    407                            break;
    408                          }
    409                        } else {
    410                          switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    411                          case 0:
    412                            pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x, y, Index);
    413                            break;
    414                          case LCD_DRAWMODE_TRANS:
    415                            if (Index) {
    416                              pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x, y, Index);
    417                            }
    418                            break;
    419                          case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    420                          case LCD_DRAWMODE_XOR:
    421                            pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x, y, Index ^ IndexMask);
    422                            break;
    423                          }
    424                        }
    425                      }
    426                    }
    427                  }
    428                }
    429              }
    430            } else {
    431              pDevice->pDeviceAPI->pfDrawBitmap(pDevice, x0, y0, xSize, ySize, BitsPerPixel, BytesPerLine, pData, Diff, pTrans);
   \   000000AC   90009DE5           LDR      R0,[SP, #+144]
   \   000000B0   14908DE5           STR      R9,[SP, #+20]
   \   000000B4   10008DE5           STR      R0,[SP, #+16]
   \   000000B8   8C009DE5           LDR      R0,[SP, #+140]
   \   000000BC   08808DE5           STR      R8,[SP, #+8]
   \   000000C0   0C008DE5           STR      R0,[SP, #+12]
   \   000000C4   84009DE5           LDR      R0,[SP, #+132]
   \   000000C8   00708DE5           STR      R7,[SP, #+0]
   \   000000CC   04008DE5           STR      R0,[SP, #+4]
   \   000000D0   0CC09BE5           LDR      R12,[R11, #+12]
   \   000000D4   0630A0E1           MOV      R3,R6
   \   000000D8   0520A0E1           MOV      R2,R5
   \   000000DC   0410A0E1           MOV      R1,R4
   \   000000E0   0B00A0E1           MOV      R0,R11
   \   000000E4   04C09CE5           LDR      R12,[R12, #+4]
   \   000000E8   3CFF2FE1           BLX      R12
    432            }
    433            GUI_UNLOCK_H(pSprite);
   \                     ??_DrawBitmap_5:
   \   000000EC   ........           BL       GUI_ALLOC_UnlockH
    434          }
   \   000000F0   5CD08DE2           ADD      SP,SP,#+92       ;; stack cleaning
   \   000000F4   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??_DrawBitmap_6:
   \   000000F8   28008DE2           ADD      R0,SP,#+40
   \   000000FC   14008DE5           STR      R0,[SP, #+20]
   \   00000100   44008DE2           ADD      R0,SP,#+68
   \   00000104   10008DE5           STR      R0,[SP, #+16]
   \   00000108   90009DE5           LDR      R0,[SP, #+144]
   \   0000010C   04808DE5           STR      R8,[SP, #+4]
   \   00000110   0C008DE5           STR      R0,[SP, #+12]
   \   00000114   8C009DE5           LDR      R0,[SP, #+140]
   \   00000118   0730A0E1           MOV      R3,R7
   \   0000011C   08008DE5           STR      R0,[SP, #+8]
   \   00000120   84009DE5           LDR      R0,[SP, #+132]
   \   00000124   0620A0E1           MOV      R2,R6
   \   00000128   00008DE5           STR      R0,[SP, #+0]
   \   0000012C   0510A0E1           MOV      R1,R5
   \   00000130   0400A0E1           MOV      R0,R4
   \   00000134   ........           BL       _GetClipParam
   \   00000138   000050E3           CMP      R0,#+0
   \   0000013C   1000001A           BNE      ??_DrawBitmap_4
   \   00000140   28009DE5           LDR      R0,[SP, #+40]
   \   00000144   14908DE5           STR      R9,[SP, #+20]
   \   00000148   10008DE5           STR      R0,[SP, #+16]
   \   0000014C   3C009DE5           LDR      R0,[SP, #+60]
   \   00000150   08808DE5           STR      R8,[SP, #+8]
   \   00000154   0C008DE5           STR      R0,[SP, #+12]
   \   00000158   84009DE5           LDR      R0,[SP, #+132]
   \   0000015C   34309DE5           LDR      R3,[SP, #+52]
   \   00000160   04008DE5           STR      R0,[SP, #+4]
   \   00000164   38009DE5           LDR      R0,[SP, #+56]
   \   00000168   30209DE5           LDR      R2,[SP, #+48]
   \   0000016C   00008DE5           STR      R0,[SP, #+0]
   \   00000170   0CC09BE5           LDR      R12,[R11, #+12]
   \   00000174   2C109DE5           LDR      R1,[SP, #+44]
   \   00000178   0B00A0E1           MOV      R0,R11
   \   0000017C   04C09CE5           LDR      R12,[R12, #+4]
   \   00000180   3CFF2FE1           BLX      R12
   \                     ??_DrawBitmap_4:
   \   00000184   40008DE2           ADD      R0,SP,#+64
   \   00000188   ........           BL       _GetClipRect
   \   0000018C   000050E3           CMP      R0,#+0
   \   00000190   D8FFFF1A           BNE      ??_DrawBitmap_6
   \   00000194   18008DE2           ADD      R0,SP,#+24
   \   00000198   40109DE5           LDR      R1,[SP, #+64]
   \   0000019C   0820A0E3           MOV      R2,#+8
   \   000001A0   ........           BL       __aeabi_memcpy
   \   000001A4   4C108DE2           ADD      R1,SP,#+76
   \   000001A8   18008DE2           ADD      R0,SP,#+24
   \   000001AC   ........           BL       GUI_RectsIntersect
   \   000001B0   000050E3           CMP      R0,#+0
   \   000001B4   CCFFFF0A           BEQ      ??_DrawBitmap_5
   \   000001B8   4C108DE2           ADD      R1,SP,#+76
   \   000001BC   18008DE2           ADD      R0,SP,#+24
   \   000001C0   ........           BL       GUI__IntersectRect
   \   000001C4   28008DE2           ADD      R0,SP,#+40
   \   000001C8   14008DE5           STR      R0,[SP, #+20]
   \   000001CC   18008DE2           ADD      R0,SP,#+24
   \   000001D0   10008DE5           STR      R0,[SP, #+16]
   \   000001D4   90009DE5           LDR      R0,[SP, #+144]
   \   000001D8   04808DE5           STR      R8,[SP, #+4]
   \   000001DC   0C008DE5           STR      R0,[SP, #+12]
   \   000001E0   8C009DE5           LDR      R0,[SP, #+140]
   \   000001E4   0730A0E1           MOV      R3,R7
   \   000001E8   08008DE5           STR      R0,[SP, #+8]
   \   000001EC   84009DE5           LDR      R0,[SP, #+132]
   \   000001F0   0620A0E1           MOV      R2,R6
   \   000001F4   00008DE5           STR      R0,[SP, #+0]
   \   000001F8   0510A0E1           MOV      R1,R5
   \   000001FC   0400A0E1           MOV      R0,R4
   \   00000200   ........           BL       _GetClipParam
   \   00000204   000050E3           CMP      R0,#+0
   \   00000208   B7FFFF1A           BNE      ??_DrawBitmap_5
   \   0000020C   10009BE5           LDR      R0,[R11, #+16]
   \   00000210   080090E5           LDR      R0,[R0, #+8]
   \   00000214   30FF2FE1           BLX      R0
   \   00000218   0040A0E1           MOV      R4,R0
   \   0000021C   FA51DDE1           LDRSH    R5,[SP, #+26]
   \   00000220   FE01DDE1           LDRSH    R0,[SP, #+30]
   \   00000224   050050E1           CMP      R0,R5
   \   00000228   AFFFFFBA           BLT      ??_DrawBitmap_5
   \                     ??_DrawBitmap_7:
   \   0000022C   F861DDE1           LDRSH    R6,[SP, #+24]
   \   00000230   FC01DDE1           LDRSH    R0,[SP, #+28]
   \   00000234   060050E1           CMP      R0,R6
   \   00000238   670000BA           BLT      ??_DrawBitmap_8
   \                     ??_DrawBitmap_9:
   \   0000023C   30009DE5           LDR      R0,[SP, #+48]
   \   00000240   3C209DE5           LDR      R2,[SP, #+60]
   \   00000244   000045E0           SUB      R0,R5,R0
   \   00000248   00008DE5           STR      R0,[SP, #+0]
   \   0000024C   2C009DE5           LDR      R0,[SP, #+44]
   \   00000250   0810A0E1           MOV      R1,R8
   \   00000254   003046E0           SUB      R3,R6,R0
   \   00000258   84009DE5           LDR      R0,[SP, #+132]
   \   0000025C   ........           BL       GUI_GetBitmapPixelIndexEx
   \   00000260   0070A0E1           MOV      R7,R0
   \   00000264   F600DAE1           LDRSH    R0,[R10, #+6]
   \   00000268   002045E0           SUB      R2,R5,R0
   \   0000026C   F400DAE1           LDRSH    R0,[R10, #+4]
   \   00000270   001046E0           SUB      R1,R6,R0
   \   00000274   20009DE5           LDR      R0,[SP, #+32]
   \   00000278   ........           BL       GUI_GetBitmapPixelIndex
   \   0000027C   000050E3           CMP      R0,#+0
   \   00000280   2A00000A           BEQ      ??_DrawBitmap_10
   \   00000284   F610DAE1           LDRSH    R1,[R10, #+6]
   \   00000288   24009DE5           LDR      R0,[SP, #+36]
   \   0000028C   000059E3           CMP      R9,#+0
   \   00000290   011045E0           SUB      R1,R5,R1
   \   00000294   916020E0           MLA      R0,R1,R0,R6
   \   00000298   F410DAE1           LDRSH    R1,[R10, #+4]
   \   0000029C   010040E0           SUB      R0,R0,R1
   \   000002A0   ........           LDR      R1,??DataTable10
   \   000002A4   00018AE0           ADD      R0,R10,R0, LSL #+2
   \   000002A8   1010D1E5           LDRB     R1,[R1, #+16]
   \   000002AC   200080E2           ADD      R0,R0,#+32
   \   000002B0   031001E2           AND      R1,R1,#0x3
   \   000002B4   0F00000A           BEQ      ??_DrawBitmap_11
   \   000002B8   030051E3           CMP      R1,#+3
   \   000002BC   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitmap_0:
   \   000002C0   4100008A           BHI      ??_DrawBitmap_12
   \   000002C4   020000EA           B        ??_DrawBitmap_13
   \   000002C8   070000EA           B        ??_DrawBitmap_14
   \   000002CC   030000EA           B        ??_DrawBitmap_15
   \   000002D0   050000EA           B        ??_DrawBitmap_14
   \                     ??_DrawBitmap_13:
   \   000002D4   071199E7           LDR      R1,[R9, +R7, LSL #+2]
   \                     ??_DrawBitmap_16:
   \   000002D8   001080E5           STR      R1,[R0, #+0]
   \   000002DC   3A0000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_15:
   \   000002E0   000057E3           CMP      R7,#+0
   \   000002E4   FAFFFF1A           BNE      ??_DrawBitmap_13
   \   000002E8   370000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_14:
   \   000002EC   071199E7           LDR      R1,[R9, +R7, LSL #+2]
   \   000002F0   011024E0           EOR      R1,R4,R1
   \   000002F4   F7FFFFEA           B        ??_DrawBitmap_16
   \                     ??_DrawBitmap_11:
   \   000002F8   030051E3           CMP      R1,#+3
   \   000002FC   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitmap_1:
   \   00000300   3100008A           BHI      ??_DrawBitmap_12
   \   00000304   020000EA           B        ??_DrawBitmap_17
   \   00000308   060000EA           B        ??_DrawBitmap_18
   \   0000030C   020000EA           B        ??_DrawBitmap_19
   \   00000310   040000EA           B        ??_DrawBitmap_18
   \                     ??_DrawBitmap_17:
   \   00000314   007080E5           STR      R7,[R0, #+0]
   \   00000318   2B0000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_19:
   \   0000031C   000057E3           CMP      R7,#+0
   \   00000320   2900000A           BEQ      ??_DrawBitmap_12
   \   00000324   FAFFFFEA           B        ??_DrawBitmap_17
   \                     ??_DrawBitmap_18:
   \   00000328   071024E0           EOR      R1,R4,R7
   \   0000032C   E9FFFFEA           B        ??_DrawBitmap_16
   \                     ??_DrawBitmap_10:
   \   00000330   ........           LDR      R0,??DataTable10
   \   00000334   000059E3           CMP      R9,#+0
   \   00000338   1000D0E5           LDRB     R0,[R0, #+16]
   \   0000033C   031000E2           AND      R1,R0,#0x3
   \   00000340   0E00000A           BEQ      ??_DrawBitmap_20
   \   00000344   030051E3           CMP      R1,#+3
   \   00000348   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitmap_2:
   \   0000034C   1E00008A           BHI      ??_DrawBitmap_12
   \   00000350   020000EA           B        ??_DrawBitmap_21
   \   00000354   060000EA           B        ??_DrawBitmap_22
   \   00000358   020000EA           B        ??_DrawBitmap_23
   \   0000035C   040000EA           B        ??_DrawBitmap_22
   \                     ??_DrawBitmap_21:
   \   00000360   073199E7           LDR      R3,[R9, +R7, LSL #+2]
   \   00000364   120000EA           B        ??_DrawBitmap_24
   \                     ??_DrawBitmap_23:
   \   00000368   000057E3           CMP      R7,#+0
   \   0000036C   FBFFFF1A           BNE      ??_DrawBitmap_21
   \   00000370   150000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_22:
   \   00000374   070199E7           LDR      R0,[R9, +R7, LSL #+2]
   \   00000378   003024E0           EOR      R3,R4,R0
   \   0000037C   0C0000EA           B        ??_DrawBitmap_24
   \                     ??_DrawBitmap_20:
   \   00000380   030051E3           CMP      R1,#+3
   \   00000384   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitmap_3:
   \   00000388   0F00008A           BHI      ??_DrawBitmap_12
   \   0000038C   020000EA           B        ??_DrawBitmap_25
   \   00000390   060000EA           B        ??_DrawBitmap_26
   \   00000394   020000EA           B        ??_DrawBitmap_27
   \   00000398   040000EA           B        ??_DrawBitmap_26
   \                     ??_DrawBitmap_25:
   \   0000039C   0730A0E1           MOV      R3,R7
   \   000003A0   030000EA           B        ??_DrawBitmap_24
   \                     ??_DrawBitmap_27:
   \   000003A4   000057E3           CMP      R7,#+0
   \   000003A8   FBFFFF1A           BNE      ??_DrawBitmap_25
   \   000003AC   060000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_26:
   \   000003B0   073024E0           EOR      R3,R4,R7
   \                     ??_DrawBitmap_24:
   \   000003B4   0CC09BE5           LDR      R12,[R11, #+12]
   \   000003B8   0520A0E1           MOV      R2,R5
   \   000003BC   0610A0E1           MOV      R1,R6
   \   000003C0   0B00A0E1           MOV      R0,R11
   \   000003C4   18C09CE5           LDR      R12,[R12, #+24]
   \   000003C8   3CFF2FE1           BLX      R12
   \                     ??_DrawBitmap_12:
   \   000003CC   FC01DDE1           LDRSH    R0,[SP, #+28]
   \   000003D0   016086E2           ADD      R6,R6,#+1
   \   000003D4   060050E1           CMP      R0,R6
   \   000003D8   97FFFFAA           BGE      ??_DrawBitmap_9
   \                     ??_DrawBitmap_8:
   \   000003DC   FE01DDE1           LDRSH    R0,[SP, #+30]
   \   000003E0   015085E2           ADD      R5,R5,#+1
   \   000003E4   050050E1           CMP      R0,R5
   \   000003E8   3FFFFFBA           BLT      ??_DrawBitmap_5
   \   000003EC   8EFFFFEA           B        ??_DrawBitmap_7
    435          
    436          /*********************************************************************
    437          *
    438          *       GUI_DEVICE_API functions: _DrawHLine
    439          */

   \                                 In section .text, align 4, keep-with-next
    440          static void _DrawHLine(GUI_DEVICE * pDevice, int x0, int y,  int x1) {
   \                     _DrawHLine:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
   \   00000008   00A0A0E1           MOV      R10,R0
   \   0000000C   0180A0E1           MOV      R8,R1
   \   00000010   0240A0E1           MOV      R4,R2
   \   00000014   0390A0E1           MOV      R9,R3
    441            CLIP_CONTEXT Context = {0};
   \   00000018   08008DE2           ADD      R0,SP,#+8
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   0020A0E3           MOV      R2,#+0
   \   00000024   0030A0E3           MOV      R3,#+0
   \   00000028   0E00A0E8           STM      R0!,{R1-R3}
   \   0000002C   0E00A0E8           STM      R0!,{R1-R3}
    442            GUI_SPRITE_OBJ * pSprite;
    443            const GUI_BITMAP GUI_UNI_PTR * pBM;
    444            LCD_PIXELINDEX * pSave;
    445            int x, xSizeSprite;
    446            GUI_RECT Rect;
    447          
    448            pSprite             = SPRITE_LOCK_H(pDevice->u.hContext);
   \   00000030   08009AE5           LDR      R0,[R10, #+8]
   \   00000034   ........           BL       GUI_ALLOC_LockH
   \   00000038   0050A0E1           MOV      R5,R0
    449            xSizeSprite         = pSprite->Rect.x1 - pSprite->Rect.x0 + 1;
   \   0000003C   F800D5E1           LDRSH    R0,[R5, #+8]
   \   00000040   F410D5E1           LDRSH    R1,[R5, #+4]
    450            pBM                 = pSprite->pBM;
   \   00000044   1C7095E5           LDR      R7,[R5, #+28]
   \   00000048   010040E0           SUB      R0,R0,R1
   \   0000004C   016080E2           ADD      R6,R0,#+1
    451            Context.pRectSprite = &pSprite->Rect;
   \   00000050   040085E2           ADD      R0,R5,#+4
   \   00000054   08008DE5           STR      R0,[SP, #+8]
    452            pDevice             = pDevice->pNext;
   \   00000058   00A09AE5           LDR      R10,[R10, #+0]
    453            Context.RectAll.x0  = x0;
   \   0000005C   B481CDE1           STRH     R8,[SP, #+20]
    454            Context.RectAll.y0  = y;
   \   00000060   B641CDE1           STRH     R4,[SP, #+22]
    455            Context.RectAll.x1  = x1;
   \   00000064   B891CDE1           STRH     R9,[SP, #+24]
    456            Context.RectAll.y1  = y;
   \   00000068   BA41CDE1           STRH     R4,[SP, #+26]
    457            if (GUI_RectsIntersect(&Context.RectAll, Context.pRectSprite)) {
   \   0000006C   08109DE5           LDR      R1,[SP, #+8]
   \   00000070   14008DE2           ADD      R0,SP,#+20
   \   00000074   ........           BL       GUI_RectsIntersect
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   1000001A           BNE      ??_DrawHLine_0
    458              //
    459              // Draw pixels outside of sprite
    460              //
    461              while (_GetClipRect(&Context)) {
    462                pDevice->pDeviceAPI->pfDrawHLine(pDevice, Context.RectDraw.x0, Context.RectDraw.y0, Context.RectDraw.x1);
    463              }
    464              //
    465              // Draw pixels inside of sprite
    466              //
    467              Rect    = *Context.pRectSprite;
    468              if (GUI_RectsIntersect(&Rect, &Context.RectAll)) {
    469                GUI__IntersectRect(&Rect, &Context.RectAll);
    470                for (x = Rect.x0; x <= Rect.x1; x++) {
    471                  if (GUI_GetBitmapPixelIndex(pBM, x - pSprite->Rect.x0, y - pSprite->Rect.y0) != 0) {
    472                    //
    473                    // Sprite pixel exist on current position, so store output in sprite buffer
    474                    //
    475                    pSave = (LCD_PIXELINDEX *)((U8 *)pSprite + sizeof(GUI_SPRITE_OBJ));
    476                    pSave += xSizeSprite * (Rect.y0 - pSprite->Rect.y0) + (x - pSprite->Rect.x0);
    477                    *pSave = LCD__GetColorIndex();
    478                  } else {
    479                    pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x, y, LCD__GetColorIndex());
    480                  }
    481                }
    482              }
    483            } else {
    484              pDevice->pDeviceAPI->pfDrawHLine(pDevice, x0, y,  x1);
   \   00000080   0CC09AE5           LDR      R12,[R10, #+12]
   \   00000084   0930A0E1           MOV      R3,R9
   \   00000088   0420A0E1           MOV      R2,R4
   \   0000008C   0810A0E1           MOV      R1,R8
   \   00000090   0A00A0E1           MOV      R0,R10
   \   00000094   08C09CE5           LDR      R12,[R12, #+8]
   \   00000098   3CFF2FE1           BLX      R12
    485            }
    486            GUI_UNLOCK_H(pSprite);
   \                     ??_DrawHLine_1:
   \   0000009C   ........           BL       GUI_ALLOC_UnlockH
    487          }
   \   000000A0   20D08DE2           ADD      SP,SP,#+32       ;; stack cleaning
   \   000000A4   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??_DrawHLine_2:
   \   000000A8   0CC09AE5           LDR      R12,[R10, #+12]
   \   000000AC   F031DDE1           LDRSH    R3,[SP, #+16]
   \   000000B0   FE20DDE1           LDRSH    R2,[SP, #+14]
   \   000000B4   FC10DDE1           LDRSH    R1,[SP, #+12]
   \   000000B8   0A00A0E1           MOV      R0,R10
   \   000000BC   08C09CE5           LDR      R12,[R12, #+8]
   \   000000C0   3CFF2FE1           BLX      R12
   \                     ??_DrawHLine_0:
   \   000000C4   08008DE2           ADD      R0,SP,#+8
   \   000000C8   ........           BL       _GetClipRect
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   F4FFFF1A           BNE      ??_DrawHLine_2
   \   000000D4   0D00A0E1           MOV      R0,SP
   \   000000D8   08109DE5           LDR      R1,[SP, #+8]
   \   000000DC   0820A0E3           MOV      R2,#+8
   \   000000E0   ........           BL       __aeabi_memcpy
   \   000000E4   14108DE2           ADD      R1,SP,#+20
   \   000000E8   0D00A0E1           MOV      R0,SP
   \   000000EC   ........           BL       GUI_RectsIntersect
   \   000000F0   000050E3           CMP      R0,#+0
   \   000000F4   E8FFFF0A           BEQ      ??_DrawHLine_1
   \   000000F8   14108DE2           ADD      R1,SP,#+20
   \   000000FC   0D00A0E1           MOV      R0,SP
   \   00000100   ........           BL       GUI__IntersectRect
   \   00000104   F080DDE1           LDRSH    R8,[SP, #+0]
   \   00000108   F400DDE1           LDRSH    R0,[SP, #+4]
   \   0000010C   080050E1           CMP      R0,R8
   \   00000110   E1FFFFBA           BLT      ??_DrawHLine_1
   \                     ??_DrawHLine_3:
   \   00000114   F600D5E1           LDRSH    R0,[R5, #+6]
   \   00000118   002044E0           SUB      R2,R4,R0
   \   0000011C   F400D5E1           LDRSH    R0,[R5, #+4]
   \   00000120   001048E0           SUB      R1,R8,R0
   \   00000124   0700A0E1           MOV      R0,R7
   \   00000128   ........           BL       GUI_GetBitmapPixelIndex
   \   0000012C   000050E3           CMP      R0,#+0
   \   00000130   0B00000A           BEQ      ??_DrawHLine_4
   \   00000134   F200DDE1           LDRSH    R0,[SP, #+2]
   \   00000138   F610D5E1           LDRSH    R1,[R5, #+6]
   \   0000013C   010040E0           SUB      R0,R0,R1
   \   00000140   908621E0           MLA      R1,R0,R6,R8
   \   00000144   F400D5E1           LDRSH    R0,[R5, #+4]
   \   00000148   000041E0           SUB      R0,R1,R0
   \   0000014C   ........           LDR      R1,??DataTable11
   \   00000150   000185E0           ADD      R0,R5,R0, LSL #+2
   \   00000154   001091E5           LDR      R1,[R1, #+0]
   \   00000158   001091E5           LDR      R1,[R1, #+0]
   \   0000015C   201080E5           STR      R1,[R0, #+32]
   \   00000160   080000EA           B        ??_DrawHLine_5
   \                     ??_DrawHLine_4:
   \   00000164   ........           LDR      R0,??DataTable11
   \   00000168   0CC09AE5           LDR      R12,[R10, #+12]
   \   0000016C   000090E5           LDR      R0,[R0, #+0]
   \   00000170   0420A0E1           MOV      R2,R4
   \   00000174   003090E5           LDR      R3,[R0, #+0]
   \   00000178   0810A0E1           MOV      R1,R8
   \   0000017C   0A00A0E1           MOV      R0,R10
   \   00000180   18C09CE5           LDR      R12,[R12, #+24]
   \   00000184   3CFF2FE1           BLX      R12
   \                     ??_DrawHLine_5:
   \   00000188   F400DDE1           LDRSH    R0,[SP, #+4]
   \   0000018C   018088E2           ADD      R8,R8,#+1
   \   00000190   080050E1           CMP      R0,R8
   \   00000194   DEFFFFAA           BGE      ??_DrawHLine_3
   \   00000198   BFFFFFEA           B        ??_DrawHLine_1
    488          
    489          /*********************************************************************
    490          *
    491          *       GUI_DEVICE_API functions: _DrawVLine
    492          */

   \                                 In section .text, align 4, keep-with-next
    493          static void _DrawVLine(GUI_DEVICE * pDevice, int x, int y0,  int y1) {
   \                     _DrawVLine:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
   \   00000008   00A0A0E1           MOV      R10,R0
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0280A0E1           MOV      R8,R2
   \   00000014   0390A0E1           MOV      R9,R3
    494            CLIP_CONTEXT Context = {0};
   \   00000018   08008DE2           ADD      R0,SP,#+8
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   0020A0E3           MOV      R2,#+0
   \   00000024   0030A0E3           MOV      R3,#+0
   \   00000028   0E00A0E8           STM      R0!,{R1-R3}
   \   0000002C   0E00A0E8           STM      R0!,{R1-R3}
    495            GUI_SPRITE_OBJ * pSprite;
    496            const GUI_BITMAP GUI_UNI_PTR * pBM;
    497            LCD_PIXELINDEX * pSave;
    498            int y, xSizeSprite;
    499            GUI_RECT Rect;
    500          
    501            pSprite             = SPRITE_LOCK_H(pDevice->u.hContext);
   \   00000030   08009AE5           LDR      R0,[R10, #+8]
   \   00000034   ........           BL       GUI_ALLOC_LockH
   \   00000038   0050A0E1           MOV      R5,R0
    502            xSizeSprite         = pSprite->Rect.x1 - pSprite->Rect.x0 + 1;
   \   0000003C   F800D5E1           LDRSH    R0,[R5, #+8]
   \   00000040   F410D5E1           LDRSH    R1,[R5, #+4]
    503            pBM                 = pSprite->pBM;
   \   00000044   1C7095E5           LDR      R7,[R5, #+28]
   \   00000048   010040E0           SUB      R0,R0,R1
   \   0000004C   016080E2           ADD      R6,R0,#+1
    504            Context.pRectSprite = &pSprite->Rect;
   \   00000050   040085E2           ADD      R0,R5,#+4
   \   00000054   08008DE5           STR      R0,[SP, #+8]
    505            pDevice             = pDevice->pNext;
   \   00000058   00A09AE5           LDR      R10,[R10, #+0]
    506            Context.RectAll.x0  = x;
   \   0000005C   B441CDE1           STRH     R4,[SP, #+20]
    507            Context.RectAll.y0  = y0;
   \   00000060   B681CDE1           STRH     R8,[SP, #+22]
    508            Context.RectAll.x1  = x;
   \   00000064   B841CDE1           STRH     R4,[SP, #+24]
    509            Context.RectAll.y1  = y1;
   \   00000068   BA91CDE1           STRH     R9,[SP, #+26]
    510            if (GUI_RectsIntersect(&Context.RectAll, Context.pRectSprite)) {
   \   0000006C   08109DE5           LDR      R1,[SP, #+8]
   \   00000070   14008DE2           ADD      R0,SP,#+20
   \   00000074   ........           BL       GUI_RectsIntersect
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   1000001A           BNE      ??_DrawVLine_0
    511              //
    512              // Draw pixels outside of sprite
    513              //
    514              while (_GetClipRect(&Context)) {
    515                pDevice->pDeviceAPI->pfDrawVLine(pDevice, Context.RectDraw.x0, Context.RectDraw.y0, Context.RectDraw.y1);
    516              }
    517              //
    518              // Draw pixels inside of sprite
    519              //
    520              Rect    = *Context.pRectSprite;
    521              if (GUI_RectsIntersect(&Rect, &Context.RectAll)) {
    522                GUI__IntersectRect(&Rect, &Context.RectAll);
    523                for (y = Rect.y0; y <= Rect.y1; y++) {
    524                  if (GUI_GetBitmapPixelIndex(pBM, x - pSprite->Rect.x0, y - pSprite->Rect.y0) != 0) {
    525                    //
    526                    // Sprite pixel exist on current position, so store output in sprite buffer
    527                    //
    528                    pSave = (LCD_PIXELINDEX *)((U8 *)pSprite + sizeof(GUI_SPRITE_OBJ));
    529                    pSave += xSizeSprite * (y - pSprite->Rect.y0) + (x - pSprite->Rect.x0);
    530                    *pSave = LCD__GetColorIndex();
    531                  } else {
    532                    pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x, y, LCD__GetColorIndex());
    533                  }
    534                }
    535              }
    536            } else {
    537              pDevice->pDeviceAPI->pfDrawVLine(pDevice, x, y0,  y1);
   \   00000080   0CC09AE5           LDR      R12,[R10, #+12]
   \   00000084   0930A0E1           MOV      R3,R9
   \   00000088   0820A0E1           MOV      R2,R8
   \   0000008C   0410A0E1           MOV      R1,R4
   \   00000090   0A00A0E1           MOV      R0,R10
   \   00000094   0CC09CE5           LDR      R12,[R12, #+12]
   \   00000098   3CFF2FE1           BLX      R12
    538            }
    539            GUI_UNLOCK_H(pSprite);
   \                     ??_DrawVLine_1:
   \   0000009C   ........           BL       GUI_ALLOC_UnlockH
    540          }
   \   000000A0   20D08DE2           ADD      SP,SP,#+32       ;; stack cleaning
   \   000000A4   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??_DrawVLine_2:
   \   000000A8   0CC09AE5           LDR      R12,[R10, #+12]
   \   000000AC   F231DDE1           LDRSH    R3,[SP, #+18]
   \   000000B0   FE20DDE1           LDRSH    R2,[SP, #+14]
   \   000000B4   FC10DDE1           LDRSH    R1,[SP, #+12]
   \   000000B8   0A00A0E1           MOV      R0,R10
   \   000000BC   0CC09CE5           LDR      R12,[R12, #+12]
   \   000000C0   3CFF2FE1           BLX      R12
   \                     ??_DrawVLine_0:
   \   000000C4   08008DE2           ADD      R0,SP,#+8
   \   000000C8   ........           BL       _GetClipRect
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   F4FFFF1A           BNE      ??_DrawVLine_2
   \   000000D4   0D00A0E1           MOV      R0,SP
   \   000000D8   08109DE5           LDR      R1,[SP, #+8]
   \   000000DC   0820A0E3           MOV      R2,#+8
   \   000000E0   ........           BL       __aeabi_memcpy
   \   000000E4   14108DE2           ADD      R1,SP,#+20
   \   000000E8   0D00A0E1           MOV      R0,SP
   \   000000EC   ........           BL       GUI_RectsIntersect
   \   000000F0   000050E3           CMP      R0,#+0
   \   000000F4   E8FFFF0A           BEQ      ??_DrawVLine_1
   \   000000F8   14108DE2           ADD      R1,SP,#+20
   \   000000FC   0D00A0E1           MOV      R0,SP
   \   00000100   ........           BL       GUI__IntersectRect
   \   00000104   F280DDE1           LDRSH    R8,[SP, #+2]
   \   00000108   F600DDE1           LDRSH    R0,[SP, #+6]
   \   0000010C   080050E1           CMP      R0,R8
   \   00000110   E1FFFFBA           BLT      ??_DrawVLine_1
   \                     ??_DrawVLine_3:
   \   00000114   F600D5E1           LDRSH    R0,[R5, #+6]
   \   00000118   002048E0           SUB      R2,R8,R0
   \   0000011C   F400D5E1           LDRSH    R0,[R5, #+4]
   \   00000120   001044E0           SUB      R1,R4,R0
   \   00000124   0700A0E1           MOV      R0,R7
   \   00000128   ........           BL       GUI_GetBitmapPixelIndex
   \   0000012C   000050E3           CMP      R0,#+0
   \   00000130   0A00000A           BEQ      ??_DrawVLine_4
   \   00000134   F600D5E1           LDRSH    R0,[R5, #+6]
   \   00000138   000048E0           SUB      R0,R8,R0
   \   0000013C   904621E0           MLA      R1,R0,R6,R4
   \   00000140   F400D5E1           LDRSH    R0,[R5, #+4]
   \   00000144   000041E0           SUB      R0,R1,R0
   \   00000148   ........           LDR      R1,??DataTable11
   \   0000014C   000185E0           ADD      R0,R5,R0, LSL #+2
   \   00000150   001091E5           LDR      R1,[R1, #+0]
   \   00000154   001091E5           LDR      R1,[R1, #+0]
   \   00000158   201080E5           STR      R1,[R0, #+32]
   \   0000015C   080000EA           B        ??_DrawVLine_5
   \                     ??_DrawVLine_4:
   \   00000160   ........           LDR      R0,??DataTable11
   \   00000164   0CC09AE5           LDR      R12,[R10, #+12]
   \   00000168   000090E5           LDR      R0,[R0, #+0]
   \   0000016C   0820A0E1           MOV      R2,R8
   \   00000170   003090E5           LDR      R3,[R0, #+0]
   \   00000174   0410A0E1           MOV      R1,R4
   \   00000178   0A00A0E1           MOV      R0,R10
   \   0000017C   18C09CE5           LDR      R12,[R12, #+24]
   \   00000180   3CFF2FE1           BLX      R12
   \                     ??_DrawVLine_5:
   \   00000184   F600DDE1           LDRSH    R0,[SP, #+6]
   \   00000188   018088E2           ADD      R8,R8,#+1
   \   0000018C   080050E1           CMP      R0,R8
   \   00000190   DFFFFFAA           BGE      ??_DrawVLine_3
   \   00000194   C0FFFFEA           B        ??_DrawVLine_1
    541          
    542          /*********************************************************************
    543          *
    544          *       GUI_DEVICE_API functions: _FillRect
    545          */

   \                                 In section .text, align 4, keep-with-next
    546          static void _FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   24D04DE2           SUB      SP,SP,#+36
   \   00000008   00B0A0E1           MOV      R11,R0
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   0360A0E1           MOV      R6,R3
   \   00000018   48709DE5           LDR      R7,[SP, #+72]
    547            CLIP_CONTEXT Context = {0};
   \   0000001C   0C008DE2           ADD      R0,SP,#+12
   \   00000020   0010A0E3           MOV      R1,#+0
   \   00000024   0020A0E3           MOV      R2,#+0
   \   00000028   0030A0E3           MOV      R3,#+0
   \   0000002C   0E00A0E8           STM      R0!,{R1-R3}
   \   00000030   0E00A0E8           STM      R0!,{R1-R3}
    548            GUI_SPRITE_OBJ * pSprite;
    549            const GUI_BITMAP GUI_UNI_PTR * pBM;
    550            LCD_PIXELINDEX * pSave;
    551            int x, y, xSizeSprite;
    552            GUI_RECT Rect;
    553            GUI_RECT * pRect;
    554          
    555            pSprite             = SPRITE_LOCK_H(pDevice->u.hContext);
   \   00000034   08009BE5           LDR      R0,[R11, #+8]
   \   00000038   ........           BL       GUI_ALLOC_LockH
   \   0000003C   0080A0E1           MOV      R8,R0
    556            xSizeSprite         = pSprite->Rect.x1 - pSprite->Rect.x0 + 1;
   \   00000040   F800D8E1           LDRSH    R0,[R8, #+8]
   \   00000044   F410D8E1           LDRSH    R1,[R8, #+4]
    557            pBM                 = pSprite->pBM;
   \   00000048   1CA098E5           LDR      R10,[R8, #+28]
   \   0000004C   010040E0           SUB      R0,R0,R1
   \   00000050   019080E2           ADD      R9,R0,#+1
    558            Context.pRectSprite = &pSprite->Rect;
   \   00000054   040088E2           ADD      R0,R8,#+4
   \   00000058   0C008DE5           STR      R0,[SP, #+12]
    559            pDevice             = pDevice->pNext;
   \   0000005C   00B09BE5           LDR      R11,[R11, #+0]
    560            Context.RectAll.x0  = x0;
   \   00000060   B841CDE1           STRH     R4,[SP, #+24]
    561            Context.RectAll.y0  = y0;
   \   00000064   BA51CDE1           STRH     R5,[SP, #+26]
    562            Context.RectAll.x1  = x1;
   \   00000068   BC61CDE1           STRH     R6,[SP, #+28]
    563            Context.RectAll.y1  = y1;
   \   0000006C   BE71CDE1           STRH     R7,[SP, #+30]
    564            if (GUI_RectsIntersect(&Context.RectAll, Context.pRectSprite)) {
   \   00000070   0C109DE5           LDR      R1,[SP, #+12]
   \   00000074   18008DE2           ADD      R0,SP,#+24
   \   00000078   ........           BL       GUI_RectsIntersect
   \   0000007C   000050E3           CMP      R0,#+0
   \   00000080   1300001A           BNE      ??_FillRect_0
    565              //
    566              // Draw pixels outside of sprite
    567              //
    568              while (_GetClipRect(&Context)) {
    569                pDevice->pDeviceAPI->pfFillRect(pDevice, Context.RectDraw.x0, Context.RectDraw.y0, Context.RectDraw.x1, Context.RectDraw.y1);
    570              }
    571              //
    572              // Draw pixels inside of sprite
    573              //
    574              Rect    = *Context.pRectSprite;
    575              if (GUI_RectsIntersect(&Rect, &Context.RectAll)) {
    576                GUI__IntersectRect(&Rect, &Context.RectAll);
    577                pRect  = &Rect;
    578                for (y = pRect->y0; y <= pRect->y1; y++) {
    579                  for (x = pRect->x0; x <= pRect->x1; x++) {
    580                    if (GUI_GetBitmapPixelIndex(pBM, x - pSprite->Rect.x0, y - pSprite->Rect.y0) != 0) {
    581                      //
    582                      // Sprite pixel exist on current position, so store output in sprite buffer
    583                      //
    584                      pSave = (LCD_PIXELINDEX *)((U8 *)pSprite + sizeof(GUI_SPRITE_OBJ));
    585                      pSave += xSizeSprite * (y - pSprite->Rect.y0) + (x - pSprite->Rect.x0);
    586                      *pSave = LCD__GetColorIndex();
    587                    } else {
    588                      //
    589                      // No sprite pixel on current position, so draw it
    590                      //
    591                      pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x, y, LCD__GetColorIndex());
    592                    }
    593                  }
    594                }
    595              }
    596            } else {
    597              pDevice->pDeviceAPI->pfFillRect(pDevice, x0, y0, x1, y1);
   \   00000084   00708DE5           STR      R7,[SP, #+0]
   \   00000088   0CC09BE5           LDR      R12,[R11, #+12]
   \   0000008C   0630A0E1           MOV      R3,R6
   \   00000090   0520A0E1           MOV      R2,R5
   \   00000094   0410A0E1           MOV      R1,R4
   \   00000098   0B00A0E1           MOV      R0,R11
   \   0000009C   10C09CE5           LDR      R12,[R12, #+16]
   \   000000A0   3CFF2FE1           BLX      R12
    598            }
    599            GUI_UNLOCK_H(pSprite);
   \                     ??_FillRect_1:
   \   000000A4   ........           BL       GUI_ALLOC_UnlockH
    600          }
   \   000000A8   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   000000AC   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??_FillRect_2:
   \   000000B0   F601DDE1           LDRSH    R0,[SP, #+22]
   \   000000B4   F431DDE1           LDRSH    R3,[SP, #+20]
   \   000000B8   F221DDE1           LDRSH    R2,[SP, #+18]
   \   000000BC   00008DE5           STR      R0,[SP, #+0]
   \   000000C0   0CC09BE5           LDR      R12,[R11, #+12]
   \   000000C4   F011DDE1           LDRSH    R1,[SP, #+16]
   \   000000C8   0B00A0E1           MOV      R0,R11
   \   000000CC   10C09CE5           LDR      R12,[R12, #+16]
   \   000000D0   3CFF2FE1           BLX      R12
   \                     ??_FillRect_0:
   \   000000D4   0C008DE2           ADD      R0,SP,#+12
   \   000000D8   ........           BL       _GetClipRect
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   F2FFFF1A           BNE      ??_FillRect_2
   \   000000E4   04008DE2           ADD      R0,SP,#+4
   \   000000E8   0C109DE5           LDR      R1,[SP, #+12]
   \   000000EC   0820A0E3           MOV      R2,#+8
   \   000000F0   ........           BL       __aeabi_memcpy
   \   000000F4   18108DE2           ADD      R1,SP,#+24
   \   000000F8   04008DE2           ADD      R0,SP,#+4
   \   000000FC   ........           BL       GUI_RectsIntersect
   \   00000100   000050E3           CMP      R0,#+0
   \   00000104   E6FFFF0A           BEQ      ??_FillRect_1
   \   00000108   18108DE2           ADD      R1,SP,#+24
   \   0000010C   04008DE2           ADD      R0,SP,#+4
   \   00000110   ........           BL       GUI__IntersectRect
   \   00000114   F640DDE1           LDRSH    R4,[SP, #+6]
   \   00000118   FA00DDE1           LDRSH    R0,[SP, #+10]
   \   0000011C   040050E1           CMP      R0,R4
   \   00000120   DFFFFFBA           BLT      ??_FillRect_1
   \                     ??_FillRect_3:
   \   00000124   F450DDE1           LDRSH    R5,[SP, #+4]
   \   00000128   F800DDE1           LDRSH    R0,[SP, #+8]
   \   0000012C   050050E1           CMP      R0,R5
   \   00000130   1F0000BA           BLT      ??_FillRect_4
   \                     ??_FillRect_5:
   \   00000134   F600D8E1           LDRSH    R0,[R8, #+6]
   \   00000138   002044E0           SUB      R2,R4,R0
   \   0000013C   F400D8E1           LDRSH    R0,[R8, #+4]
   \   00000140   001045E0           SUB      R1,R5,R0
   \   00000144   0A00A0E1           MOV      R0,R10
   \   00000148   ........           BL       GUI_GetBitmapPixelIndex
   \   0000014C   000050E3           CMP      R0,#+0
   \   00000150   0A00000A           BEQ      ??_FillRect_6
   \   00000154   F600D8E1           LDRSH    R0,[R8, #+6]
   \   00000158   000044E0           SUB      R0,R4,R0
   \   0000015C   905921E0           MLA      R1,R0,R9,R5
   \   00000160   F400D8E1           LDRSH    R0,[R8, #+4]
   \   00000164   000041E0           SUB      R0,R1,R0
   \   00000168   ........           LDR      R1,??DataTable11
   \   0000016C   000188E0           ADD      R0,R8,R0, LSL #+2
   \   00000170   001091E5           LDR      R1,[R1, #+0]
   \   00000174   001091E5           LDR      R1,[R1, #+0]
   \   00000178   201080E5           STR      R1,[R0, #+32]
   \   0000017C   080000EA           B        ??_FillRect_7
   \                     ??_FillRect_6:
   \   00000180   ........           LDR      R0,??DataTable11
   \   00000184   0CC09BE5           LDR      R12,[R11, #+12]
   \   00000188   000090E5           LDR      R0,[R0, #+0]
   \   0000018C   0420A0E1           MOV      R2,R4
   \   00000190   003090E5           LDR      R3,[R0, #+0]
   \   00000194   0510A0E1           MOV      R1,R5
   \   00000198   0B00A0E1           MOV      R0,R11
   \   0000019C   18C09CE5           LDR      R12,[R12, #+24]
   \   000001A0   3CFF2FE1           BLX      R12
   \                     ??_FillRect_7:
   \   000001A4   F800DDE1           LDRSH    R0,[SP, #+8]
   \   000001A8   015085E2           ADD      R5,R5,#+1
   \   000001AC   050050E1           CMP      R0,R5
   \   000001B0   DFFFFFAA           BGE      ??_FillRect_5
   \                     ??_FillRect_4:
   \   000001B4   FA00DDE1           LDRSH    R0,[SP, #+10]
   \   000001B8   014084E2           ADD      R4,R4,#+1
   \   000001BC   040050E1           CMP      R0,R4
   \   000001C0   B7FFFFBA           BLT      ??_FillRect_1
   \   000001C4   D6FFFFEA           B        ??_FillRect_3
    601          
    602          /*********************************************************************
    603          *
    604          *       GUI_DEVICE_API functions: _GetPixelIndex
    605          */

   \                                 In section .text, align 4, keep-with-next
    606          static unsigned _GetPixelIndex(GUI_DEVICE * pDevice, int x, int y)  {
   \                     _GetPixelIndex:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0080A0E1           MOV      R8,R0
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
    607            GUI_SPRITE_OBJ * pSprite;
    608            LCD_PIXELINDEX * pSave;
    609            LCD_PIXELINDEX Index;
    610            int xSizeSprite;
    611          
    612            pSprite = SPRITE_LOCK_H(pDevice->u.hContext);
   \   00000010   080098E5           LDR      R0,[R8, #+8]
   \   00000014   ........           BL       GUI_ALLOC_LockH
   \   00000018   0060A0E1           MOV      R6,R0
    613            xSizeSprite = pSprite->Rect.x1 - pSprite->Rect.x0 + 1;
   \   0000001C   F800D6E1           LDRSH    R0,[R6, #+8]
   \   00000020   F410D6E1           LDRSH    R1,[R6, #+4]
   \   00000024   010040E0           SUB      R0,R0,R1
    614            pDevice = pDevice->pNext;
    615            if (_PixelExists(x, y, pSprite)) {
   \   00000028   010054E1           CMP      R4,R1
   \   0000002C   F610D6A1           LDRSHGE  R1,[R6, #+6]
   \   00000030   017080E2           ADD      R7,R0,#+1
   \   00000034   008098E5           LDR      R8,[R8, #+0]
   \   00000038   1C0096E5           LDR      R0,[R6, #+28]
   \   0000003C   010055A1           CMPGE    R5,R1
   \   00000040   1A0000BA           BLT      ??_GetPixelIndex_0
   \   00000044   F420D6E1           LDRSH    R2,[R6, #+4]
   \   00000048   B010D0E1           LDRH     R1,[R0, #+0]
   \   0000004C   022044E0           SUB      R2,R4,R2
   \   00000050   012082E2           ADD      R2,R2,#+1
   \   00000054   020051E1           CMP      R1,R2
   \   00000058   140000BA           BLT      ??_GetPixelIndex_0
   \   0000005C   F620D6E1           LDRSH    R2,[R6, #+6]
   \   00000060   B210D0E1           LDRH     R1,[R0, #+2]
   \   00000064   022045E0           SUB      R2,R5,R2
   \   00000068   012082E2           ADD      R2,R2,#+1
   \   0000006C   020051E1           CMP      R1,R2
   \   00000070   0E0000BA           BLT      ??_GetPixelIndex_0
   \   00000074   F610D6E1           LDRSH    R1,[R6, #+6]
   \   00000078   012045E0           SUB      R2,R5,R1
   \   0000007C   F410D6E1           LDRSH    R1,[R6, #+4]
   \   00000080   011044E0           SUB      R1,R4,R1
   \   00000084   ........           BL       GUI_GetBitmapPixelIndex
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   0700000A           BEQ      ??_GetPixelIndex_0
    616              //
    617              // Pixel is inside of sprite, so return value from sprite buffer
    618              //
    619              pSave = (LCD_PIXELINDEX *)((U8 *)pSprite + sizeof(GUI_SPRITE_OBJ));
    620              pSave += xSizeSprite * (y - pSprite->Rect.y0) + (x - pSprite->Rect.x0);
    621              Index = *pSave;
   \   00000090   F600D6E1           LDRSH    R0,[R6, #+6]
   \   00000094   000045E0           SUB      R0,R5,R0
   \   00000098   904721E0           MLA      R1,R0,R7,R4
   \   0000009C   F400D6E1           LDRSH    R0,[R6, #+4]
   \   000000A0   000041E0           SUB      R0,R1,R0
   \   000000A4   000186E0           ADD      R0,R6,R0, LSL #+2
   \   000000A8   204090E5           LDR      R4,[R0, #+32]
   \   000000AC   060000EA           B        ??_GetPixelIndex_1
    622            } else {
    623              //
    624              // Pixel is outside of sprite, so rout the request to the next layer
    625              //
    626              Index = pDevice->pDeviceAPI->pfGetPixelIndex(pDevice, x, y);
   \                     ??_GetPixelIndex_0:
   \   000000B0   0C3098E5           LDR      R3,[R8, #+12]
   \   000000B4   0520A0E1           MOV      R2,R5
   \   000000B8   0410A0E1           MOV      R1,R4
   \   000000BC   0800A0E1           MOV      R0,R8
   \   000000C0   143093E5           LDR      R3,[R3, #+20]
   \   000000C4   33FF2FE1           BLX      R3
   \   000000C8   0040A0E1           MOV      R4,R0
    627            }
    628            GUI_UNLOCK_H(pSprite);
   \                     ??_GetPixelIndex_1:
   \   000000CC   ........           BL       GUI_ALLOC_UnlockH
    629            return Index;
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   F081BDE8           POP      {R4-R8,PC}       ;; return
    630          }
    631          
    632          /*********************************************************************
    633          *
    634          *       GUI_DEVICE_API functions: _SetPixelIndex
    635          */

   \                                 In section .text, align 4, keep-with-next
    636          static void _SetPixelIndex(GUI_DEVICE * pDevice, int x, int y, int ColorIndex) {
   \                     _SetPixelIndex:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0080A0E1           MOV      R8,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   0360A0E1           MOV      R6,R3
    637            GUI_SPRITE_OBJ * pSprite;
    638            LCD_PIXELINDEX * pSave;
    639            int xSizeSprite;
    640          
    641            pSprite = SPRITE_LOCK_H(pDevice->u.hContext);
   \   00000018   080098E5           LDR      R0,[R8, #+8]
   \   0000001C   ........           BL       GUI_ALLOC_LockH
   \   00000020   0070A0E1           MOV      R7,R0
    642            xSizeSprite = pSprite->Rect.x1 - pSprite->Rect.x0 + 1;
   \   00000024   F800D7E1           LDRSH    R0,[R7, #+8]
   \   00000028   F410D7E1           LDRSH    R1,[R7, #+4]
   \   0000002C   010040E0           SUB      R0,R0,R1
    643            pDevice = pDevice->pNext;
    644            if (_PixelExists(x, y, pSprite)) {
   \   00000030   010054E1           CMP      R4,R1
   \   00000034   F610D7A1           LDRSHGE  R1,[R7, #+6]
   \   00000038   019080E2           ADD      R9,R0,#+1
   \   0000003C   008098E5           LDR      R8,[R8, #+0]
   \   00000040   1C0097E5           LDR      R0,[R7, #+28]
   \   00000044   010055A1           CMPGE    R5,R1
   \   00000048   1A0000BA           BLT      ??_SetPixelIndex_0
   \   0000004C   F420D7E1           LDRSH    R2,[R7, #+4]
   \   00000050   B010D0E1           LDRH     R1,[R0, #+0]
   \   00000054   022044E0           SUB      R2,R4,R2
   \   00000058   012082E2           ADD      R2,R2,#+1
   \   0000005C   020051E1           CMP      R1,R2
   \   00000060   140000BA           BLT      ??_SetPixelIndex_0
   \   00000064   F620D7E1           LDRSH    R2,[R7, #+6]
   \   00000068   B210D0E1           LDRH     R1,[R0, #+2]
   \   0000006C   022045E0           SUB      R2,R5,R2
   \   00000070   012082E2           ADD      R2,R2,#+1
   \   00000074   020051E1           CMP      R1,R2
   \   00000078   0E0000BA           BLT      ??_SetPixelIndex_0
   \   0000007C   F610D7E1           LDRSH    R1,[R7, #+6]
   \   00000080   012045E0           SUB      R2,R5,R1
   \   00000084   F410D7E1           LDRSH    R1,[R7, #+4]
   \   00000088   011044E0           SUB      R1,R4,R1
   \   0000008C   ........           BL       GUI_GetBitmapPixelIndex
   \   00000090   000050E3           CMP      R0,#+0
   \   00000094   0700000A           BEQ      ??_SetPixelIndex_0
    645              //
    646              // Pixel is inside of sprite, so return value from sprite buffer
    647              //
    648              pSave = (LCD_PIXELINDEX *)((U8 *)pSprite + sizeof(GUI_SPRITE_OBJ));
    649              pSave += xSizeSprite * (y - pSprite->Rect.y0) + (x - pSprite->Rect.x0);
    650              *pSave = ColorIndex;
   \   00000098   F600D7E1           LDRSH    R0,[R7, #+6]
   \   0000009C   000045E0           SUB      R0,R5,R0
   \   000000A0   904921E0           MLA      R1,R0,R9,R4
   \   000000A4   F400D7E1           LDRSH    R0,[R7, #+4]
   \   000000A8   000041E0           SUB      R0,R1,R0
   \   000000AC   000187E0           ADD      R0,R7,R0, LSL #+2
   \   000000B0   206080E5           STR      R6,[R0, #+32]
   \   000000B4   060000EA           B        ??_SetPixelIndex_1
    651            } else {
    652              //
    653              // Pixel is outside of sprite, so rout the request to the next layer
    654              //
    655              pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x, y, ColorIndex);
   \                     ??_SetPixelIndex_0:
   \   000000B8   0CC098E5           LDR      R12,[R8, #+12]
   \   000000BC   0630A0E1           MOV      R3,R6
   \   000000C0   0520A0E1           MOV      R2,R5
   \   000000C4   0410A0E1           MOV      R1,R4
   \   000000C8   0800A0E1           MOV      R0,R8
   \   000000CC   18C09CE5           LDR      R12,[R12, #+24]
   \   000000D0   3CFF2FE1           BLX      R12
    656            }
    657            GUI_UNLOCK_H(pSprite);
   \                     ??_SetPixelIndex_1:
   \   000000D4   04D08DE2           ADD      SP,SP,#+4
   \   000000D8   F043BDE8           POP      {R4-R9,LR}
   \   000000DC   ........           B        GUI_ALLOC_UnlockH  ;; tailcall
    658          }
    659          
    660          /*********************************************************************
    661          *
    662          *       GUI_DEVICE_API functions: _XorPixel
    663          */

   \                                 In section .text, align 4, keep-with-next
    664          static void _XorPixel(GUI_DEVICE * pDevice, int x, int y) {
   \                     _XorPixel:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0080A0E1           MOV      R8,R0
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
    665            GUI_SPRITE_OBJ * pSprite;
    666            LCD_PIXELINDEX * pSave;
    667            LCD_PIXELINDEX IndexMask;
    668            int xSizeSprite;
    669          
    670            pSprite = SPRITE_LOCK_H(pDevice->u.hContext);
   \   00000010   080098E5           LDR      R0,[R8, #+8]
   \   00000014   ........           BL       GUI_ALLOC_LockH
   \   00000018   0060A0E1           MOV      R6,R0
   \   0000001C   F410D6E1           LDRSH    R1,[R6, #+4]
   \   00000020   F800D6E1           LDRSH    R0,[R6, #+8]
    671            xSizeSprite = pSprite->Rect.x1 - pSprite->Rect.x0 + 1;
    672            pDevice = pDevice->pNext;
   \   00000024   008098E5           LDR      R8,[R8, #+0]
    673            if (_PixelExists(x, y, pSprite)) {
   \   00000028   010054E1           CMP      R4,R1
   \   0000002C   F620D6A1           LDRSHGE  R2,[R6, #+6]
   \   00000030   010040E0           SUB      R0,R0,R1
   \   00000034   017080E2           ADD      R7,R0,#+1
   \   00000038   1C0096E5           LDR      R0,[R6, #+28]
   \   0000003C   020055A1           CMPGE    R5,R2
   \   00000040   1A0000BA           BLT      ??_XorPixel_0
   \   00000044   B030D0E1           LDRH     R3,[R0, #+0]
   \   00000048   011044E0           SUB      R1,R4,R1
   \   0000004C   01C081E2           ADD      R12,R1,#+1
   \   00000050   0C0053E1           CMP      R3,R12
   \   00000054   150000BA           BLT      ??_XorPixel_0
   \   00000058   B230D0E1           LDRH     R3,[R0, #+2]
   \   0000005C   022045E0           SUB      R2,R5,R2
   \   00000060   01C082E2           ADD      R12,R2,#+1
   \   00000064   0C0053E1           CMP      R3,R12
   \   00000068   100000BA           BLT      ??_XorPixel_0
   \   0000006C   ........           BL       GUI_GetBitmapPixelIndex
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   0D00000A           BEQ      ??_XorPixel_0
    674              //
    675              // Pixel is inside of sprite, so manage sprite buffer
    676              //
    677              pSave = (LCD_PIXELINDEX *)((U8 *)pSprite + sizeof(GUI_SPRITE_OBJ));
    678              pSave += xSizeSprite * (y - pSprite->Rect.y0) + (x - pSprite->Rect.x0);
   \   00000078   F600D6E1           LDRSH    R0,[R6, #+6]
   \   0000007C   000045E0           SUB      R0,R5,R0
   \   00000080   904721E0           MLA      R1,R0,R7,R4
   \   00000084   F400D6E1           LDRSH    R0,[R6, #+4]
   \   00000088   000041E0           SUB      R0,R1,R0
   \   0000008C   000186E0           ADD      R0,R6,R0, LSL #+2
   \   00000090   204080E2           ADD      R4,R0,#+32
    679              IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \   00000094   100098E5           LDR      R0,[R8, #+16]
   \   00000098   080090E5           LDR      R0,[R0, #+8]
   \   0000009C   30FF2FE1           BLX      R0
    680              *pSave ^= IndexMask;
   \   000000A0   001094E5           LDR      R1,[R4, #+0]
   \   000000A4   010020E0           EOR      R0,R0,R1
   \   000000A8   000084E5           STR      R0,[R4, #+0]
   \   000000AC   050000EA           B        ??_XorPixel_1
    681            } else {
    682              //
    683              // Pixel is outside of sprite, so rout the request to the next layer
    684              //
    685              pDevice->pDeviceAPI->pfXorPixel(pDevice, x, y);
   \                     ??_XorPixel_0:
   \   000000B0   0C3098E5           LDR      R3,[R8, #+12]
   \   000000B4   0520A0E1           MOV      R2,R5
   \   000000B8   0410A0E1           MOV      R1,R4
   \   000000BC   0800A0E1           MOV      R0,R8
   \   000000C0   1C3093E5           LDR      R3,[R3, #+28]
   \   000000C4   33FF2FE1           BLX      R3
    686            }
    687            GUI_UNLOCK_H(pSprite);
   \                     ??_XorPixel_1:
   \   000000C8   F041BDE8           POP      {R4-R8,LR}
   \   000000CC   ........           B        GUI_ALLOC_UnlockH  ;; tailcall
    688          }
    689          
    690          /*********************************************************************
    691          *
    692          *       _GetDevData
    693          */

   \                                 In section .text, align 4, keep-with-next
    694          static void * _GetDevData(GUI_DEVICE * pDevice, int Index) {
    695            GUI_USE_PARA(pDevice);
    696            GUI_USE_PARA(Index);
    697            return NULL;
   \                     _GetDevData:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return
    698          }
    699          
    700          /*********************************************************************
    701          *
    702          *       GUI_DEVICE_API functions: From here there is nothing to do except routing...
    703          */

   \                                 In section .text, align 4, keep-with-next
    704          static void _SetOrg(GUI_DEVICE * pDevice, int x, int y) {
    705            pDevice = pDevice->pNext;
   \                     _SetOrg:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    706            if (pDevice) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0000001A           BNE      ??_SetOrg_0
    707              pDevice->pDeviceAPI->pfSetOrg(pDevice, x, y);
   \   0000000C   1EFF2FE1           BX       LR
    708            }
   \                     ??_SetOrg_0:
   \   00000010   00402DE9           PUSH     {LR}
   \   00000014   0C3090E5           LDR      R3,[R0, #+12]
   \   00000018   04D04DE2           SUB      SP,SP,#+4
   \   0000001C   203093E5           LDR      R3,[R3, #+32]
   \   00000020   33FF2FE1           BLX      R3
    709          }
   \   00000024   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000028   0080BDE8           POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
    710          static void (* _GetDevFunc(GUI_DEVICE ** ppDevice, int Index))(void) {
    711            GUI_USE_PARA(ppDevice);
    712            GUI_USE_PARA(Index);
    713            return NULL;
   \                     _GetDevFunc:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return
    714          }

   \                                 In section .text, align 4, keep-with-next
    715          static I32 _GetDevProp(GUI_DEVICE * pDevice, int Index) {
    716            pDevice = pDevice->pNext;
   \                     _GetDevProp:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    717            if (pDevice) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0000001A           BNE      ??_GetDevProp_0
    718              return pDevice->pDeviceAPI->pfGetDevProp(pDevice, Index);
   \   0000000C   1EFF2FE1           BX       LR
    719            }
   \                     ??_GetDevProp_0:
   \   00000010   00402DE9           PUSH     {LR}
   \   00000014   0C2090E5           LDR      R2,[R0, #+12]
   \   00000018   04D04DE2           SUB      SP,SP,#+4
   \   0000001C   282092E5           LDR      R2,[R2, #+40]
   \   00000020   32FF2FE1           BLX      R2
    720            return 0;
   \   00000024   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000028   0080BDE8           POP      {PC}             ;; return
    721          }

   \                                 In section .text, align 4, keep-with-next
    722          static void _GetRect(GUI_DEVICE * pDevice, LCD_RECT * pRect) {
    723            pDevice = pDevice->pNext;
   \                     _GetRect:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    724            if (pDevice) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0000001A           BNE      ??_GetRect_0
    725              pDevice->pDeviceAPI->pfGetRect(pDevice, pRect);
   \   0000000C   1EFF2FE1           BX       LR
    726            }
   \                     ??_GetRect_0:
   \   00000010   00402DE9           PUSH     {LR}
   \   00000014   0C2090E5           LDR      R2,[R0, #+12]
   \   00000018   04D04DE2           SUB      SP,SP,#+4
   \   0000001C   302092E5           LDR      R2,[R2, #+48]
   \   00000020   32FF2FE1           BLX      R2
    727          }
   \   00000024   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000028   0080BDE8           POP      {PC}             ;; return
    728          
    729          /*********************************************************************
    730          *
    731          *       GUI_DEVICE_API structure
    732          */

   \                                 In section .text, align 4, keep-with-next
    733          static const GUI_DEVICE_API _Sprite_API = {
   \                     _Sprite_API:
   \   00000000                      ; Initializer data, 52 bytes
   \   00000000   03000000....       DC32 3, _DrawBitmap, _DrawHLine, _DrawVLine, _FillRect, _GetPixelIndex, _SetPixelIndex, _XorPixel, _SetOrg, _GetDevFunc
   \              ............
   \              ............
   \              ............
   \              ............
   \              ............
   \              ........    
   \   00000028   ............       DC32 _GetDevProp, _GetDevData, _GetRect
   \              ............
    734            //
    735            // Data
    736            //
    737            DEVICE_CLASS_SPRITE,
    738            //
    739            // Drawing functions
    740            //
    741            _DrawBitmap   ,
    742            _DrawHLine    ,
    743            _DrawVLine    ,
    744            _FillRect     ,
    745            _GetPixelIndex,
    746            _SetPixelIndex,
    747            _XorPixel     ,
    748            //
    749            // Set origin
    750            //
    751            _SetOrg       ,
    752            //
    753            // Request information
    754            //
    755            _GetDevFunc   ,
    756            _GetDevProp   ,
    757            _GetDevData,
    758            _GetRect      ,
    759          };
    760          
    761          /*********************************************************************
    762          *
    763          *       _GetBkPixel
    764          *
    765          * Purpose:
    766          *   Returns the background value of the given position.
    767          */

   \                                 In section .text, align 4, keep-with-next
    768          static int _GetBkPixel(int x, int y, GUI_DEVICE * pDevice, GUI_SPRITE_OBJ * pSprite) {
   \                     _GetBkPixel:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0370A0E1           MOV      R7,R3
   \   0000000C   F400D7E1           LDRSH    R0,[R7, #+4]
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   000054E1           CMP      R4,R0
   \   0000001C   F810D7A1           LDRSHGE  R1,[R7, #+8]
   \   00000020   04D04DE2           SUB      SP,SP,#+4
   \   00000024   040051A1           CMPGE    R1,R4
   \   00000028   F610D7A1           LDRSHGE  R1,[R7, #+6]
   \   0000002C   010055A1           CMPGE    R5,R1
   \   00000030   FA20D7A1           LDRSHGE  R2,[R7, #+10]
   \   00000034   050052A1           CMPGE    R2,R5
   \   00000038   070000BA           BLT      ??_GetBkPixel_0
    769            LCD_PIXELINDEX Index;
    770            LCD_PIXELINDEX * pSave;
    771            int xPos, yPos, xSizeSprite;
    772          
    773            if ((x >= pSprite->Rect.x0) && (x <= pSprite->Rect.x1) && (y >= pSprite->Rect.y0) && (y <= pSprite->Rect.y1)) {
    774              xPos = x - pSprite->Rect.x0;
   \   0000003C   008044E0           SUB      R8,R4,R0
    775              yPos = y - pSprite->Rect.y0;
   \   00000040   019045E0           SUB      R9,R5,R1
    776              Index = GUI_GetBitmapPixelIndex(pSprite->pBM, xPos, yPos);
    777            } else {
    778              Index = 0;
    779            }
    780            if (Index == 0) {
   \   00000044   0920A0E1           MOV      R2,R9
   \   00000048   0810A0E1           MOV      R1,R8
   \   0000004C   1C0097E5           LDR      R0,[R7, #+28]
   \   00000050   ........           BL       GUI_GetBitmapPixelIndex
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0B00001A           BNE      ??_GetBkPixel_1
    781              pDevice = pDevice->pNext;
   \                     ??_GetBkPixel_0:
   \   0000005C   006096E5           LDR      R6,[R6, #+0]
    782              if (pDevice) {
   \   00000060   000056E3           CMP      R6,#+0
   \   00000064   0600000A           BEQ      ??_GetBkPixel_2
    783                return pDevice->pDeviceAPI->pfGetPixelIndex(pDevice, x, y);
   \   00000068   0C3096E5           LDR      R3,[R6, #+12]
   \   0000006C   0520A0E1           MOV      R2,R5
   \   00000070   0410A0E1           MOV      R1,R4
   \   00000074   0600A0E1           MOV      R0,R6
   \   00000078   143093E5           LDR      R3,[R3, #+20]
   \   0000007C   33FF2FE1           BLX      R3
   \   00000080   080000EA           B        ??_GetBkPixel_3
    784              }
    785              return 0;
   \                     ??_GetBkPixel_2:
   \   00000084   0000A0E3           MOV      R0,#+0
   \   00000088   060000EA           B        ??_GetBkPixel_3
    786            } else {
    787              xSizeSprite = pSprite->Rect.x1 - pSprite->Rect.x0 + 1;
    788              pSave = (LCD_PIXELINDEX *)((U8 *)pSprite + sizeof(GUI_SPRITE_OBJ));
    789              pSave += xSizeSprite * yPos + xPos;
    790              Index = *pSave;
    791              return Index;
   \                     ??_GetBkPixel_1:
   \   0000008C   F800D7E1           LDRSH    R0,[R7, #+8]
   \   00000090   F410D7E1           LDRSH    R1,[R7, #+4]
   \   00000094   010040E0           SUB      R0,R0,R1
   \   00000098   010080E2           ADD      R0,R0,#+1
   \   0000009C   998020E0           MLA      R0,R9,R0,R8
   \   000000A0   000187E0           ADD      R0,R7,R0, LSL #+2
   \   000000A4   200090E5           LDR      R0,[R0, #+32]
   \                     ??_GetBkPixel_3:
   \   000000A8   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000AC   F083BDE8           POP      {R4-R9,PC}       ;; return
    792            }
    793          }
    794          
    795          /*********************************************************************
    796          *
    797          *       _SetSpriteBkPixel
    798          *
    799          * Purpose:
    800          *   This routine is used to draw the sprite pixels itself. It temporary
    801          *   removes the bitmap of the given sprite and uses _SetBkPixel() for the 
    802          *   drawing operation. This makes sure that the background will be managed 
    803          *   in exact the same manner as in normal drawing operations.
    804          */
    805          static void _SetSpriteBkPixel(int x, int y, int Index, GUI_DEVICE * pDevice) {
    806            pDevice = pDevice->pNext;
    807            if (pDevice) {
    808              pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x, y, Index);
    809            }
    810          }
    811          
    812          /*********************************************************************
    813          *
    814          *       _ClipRectEx
    815          */
    816          static void _ClipRectEx(GUI_DEVICE * pDevice, GUI_RECT * pRect) {
    817            GUI_RECT RectDevice;
    818            pDevice->pDeviceAPI->pfGetRect(pDevice, &RectDevice);
    819            GUI__IntersectRect(pRect, &RectDevice);
    820          }
    821          
    822          /*********************************************************************
    823          *
    824          *       _Undraw
    825          *
    826          * Purpose:
    827          *   This routine removes the drawing of the sprite from the screen. It
    828          *   replaces the non transparent sprite pixels with the background stored
    829          *   in the sprite data area. If a non transparent sprite pixel is covered
    830          *   by a further sprite the routine makes sure that the background data
    831          *   is passed to the right sprite.
    832          */

   \                                 In section .text, align 4, keep-with-next
    833          static void _Undraw(GUI_HSPRITE hSprite) {
   \                     _Undraw:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
    834            GUI_SPRITE_OBJ * pSprite;
    835            int x, y, xPos, yPos;
    836            int Layer, LayerOld;
    837            const GUI_BITMAP GUI_UNI_PTR * pBM;
    838            LCD_PIXELINDEX Data;
    839            LCD_PIXELINDEX * pData;
    840            GUI_DEVICE * pDevice;
    841            GUI_RECT ClipRect;
    842          
    843            pSprite = SPRITE_LOCK_H(hSprite);
   \   00000008   ........           BL       GUI_ALLOC_LockH
   \   0000000C   0040A0E1           MOV      R4,R0
    844            pDevice = pSprite->pDevice;
   \   00000010   005094E5           LDR      R5,[R4, #+0]
    845            SET_SPRITE_LAYER()
    846            pBM   = pSprite->pBM;
    847            pData = (LCD_PIXELINDEX *)((U8 *)pSprite + sizeof(GUI_SPRITE_OBJ));
   \   00000014   207084E2           ADD      R7,R4,#+32
   \   00000018   180095E5           LDR      R0,[R5, #+24]
    848            ClipRect = pSprite->Rect;
   \   0000001C   0820A0E3           MOV      R2,#+8
   \   00000020   0C008DE5           STR      R0,[SP, #+12]
   \   00000024   ........           LDR      R0,??DataTable10
   \   00000028   1100D0E5           LDRB     R0,[R0, #+17]
   \   0000002C   08008DE5           STR      R0,[SP, #+8]
   \   00000030   0C009DE5           LDR      R0,[SP, #+12]
   \   00000034   08109DE5           LDR      R1,[SP, #+8]
   \   00000038   010050E1           CMP      R0,R1
   \   0000003C   ........           LDRNE    R0,??DataTable10
   \   00000040   0C109D15           LDRNE    R1,[SP, #+12]
   \   00000044   1110C015           STRBNE   R1,[R0, #+17]
   \   00000048   1C6094E5           LDR      R6,[R4, #+28]
   \   0000004C   0D00A0E1           MOV      R0,SP
   \   00000050   041084E2           ADD      R1,R4,#+4
   \   00000054   ........           BL       __aeabi_memcpy
    849            _ClipRectEx(pDevice, &ClipRect);
   \   00000058   0C2095E5           LDR      R2,[R5, #+12]
   \   0000005C   10108DE2           ADD      R1,SP,#+16
   \   00000060   0500A0E1           MOV      R0,R5
   \   00000064   302092E5           LDR      R2,[R2, #+48]
   \   00000068   32FF2FE1           BLX      R2
   \   0000006C   10108DE2           ADD      R1,SP,#+16
   \   00000070   0D00A0E1           MOV      R0,SP
   \   00000074   ........           BL       GUI__IntersectRect
    850            for (y = ClipRect.y0; y <= ClipRect.y1; y++) {
   \   00000078   F280DDE1           LDRSH    R8,[SP, #+2]
   \   0000007C   F600DDE1           LDRSH    R0,[SP, #+6]
   \   00000080   080050E1           CMP      R0,R8
   \   00000084   200000BA           BLT      ??_Undraw_0
    851              yPos = y - pSprite->Rect.y0;
   \                     ??_Undraw_1:
   \   00000088   F600D4E1           LDRSH    R0,[R4, #+6]
    852              for (x = ClipRect.x0; x <= ClipRect.x1; x++) {
   \   0000008C   F0A0DDE1           LDRSH    R10,[SP, #+0]
   \   00000090   009048E0           SUB      R9,R8,R0
   \   00000094   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000098   0A0050E1           CMP      R0,R10
   \   0000009C   160000BA           BLT      ??_Undraw_2
    853                xPos = x - pSprite->Rect.x0;
   \                     ??_Undraw_3:
   \   000000A0   F400D4E1           LDRSH    R0,[R4, #+4]
    854                if (GUI_GetBitmapPixelIndex(pBM, xPos, yPos) != 0) {
   \   000000A4   0920A0E1           MOV      R2,R9
   \   000000A8   00B04AE0           SUB      R11,R10,R0
   \   000000AC   0B10A0E1           MOV      R1,R11
   \   000000B0   0600A0E1           MOV      R0,R6
   \   000000B4   ........           BL       GUI_GetBitmapPixelIndex
   \   000000B8   000050E3           CMP      R0,#+0
    855                  Data = *(pData + yPos * pBM->XSize + xPos);
    856                  _SetSpriteBkPixel(x, y, Data, pDevice);
   \   000000BC   00009515           LDRNE    R0,[R5, #+0]
   \   000000C0   00005013           CMPNE    R0,#+0
   \   000000C4   0800000A           BEQ      ??_Undraw_4
   \   000000C8   B010D6E1           LDRH     R1,[R6, #+0]
   \   000000CC   0CC090E5           LDR      R12,[R0, #+12]
   \   000000D0   910902E0           MUL      R2,R1,R9
   \   000000D4   18C09CE5           LDR      R12,[R12, #+24]
   \   000000D8   021187E0           ADD      R1,R7,R2, LSL #+2
   \   000000DC   0B3191E7           LDR      R3,[R1, +R11, LSL #+2]
   \   000000E0   0820A0E1           MOV      R2,R8
   \   000000E4   0A10A0E1           MOV      R1,R10
   \   000000E8   3CFF2FE1           BLX      R12
    857                }
    858              }
   \                     ??_Undraw_4:
   \   000000EC   F400DDE1           LDRSH    R0,[SP, #+4]
   \   000000F0   01A08AE2           ADD      R10,R10,#+1
   \   000000F4   0A0050E1           CMP      R0,R10
   \   000000F8   E8FFFFAA           BGE      ??_Undraw_3
    859            }
   \                     ??_Undraw_2:
   \   000000FC   F600DDE1           LDRSH    R0,[SP, #+6]
   \   00000100   018088E2           ADD      R8,R8,#+1
   \   00000104   080050E1           CMP      R0,R8
   \   00000108   DEFFFFAA           BGE      ??_Undraw_1
    860            GUI_UNLOCK_H(pSprite);
   \                     ??_Undraw_0:
   \   0000010C   ........           BL       GUI_ALLOC_UnlockH
    861            RESTORE_LAYER()
   \   00000110   0C009DE5           LDR      R0,[SP, #+12]
   \   00000114   08109DE5           LDR      R1,[SP, #+8]
    862          }
   \   00000118   1CD08DE2           ADD      SP,SP,#+28
   \   0000011C   010050E1           CMP      R0,R1
   \   00000120   ........           LDRNE    R0,??DataTable10
   \   00000124   1110C015           STRBNE   R1,[R0, #+17]
   \   00000128   F08FBDE8           POP      {R4-R11,PC}      ;; return
    863          
    864          /*********************************************************************
    865          *
    866          *       _SetBitmap
    867          */

   \                                 In section .text, align 4, keep-with-next
    868          static void _SetBitmap(GUI_HSPRITE hSprite, const GUI_BITMAP GUI_UNI_PTR * pBM) {
   \                     _SetBitmap:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
    869            GUI_SPRITE_OBJ * pSprite;
    870            int xPos, yPos, x, y, Index;
    871            int PixelOld, PixelNew;
    872            int Layer, LayerOld;
    873            LCD_PIXELINDEX * pData;
    874            LCD_PIXELINDEX * pColors;
    875            GUI_DEVICE * pDevice;
    876            GUI_RECT ClipRect;
    877          
    878            pSprite = SPRITE_LOCK_H(hSprite);
   \   00000008   ........           BL       GUI_ALLOC_LockH
   \   0000000C   0040A0E1           MOV      R4,R0
    879            pDevice = pSprite->pDevice;
   \   00000010   005094E5           LDR      R5,[R4, #+0]
    880            SET_SPRITE_LAYER()
   \   00000014   180095E5           LDR      R0,[R5, #+24]
   \   00000018   0C008DE5           STR      R0,[SP, #+12]
   \   0000001C   ........           LDR      R0,??DataTable10
   \   00000020   1100D0E5           LDRB     R0,[R0, #+17]
   \   00000024   08008DE5           STR      R0,[SP, #+8]
   \   00000028   0C009DE5           LDR      R0,[SP, #+12]
   \   0000002C   08109DE5           LDR      R1,[SP, #+8]
   \   00000030   010050E1           CMP      R0,R1
   \   00000034   ........           LDRNE    R0,??DataTable10
   \   00000038   0C109D15           LDRNE    R1,[SP, #+12]
   \   0000003C   1110C015           STRBNE   R1,[R0, #+17]
    881            pData   = (LCD_PIXELINDEX *)((U8 *)pSprite + sizeof(GUI_SPRITE_OBJ));
   \   00000040   200084E2           ADD      R0,R4,#+32
   \   00000044   10008DE5           STR      R0,[SP, #+16]
    882            pColors = (LCD_PIXELINDEX *)GUI_LOCK_H(pSprite->hColors);
   \   00000048   0C0094E5           LDR      R0,[R4, #+12]
   \   0000004C   ........           BL       GUI_ALLOC_LockH
   \   00000050   14008DE5           STR      R0,[SP, #+20]
    883            ClipRect = pSprite->Rect;
   \   00000054   0D00A0E1           MOV      R0,SP
   \   00000058   041084E2           ADD      R1,R4,#+4
   \   0000005C   0820A0E3           MOV      R2,#+8
   \   00000060   ........           BL       __aeabi_memcpy
    884            _ClipRectEx(pDevice, &ClipRect);
   \   00000064   0C2095E5           LDR      R2,[R5, #+12]
   \   00000068   18108DE2           ADD      R1,SP,#+24
   \   0000006C   0500A0E1           MOV      R0,R5
   \   00000070   302092E5           LDR      R2,[R2, #+48]
   \   00000074   32FF2FE1           BLX      R2
   \   00000078   18108DE2           ADD      R1,SP,#+24
   \   0000007C   0D00A0E1           MOV      R0,SP
   \   00000080   ........           BL       GUI__IntersectRect
    885            for (y = ClipRect.y0; y <= ClipRect.y1; y++) {
   \   00000084   F260DDE1           LDRSH    R6,[SP, #+2]
   \   00000088   F600DDE1           LDRSH    R0,[SP, #+6]
   \   0000008C   060050E1           CMP      R0,R6
   \   00000090   3A0000BA           BLT      ??_SetBitmap_0
    886              yPos = y - pSprite->Rect.y0;
   \                     ??_SetBitmap_1:
   \   00000094   F600D4E1           LDRSH    R0,[R4, #+6]
    887              for (x = ClipRect.x0; x <= ClipRect.x1; x++) {
   \   00000098   F080DDE1           LDRSH    R8,[SP, #+0]
   \   0000009C   007046E0           SUB      R7,R6,R0
   \   000000A0   F400DDE1           LDRSH    R0,[SP, #+4]
   \   000000A4   080050E1           CMP      R0,R8
   \   000000A8   300000BA           BLT      ??_SetBitmap_2
    888                xPos = x - pSprite->Rect.x0;
   \                     ??_SetBitmap_3:
   \   000000AC   F400D4E1           LDRSH    R0,[R4, #+4]
    889                PixelOld = GUI_GetBitmapPixelIndex(pSprite->pBM, xPos, yPos);
   \   000000B0   0720A0E1           MOV      R2,R7
   \   000000B4   009048E0           SUB      R9,R8,R0
   \   000000B8   0910A0E1           MOV      R1,R9
   \   000000BC   1C0094E5           LDR      R0,[R4, #+28]
   \   000000C0   ........           BL       GUI_GetBitmapPixelIndex
   \   000000C4   00B0A0E1           MOV      R11,R0
    890                PixelNew = GUI_GetBitmapPixelIndex(pBM, xPos, yPos);
   \   000000C8   0720A0E1           MOV      R2,R7
   \   000000CC   0910A0E1           MOV      R1,R9
   \   000000D0   20009DE5           LDR      R0,[SP, #+32]
   \   000000D4   ........           BL       GUI_GetBitmapPixelIndex
   \   000000D8   00A0B0E1           MOVS     R10,R0
    891                if (PixelNew == 0) {
   \   000000DC   0A00001A           BNE      ??_SetBitmap_4
    892                  if (PixelOld) {
   \   000000E0   00005BE3           CMP      R11,#+0
    893                    //
    894                    // Restore background
    895                    //
    896                    Index = *(pData + yPos * pBM->XSize + xPos);
    897                    _SetSpriteBkPixel(x, y, Index, pDevice);
   \   000000E4   00009515           LDRNE    R0,[R5, #+0]
   \   000000E8   00005013           CMPNE    R0,#+0
   \   000000EC   1B00000A           BEQ      ??_SetBitmap_5
   \   000000F0   20109DE5           LDR      R1,[SP, #+32]
   \   000000F4   B010D1E1           LDRH     R1,[R1, #+0]
   \   000000F8   910702E0           MUL      R2,R1,R7
   \   000000FC   10109DE5           LDR      R1,[SP, #+16]
   \   00000100   021181E0           ADD      R1,R1,R2, LSL #+2
   \   00000104   093191E7           LDR      R3,[R1, +R9, LSL #+2]
   \   00000108   0F0000EA           B        ??_SetBitmap_6
    898                  }
    899                } else {
    900                  //
    901                  // Save background
    902                  //
    903                  *(pData + yPos * pBM->XSize + xPos) = _GetBkPixel(x, y, pDevice, pSprite);
   \                     ??_SetBitmap_4:
   \   0000010C   0430A0E1           MOV      R3,R4
   \   00000110   0520A0E1           MOV      R2,R5
   \   00000114   0610A0E1           MOV      R1,R6
   \   00000118   0800A0E1           MOV      R0,R8
   \   0000011C   ........           BL       _GetBkPixel
   \   00000120   20109DE5           LDR      R1,[SP, #+32]
   \   00000124   B010D1E1           LDRH     R1,[R1, #+0]
   \   00000128   910702E0           MUL      R2,R1,R7
   \   0000012C   10109DE5           LDR      R1,[SP, #+16]
   \   00000130   021181E0           ADD      R1,R1,R2, LSL #+2
   \   00000134   090181E7           STR      R0,[R1, +R9, LSL #+2]
    904                  //
    905                  // Draw new pixel
    906                  //
    907                  Index = *(pColors + PixelNew);
    908                  _SetSpriteBkPixel(x, y, Index, pDevice);
   \   00000138   000095E5           LDR      R0,[R5, #+0]
   \   0000013C   000050E3           CMP      R0,#+0
   \   00000140   0600000A           BEQ      ??_SetBitmap_5
   \   00000144   14109DE5           LDR      R1,[SP, #+20]
   \   00000148   0A3191E7           LDR      R3,[R1, +R10, LSL #+2]
   \                     ??_SetBitmap_6:
   \   0000014C   0CC090E5           LDR      R12,[R0, #+12]
   \   00000150   0620A0E1           MOV      R2,R6
   \   00000154   0810A0E1           MOV      R1,R8
   \   00000158   18C09CE5           LDR      R12,[R12, #+24]
   \   0000015C   3CFF2FE1           BLX      R12
    909                }
    910              }
   \                     ??_SetBitmap_5:
   \   00000160   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000164   018088E2           ADD      R8,R8,#+1
   \   00000168   080050E1           CMP      R0,R8
   \   0000016C   CEFFFFAA           BGE      ??_SetBitmap_3
    911            }
   \                     ??_SetBitmap_2:
   \   00000170   F600DDE1           LDRSH    R0,[SP, #+6]
   \   00000174   016086E2           ADD      R6,R6,#+1
   \   00000178   060050E1           CMP      R0,R6
   \   0000017C   C4FFFFAA           BGE      ??_SetBitmap_1
    912            pSprite->pBM = pBM;
   \                     ??_SetBitmap_0:
   \   00000180   20009DE5           LDR      R0,[SP, #+32]
   \   00000184   1C0084E5           STR      R0,[R4, #+28]
    913            GUI_UNLOCK_H(pSprite);
   \   00000188   ........           BL       GUI_ALLOC_UnlockH
    914            GUI_UNLOCK_H(pColors);
   \   0000018C   ........           BL       GUI_ALLOC_UnlockH
    915            RESTORE_LAYER()
   \   00000190   0C009DE5           LDR      R0,[SP, #+12]
   \   00000194   08109DE5           LDR      R1,[SP, #+8]
    916          }
   \   00000198   24D08DE2           ADD      SP,SP,#+36
   \   0000019C   010050E1           CMP      R0,R1
   \   000001A0   ........           LDRNE    R0,??DataTable10
   \   000001A4   1110C015           STRBNE   R1,[R0, #+17]
   \   000001A8   F08FBDE8           POP      {R4-R11,PC}      ;; return
    917          
    918          /*********************************************************************
    919          *
    920          *       _SetPosition
    921          *
    922          * Purpose:
    923          *   Sets the new position of the given sprite and restores the background
    924          *   on demand.
    925          */

   \                                 In section .text, align 4, keep-with-next
    926          static void _SetPosition(GUI_HSPRITE hSprite, int xNewPos, int yNewPos) {
   \                     _SetPosition:
   \   00000000   F64F2DE9           PUSH     {R1,R2,R4-R11,LR}
   \   00000004   74D04DE2           SUB      SP,SP,#+116
    927            GUI_SPRITE_OBJ * pSprite;
    928            int x, xPos, xPosBK, xStart, xStep, xEnd, xOff, xOverlapMin, xOverlapMax;
    929            int y, yPos, yPosBK, yStart, yStep, yEnd, yOff, yOverlapMin, yOverlapMax;
    930            int xSize, ySize;
    931            int Layer, LayerOld;
    932            LCD_PIXELINDEX * pData;
    933            LCD_PIXELINDEX * pColors;
    934            const GUI_BITMAP GUI_UNI_PTR * pBM;
    935            GUI_DEVICE * pDevice;
    936            GUI_RECT ClipRect;
    937          
    938            pSprite = SPRITE_LOCK_H(hSprite);
   \   00000008   ........           BL       GUI_ALLOC_LockH
   \   0000000C   00008DE5           STR      R0,[SP, #+0]
    939            pDevice = pSprite->pDevice;
   \   00000010   001090E5           LDR      R1,[R0, #+0]
    940            if ((xNewPos == pSprite->Rect.x0) && (yNewPos == pSprite->Rect.y0)) {
   \   00000014   74009DE5           LDR      R0,[SP, #+116]
   \   00000018   04108DE5           STR      R1,[SP, #+4]
   \   0000001C   00109DE5           LDR      R1,[SP, #+0]
   \   00000020   F410D1E1           LDRSH    R1,[R1, #+4]
   \   00000024   010050E1           CMP      R0,R1
   \   00000028   0700001A           BNE      ??_SetPosition_0
   \   0000002C   00109DE5           LDR      R1,[SP, #+0]
   \   00000030   78009DE5           LDR      R0,[SP, #+120]
   \   00000034   F610D1E1           LDRSH    R1,[R1, #+6]
   \   00000038   010050E1           CMP      R0,R1
   \   0000003C   0200001A           BNE      ??_SetPosition_0
    941              GUI_UNLOCK_H(pSprite);
   \                     ??_SetPosition_1:
   \   00000040   ........           BL       GUI_ALLOC_UnlockH
    942              return;
   \   00000044   7CD08DE2           ADD      SP,SP,#+124      ;; stack cleaning
   \   00000048   F08FBDE8           POP      {R4-R11,PC}      ;; return
    943            }
    944            SET_SPRITE_LAYER()
   \                     ??_SetPosition_0:
   \   0000004C   04009DE5           LDR      R0,[SP, #+4]
   \   00000050   180090E5           LDR      R0,[R0, #+24]
   \   00000054   38008DE5           STR      R0,[SP, #+56]
   \   00000058   ........           LDR      R0,??DataTable17
   \   0000005C   1100D0E5           LDRB     R0,[R0, #+17]
   \   00000060   34008DE5           STR      R0,[SP, #+52]
   \   00000064   38009DE5           LDR      R0,[SP, #+56]
   \   00000068   34109DE5           LDR      R1,[SP, #+52]
   \   0000006C   010050E1           CMP      R0,R1
   \   00000070   ........           LDRNE    R0,??DataTable17
   \   00000074   38109D15           LDRNE    R1,[SP, #+56]
   \   00000078   1110C015           STRBNE   R1,[R0, #+17]
    945            xPos  = pSprite->Rect.x0;
   \   0000007C   00009DE5           LDR      R0,[SP, #+0]
   \   00000080   F400D0E1           LDRSH    R0,[R0, #+4]
   \   00000084   20008DE5           STR      R0,[SP, #+32]
    946            yPos  = pSprite->Rect.y0;
   \   00000088   00009DE5           LDR      R0,[SP, #+0]
    947            xSize = pSprite->Rect.x1 - xPos + 1;
   \   0000008C   20109DE5           LDR      R1,[SP, #+32]
   \   00000090   F600D0E1           LDRSH    R0,[R0, #+6]
   \   00000094   1C008DE5           STR      R0,[SP, #+28]
   \   00000098   00009DE5           LDR      R0,[SP, #+0]
   \   0000009C   F800D0E1           LDRSH    R0,[R0, #+8]
   \   000000A0   010040E0           SUB      R0,R0,R1
   \   000000A4   010080E2           ADD      R0,R0,#+1
   \   000000A8   18008DE5           STR      R0,[SP, #+24]
    948            ySize = pSprite->Rect.y1 - yPos + 1;
   \   000000AC   00009DE5           LDR      R0,[SP, #+0]
   \   000000B0   1C109DE5           LDR      R1,[SP, #+28]
   \   000000B4   FA00D0E1           LDRSH    R0,[R0, #+10]
   \   000000B8   010040E0           SUB      R0,R0,R1
   \   000000BC   010080E2           ADD      R0,R0,#+1
   \   000000C0   30008DE5           STR      R0,[SP, #+48]
    949            if (pSprite->Flags & GUI_SPRITE_CF_SHOW) {
   \   000000C4   00009DE5           LDR      R0,[SP, #+0]
   \   000000C8   1800D0E5           LDRB     R0,[R0, #+24]
   \   000000CC   020010E3           TST      R0,#0x2
   \   000000D0   BF00000A           BEQ      ??_SetPosition_2
    950              pBM   = pSprite->pBM;
   \   000000D4   00009DE5           LDR      R0,[SP, #+0]
    951              pData = (LCD_PIXELINDEX *)((U8 *)pSprite + sizeof(GUI_SPRITE_OBJ));
    952              xOff  = xNewPos - xPos;
   \   000000D8   20109DE5           LDR      R1,[SP, #+32]
   \   000000DC   1C0090E5           LDR      R0,[R0, #+28]
   \   000000E0   5C008DE5           STR      R0,[SP, #+92]
   \   000000E4   00009DE5           LDR      R0,[SP, #+0]
   \   000000E8   200080E2           ADD      R0,R0,#+32
   \   000000EC   6C008DE5           STR      R0,[SP, #+108]
   \   000000F0   74009DE5           LDR      R0,[SP, #+116]
   \   000000F4   010040E0           SUB      R0,R0,R1
   \   000000F8   14008DE5           STR      R0,[SP, #+20]
    953              yOff  = yNewPos - yPos;
   \   000000FC   78009DE5           LDR      R0,[SP, #+120]
   \   00000100   1C109DE5           LDR      R1,[SP, #+28]
   \   00000104   010040E0           SUB      R0,R0,R1
   \   00000108   10008DE5           STR      R0,[SP, #+16]
    954              if (xOff > 0) {
   \   0000010C   18009DE5           LDR      R0,[SP, #+24]
   \   00000110   14109DE5           LDR      R1,[SP, #+20]
   \   00000114   010040E2           SUB      R0,R0,#+1
   \   00000118   010051E3           CMP      R1,#+1
   \   0000011C   090000BA           BLT      ??_SetPosition_3
    955                xStep  = 1;
   \   00000120   0120A0E3           MOV      R2,#+1
   \   00000124   58208DE5           STR      R2,[SP, #+88]
    956                xStart = 0;
   \   00000128   0020A0E3           MOV      R2,#+0
   \   0000012C   2C208DE5           STR      R2,[SP, #+44]
    957                xEnd   = xSize;
   \   00000130   18209DE5           LDR      R2,[SP, #+24]
    958                xOverlapMax = xEnd - 1;
    959                xOverlapMin = xOff;
   \   00000134   14109DE5           LDR      R1,[SP, #+20]
   \   00000138   28208DE5           STR      R2,[SP, #+40]
   \   0000013C   54008DE5           STR      R0,[SP, #+84]
   \   00000140   50108DE5           STR      R1,[SP, #+80]
   \   00000144   090000EA           B        ??_SetPosition_4
    960              } else {
    961                xStep  = -1;
    962                xStart = xSize - 1;
    963                xEnd   = -1;
    964                xOverlapMin = 0;
   \                     ??_SetPosition_3:
   \   00000148   0010A0E3           MOV      R1,#+0
   \   0000014C   2C008DE5           STR      R0,[SP, #+44]
   \   00000150   50108DE5           STR      R1,[SP, #+80]
    965                xOverlapMax = xStart + xOff;
   \   00000154   2C009DE5           LDR      R0,[SP, #+44]
   \   00000158   14109DE5           LDR      R1,[SP, #+20]
   \   0000015C   0020E0E3           MVN      R2,#+0
   \   00000160   000081E0           ADD      R0,R1,R0
   \   00000164   58208DE5           STR      R2,[SP, #+88]
   \   00000168   28208DE5           STR      R2,[SP, #+40]
   \   0000016C   54008DE5           STR      R0,[SP, #+84]
    966              }
    967              if (yOff > 0) {
   \                     ??_SetPosition_4:
   \   00000170   30009DE5           LDR      R0,[SP, #+48]
   \   00000174   10109DE5           LDR      R1,[SP, #+16]
   \   00000178   010040E2           SUB      R0,R0,#+1
   \   0000017C   010051E3           CMP      R1,#+1
   \   00000180   080000BA           BLT      ??_SetPosition_5
    968                yStep  = 1;
   \   00000184   0120A0E3           MOV      R2,#+1
   \   00000188   4C208DE5           STR      R2,[SP, #+76]
    969                yStart = 0;
    970                yEnd   = ySize;
   \   0000018C   30209DE5           LDR      R2,[SP, #+48]
    971                yOverlapMax = yEnd - 1;
    972                yOverlapMin = yOff;
   \   00000190   10109DE5           LDR      R1,[SP, #+16]
   \   00000194   0040A0E3           MOV      R4,#+0
   \   00000198   24208DE5           STR      R2,[SP, #+36]
   \   0000019C   48008DE5           STR      R0,[SP, #+72]
   \   000001A0   44108DE5           STR      R1,[SP, #+68]
   \   000001A4   080000EA           B        ??_SetPosition_6
    973              } else {
    974                yStep  = -1;
    975                yStart = ySize - 1;
   \                     ??_SetPosition_5:
   \   000001A8   0040A0E1           MOV      R4,R0
    976                yEnd   = -1;
    977                yOverlapMin = 0;
    978                yOverlapMax = yStart + yOff;
   \   000001AC   10009DE5           LDR      R0,[SP, #+16]
   \   000001B0   0020E0E3           MVN      R2,#+0
   \   000001B4   0010A0E3           MOV      R1,#+0
   \   000001B8   040080E0           ADD      R0,R0,R4
   \   000001BC   4C208DE5           STR      R2,[SP, #+76]
   \   000001C0   24208DE5           STR      R2,[SP, #+36]
   \   000001C4   44108DE5           STR      R1,[SP, #+68]
   \   000001C8   48008DE5           STR      R0,[SP, #+72]
    979              }
    980              pColors = (LCD_PIXELINDEX *)GUI_LOCK_H(pSprite->hColors);
   \                     ??_SetPosition_6:
   \   000001CC   00009DE5           LDR      R0,[SP, #+0]
   \   000001D0   0C0090E5           LDR      R0,[R0, #+12]
   \   000001D4   ........           BL       GUI_ALLOC_LockH
   \   000001D8   68008DE5           STR      R0,[SP, #+104]
    981              pDevice->pDeviceAPI->pfGetRect(pDevice, &ClipRect);
   \   000001DC   04009DE5           LDR      R0,[SP, #+4]
   \   000001E0   08108DE2           ADD      R1,SP,#+8
   \   000001E4   0C2090E5           LDR      R2,[R0, #+12]
   \   000001E8   302092E5           LDR      R2,[R2, #+48]
   \   000001EC   32FF2FE1           BLX      R2
    982              for (y = yStart; y != yEnd; y += yStep) {
   \   000001F0   24009DE5           LDR      R0,[SP, #+36]
   \   000001F4   000054E1           CMP      R4,R0
   \   000001F8   7400000A           BEQ      ??_SetPosition_7
    983                char yOverlaps;
    984                int yNew = yPos + y + yOff;
   \                     ??_SetPosition_8:
   \   000001FC   1C009DE5           LDR      R0,[SP, #+28]
   \   00000200   10109DE5           LDR      R1,[SP, #+16]
    985                yOverlaps    = (y >= yOverlapMin) && (y <= yOverlapMax);
    986                for (x = xStart; x != xEnd; x += xStep) {
   \   00000204   2C609DE5           LDR      R6,[SP, #+44]
   \   00000208   000081E0           ADD      R0,R1,R0
   \   0000020C   005084E0           ADD      R5,R4,R0
   \   00000210   44009DE5           LDR      R0,[SP, #+68]
   \   00000214   000054E1           CMP      R4,R0
   \   00000218   48009DA5           LDRGE    R0,[SP, #+72]
   \   0000021C   040050A1           CMPGE    R0,R4
   \   00000220   10009DE5           LDR      R0,[SP, #+16]
   \   00000224   0110A0A3           MOVGE    R1,#+1
   \   00000228   000044E0           SUB      R0,R4,R0
   \   0000022C   3C008DE5           STR      R0,[SP, #+60]
   \   00000230   0010A0B3           MOVLT    R1,#+0
   \   00000234   18009DE5           LDR      R0,[SP, #+24]
   \   00000238   40108DE5           STR      R1,[SP, #+64]
   \   0000023C   900401E0           MUL      R1,R0,R4
   \   00000240   1C009DE5           LDR      R0,[SP, #+28]
   \   00000244   64108DE5           STR      R1,[SP, #+100]
   \   00000248   040080E0           ADD      R0,R0,R4
   \   0000024C   60008DE5           STR      R0,[SP, #+96]
   \   00000250   28009DE5           LDR      R0,[SP, #+40]
   \   00000254   000056E1           CMP      R6,R0
   \   00000258   5700000A           BEQ      ??_SetPosition_9
    987                  char xyOverlaps;
    988                  int BitmapPixel;
    989                  int BkPixel;
    990                  LCD_PIXELINDEX * pSave;
    991                  int xNew;
    992          
    993                  BkPixel = 0;
   \                     ??_SetPosition_10:
   \   0000025C   00A0A0E3           MOV      R10,#+0
    994                  BitmapPixel = GUI_GetBitmapPixelIndex(pBM, x, y);
   \   00000260   0420A0E1           MOV      R2,R4
   \   00000264   0610A0E1           MOV      R1,R6
   \   00000268   5C009DE5           LDR      R0,[SP, #+92]
   \   0000026C   ........           BL       GUI_GetBitmapPixelIndex
   \   00000270   0070B0E1           MOVS     R7,R0
    995                  //
    996                  // Manage pixel only if it is not transparent
    997                  //
    998                  if (BitmapPixel) {
   \   00000274   4B00000A           BEQ      ??_SetPosition_11
    999                    LCD_PIXELINDEX NewPixel;
   1000                    int DoSetSpriteBkPixel;
   1001                    pSave      = pData + x + y * xSize;
   \   00000278   64009DE5           LDR      R0,[SP, #+100]
   \   0000027C   6C109DE5           LDR      R1,[SP, #+108]
   \   00000280   000181E0           ADD      R0,R1,R0, LSL #+2
   \   00000284   068180E0           ADD      R8,R0,R6, LSL #+2
   1002                    xNew       = xPos + x + xOff;
   \   00000288   20009DE5           LDR      R0,[SP, #+32]
   \   0000028C   14109DE5           LDR      R1,[SP, #+20]
   \   00000290   000081E0           ADD      R0,R1,R0
   \   00000294   009086E0           ADD      R9,R6,R0
   1003                    xyOverlaps = (x >= xOverlapMin) && (x <= xOverlapMax) && yOverlaps;
   \   00000298   50009DE5           LDR      R0,[SP, #+80]
   \   0000029C   000056E1           CMP      R6,R0
   \   000002A0   54009DA5           LDRGE    R0,[SP, #+84]
   \   000002A4   060050A1           CMPGE    R0,R6
   \   000002A8   030000BA           BLT      ??_SetPosition_12
   \   000002AC   40009DE5           LDR      R0,[SP, #+64]
   \   000002B0   000050E3           CMP      R0,#+0
   \   000002B4   01B0A013           MOVNE    R11,#+1
   \   000002B8   0000001A           BNE      ??_SetPosition_13
   \                     ??_SetPosition_12:
   \   000002BC   00B0A0E3           MOV      R11,#+0
   1004                    //
   1005                    // Get background pixel of new position
   1006                    //
   1007                    if ((xNew >= ClipRect.x0) && (yNew >= ClipRect.y0) && (xNew <= ClipRect.x1) && (yNew <= ClipRect.y1)) {
   \                     ??_SetPosition_13:
   \   000002C0   F800DDE1           LDRSH    R0,[SP, #+8]
   \   000002C4   000059E1           CMP      R9,R0
   \   000002C8   FA00DDA1           LDRSHGE  R0,[SP, #+10]
   \   000002CC   000055A1           CMPGE    R5,R0
   \   000002D0   FC00DDA1           LDRSHGE  R0,[SP, #+12]
   \   000002D4   090050A1           CMPGE    R0,R9
   \   000002D8   FE00DDA1           LDRSHGE  R0,[SP, #+14]
   \   000002DC   050050A1           CMPGE    R0,R5
   \   000002E0   050000BA           BLT      ??_SetPosition_14
   1008                      BkPixel = _GetBkPixel(xNew, yNew, pDevice, pSprite);
   \   000002E4   00309DE5           LDR      R3,[SP, #+0]
   \   000002E8   04209DE5           LDR      R2,[SP, #+4]
   \   000002EC   0510A0E1           MOV      R1,R5
   \   000002F0   0900A0E1           MOV      R0,R9
   \   000002F4   ........           BL       _GetBkPixel
   \   000002F8   00A0A0E1           MOV      R10,R0
   1009                    }
   1010                    //
   1011                    // Restore old pixel if it was not transparent
   1012                    //
   1013                    DoSetSpriteBkPixel = 0;
   1014                    if (!xyOverlaps) {
   \                     ??_SetPosition_14:
   \   000002FC   00005BE3           CMP      R11,#+0
   \   00000300   4C00001A           BNE      ??_SetPosition_15
   1015                      DoSetSpriteBkPixel = 1;
   1016                    } else {
   1017                      if (((x - xOff) >= 0) && ((y - yOff) >= 0)) {
   1018                        if (GUI_GetBitmapPixelIndex(pBM, x - xOff, y - yOff) == 0) {
   1019                          DoSetSpriteBkPixel = 1;
   1020                        }
   1021                      }
   1022                    }
   1023                    if (DoSetSpriteBkPixel) {
   1024                      xPosBK = x + xPos;
   \                     ??_SetPosition_16:
   \   00000304   20009DE5           LDR      R0,[SP, #+32]
   1025                      yPosBK = y + yPos;
   \   00000308   60209DE5           LDR      R2,[SP, #+96]
   \   0000030C   061080E0           ADD      R1,R0,R6
   1026                      if ((xPosBK >= ClipRect.x0) && (yPosBK >= ClipRect.y0) && (xPosBK <= ClipRect.x1) && (yPosBK <= ClipRect.y1)) {
   \   00000310   F800DDE1           LDRSH    R0,[SP, #+8]
   \   00000314   000051E1           CMP      R1,R0
   \   00000318   FA00DDA1           LDRSHGE  R0,[SP, #+10]
   \   0000031C   000052A1           CMPGE    R2,R0
   \   00000320   FC00DDA1           LDRSHGE  R0,[SP, #+12]
   \   00000324   010050A1           CMPGE    R0,R1
   \   00000328   FE00DDA1           LDRSHGE  R0,[SP, #+14]
   \   0000032C   020050A1           CMPGE    R0,R2
   \   00000330   070000BA           BLT      ??_SetPosition_17
   1027                        _SetSpriteBkPixel(xPosBK, yPosBK, *(pSave), pDevice);
   \   00000334   04009DE5           LDR      R0,[SP, #+4]
   \   00000338   000090E5           LDR      R0,[R0, #+0]
   \   0000033C   000050E3           CMP      R0,#+0
   \   00000340   0300000A           BEQ      ??_SetPosition_17
   \   00000344   0CC090E5           LDR      R12,[R0, #+12]
   \   00000348   003098E5           LDR      R3,[R8, #+0]
   \   0000034C   18C09CE5           LDR      R12,[R12, #+24]
   \   00000350   3CFF2FE1           BLX      R12
   1028                      }
   1029                    }
   1030                    //
   1031                    // Draw new pixel
   1032                    //
   1033                    if ((xNew >= ClipRect.x0) && (yNew >= ClipRect.y0) && (xNew <= ClipRect.x1) && (yNew <= ClipRect.y1)) {
   \                     ??_SetPosition_17:
   \   00000354   F800DDE1           LDRSH    R0,[SP, #+8]
   \   00000358   000059E1           CMP      R9,R0
   \   0000035C   FA00DDA1           LDRSHGE  R0,[SP, #+10]
   \   00000360   000055A1           CMPGE    R5,R0
   \   00000364   FC00DDA1           LDRSHGE  R0,[SP, #+12]
   \   00000368   090050A1           CMPGE    R0,R9
   \   0000036C   FE00DDA1           LDRSHGE  R0,[SP, #+14]
   \   00000370   050050A1           CMPGE    R0,R5
   \   00000374   0A0000BA           BLT      ??_SetPosition_18
   1034                      NewPixel = *(pColors + BitmapPixel);
   1035                      _SetSpriteBkPixel(xNew, yNew, NewPixel, pDevice);
   \   00000378   04009DE5           LDR      R0,[SP, #+4]
   \   0000037C   000090E5           LDR      R0,[R0, #+0]
   \   00000380   000050E3           CMP      R0,#+0
   \   00000384   0600000A           BEQ      ??_SetPosition_18
   \   00000388   68109DE5           LDR      R1,[SP, #+104]
   \   0000038C   0CC090E5           LDR      R12,[R0, #+12]
   \   00000390   073191E7           LDR      R3,[R1, +R7, LSL #+2]
   \   00000394   0520A0E1           MOV      R2,R5
   \   00000398   0910A0E1           MOV      R1,R9
   \   0000039C   18C09CE5           LDR      R12,[R12, #+24]
   \   000003A0   3CFF2FE1           BLX      R12
   1036                    }
   1037                    //
   1038                    // Save background pixel
   1039                    //
   1040                    *pSave = BkPixel;
   \                     ??_SetPosition_18:
   \   000003A4   00A088E5           STR      R10,[R8, #+0]
   \                     ??_SetPosition_11:
   \   000003A8   58009DE5           LDR      R0,[SP, #+88]
   \   000003AC   066080E0           ADD      R6,R0,R6
   \   000003B0   28009DE5           LDR      R0,[SP, #+40]
   \   000003B4   000056E1           CMP      R6,R0
   \   000003B8   A7FFFF1A           BNE      ??_SetPosition_10
   \                     ??_SetPosition_9:
   \   000003BC   4C009DE5           LDR      R0,[SP, #+76]
   \   000003C0   044080E0           ADD      R4,R0,R4
   \   000003C4   24009DE5           LDR      R0,[SP, #+36]
   \   000003C8   000054E1           CMP      R4,R0
   \   000003CC   8AFFFF1A           BNE      ??_SetPosition_8
   1041                  }
   1042                }
   1043              }
   1044              GUI_UNLOCK_H(pColors);
   \                     ??_SetPosition_7:
   \   000003D0   ........           BL       GUI_ALLOC_UnlockH
   1045            }
   1046            //
   1047            // Adjust position of sprite
   1048            //
   1049            pSprite->Rect.x0 = xNewPos;
   \                     ??_SetPosition_2:
   \   000003D4   00009DE5           LDR      R0,[SP, #+0]
   \   000003D8   74109DE5           LDR      R1,[SP, #+116]
   \   000003DC   B410C0E1           STRH     R1,[R0, #+4]
   1050            pSprite->Rect.y0 = yNewPos;
   \   000003E0   00009DE5           LDR      R0,[SP, #+0]
   \   000003E4   78109DE5           LDR      R1,[SP, #+120]
   \   000003E8   B610C0E1           STRH     R1,[R0, #+6]
   1051            pSprite->Rect.x1 = xNewPos + xSize - 1;
   \   000003EC   74009DE5           LDR      R0,[SP, #+116]
   \   000003F0   18109DE5           LDR      R1,[SP, #+24]
   \   000003F4   000081E0           ADD      R0,R1,R0
   \   000003F8   00109DE5           LDR      R1,[SP, #+0]
   \   000003FC   010040E2           SUB      R0,R0,#+1
   \   00000400   B800C1E1           STRH     R0,[R1, #+8]
   1052            pSprite->Rect.y1 = yNewPos + ySize - 1;
   \   00000404   78009DE5           LDR      R0,[SP, #+120]
   \   00000408   30109DE5           LDR      R1,[SP, #+48]
   \   0000040C   000081E0           ADD      R0,R1,R0
   \   00000410   00109DE5           LDR      R1,[SP, #+0]
   \   00000414   010040E2           SUB      R0,R0,#+1
   \   00000418   BA00C1E1           STRH     R0,[R1, #+10]
   1053            RESTORE_LAYER()
   \   0000041C   38009DE5           LDR      R0,[SP, #+56]
   \   00000420   34109DE5           LDR      R1,[SP, #+52]
   \   00000424   010050E1           CMP      R0,R1
   \   00000428   04FFFF0A           BEQ      ??_SetPosition_1
   \   0000042C   ........           LDR      R0,??DataTable17
   \   00000430   1110C0E5           STRB     R1,[R0, #+17]
   \   00000434   01FFFFEA           B        ??_SetPosition_1
   \                     ??_SetPosition_15:
   \   00000438   14009DE5           LDR      R0,[SP, #+20]
   \   0000043C   001056E0           SUBS     R1,R6,R0
   \   00000440   3C009D55           LDRPL    R0,[SP, #+60]
   \   00000444   00005053           CMPPL    R0,#+0
   \   00000448   C1FFFF4A           BMI      ??_SetPosition_17
   \   0000044C   0020A0E1           MOV      R2,R0
   \   00000450   5C009DE5           LDR      R0,[SP, #+92]
   \   00000454   ........           BL       GUI_GetBitmapPixelIndex
   \   00000458   000050E3           CMP      R0,#+0
   \   0000045C   BCFFFF1A           BNE      ??_SetPosition_17
   \   00000460   A7FFFFEA           B        ??_SetPosition_16
   1054            GUI_UNLOCK_H(pSprite);
   1055          }
   1056          
   1057          /*********************************************************************
   1058          *
   1059          *       _SetBitmapAndPosition
   1060          */

   \                                 In section .text, align 4, keep-with-next
   1061          static void _SetBitmapAndPosition(GUI_HSPRITE hSprite, const GUI_BITMAP GUI_UNI_PTR * pBM_New, int xOff, int yOff) {
   \                     _SetBitmapAndPosition:
   \   00000000   FC4F2DE9           PUSH     {R2-R11,LR}
   \   00000004   44D04DE2           SUB      SP,SP,#+68
   \   00000008   0150A0E1           MOV      R5,R1
   1062            GUI_SPRITE_OBJ * pSprite;
   1063            int xSize, ySize;
   1064            int x, y;
   1065            int xStart, xEnd, yStart, yEnd;
   1066            int xInc, yInc;
   1067            const GUI_BITMAP GUI_UNI_PTR * pBM_Old;
   1068            LCD_PIXELINDEX * pData;
   1069            LCD_PIXELINDEX * pColors;
   1070            GUI_DEVICE * pDevice;
   1071            GUI_RECT ClipRect;
   1072            int xPos, yPos;
   1073            int Pixel, Overlap, Undraw;
   1074            int PixelOld, PixelNew;
   1075            int Index, BkIndex;
   1076            int Layer, LayerOld;
   1077            LCD_PIXELINDEX Data;
   1078          
   1079            pSprite = SPRITE_LOCK_H(hSprite);
   \   0000000C   ........           BL       GUI_ALLOC_LockH
   \   00000010   0060A0E1           MOV      R6,R0
   1080            pDevice = pSprite->pDevice;
   \   00000014   001096E5           LDR      R1,[R6, #+0]
   \   00000018   00108DE5           STR      R1,[SP, #+0]
   1081            SET_SPRITE_LAYER()
   \   0000001C   180091E5           LDR      R0,[R1, #+24]
   \   00000020   1C008DE5           STR      R0,[SP, #+28]
   \   00000024   ........           LDR      R0,??DataTable17
   \   00000028   1100D0E5           LDRB     R0,[R0, #+17]
   \   0000002C   18008DE5           STR      R0,[SP, #+24]
   \   00000030   1C009DE5           LDR      R0,[SP, #+28]
   \   00000034   18109DE5           LDR      R1,[SP, #+24]
   \   00000038   010050E1           CMP      R0,R1
   \   0000003C   ........           LDRNE    R0,??DataTable17
   \   00000040   1C109D15           LDRNE    R1,[SP, #+28]
   \   00000044   1110C015           STRBNE   R1,[R0, #+17]
   1082            pBM_Old   = pSprite->pBM;
   \   00000048   1C0096E5           LDR      R0,[R6, #+28]
   \   0000004C   3C008DE5           STR      R0,[SP, #+60]
   1083            pData = (LCD_PIXELINDEX *)((U8 *)pSprite + sizeof(GUI_SPRITE_OBJ));
   \   00000050   200086E2           ADD      R0,R6,#+32
   \   00000054   38008DE5           STR      R0,[SP, #+56]
   1084            xSize = pSprite->Rect.x1 - pSprite->Rect.x0 + 1;
   \   00000058   F800D6E1           LDRSH    R0,[R6, #+8]
   \   0000005C   F410D6E1           LDRSH    R1,[R6, #+4]
   \   00000060   010040E0           SUB      R0,R0,R1
   \   00000064   010080E2           ADD      R0,R0,#+1
   \   00000068   14008DE5           STR      R0,[SP, #+20]
   1085            ySize = pSprite->Rect.y1 - pSprite->Rect.y0 + 1;
   \   0000006C   FA00D6E1           LDRSH    R0,[R6, #+10]
   \   00000070   F610D6E1           LDRSH    R1,[R6, #+6]
   \   00000074   010040E0           SUB      R0,R0,R1
   1086            if (yOff < 0) {
   \   00000078   48109DE5           LDR      R1,[SP, #+72]
   \   0000007C   010080E2           ADD      R0,R0,#+1
   \   00000080   000051E3           CMP      R1,#+0
   \   00000084   0300005A           BPL      ??_SetBitmapAndPosition_0
   1087              yStart = ySize - 1;
   1088              yEnd   = -1;
   \   00000088   0010E0E3           MVN      R1,#+0
   \   0000008C   014040E2           SUB      R4,R0,#+1
   \   00000090   10108DE5           STR      R1,[SP, #+16]
   1089              yInc   = -1;
   \   00000094   020000EA           B        ??_SetBitmapAndPosition_1
   1090            } else {
   1091              yStart = 0;
   \                     ??_SetBitmapAndPosition_0:
   \   00000098   0040A0E3           MOV      R4,#+0
   1092              yEnd   = ySize;
   \   0000009C   10008DE5           STR      R0,[SP, #+16]
   1093              yInc   = 1;
   \   000000A0   0110A0E3           MOV      R1,#+1
   1094            }
   1095            if (xOff < 0) {
   \                     ??_SetBitmapAndPosition_1:
   \   000000A4   44009DE5           LDR      R0,[SP, #+68]
   \   000000A8   2C108DE5           STR      R1,[SP, #+44]
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   0500005A           BPL      ??_SetBitmapAndPosition_2
   1096              xStart = xSize - 1;
   \   000000B4   14009DE5           LDR      R0,[SP, #+20]
   1097              xEnd   = -1;
   \   000000B8   0010E0E3           MVN      R1,#+0
   \   000000BC   010040E2           SUB      R0,R0,#+1
   \   000000C0   28008DE5           STR      R0,[SP, #+40]
   \   000000C4   0C108DE5           STR      R1,[SP, #+12]
   1098              xInc   = -1;
   \   000000C8   040000EA           B        ??_SetBitmapAndPosition_3
   1099            } else {
   1100              xStart = 0;
   \                     ??_SetBitmapAndPosition_2:
   \   000000CC   0010A0E3           MOV      R1,#+0
   \   000000D0   28108DE5           STR      R1,[SP, #+40]
   1101              xEnd   = xSize;
   \   000000D4   14109DE5           LDR      R1,[SP, #+20]
   \   000000D8   0C108DE5           STR      R1,[SP, #+12]
   1102              xInc   = 1;
   \   000000DC   0110A0E3           MOV      R1,#+1
   \                     ??_SetBitmapAndPosition_3:
   \   000000E0   24108DE5           STR      R1,[SP, #+36]
   1103            }
   1104            pColors = (LCD_PIXELINDEX *)GUI_LOCK_H(pSprite->hColors);
   \   000000E4   0C0096E5           LDR      R0,[R6, #+12]
   \   000000E8   ........           BL       GUI_ALLOC_LockH
   \   000000EC   34008DE5           STR      R0,[SP, #+52]
   1105            pDevice->pDeviceAPI->pfGetRect(pDevice, &ClipRect);
   \   000000F0   00009DE5           LDR      R0,[SP, #+0]
   \   000000F4   04108DE2           ADD      R1,SP,#+4
   \   000000F8   0C2090E5           LDR      R2,[R0, #+12]
   \   000000FC   302092E5           LDR      R2,[R2, #+48]
   \   00000100   32FF2FE1           BLX      R2
   1106            for (y = yStart; y != yEnd; y += yInc) {
   \   00000104   10009DE5           LDR      R0,[SP, #+16]
   \   00000108   000054E1           CMP      R4,R0
   \   0000010C   7100000A           BEQ      ??_SetBitmapAndPosition_4
   1107              for (x = xStart; x != xEnd; x += xInc) {
   \                     ??_SetBitmapAndPosition_5:
   \   00000110   14109DE5           LDR      R1,[SP, #+20]
   \   00000114   28709DE5           LDR      R7,[SP, #+40]
   \   00000118   910400E0           MUL      R0,R1,R4
   \   0000011C   38109DE5           LDR      R1,[SP, #+56]
   \   00000120   000181E0           ADD      R0,R1,R0, LSL #+2
   \   00000124   20008DE5           STR      R0,[SP, #+32]
   \   00000128   48009DE5           LDR      R0,[SP, #+72]
   \   0000012C   000044E0           SUB      R0,R4,R0
   \   00000130   30008DE5           STR      R0,[SP, #+48]
   \   00000134   0C009DE5           LDR      R0,[SP, #+12]
   \   00000138   000057E1           CMP      R7,R0
   \   0000013C   6000000A           BEQ      ??_SetBitmapAndPosition_6
   1108                Undraw = 1;
   1109                PixelOld = GUI_GetBitmapPixelIndex(pBM_Old, x, y);
   \                     ??_SetBitmapAndPosition_7:
   \   00000140   0420A0E1           MOV      R2,R4
   \   00000144   0710A0E1           MOV      R1,R7
   \   00000148   3C009DE5           LDR      R0,[SP, #+60]
   \   0000014C   ........           BL       GUI_GetBitmapPixelIndex
   \   00000150   00B0A0E1           MOV      R11,R0
   1110                PixelNew = GUI_GetBitmapPixelIndex(pBM_New, x, y);
   \   00000154   0420A0E1           MOV      R2,R4
   \   00000158   0710A0E1           MOV      R1,R7
   \   0000015C   0500A0E1           MOV      R0,R5
   \   00000160   ........           BL       GUI_GetBitmapPixelIndex
   \   00000164   0080A0E1           MOV      R8,R0
   1111                xPos = x - xOff;
   \   00000168   44009DE5           LDR      R0,[SP, #+68]
   1112                yPos = y - yOff;
   \   0000016C   30A09DE5           LDR      R10,[SP, #+48]
   \   00000170   009057E0           SUBS     R9,R7,R0
   1113                Overlap = (xPos >= 0) && (yPos >= 0) && (xPos < pBM_New->XSize) && (yPos < pBM_New->YSize);
   \   00000174   00005A53           CMPPL    R10,#+0
   \   00000178   0500004A           BMI      ??_SetBitmapAndPosition_8
   \   0000017C   B000D5E1           LDRH     R0,[R5, #+0]
   \   00000180   000059E1           CMP      R9,R0
   \   00000184   B200D5B1           LDRHLT   R0,[R5, #+2]
   \   00000188   00005AB1           CMPLT    R10,R0
   \   0000018C   0100A0B3           MOVLT    R0,#+1
   \   00000190   000000BA           BLT      ??_SetBitmapAndPosition_9
   \                     ??_SetBitmapAndPosition_8:
   \   00000194   0000A0E3           MOV      R0,#+0
   1114                //
   1115                // Restore background
   1116                //
   1117                if (PixelOld) {
   \                     ??_SetBitmapAndPosition_9:
   \   00000198   00005BE3           CMP      R11,#+0
   \   0000019C   1D00000A           BEQ      ??_SetBitmapAndPosition_10
   1118                  if (Overlap) {
   \   000001A0   000050E3           CMP      R0,#+0
   \   000001A4   0500000A           BEQ      ??_SetBitmapAndPosition_11
   1119                    Pixel = GUI_GetBitmapPixelIndex(pBM_New, xPos, yPos);
   1120                    if (Pixel) {
   \   000001A8   0A20A0E1           MOV      R2,R10
   \   000001AC   0910A0E1           MOV      R1,R9
   \   000001B0   0500A0E1           MOV      R0,R5
   \   000001B4   ........           BL       GUI_GetBitmapPixelIndex
   \   000001B8   000050E3           CMP      R0,#+0
   \   000001BC   1500001A           BNE      ??_SetBitmapAndPosition_10
   1121                      Undraw = 0;
   1122                    }
   1123                  }
   1124                  if (Undraw) {
   1125                    xPos = pSprite->Rect.x0 + x;
   \                     ??_SetBitmapAndPosition_11:
   \   000001C0   F400D6E1           LDRSH    R0,[R6, #+4]
   \   000001C4   001087E0           ADD      R1,R7,R0
   1126                    yPos = pSprite->Rect.y0 + y;
   \   000001C8   F600D6E1           LDRSH    R0,[R6, #+6]
   \   000001CC   002084E0           ADD      R2,R4,R0
   1127                    if ((xPos >= ClipRect.x0) && (yPos >= ClipRect.y0) && (xPos <= ClipRect.x1) && (yPos <= ClipRect.y1)) {
   \   000001D0   F400DDE1           LDRSH    R0,[SP, #+4]
   \   000001D4   000051E1           CMP      R1,R0
   \   000001D8   F600DDA1           LDRSHGE  R0,[SP, #+6]
   \   000001DC   000052A1           CMPGE    R2,R0
   \   000001E0   F800DDA1           LDRSHGE  R0,[SP, #+8]
   \   000001E4   010050A1           CMPGE    R0,R1
   \   000001E8   FA00DDA1           LDRSHGE  R0,[SP, #+10]
   \   000001EC   020050A1           CMPGE    R0,R2
   \   000001F0   080000BA           BLT      ??_SetBitmapAndPosition_10
   1128                      Data = *(pData + y * xSize + x);
   1129                      _SetSpriteBkPixel(pSprite->Rect.x0 + x, pSprite->Rect.y0 + y, Data, pDevice);
   \   000001F4   00009DE5           LDR      R0,[SP, #+0]
   \   000001F8   000090E5           LDR      R0,[R0, #+0]
   \   000001FC   000050E3           CMP      R0,#+0
   \   00000200   0400000A           BEQ      ??_SetBitmapAndPosition_10
   \   00000204   20309DE5           LDR      R3,[SP, #+32]
   \   00000208   0CC090E5           LDR      R12,[R0, #+12]
   \   0000020C   073193E7           LDR      R3,[R3, +R7, LSL #+2]
   \   00000210   18C09CE5           LDR      R12,[R12, #+24]
   \   00000214   3CFF2FE1           BLX      R12
   1130                    }
   1131                  }
   1132                }
   1133                //
   1134                // Draw new pixel and save background data
   1135                //
   1136                if (PixelNew) {
   \                     ??_SetBitmapAndPosition_10:
   \   00000218   000058E3           CMP      R8,#+0
   \   0000021C   2300000A           BEQ      ??_SetBitmapAndPosition_12
   1137                  xPos = pSprite->Rect.x0 + x + xOff;
   \   00000220   44009DE5           LDR      R0,[SP, #+68]
   \   00000224   F410D6E1           LDRSH    R1,[R6, #+4]
   \   00000228   000087E0           ADD      R0,R7,R0
   \   0000022C   009081E0           ADD      R9,R1,R0
   1138                  yPos = pSprite->Rect.y0 + y + yOff;
   \   00000230   48009DE5           LDR      R0,[SP, #+72]
   \   00000234   F610D6E1           LDRSH    R1,[R6, #+6]
   \   00000238   000084E0           ADD      R0,R4,R0
   \   0000023C   00A081E0           ADD      R10,R1,R0
   1139                  if ((xPos >= ClipRect.x0) && (yPos >= ClipRect.y0) && (xPos <= ClipRect.x1) && (yPos <= ClipRect.y1)) {
   \   00000240   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000244   000059E1           CMP      R9,R0
   \   00000248   F600DDA1           LDRSHGE  R0,[SP, #+6]
   \   0000024C   00005AA1           CMPGE    R10,R0
   \   00000250   F800DDA1           LDRSHGE  R0,[SP, #+8]
   \   00000254   090050A1           CMPGE    R0,R9
   \   00000258   FA00DDA1           LDRSHGE  R0,[SP, #+10]
   \   0000025C   0A0050A1           CMPGE    R0,R10
   \   00000260   120000BA           BLT      ??_SetBitmapAndPosition_12
   1140                    BkIndex = _GetBkPixel(xPos, yPos, pDevice, pSprite);
   \   00000264   0630A0E1           MOV      R3,R6
   \   00000268   00209DE5           LDR      R2,[SP, #+0]
   \   0000026C   0A10A0E1           MOV      R1,R10
   \   00000270   0900A0E1           MOV      R0,R9
   \   00000274   ........           BL       _GetBkPixel
   \   00000278   00B0A0E1           MOV      R11,R0
   1141                    Index = *(pColors + PixelNew);
   1142                    _SetSpriteBkPixel(xPos, yPos, Index, pDevice);
   \   0000027C   00009DE5           LDR      R0,[SP, #+0]
   \   00000280   000090E5           LDR      R0,[R0, #+0]
   \   00000284   000050E3           CMP      R0,#+0
   \   00000288   0600000A           BEQ      ??_SetBitmapAndPosition_13
   \   0000028C   34109DE5           LDR      R1,[SP, #+52]
   \   00000290   0CC090E5           LDR      R12,[R0, #+12]
   \   00000294   083191E7           LDR      R3,[R1, +R8, LSL #+2]
   \   00000298   0A20A0E1           MOV      R2,R10
   \   0000029C   0910A0E1           MOV      R1,R9
   \   000002A0   18C09CE5           LDR      R12,[R12, #+24]
   \   000002A4   3CFF2FE1           BLX      R12
   1143                    *(pData + y * xSize + x) = BkIndex;
   \                     ??_SetBitmapAndPosition_13:
   \   000002A8   20009DE5           LDR      R0,[SP, #+32]
   \   000002AC   07B180E7           STR      R11,[R0, +R7, LSL #+2]
   1144                  }
   1145                }
   1146              }
   \                     ??_SetBitmapAndPosition_12:
   \   000002B0   24009DE5           LDR      R0,[SP, #+36]
   \   000002B4   077080E0           ADD      R7,R0,R7
   \   000002B8   0C009DE5           LDR      R0,[SP, #+12]
   \   000002BC   000057E1           CMP      R7,R0
   \   000002C0   9EFFFF1A           BNE      ??_SetBitmapAndPosition_7
   1147            }
   \                     ??_SetBitmapAndPosition_6:
   \   000002C4   2C009DE5           LDR      R0,[SP, #+44]
   \   000002C8   044080E0           ADD      R4,R0,R4
   \   000002CC   10009DE5           LDR      R0,[SP, #+16]
   \   000002D0   000054E1           CMP      R4,R0
   \   000002D4   8DFFFF1A           BNE      ??_SetBitmapAndPosition_5
   1148            GUI_UNLOCK_H(pColors);
   \                     ??_SetBitmapAndPosition_4:
   \   000002D8   ........           BL       GUI_ALLOC_UnlockH
   1149            pSprite->pBM = pBM_New;
   \   000002DC   1C5086E5           STR      R5,[R6, #+28]
   1150            pSprite->Rect.x0 += xOff;
   \   000002E0   F400D6E1           LDRSH    R0,[R6, #+4]
   \   000002E4   44109DE5           LDR      R1,[SP, #+68]
   \   000002E8   000081E0           ADD      R0,R1,R0
   \   000002EC   B400C6E1           STRH     R0,[R6, #+4]
   1151            pSprite->Rect.x1 += xOff;
   \   000002F0   F800D6E1           LDRSH    R0,[R6, #+8]
   \   000002F4   44109DE5           LDR      R1,[SP, #+68]
   \   000002F8   000081E0           ADD      R0,R1,R0
   \   000002FC   B800C6E1           STRH     R0,[R6, #+8]
   1152            pSprite->Rect.y0 += yOff;
   \   00000300   F600D6E1           LDRSH    R0,[R6, #+6]
   \   00000304   48109DE5           LDR      R1,[SP, #+72]
   \   00000308   000081E0           ADD      R0,R1,R0
   \   0000030C   B600C6E1           STRH     R0,[R6, #+6]
   1153            pSprite->Rect.y1 += yOff;
   \   00000310   FA00D6E1           LDRSH    R0,[R6, #+10]
   \   00000314   48109DE5           LDR      R1,[SP, #+72]
   \   00000318   000081E0           ADD      R0,R1,R0
   \   0000031C   BA00C6E1           STRH     R0,[R6, #+10]
   1154            RESTORE_LAYER()
   \   00000320   1C009DE5           LDR      R0,[SP, #+28]
   \   00000324   18109DE5           LDR      R1,[SP, #+24]
   \   00000328   010050E1           CMP      R0,R1
   \   0000032C   ........           LDRNE    R0,??DataTable17
   \   00000330   1110C015           STRBNE   R1,[R0, #+17]
   1155            GUI_UNLOCK_H(pSprite);
   \   00000334   ........           BL       GUI_ALLOC_UnlockH
   1156          }
   \   00000338   4CD08DE2           ADD      SP,SP,#+76       ;; stack cleaning
   \   0000033C   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1157          
   1158          /*********************************************************************
   1159          *
   1160          *       _SpriteDraw
   1161          */

   \                                 In section .text, align 4, keep-with-next
   1162          static void _SpriteDraw(GUI_HSPRITE hSprite) {
   \                     _SpriteDraw:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   24D04DE2           SUB      SP,SP,#+36
   1163            GUI_RECT ClipRect;
   1164            GUI_SPRITE_OBJ * pSprite;
   1165            int xPos, yPos, x, y, Index;
   1166            int Layer, LayerOld;
   1167            int PixelNew;
   1168            LCD_PIXELINDEX * pData;
   1169            LCD_PIXELINDEX * pColors;
   1170            const GUI_BITMAP GUI_UNI_PTR * pBM;
   1171            GUI_DEVICE * pDevice;
   1172          
   1173            pSprite = SPRITE_LOCK_H(hSprite);
   \   00000008   ........           BL       GUI_ALLOC_LockH
   \   0000000C   0040A0E1           MOV      R4,R0
   1174            pDevice = pSprite->pDevice;
   \   00000010   005094E5           LDR      R5,[R4, #+0]
   1175            SET_SPRITE_LAYER()
   \   00000014   180095E5           LDR      R0,[R5, #+24]
   \   00000018   10008DE5           STR      R0,[SP, #+16]
   \   0000001C   ........           LDR      R0,??DataTable17
   \   00000020   1100D0E5           LDRB     R0,[R0, #+17]
   \   00000024   0C008DE5           STR      R0,[SP, #+12]
   \   00000028   10009DE5           LDR      R0,[SP, #+16]
   \   0000002C   0C109DE5           LDR      R1,[SP, #+12]
   \   00000030   010050E1           CMP      R0,R1
   \   00000034   ........           LDRNE    R0,??DataTable17
   \   00000038   10109D15           LDRNE    R1,[SP, #+16]
   \   0000003C   1110C015           STRBNE   R1,[R0, #+17]
   1176            pBM = pSprite->pBM;
   \   00000040   1C6094E5           LDR      R6,[R4, #+28]
   1177            pData = (LCD_PIXELINDEX *)((U8 *)pSprite + sizeof(GUI_SPRITE_OBJ));
   \   00000044   200084E2           ADD      R0,R4,#+32
   \   00000048   18008DE5           STR      R0,[SP, #+24]
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   1C0084E5           STR      R0,[R4, #+28]
   1178            pSprite->pBM = NULL; // Temporary remove bitmap to make sure not the background of the sprite itself will be saved
   1179            pColors = (LCD_PIXELINDEX *)GUI_LOCK_H(pSprite->hColors);
   \   00000054   0C0094E5           LDR      R0,[R4, #+12]
   \   00000058   ........           BL       GUI_ALLOC_LockH
   \   0000005C   14008DE5           STR      R0,[SP, #+20]
   1180            ClipRect = pSprite->Rect;
   \   00000060   04008DE2           ADD      R0,SP,#+4
   \   00000064   041084E2           ADD      R1,R4,#+4
   \   00000068   0820A0E3           MOV      R2,#+8
   \   0000006C   ........           BL       __aeabi_memcpy
   1181            _ClipRectEx(pDevice, &ClipRect);
   \   00000070   0C2095E5           LDR      R2,[R5, #+12]
   \   00000074   1C108DE2           ADD      R1,SP,#+28
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   302092E5           LDR      R2,[R2, #+48]
   \   00000080   32FF2FE1           BLX      R2
   \   00000084   1C108DE2           ADD      R1,SP,#+28
   \   00000088   04008DE2           ADD      R0,SP,#+4
   \   0000008C   ........           BL       GUI__IntersectRect
   1182            for (y = ClipRect.y0; y <= ClipRect.y1; y++) {
   \   00000090   F670DDE1           LDRSH    R7,[SP, #+6]
   \   00000094   FA00DDE1           LDRSH    R0,[SP, #+10]
   \   00000098   070050E1           CMP      R0,R7
   \   0000009C   2B0000BA           BLT      ??_SpriteDraw_0
   1183              yPos = y - pSprite->Rect.y0;
   \                     ??_SpriteDraw_1:
   \   000000A0   F600D4E1           LDRSH    R0,[R4, #+6]
   1184              for (x = ClipRect.x0; x <= ClipRect.x1; x++) {
   \   000000A4   F490DDE1           LDRSH    R9,[SP, #+4]
   \   000000A8   008047E0           SUB      R8,R7,R0
   \   000000AC   F800DDE1           LDRSH    R0,[SP, #+8]
   \   000000B0   090050E1           CMP      R0,R9
   \   000000B4   210000BA           BLT      ??_SpriteDraw_2
   1185                xPos = x - pSprite->Rect.x0;
   \                     ??_SpriteDraw_3:
   \   000000B8   F400D4E1           LDRSH    R0,[R4, #+4]
   1186                PixelNew = GUI_GetBitmapPixelIndex(pBM, xPos, yPos);
   \   000000BC   0820A0E1           MOV      R2,R8
   \   000000C0   00A049E0           SUB      R10,R9,R0
   \   000000C4   0A10A0E1           MOV      R1,R10
   \   000000C8   0600A0E1           MOV      R0,R6
   \   000000CC   ........           BL       GUI_GetBitmapPixelIndex
   \   000000D0   00B0B0E1           MOVS     R11,R0
   1187                if (PixelNew) {
   \   000000D4   1500000A           BEQ      ??_SpriteDraw_4
   1188                  //
   1189                  // Save background
   1190                  //
   1191                  *(pData + yPos * pBM->XSize + xPos) = _GetBkPixel(x, y, pDevice, pSprite);
   \   000000D8   B000D6E1           LDRH     R0,[R6, #+0]
   \   000000DC   0430A0E1           MOV      R3,R4
   \   000000E0   0520A0E1           MOV      R2,R5
   \   000000E4   900801E0           MUL      R1,R0,R8
   \   000000E8   18009DE5           LDR      R0,[SP, #+24]
   \   000000EC   010180E0           ADD      R0,R0,R1, LSL #+2
   \   000000F0   00008DE5           STR      R0,[SP, #+0]
   \   000000F4   0710A0E1           MOV      R1,R7
   \   000000F8   0900A0E1           MOV      R0,R9
   \   000000FC   ........           BL       _GetBkPixel
   \   00000100   00109DE5           LDR      R1,[SP, #+0]
   \   00000104   0A0181E7           STR      R0,[R1, +R10, LSL #+2]
   1192                  //
   1193                  // Draw new pixel
   1194                  //
   1195                  Index = *(pColors + PixelNew);
   1196                  _SetSpriteBkPixel(x, y, Index, pDevice);
   \   00000108   000095E5           LDR      R0,[R5, #+0]
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   0600000A           BEQ      ??_SpriteDraw_4
   \   00000114   14109DE5           LDR      R1,[SP, #+20]
   \   00000118   0CC090E5           LDR      R12,[R0, #+12]
   \   0000011C   0B3191E7           LDR      R3,[R1, +R11, LSL #+2]
   \   00000120   0720A0E1           MOV      R2,R7
   \   00000124   0910A0E1           MOV      R1,R9
   \   00000128   18C09CE5           LDR      R12,[R12, #+24]
   \   0000012C   3CFF2FE1           BLX      R12
   1197                }
   1198              }
   \                     ??_SpriteDraw_4:
   \   00000130   F800DDE1           LDRSH    R0,[SP, #+8]
   \   00000134   019089E2           ADD      R9,R9,#+1
   \   00000138   090050E1           CMP      R0,R9
   \   0000013C   DDFFFFAA           BGE      ??_SpriteDraw_3
   1199            }
   \                     ??_SpriteDraw_2:
   \   00000140   FA00DDE1           LDRSH    R0,[SP, #+10]
   \   00000144   017087E2           ADD      R7,R7,#+1
   \   00000148   070050E1           CMP      R0,R7
   \   0000014C   D3FFFFAA           BGE      ??_SpriteDraw_1
   1200            GUI_UNLOCK_H(pColors);
   \                     ??_SpriteDraw_0:
   \   00000150   ........           BL       GUI_ALLOC_UnlockH
   1201            pSprite->pBM = pBM;
   \   00000154   1C6084E5           STR      R6,[R4, #+28]
   1202            RESTORE_LAYER()
   \   00000158   10009DE5           LDR      R0,[SP, #+16]
   \   0000015C   0C109DE5           LDR      R1,[SP, #+12]
   \   00000160   010050E1           CMP      R0,R1
   \   00000164   ........           LDRNE    R0,??DataTable17
   \   00000168   1110C015           STRBNE   R1,[R0, #+17]
   1203            GUI_UNLOCK_H(pSprite);
   \   0000016C   ........           BL       GUI_ALLOC_UnlockH
   1204          }
   \   00000170   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   00000174   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1205          
   1206          /*********************************************************************
   1207          *
   1208          *       _Link
   1209          *
   1210          * Purpose:
   1211          *   Inserts the given sprite into the list. Sprites with non STAYONTOP attribute
   1212          *   are placed directly after the last sprite with STAYONTOP attribute. New
   1213          *   sprites with STAYONTOP attribute are placed at the top of the list.
   1214          */
   1215          static void _Link(GUI_HSPRITE hSprite) {
   1216            GUI_SPRITE_OBJ * pSprite;
   1217          
   1218            pSprite = SPRITE_LOCK_H(hSprite);
   1219            GUI_DEVICE_Link(pSprite->pDevice);
   1220            GUI_UNLOCK_H(pSprite);
   1221          }
   1222          
   1223          /*********************************************************************
   1224          *
   1225          *       _Unlink
   1226          */
   1227          static void _Unlink(GUI_HSPRITE hSprite) {
   1228            GUI_SPRITE_OBJ * pSprite;
   1229          
   1230            pSprite = SPRITE_LOCK_H(hSprite);
   1231            GUI_DEVICE_Unlink(pSprite->pDevice);
   1232            GUI_UNLOCK_H(pSprite);
   1233          }
   1234          
   1235          /*********************************************************************
   1236          *
   1237          *       _DoColorConversion
   1238          */
   1239          static int _DoColorConversion(GUI_HSPRITE hSprite, const GUI_BITMAP GUI_UNI_PTR * pBM) {
   1240            GUI_SPRITE_OBJ * pSprite;
   1241            LCD_PIXELINDEX * pColors;
   1242            int i;
   1243            int Layer;
   1244            GUI_HMEM hColors;
   1245            pSprite = SPRITE_LOCK_H(hSprite);
   1246            hColors = pSprite->hColors;
   1247            Layer = pSprite->pDevice->LayerIndex;
   1248            GUI_UNLOCK_H(pSprite);
   1249            if (hColors) {
   1250              GUI_ALLOC_Free(hColors);
   1251            }
   1252            hColors = GUI_ALLOC_AllocZero(sizeof(LCD_PIXELINDEX) * pBM->pPal->NumEntries);
   1253            if (hColors == 0) {
   1254              return 1;
   1255            }
   1256            pColors = (LCD_PIXELINDEX *)GUI_LOCK_H(hColors);
   1257            for (i = 0; i < pBM->pPal->NumEntries; i++) {
   1258              LCD_COLOR Color;
   1259              LCD_PIXELINDEX Index;
   1260              Color = *(pBM->pPal->pPalEntries + i);
   1261              Index = GUI_Context.apDevice[Layer]->pColorConvAPI->pfColor2Index(Color);
   1262              *(pColors++) = Index;
   1263            }
   1264            GUI_UNLOCK_H(pColors);
   1265            pSprite = SPRITE_LOCK_H(hSprite);
   1266            pSprite->hColors = hColors;
   1267            GUI_UNLOCK_H(pSprite);
   1268            return 0;
   1269          }
   1270          
   1271          /*********************************************************************
   1272          *
   1273          *       _Delete
   1274          */
   1275          static void _Delete(GUI_HSPRITE hSprite) {
   1276            GUI_SPRITE_OBJ * pSprite;
   1277            pSprite = SPRITE_LOCK_H(hSprite);
   1278            GUI_ALLOC_FreeFixedBlock(pSprite->pDevice);
   1279            GUI_ALLOC_Free(pSprite->hColors); // Remove colors from memory
   1280            GUI_ALLOC_Free(hSprite);          // Remove sprite from memory
   1281            GUI_UNLOCK_H(pSprite);
   1282          }
   1283          
   1284          /*********************************************************************
   1285          *
   1286          *       Private code
   1287          *
   1288          **********************************************************************
   1289          */
   1290          /*********************************************************************
   1291          *
   1292          *       GUI_SPRITE__CreateEx
   1293          */

   \                                 In section .text, align 4, keep-with-next
   1294          GUI_HSPRITE GUI_SPRITE__CreateEx(const GUI_BITMAP GUI_UNI_PTR * pBM, int x, int y, int Layer, U16 Flags) {
   \                     GUI_SPRITE__CreateEx:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   1295            GUI_DEVICE * pDevice;        // Pointer to device object
   1296            GUI_HSPRITE      hSpriteNew; // Handle of new sprite
   1297            GUI_SPRITE_OBJ * pSpriteNew; // Pointer to new sprite object
   1298            int AllocSize;
   1299            U16 FlagsDevice;
   1300          
   1301            if ((pBM->XSize == 0) || (pBM->YSize == 0)) {
   \   00000008   B000D5E1           LDRH     R0,[R5, #+0]
   \   0000000C   0170A0E1           MOV      R7,R1
   \   00000010   0280A0E1           MOV      R8,R2
   \   00000014   B062DDE1           LDRH     R6,[SP, #+32]
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   5A00000A           BEQ      ??GUI_SPRITE__CreateEx_0
   \   00000020   B200D5E1           LDRH     R0,[R5, #+2]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0100001A           BNE      ??GUI_SPRITE__CreateEx_1
   1302              return 0; // Error, Zerosized sprites make no sense...
   \                     ??GUI_SPRITE__CreateEx_2:
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   F087BDE8           POP      {R4-R10,PC}
   1303            }
   1304            if (pBM->BitsPerPixel > 8) {
   \                     ??GUI_SPRITE__CreateEx_1:
   \   00000034   B600D5E1           LDRH     R0,[R5, #+6]
   \   00000038   090050E3           CMP      R0,#+9
   \   0000003C   FAFFFF2A           BCS      ??GUI_SPRITE__CreateEx_2
   1305              return 0; // Error, Only pallete based bitmaps are currently supported...
   1306            }
   1307            if (pBM->pPal->pPalEntries == NULL) {
   \   00000040   0C0095E5           LDR      R0,[R5, #+12]
   \   00000044   080090E5           LDR      R0,[R0, #+8]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   4E00000A           BEQ      ??GUI_SPRITE__CreateEx_0
   1308              return 0; // Error, Only device independent bitmaps are currently supported...
   1309            }
   1310            //
   1311            // Create device object
   1312            //
   1313            FlagsDevice = (Flags & GUI_SPRITE_CF_STAYONTOP) ? GUI_DEVICE_STAYONTOP : 0;
   1314            pDevice = GUI_DEVICE_Create(&_Sprite_API, NULL, FlagsDevice, Layer);
   \   00000050   012006E2           AND      R2,R6,#0x1
   \   00000054   0010A0E3           MOV      R1,#+0
   \   00000058   ............       ADRL     R0,_Sprite_API
   \              ....        
   \   00000060   ........           BL       GUI_DEVICE_Create
   \   00000064   0090B0E1           MOVS     R9,R0
   1315            if (pDevice == NULL) {
   \   00000068   EFFFFF0A           BEQ      ??GUI_SPRITE__CreateEx_2
   1316              return 0; // Error
   1317            }
   1318            //
   1319            // Create sprite object
   1320            //
   1321            AllocSize = sizeof(LCD_PIXELINDEX) * pBM->XSize * pBM->YSize; // Memory area for saving background data
   \   0000006C   B000D5E1           LDRH     R0,[R5, #+0]
   \   00000070   B210D5E1           LDRH     R1,[R5, #+2]
   \   00000074   910000E0           MUL      R0,R1,R0
   \   00000078   0041A0E1           LSL      R4,R0,#+2
   1322            GUI_LOCK();
   \   0000007C   ........           BL       GUI_Lock
   1323            hSpriteNew = GUI_ALLOC_AllocZero(sizeof(GUI_SPRITE_OBJ) + AllocSize);
   \   00000080   200084E2           ADD      R0,R4,#+32
   \   00000084   ........           BL       GUI_ALLOC_AllocZero
   \   00000088   0040B0E1           MOVS     R4,R0
   1324            if (hSpriteNew == 0) {
   \   0000008C   0300001A           BNE      ??GUI_SPRITE__CreateEx_3
   1325              GUI_DEVICE_Delete(pDevice);
   \   00000090   0900A0E1           MOV      R0,R9
   \   00000094   ........           BL       GUI_DEVICE_Delete
   1326              GUI_UNLOCK();
   \                     ??GUI_SPRITE__CreateEx_4:
   \   00000098   ........           BL       GUI_Unlock
   1327              return 0; // Error, Allocation failed...
   \   0000009C   E2FFFFEA           B        ??GUI_SPRITE__CreateEx_2
   1328            }
   1329            pDevice->u.hContext = hSpriteNew;
   \                     ??GUI_SPRITE__CreateEx_3:
   \   000000A0   084089E5           STR      R4,[R9, #+8]
   1330            //
   1331            // Create and initialize object
   1332            //
   1333            pSpriteNew = SPRITE_LOCK_H(hSpriteNew);
   \   000000A4   ........           BL       GUI_ALLOC_LockH
   1334            pSpriteNew->Flags   = Flags;
   \   000000A8   B861C0E1           STRH     R6,[R0, #+24]
   1335            pSpriteNew->pBM     = pBM;
   \   000000AC   1C5080E5           STR      R5,[R0, #+28]
   1336            pSpriteNew->Rect.x0 = x;
   \   000000B0   B470C0E1           STRH     R7,[R0, #+4]
   1337            pSpriteNew->Rect.y0 = y;
   \   000000B4   B680C0E1           STRH     R8,[R0, #+6]
   1338            pSpriteNew->Rect.x1 = pSpriteNew->Rect.x0 + pBM->XSize - 1;
   \   000000B8   F410D0E1           LDRSH    R1,[R0, #+4]
   \   000000BC   F020D5E1           LDRSH    R2,[R5, #+0]
   \   000000C0   011082E0           ADD      R1,R2,R1
   \   000000C4   011041E2           SUB      R1,R1,#+1
   \   000000C8   B810C0E1           STRH     R1,[R0, #+8]
   1339            pSpriteNew->Rect.y1 = pSpriteNew->Rect.y0 + pBM->YSize - 1;
   \   000000CC   F610D0E1           LDRSH    R1,[R0, #+6]
   \   000000D0   F220D5E1           LDRSH    R2,[R5, #+2]
   \   000000D4   011082E0           ADD      R1,R2,R1
   \   000000D8   011041E2           SUB      R1,R1,#+1
   \   000000DC   BA10C0E1           STRH     R1,[R0, #+10]
   1340            pSpriteNew->pDevice = pDevice;
   \   000000E0   009080E5           STR      R9,[R0, #+0]
   1341            GUI_UNLOCK_H(pSpriteNew);
   \   000000E4   ........           BL       GUI_ALLOC_UnlockH
   1342            //
   1343            // Do the color conversion
   1344            //
   1345            if (_DoColorConversion(hSpriteNew, pBM)) { // Set bitmap data
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       GUI_ALLOC_LockH
   \   000000F0   0C9090E5           LDR      R9,[R0, #+12]
   \   000000F4   000090E5           LDR      R0,[R0, #+0]
   \   000000F8   187090E5           LDR      R7,[R0, #+24]
   \   000000FC   ........           BL       GUI_ALLOC_UnlockH
   \   00000100   000059E3           CMP      R9,#+0
   \   00000104   0100000A           BEQ      ??GUI_SPRITE__CreateEx_5
   \   00000108   0900A0E1           MOV      R0,R9
   \   0000010C   ........           BL       GUI_ALLOC_Free
   \                     ??GUI_SPRITE__CreateEx_5:
   \   00000110   0C0095E5           LDR      R0,[R5, #+12]
   \   00000114   000090E5           LDR      R0,[R0, #+0]
   \   00000118   0001A0E1           LSL      R0,R0,#+2
   \   0000011C   ........           BL       GUI_ALLOC_AllocZero
   \   00000120   0080B0E1           MOVS     R8,R0
   \   00000124   DBFFFF0A           BEQ      ??GUI_SPRITE__CreateEx_4
   \   00000128   ........           BL       GUI_ALLOC_LockH
   \   0000012C   0090A0E1           MOV      R9,R0
   \   00000130   ........           LDR      R0,??DataTable17
   \   00000134   00A0A0E3           MOV      R10,#+0
   \   00000138   077180E0           ADD      R7,R0,R7, LSL #+2
   \   0000013C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000140   000090E5           LDR      R0,[R0, #+0]
   \   00000144   010050E3           CMP      R0,#+1
   \   00000148   100000AA           BGE      ??GUI_SPRITE__CreateEx_6
   \                     ??GUI_SPRITE__CreateEx_7:
   \   0000014C   ........           BL       GUI_ALLOC_UnlockH
   \   00000150   0400A0E1           MOV      R0,R4
   \   00000154   ........           BL       GUI_ALLOC_LockH
   \   00000158   0C8080E5           STR      R8,[R0, #+12]
   \   0000015C   ........           BL       GUI_ALLOC_UnlockH
   1346              GUI_UNLOCK();
   1347              return 0; // Error, Allocation failed...
   1348            };
   1349            //
   1350            // Linking & Drawing
   1351            //
   1352            if (Flags & GUI_SPRITE_CF_SHOW) {
   \   00000160   020016E3           TST      R6,#0x2
   \   00000164   0600000A           BEQ      ??GUI_SPRITE__CreateEx_8
   1353              _Link(hSpriteNew);        // Put it into linked list
   \   00000168   0400A0E1           MOV      R0,R4
   \   0000016C   ........           BL       GUI_ALLOC_LockH
   \   00000170   000090E5           LDR      R0,[R0, #+0]
   \   00000174   ........           BL       GUI_DEVICE_Link
   \   00000178   ........           BL       GUI_ALLOC_UnlockH
   1354              _SpriteDraw(hSpriteNew);  // Draw it
   \   0000017C   0400A0E1           MOV      R0,R4
   \   00000180   ........           BL       _SpriteDraw
   1355            }
   1356            GUI_UNLOCK();
   \                     ??GUI_SPRITE__CreateEx_8:
   \   00000184   ........           BL       GUI_Unlock
   1357            return hSpriteNew;
   \   00000188   0400A0E1           MOV      R0,R4
   \                     ??GUI_SPRITE__CreateEx_0:
   \   0000018C   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??GUI_SPRITE__CreateEx_6:
   \   00000190   0C0095E5           LDR      R0,[R5, #+12]
   \   00000194   481097E5           LDR      R1,[R7, #+72]
   \   00000198   080090E5           LDR      R0,[R0, #+8]
   \   0000019C   101091E5           LDR      R1,[R1, #+16]
   \   000001A0   0A0190E7           LDR      R0,[R0, +R10, LSL #+2]
   \   000001A4   001091E5           LDR      R1,[R1, #+0]
   \   000001A8   31FF2FE1           BLX      R1
   \   000001AC   040089E4           STR      R0,[R9], #+4
   \   000001B0   0C0095E5           LDR      R0,[R5, #+12]
   \   000001B4   01A08AE2           ADD      R10,R10,#+1
   \   000001B8   000090E5           LDR      R0,[R0, #+0]
   \   000001BC   00005AE1           CMP      R10,R0
   \   000001C0   F2FFFFBA           BLT      ??GUI_SPRITE__CreateEx_6
   \   000001C4   E0FFFFEA           B        ??GUI_SPRITE__CreateEx_7
   1358          }
   1359          
   1360          /*********************************************************************
   1361          *
   1362          *       Public code
   1363          *
   1364          **********************************************************************
   1365          */
   1366          /*********************************************************************
   1367          *
   1368          *       GUI_SPRITE_CreateEx
   1369          */

   \                                 In section .text, align 4, keep-with-next
   1370          GUI_HSPRITE GUI_SPRITE_CreateEx(const GUI_BITMAP GUI_UNI_PTR * pBM, int x, int y, int Layer) {
   \                     GUI_SPRITE_CreateEx:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1371            return GUI_SPRITE__CreateEx(pBM, x, y, Layer, GUI_SPRITE_CF_SHOW);
   \   00000008   02C0A0E3           MOV      R12,#+2
   \   0000000C   00C08DE5           STR      R12,[SP, #+0]
   \   00000010   ........           BL       GUI_SPRITE__CreateEx
   \   00000014   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000018   0080BDE8           POP      {PC}             ;; return
   1372          }
   1373          
   1374          /*********************************************************************
   1375          *
   1376          *       GUI_SPRITE_Create
   1377          */

   \                                 In section .text, align 4, keep-with-next
   1378          GUI_HSPRITE GUI_SPRITE_Create(const GUI_BITMAP GUI_UNI_PTR * pBM, int x, int y) {
   \                     GUI_SPRITE_Create:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1379            return GUI_SPRITE_CreateEx(pBM, x, y, GUI_Context.SelLayer);
   \   00000008   0230A0E3           MOV      R3,#+2
   \   0000000C   00308DE5           STR      R3,[SP, #+0]
   \   00000010   ........           LDR      R3,??DataTable17
   \   00000014   1130D3E5           LDRB     R3,[R3, #+17]
   \   00000018   ........           BL       GUI_SPRITE__CreateEx
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1380          }
   1381          
   1382          /*********************************************************************
   1383          *
   1384          *       GUI_SPRITE_Delete
   1385          */

   \                                 In section .text, align 4, keep-with-next
   1386          void GUI_SPRITE_Delete(GUI_HSPRITE hSprite) {
   \                     GUI_SPRITE_Delete:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
   1387            if (hSprite) {
   \   0000000C   1200000A           BEQ      ??GUI_SPRITE_Delete_0
   1388              GUI_LOCK();
   \   00000010   ........           BL       GUI_Lock
   1389              _Undraw(hSprite);        // Remove from screen
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   ........           BL       _Undraw
   1390              _Unlink(hSprite);        // Remove from linked list
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
   \   00000024   000090E5           LDR      R0,[R0, #+0]
   \   00000028   ........           BL       GUI_DEVICE_Unlink
   \   0000002C   ........           BL       GUI_ALLOC_UnlockH
   1391              _Delete(hSprite);        // Remove from memory
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       GUI_ALLOC_LockH
   \   00000038   0050A0E1           MOV      R5,R0
   \   0000003C   000095E5           LDR      R0,[R5, #+0]
   \   00000040   ........           BL       GUI_ALLOC_FreeFixedBlock
   \   00000044   0C0095E5           LDR      R0,[R5, #+12]
   \   00000048   ........           BL       GUI_ALLOC_Free
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       GUI_ALLOC_Free
   \   00000054   ........           BL       GUI_ALLOC_UnlockH
   1392              GUI_UNLOCK();
   \   00000058   ........           BL       GUI_Unlock
   1393            }
   1394          }
   \                     ??GUI_SPRITE_Delete_0:
   \   0000005C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000060   3080BDE8           POP      {R4,R5,PC}       ;; return
   1395          
   1396          /*********************************************************************
   1397          *
   1398          *       GUI_SPRITE_SetPosition
   1399          */

   \                                 In section .text, align 4, keep-with-next
   1400          void GUI_SPRITE_SetPosition(GUI_HSPRITE hSprite, int x, int y) {
   \                     GUI_SPRITE_SetPosition:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   1401            GUI_LOCK();
   \   00000010   ........           BL       GUI_Lock
   1402            _SetPosition(hSprite, x, y);
   \   00000014   0620A0E1           MOV      R2,R6
   \   00000018   0510A0E1           MOV      R1,R5
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       _SetPosition
   1403            GUI_UNLOCK();
   \   00000024   7040BDE8           POP      {R4-R6,LR}
   \   00000028   ........           B        GUI_Unlock       ;; tailcall
   1404          }
   1405          
   1406          /*********************************************************************
   1407          *
   1408          *       GUI_SPRITE_SetBitmap
   1409          */

   \                                 In section .text, align 4, keep-with-next
   1410          int GUI_SPRITE_SetBitmap(GUI_HSPRITE hSprite, const GUI_BITMAP GUI_UNI_PTR * pBM) {
   \                     GUI_SPRITE_SetBitmap:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
   1411            int r = 1;
   \   00000010   0160A0E3           MOV      R6,#+1
   1412            int XSize, YSize;
   1413            GUI_SPRITE_OBJ * pSprite;
   1414            if (hSprite) {
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   2E00000A           BEQ      ??GUI_SPRITE_SetBitmap_0
   1415              GUI_LOCK();
   \   0000001C   ........           BL       GUI_Lock
   1416              pSprite = SPRITE_LOCK_H(hSprite);
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       GUI_ALLOC_LockH
   1417              XSize = pSprite->pBM->XSize;
   \   00000028   1C0090E5           LDR      R0,[R0, #+28]
   \   0000002C   B070D0E1           LDRH     R7,[R0, #+0]
   1418              YSize = pSprite->pBM->YSize;
   \   00000030   B280D0E1           LDRH     R8,[R0, #+2]
   1419              GUI_UNLOCK_H(pSprite);
   \   00000034   ........           BL       GUI_ALLOC_UnlockH
   1420              //
   1421              // Only bitmaps of the same size are supported by this function
   1422              //
   1423              if ((XSize == pBM->XSize) && (YSize == pBM->YSize)) {
   \   00000038   B010D5E1           LDRH     R1,[R5, #+0]
   \   0000003C   010057E1           CMP      R7,R1
   \   00000040   B200D501           LDRHEQ   R0,[R5, #+2]
   \   00000044   00005801           CMPEQ    R8,R0
   \   00000048   2100001A           BNE      ??GUI_SPRITE_SetBitmap_1
   1424                //
   1425                // Do the color conversion
   1426                //
   1427                if (_DoColorConversion(hSprite, pBM) == 0) {
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       GUI_ALLOC_LockH
   \   00000054   0C8090E5           LDR      R8,[R0, #+12]
   \   00000058   000090E5           LDR      R0,[R0, #+0]
   \   0000005C   187090E5           LDR      R7,[R0, #+24]
   \   00000060   ........           BL       GUI_ALLOC_UnlockH
   \   00000064   000058E3           CMP      R8,#+0
   \   00000068   0100000A           BEQ      ??GUI_SPRITE_SetBitmap_2
   \   0000006C   0800A0E1           MOV      R0,R8
   \   00000070   ........           BL       GUI_ALLOC_Free
   \                     ??GUI_SPRITE_SetBitmap_2:
   \   00000074   0C0095E5           LDR      R0,[R5, #+12]
   \   00000078   000090E5           LDR      R0,[R0, #+0]
   \   0000007C   0001A0E1           LSL      R0,R0,#+2
   \   00000080   ........           BL       GUI_ALLOC_AllocZero
   \   00000084   0080B0E1           MOVS     R8,R0
   \   00000088   1100000A           BEQ      ??GUI_SPRITE_SetBitmap_1
   \   0000008C   ........           BL       GUI_ALLOC_LockH
   \   00000090   0060A0E1           MOV      R6,R0
   \   00000094   ........           LDR      R0,??DataTable17
   \   00000098   0090A0E3           MOV      R9,#+0
   \   0000009C   077180E0           ADD      R7,R0,R7, LSL #+2
   \   000000A0   0C0095E5           LDR      R0,[R5, #+12]
   \   000000A4   000090E5           LDR      R0,[R0, #+0]
   \   000000A8   010050E3           CMP      R0,#+1
   \   000000AC   0C0000AA           BGE      ??GUI_SPRITE_SetBitmap_3
   \                     ??GUI_SPRITE_SetBitmap_4:
   \   000000B0   ........           BL       GUI_ALLOC_UnlockH
   \   000000B4   0400A0E1           MOV      R0,R4
   \   000000B8   ........           BL       GUI_ALLOC_LockH
   \   000000BC   0C8080E5           STR      R8,[R0, #+12]
   \   000000C0   ........           BL       GUI_ALLOC_UnlockH
   1428                  //
   1429                  // Set new image
   1430                  //
   1431                  _SetBitmap(hSprite, pBM);
   \   000000C4   0510A0E1           MOV      R1,R5
   \   000000C8   0400A0E1           MOV      R0,R4
   \   000000CC   ........           BL       _SetBitmap
   1432                  r = 0;
   \   000000D0   0060A0E3           MOV      R6,#+0
   1433                }
   1434              }
   1435              GUI_UNLOCK();
   \                     ??GUI_SPRITE_SetBitmap_1:
   \   000000D4   ........           BL       GUI_Unlock
   1436            }
   1437            return r;
   \                     ??GUI_SPRITE_SetBitmap_0:
   \   000000D8   0600A0E1           MOV      R0,R6
   \   000000DC   04D08DE2           ADD      SP,SP,#+4
   \   000000E0   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??GUI_SPRITE_SetBitmap_3:
   \   000000E4   0C0095E5           LDR      R0,[R5, #+12]
   \   000000E8   481097E5           LDR      R1,[R7, #+72]
   \   000000EC   080090E5           LDR      R0,[R0, #+8]
   \   000000F0   101091E5           LDR      R1,[R1, #+16]
   \   000000F4   090190E7           LDR      R0,[R0, +R9, LSL #+2]
   \   000000F8   001091E5           LDR      R1,[R1, #+0]
   \   000000FC   31FF2FE1           BLX      R1
   \   00000100   040086E4           STR      R0,[R6], #+4
   \   00000104   0C0095E5           LDR      R0,[R5, #+12]
   \   00000108   019089E2           ADD      R9,R9,#+1
   \   0000010C   000090E5           LDR      R0,[R0, #+0]
   \   00000110   000059E1           CMP      R9,R0
   \   00000114   F2FFFFBA           BLT      ??GUI_SPRITE_SetBitmap_3
   \   00000118   E4FFFFEA           B        ??GUI_SPRITE_SetBitmap_4
   1438          }
   1439          
   1440          /*********************************************************************
   1441          *
   1442          *       GUI_SPRITE_SetBitmapAndPosition
   1443          */

   \                                 In section .text, align 4, keep-with-next
   1444          int GUI_SPRITE_SetBitmapAndPosition(GUI_HSPRITE hSprite, const GUI_BITMAP GUI_UNI_PTR * pBM, int x, int y) {
   \                     GUI_SPRITE_SetBitmapAndPosition:
   \   00000000   FC4F2DE9           PUSH     {R2-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
   1445            int r = 1;
   \   00000010   01A0A0E3           MOV      R10,#+1
   1446            int XSize, YSize, x0, y0;
   1447            GUI_SPRITE_OBJ * pSprite;
   1448            if (hSprite) {
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   3400000A           BEQ      ??GUI_SPRITE_SetBitmapAndPosition_0
   1449              GUI_LOCK();
   \   0000001C   ........           BL       GUI_Lock
   1450              pSprite = SPRITE_LOCK_H(hSprite);
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       GUI_ALLOC_LockH
   1451              XSize = pSprite->pBM->XSize;
   \   00000028   1C1090E5           LDR      R1,[R0, #+28]
   1452              YSize = pSprite->pBM->YSize;
   1453              x0 = pSprite->Rect.x0;
   \   0000002C   F460D0E1           LDRSH    R6,[R0, #+4]
   \   00000030   B080D1E1           LDRH     R8,[R1, #+0]
   \   00000034   B290D1E1           LDRH     R9,[R1, #+2]
   1454              y0 = pSprite->Rect.y0;
   \   00000038   F670D0E1           LDRSH    R7,[R0, #+6]
   1455              GUI_UNLOCK_H(pSprite);
   \   0000003C   ........           BL       GUI_ALLOC_UnlockH
   1456              //
   1457              // Only bitmaps of the same size are supported by this function
   1458              //
   1459              if ((XSize == pBM->XSize) && (YSize == pBM->YSize)) {
   \   00000040   B010D5E1           LDRH     R1,[R5, #+0]
   \   00000044   010058E1           CMP      R8,R1
   \   00000048   B200D501           LDRHEQ   R0,[R5, #+2]
   \   0000004C   00005901           CMPEQ    R9,R0
   \   00000050   2500001A           BNE      ??GUI_SPRITE_SetBitmapAndPosition_1
   1460                //
   1461                // Do the color conversion
   1462                //
   1463                if (_DoColorConversion(hSprite, pBM) == 0) {
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       GUI_ALLOC_LockH
   \   0000005C   0C9090E5           LDR      R9,[R0, #+12]
   \   00000060   000090E5           LDR      R0,[R0, #+0]
   \   00000064   188090E5           LDR      R8,[R0, #+24]
   \   00000068   ........           BL       GUI_ALLOC_UnlockH
   \   0000006C   000059E3           CMP      R9,#+0
   \   00000070   0100000A           BEQ      ??GUI_SPRITE_SetBitmapAndPosition_2
   \   00000074   0900A0E1           MOV      R0,R9
   \   00000078   ........           BL       GUI_ALLOC_Free
   \                     ??GUI_SPRITE_SetBitmapAndPosition_2:
   \   0000007C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000080   000090E5           LDR      R0,[R0, #+0]
   \   00000084   0001A0E1           LSL      R0,R0,#+2
   \   00000088   ........           BL       GUI_ALLOC_AllocZero
   \   0000008C   0090B0E1           MOVS     R9,R0
   \   00000090   1500000A           BEQ      ??GUI_SPRITE_SetBitmapAndPosition_1
   \   00000094   ........           BL       GUI_ALLOC_LockH
   \   00000098   00A0A0E1           MOV      R10,R0
   \   0000009C   ........           LDR      R0,??DataTable17
   \   000000A0   00B0A0E3           MOV      R11,#+0
   \   000000A4   088180E0           ADD      R8,R0,R8, LSL #+2
   \   000000A8   0C0095E5           LDR      R0,[R5, #+12]
   \   000000AC   000090E5           LDR      R0,[R0, #+0]
   \   000000B0   010050E3           CMP      R0,#+1
   \   000000B4   100000AA           BGE      ??GUI_SPRITE_SetBitmapAndPosition_3
   \                     ??GUI_SPRITE_SetBitmapAndPosition_4:
   \   000000B8   ........           BL       GUI_ALLOC_UnlockH
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   ........           BL       GUI_ALLOC_LockH
   \   000000C4   0C9080E5           STR      R9,[R0, #+12]
   \   000000C8   ........           BL       GUI_ALLOC_UnlockH
   1464                  //
   1465                  // Set new image
   1466                  //
   1467                  _SetBitmapAndPosition(hSprite, pBM, x - x0, y - y0);
   \   000000CC   08009DE5           LDR      R0,[SP, #+8]
   \   000000D0   0510A0E1           MOV      R1,R5
   \   000000D4   073040E0           SUB      R3,R0,R7
   \   000000D8   04009DE5           LDR      R0,[SP, #+4]
   \   000000DC   062040E0           SUB      R2,R0,R6
   \   000000E0   0400A0E1           MOV      R0,R4
   \   000000E4   ........           BL       _SetBitmapAndPosition
   1468                  r = 0;
   \   000000E8   00A0A0E3           MOV      R10,#+0
   1469                }
   1470              }
   1471              GUI_UNLOCK();
   \                     ??GUI_SPRITE_SetBitmapAndPosition_1:
   \   000000EC   ........           BL       GUI_Unlock
   1472            }
   1473            return r;
   \                     ??GUI_SPRITE_SetBitmapAndPosition_0:
   \   000000F0   0A00A0E1           MOV      R0,R10
   \   000000F4   0CD08DE2           ADD      SP,SP,#+12
   \   000000F8   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??GUI_SPRITE_SetBitmapAndPosition_3:
   \   000000FC   0C0095E5           LDR      R0,[R5, #+12]
   \   00000100   481098E5           LDR      R1,[R8, #+72]
   \   00000104   080090E5           LDR      R0,[R0, #+8]
   \   00000108   101091E5           LDR      R1,[R1, #+16]
   \   0000010C   0B0190E7           LDR      R0,[R0, +R11, LSL #+2]
   \   00000110   001091E5           LDR      R1,[R1, #+0]
   \   00000114   31FF2FE1           BLX      R1
   \   00000118   04008AE4           STR      R0,[R10], #+4
   \   0000011C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000120   01B08BE2           ADD      R11,R11,#+1
   \   00000124   000090E5           LDR      R0,[R0, #+0]
   \   00000128   00005BE1           CMP      R11,R0
   \   0000012C   F2FFFFBA           BLT      ??GUI_SPRITE_SetBitmapAndPosition_3
   \   00000130   E0FFFFEA           B        ??GUI_SPRITE_SetBitmapAndPosition_4
   1474          }
   1475          
   1476          /*********************************************************************
   1477          *
   1478          *       GUI_SPRITE_Hide
   1479          */

   \                                 In section .text, align 4, keep-with-next
   1480          void GUI_SPRITE_Hide(GUI_HSPRITE hSprite) {
   \                     GUI_SPRITE_Hide:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
   1481            GUI_SPRITE_OBJ * pSprite;
   1482            if (hSprite) {
   \   0000000C   1200000A           BEQ      ??GUI_SPRITE_Hide_0
   1483              GUI_LOCK();
   \   00000010   ........           BL       GUI_Lock
   1484              pSprite = SPRITE_LOCK_H(hSprite);
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   ........           BL       GUI_ALLOC_LockH
   \   0000001C   0050A0E1           MOV      R5,R0
   1485              if ((pSprite->Flags & GUI_SPRITE_CF_SHOW) != 0) {
   \   00000020   1800D5E5           LDRB     R0,[R5, #+24]
   \   00000024   020010E3           TST      R0,#0x2
   \   00000028   0900000A           BEQ      ??GUI_SPRITE_Hide_1
   1486                _Undraw(hSprite);          // Remove from screen
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       _Undraw
   1487                _Unlink(hSprite);          // Remove from linked list
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       GUI_ALLOC_LockH
   \   0000003C   000090E5           LDR      R0,[R0, #+0]
   \   00000040   ........           BL       GUI_DEVICE_Unlink
   \   00000044   ........           BL       GUI_ALLOC_UnlockH
   1488                pSprite->Flags &= ~GUI_SPRITE_CF_SHOW;
   \   00000048   B801D5E1           LDRH     R0,[R5, #+24]
   \   0000004C   0200C0E3           BIC      R0,R0,#0x2
   \   00000050   B801C5E1           STRH     R0,[R5, #+24]
   1489              }
   1490              GUI_UNLOCK_H(pSprite);
   \                     ??GUI_SPRITE_Hide_1:
   \   00000054   ........           BL       GUI_ALLOC_UnlockH
   1491              GUI_UNLOCK();
   \   00000058   ........           BL       GUI_Unlock
   1492            }
   1493          }
   \                     ??GUI_SPRITE_Hide_0:
   \   0000005C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000060   3080BDE8           POP      {R4,R5,PC}       ;; return
   1494          
   1495          /*********************************************************************
   1496          *
   1497          *       GUI_SPRITE_Show
   1498          */

   \                                 In section .text, align 4, keep-with-next
   1499          void GUI_SPRITE_Show(GUI_HSPRITE hSprite) {
   \                     GUI_SPRITE_Show:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
   1500            GUI_SPRITE_OBJ * pSprite;
   1501            if (hSprite) {
   \   0000000C   1200000A           BEQ      ??GUI_SPRITE_Show_0
   1502              GUI_LOCK();
   \   00000010   ........           BL       GUI_Lock
   1503              pSprite = SPRITE_LOCK_H(hSprite);
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   ........           BL       GUI_ALLOC_LockH
   \   0000001C   0050A0E1           MOV      R5,R0
   1504              if ((pSprite->Flags & GUI_SPRITE_CF_SHOW) == 0) {
   \   00000020   1800D5E5           LDRB     R0,[R5, #+24]
   \   00000024   020010E3           TST      R0,#0x2
   \   00000028   0900001A           BNE      ??GUI_SPRITE_Show_1
   1505                _Link(hSprite);            // Put it into linked list
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       GUI_ALLOC_LockH
   \   00000034   000090E5           LDR      R0,[R0, #+0]
   \   00000038   ........           BL       GUI_DEVICE_Link
   \   0000003C   ........           BL       GUI_ALLOC_UnlockH
   1506                _SpriteDraw(hSprite);      // Draw it
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   ........           BL       _SpriteDraw
   1507                pSprite->Flags |= GUI_SPRITE_CF_SHOW;
   \   00000048   B801D5E1           LDRH     R0,[R5, #+24]
   \   0000004C   020080E3           ORR      R0,R0,#0x2
   \   00000050   B801C5E1           STRH     R0,[R5, #+24]
   1508              }
   1509              GUI_UNLOCK_H(pSprite);
   \                     ??GUI_SPRITE_Show_1:
   \   00000054   ........           BL       GUI_ALLOC_UnlockH
   1510              GUI_UNLOCK();
   \   00000058   ........           BL       GUI_Unlock
   1511            }
   1512          }
   \                     ??GUI_SPRITE_Show_0:
   \   0000005C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000060   3080BDE8           POP      {R4,R5,PC}       ;; return
   1513          
   1514          /*********************************************************************
   1515          *
   1516          *       GUI_SPRITE_GetState
   1517          */

   \                                 In section .text, align 4, keep-with-next
   1518          int GUI_SPRITE_GetState(GUI_HSPRITE hSprite) {
   \                     GUI_SPRITE_GetState:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
   1519            int r = 0;
   \   0000000C   0050A0E3           MOV      R5,#+0
   1520            GUI_SPRITE_OBJ * pSprite;
   1521            if (hSprite) {
   \   00000010   0800000A           BEQ      ??GUI_SPRITE_GetState_0
   1522              GUI_LOCK();
   \   00000014   ........           BL       GUI_Lock
   1523              pSprite = SPRITE_LOCK_H(hSprite);
   1524              r = (pSprite->Flags & GUI_SPRITE_CF_SHOW) ? 1 : 0;
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           BL       GUI_ALLOC_LockH
   \   00000020   B801D0E1           LDRH     R0,[R0, #+24]
   \   00000024   0110A0E3           MOV      R1,#+1
   \   00000028   FF0000E2           AND      R0,R0,#0xFF
   \   0000002C   A05001E0           AND      R5,R1,R0, LSR #+1
   1525              GUI_UNLOCK_H(pSprite);
   \   00000030   ........           BL       GUI_ALLOC_UnlockH
   1526              GUI_UNLOCK();
   \   00000034   ........           BL       GUI_Unlock
   1527            }
   1528            return r;
   \                     ??GUI_SPRITE_GetState_0:
   \   00000038   0500A0E1           MOV      R0,R5
   \   0000003C   04D08DE2           ADD      SP,SP,#+4
   \   00000040   3080BDE8           POP      {R4,R5,PC}       ;; return
   1529          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {(GUI_RECT *)0}>`:
   \   00000000                      ; Initializer data, 24 bytes
   \   00000000   00000000           DC32 0
   \   00000004   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              00000000    
   \   0000000E   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              00000000    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {(GUI_RECT *)0}>_1`:
   \   00000000                      ; Initializer data, 24 bytes
   \   00000000   00000000           DC32 0
   \   00000004   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              00000000    
   \   0000000E   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              00000000    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {(GUI_RECT *)0}>_2`:
   \   00000000                      ; Initializer data, 24 bytes
   \   00000000   00000000           DC32 0
   \   00000004   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              00000000    
   \   0000000E   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              00000000    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {(GUI_RECT *)0}>_3`:
   \   00000000                      ; Initializer data, 24 bytes
   \   00000000   00000000           DC32 0
   \   00000004   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              00000000    
   \   0000000E   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              00000000    
   1530          
   1531          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     GUI_SPRITE_Create                   8
     GUI_SPRITE_CreateEx                 8
     GUI_SPRITE_Delete                  16
     GUI_SPRITE_GetState                16
     GUI_SPRITE_Hide                    16
     GUI_SPRITE_SetBitmap               32
     GUI_SPRITE_SetBitmapAndPosition
                                        48
     GUI_SPRITE_SetPosition             16
     GUI_SPRITE_Show                    16
     GUI_SPRITE__CreateEx               32
     _DrawBitmap                       128
     _DrawHLine                         64
     _DrawVLine                         64
     _FillRect                          72
     _GetBkPixel                        32
     _GetClipParam                      20
     _GetClipRect                       16
     _GetDevData                         0
     _GetDevFunc                         0
     _GetDevProp                         8
     _GetPixelIndex                     24
     _GetRect                            8
     _SetBitmap                         72
     _SetBitmapAndPosition             112
     _SetOrg                             8
     _SetPixelIndex                     32
     _SetPosition                      160
     _SpriteDraw                        72
     _Undraw                            64
     _XorPixel                          24


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     _GetClipRect                    352
     _GetClipParam                   520
     _DrawBitmap                    1008
     _DrawHLine                      412
     _DrawVLine                      408
     _FillRect                       456
     _GetPixelIndex                  216
     _SetPixelIndex                  224
     _XorPixel                       208
     _GetDevData                       8
     _SetOrg                          44
     _GetDevFunc                       8
     _GetDevProp                      44
     _GetRect                         44
     _Sprite_API                      52
     _GetBkPixel                     176
     _Undraw                         300
     _SetBitmap                      428
     _SetPosition                   1124
     _SetBitmapAndPosition           832
     _SpriteDraw                     376
     GUI_SPRITE__CreateEx            456
     GUI_SPRITE_CreateEx              28
     GUI_SPRITE_Create                36
     GUI_SPRITE_Delete               100
     GUI_SPRITE_SetPosition           44
     GUI_SPRITE_SetBitmap            284
     GUI_SPRITE_SetBitmapAndPosition
                                     308
     GUI_SPRITE_Hide                 100
     GUI_SPRITE_Show                 100
     GUI_SPRITE_GetState              68
     ??DataTable10                     4
     ??DataTable11                     4
     ??DataTable17                     4
     ?<Constant {(GUI_RECT *)0}>      24
     ?<Constant {(GUI_RECT *)0}>_1    24
     ?<Constant {(GUI_RECT *)0}>_2    24
     ?<Constant {(GUI_RECT *)0}>_3    24

 
    96 bytes in section .rodata
 8 776 bytes in section .text
 
 8 776 bytes of CODE  memory
    96 bytes of CONST memory

Errors: none
Warnings: none
