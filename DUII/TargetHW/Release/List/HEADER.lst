###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:11:28 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\HEADER.c                            #
#    Command line =  C:\DUII\TargetHW\GUI\HEADER.c -D DEBUG=1 -D              #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\HEADER.lst                 #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\HEADER.o                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\HEADER.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : HEADER.c
     19          Purpose     : Implementation of header widget
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stdlib.h>
     24          #include <string.h>
     25          
     26          #include "HEADER_Private.h"
     27          #include "SCROLLBAR.h"
     28          #include "GUI.h"
     29          
     30          #if GUI_WINSUPPORT
     31          
     32          /*********************************************************************
     33          *
     34          *       Private config defaults
     35          *
     36          **********************************************************************
     37          */
     38          
     39          #ifndef HEADER_SUPPORT_DRAG
     40            #define HEADER_SUPPORT_DRAG 1
     41          #endif
     42          
     43          #ifndef HEADER_BORDER_V_DEFAULT
     44            #define HEADER_BORDER_V_DEFAULT 0
     45          #endif
     46          
     47          #ifndef HEADER_BORDER_H_DEFAULT
     48            #define HEADER_BORDER_H_DEFAULT 2
     49          #endif
     50          
     51          /* Define default fonts */
     52          #ifndef HEADER_FONT_DEFAULT
     53            #if   WIDGET_USE_SCHEME_SMALL
     54              #define HEADER_FONT_DEFAULT &GUI_Font13_1
     55            #elif WIDGET_USE_SCHEME_MEDIUM
     56              #define HEADER_FONT_DEFAULT &GUI_Font16_1
     57            #elif WIDGET_USE_SCHEME_LARGE
     58              #define HEADER_FONT_DEFAULT &GUI_Font24_1
     59            #endif
     60          #endif
     61          
     62          /* Define colors */
     63          #ifndef HEADER_BKCOLOR_DEFAULT
     64            #define HEADER_BKCOLOR_DEFAULT 0xAAAAAA
     65          #endif
     66          
     67          #ifndef HEADER_TEXTCOLOR_DEFAULT
     68            #define HEADER_TEXTCOLOR_DEFAULT GUI_BLACK
     69          #endif
     70          
     71          #ifndef HEADER_ARROWCOLOR_DEFAULT
     72            #define HEADER_ARROWCOLOR_DEFAULT GUI_BLACK
     73          #endif
     74          
     75          /* Define cursors */
     76          #ifndef HEADER_CURSOR_DEFAULT
     77            #define HEADER_CURSOR_DEFAULT &GUI_CursorHeaderM
     78          #endif
     79          
     80          #ifndef   HEADER_DRAW_SKIN_DEFAULT
     81            #define HEADER_DRAW_SKIN_DEFAULT NULL
     82          #endif
     83          
     84          /*********************************************************************
     85          *
     86          *       Static data
     87          *
     88          **********************************************************************
     89          */
     90          

   \                                 In section .data, align 4
     91          HEADER_PROPS HEADER__DefaultProps = {
   \                     HEADER__DefaultProps:
   \   00000000   ........AAAA       DC32 GUI_Font13_1, 11184810, 0, 0, 0H
   \              AA0000000000
   \              000000000000
   \              0000        
     92            HEADER_FONT_DEFAULT,
     93            HEADER_BKCOLOR_DEFAULT,
     94            HEADER_TEXTCOLOR_DEFAULT,
     95            HEADER_ARROWCOLOR_DEFAULT,
     96            {
     97              HEADER_DRAW_SKIN_DEFAULT
     98            }
     99          };
    100          
    101          /* Remember the old cursor */
    102          static const GUI_CURSOR GUI_UNI_PTR * _pOldCursor;
    103          
    104          /* Default values */
    105          const GUI_CURSOR GUI_UNI_PTR * HEADER__pDefaultCursor   = HEADER_CURSOR_DEFAULT;
    106          int                            HEADER__DefaultBorderH   = HEADER_BORDER_H_DEFAULT;
    107          int                            HEADER__DefaultBorderV   = HEADER_BORDER_V_DEFAULT;
   \                     HEADER__DefaultBorderV:
   \   00000014   00000000           DC32 0
    108          
    109          WIDGET_SKIN const * HEADER__pSkinDefault = &HEADER__SkinClassic;
   \                     HEADER__pSkinDefault:
   \   00000018   ........           DC32 HEADER__SkinClassic

   \                                 In section .data, align 4
   \                     _pOldCursor:
   \   00000000   00000000           DC8 0, 0, 0, 0
   \                     HEADER__pDefaultCursor:
   \   00000004   ........           DC32 GUI_CursorHeaderM

   \                                 In section .data, align 4
   \                     HEADER__DefaultBorderH:
   \   00000000   02000000           DC32 2
    110          
    111          /*********************************************************************
    112          *
    113          *       static routines
    114          *
    115          **********************************************************************
    116          */
    117          /*********************************************************************
    118          *
    119          *       _Paint
    120          */
    121          static void _Paint(HEADER_Handle hObj) {
    122            HEADER_Obj * pObj;
    123            WIDGET_PAINT * pfPaint;
    124          
    125            pObj = HEADER_LOCK_H(hObj);
    126            pfPaint = pObj->pWidgetSkin->pfPaint;
    127            GUI_UNLOCK_H(pObj);
    128            if (pfPaint) {
    129              pfPaint(hObj);
    130            }
    131          }
    132          
    133          /*********************************************************************
    134          *
    135          *       _RestoreOldCursor
    136          */
    137          static void _RestoreOldCursor(void) {
    138            if (_pOldCursor) {
    139              #if GUI_SUPPORT_CURSOR
    140                if (GUI_CURSOR_GetStateEx(WM__TOUCHED_LAYER)) {
    141                  GUI_CURSOR_SelectEx(_pOldCursor, WM__TOUCHED_LAYER);
    142                }
    143              #endif
    144              _pOldCursor = 0;
    145            }
    146          }
    147          
    148          /*********************************************************************
    149          *
    150          *       _FreeAttached
    151          *
    152          * Delete attached objects (if any)
    153          */
    154          static void _FreeAttached(HEADER_Handle hObj) {
    155            int i, NumItems;
    156            HEADER_Obj * pObj;
    157            GUI_ARRAY Columns;
    158            pObj = HEADER_LOCK_H(hObj);
    159            Columns = pObj->Columns;
    160            GUI_UNLOCK_H(pObj);
    161            NumItems = GUI_ARRAY_GetNumItems(Columns);
    162            for (i = 0; i < NumItems; i++) {
    163              HEADER_COLUMN * pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItemLocked(Columns, i);
    164              if (pColumn->hDrawObj) {
    165                GUI_ALLOC_Free(pColumn->hDrawObj);
    166              }
    167              GUI_UNLOCK_H(pColumn);
    168            }
    169            /* Delete attached objects (if any) */
    170            GUI_ARRAY_Delete(Columns);
    171            _RestoreOldCursor();
    172          }
    173          
    174          /*********************************************************************
    175          *
    176          *       _GetDividerIndex
    177          */
    178          #if (HEADER_SUPPORT_DRAG)

   \                                 In section .text, align 4, keep-with-next
    179          static int _GetDividerIndex(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y) {
   \                     _GetDividerIndex:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0080A0E1           MOV      R8,R0
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   0390B0E1           MOVS     R9,R3
    180            int Item;
    181            int LastFixedPos;
    182            Item = -1;
   \   00000018   0060E0E3           MVN      R6,#+0
    183            LastFixedPos = 0;
   \   0000001C   0070A0E3           MOV      R7,#+0
    184            if ((y >= 0) && (y < WM_GetWindowSizeY(hObj))) {
   \   00000020   3300004A           BMI      ??_GetDividerIndex_0
   \   00000024   ........           BL       WM_GetWindowSizeY
   \   00000028   000059E1           CMP      R9,R0
   \   0000002C   300000AA           BGE      ??_GetDividerIndex_0
    185              if (hObj) {
   \   00000030   000058E3           CMP      R8,#+0
   \   00000034   2E00000A           BEQ      ??_GetDividerIndex_0
    186                int xPos;
    187                unsigned Index, NumColumns;
    188                NumColumns = GUI_ARRAY_GetNumItems(pObj->Columns);
   \   00000038   4C0094E5           LDR      R0,[R4, #+76]
   \   0000003C   ........           BL       GUI_ARRAY_GetNumItems
   \   00000040   0080A0E1           MOV      R8,R0
    189                if (pObj->Fixed) {
   \   00000044   680094E5           LDR      R0,[R4, #+104]
    190                  xPos = pObj->ScrollPos;
    191                } else {
    192                  xPos = 0;
    193                }
    194                for (Index = 0; Index < NumColumns; Index++) {
   \   00000048   0090A0E3           MOV      R9,#+0
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   58A09415           LDRNE    R10,[R4, #+88]
   \   00000054   00A0A003           MOVEQ    R10,#+0
   \   00000058   000058E3           CMP      R8,#+0
   \   0000005C   2400000A           BEQ      ??_GetDividerIndex_0
    195                  HEADER_COLUMN * pColumn;
    196                  pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItemLocked(pObj->Columns, Index);
    197                  xPos += pColumn->Width;
   \                     ??_GetDividerIndex_1:
   \   00000060   0910A0E1           MOV      R1,R9
   \   00000064   4C0094E5           LDR      R0,[R4, #+76]
   \   00000068   ........           BL       GUI_ARRAY_GetpItemLocked
   \   0000006C   000090E5           LDR      R0,[R0, #+0]
   \   00000070   0AA080E0           ADD      R10,R0,R10
    198                  GUI_UNLOCK_H(pColumn);
   \   00000074   ........           BL       GUI_ALLOC_UnlockH
    199                  if (Index < pObj->Fixed) {
   \   00000078   680094E5           LDR      R0,[R4, #+104]
   \   0000007C   000059E1           CMP      R9,R0
    200                    LastFixedPos = xPos;
   \   00000080   0A70A031           MOVCC    R7,R10
   \   00000084   0400003A           BCC      ??_GetDividerIndex_2
    201                  } else if (pObj->Fixed && (Index == pObj->Fixed)) {
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   0200000A           BEQ      ??_GetDividerIndex_2
   \   00000090   000059E1           CMP      R9,R0
    202                    xPos -= pObj->ScrollPos;
   \   00000094   58009405           LDREQ    R0,[R4, #+88]
   \   00000098   00A04A00           SUBEQ    R10,R10,R0
    203                  }
    204                  if (xPos >= LastFixedPos) {
   \                     ??_GetDividerIndex_2:
   \   0000009C   07005AE1           CMP      R10,R7
    205                    if ((xPos >= (x - 4)) && (xPos <= (x + 4))) {
   \   000000A0   040045A2           SUBGE    R0,R5,#+4
   \   000000A4   00005AA1           CMPGE    R10,R0
   \   000000A8   040085A2           ADDGE    R0,R5,#+4
   \   000000AC   0A0050A1           CMPGE    R0,R10
   \   000000B0   0C0000BA           BLT      ??_GetDividerIndex_3
    206                      Item = Index;
    207                      if ((Index < (NumColumns - 1)) && (x < xPos)) {
   \   000000B4   010048E2           SUB      R0,R8,#+1
   \   000000B8   0960A0E1           MOV      R6,R9
   \   000000BC   000059E1           CMP      R9,R0
   \   000000C0   0800002A           BCS      ??_GetDividerIndex_3
   \   000000C4   0A0055E1           CMP      R5,R10
   \   000000C8   060000AA           BGE      ??_GetDividerIndex_3
    208                        int Width;
    209                        pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItemLocked(pObj->Columns, Index + 1);
    210                        Width = pColumn->Width;
   \   000000CC   011089E2           ADD      R1,R9,#+1
   \   000000D0   4C0094E5           LDR      R0,[R4, #+76]
   \   000000D4   ........           BL       GUI_ARRAY_GetpItemLocked
   \   000000D8   00B090E5           LDR      R11,[R0, #+0]
    211                        GUI_UNLOCK_H(pColumn);
   \   000000DC   ........           BL       GUI_ALLOC_UnlockH
    212                        if (Width == 0) {
   \   000000E0   00005BE3           CMP      R11,#+0
   \   000000E4   0200000A           BEQ      ??_GetDividerIndex_0
    213                          break;
    214                        }
    215                      }
    216                    }
    217                  }
    218                }
   \                     ??_GetDividerIndex_3:
   \   000000E8   019089E2           ADD      R9,R9,#+1
   \   000000EC   080059E1           CMP      R9,R8
   \   000000F0   DAFFFF3A           BCC      ??_GetDividerIndex_1
    219              }
    220            }
    221            return Item;
   \                     ??_GetDividerIndex_0:
   \   000000F4   0600A0E1           MOV      R0,R6
   \   000000F8   04D08DE2           ADD      SP,SP,#+4
   \   000000FC   F08FBDE8           POP      {R4-R11,PC}      ;; return
    222          }
    223          #endif
    224          
    225          /*********************************************************************
    226          *
    227          *       _LimitDragWitdh
    228          *
    229          * Purpose:
    230          *   Limits dragging of the captured header item to the right border of the window.
    231          *
    232          * Return value:
    233          *   1 - If function has limitted the clipped header item
    234          *   0 - If function has not limitted the clipped header item
    235          */

   \                                 In section .text, align 4, keep-with-next
    236          static int _LimitDragWitdh(HEADER_Handle hObj) {
   \                     _LimitDragWitdh:
   \   00000000   F04B2DE9           PUSH     {R4-R9,R11,LR}
   \   00000004   18D04DE2           SUB      SP,SP,#+24
   \   00000008   0050A0E1           MOV      R5,R0
    237            HEADER_Obj * pObj;
    238            int DragLimit, i, SumX;
    239            GUI_RECT Rect;
    240            WM_HWIN hVScroll, hParent;
    241            int CaptureItem;
    242            pObj = HEADER_LOCK_H(hObj);
   \   0000000C   ........           BL       GUI_ALLOC_LockH
    243            CaptureItem = pObj->CaptureItem;
   \   00000010   544090E5           LDR      R4,[R0, #+84]
    244            DragLimit = pObj->DragLimit;
   \   00000014   6C60D0E5           LDRB     R6,[R0, #+108]
    245            GUI_UNLOCK_H(pObj);
   \   00000018   ........           BL       GUI_ALLOC_UnlockH
    246            if (DragLimit) {
   \   0000001C   000056E3           CMP      R6,#+0
   \   00000020   6C00000A           BEQ      ??_LimitDragWitdh_0
    247              /* Take the x-size of the widgets client rectangle as limit */
    248              WM_GetClientRectEx(hObj, &Rect);
   \   00000024   10108DE2           ADD      R1,SP,#+16
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   ........           BL       WM_GetClientRectEx
    249              DragLimit = Rect.x1;
   \   00000030   F461DDE1           LDRSH    R6,[SP, #+20]
    250              /* If the parent window has a vertical scrollbar, reduce the drag limit by the xsize of the scrollbar */
    251              hParent = WM_GetParent(hObj);
    252              if (hParent) {
   \   00000034   0500A0E1           MOV      R0,R5
   \   00000038   ........           BL       WM_GetParent
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0600000A           BEQ      ??_LimitDragWitdh_1
    253                hVScroll = WM_GetScrollbarV(WM_GetParent(hObj));
   \   00000044   0500A0E1           MOV      R0,R5
   \   00000048   ........           BL       WM_GetParent
   \   0000004C   ........           BL       WM_GetScrollbarV
    254                if (hVScroll) {
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0100000A           BEQ      ??_LimitDragWitdh_1
    255                  DragLimit -= WM_GetWindowSizeX(hVScroll);
   \   00000058   ........           BL       WM_GetWindowSizeX
   \   0000005C   006046E0           SUB      R6,R6,R0
    256                }
    257              }
    258              /* Calculate the sum of the width of all header items */
    259              for (SumX = i = 0; i <= CaptureItem; i++) {
   \                     ??_LimitDragWitdh_1:
   \   00000060   0070A0E3           MOV      R7,#+0
   \   00000064   0080A0E3           MOV      R8,#+0
   \   00000068   000054E3           CMP      R4,#+0
   \   0000006C   1500004A           BMI      ??_LimitDragWitdh_2
    260                SumX += HEADER_GetItemWidth(hObj, i);
   \                     ??_LimitDragWitdh_3:
   \   00000070   0090A0E3           MOV      R9,#+0
   \   00000074   000055E3           CMP      R5,#+0
   \   00000078   0E00000A           BEQ      ??_LimitDragWitdh_4
   \   0000007C   ........           BL       GUI_Lock
   \   00000080   0500A0E1           MOV      R0,R5
   \   00000084   ........           BL       GUI_ALLOC_LockH
   \   00000088   00B0A0E1           MOV      R11,R0
   \   0000008C   4C009BE5           LDR      R0,[R11, #+76]
   \   00000090   ........           BL       GUI_ARRAY_GetNumItems
   \   00000094   070050E1           CMP      R0,R7
   \   00000098   0400003A           BCC      ??_LimitDragWitdh_5
   \   0000009C   0710A0E1           MOV      R1,R7
   \   000000A0   4C009BE5           LDR      R0,[R11, #+76]
   \   000000A4   ........           BL       GUI_ARRAY_GetpItemLocked
   \   000000A8   009090E5           LDR      R9,[R0, #+0]
   \   000000AC   ........           BL       GUI_ALLOC_UnlockH
   \                     ??_LimitDragWitdh_5:
   \   000000B0   ........           BL       GUI_ALLOC_UnlockH
   \   000000B4   ........           BL       GUI_Unlock
    261              }
   \                     ??_LimitDragWitdh_4:
   \   000000B8   017087E2           ADD      R7,R7,#+1
   \   000000BC   088089E0           ADD      R8,R9,R8
   \   000000C0   070054E1           CMP      R4,R7
   \   000000C4   E9FFFFAA           BGE      ??_LimitDragWitdh_3
    262              /* If the sum of the width of all header items exeeds the limit, limit the captured item */
    263              if (SumX > DragLimit) {
   \                     ??_LimitDragWitdh_2:
   \   000000C8   080056E1           CMP      R6,R8
   \   000000CC   410000AA           BGE      ??_LimitDragWitdh_0
    264                for (SumX = i = 0; i < CaptureItem; i++) {
   \   000000D0   0070A0E3           MOV      R7,#+0
   \   000000D4   0080A0E3           MOV      R8,#+0
   \   000000D8   010054E3           CMP      R4,#+1
   \   000000DC   150000BA           BLT      ??_LimitDragWitdh_6
    265                  SumX += HEADER_GetItemWidth(hObj, i);
   \                     ??_LimitDragWitdh_7:
   \   000000E0   0090A0E3           MOV      R9,#+0
   \   000000E4   000055E3           CMP      R5,#+0
   \   000000E8   0E00000A           BEQ      ??_LimitDragWitdh_8
   \   000000EC   ........           BL       GUI_Lock
   \   000000F0   0500A0E1           MOV      R0,R5
   \   000000F4   ........           BL       GUI_ALLOC_LockH
   \   000000F8   00B0A0E1           MOV      R11,R0
   \   000000FC   4C009BE5           LDR      R0,[R11, #+76]
   \   00000100   ........           BL       GUI_ARRAY_GetNumItems
   \   00000104   070050E1           CMP      R0,R7
   \   00000108   0400003A           BCC      ??_LimitDragWitdh_9
   \   0000010C   0710A0E1           MOV      R1,R7
   \   00000110   4C009BE5           LDR      R0,[R11, #+76]
   \   00000114   ........           BL       GUI_ARRAY_GetpItemLocked
   \   00000118   009090E5           LDR      R9,[R0, #+0]
   \   0000011C   ........           BL       GUI_ALLOC_UnlockH
   \                     ??_LimitDragWitdh_9:
   \   00000120   ........           BL       GUI_ALLOC_UnlockH
   \   00000124   ........           BL       GUI_Unlock
    266                }
   \                     ??_LimitDragWitdh_8:
   \   00000128   017087E2           ADD      R7,R7,#+1
   \   0000012C   088089E0           ADD      R8,R9,R8
   \   00000130   040057E1           CMP      R7,R4
   \   00000134   E9FFFFBA           BLT      ??_LimitDragWitdh_7
    267                HEADER_SetItemWidth(hObj, CaptureItem, DragLimit - SumX);
   \                     ??_LimitDragWitdh_6:
   \   00000138   086046E0           SUB      R6,R6,R8
   \   0000013C   000055E3           CMP      R5,#+0
   \   00000140   2200000A           BEQ      ??_LimitDragWitdh_10
   \   00000144   000056E3           CMP      R6,#+0
   \   00000148   2000004A           BMI      ??_LimitDragWitdh_10
   \   0000014C   ........           BL       GUI_Lock
   \   00000150   0500A0E1           MOV      R0,R5
   \   00000154   ........           BL       GUI_ALLOC_LockH
   \   00000158   4C7090E5           LDR      R7,[R0, #+76]
   \   0000015C   ........           BL       GUI_ALLOC_UnlockH
   \   00000160   0700A0E1           MOV      R0,R7
   \   00000164   ........           BL       GUI_ARRAY_GetNumItems
   \   00000168   040050E1           CMP      R0,R4
   \   0000016C   1600003A           BCC      ??_LimitDragWitdh_11
   \   00000170   0410A0E1           MOV      R1,R4
   \   00000174   0700A0E1           MOV      R0,R7
   \   00000178   ........           BL       GUI_ARRAY_GetpItemLocked
   \   0000017C   000050E3           CMP      R0,#+0
   \   00000180   0100001A           BNE      ??_LimitDragWitdh_12
   \   00000184   ........           BL       GUI_ALLOC_UnlockH
   \   00000188   0F0000EA           B        ??_LimitDragWitdh_11
   \                     ??_LimitDragWitdh_12:
   \   0000018C   006080E5           STR      R6,[R0, #+0]
   \   00000190   ........           BL       GUI_ALLOC_UnlockH
   \   00000194   0500A0E1           MOV      R0,R5
   \   00000198   ........           BL       WM_GetParent
   \   0000019C   04008DE5           STR      R0,[SP, #+4]
   \   000001A0   2510A0E3           MOV      R1,#+37
   \   000001A4   00108DE5           STR      R1,[SP, #+0]
   \   000001A8   08508DE5           STR      R5,[SP, #+8]
   \   000001AC   0500A0E1           MOV      R0,R5
   \   000001B0   ........           BL       WM_InvalidateWindow
   \   000001B4   0D10A0E1           MOV      R1,SP
   \   000001B8   04009DE5           LDR      R0,[SP, #+4]
   \   000001BC   ........           BL       WM__SendMessage
   \   000001C0   0500A0E1           MOV      R0,R5
   \   000001C4   ........           BL       WM_GetParent
   \   000001C8   ........           BL       WM_InvalidateWindow
   \                     ??_LimitDragWitdh_11:
   \   000001CC   ........           BL       GUI_Unlock
    268                return 1;
   \                     ??_LimitDragWitdh_10:
   \   000001D0   0100A0E3           MOV      R0,#+1
   \   000001D4   000000EA           B        ??_LimitDragWitdh_13
    269              }
    270            }
    271            return 0;
   \                     ??_LimitDragWitdh_0:
   \   000001D8   0000A0E3           MOV      R0,#+0
   \                     ??_LimitDragWitdh_13:
   \   000001DC   18D08DE2           ADD      SP,SP,#+24       ;; stack cleaning
   \   000001E0   F08BBDE8           POP      {R4-R9,R11,PC}   ;; return
    272          }
    273          
    274          /*********************************************************************
    275          *
    276          *       _HandlePID
    277          */
    278          #if (HEADER_SUPPORT_DRAG)

   \                                 In section .text, align 4, keep-with-next
    279          static void _HandlePID(HEADER_Handle hObj, int x, int y, int Pressed) {
   \                     _HandlePID:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   0370A0E1           MOV      R7,R3
    280            HEADER_Obj * pObj;
    281            int Hit;
    282            int CapturePosX;
    283            int CaptureItem;
    284          
    285            pObj = HEADER_LOCK_H(hObj);
   \   00000018   ........           BL       GUI_ALLOC_LockH
   \   0000001C   0090A0E1           MOV      R9,R0
    286            Hit = _GetDividerIndex(hObj, pObj, x, y);
   \   00000020   0630A0E1           MOV      R3,R6
   \   00000024   0520A0E1           MOV      R2,R5
   \   00000028   0910A0E1           MOV      R1,R9
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       _GetDividerIndex
   \   00000034   0080A0E1           MOV      R8,R0
    287            /* set capture position */
    288            if ((Pressed == 1) && (Hit >= 0) && (pObj->CapturePosX == -1)) {
   \   00000038   010057E3           CMP      R7,#+1
   \   0000003C   0700001A           BNE      ??_HandlePID_0
   \   00000040   000058E3           CMP      R8,#+0
   \   00000044   0700004A           BMI      ??_HandlePID_1
   \   00000048   500099E5           LDR      R0,[R9, #+80]
   \   0000004C   010070E3           CMN      R0,#+1
   \   00000050   0400001A           BNE      ??_HandlePID_1
    289              pObj->CapturePosX = x;
   \   00000054   505089E5           STR      R5,[R9, #+80]
    290              pObj->CaptureItem = Hit;
   \   00000058   548089E5           STR      R8,[R9, #+84]
   \   0000005C   010000EA           B        ??_HandlePID_1
    291            }
    292            if (Pressed <= 0) {
    293              pObj->CapturePosX = -1;
   \                     ??_HandlePID_0:
   \   00000060   0000E0B3           MVNLT    R0,#+0
   \   00000064   500089B5           STRLT    R0,[R9, #+80]
    294            }
    295            CapturePosX = pObj->CapturePosX;
    296            CaptureItem = pObj->CaptureItem;
   \                     ??_HandlePID_1:
   \   00000068   541099E5           LDR      R1,[R9, #+84]
   \   0000006C   506099E5           LDR      R6,[R9, #+80]
   \   00000070   00108DE5           STR      R1,[SP, #+0]
    297            GUI_UNLOCK_H(pObj);
   \   00000074   ........           BL       GUI_ALLOC_UnlockH
   \   00000078   0090A0E3           MOV      R9,#+0
    298            /* set mouse cursor and capture */
    299            if (Hit >= 0) {
   \   0000007C   000058E3           CMP      R8,#+0
   \   00000080   0F00004A           BMI      ??_HandlePID_2
    300              WM_SetCapture(hObj, 1);
   \   00000084   0110A0E3           MOV      R1,#+1
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   ........           BL       WM_SetCapture
    301              #if GUI_SUPPORT_CURSOR
    302                if (!_pOldCursor) {
   \   00000090   ........           LDR      R10,??DataTable3
   \   00000094   00009AE5           LDR      R0,[R10, #+0]
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   0800001A           BNE      ??_HandlePID_2
    303                  if (GUI_CURSOR_GetStateEx(WM__TOUCHED_LAYER)) {
   \   000000A0   ........           LDR      R11,??DataTable3_1
   \   000000A4   00009BE5           LDR      R0,[R11, #+0]
   \   000000A8   ........           BL       GUI_CURSOR_GetStateEx
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   0300000A           BEQ      ??_HandlePID_2
    304                    _pOldCursor = GUI_CURSOR_SelectEx(HEADER__pDefaultCursor, WM__TOUCHED_LAYER);
   \   000000B4   00109BE5           LDR      R1,[R11, #+0]
   \   000000B8   04009AE5           LDR      R0,[R10, #+4]
   \   000000BC   ........           BL       GUI_CURSOR_SelectEx
   \   000000C0   00008AE5           STR      R0,[R10, #+0]
    305                  }
    306                }
    307              #endif
    308            }
    309            /* modify header */
    310            if ((CapturePosX >= 0) && (x != CapturePosX) && (Pressed == 1)) {
   \                     ??_HandlePID_2:
   \   000000C4   000056E3           CMP      R6,#+0
   \   000000C8   4300004A           BMI      ??_HandlePID_3
   \   000000CC   060055E1           CMP      R5,R6
   \   000000D0   4100000A           BEQ      ??_HandlePID_3
   \   000000D4   010057E3           CMP      R7,#+1
   \   000000D8   3F00001A           BNE      ??_HandlePID_3
    311              int NewSize = HEADER_GetItemWidth(hObj, CaptureItem) + x - CapturePosX;
   \   000000DC   00709DE5           LDR      R7,[SP, #+0]
   \   000000E0   0080A0E3           MOV      R8,#+0
   \   000000E4   000054E3           CMP      R4,#+0
   \   000000E8   0E00000A           BEQ      ??_HandlePID_4
   \   000000EC   ........           BL       GUI_Lock
   \   000000F0   0400A0E1           MOV      R0,R4
   \   000000F4   ........           BL       GUI_ALLOC_LockH
   \   000000F8   00A0A0E1           MOV      R10,R0
   \   000000FC   4C009AE5           LDR      R0,[R10, #+76]
   \   00000100   ........           BL       GUI_ARRAY_GetNumItems
   \   00000104   070050E1           CMP      R0,R7
   \   00000108   0400003A           BCC      ??_HandlePID_5
   \   0000010C   0710A0E1           MOV      R1,R7
   \   00000110   4C009AE5           LDR      R0,[R10, #+76]
   \   00000114   ........           BL       GUI_ARRAY_GetpItemLocked
   \   00000118   008090E5           LDR      R8,[R0, #+0]
   \   0000011C   ........           BL       GUI_ALLOC_UnlockH
   \                     ??_HandlePID_5:
   \   00000120   ........           BL       GUI_ALLOC_UnlockH
   \   00000124   ........           BL       GUI_Unlock
   \                     ??_HandlePID_4:
   \   00000128   080085E0           ADD      R0,R5,R8
   \   0000012C   067050E0           SUBS     R7,R0,R6
    312              if (NewSize >= 0) {
   \   00000130   3C00004A           BMI      ??_HandlePID_6
    313                HEADER_SetItemWidth(hObj, CaptureItem, NewSize);
   \   00000134   00809DE5           LDR      R8,[SP, #+0]
   \   00000138   000054E3           CMP      R4,#+0
   \   0000013C   2000000A           BEQ      ??_HandlePID_7
   \   00000140   ........           BL       GUI_Lock
   \   00000144   0400A0E1           MOV      R0,R4
   \   00000148   ........           BL       GUI_ALLOC_LockH
   \   0000014C   4C9090E5           LDR      R9,[R0, #+76]
   \   00000150   ........           BL       GUI_ALLOC_UnlockH
   \   00000154   0900A0E1           MOV      R0,R9
   \   00000158   ........           BL       GUI_ARRAY_GetNumItems
   \   0000015C   080050E1           CMP      R0,R8
   \   00000160   1600003A           BCC      ??_HandlePID_8
   \   00000164   0810A0E1           MOV      R1,R8
   \   00000168   0900A0E1           MOV      R0,R9
   \   0000016C   ........           BL       GUI_ARRAY_GetpItemLocked
   \   00000170   000050E3           CMP      R0,#+0
   \   00000174   0100001A           BNE      ??_HandlePID_9
   \   00000178   ........           BL       GUI_ALLOC_UnlockH
   \   0000017C   0F0000EA           B        ??_HandlePID_8
   \                     ??_HandlePID_9:
   \   00000180   007080E5           STR      R7,[R0, #+0]
   \   00000184   ........           BL       GUI_ALLOC_UnlockH
   \   00000188   0400A0E1           MOV      R0,R4
   \   0000018C   ........           BL       WM_GetParent
   \   00000190   08008DE5           STR      R0,[SP, #+8]
   \   00000194   2510A0E3           MOV      R1,#+37
   \   00000198   04108DE5           STR      R1,[SP, #+4]
   \   0000019C   0C408DE5           STR      R4,[SP, #+12]
   \   000001A0   0400A0E1           MOV      R0,R4
   \   000001A4   ........           BL       WM_InvalidateWindow
   \   000001A8   04108DE2           ADD      R1,SP,#+4
   \   000001AC   08009DE5           LDR      R0,[SP, #+8]
   \   000001B0   ........           BL       WM__SendMessage
   \   000001B4   0400A0E1           MOV      R0,R4
   \   000001B8   ........           BL       WM_GetParent
   \   000001BC   ........           BL       WM_InvalidateWindow
   \                     ??_HandlePID_8:
   \   000001C0   ........           BL       GUI_Unlock
    314                if (!_LimitDragWitdh(hObj)) {
   \                     ??_HandlePID_7:
   \   000001C4   0400A0E1           MOV      R0,R4
   \   000001C8   ........           BL       _LimitDragWitdh
   \   000001CC   000050E3           CMP      R0,#+0
   \   000001D0   1400001A           BNE      ??_HandlePID_6
    315                  CapturePosX = x;
   \   000001D4   0560A0E1           MOV      R6,R5
   \   000001D8   120000EA           B        ??_HandlePID_6
    316                }
    317              }
    318            }
    319            /* release capture & restore cursor */
    320            if (Pressed <= 0) {
   \                     ??_HandlePID_3:
   \   000001DC   010057E3           CMP      R7,#+1
   \   000001E0   100000AA           BGE      ??_HandlePID_6
    321              #if (GUI_SUPPORT_MOUSE)
    322              if (Hit == -1)
   \   000001E4   010078E3           CMN      R8,#+1
   \   000001E8   0E00001A           BNE      ??_HandlePID_6
    323              #endif
    324              {
    325                _RestoreOldCursor();
   \   000001EC   ........           LDR      R10,??DataTable3
   \   000001F0   00009AE5           LDR      R0,[R10, #+0]
   \   000001F4   000050E3           CMP      R0,#+0
   \   000001F8   0800000A           BEQ      ??_HandlePID_10
   \   000001FC   ........           LDR      R11,??DataTable3_1
   \   00000200   00009BE5           LDR      R0,[R11, #+0]
   \   00000204   ........           BL       GUI_CURSOR_GetStateEx
   \   00000208   000050E3           CMP      R0,#+0
   \   0000020C   0200000A           BEQ      ??_HandlePID_11
   \   00000210   00109BE5           LDR      R1,[R11, #+0]
   \   00000214   00009AE5           LDR      R0,[R10, #+0]
   \   00000218   ........           BL       GUI_CURSOR_SelectEx
   \                     ??_HandlePID_11:
   \   0000021C   00908AE5           STR      R9,[R10, #+0]
    326                CapturePosX = -1;
   \                     ??_HandlePID_10:
   \   00000220   0960E0E1           MVN      R6,R9
    327                WM_ReleaseCapture();
   \   00000224   ........           BL       WM_ReleaseCapture
    328              }
    329            }
    330            pObj = HEADER_LOCK_H(hObj);
    331            pObj->CapturePosX = CapturePosX;
   \                     ??_HandlePID_6:
   \   00000228   0400A0E1           MOV      R0,R4
   \   0000022C   ........           BL       GUI_ALLOC_LockH
   \   00000230   506080E5           STR      R6,[R0, #+80]
    332            GUI_UNLOCK_H(pObj);
   \   00000234   ........           BL       GUI_ALLOC_UnlockH
    333          }
   \   00000238   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   0000023C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    334          #endif
    335          
    336          /*********************************************************************
    337          *
    338          *       _OnMouseOver
    339          */
    340          #if (HEADER_SUPPORT_DRAG & GUI_SUPPORT_MOUSE)
    341          static void _OnMouseOver(HEADER_Handle hObj, WM_MESSAGE * pMsg) {
    342            HEADER_Obj * pObj;
    343            const GUI_PID_STATE * pState;
    344            int ScrollPos;
    345            pObj = HEADER_LOCK_H(hObj);
    346            ScrollPos = pObj->ScrollPos;
    347            GUI_UNLOCK_H(pObj);
    348            pState = (const GUI_PID_STATE *)pMsg->Data.p;
    349            if (pState) {
    350              _HandlePID(hObj, pState->x + ScrollPos, pState->y, -1);
    351            }
    352          }
    353          #endif
    354          
    355          /*********************************************************************
    356          *
    357          *       _GetItemIndex
    358          */

   \                                 In section .text, align 4, keep-with-next
    359          static int _GetItemIndex(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y) {
   \                     _GetItemIndex:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0080A0E1           MOV      R8,R0
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   0390B0E1           MOVS     R9,R3
    360            int Item;
    361            int LastFixedPos;
    362            Item = -1;
   \   00000018   0060E0E3           MVN      R6,#+0
    363            LastFixedPos = 0;
   \   0000001C   0070A0E3           MOV      R7,#+0
    364            if ((y >= 0) && (y < WM_GetWindowSizeY(hObj))) {
   \   00000020   2A00004A           BMI      ??_GetItemIndex_0
   \   00000024   ........           BL       WM_GetWindowSizeY
   \   00000028   000059E1           CMP      R9,R0
   \   0000002C   270000AA           BGE      ??_GetItemIndex_0
    365              if (hObj) {
   \   00000030   000058E3           CMP      R8,#+0
   \   00000034   2500000A           BEQ      ??_GetItemIndex_0
    366                int xPos;
    367                unsigned Index, NumColumns;
    368                NumColumns = GUI_ARRAY_GetNumItems(pObj->Columns);
   \   00000038   4C0094E5           LDR      R0,[R4, #+76]
   \   0000003C   ........           BL       GUI_ARRAY_GetNumItems
   \   00000040   0080A0E1           MOV      R8,R0
    369                if (pObj->Fixed) {
   \   00000044   680094E5           LDR      R0,[R4, #+104]
    370                  xPos = pObj->ScrollPos;
    371                } else {
    372                  xPos = 0;
    373                }
    374                for (Index = 0; Index < NumColumns; Index++) {
   \   00000048   00A0A0E3           MOV      R10,#+0
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   58909415           LDRNE    R9,[R4, #+88]
   \   00000054   0090A003           MOVEQ    R9,#+0
   \   00000058   000058E3           CMP      R8,#+0
   \   0000005C   1B00000A           BEQ      ??_GetItemIndex_0
    375                  int Width;
    376                  HEADER_COLUMN * pColumn;
    377                  pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItemLocked(pObj->Columns, Index);
    378                  Width = pColumn->Width;
   \                     ??_GetItemIndex_1:
   \   00000060   0A10A0E1           MOV      R1,R10
   \   00000064   4C0094E5           LDR      R0,[R4, #+76]
   \   00000068   ........           BL       GUI_ARRAY_GetpItemLocked
   \   0000006C   00B090E5           LDR      R11,[R0, #+0]
    379                  GUI_UNLOCK_H(pColumn);
   \   00000070   ........           BL       GUI_ALLOC_UnlockH
    380                  if (xPos >= LastFixedPos) {
   \   00000074   070059E1           CMP      R9,R7
   \   00000078   070000BA           BLT      ??_GetItemIndex_2
    381                    if ((x > (xPos + 4)) && (x < (xPos + Width - 4))) {
   \   0000007C   040089E2           ADD      R0,R9,#+4
   \   00000080   050050E1           CMP      R0,R5
   \   00000084   040000AA           BGE      ??_GetItemIndex_2
   \   00000088   0B0089E0           ADD      R0,R9,R11
   \   0000008C   040040E2           SUB      R0,R0,#+4
   \   00000090   000055E1           CMP      R5,R0
    382                      Item = Index;
   \   00000094   0A60A0B1           MOVLT    R6,R10
    383                      break;
   \   00000098   0C0000BA           BLT      ??_GetItemIndex_0
    384                    }
    385                  }
    386                  if (Index < pObj->Fixed) {
   \                     ??_GetItemIndex_2:
   \   0000009C   680094E5           LDR      R0,[R4, #+104]
   \   000000A0   00005AE1           CMP      R10,R0
    387                    LastFixedPos = xPos;
   \   000000A4   0970A031           MOVCC    R7,R9
   \   000000A8   0400003A           BCC      ??_GetItemIndex_3
    388                  } else if (pObj->Fixed && (Index == pObj->Fixed)) {
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   0200000A           BEQ      ??_GetItemIndex_3
   \   000000B4   00005AE1           CMP      R10,R0
    389                    xPos -= pObj->ScrollPos;
   \   000000B8   58009405           LDREQ    R0,[R4, #+88]
   \   000000BC   00904900           SUBEQ    R9,R9,R0
    390                  }
    391                  xPos += Width;
    392                }
   \                     ??_GetItemIndex_3:
   \   000000C0   01A08AE2           ADD      R10,R10,#+1
   \   000000C4   09908BE0           ADD      R9,R11,R9
   \   000000C8   08005AE1           CMP      R10,R8
   \   000000CC   E3FFFF3A           BCC      ??_GetItemIndex_1
    393              }
    394            }
    395            return Item;
   \                     ??_GetItemIndex_0:
   \   000000D0   0600A0E1           MOV      R0,R6
   \   000000D4   04D08DE2           ADD      SP,SP,#+4
   \   000000D8   F08FBDE8           POP      {R4-R11,PC}      ;; return
    396          }
    397          
    398          /*********************************************************************
    399          *
    400          *       _OnTouch
    401          */
    402          #if (HEADER_SUPPORT_DRAG)
    403          static void _OnTouch(HEADER_Handle hObj, WM_MESSAGE * pMsg) {
    404            HEADER_Obj * pObj;
    405            int Notification;
    406            int ScrollPos;
    407            const GUI_PID_STATE * pState;
    408          
    409            pObj = HEADER_LOCK_H(hObj);
    410            ScrollPos = pObj->ScrollPos;
    411            GUI_UNLOCK_H(pObj);
    412            pState = (const GUI_PID_STATE *)pMsg->Data.p;
    413            if (pState) {
    414              _HandlePID(hObj, pState->x + ScrollPos, pState->y, pState->Pressed);
    415              if (pState->Pressed) {
    416                Notification = WM_NOTIFICATION_CLICKED;
    417              } else {
    418                Notification = WM_NOTIFICATION_RELEASED;
    419              }
    420            } else {
    421              Notification = WM_NOTIFICATION_MOVED_OUT;
    422            }
    423            WM_NotifyParent(hObj, Notification);
    424          }
    425          #endif
    426          
    427          /*********************************************************************
    428          *
    429          *       _OnPidStateChange
    430          */
    431          static void _OnPidStateChange(HEADER_Handle hObj, WM_MESSAGE * pMsg) {
    432            HEADER_Obj * pObj;
    433            const WM_PID_STATE_CHANGED_INFO * pState;
    434            pObj = HEADER_LOCK_H(hObj);
    435            pState = (const WM_PID_STATE_CHANGED_INFO *)pMsg->Data.p;
    436            if ((pState->StatePrev == 1) && (pState->State == 0)) {
    437              pObj->Sel = _GetItemIndex(hObj, pObj, pState->x + pObj->ScrollPos, pState->y);
    438            }
    439            GUI_UNLOCK_H(pObj);
    440          }
    441          
    442          /*********************************************************************
    443          *
    444          *       Private routines
    445          *
    446          **********************************************************************
    447          */
    448          /*********************************************************************
    449          *
    450          *       HEADER_LockH
    451          */
    452          #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
    453          HEADER_Obj * HEADER_LockH(HEADER_Handle h) {
    454            HEADER_Obj * p = (HEADER_Obj *)GUI_LOCK_H(h);
    455            if (p) {
    456              if (p->DebugId != HEADER_ID) {
    457                GUI_DEBUG_ERROROUT("HEADER.c: Wrong handle type or Object not init'ed");
    458                return 0;
    459              }
    460            }
    461            return p;
    462          }
    463          #endif
    464          
    465          /*********************************************************************
    466          *
    467          *       Exported routines:  Callback
    468          *
    469          **********************************************************************
    470          */
    471          /*********************************************************************
    472          *
    473          *       HEADER_Callback
    474          */

   \                                 In section .text, align 4, keep-with-next
    475          void HEADER_Callback (WM_MESSAGE *pMsg) {
   \                     HEADER_Callback:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    476            HEADER_Handle hObj;
    477            hObj = pMsg->hWin;
   \   00000008   044095E5           LDR      R4,[R5, #+4]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
    478            /* Let widget handle the standard messages */
    479            if (WIDGET_HandleActive(hObj, pMsg) == 0) {
   \   00000010   0510A0E1           MOV      R1,R5
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   ........           BL       WIDGET_HandleActive
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   6900000A           BEQ      ??HEADER_Callback_1
    480              return;
    481            }
    482            WM_LOCK();
   \   00000024   ........           BL       GUI_Lock
    483            switch (pMsg->MsgId) {
   \   00000028   000095E5           LDR      R0,[R5, #+0]
   \   0000002C   0B0040E2           SUB      R0,R0,#+11
   \   00000030   060050E3           CMP      R0,#+6
   \   00000034   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??HEADER_Callback_0:
   \   00000038   6000008A           BHI      ??HEADER_Callback_2
   \   0000003C   450000EA           B        ??HEADER_Callback_3
   \   00000040   210000EA           B        ??HEADER_Callback_4
   \   00000044   5D0000EA           B        ??HEADER_Callback_2
   \   00000048   5C0000EA           B        ??HEADER_Callback_2
   \   0000004C   010000EA           B        ??HEADER_Callback_5
   \   00000050   320000EA           B        ??HEADER_Callback_6
   \   00000054   090000EA           B        ??HEADER_Callback_7
    484            case WM_PAINT:
    485              _Paint(hObj);
   \                     ??HEADER_Callback_5:
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           BL       GUI_ALLOC_LockH
   \   00000060   480090E5           LDR      R0,[R0, #+72]
   \   00000064   005090E5           LDR      R5,[R0, #+0]
   \   00000068   ........           BL       GUI_ALLOC_UnlockH
   \   0000006C   000055E3           CMP      R5,#+0
   \   00000070   5400000A           BEQ      ??HEADER_Callback_8
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   35FF2FE1           BLX      R5
   \   0000007C   510000EA           B        ??HEADER_Callback_8
    486              break;
    487            case WM_PID_STATE_CHANGED:
    488              _OnPidStateChange(hObj, pMsg);
   \                     ??HEADER_Callback_7:
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   ........           BL       GUI_ALLOC_LockH
   \   00000088   0060A0E1           MOV      R6,R0
   \   0000008C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000090   0910D0E5           LDRB     R1,[R0, #+9]
   \   00000094   010051E3           CMP      R1,#+1
   \   00000098   0810D005           LDRBEQ   R1,[R0, #+8]
   \   0000009C   00005103           CMPEQ    R1,#+0
   \   000000A0   0700001A           BNE      ??HEADER_Callback_9
   \   000000A4   043090E5           LDR      R3,[R0, #+4]
   \   000000A8   000090E5           LDR      R0,[R0, #+0]
   \   000000AC   581096E5           LDR      R1,[R6, #+88]
   \   000000B0   002081E0           ADD      R2,R1,R0
   \   000000B4   0610A0E1           MOV      R1,R6
   \   000000B8   0400A0E1           MOV      R0,R4
   \   000000BC   ........           BL       _GetItemIndex
   \   000000C0   5C0086E5           STR      R0,[R6, #+92]
   \                     ??HEADER_Callback_9:
   \   000000C4   ........           BL       GUI_ALLOC_UnlockH
    489              break;
   \   000000C8   3E0000EA           B        ??HEADER_Callback_8
    490          #if (HEADER_SUPPORT_DRAG)
    491            case WM_TOUCH:
    492              _OnTouch(hObj, pMsg);
   \                     ??HEADER_Callback_4:
   \   000000CC   0400A0E1           MOV      R0,R4
   \   000000D0   ........           BL       GUI_ALLOC_LockH
   \   000000D4   586090E5           LDR      R6,[R0, #+88]
   \   000000D8   ........           BL       GUI_ALLOC_UnlockH
   \   000000DC   0C5095E5           LDR      R5,[R5, #+12]
   \   000000E0   000055E3           CMP      R5,#+0
   \   000000E4   0310A003           MOVEQ    R1,#+3
   \   000000E8   0900000A           BEQ      ??HEADER_Callback_10
   \   000000EC   000095E5           LDR      R0,[R5, #+0]
   \   000000F0   0830D5E5           LDRB     R3,[R5, #+8]
   \   000000F4   001086E0           ADD      R1,R6,R0
   \   000000F8   042095E5           LDR      R2,[R5, #+4]
   \   000000FC   0400A0E1           MOV      R0,R4
   \   00000100   ........           BL       _HandlePID
   \   00000104   0800D5E5           LDRB     R0,[R5, #+8]
   \   00000108   000050E3           CMP      R0,#+0
   \   0000010C   0110A013           MOVNE    R1,#+1
   \   00000110   0210A003           MOVEQ    R1,#+2
   \                     ??HEADER_Callback_10:
   \   00000114   0400A0E1           MOV      R0,R4
   \   00000118   ........           BL       WM_NotifyParent
    493              break;
   \   0000011C   290000EA           B        ??HEADER_Callback_8
    494          #endif
    495          #if (HEADER_SUPPORT_DRAG & GUI_SUPPORT_MOUSE)
    496            case WM_MOUSEOVER:
    497              _OnMouseOver(hObj, pMsg);
   \                     ??HEADER_Callback_6:
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   ........           BL       GUI_ALLOC_LockH
   \   00000128   586090E5           LDR      R6,[R0, #+88]
   \   0000012C   ........           BL       GUI_ALLOC_UnlockH
   \   00000130   0C0095E5           LDR      R0,[R5, #+12]
   \   00000134   000050E3           CMP      R0,#+0
   \   00000138   2200000A           BEQ      ??HEADER_Callback_8
   \   0000013C   042090E5           LDR      R2,[R0, #+4]
   \   00000140   000090E5           LDR      R0,[R0, #+0]
   \   00000144   0030E0E3           MVN      R3,#+0
   \   00000148   001086E0           ADD      R1,R6,R0
   \   0000014C   0400A0E1           MOV      R0,R4
   \   00000150   ........           BL       _HandlePID
   \   00000154   1B0000EA           B        ??HEADER_Callback_8
    498              break;
    499          #endif
    500            case WM_DELETE:
    501              _FreeAttached(hObj); /* No return here ... WM_DefaultProc needs to be called */
   \                     ??HEADER_Callback_3:
   \   00000158   0400A0E1           MOV      R0,R4
   \   0000015C   ........           BL       GUI_ALLOC_LockH
   \   00000160   4C4090E5           LDR      R4,[R0, #+76]
   \   00000164   ........           BL       GUI_ALLOC_UnlockH
   \   00000168   0400A0E1           MOV      R0,R4
   \   0000016C   ........           BL       GUI_ARRAY_GetNumItems
   \   00000170   0060A0E1           MOV      R6,R0
   \   00000174   0070A0E3           MOV      R7,#+0
   \   00000178   010056E3           CMP      R6,#+1
   \   0000017C   140000AA           BGE      ??HEADER_Callback_11
   \                     ??HEADER_Callback_12:
   \   00000180   0400A0E1           MOV      R0,R4
   \   00000184   ........           BL       GUI_ARRAY_Delete
   \   00000188   ........           LDR      R4,??DataTable3
   \   0000018C   000094E5           LDR      R0,[R4, #+0]
   \   00000190   000050E3           CMP      R0,#+0
   \   00000194   0900000A           BEQ      ??HEADER_Callback_2
   \   00000198   ........           LDR      R6,??DataTable3_1
   \   0000019C   000096E5           LDR      R0,[R6, #+0]
   \   000001A0   ........           BL       GUI_CURSOR_GetStateEx
   \   000001A4   000050E3           CMP      R0,#+0
   \   000001A8   0300000A           BEQ      ??HEADER_Callback_13
   \   000001AC   001096E5           LDR      R1,[R6, #+0]
   \   000001B0   000094E5           LDR      R0,[R4, #+0]
   \   000001B4   ........           BL       GUI_CURSOR_SelectEx
   \   000001B8   0000A0E3           MOV      R0,#+0
   \                     ??HEADER_Callback_13:
   \   000001BC   000084E5           STR      R0,[R4, #+0]
    502            default:
    503              WM_DefaultProc(pMsg);
   \                     ??HEADER_Callback_2:
   \   000001C0   0500A0E1           MOV      R0,R5
   \   000001C4   ........           BL       WM_DefaultProc
    504            }
    505            WM_UNLOCK();
   \                     ??HEADER_Callback_8:
   \   000001C8   ........           BL       GUI_Unlock
    506          }
   \                     ??HEADER_Callback_1:
   \   000001CC   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000001D0   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??HEADER_Callback_11:
   \   000001D4   0710A0E1           MOV      R1,R7
   \   000001D8   0400A0E1           MOV      R0,R4
   \   000001DC   ........           BL       GUI_ARRAY_GetpItemLocked
   \   000001E0   080090E5           LDR      R0,[R0, #+8]
   \   000001E4   000050E3           CMP      R0,#+0
   \   000001E8   0000000A           BEQ      ??HEADER_Callback_14
   \   000001EC   ........           BL       GUI_ALLOC_Free
   \                     ??HEADER_Callback_14:
   \   000001F0   ........           BL       GUI_ALLOC_UnlockH
   \   000001F4   017087E2           ADD      R7,R7,#+1
   \   000001F8   060057E1           CMP      R7,R6
   \   000001FC   F4FFFFBA           BLT      ??HEADER_Callback_11
   \   00000200   DEFFFFEA           B        ??HEADER_Callback_12
    507          
    508          /*********************************************************************
    509          *
    510          *       Exported routines:  Create
    511          *
    512          **********************************************************************
    513          */
    514          /*********************************************************************
    515          *
    516          *       HEADER_Create
    517          */

   \                                 In section .text, align 4, keep-with-next
    518          HEADER_Handle HEADER_Create(int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int Id, int Flags, int ExFlags) {
   \                     HEADER_Create:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   20C09DE5           LDR      R12,[SP, #+32]
   \   0000000C   24E09DE5           LDR      LR,[SP, #+36]
   \   00000010   28409DE5           LDR      R4,[SP, #+40]
   \   00000014   2C509DE5           LDR      R5,[SP, #+44]
    519            return HEADER_CreateEx(x0, y0, xsize, ysize, hParent, Flags, ExFlags, Id);
   \   00000018   0CE08DE5           STR      LR,[SP, #+12]
   \   0000001C   08508DE5           STR      R5,[SP, #+8]
   \   00000020   04408DE5           STR      R4,[SP, #+4]
   \   00000024   00C08DE5           STR      R12,[SP, #+0]
   \   00000028   ........           BL       HEADER_CreateEx
   \   0000002C   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000030   3080BDE8           POP      {R4,R5,PC}       ;; return
    520          }
    521          
    522          /*********************************************************************
    523          *
    524          *       HEADER_CreateEx
    525          */

   \                                 In section .text, align 4, keep-with-next
    526          HEADER_Handle HEADER_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
    527                                        int WinFlags, int ExFlags, int Id)
    528          {
   \                     HEADER_CreateEx:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0190A0E1           MOV      R9,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   03A0A0E1           MOV      R10,R3
   \   00000018   38609DE5           LDR      R6,[SP, #+56]
   \   0000001C   3C709DE5           LDR      R7,[SP, #+60]
   \   00000020   44809DE5           LDR      R8,[SP, #+68]
    529            HEADER_Handle hObj;
    530            GUI_USE_PARA(ExFlags);
    531            /* Create the window */
    532            WM_LOCK();
   \   00000024   ........           BL       GUI_Lock
    533            if ((xsize == 0) && (x0 == 0) && (y0 == 0)) {
   \   00000028   050084E1           ORR      R0,R4,R5
   \   0000002C   000099E1           ORRS     R0,R9,R0
   \   00000030   0700001A           BNE      ??HEADER_CreateEx_0
    534              GUI_RECT Rect;
    535              WM_GetInsideRectEx(hParent, &Rect);
   \   00000034   0D10A0E1           MOV      R1,SP
   \   00000038   0600A0E1           MOV      R0,R6
   \   0000003C   ........           BL       WM_GetInsideRectEx
    536              xsize = Rect.x1 - Rect.x0 + 1;
   \   00000040   F040DDE1           LDRSH    R4,[SP, #+0]
   \   00000044   F400DDE1           LDRSH    R0,[SP, #+4]
    537              x0    = Rect.x0;
    538              y0    = Rect.y0;
   \   00000048   F290DDE1           LDRSH    R9,[SP, #+2]
   \   0000004C   040040E0           SUB      R0,R0,R4
   \   00000050   015080E2           ADD      R5,R0,#+1
    539            }
    540            if (ysize == 0) {
   \                     ??HEADER_CreateEx_0:
   \   00000054   00005AE3           CMP      R10,#+0
   \   00000058   0800001A           BNE      ??HEADER_CreateEx_1
    541              const WIDGET_EFFECT* pEffect = WIDGET_GetDefaultEffect();
   \   0000005C   ........           BL       WIDGET_GetDefaultEffect
    542              ysize  = GUI_GetYDistOfFont(HEADER__DefaultProps.pFont);
   \   00000060   ........           LDR      R10,??DataTable3_2
   \   00000064   00B0A0E1           MOV      R11,R0
   \   00000068   00009AE5           LDR      R0,[R10, #+0]
   \   0000006C   ........           BL       GUI_GetYDistOfFont
    543              ysize += 2 * HEADER__DefaultBorderV;
    544              ysize += 2 * (unsigned)pEffect->EffectSize;
   \   00000070   14109AE5           LDR      R1,[R10, #+20]
   \   00000074   00209BE5           LDR      R2,[R11, #+0]
   \   00000078   011082E0           ADD      R1,R2,R1
   \   0000007C   81A080E0           ADD      R10,R0,R1, LSL #+1
    545            }
    546            WinFlags |= WM_CF_ANCHOR_LEFT | WM_CF_ANCHOR_RIGHT;
    547            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, &HEADER_Callback,
    548                                          sizeof(HEADER_Obj) - sizeof(WM_Obj));
   \                     ??HEADER_CreateEx_1:
   \   00000080   4400A0E3           MOV      R0,#+68
   \   00000084   0C008DE5           STR      R0,[SP, #+12]
   \   00000088   ........           LDR      R0,??DataTable3_3
   \   0000008C   00608DE5           STR      R6,[SP, #+0]
   \   00000090   08008DE5           STR      R0,[SP, #+8]
   \   00000094   A00F87E3           ORR      R0,R7,#0x280
   \   00000098   04008DE5           STR      R0,[SP, #+4]
   \   0000009C   0A30A0E1           MOV      R3,R10
   \   000000A0   0520A0E1           MOV      R2,R5
   \   000000A4   0910A0E1           MOV      R1,R9
   \   000000A8   0400A0E1           MOV      R0,R4
   \   000000AC   ........           BL       WM_CreateWindowAsChild
   \   000000B0   0040B0E1           MOVS     R4,R0
    549            if (hObj) {
   \   000000B4   1A00000A           BEQ      ??HEADER_CreateEx_2
    550              HEADER_Obj * pObj;
    551              GUI_ARRAY Columns;
    552              Columns = GUI_ARRAY_Create();
   \   000000B8   ........           BL       GUI_ARRAY_Create
   \   000000BC   0060A0E1           MOV      R6,R0
    553              pObj = (HEADER_Obj *)GUI_LOCK_H(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   ........           BL       GUI_ALLOC_LockH
   \   000000C8   0050A0E1           MOV      R5,R0
    554              /* Init sub-classes */
    555              pObj->Columns = Columns;
   \   000000CC   4C6085E5           STR      R6,[R5, #+76]
    556              /* init widget specific variables */
    557              WIDGET__Init(&pObj->Widget, Id, 0);
   \   000000D0   0020A0E3           MOV      R2,#+0
   \   000000D4   0810A0E1           MOV      R1,R8
   \   000000D8   ........           BL       WIDGET__Init
    558              /* init member variables */
    559              HEADER_INIT_ID(pObj);
    560              pObj->Props       = HEADER__DefaultProps;
   \   000000DC   ........           LDR      R10,??DataTable3_2
   \   000000E0   340085E2           ADD      R0,R5,#+52
   \   000000E4   0E50BAE8           LDM      R10!,{R1-R3,R12,LR}
   \   000000E8   14A04AE2           SUB      R10,R10,#+20
   \   000000EC   0E50A0E8           STM      R0!,{R1-R3,R12,LR}
    561              pObj->CapturePosX = -1;
   \   000000F0   0000E0E3           MVN      R0,#+0
   \   000000F4   500085E5           STR      R0,[R5, #+80]
    562              pObj->CaptureItem = -1;
   \   000000F8   540085E5           STR      R0,[R5, #+84]
    563              pObj->ScrollPos   = 0;
   \   000000FC   0010A0E3           MOV      R1,#+0
   \   00000100   581085E5           STR      R1,[R5, #+88]
    564              pObj->DirIndicatorColumn = -1;
   \   00000104   600085E5           STR      R0,[R5, #+96]
    565              pObj->pWidgetSkin = HEADER__pSkinDefault;
   \   00000108   18009AE5           LDR      R0,[R10, #+24]
   \   0000010C   480085E5           STR      R0,[R5, #+72]
    566              GUI_UNLOCK_H(pObj);
   \   00000110   ........           BL       GUI_ALLOC_UnlockH
    567              HEADER__pSkinDefault->pfCreate(hObj);
   \   00000114   18109AE5           LDR      R1,[R10, #+24]
   \   00000118   0400A0E1           MOV      R0,R4
   \   0000011C   041091E5           LDR      R1,[R1, #+4]
   \   00000120   31FF2FE1           BLX      R1
    568            } else {
    569              GUI_DEBUG_ERROROUT_IF(hObj==0, "HEADER_Create failed")
    570            }
    571            WM_UNLOCK();
   \                     ??HEADER_CreateEx_2:
   \   00000124   ........           BL       GUI_Unlock
    572            return hObj;
   \   00000128   0400A0E1           MOV      R0,R4
   \   0000012C   14D08DE2           ADD      SP,SP,#+20
   \   00000130   F08FBDE8           POP      {R4-R11,PC}      ;; return
    573          }
    574          
    575          /*********************************************************************
    576          *
    577          *       Exported routines: Global functions
    578          *
    579          **********************************************************************
    580          */
    581          /*********************************************************************
    582          *
    583          *       Exported routines: Member functions
    584          *
    585          **********************************************************************
    586          */
    587          /*********************************************************************
    588          *
    589          *       HEADER_SetFont
    590          */

   \                                 In section .text, align 4, keep-with-next
    591          void HEADER_SetFont(HEADER_Handle hObj, const GUI_FONT GUI_UNI_PTR * pFont) {
   \                     HEADER_SetFont:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   08D04DE2           SUB      SP,SP,#+8
   \   0000000C   0150A0E1           MOV      R5,R1
    592            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   1A00000A           BEQ      ??HEADER_SetFont_0
    593              HEADER_Obj * pObj;
    594              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
    595              pObj = HEADER_LOCK_H(hObj);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
   \   00000024   0060A0E1           MOV      R6,R0
    596              pObj->Props.pFont = pFont;
   \   00000028   345086E5           STR      R5,[R6, #+52]
    597              HEADER_SetHeight(hObj, GUI_GetYDistOfFont(pFont) + 2 * HEADER_BORDER_V_DEFAULT + 2 * pObj->Widget.pEffect->EffectSize);
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   ........           BL       GUI_GetYDistOfFont
   \   00000034   2C1096E5           LDR      R1,[R6, #+44]
   \   00000038   001091E5           LDR      R1,[R1, #+0]
   \   0000003C   815080E0           ADD      R5,R0,R1, LSL #+1
   \   00000040   0D10A0E1           MOV      R1,SP
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       WM_GetClientRectEx
   \   0000004C   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000050   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000054   0520A0E1           MOV      R2,R5
   \   00000058   010040E0           SUB      R0,R0,R1
   \   0000005C   011080E2           ADD      R1,R0,#+1
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       WM_SetSize
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   ........           BL       WM_GetParent
   \   00000070   ........           BL       WM_InvalidateWindow
    598              WM_InvalidateWindow(hObj);
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   ........           BL       WM_InvalidateWindow
    599              GUI_UNLOCK_H(pObj);
   \   0000007C   ........           BL       GUI_ALLOC_UnlockH
    600              WM_UNLOCK();
   \   00000080   ........           BL       GUI_Unlock
    601            }
    602          }
   \                     ??HEADER_SetFont_0:
   \   00000084   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000088   7080BDE8           POP      {R4-R6,PC}       ;; return
    603          
    604          /*********************************************************************
    605          *
    606          *       HEADER_SetHeight
    607          */

   \                                 In section .text, align 4, keep-with-next
    608          void HEADER_SetHeight(HEADER_Handle hObj, int Height) {
   \                     HEADER_SetHeight:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   0150A0E1           MOV      R5,R1
    609            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0B00000A           BEQ      ??HEADER_SetHeight_0
    610              GUI_RECT Rect;
    611              WM_GetClientRectEx(hObj, &Rect);
   \   00000018   0D10A0E1           MOV      R1,SP
   \   0000001C   ........           BL       WM_GetClientRectEx
    612              WM_SetSize(hObj, Rect.x1 - Rect.x0 + 1, Height);
   \   00000020   F400DDE1           LDRSH    R0,[SP, #+4]
   \   00000024   F010DDE1           LDRSH    R1,[SP, #+0]
   \   00000028   0520A0E1           MOV      R2,R5
   \   0000002C   010040E0           SUB      R0,R0,R1
   \   00000030   011080E2           ADD      R1,R0,#+1
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       WM_SetSize
    613              WM_InvalidateWindow(WM_GetParent(hObj));
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       WM_GetParent
   \   00000044   ........           BL       WM_InvalidateWindow
    614            }
    615          }
   \                     ??HEADER_SetHeight_0:
   \   00000048   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   0000004C   3080BDE8           POP      {R4,R5,PC}       ;; return
    616          
    617          /*********************************************************************
    618          *
    619          *       HEADER_SetTextAlign
    620          */

   \                                 In section .text, align 4, keep-with-next
    621          void HEADER_SetTextAlign(HEADER_Handle hObj, unsigned int Index, int Align) {
   \                     HEADER_SetTextAlign:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
    622            if (hObj) {
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   1000000A           BEQ      ??HEADER_SetTextAlign_0
    623              HEADER_Obj * pObj;
    624              WM_LOCK();
   \   0000001C   ........           BL       GUI_Lock
    625              pObj = HEADER_LOCK_H(hObj);
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       GUI_ALLOC_LockH
   \   00000028   0070A0E1           MOV      R7,R0
    626              if (Index <= GUI_ARRAY_GetNumItems(pObj->Columns)) {
   \   0000002C   4C0097E5           LDR      R0,[R7, #+76]
   \   00000030   ........           BL       GUI_ARRAY_GetNumItems
   \   00000034   050050E1           CMP      R0,R5
   \   00000038   0600003A           BCC      ??HEADER_SetTextAlign_1
    627                HEADER_COLUMN * pColumn;
    628                pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItemLocked(pObj->Columns, Index);
    629                pColumn->Align = Align;
   \   0000003C   0510A0E1           MOV      R1,R5
   \   00000040   4C0097E5           LDR      R0,[R7, #+76]
   \   00000044   ........           BL       GUI_ARRAY_GetpItemLocked
   \   00000048   B460C0E1           STRH     R6,[R0, #+4]
    630                GUI_UNLOCK_H(pColumn);
   \   0000004C   ........           BL       GUI_ALLOC_UnlockH
    631                WM_InvalidateWindow(hObj);
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           BL       WM_InvalidateWindow
    632              }
    633              GUI_UNLOCK_H(pObj);
   \                     ??HEADER_SetTextAlign_1:
   \   00000058   ........           BL       GUI_ALLOC_UnlockH
    634              WM_UNLOCK();
   \   0000005C   ........           BL       GUI_Unlock
    635            }
    636          }
   \                     ??HEADER_SetTextAlign_0:
   \   00000060   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000064   F080BDE8           POP      {R4-R7,PC}       ;; return
    637          
    638          /*********************************************************************
    639          *
    640          *       HEADER_SetScrollPos
    641          */

   \                                 In section .text, align 4, keep-with-next
    642          void HEADER_SetScrollPos(HEADER_Handle hObj, int ScrollPos) {
   \                     HEADER_SetScrollPos:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
    643            if (hObj && (ScrollPos >= 0)) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0F00000A           BEQ      ??HEADER_SetScrollPos_0
   \   00000018   000055E3           CMP      R5,#+0
   \   0000001C   0D00004A           BMI      ??HEADER_SetScrollPos_0
    644              HEADER_Obj* pObj;
    645              WM_LOCK();
   \   00000020   ........           BL       GUI_Lock
    646              pObj = HEADER_LOCK_H(hObj);
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       GUI_ALLOC_LockH
    647              if (ScrollPos != pObj->ScrollPos) {
   \   0000002C   581090E5           LDR      R1,[R0, #+88]
   \   00000030   010055E1           CMP      R5,R1
   \   00000034   0500000A           BEQ      ??HEADER_SetScrollPos_1
    648                pObj->ScrollPos = ScrollPos;
   \   00000038   585080E5           STR      R5,[R0, #+88]
    649                WM_Invalidate(hObj);
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       WM_InvalidateWindow
    650                WM_InvalidateWindow(WM_GetParent(hObj));
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       WM_GetParent
   \   0000004C   ........           BL       WM_InvalidateWindow
    651              }
    652              GUI_UNLOCK_H(pObj);
   \                     ??HEADER_SetScrollPos_1:
   \   00000050   ........           BL       GUI_ALLOC_UnlockH
    653              WM_UNLOCK();
   \   00000054   ........           BL       GUI_Unlock
    654            }
    655          }
   \                     ??HEADER_SetScrollPos_0:
   \   00000058   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000005C   3080BDE8           POP      {R4,R5,PC}       ;; return
    656          
    657          /*********************************************************************
    658          *
    659          *       HEADER_AddItem
    660          */

   \                                 In section .text, align 4, keep-with-next
    661          void HEADER_AddItem(HEADER_Handle hObj, int Width, const char * s, int Align) {
   \                     HEADER_AddItem:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   14D04DE2           SUB      SP,SP,#+20
   \   0000000C   0180A0E1           MOV      R8,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   0390A0E1           MOV      R9,R3
    662            if (hObj) {
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   3B00000A           BEQ      ??HEADER_AddItem_0
    663              HEADER_Obj * pObj;
    664              HEADER_COLUMN Column;
    665              GUI_ARRAY Columns;
    666              int Index;
    667              int Len;
    668          
    669              WM_LOCK();
   \   00000020   ........           BL       GUI_Lock
    670              pObj = HEADER_LOCK_H(hObj);
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       GUI_ALLOC_LockH
   \   0000002C   00A0A0E1           MOV      R10,R0
    671              Columns = pObj->Columns;
   \   00000030   4C709AE5           LDR      R7,[R10, #+76]
    672              Len = s ? strlen(s) : 0;
   \   00000034   000055E3           CMP      R5,#+0
   \   00000038   0300000A           BEQ      ??HEADER_AddItem_1
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   ........           BL       strlen
   \   00000044   0060A0E1           MOV      R6,R0
   \   00000048   000000EA           B        ??HEADER_AddItem_2
   \                     ??HEADER_AddItem_1:
   \   0000004C   0060A0E3           MOV      R6,#+0
    673              if (Width || Len) {
   \                     ??HEADER_AddItem_2:
   \   00000050   080096E1           ORRS     R0,R6,R8
   \   00000054   2C00000A           BEQ      ??HEADER_AddItem_3
    674                if (!Width) {
   \   00000058   000058E3           CMP      R8,#+0
   \   0000005C   0C00001A           BNE      ??HEADER_AddItem_4
    675                  const GUI_FONT GUI_UNI_PTR * pFont;
    676                  pFont = GUI_SetFont(pObj->Props.pFont);
   \   00000060   34009AE5           LDR      R0,[R10, #+52]
   \   00000064   ........           BL       GUI_SetFont
   \   00000068   00B0A0E1           MOV      R11,R0
    677                  Width = GUI_GetStringDistX(s) + 2 * (pObj->Widget.pEffect->EffectSize + HEADER__DefaultBorderH);
   \   0000006C   0500A0E1           MOV      R0,R5
   \   00000070   ........           BL       GUI_GetStringDistX
   \   00000074   2C109AE5           LDR      R1,[R10, #+44]
   \   00000078   ........           LDR      R2,??DataTable3_4
   \   0000007C   001091E5           LDR      R1,[R1, #+0]
   \   00000080   002092E5           LDR      R2,[R2, #+0]
   \   00000084   011082E0           ADD      R1,R2,R1
   \   00000088   818080E0           ADD      R8,R0,R1, LSL #+1
    678                  GUI_SetFont(pFont);
   \   0000008C   0B00A0E1           MOV      R0,R11
   \   00000090   ........           BL       GUI_SetFont
    679                }
    680                Column.Width    = Width;
   \                     ??HEADER_AddItem_4:
   \   00000094   00808DE5           STR      R8,[SP, #+0]
    681                Column.Align    = Align;
    682                Column.hDrawObj = 0;
   \   00000098   0080A0E3           MOV      R8,#+0
   \   0000009C   B490CDE1           STRH     R9,[SP, #+4]
   \   000000A0   08808DE5           STR      R8,[SP, #+8]
    683                GUI_UNLOCK_H(pObj);
   \   000000A4   ........           BL       GUI_ALLOC_UnlockH
    684                Index = GUI_ARRAY_GetNumItems(Columns);
   \   000000A8   0700A0E1           MOV      R0,R7
   \   000000AC   ........           BL       GUI_ARRAY_GetNumItems
   \   000000B0   0090A0E1           MOV      R9,R0
    685                if (GUI_ARRAY_AddItem(Columns, &Column, sizeof(HEADER_COLUMN) + Len + 1) == 0) {
   \   000000B4   112086E2           ADD      R2,R6,#+17
   \   000000B8   0D10A0E1           MOV      R1,SP
   \   000000BC   0700A0E1           MOV      R0,R7
   \   000000C0   ........           BL       GUI_ARRAY_AddItem
   \   000000C4   000050E3           CMP      R0,#+0
   \   000000C8   0F00001A           BNE      ??HEADER_AddItem_3
    686                  HEADER_COLUMN * pColumn;
    687                  pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItemLocked(Columns, Index);
   \   000000CC   0910A0E1           MOV      R1,R9
   \   000000D0   0700A0E1           MOV      R0,R7
   \   000000D4   ........           BL       GUI_ARRAY_GetpItemLocked
    688                  if (Len) {
   \   000000D8   000056E3           CMP      R6,#+0
   \   000000DC   0300000A           BEQ      ??HEADER_AddItem_5
    689                    strcpy(pColumn->acText, s);
   \   000000E0   0510A0E1           MOV      R1,R5
   \   000000E4   0C0080E2           ADD      R0,R0,#+12
   \   000000E8   ........           BL       strcpy
   \   000000EC   000000EA           B        ??HEADER_AddItem_6
    690                  } else {
    691                    pColumn->acText[0] = 0;
   \                     ??HEADER_AddItem_5:
   \   000000F0   0C80C0E5           STRB     R8,[R0, #+12]
    692                  }
    693                  GUI_UNLOCK_H(pColumn);
   \                     ??HEADER_AddItem_6:
   \   000000F4   ........           BL       GUI_ALLOC_UnlockH
    694                  WM_InvalidateWindow(hObj);
   \   000000F8   0400A0E1           MOV      R0,R4
   \   000000FC   ........           BL       WM_InvalidateWindow
    695                  WM_InvalidateWindow(WM_GetParent(hObj));
   \   00000100   0400A0E1           MOV      R0,R4
   \   00000104   ........           BL       WM_GetParent
   \   00000108   ........           BL       WM_InvalidateWindow
    696                }
    697              }
    698              WM_UNLOCK();
   \                     ??HEADER_AddItem_3:
   \   0000010C   ........           BL       GUI_Unlock
    699            }
    700          }
   \                     ??HEADER_AddItem_0:
   \   00000110   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000114   F08FBDE8           POP      {R4-R11,PC}      ;; return
    701          
    702          /*********************************************************************
    703          *
    704          *       HEADER_DeleteItem
    705          */

   \                                 In section .text, align 4, keep-with-next
    706          void HEADER_DeleteItem(HEADER_Handle hObj, unsigned Index) {
   \                     HEADER_DeleteItem:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    707            if (hObj) {
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   1100000A           BEQ      ??HEADER_DeleteItem_0
    708              HEADER_Obj* pObj;
    709              WM_LOCK();
   \   00000014   ........           BL       GUI_Lock
    710              pObj = HEADER_LOCK_H(hObj);
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           BL       GUI_ALLOC_LockH
   \   00000020   0060A0E1           MOV      R6,R0
    711              if (Index < GUI_ARRAY_GetNumItems(pObj->Columns)) {
   \   00000024   4C0096E5           LDR      R0,[R6, #+76]
   \   00000028   ........           BL       GUI_ARRAY_GetNumItems
   \   0000002C   000055E1           CMP      R5,R0
   \   00000030   0700002A           BCS      ??HEADER_DeleteItem_1
    712                GUI_ARRAY_DeleteItem(pObj->Columns, Index);
   \   00000034   0510A0E1           MOV      R1,R5
   \   00000038   4C0096E5           LDR      R0,[R6, #+76]
   \   0000003C   ........           BL       GUI_ARRAY_DeleteItem
    713                WM_InvalidateWindow(hObj);
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   ........           BL       WM_InvalidateWindow
    714                WM_InvalidateWindow(WM_GetParent(hObj));
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   ........           BL       WM_GetParent
   \   00000050   ........           BL       WM_InvalidateWindow
    715              }
    716              GUI_UNLOCK_H(pObj);
   \                     ??HEADER_DeleteItem_1:
   \   00000054   ........           BL       GUI_ALLOC_UnlockH
    717              WM_UNLOCK();
   \   00000058   ........           BL       GUI_Unlock
    718            }
    719          }
   \                     ??HEADER_DeleteItem_0:
   \   0000005C   7080BDE8           POP      {R4-R6,PC}       ;; return
    720          
    721          /*********************************************************************
    722          *
    723          *       HEADER_SetItemText
    724          */

   \                                 In section .text, align 4, keep-with-next
    725          void HEADER_SetItemText(HEADER_Handle hObj, unsigned int Index, const char* s) {
   \                     HEADER_SetItemText:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
    726            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   1500000A           BEQ      ??HEADER_SetItemText_0
    727              GUI_ARRAY Columns;
    728              HEADER_Obj * pObj;
    729              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
    730              pObj = HEADER_LOCK_H(hObj);
    731              Columns = pObj->Columns;
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
   \   00000024   4C4090E5           LDR      R4,[R0, #+76]
    732              GUI_UNLOCK_H(pObj);
   \   00000028   ........           BL       GUI_ALLOC_UnlockH
    733              if (Index < GUI_ARRAY_GetNumItems(Columns)) {
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       GUI_ARRAY_GetNumItems
   \   00000034   000055E1           CMP      R5,R0
   \   00000038   0B00002A           BCS      ??HEADER_SetItemText_1
    734                HEADER_COLUMN * pColumn;
    735                pColumn = (HEADER_COLUMN *)GUI_ARRAY_ResizeItemLocked(Columns, Index, sizeof(HEADER_COLUMN) + strlen(s));
   \   0000003C   0600A0E1           MOV      R0,R6
   \   00000040   ........           BL       strlen
   \   00000044   102080E2           ADD      R2,R0,#+16
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       GUI_ARRAY_ResizeItemLocked
    736                if (pColumn) {
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0300000A           BEQ      ??HEADER_SetItemText_1
    737                  strcpy(pColumn->acText, s);
   \   0000005C   0610A0E1           MOV      R1,R6
   \   00000060   0C0080E2           ADD      R0,R0,#+12
   \   00000064   ........           BL       strcpy
    738                  GUI_UNLOCK_H(pColumn);
   \   00000068   ........           BL       GUI_ALLOC_UnlockH
    739                }
    740              }
    741              WM_UNLOCK();
   \                     ??HEADER_SetItemText_1:
   \   0000006C   ........           BL       GUI_Unlock
    742            }
    743          }
   \                     ??HEADER_SetItemText_0:
   \   00000070   7080BDE8           POP      {R4-R6,PC}       ;; return
    744          
    745          /*********************************************************************
    746          *
    747          *       HEADER_SetItemWidth
    748          */

   \                                 In section .text, align 4, keep-with-next
    749          void HEADER_SetItemWidth(HEADER_Handle hObj, unsigned int Index, int Width) {
   \                     HEADER_SetItemWidth:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   14D04DE2           SUB      SP,SP,#+20
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
    750            if (hObj && (Width >= 0)) {
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   2200000A           BEQ      ??HEADER_SetItemWidth_0
   \   0000001C   000056E3           CMP      R6,#+0
   \   00000020   2000004A           BMI      ??HEADER_SetItemWidth_0
    751              GUI_ARRAY Columns;
    752              HEADER_Obj * pObj;
    753              WM_LOCK();
   \   00000024   ........           BL       GUI_Lock
    754              pObj = HEADER_LOCK_H(hObj);
    755              Columns = pObj->Columns;
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       GUI_ALLOC_LockH
   \   00000030   4C7090E5           LDR      R7,[R0, #+76]
    756              GUI_UNLOCK_H(pObj);
   \   00000034   ........           BL       GUI_ALLOC_UnlockH
    757              if (Index <= GUI_ARRAY_GetNumItems(Columns)) {
   \   00000038   0700A0E1           MOV      R0,R7
   \   0000003C   ........           BL       GUI_ARRAY_GetNumItems
   \   00000040   050050E1           CMP      R0,R5
   \   00000044   1600003A           BCC      ??HEADER_SetItemWidth_1
    758                HEADER_COLUMN * pColumn;
    759                pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItemLocked(Columns, Index);
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0700A0E1           MOV      R0,R7
   \   00000050   ........           BL       GUI_ARRAY_GetpItemLocked
    760                if (pColumn) {
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   1000000A           BEQ      ??HEADER_SetItemWidth_2
    761                  WM_MESSAGE Msg;
    762                  pColumn->Width = Width;
   \   0000005C   006080E5           STR      R6,[R0, #+0]
    763                  GUI_UNLOCK_H(pColumn);
   \   00000060   ........           BL       GUI_ALLOC_UnlockH
    764                  Msg.hWin  = WM_GetParent(hObj);
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           BL       WM_GetParent
   \   0000006C   04008DE5           STR      R0,[SP, #+4]
    765                  Msg.MsgId = WM_NOTIFY_CLIENTCHANGE;
   \   00000070   2510A0E3           MOV      R1,#+37
   \   00000074   00108DE5           STR      R1,[SP, #+0]
    766                  Msg.hWinSrc = hObj;
   \   00000078   08408DE5           STR      R4,[SP, #+8]
    767                  WM_InvalidateWindow(hObj);
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   ........           BL       WM_InvalidateWindow
    768                  WM__SendMessage(Msg.hWin, &Msg);
   \   00000084   0D10A0E1           MOV      R1,SP
   \   00000088   04009DE5           LDR      R0,[SP, #+4]
   \   0000008C   ........           BL       WM__SendMessage
    769                  WM_InvalidateWindow(WM_GetParent(hObj));
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   ........           BL       WM_GetParent
   \   00000098   ........           BL       WM_InvalidateWindow
   \   0000009C   000000EA           B        ??HEADER_SetItemWidth_1
    770                } else {
    771                  GUI_UNLOCK_H(pColumn);
   \                     ??HEADER_SetItemWidth_2:
   \   000000A0   ........           BL       GUI_ALLOC_UnlockH
    772                }
    773              }
    774              WM_UNLOCK();
   \                     ??HEADER_SetItemWidth_1:
   \   000000A4   ........           BL       GUI_Unlock
    775            }
    776          }
   \                     ??HEADER_SetItemWidth_0:
   \   000000A8   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000000AC   F080BDE8           POP      {R4-R7,PC}       ;; return
    777          
    778          /*********************************************************************
    779          *
    780          *       HEADER_GetHeight
    781          */

   \                                 In section .text, align 4, keep-with-next
    782          int HEADER_GetHeight(HEADER_Handle hObj) {
   \                     HEADER_GetHeight:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
    783            int Height = 0;
   \   00000008   0010A0E3           MOV      R1,#+0
    784            if (hObj) {
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0B00000A           BEQ      ??HEADER_GetHeight_0
    785              GUI_RECT Rect;
    786              WM_GetClientRectEx(hObj, &Rect);
   \   00000014   0D10A0E1           MOV      R1,SP
   \   00000018   ........           BL       WM_GetClientRectEx
    787              GUI_MoveRect(&Rect, -Rect.x0, -Rect.y0);
   \   0000001C   F200DDE1           LDRSH    R0,[SP, #+2]
   \   00000020   002060E2           RSB      R2,R0,#+0
   \   00000024   F000DDE1           LDRSH    R0,[SP, #+0]
   \   00000028   001060E2           RSB      R1,R0,#+0
   \   0000002C   0D00A0E1           MOV      R0,SP
   \   00000030   ........           BL       GUI_MoveRect
    788              Height = Rect.y1 - Rect.y0 + 1;
   \   00000034   F600DDE1           LDRSH    R0,[SP, #+6]
   \   00000038   F210DDE1           LDRSH    R1,[SP, #+2]
   \   0000003C   010040E0           SUB      R0,R0,R1
   \   00000040   011080E2           ADD      R1,R0,#+1
    789            }
    790            return Height;
   \                     ??HEADER_GetHeight_0:
   \   00000044   0100A0E1           MOV      R0,R1
   \   00000048   0CD08DE2           ADD      SP,SP,#+12
   \   0000004C   0080BDE8           POP      {PC}             ;; return
    791          }
    792          
    793          /*********************************************************************
    794          *
    795          *       HEADER_GetItemWidth
    796          */

   \                                 In section .text, align 4, keep-with-next
    797          int HEADER_GetItemWidth(HEADER_Handle hObj, unsigned int Index) {
   \                     HEADER_GetItemWidth:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    798            int Width = 0;
   \   0000000C   0060A0E3           MOV      R6,#+0
    799            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0E00000A           BEQ      ??HEADER_GetItemWidth_0
    800              HEADER_Obj * pObj;
    801              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
    802              pObj = HEADER_LOCK_H(hObj);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
   \   00000024   0040A0E1           MOV      R4,R0
    803              if (Index <= GUI_ARRAY_GetNumItems(pObj->Columns)) {
   \   00000028   4C0094E5           LDR      R0,[R4, #+76]
   \   0000002C   ........           BL       GUI_ARRAY_GetNumItems
   \   00000030   050050E1           CMP      R0,R5
   \   00000034   0400003A           BCC      ??HEADER_GetItemWidth_1
    804                HEADER_COLUMN * pColumn;
    805                pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItemLocked(pObj->Columns, Index);
    806                Width = pColumn->Width;
   \   00000038   0510A0E1           MOV      R1,R5
   \   0000003C   4C0094E5           LDR      R0,[R4, #+76]
   \   00000040   ........           BL       GUI_ARRAY_GetpItemLocked
   \   00000044   006090E5           LDR      R6,[R0, #+0]
    807                GUI_UNLOCK_H(pColumn);
   \   00000048   ........           BL       GUI_ALLOC_UnlockH
    808              }
    809              GUI_UNLOCK_H(pObj);
   \                     ??HEADER_GetItemWidth_1:
   \   0000004C   ........           BL       GUI_ALLOC_UnlockH
    810              WM_UNLOCK();
   \   00000050   ........           BL       GUI_Unlock
    811            }
    812            return Width;
   \                     ??HEADER_GetItemWidth_0:
   \   00000054   0600A0E1           MOV      R0,R6
   \   00000058   7080BDE8           POP      {R4-R6,PC}       ;; return
    813          }
    814          
    815          /*********************************************************************
    816          *
    817          *       HEADER_GetNumItems
    818          */

   \                                 In section .text, align 4, keep-with-next
    819          int  HEADER_GetNumItems(HEADER_Handle hObj) {
   \                     HEADER_GetNumItems:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
    820            int NumCols = 0;
   \   0000000C   0050A0E3           MOV      R5,#+0
    821            if (hObj) {
   \   00000010   0700000A           BEQ      ??HEADER_GetNumItems_0
    822              HEADER_Obj * pObj;
    823              WM_LOCK();
   \   00000014   ........           BL       GUI_Lock
    824              pObj = HEADER_LOCK_H(hObj);
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           BL       GUI_ALLOC_LockH
    825              NumCols = GUI_ARRAY_GetNumItems(pObj->Columns);
   \   00000020   4C0090E5           LDR      R0,[R0, #+76]
   \   00000024   ........           BL       GUI_ARRAY_GetNumItems
   \   00000028   0050A0E1           MOV      R5,R0
    826              GUI_UNLOCK_H(pObj);
   \   0000002C   ........           BL       GUI_ALLOC_UnlockH
    827              WM_UNLOCK();
   \   00000030   ........           BL       GUI_Unlock
    828            }
    829            return NumCols;
   \                     ??HEADER_GetNumItems_0:
   \   00000034   0500A0E1           MOV      R0,R5
   \   00000038   04D08DE2           ADD      SP,SP,#+4
   \   0000003C   3080BDE8           POP      {R4,R5,PC}       ;; return
    830          }
    831          
    832          /*********************************************************************
    833          *
    834          *       HEADER_SetDirIndicator
    835          */

   \                                 In section .text, align 4, keep-with-next
    836          void HEADER_SetDirIndicator(HEADER_Handle hObj, int Column, int Reverse) {
   \                     HEADER_SetDirIndicator:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
    837            if (hObj) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0D00000A           BEQ      ??HEADER_SetDirIndicator_0
    838              HEADER_Obj * pObj;
    839              WM_LOCK();
   \   00000018   ........           BL       GUI_Lock
    840              pObj = HEADER_LOCK_H(hObj);
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       GUI_ALLOC_LockH
    841              if ((pObj->DirIndicatorColumn != Column) || (pObj->DirIndicatorReverse != Reverse)) {
   \   00000024   601090E5           LDR      R1,[R0, #+96]
   \   00000028   050051E1           CMP      R1,R5
   \   0000002C   64109005           LDREQ    R1,[R0, #+100]
   \   00000030   06005101           CMPEQ    R1,R6
   \   00000034   0300000A           BEQ      ??HEADER_SetDirIndicator_1
    842                pObj->DirIndicatorColumn = Column;
   \   00000038   605080E5           STR      R5,[R0, #+96]
    843                pObj->DirIndicatorReverse = Reverse;
   \   0000003C   646080E5           STR      R6,[R0, #+100]
    844                WM_InvalidateWindow(hObj);
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   ........           BL       WM_InvalidateWindow
    845              }
    846              GUI_UNLOCK_H(pObj);
   \                     ??HEADER_SetDirIndicator_1:
   \   00000048   ........           BL       GUI_ALLOC_UnlockH
    847              WM_UNLOCK();
   \   0000004C   ........           BL       GUI_Unlock
    848            }
    849          }
   \                     ??HEADER_SetDirIndicator_0:
   \   00000050   7080BDE8           POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     _pOldCursor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   ........           DC32     WM__TouchedLayer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   ........           DC32     HEADER__DefaultProps

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   ........           DC32     HEADER_Callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   ........           DC32     HEADER__DefaultBorderH
    850          
    851          #else /* avoid empty object files */
    852          
    853          void HEADER_C(void);
    854          void HEADER_C(void){}
    855          
    856          #endif  /* #if GUI_WINSUPPORT */

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     HEADER_AddItem             56
     HEADER_Callback            24
     HEADER_Create              32
     HEADER_CreateEx            56
     HEADER_DeleteItem          16
     HEADER_GetHeight           16
     HEADER_GetItemWidth        16
     HEADER_GetNumItems         16
     HEADER_SetDirIndicator     16
     HEADER_SetFont             24
     HEADER_SetHeight           24
     HEADER_SetItemText         16
     HEADER_SetItemWidth        40
     HEADER_SetScrollPos        16
     HEADER_SetTextAlign        24
     _GetDividerIndex           40
     _GetItemIndex              40
     _HandlePID                 56
     _LimitDragWitdh            64


   Section sizes:

     Function/Label         Bytes
     --------------         -----
     HEADER__DefaultProps     28
     HEADER__DefaultBorderV
     HEADER__pSkinDefault
     _pOldCursor               8
     HEADER__pDefaultCursor
     HEADER__DefaultBorderH    4
     _GetDividerIndex        256
     _LimitDragWitdh         484
     _HandlePID              576
     _GetItemIndex           220
     HEADER_Callback         516
     HEADER_Create            52
     HEADER_CreateEx         308
     HEADER_SetFont          140
     HEADER_SetHeight         80
     HEADER_SetTextAlign     104
     HEADER_SetScrollPos      96
     HEADER_AddItem          280
     HEADER_DeleteItem        96
     HEADER_SetItemText      116
     HEADER_SetItemWidth     176
     HEADER_GetHeight         80
     HEADER_GetItemWidth      92
     HEADER_GetNumItems       64
     HEADER_SetDirIndicator   84
     ??DataTable3              4
     ??DataTable3_1            4
     ??DataTable3_2            4
     ??DataTable3_3            4
     ??DataTable3_4            4

 
    40 bytes in section .data
 3 840 bytes in section .text
 
 3 840 bytes of CODE memory
    40 bytes of DATA memory

Errors: none
Warnings: none
