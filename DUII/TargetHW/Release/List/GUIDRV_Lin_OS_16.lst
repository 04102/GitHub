###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:15:33 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_OS_16.c                  #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_OS_16.c -D DEBUG=1 -D    #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUIDRV_Lin_OS_16.lst       #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUIDRV_Lin_OS_16.o          #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDRV_Lin_OS_16.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDRV_Lin_OS_16.c
     19          Purpose     : Driver for accessing linear video memory
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stddef.h>
     24          #include <string.h>
     25          
     26          #include "LCD_Private.h"
     27          #include "GUI_Private.h"
     28          #include "LCD_SIM.h"
     29          #include "LCD_ConfDefaults.h"
     30          
     31          #include "GUIDRV_Lin.h"
     32          
     33          #if (!defined(WIN32) | defined(LCD_SIMCONTROLLER))
     34          
     35          /*********************************************************************
     36          *
     37          *       Defines
     38          *
     39          **********************************************************************
     40          */
     41          #ifdef WIN32
     42            //
     43            // Simulation prototypes
     44            //
     45            U16  SIM_Lin_ReadMem16  (unsigned int Off);
     46            U32  SIM_Lin_ReadMem32  (unsigned int Off);
     47            U32  SIM_Lin_ReadMem32p (U32 * p);
     48            void SIM_Lin_WriteMem16 (unsigned int Off, U16 Data);
     49            void SIM_Lin_WriteMem32 (unsigned int Off, U32 Data);
     50            void SIM_Lin_WriteMem16p(U16 * p, U16 Data);
     51            void SIM_Lin_WriteMem32p(U32 * p, U32 Data);
     52            void SIM_Lin_memcpy     (void * pDst, const void * pSrc, int Len);
     53            void SIM_Lin_SetVRAMAddr(int LayerIndex, void * pVRAM);
     54            void SIM_Lin_SetVRAMSize(int LayerIndex, int xSize, int ySize);
     55            //
     56            // Access macro definition for internal simulation
     57            //
     58            #define LCD_READ_MEM16(VRAMAddr, Off)        SIM_Lin_ReadMem16(Off)
     59            #define LCD_READ_MEM32(VRAMAddr, Off)        SIM_Lin_ReadMem32(Off)
     60            #define LCD_READ_MEM32P(p)                   SIM_Lin_ReadMem32p(p)
     61            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) SIM_Lin_WriteMem16(Off, Data)
     62            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) SIM_Lin_WriteMem32(Off, Data)
     63            #define LCD_WRITE_MEM16P(p, Data)            SIM_Lin_WriteMem16p(p, Data)
     64            #define LCD_WRITE_MEM32P(p, Data)            SIM_Lin_WriteMem32p(p, Data)
     65            #undef  GUI_MEMCPY
     66            #define GUI_MEMCPY(pDst, pSrc, Len) SIM_Lin_memcpy(pDst, pSrc, Len)
     67          #else
     68            //
     69            // Access macro definition for hardware
     70            //
     71            #define LCD_READ_MEM16(VRAMAddr, Off)        (*((U16 *)VRAMAddr + (U32)Off))
     72            #define LCD_READ_MEM32(VRAMAddr, Off)        (*((U32 *)VRAMAddr + (U32)Off))
     73            #define LCD_READ_MEM32P(p)                   (*((U32 *)p))
     74            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) *((U16 *)VRAMAddr + (U32)Off) = Data
     75            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) *((U32 *)VRAMAddr + (U32)Off) = Data
     76            #define LCD_WRITE_MEM16P(p, Data)            *((U16 *)p) = Data
     77            #define LCD_WRITE_MEM32P(p, Data)            *((U32 *)p) = Data
     78          #endif
     79          
     80          #define WRITE_MEM16(VRAMAddr, Off, Data) LCD_WRITE_MEM16(VRAMAddr, Off, Data)
     81          #define WRITE_MEM32(VRAMAddr, Off, Data) LCD_WRITE_MEM32(VRAMAddr, Off, Data)
     82          #define READ_MEM16(VRAMAddr, Off)        LCD_READ_MEM16(VRAMAddr, Off)
     83          #define READ_MEM32(VRAMAddr, Off)        LCD_READ_MEM32(VRAMAddr, Off)
     84          #define READ_MEM32P(p)                   LCD_READ_MEM32P(p)
     85          #define WRITE_MEM16P(p, Data)            LCD_WRITE_MEM16P(p, Data)
     86          #define WRITE_MEM32P(p, Data)            LCD_WRITE_MEM32P(p, Data)
     87          
     88          #define OFF2PTR16(VRAMAddr, Off)     (U16 *)((U8 *)VRAMAddr + (Off << 1))
     89          #define OFF2PTR32(VRAMAddr, Off)     (U32 *)((U8 *)VRAMAddr + (Off << 2))
     90          
     91          #define XY2OFF16(vxSizePhys, x, y)    ((U32)y *  vxSizePhys       +       x      )
     92          #define XY2OFF32(vxSizePhys, x, y)    ((U32)y * (vxSizePhys >> 1) + ((U32)x >> 1))
     93          
     94          #define LOG2PHYS_X(vxSize, vySize, x, y) y
     95          #define LOG2PHYS_Y(vxSize, vySize, x, y) x
     96          
     97          /*********************************************************************
     98          *
     99          *       Types
    100          *
    101          **********************************************************************
    102          */
    103          typedef struct {
    104            U32 VRAMAddr;
    105            int xSize, ySize;
    106            int vxSize, vySize;
    107            int vxSizePhys;
    108            int xPos, yPos;
    109            int Alpha;
    110            int IsVisible;
    111            void (* pfFillRect)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex);
    112          } DRIVER_CONTEXT;
    113          
    114          /*********************************************************************
    115          *
    116          *       Static functions
    117          *
    118          **********************************************************************
    119          */
    120          /*********************************************************************
    121          *
    122          *       _SetPixelIndex
    123          *
    124          * Purpose:
    125          *   Sets the index of the given pixel. The upper layers
    126          *   calling this routine make sure that the coordinates are in range, so
    127          *   that no check on the parameters needs to be performed.
    128          */

   \                                 In section .text, align 4, keep-with-next
    129          static void _SetPixelIndex(GUI_DEVICE * pDevice, int x, int y, int PixelIndex) {
    130            DRIVER_CONTEXT * pContext;
    131            U32 Off;
    132            int xPhys, yPhys;
    133          
    134            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    135            //
    136            //  Convert logical into physical coordinates
    137            //
    138            xPhys = LOG2PHYS_X(pContext->vxSize, pContext->vySize, x, y);
    139            yPhys = LOG2PHYS_Y(pContext->vxSize, pContext->vySize, x, y);
    140            //
    141            // Write into hardware
    142            //
    143            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _SetPixelIndex:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    144            Off      = XY2OFF16(pContext->vxSizePhys, xPhys, yPhys);
    145            WRITE_MEM16(pContext->VRAMAddr, Off, PixelIndex);
   \   00000004   14C090E5           LDR      R12,[R0, #+20]
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   9C2121E0           MLA      R1,R12,R1,R2
   \   00000010   810080E0           ADD      R0,R0,R1, LSL #+1
   \   00000014   B030C0E1           STRH     R3,[R0, #+0]
    146          }
   \   00000018   1EFF2FE1           BX       LR               ;; return
    147          
    148          /*********************************************************************
    149          *
    150          *       _GetPixelIndex
    151          *
    152          * Purpose:
    153          *   Returns the index of the given pixel. The upper layers
    154          *   calling this routine make sure that the coordinates are in range, so
    155          *   that no check on the parameters needs to be performed.
    156          */

   \                                 In section .text, align 4, keep-with-next
    157          static unsigned int _GetPixelIndex(GUI_DEVICE * pDevice, int x, int y) {
    158            DRIVER_CONTEXT * pContext;
    159            U32 Off;
    160            LCD_PIXELINDEX PixelIndex;
    161            int xPhys, yPhys;
    162          
    163            pContext   = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetPixelIndex:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    164            //
    165            //  Convert logical into physical coordinates
    166            //
    167            xPhys = LOG2PHYS_X(pContext->vxSize, pContext->vySize, x, y);
    168            yPhys = LOG2PHYS_Y(pContext->vxSize, pContext->vySize, x, y);
    169            //
    170            // Read from hardware
    171            //
    172            Off        = XY2OFF16(pContext->vxSizePhys, xPhys, yPhys);
    173            PixelIndex = READ_MEM16(pContext->VRAMAddr, Off);
    174            return PixelIndex;
   \   00000004   143090E5           LDR      R3,[R0, #+20]
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   932121E0           MLA      R1,R3,R1,R2
   \   00000010   810080E0           ADD      R0,R0,R1, LSL #+1
   \   00000014   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000018   1EFF2FE1           BX       LR               ;; return
    175          }
    176          
    177          /*********************************************************************
    178          *
    179          *       _XorPixel
    180          */

   \                                 In section .text, align 4, keep-with-next
    181          static void _XorPixel(GUI_DEVICE * pDevice, int x, int y) {
   \                     _XorPixel:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0060A0E1           MOV      R6,R0
    182            LCD_PIXELINDEX PixelIndex;
    183            LCD_PIXELINDEX IndexMask;
    184            
    185            PixelIndex = _GetPixelIndex(pDevice, x, y);
   \   00000008   080096E5           LDR      R0,[R6, #+8]
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   141090E5           LDR      R1,[R0, #+20]
   \   00000014   0250A0E1           MOV      R5,R2
   \   00000018   915422E0           MLA      R2,R1,R4,R5
   \   0000001C   000090E5           LDR      R0,[R0, #+0]
   \   00000020   04D04DE2           SUB      SP,SP,#+4
   \   00000024   820080E0           ADD      R0,R0,R2, LSL #+1
   \   00000028   B070D0E1           LDRH     R7,[R0, #+0]
    186            IndexMask  = pDevice->pColorConvAPI->pfGetIndexMask();
   \   0000002C   100096E5           LDR      R0,[R6, #+16]
   \   00000030   080090E5           LDR      R0,[R0, #+8]
   \   00000034   30FF2FE1           BLX      R0
    187            _SetPixelIndex(pDevice, x, y, PixelIndex ^ IndexMask);
   \   00000038   081096E5           LDR      R1,[R6, #+8]
   \   0000003C   070020E0           EOR      R0,R0,R7
   \   00000040   142091E5           LDR      R2,[R1, #+20]
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   925423E0           MLA      R3,R2,R4,R5
    188          }
   \   0000004C   04D08DE2           ADD      SP,SP,#+4
   \   00000050   831081E0           ADD      R1,R1,R3, LSL #+1
   \   00000054   B000C1E1           STRH     R0,[R1, #+0]
   \   00000058   F080BDE8           POP      {R4-R7,PC}       ;; return
    189          
    190          /*********************************************************************
    191          *
    192          *       _DrawHLine
    193          */

   \                                 In section .text, align 4, keep-with-next
    194          static void _DrawHLine  (GUI_DEVICE * pDevice, int x0, int y,  int x1) {
   \                     _DrawHLine:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    195            LCD_PIXELINDEX ColorIndex;
    196          
    197            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable15
   \   0000000C   0170A0E1           MOV      R7,R1
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0250A0E1           MOV      R5,R2
   \   00000018   0360A0E1           MOV      R6,R3
   \   0000001C   010010E3           TST      R0,#0x1
   \   00000020   1500000A           BEQ      ??_DrawHLine_0
   \   00000024   070056E1           CMP      R6,R7
   \   00000028   210000BA           BLT      ??_DrawHLine_1
    198              for (; x0 <= x1; x0++) {
    199                _XorPixel(pDevice, x0, y);
   \                     ??_DrawHLine_2:
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   141090E5           LDR      R1,[R0, #+20]
   \   00000034   000090E5           LDR      R0,[R0, #+0]
   \   00000038   915722E0           MLA      R2,R1,R7,R5
   \   0000003C   820080E0           ADD      R0,R0,R2, LSL #+1
   \   00000040   B080D0E1           LDRH     R8,[R0, #+0]
   \   00000044   100094E5           LDR      R0,[R4, #+16]
   \   00000048   080090E5           LDR      R0,[R0, #+8]
   \   0000004C   30FF2FE1           BLX      R0
   \   00000050   081094E5           LDR      R1,[R4, #+8]
   \   00000054   080020E0           EOR      R0,R0,R8
   \   00000058   142091E5           LDR      R2,[R1, #+20]
   \   0000005C   001091E5           LDR      R1,[R1, #+0]
   \   00000060   925723E0           MLA      R3,R2,R7,R5
    200              }
   \   00000064   017087E2           ADD      R7,R7,#+1
   \   00000068   831081E0           ADD      R1,R1,R3, LSL #+1
   \   0000006C   B000C1E1           STRH     R0,[R1, #+0]
   \   00000070   070056E1           CMP      R6,R7
   \   00000074   ECFFFFAA           BGE      ??_DrawHLine_2
   \   00000078   F081BDE8           POP      {R4-R8,PC}
    201            } else {
    202              ColorIndex = LCD__GetColorIndex();
   \                     ??_DrawHLine_0:
   \   0000007C   ........           LDR      R0,??DataTable15_1
   \   00000080   070056E1           CMP      R6,R7
   \   00000084   000090E5           LDR      R0,[R0, #+0]
   \   00000088   000090E5           LDR      R0,[R0, #+0]
   \   0000008C   080000BA           BLT      ??_DrawHLine_1
    203              for (; x0 <= x1; x0++) {
    204                _SetPixelIndex(pDevice, x0, y, ColorIndex);
   \                     ??_DrawHLine_3:
   \   00000090   081094E5           LDR      R1,[R4, #+8]
   \   00000094   142091E5           LDR      R2,[R1, #+20]
   \   00000098   001091E5           LDR      R1,[R1, #+0]
   \   0000009C   925723E0           MLA      R3,R2,R7,R5
    205              }
   \   000000A0   017087E2           ADD      R7,R7,#+1
   \   000000A4   831081E0           ADD      R1,R1,R3, LSL #+1
   \   000000A8   B000C1E1           STRH     R0,[R1, #+0]
   \   000000AC   070056E1           CMP      R6,R7
   \   000000B0   F6FFFFAA           BGE      ??_DrawHLine_3
    206            }
    207          }
   \                     ??_DrawHLine_1:
   \   000000B4   F081BDE8           POP      {R4-R8,PC}       ;; return
    208          
    209          /*********************************************************************
    210          *
    211          *       _DrawVLine
    212          */

   \                                 In section .text, align 4, keep-with-next
    213          static void _DrawVLine  (GUI_DEVICE * pDevice, int x, int y0,  int y1) {
   \                     _DrawVLine:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0070A0E1           MOV      R7,R0
    214            DRIVER_CONTEXT * pContext;
    215            U32 Off, RemPixels;
    216            U32 Data, ColorMask;
    217            U32 * pDest;
    218            int x0, x1, y;
    219            LCD_PIXELINDEX ColorIndex;
    220          
    221            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable15
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0250A0E1           MOV      R5,R2
   \   00000018   0360A0E1           MOV      R6,R3
   \   0000001C   010010E3           TST      R0,#0x1
   \   00000020   1500000A           BEQ      ??_DrawVLine_0
   \   00000024   050056E1           CMP      R6,R5
   \   00000028   430000BA           BLT      ??_DrawVLine_1
    222              for (; y0 <= y1; y0++) {
    223                _XorPixel(pDevice, x, y0);
   \                     ??_DrawVLine_2:
   \   0000002C   080097E5           LDR      R0,[R7, #+8]
   \   00000030   141090E5           LDR      R1,[R0, #+20]
   \   00000034   000090E5           LDR      R0,[R0, #+0]
   \   00000038   915422E0           MLA      R2,R1,R4,R5
   \   0000003C   820080E0           ADD      R0,R0,R2, LSL #+1
   \   00000040   B080D0E1           LDRH     R8,[R0, #+0]
   \   00000044   100097E5           LDR      R0,[R7, #+16]
   \   00000048   080090E5           LDR      R0,[R0, #+8]
   \   0000004C   30FF2FE1           BLX      R0
   \   00000050   081097E5           LDR      R1,[R7, #+8]
   \   00000054   080020E0           EOR      R0,R0,R8
   \   00000058   142091E5           LDR      R2,[R1, #+20]
   \   0000005C   001091E5           LDR      R1,[R1, #+0]
   \   00000060   925423E0           MLA      R3,R2,R4,R5
    224              }
   \   00000064   015085E2           ADD      R5,R5,#+1
   \   00000068   831081E0           ADD      R1,R1,R3, LSL #+1
   \   0000006C   B000C1E1           STRH     R0,[R1, #+0]
   \   00000070   050056E1           CMP      R6,R5
   \   00000074   ECFFFFAA           BGE      ??_DrawVLine_2
   \   00000078   F081BDE8           POP      {R4-R8,PC}
    225            } else {
    226              ColorIndex = LCD__GetColorIndex();
    227              pContext  = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     ??_DrawVLine_0:
   \   0000007C   082097E5           LDR      R2,[R7, #+8]
   \   00000080   ........           LDR      R0,??DataTable15_1
    228              x0        = y0;
    229              x1        = y1;
    230              y         = x;
    231              Off       = XY2OFF32(pContext->vxSizePhys, x0, y);
    232              RemPixels = x1 - x0 + 1;
    233              pDest     = OFF2PTR32(pContext->VRAMAddr, Off);
   \   00000084   143092E5           LDR      R3,[R2, #+20]
   \   00000088   000090E5           LDR      R0,[R0, #+0]
   \   0000008C   C330A0E1           ASR      R3,R3,#+1
   \   00000090   93040CE0           MUL      R12,R3,R4
   \   00000094   002092E5           LDR      R2,[R2, #+0]
   \   00000098   051046E0           SUB      R1,R6,R5
   \   0000009C   A5308CE0           ADD      R3,R12,R5, LSR #+1
   \   000000A0   000090E5           LDR      R0,[R0, #+0]
   \   000000A4   011081E2           ADD      R1,R1,#+1
   \   000000A8   032182E0           ADD      R2,R2,R3, LSL #+2
    234              //
    235              // First DWORD
    236              //
    237              if (x0 & 1) {
   \   000000AC   010015E3           TST      R5,#0x1
   \   000000B0   0500000A           BEQ      ??_DrawVLine_3
    238                Data = READ_MEM32P(pDest);
    239                #if (LCD_ENDIAN_BIG == 0)
    240                  Data &= 0xFFFF;
    241                  Data |= (((U32)ColorIndex) << 16);
    242                #else
    243                  Data &= 0xFFFF0000;
    244                  Data |= ColorIndex;
    245                #endif
    246                WRITE_MEM32P(pDest, Data);
   \   000000B4   B030D2E1           LDRH     R3,[R2, #+0]
   \   000000B8   00C8A0E1           LSL      R12,R0,#+16
    247                pDest++;
    248                RemPixels--;
   \   000000BC   011041E2           SUB      R1,R1,#+1
   \   000000C0   0338A0E1           LSL      R3,R3,#+16
   \   000000C4   23388CE1           ORR      R3,R12,R3, LSR #+16
   \   000000C8   043082E4           STR      R3,[R2], #+4
    249              }
    250              //
    251              // Complete DWORDS
    252              //
    253              ColorMask = ColorIndex * 0x00010001;
   \                     ??_DrawVLine_3:
   \   000000CC   003880E0           ADD      R3,R0,R0, LSL #+16
    254              if (RemPixels >= 16) {
   \   000000D0   100051E3           CMP      R1,#+16
   \   000000D4   0A00003A           BCC      ??_DrawVLine_4
    255                do {
    256                  WRITE_MEM32P(pDest,     ColorMask);
   \                     ??_DrawVLine_5:
   \   000000D8   043082E4           STR      R3,[R2], #+4
    257                  WRITE_MEM32P(pDest + 1, ColorMask);
   \   000000DC   043082E4           STR      R3,[R2], #+4
    258                  WRITE_MEM32P(pDest + 2, ColorMask);
   \   000000E0   043082E4           STR      R3,[R2], #+4
    259                  WRITE_MEM32P(pDest + 3, ColorMask);
   \   000000E4   043082E4           STR      R3,[R2], #+4
    260                  WRITE_MEM32P(pDest + 4, ColorMask);
   \   000000E8   043082E4           STR      R3,[R2], #+4
    261                  WRITE_MEM32P(pDest + 5, ColorMask);
   \   000000EC   043082E4           STR      R3,[R2], #+4
    262                  WRITE_MEM32P(pDest + 6, ColorMask);
   \   000000F0   043082E4           STR      R3,[R2], #+4
    263                  WRITE_MEM32P(pDest + 7, ColorMask);
    264                  pDest += 8;
    265                } while ((RemPixels -= 16) >= 16);
   \   000000F4   101041E2           SUB      R1,R1,#+16
   \   000000F8   043082E4           STR      R3,[R2], #+4
   \   000000FC   100051E3           CMP      R1,#+16
   \   00000100   F4FFFF2A           BCS      ??_DrawVLine_5
    266              }
    267              if (RemPixels >= 2) {
   \                     ??_DrawVLine_4:
   \   00000104   020051E3           CMP      R1,#+2
   \   00000108   0300003A           BCC      ??_DrawVLine_6
    268                do {
    269                  WRITE_MEM32P(pDest, ColorMask);
    270                  pDest++;
    271                } while ((RemPixels -= 2) >= 2);
   \                     ??_DrawVLine_7:
   \   0000010C   021041E2           SUB      R1,R1,#+2
   \   00000110   043082E4           STR      R3,[R2], #+4
   \   00000114   020051E3           CMP      R1,#+2
   \   00000118   FBFFFF2A           BCS      ??_DrawVLine_7
    272              }
    273              //
    274              // Last DWORD
    275              //
    276              if (RemPixels > 0) {
   \                     ??_DrawVLine_6:
   \   0000011C   000051E3           CMP      R1,#+0
   \   00000120   0500000A           BEQ      ??_DrawVLine_1
    277                Data = READ_MEM32P(pDest);
    278                #if (LCD_ENDIAN_BIG == 0)
    279                  Data &= 0xFFFF0000;
    280                  Data |= ColorIndex & 0xFFFF;
    281                #else
    282                  Data &= 0xFFFF;
    283                  Data |= (((U32)ColorIndex) << 16);
    284                #endif
    285                WRITE_MEM32P(pDest, Data);
   \   00000124   001092E5           LDR      R1,[R2, #+0]
   \   00000128   0008A0E1           LSL      R0,R0,#+16
   \   0000012C   2118A0E1           LSR      R1,R1,#+16
   \   00000130   2008A0E1           LSR      R0,R0,#+16
   \   00000134   010880E1           ORR      R0,R0,R1, LSL #+16
   \   00000138   000082E5           STR      R0,[R2, #+0]
    286              }
    287            }
    288          }
   \                     ??_DrawVLine_1:
   \   0000013C   F081BDE8           POP      {R4-R8,PC}       ;; return
    289          
    290          /*********************************************************************
    291          *
    292          *       _FillRect
    293          */

   \                                 In section .text, align 4, keep-with-next
    294          static void _FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   \   00000008   0370A0E1           MOV      R7,R3
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   18809DE5           LDR      R8,[SP, #+24]
   \   00000018   050057E1           CMP      R7,R5
   \   0000001C   070000BA           BLT      ??_FillRect_0
    295            #ifdef LCD_FILL_RECT
    296               LCD_FILL_RECT(x0, y0, x1, y1, LCD__GetColorIndex());
    297            #else
    298              for (; x0 <= x1; x0++) {
    299                _DrawVLine(pDevice, x0, y0, y1);
   \                     ??_FillRect_1:
   \   00000020   0830A0E1           MOV      R3,R8
   \   00000024   0620A0E1           MOV      R2,R6
   \   00000028   0510A0E1           MOV      R1,R5
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       _DrawVLine
    300              }
   \   00000034   015085E2           ADD      R5,R5,#+1
   \   00000038   050057E1           CMP      R7,R5
   \   0000003C   F7FFFFAA           BGE      ??_FillRect_1
    301            #endif
    302          }
   \                     ??_FillRect_0:
   \   00000040   F081BDE8           POP      {R4-R8,PC}       ;; return
    303          
    304          /*********************************************************************
    305          *
    306          *       Draw Bitmap 1 BPP
    307          */

   \                                 In section .text, align 4, keep-with-next
    308          static void _DrawBitLine1BPP_Swap(GUI_DEVICE * pDevice, unsigned x, unsigned y, U8 const GUI_UNI_PTR * pData, int ySize, const LCD_PIXELINDEX * pTrans, int BytesPerLine, U8 Pos) {
   \                     _DrawBitLine1BPP_Swap:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    309            DRIVER_CONTEXT * pContext;
    310            LCD_PIXELINDEX Index, Index0, Index1, IndexMask;
    311            U32 Off;
    312            U8 Mask;
    313            U16 * pDest;
    314            int x0, y0;
    315          
    316            pContext  = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000004   08B090E5           LDR      R11,[R0, #+8]
    317            y0        = x;
    318            x0        = y;
    319            IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \   00000008   100090E5           LDR      R0,[R0, #+16]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0140A0E1           MOV      R4,R1
   \   00000014   0250A0E1           MOV      R5,R2
   \   00000018   0360A0E1           MOV      R6,R3
   \   0000001C   28709DE5           LDR      R7,[SP, #+40]
   \   00000020   2C809DE5           LDR      R8,[SP, #+44]
   \   00000024   30909DE5           LDR      R9,[SP, #+48]
   \   00000028   34A0DDE5           LDRB     R10,[SP, #+52]
   \   0000002C   080090E5           LDR      R0,[R0, #+8]
   \   00000030   30FF2FE1           BLX      R0
    320            Off       = XY2OFF16(pContext->vxSizePhys, x0, y0);
   \   00000034   14109BE5           LDR      R1,[R11, #+20]
    321            pDest     = OFF2PTR16(pContext->VRAMAddr, Off);
    322            Index0    = *(pTrans + 0);
    323            Index1    = *(pTrans + 1);
    324            Mask      = 0x80 >> (Pos & 0x7);
   \   00000038   80C0A0E3           MOV      R12,#+128
   \   0000003C   91542EE0           MLA      LR,R1,R4,R5
   \   00000040   07400AE2           AND      R4,R10,#0x7
   \   00000044   3CC4A0E1           LSR      R12,R12,R4
    325            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000048   ........           LDR      R4,??DataTable15
   \   0000004C   00109BE5           LDR      R1,[R11, #+0]
   \   00000050   1040D4E5           LDRB     R4,[R4, #+16]
   \   00000054   8E1081E0           ADD      R1,R1,LR, LSL #+1
   \   00000058   002098E5           LDR      R2,[R8, #+0]
   \   0000005C   034004E2           AND      R4,R4,#0x3
   \   00000060   043098E5           LDR      R3,[R8, #+4]
   \   00000064   030054E3           CMP      R4,#+3
   \   00000068   04F18F90           ADDLS    PC,PC,R4, LSL #+2
   \                     ??_DrawBitLine1BPP_Swap_0:
   \   0000006C   5C00008A           BHI      ??_DrawBitLine1BPP_Swap_1
   \   00000070   020000EA           B        ??_DrawBitLine1BPP_Swap_2
   \   00000074   2A0000EA           B        ??_DrawBitLine1BPP_Swap_3
   \   00000078   4E0000EA           B        ??_DrawBitLine1BPP_Swap_4
   \   0000007C   280000EA           B        ??_DrawBitLine1BPP_Swap_3
    326            case 0:
    327              while (ySize >= 4) {
   \                     ??_DrawBitLine1BPP_Swap_2:
   \   00000080   040057E3           CMP      R7,#+4
   \   00000084   1B0000BA           BLT      ??_DrawBitLine1BPP_Swap_5
    328                do {
    329                  Index = (*pData & Mask) ? Index1 : Index0;
   \                     ??_DrawBitLine1BPP_Swap_6:
   \   00000088   0000D6E5           LDRB     R0,[R6, #+0]
    330                  WRITE_MEM16P(pDest, Index);
    331                  pData += BytesPerLine;
    332                  pDest++;
    333                  Index = (*pData & Mask) ? Index1 : Index0;
    334                  WRITE_MEM16P(pDest, Index);
    335                  pData += BytesPerLine;
    336                  pDest++;
    337                  Index = (*pData & Mask) ? Index1 : Index0;
    338                  WRITE_MEM16P(pDest, Index);
    339                  pData += BytesPerLine;
    340                  pDest++;
    341                  Index = (*pData & Mask) ? Index1 : Index0;
    342                  WRITE_MEM16P(pDest, Index);
    343                  pData += BytesPerLine;
    344                  pDest++;
    345                  ySize -= 4;
   \   0000008C   047047E2           SUB      R7,R7,#+4
   \   00000090   00001CE1           TST      R12,R0
   \   00000094   0300A011           MOVNE    R0,R3
   \   00000098   0200A001           MOVEQ    R0,R2
   \   0000009C   B200C1E0           STRH     R0,[R1], #+2
   \   000000A0   060089E0           ADD      R0,R9,R6
   \   000000A4   00E0D0E5           LDRB     LR,[R0, #+0]
   \   000000A8   000089E0           ADD      R0,R9,R0
   \   000000AC   0E001CE1           TST      R12,LR
   \   000000B0   03E0A011           MOVNE    LR,R3
   \   000000B4   02E0A001           MOVEQ    LR,R2
   \   000000B8   B2E0C1E0           STRH     LR,[R1], #+2
   \   000000BC   00E0D0E5           LDRB     LR,[R0, #+0]
   \   000000C0   000089E0           ADD      R0,R9,R0
   \   000000C4   006089E0           ADD      R6,R9,R0
   \   000000C8   0E001CE1           TST      R12,LR
   \   000000CC   03E0A011           MOVNE    LR,R3
   \   000000D0   02E0A001           MOVEQ    LR,R2
   \   000000D4   B2E0C1E0           STRH     LR,[R1], #+2
   \   000000D8   00E0D0E5           LDRB     LR,[R0, #+0]
   \   000000DC   0E001CE1           TST      R12,LR
   \   000000E0   03E0A011           MOVNE    LR,R3
   \   000000E4   02E0A001           MOVEQ    LR,R2
   \   000000E8   B2E0C1E0           STRH     LR,[R1], #+2
    346                } while (ySize >= 4);
   \   000000EC   040057E3           CMP      R7,#+4
   \   000000F0   E4FFFFAA           BGE      ??_DrawBitLine1BPP_Swap_6
   \   000000F4   E1FFFFEA           B        ??_DrawBitLine1BPP_Swap_2
    347              }
    348              if (ySize) { 
   \                     ??_DrawBitLine1BPP_Swap_5:
   \   000000F8   000057E3           CMP      R7,#+0
   \   000000FC   3800000A           BEQ      ??_DrawBitLine1BPP_Swap_1
    349          	    do {
    350                  Index = (*pData & Mask) ? Index1 : Index0;
   \                     ??_DrawBitLine1BPP_Swap_7:
   \   00000100   0000D6E5           LDRB     R0,[R6, #+0]
    351                  WRITE_MEM16P(pDest, Index);
    352                  pData += BytesPerLine;
   \   00000104   066089E0           ADD      R6,R9,R6
   \   00000108   00001CE1           TST      R12,R0
   \   0000010C   03E0A011           MOVNE    LR,R3
   \   00000110   02E0A001           MOVEQ    LR,R2
   \   00000114   B2E0C1E0           STRH     LR,[R1], #+2
    353                  pDest++;
    354                } while (--ySize);
   \   00000118   017057E2           SUBS     R7,R7,#+1
   \   0000011C   F7FFFF1A           BNE      ??_DrawBitLine1BPP_Swap_7
   \   00000120   2F0000EA           B        ??_DrawBitLine1BPP_Swap_1
    355              }
    356              break;
    357            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    358            case LCD_DRAWMODE_XOR:
    359              do {
    360                if (*pData & Mask) {
   \                     ??_DrawBitLine1BPP_Swap_3:
   \   00000124   0010D6E5           LDRB     R1,[R6, #+0]
   \   00000128   01001CE1           TST      R12,R1
   \   0000012C   0400000A           BEQ      ??_DrawBitLine1BPP_Swap_8
    361                  Index = READ_MEM16(pContext->VRAMAddr, Off);
    362                  Index ^= IndexMask;
    363                  WRITE_MEM16(pContext->VRAMAddr, Off, Index);
   \   00000130   00209BE5           LDR      R2,[R11, #+0]
   \   00000134   8E10A0E1           LSL      R1,LR,#+1
   \   00000138   B23091E1           LDRH     R3,[R1, +R2]
   \   0000013C   033020E0           EOR      R3,R0,R3
   \   00000140   B23081E1           STRH     R3,[R1, +R2]
    364                }
    365                pData += BytesPerLine;
   \                     ??_DrawBitLine1BPP_Swap_8:
   \   00000144   066089E0           ADD      R6,R9,R6
    366                Off++;
   \   00000148   01E08EE2           ADD      LR,LR,#+1
    367              } while (--ySize);
   \   0000014C   017057E2           SUBS     R7,R7,#+1
   \   00000150   F3FFFF1A           BNE      ??_DrawBitLine1BPP_Swap_3
   \   00000154   220000EA           B        ??_DrawBitLine1BPP_Swap_1
    368              break;
    369            case LCD_DRAWMODE_TRANS:
    370              while (ySize >= 4) {
    371                do {
    372                  if (*pData & Mask) {
   \                     ??_DrawBitLine1BPP_Swap_9:
   \   00000158   0000D6E5           LDRB     R0,[R6, #+0]
    373                    WRITE_MEM16P(pDest, Index1);
    374                  }
    375                  pData += BytesPerLine;
    376                  pDest++;
    377                  if (*pData & Mask) {
   \   0000015C   0CE0A0E1           MOV      LR,R12
    378                    WRITE_MEM16P(pDest, Index1);
    379                  }
    380                  pData += BytesPerLine;
    381                  pDest++;
    382                  if (*pData & Mask) {
    383                    WRITE_MEM16P(pDest, Index1);
    384                  }
    385                  pData += BytesPerLine;
    386                  pDest++;
    387                  if (*pData & Mask) {
    388                    WRITE_MEM16P(pDest, Index1);
    389                  }
    390                  pData += BytesPerLine;
    391                  pDest++;
    392                  ySize -= 4;
   \   00000160   047047E2           SUB      R7,R7,#+4
   \   00000164   00001CE1           TST      R12,R0
   \   00000168   B030C111           STRHNE   R3,[R1, #+0]
   \   0000016C   060089E0           ADD      R0,R9,R6
   \   00000170   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000174   021081E2           ADD      R1,R1,#+2
   \   00000178   000089E0           ADD      R0,R9,R0
   \   0000017C   02001EE1           TST      LR,R2
   \   00000180   B030C111           STRHNE   R3,[R1, #+0]
   \   00000184   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000188   021081E2           ADD      R1,R1,#+2
   \   0000018C   000089E0           ADD      R0,R9,R0
   \   00000190   02001EE1           TST      LR,R2
   \   00000194   B030C111           STRHNE   R3,[R1, #+0]
   \   00000198   0020D0E5           LDRB     R2,[R0, #+0]
   \   0000019C   021081E2           ADD      R1,R1,#+2
   \   000001A0   006089E0           ADD      R6,R9,R0
   \   000001A4   02001EE1           TST      LR,R2
   \   000001A8   B030C111           STRHNE   R3,[R1, #+0]
   \   000001AC   021081E2           ADD      R1,R1,#+2
    393                } while (ySize >= 4);
   \   000001B0   040057E3           CMP      R7,#+4
   \   000001B4   E7FFFFAA           BGE      ??_DrawBitLine1BPP_Swap_9
    394              }
   \                     ??_DrawBitLine1BPP_Swap_4:
   \   000001B8   040057E3           CMP      R7,#+4
   \   000001BC   E5FFFFAA           BGE      ??_DrawBitLine1BPP_Swap_9
    395              if (ySize) { 
   \   000001C0   000057E3           CMP      R7,#+0
   \   000001C4   0600000A           BEQ      ??_DrawBitLine1BPP_Swap_1
    396          	    do {
    397                  if (*pData & Mask) {
   \                     ??_DrawBitLine1BPP_Swap_10:
   \   000001C8   0000D6E5           LDRB     R0,[R6, #+0]
    398                    WRITE_MEM16P(pDest, Index1);
    399                  }
    400                  pData += BytesPerLine;
   \   000001CC   066089E0           ADD      R6,R9,R6
   \   000001D0   00001CE1           TST      R12,R0
   \   000001D4   B030C111           STRHNE   R3,[R1, #+0]
    401                  pDest++;
   \   000001D8   021081E2           ADD      R1,R1,#+2
    402                } while (--ySize);
   \   000001DC   017057E2           SUBS     R7,R7,#+1
   \   000001E0   F8FFFF1A           BNE      ??_DrawBitLine1BPP_Swap_10
    403              }
    404              break;
    405            }
    406          }
   \                     ??_DrawBitLine1BPP_Swap_1:
   \   000001E4   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000001E8   F08FBDE8           POP      {R4-R11,PC}      ;; return
    407          
    408          /*********************************************************************
    409          *
    410          *       Draw Bitmap 2 BPP, not optimized
    411          */

   \                                 In section .text, align 4, keep-with-next
    412          static void  _DrawBitLine2BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine2BPP:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    413            LCD_PIXELINDEX Pixels, PixelIndex;
    414            int CurrentPixel, Shift, Index;
    415            Pixels       = *p;
    416            CurrentPixel = Diff;
    417            x           += Diff;
    418            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000004   ........           LDR      R6,??DataTable15
   \   00000008   20409DE5           LDR      R4,[SP, #+32]
   \   0000000C   1060D6E5           LDRB     R6,[R6, #+16]
   \   00000010   24E09DE5           LDR      LR,[SP, #+36]
   \   00000014   28509DE5           LDR      R5,[SP, #+40]
   \   00000018   00C0D3E5           LDRB     R12,[R3, #+0]
   \   0000001C   011084E0           ADD      R1,R4,R1
   \   00000020   036016E2           ANDS     R6,R6,#0x3
   \   00000024   0200000A           BEQ      ??_DrawBitLine2BPP_0
   \   00000028   026056E2           SUBS     R6,R6,#+2
   \   0000002C   2C00000A           BEQ      ??_DrawBitLine2BPP_1
   \   00000030   F087BDE8           POP      {R4-R10,PC}
    419            case 0:
    420              if (pTrans) {
   \                     ??_DrawBitLine2BPP_0:
   \   00000034   C060A0E3           MOV      R6,#+192
   \   00000038   000055E3           CMP      R5,#+0
   \   0000003C   1400000A           BEQ      ??_DrawBitLine2BPP_2
    421                do {
    422                  Shift = (3 - CurrentPixel) << 1;
    423                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    424                  PixelIndex = *(pTrans + Index);
    425                  _SetPixelIndex(pDevice, x++, y, PixelIndex);
   \                     ??_DrawBitLine2BPP_3:
   \   00000040   088090E5           LDR      R8,[R0, #+8]
   \   00000044   037064E2           RSB      R7,R4,#+3
   \   00000048   149098E5           LDR      R9,[R8, #+20]
   \   0000004C   8770A0E1           LSL      R7,R7,#+1
   \   00000050   99212AE0           MLA      R10,R9,R1,R2
   \   00000054   0790A0E1           MOV      R9,R7
   \   00000058   069069E2           RSB      R9,R9,#+6
   \   0000005C   56990CE0           AND      R9,R12,R6, ASR R9
   \   00000060   008098E5           LDR      R8,[R8, #+0]
   \   00000064   3977A0E1           LSR      R7,R9,R7
   \   00000068   077195E7           LDR      R7,[R5, +R7, LSL #+2]
   \   0000006C   8A8088E0           ADD      R8,R8,R10, LSL #+1
    426                  if (++CurrentPixel == 4) {
   \   00000070   014084E2           ADD      R4,R4,#+1
   \   00000074   B070C8E1           STRH     R7,[R8, #+0]
   \   00000078   040054E3           CMP      R4,#+4
    427                    CurrentPixel = 0;
   \   0000007C   0040A003           MOVEQ    R4,#+0
    428                    Pixels = *(++p);
   \   00000080   01C0F305           LDRBEQ   R12,[R3, #+1]!
   \   00000084   011081E2           ADD      R1,R1,#+1
    429                  }
    430          		  } while (--xsize);
   \   00000088   01E05EE2           SUBS     LR,LR,#+1
   \   0000008C   EBFFFF1A           BNE      ??_DrawBitLine2BPP_3
   \   00000090   F087BDE8           POP      {R4-R10,PC}
    431              } else {
    432                do {
    433                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_2:
   \   00000094   035064E2           RSB      R5,R4,#+3
   \   00000098   8570A0E1           LSL      R7,R5,#+1
    434                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    435                  _SetPixelIndex(pDevice, x++, y, Index);
   \   0000009C   085090E5           LDR      R5,[R0, #+8]
    436                  if (++CurrentPixel == 4) {
   \   000000A0   014084E2           ADD      R4,R4,#+1
   \   000000A4   148095E5           LDR      R8,[R5, #+20]
   \   000000A8   005095E5           LDR      R5,[R5, #+0]
   \   000000AC   982129E0           MLA      R9,R8,R1,R2
   \   000000B0   0780A0E1           MOV      R8,R7
   \   000000B4   068068E2           RSB      R8,R8,#+6
   \   000000B8   56880CE0           AND      R8,R12,R6, ASR R8
   \   000000BC   895085E0           ADD      R5,R5,R9, LSL #+1
   \   000000C0   3877A0E1           LSR      R7,R8,R7
   \   000000C4   B070C5E1           STRH     R7,[R5, #+0]
   \   000000C8   040054E3           CMP      R4,#+4
    437                    CurrentPixel = 0;
   \   000000CC   0040A003           MOVEQ    R4,#+0
    438                    Pixels = *(++p);
   \   000000D0   01C0F305           LDRBEQ   R12,[R3, #+1]!
   \   000000D4   011081E2           ADD      R1,R1,#+1
    439                  }
    440          		  } while (--xsize);
   \   000000D8   01E05EE2           SUBS     LR,LR,#+1
   \   000000DC   ECFFFF1A           BNE      ??_DrawBitLine2BPP_2
   \   000000E0   F087BDE8           POP      {R4-R10,PC}
    441              }
    442              break;
    443            case LCD_DRAWMODE_TRANS:
    444              if (pTrans) {
   \                     ??_DrawBitLine2BPP_1:
   \   000000E4   C060A0E3           MOV      R6,#+192
   \   000000E8   000055E3           CMP      R5,#+0
   \   000000EC   1500000A           BEQ      ??_DrawBitLine2BPP_4
    445                do {
    446                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_5:
   \   000000F0   037064E2           RSB      R7,R4,#+3
   \   000000F4   8770A0E1           LSL      R7,R7,#+1
    447                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   000000F8   0780A0E1           MOV      R8,R7
   \   000000FC   068068E2           RSB      R8,R8,#+6
   \   00000100   56880CE0           AND      R8,R12,R6, ASR R8
   \   00000104   3877B0E1           LSRS     R7,R8,R7
    448                  if (Index) {
   \   00000108   0600000A           BEQ      ??_DrawBitLine2BPP_6
    449                    PixelIndex = *(pTrans + Index);
    450                    _SetPixelIndex(pDevice, x, y, PixelIndex);
   \   0000010C   088090E5           LDR      R8,[R0, #+8]
   \   00000110   077195E7           LDR      R7,[R5, +R7, LSL #+2]
   \   00000114   149098E5           LDR      R9,[R8, #+20]
   \   00000118   008098E5           LDR      R8,[R8, #+0]
   \   0000011C   99212AE0           MLA      R10,R9,R1,R2
   \   00000120   8A8088E0           ADD      R8,R8,R10, LSL #+1
   \   00000124   B070C8E1           STRH     R7,[R8, #+0]
    451                  }
    452                  x++;
    453                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_6:
   \   00000128   014084E2           ADD      R4,R4,#+1
   \   0000012C   040054E3           CMP      R4,#+4
    454                    CurrentPixel = 0;
   \   00000130   0040A003           MOVEQ    R4,#+0
    455                    Pixels = *(++p);
   \   00000134   01C0F305           LDRBEQ   R12,[R3, #+1]!
   \   00000138   011081E2           ADD      R1,R1,#+1
    456                  }
    457          		  } while (--xsize);
   \   0000013C   01E05EE2           SUBS     LR,LR,#+1
   \   00000140   EAFFFF1A           BNE      ??_DrawBitLine2BPP_5
   \   00000144   F087BDE8           POP      {R4-R10,PC}
    458              } else {
    459                do {
    460                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_4:
   \   00000148   035064E2           RSB      R5,R4,#+3
   \   0000014C   8570A0E1           LSL      R7,R5,#+1
    461                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000150   0750A0E1           MOV      R5,R7
   \   00000154   065065E2           RSB      R5,R5,#+6
   \   00000158   56550CE0           AND      R5,R12,R6, ASR R5
   \   0000015C   3577B0E1           LSRS     R7,R5,R7
    462                  if (Index) {
   \   00000160   0500000A           BEQ      ??_DrawBitLine2BPP_7
    463                    _SetPixelIndex(pDevice, x, y, Index);
   \   00000164   085090E5           LDR      R5,[R0, #+8]
   \   00000168   148095E5           LDR      R8,[R5, #+20]
   \   0000016C   005095E5           LDR      R5,[R5, #+0]
   \   00000170   982129E0           MLA      R9,R8,R1,R2
   \   00000174   895085E0           ADD      R5,R5,R9, LSL #+1
   \   00000178   B070C5E1           STRH     R7,[R5, #+0]
    464                  }
    465                  x++;
    466                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_7:
   \   0000017C   014084E2           ADD      R4,R4,#+1
   \   00000180   040054E3           CMP      R4,#+4
    467                    CurrentPixel = 0;
   \   00000184   0040A003           MOVEQ    R4,#+0
    468                    Pixels = *(++p);
   \   00000188   01C0F305           LDRBEQ   R12,[R3, #+1]!
   \   0000018C   011081E2           ADD      R1,R1,#+1
    469                  }
    470          		  } while (--xsize);
   \   00000190   01E05EE2           SUBS     LR,LR,#+1
   \   00000194   EBFFFF1A           BNE      ??_DrawBitLine2BPP_4
    471              }
    472              break;
    473            }
    474          }
   \   00000198   F087BDE8           POP      {R4-R10,PC}      ;; return
    475          
    476          /*********************************************************************
    477          *
    478          *       Draw Bitmap 4 BPP, not optimized
    479          */

   \                                 In section .text, align 4, keep-with-next
    480          static void  _DrawBitLine4BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine4BPP:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    481            LCD_PIXELINDEX Pixels, PixelIndex;
    482            int CurrentPixel, Shift, Index;
    483            Pixels       = *p;
    484            CurrentPixel = Diff;
    485            x           += Diff;
    486            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000004   ........           LDR      R6,??DataTable15
   \   00000008   20409DE5           LDR      R4,[SP, #+32]
   \   0000000C   1060D6E5           LDRB     R6,[R6, #+16]
   \   00000010   24E09DE5           LDR      LR,[SP, #+36]
   \   00000014   28509DE5           LDR      R5,[SP, #+40]
   \   00000018   00C0D3E5           LDRB     R12,[R3, #+0]
   \   0000001C   011084E0           ADD      R1,R4,R1
   \   00000020   036016E2           ANDS     R6,R6,#0x3
   \   00000024   0200000A           BEQ      ??_DrawBitLine4BPP_0
   \   00000028   026056E2           SUBS     R6,R6,#+2
   \   0000002C   2C00000A           BEQ      ??_DrawBitLine4BPP_1
   \   00000030   F087BDE8           POP      {R4-R10,PC}
    487            case 0:
    488              if (pTrans) {
   \                     ??_DrawBitLine4BPP_0:
   \   00000034   F060A0E3           MOV      R6,#+240
   \   00000038   000055E3           CMP      R5,#+0
   \   0000003C   1400000A           BEQ      ??_DrawBitLine4BPP_2
    489                do {
    490                  Shift = (1 - CurrentPixel) << 2;
    491                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    492                  PixelIndex = *(pTrans + Index);
    493                  _SetPixelIndex(pDevice, x++, y, PixelIndex);
   \                     ??_DrawBitLine4BPP_3:
   \   00000040   088090E5           LDR      R8,[R0, #+8]
   \   00000044   017064E2           RSB      R7,R4,#+1
   \   00000048   149098E5           LDR      R9,[R8, #+20]
   \   0000004C   0771A0E1           LSL      R7,R7,#+2
   \   00000050   99212AE0           MLA      R10,R9,R1,R2
   \   00000054   0790A0E1           MOV      R9,R7
   \   00000058   049069E2           RSB      R9,R9,#+4
   \   0000005C   56990CE0           AND      R9,R12,R6, ASR R9
   \   00000060   008098E5           LDR      R8,[R8, #+0]
   \   00000064   3977A0E1           LSR      R7,R9,R7
   \   00000068   077195E7           LDR      R7,[R5, +R7, LSL #+2]
   \   0000006C   8A8088E0           ADD      R8,R8,R10, LSL #+1
    494                  if (++CurrentPixel == 2) {
   \   00000070   014084E2           ADD      R4,R4,#+1
   \   00000074   B070C8E1           STRH     R7,[R8, #+0]
   \   00000078   020054E3           CMP      R4,#+2
    495                    CurrentPixel = 0;
   \   0000007C   0040A003           MOVEQ    R4,#+0
    496                    Pixels = *(++p);
   \   00000080   01C0F305           LDRBEQ   R12,[R3, #+1]!
   \   00000084   011081E2           ADD      R1,R1,#+1
    497                  }
    498          		  } while (--xsize);
   \   00000088   01E05EE2           SUBS     LR,LR,#+1
   \   0000008C   EBFFFF1A           BNE      ??_DrawBitLine4BPP_3
   \   00000090   F087BDE8           POP      {R4-R10,PC}
    499              } else {
    500                do {
    501                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_2:
   \   00000094   015064E2           RSB      R5,R4,#+1
   \   00000098   0571A0E1           LSL      R7,R5,#+2
    502                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    503                  _SetPixelIndex(pDevice, x++, y, Index);
   \   0000009C   085090E5           LDR      R5,[R0, #+8]
    504                  if (++CurrentPixel == 2) {
   \   000000A0   014084E2           ADD      R4,R4,#+1
   \   000000A4   148095E5           LDR      R8,[R5, #+20]
   \   000000A8   005095E5           LDR      R5,[R5, #+0]
   \   000000AC   982129E0           MLA      R9,R8,R1,R2
   \   000000B0   0780A0E1           MOV      R8,R7
   \   000000B4   048068E2           RSB      R8,R8,#+4
   \   000000B8   56880CE0           AND      R8,R12,R6, ASR R8
   \   000000BC   895085E0           ADD      R5,R5,R9, LSL #+1
   \   000000C0   3877A0E1           LSR      R7,R8,R7
   \   000000C4   B070C5E1           STRH     R7,[R5, #+0]
   \   000000C8   020054E3           CMP      R4,#+2
    505                    CurrentPixel = 0;
   \   000000CC   0040A003           MOVEQ    R4,#+0
    506                    Pixels = *(++p);
   \   000000D0   01C0F305           LDRBEQ   R12,[R3, #+1]!
   \   000000D4   011081E2           ADD      R1,R1,#+1
    507                  }
    508          		  } while (--xsize);
   \   000000D8   01E05EE2           SUBS     LR,LR,#+1
   \   000000DC   ECFFFF1A           BNE      ??_DrawBitLine4BPP_2
   \   000000E0   F087BDE8           POP      {R4-R10,PC}
    509              }
    510              break;
    511            case LCD_DRAWMODE_TRANS:
    512              if (pTrans) {
   \                     ??_DrawBitLine4BPP_1:
   \   000000E4   F060A0E3           MOV      R6,#+240
   \   000000E8   000055E3           CMP      R5,#+0
   \   000000EC   1500000A           BEQ      ??_DrawBitLine4BPP_4
    513                do {
    514                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_5:
   \   000000F0   017064E2           RSB      R7,R4,#+1
   \   000000F4   0771A0E1           LSL      R7,R7,#+2
    515                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   000000F8   0780A0E1           MOV      R8,R7
   \   000000FC   048068E2           RSB      R8,R8,#+4
   \   00000100   56880CE0           AND      R8,R12,R6, ASR R8
   \   00000104   3877B0E1           LSRS     R7,R8,R7
    516                  if (Index) {
   \   00000108   0600000A           BEQ      ??_DrawBitLine4BPP_6
    517                    PixelIndex = *(pTrans + Index);
    518                    _SetPixelIndex(pDevice, x, y, PixelIndex);
   \   0000010C   088090E5           LDR      R8,[R0, #+8]
   \   00000110   077195E7           LDR      R7,[R5, +R7, LSL #+2]
   \   00000114   149098E5           LDR      R9,[R8, #+20]
   \   00000118   008098E5           LDR      R8,[R8, #+0]
   \   0000011C   99212AE0           MLA      R10,R9,R1,R2
   \   00000120   8A8088E0           ADD      R8,R8,R10, LSL #+1
   \   00000124   B070C8E1           STRH     R7,[R8, #+0]
    519                  }
    520                  x++;
    521                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_6:
   \   00000128   014084E2           ADD      R4,R4,#+1
   \   0000012C   020054E3           CMP      R4,#+2
    522                    CurrentPixel = 0;
   \   00000130   0040A003           MOVEQ    R4,#+0
    523                    Pixels = *(++p);
   \   00000134   01C0F305           LDRBEQ   R12,[R3, #+1]!
   \   00000138   011081E2           ADD      R1,R1,#+1
    524                  }
    525          		  } while (--xsize);
   \   0000013C   01E05EE2           SUBS     LR,LR,#+1
   \   00000140   EAFFFF1A           BNE      ??_DrawBitLine4BPP_5
   \   00000144   F087BDE8           POP      {R4-R10,PC}
    526              } else {
    527                do {
    528                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_4:
   \   00000148   015064E2           RSB      R5,R4,#+1
   \   0000014C   0571A0E1           LSL      R7,R5,#+2
    529                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000150   0750A0E1           MOV      R5,R7
   \   00000154   045065E2           RSB      R5,R5,#+4
   \   00000158   56550CE0           AND      R5,R12,R6, ASR R5
   \   0000015C   3577B0E1           LSRS     R7,R5,R7
    530                  if (Index) {
   \   00000160   0500000A           BEQ      ??_DrawBitLine4BPP_7
    531                    _SetPixelIndex(pDevice, x, y, Index);
   \   00000164   085090E5           LDR      R5,[R0, #+8]
   \   00000168   148095E5           LDR      R8,[R5, #+20]
   \   0000016C   005095E5           LDR      R5,[R5, #+0]
   \   00000170   982129E0           MLA      R9,R8,R1,R2
   \   00000174   895085E0           ADD      R5,R5,R9, LSL #+1
   \   00000178   B070C5E1           STRH     R7,[R5, #+0]
    532                  }
    533                  x++;
    534                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_7:
   \   0000017C   014084E2           ADD      R4,R4,#+1
   \   00000180   020054E3           CMP      R4,#+2
    535                    CurrentPixel = 0;
   \   00000184   0040A003           MOVEQ    R4,#+0
    536                    Pixels = *(++p);
   \   00000188   01C0F305           LDRBEQ   R12,[R3, #+1]!
   \   0000018C   011081E2           ADD      R1,R1,#+1
    537                  }
    538          		  } while (--xsize);
   \   00000190   01E05EE2           SUBS     LR,LR,#+1
   \   00000194   EBFFFF1A           BNE      ??_DrawBitLine4BPP_4
    539              }
    540              break;
    541            }
    542          }
   \   00000198   F087BDE8           POP      {R4-R10,PC}      ;; return
    543          
    544          /*********************************************************************
    545          *
    546          *       Draw Bitmap 8 BPP
    547          */

   \                                 In section .text, align 4, keep-with-next
    548          static void _DrawBitLine8BPP_Swap(GUI_DEVICE * pDevice, unsigned x, unsigned y, U8 const GUI_UNI_PTR * pData, int ySize, const LCD_PIXELINDEX * pTrans, int BytesPerLine) {
   \                     _DrawBitLine8BPP_Swap:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   10C09DE5           LDR      R12,[SP, #+16]
   \   00000008   0C409DE5           LDR      R4,[SP, #+12]
   \   0000000C   14E09DE5           LDR      LR,[SP, #+20]
    549            DRIVER_CONTEXT * pContext;
    550            LCD_PIXELINDEX Index;
    551            U32 Off;
    552            U8 Pixel;
    553            U16 * pDest;
    554            int x0, y0;
    555            
    556            if (pTrans == NULL) {
   \   00000010   00005CE3           CMP      R12,#+0
   \   00000014   5100000A           BEQ      ??_DrawBitLine8BPP_Swap_0
    557              return; // Because it makes no sense to use 8bpp bitmaps without palette with a 16bpp configuration
    558            }
    559            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000018   080090E5           LDR      R0,[R0, #+8]
    560            y0       = x;
    561            x0       = y;
    562            Off      = XY2OFF16(pContext->vxSizePhys, x0, y0);
    563            pDest    = OFF2PTR16(pContext->VRAMAddr, Off);
   \   0000001C   145090E5           LDR      R5,[R0, #+20]
   \   00000020   000090E5           LDR      R0,[R0, #+0]
   \   00000024   952121E0           MLA      R1,R5,R1,R2
   \   00000028   810080E0           ADD      R0,R0,R1, LSL #+1
    564            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   0000002C   ........           LDR      R1,??DataTable15
   \   00000030   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000034   031011E2           ANDS     R1,R1,#0x3
   \   00000038   0200000A           BEQ      ??_DrawBitLine8BPP_Swap_1
   \   0000003C   021051E2           SUBS     R1,R1,#+2
   \   00000040   3A00000A           BEQ      ??_DrawBitLine8BPP_Swap_2
   \   00000044   3080BDE8           POP      {R4,R5,PC}
    565            case 0:
    566              while (ySize >= 4) {
   \                     ??_DrawBitLine8BPP_Swap_1:
   \   00000048   040054E3           CMP      R4,#+4
   \   0000004C   130000BA           BLT      ??_DrawBitLine8BPP_Swap_3
    567                do {
    568                  Index = *(pTrans + *pData);
    569                  WRITE_MEM16P(pDest, Index);
   \                     ??_DrawBitLine8BPP_Swap_4:
   \   00000050   0010D3E5           LDRB     R1,[R3, #+0]
    570                  pData += BytesPerLine;
    571                  pDest++;
    572                  Index = *(pTrans + *pData);
    573                  WRITE_MEM16P(pDest, Index);
    574                  pData += BytesPerLine;
    575                  pDest++;
    576                  Index = *(pTrans + *pData);
    577                  WRITE_MEM16P(pDest, Index);
    578                  pData += BytesPerLine;
    579                  pDest++;
    580                  Index = *(pTrans + *pData);
    581                  WRITE_MEM16P(pDest, Index);
    582                  pData += BytesPerLine;
    583                  pDest++;
    584                  ySize -= 4;
   \   00000054   044044E2           SUB      R4,R4,#+4
    585                } while (ySize >= 4);
   \   00000058   040054E3           CMP      R4,#+4
   \   0000005C   01119CE7           LDR      R1,[R12, +R1, LSL #+2]
   \   00000060   B210C0E0           STRH     R1,[R0], #+2
   \   00000064   03108EE0           ADD      R1,LR,R3
   \   00000068   0020D1E5           LDRB     R2,[R1, #+0]
   \   0000006C   01108EE0           ADD      R1,LR,R1
   \   00000070   02219CE7           LDR      R2,[R12, +R2, LSL #+2]
   \   00000074   B220C0E0           STRH     R2,[R0], #+2
   \   00000078   0020D1E5           LDRB     R2,[R1, #+0]
   \   0000007C   01108EE0           ADD      R1,LR,R1
   \   00000080   01308EE0           ADD      R3,LR,R1
   \   00000084   02219CE7           LDR      R2,[R12, +R2, LSL #+2]
   \   00000088   B220C0E0           STRH     R2,[R0], #+2
   \   0000008C   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000090   02219CE7           LDR      R2,[R12, +R2, LSL #+2]
   \   00000094   B220C0E0           STRH     R2,[R0], #+2
   \   00000098   ECFFFFAA           BGE      ??_DrawBitLine8BPP_Swap_4
   \   0000009C   E9FFFFEA           B        ??_DrawBitLine8BPP_Swap_1
    586              }
    587              if (ySize) { 
   \                     ??_DrawBitLine8BPP_Swap_3:
   \   000000A0   000054E3           CMP      R4,#+0
   \   000000A4   2D00000A           BEQ      ??_DrawBitLine8BPP_Swap_0
    588          	    do {
    589                  Index = *(pTrans + *pData);
    590                  WRITE_MEM16P(pDest, Index);
   \                     ??_DrawBitLine8BPP_Swap_5:
   \   000000A8   0010D3E5           LDRB     R1,[R3, #+0]
    591                  pData += BytesPerLine;
   \   000000AC   03308EE0           ADD      R3,LR,R3
    592                  pDest++;
    593                } while (--ySize);
   \   000000B0   014054E2           SUBS     R4,R4,#+1
   \   000000B4   01119CE7           LDR      R1,[R12, +R1, LSL #+2]
   \   000000B8   B210C0E0           STRH     R1,[R0], #+2
   \   000000BC   F9FFFF1A           BNE      ??_DrawBitLine8BPP_Swap_5
   \   000000C0   3080BDE8           POP      {R4,R5,PC}
    594              }
    595              break;
    596            case LCD_DRAWMODE_TRANS:
    597              while (ySize >= 4) {
    598                do {
    599                  Pixel = *pData;
   \                     ??_DrawBitLine8BPP_Swap_6:
   \   000000C4   0010D3E5           LDRB     R1,[R3, #+0]
    600                  if (Pixel) {
    601                    Index = *(pTrans + Pixel);
    602                    WRITE_MEM16P(pDest, Index);
    603                  }
    604                  pData += BytesPerLine;
    605                  pDest++;
    606                  Pixel = *pData;
    607                  if (Pixel) {
    608                    Index = *(pTrans + Pixel);
    609                    WRITE_MEM16P(pDest, Index);
    610                  }
    611                  pData += BytesPerLine;
    612                  pDest++;
    613                  Pixel = *pData;
    614                  if (Pixel) {
    615                    Index = *(pTrans + Pixel);
    616                    WRITE_MEM16P(pDest, Index);
    617                  }
    618                  pData += BytesPerLine;
    619                  pDest++;
    620                  Pixel = *pData;
    621                  if (Pixel) {
    622                    Index = *(pTrans + Pixel);
    623                    WRITE_MEM16P(pDest, Index);
    624                  }
    625                  pData += BytesPerLine;
    626                  pDest++;
    627                  ySize -= 4;
   \   000000C8   044044E2           SUB      R4,R4,#+4
   \   000000CC   000051E3           CMP      R1,#+0
   \   000000D0   01119C17           LDRNE    R1,[R12, +R1, LSL #+2]
   \   000000D4   B010C011           STRHNE   R1,[R0, #+0]
   \   000000D8   03108EE0           ADD      R1,LR,R3
   \   000000DC   0020D1E5           LDRB     R2,[R1, #+0]
   \   000000E0   020080E2           ADD      R0,R0,#+2
   \   000000E4   01108EE0           ADD      R1,LR,R1
   \   000000E8   000052E3           CMP      R2,#+0
   \   000000EC   02219C17           LDRNE    R2,[R12, +R2, LSL #+2]
   \   000000F0   B020C011           STRHNE   R2,[R0, #+0]
   \   000000F4   0020D1E5           LDRB     R2,[R1, #+0]
   \   000000F8   020080E2           ADD      R0,R0,#+2
   \   000000FC   01108EE0           ADD      R1,LR,R1
   \   00000100   000052E3           CMP      R2,#+0
   \   00000104   02219C17           LDRNE    R2,[R12, +R2, LSL #+2]
   \   00000108   01308EE0           ADD      R3,LR,R1
   \   0000010C   B020C011           STRHNE   R2,[R0, #+0]
   \   00000110   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000114   020080E2           ADD      R0,R0,#+2
   \   00000118   000052E3           CMP      R2,#+0
   \   0000011C   02219C17           LDRNE    R2,[R12, +R2, LSL #+2]
   \   00000120   B020C011           STRHNE   R2,[R0, #+0]
   \   00000124   020080E2           ADD      R0,R0,#+2
    628                } while (ySize >= 4);
   \   00000128   040054E3           CMP      R4,#+4
   \   0000012C   E4FFFFAA           BGE      ??_DrawBitLine8BPP_Swap_6
    629              }
   \                     ??_DrawBitLine8BPP_Swap_2:
   \   00000130   040054E3           CMP      R4,#+4
   \   00000134   E2FFFFAA           BGE      ??_DrawBitLine8BPP_Swap_6
    630              if (ySize) { 
   \   00000138   000054E3           CMP      R4,#+0
   \   0000013C   0700000A           BEQ      ??_DrawBitLine8BPP_Swap_0
    631          	    do {
    632                  Pixel = *pData;
   \                     ??_DrawBitLine8BPP_Swap_7:
   \   00000140   0020D3E5           LDRB     R2,[R3, #+0]
    633                  if (Pixel) {
    634                    Index = *(pTrans + Pixel);
    635                    WRITE_MEM16P(pDest, Index);
    636                  }
    637                  pData += BytesPerLine;
   \   00000144   03308EE0           ADD      R3,LR,R3
   \   00000148   000052E3           CMP      R2,#+0
   \   0000014C   02119C17           LDRNE    R1,[R12, +R2, LSL #+2]
   \   00000150   B010C011           STRHNE   R1,[R0, #+0]
    638                  pDest++;
   \   00000154   020080E2           ADD      R0,R0,#+2
    639                } while (--ySize);
   \   00000158   014054E2           SUBS     R4,R4,#+1
   \   0000015C   F7FFFF1A           BNE      ??_DrawBitLine8BPP_Swap_7
   \                     ??_DrawBitLine8BPP_Swap_0:
   \   00000160   3080BDE8           POP      {R4,R5,PC}       ;; return
    640              }
    641              break;
    642            }
    643          }
    644          
    645          /*********************************************************************
    646          *
    647          *       Draw Bitmap 16 BPP
    648          */

   \                                 In section .text, align 4, keep-with-next
    649          static void _DrawBitLine16BPP_Swap(GUI_DEVICE * pDevice, int x, int y, U16 const GUI_UNI_PTR * pData, int ySize, int BytesPerLine) {
   \                     _DrawBitLine16BPP_Swap:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0CE09DE5           LDR      LR,[SP, #+12]
    650            DRIVER_CONTEXT * pContext;
    651            U32 Off;
    652            U16 * pDest;
    653            int WordsPerLine;
    654          
    655            pContext     = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000008   084090E5           LDR      R4,[R0, #+8]
    656            WordsPerLine = BytesPerLine >> 1;
   \   0000000C   CE00A0E1           ASR      R0,LR,#+1
    657            Off          = XY2OFF16(pContext->vxSizePhys, y, x);
    658            pDest        = OFF2PTR16(pContext->VRAMAddr, Off);
   \   00000010   14E094E5           LDR      LR,[R4, #+20]
   \   00000014   08C09DE5           LDR      R12,[SP, #+8]
   \   00000018   9E2121E0           MLA      R1,LR,R1,R2
   \   0000001C   002094E5           LDR      R2,[R4, #+0]
   \   00000020   811082E0           ADD      R1,R2,R1, LSL #+1
    659            while (ySize >= 4) {
   \                     ??_DrawBitLine16BPP_Swap_0:
   \   00000024   04005CE3           CMP      R12,#+4
   \   00000028   0F0000BA           BLT      ??_DrawBitLine16BPP_Swap_1
    660              do {
    661                WRITE_MEM16P(pDest, *pData);
   \                     ??_DrawBitLine16BPP_Swap_2:
   \   0000002C   B020D3E1           LDRH     R2,[R3, #+0]
    662                pDest++;
    663                pData += WordsPerLine;
    664                WRITE_MEM16P(pDest, *pData);
    665                pDest++;
    666                pData += WordsPerLine;
    667                WRITE_MEM16P(pDest, *pData);
    668                pDest++;
    669                pData += WordsPerLine;
    670                WRITE_MEM16P(pDest, *pData);
    671                pDest++;
    672                pData += WordsPerLine;
    673                ySize -= 4;
   \   00000030   04C04CE2           SUB      R12,R12,#+4
    674              } while (ySize >= 4);
   \   00000034   04005CE3           CMP      R12,#+4
   \   00000038   B220C1E0           STRH     R2,[R1], #+2
   \   0000003C   802083E0           ADD      R2,R3,R0, LSL #+1
   \   00000040   B030D2E1           LDRH     R3,[R2, #+0]
   \   00000044   802082E0           ADD      R2,R2,R0, LSL #+1
   \   00000048   B230C1E0           STRH     R3,[R1], #+2
   \   0000004C   B030D2E1           LDRH     R3,[R2, #+0]
   \   00000050   802082E0           ADD      R2,R2,R0, LSL #+1
   \   00000054   B230C1E0           STRH     R3,[R1], #+2
   \   00000058   B030D2E1           LDRH     R3,[R2, #+0]
   \   0000005C   B230C1E0           STRH     R3,[R1], #+2
   \   00000060   803082E0           ADD      R3,R2,R0, LSL #+1
   \   00000064   F0FFFFAA           BGE      ??_DrawBitLine16BPP_Swap_2
   \   00000068   EDFFFFEA           B        ??_DrawBitLine16BPP_Swap_0
    675            }
    676            if (ySize) { 
   \                     ??_DrawBitLine16BPP_Swap_1:
   \   0000006C   00005CE3           CMP      R12,#+0
   \   00000070   0400000A           BEQ      ??_DrawBitLine16BPP_Swap_3
    677          	  do {
    678                WRITE_MEM16P(pDest, *pData);
   \                     ??_DrawBitLine16BPP_Swap_4:
   \   00000074   B020D3E1           LDRH     R2,[R3, #+0]
    679                pData += WordsPerLine;
   \   00000078   803083E0           ADD      R3,R3,R0, LSL #+1
    680                pDest++;
    681              } while (--ySize);
   \   0000007C   01C05CE2           SUBS     R12,R12,#+1
   \   00000080   B220C1E0           STRH     R2,[R1], #+2
   \   00000084   FAFFFF1A           BNE      ??_DrawBitLine16BPP_Swap_4
    682            }
    683          }
   \                     ??_DrawBitLine16BPP_Swap_3:
   \   00000088   1080BDE8           POP      {R4,PC}          ;; return
    684          
    685          /*********************************************************************
    686          *
    687          *       _DrawBitmap
    688          */

   \                                 In section .text, align 4, keep-with-next
    689          static void _DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0,
    690                                 int xSize, int ySize,
    691                                 int BitsPerPixel, 
    692                                 int BytesPerLine,
    693                                 const U8 GUI_UNI_PTR * pData, int Diff,
    694                                 const LCD_PIXELINDEX* pTrans) {
   \                     _DrawBitmap:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   18D04DE2           SUB      SP,SP,#+24
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   44009DE5           LDR      R0,[SP, #+68]
   \   00000010   0190A0E1           MOV      R9,R1
    695            int i;
    696          
    697            //
    698            // Use _DrawBitLineXBPP and _DrawBitLineXBPP_Swap
    699            //
    700            switch (BitsPerPixel) {
   \   00000014   010040E2           SUB      R0,R0,#+1
   \   00000018   0270A0E1           MOV      R7,R2
   \   0000001C   40809DE5           LDR      R8,[SP, #+64]
   \   00000020   48509DE5           LDR      R5,[SP, #+72]
   \   00000024   4CB09DE5           LDR      R11,[SP, #+76]
   \   00000028   54609DE5           LDR      R6,[SP, #+84]
   \   0000002C   0F0050E3           CMP      R0,#+15
   \   00000030   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_DrawBitmap_0:
   \   00000034   E700008A           BHI      ??_DrawBitmap_1
   \   00000038   0E0000EA           B        ??_DrawBitmap_2
   \   0000003C   470000EA           B        ??_DrawBitmap_3
   \   00000040   E40000EA           B        ??_DrawBitmap_1
   \   00000044   6F0000EA           B        ??_DrawBitmap_4
   \   00000048   E20000EA           B        ??_DrawBitmap_1
   \   0000004C   E10000EA           B        ??_DrawBitmap_1
   \   00000050   E00000EA           B        ??_DrawBitmap_1
   \   00000054   950000EA           B        ??_DrawBitmap_5
   \   00000058   DE0000EA           B        ??_DrawBitmap_1
   \   0000005C   DD0000EA           B        ??_DrawBitmap_1
   \   00000060   DC0000EA           B        ??_DrawBitmap_1
   \   00000064   DB0000EA           B        ??_DrawBitmap_1
   \   00000068   DA0000EA           B        ??_DrawBitmap_1
   \   0000006C   D90000EA           B        ??_DrawBitmap_1
   \   00000070   D80000EA           B        ??_DrawBitmap_1
   \   00000074   B20000EA           B        ??_DrawBitmap_6
    701            case 1:
    702              xSize += Diff & 7;
   \                     ??_DrawBitmap_2:
   \   00000078   50209DE5           LDR      R2,[SP, #+80]
    703              for (i = Diff; i < xSize; i++) {
   \   0000007C   50A09DE5           LDR      R10,[SP, #+80]
   \   00000080   072002E2           AND      R2,R2,#0x7
   \   00000084   031082E0           ADD      R1,R2,R3
   \   00000088   18108DE5           STR      R1,[SP, #+24]
   \   0000008C   01005AE1           CMP      R10,R1
   \   00000090   D00000AA           BGE      ??_DrawBitmap_1
   \   00000094   0A1041E0           SUB      R1,R1,R10
   \   00000098   09908AE0           ADD      R9,R10,R9
   \   0000009C   14108DE5           STR      R1,[SP, #+20]
   \   000000A0   010011E3           TST      R1,#0x1
   \   000000A4   0B00000A           BEQ      ??_DrawBitmap_7
    704                _DrawBitLine1BPP_Swap(pDevice, x0 + i, y0, pData + (i >> 3), ySize, pTrans, BytesPerLine, i);
   \   000000A8   FF000AE2           AND      R0,R10,#0xFF
   \   000000AC   0C008DE5           STR      R0,[SP, #+12]
   \   000000B0   08508DE5           STR      R5,[SP, #+8]
   \   000000B4   04608DE5           STR      R6,[SP, #+4]
   \   000000B8   00808DE5           STR      R8,[SP, #+0]
   \   000000BC   CA318BE0           ADD      R3,R11,R10, ASR #+3
   \   000000C0   0720A0E1           MOV      R2,R7
   \   000000C4   0910A0E1           MOV      R1,R9
   \   000000C8   0400A0E1           MOV      R0,R4
   \   000000CC   ........           BL       _DrawBitLine1BPP_Swap
   \   000000D0   01A08AE2           ADD      R10,R10,#+1
   \   000000D4   019089E2           ADD      R9,R9,#+1
   \                     ??_DrawBitmap_7:
   \   000000D8   14109DE5           LDR      R1,[SP, #+20]
   \   000000DC   A110A0E1           LSR      R1,R1,#+1
   \   000000E0   10108DE5           STR      R1,[SP, #+16]
   \   000000E4   000051E3           CMP      R1,#+0
   \   000000E8   BA00000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_8:
   \   000000EC   FF000AE2           AND      R0,R10,#0xFF
   \   000000F0   0C008DE5           STR      R0,[SP, #+12]
   \   000000F4   08508DE5           STR      R5,[SP, #+8]
   \   000000F8   04608DE5           STR      R6,[SP, #+4]
   \   000000FC   00808DE5           STR      R8,[SP, #+0]
   \   00000100   CA318BE0           ADD      R3,R11,R10, ASR #+3
   \   00000104   0720A0E1           MOV      R2,R7
   \   00000108   0910A0E1           MOV      R1,R9
   \   0000010C   0400A0E1           MOV      R0,R4
   \   00000110   ........           BL       _DrawBitLine1BPP_Swap
   \   00000114   01A08AE2           ADD      R10,R10,#+1
   \   00000118   FF000AE2           AND      R0,R10,#0xFF
   \   0000011C   0C008DE5           STR      R0,[SP, #+12]
   \   00000120   08508DE5           STR      R5,[SP, #+8]
   \   00000124   04608DE5           STR      R6,[SP, #+4]
   \   00000128   00808DE5           STR      R8,[SP, #+0]
   \   0000012C   CA318BE0           ADD      R3,R11,R10, ASR #+3
   \   00000130   0720A0E1           MOV      R2,R7
   \   00000134   011089E2           ADD      R1,R9,#+1
   \   00000138   0400A0E1           MOV      R0,R4
   \   0000013C   ........           BL       _DrawBitLine1BPP_Swap
    705              }
   \   00000140   10109DE5           LDR      R1,[SP, #+16]
   \   00000144   01A08AE2           ADD      R10,R10,#+1
   \   00000148   011041E2           SUB      R1,R1,#+1
   \   0000014C   10108DE5           STR      R1,[SP, #+16]
   \   00000150   029089E2           ADD      R9,R9,#+2
   \   00000154   000051E3           CMP      R1,#+0
   \   00000158   E3FFFF1A           BNE      ??_DrawBitmap_8
   \   0000015C   9D0000EA           B        ??_DrawBitmap_1
    706              break;
    707            case 2:
    708              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_3:
   \   00000160   010058E3           CMP      R8,#+1
   \   00000164   9B0000BA           BLT      ??_DrawBitmap_1
   \   00000168   010018E3           TST      R8,#0x1
   \   0000016C   0800000A           BEQ      ??_DrawBitmap_9
    709                _DrawBitLine2BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   00000170   50009DE5           LDR      R0,[SP, #+80]
   \   00000174   04308DE5           STR      R3,[SP, #+4]
   \   00000178   00008DE5           STR      R0,[SP, #+0]
   \   0000017C   08608DE5           STR      R6,[SP, #+8]
   \   00000180   0B30A0E1           MOV      R3,R11
   \   00000184   0400A0E1           MOV      R0,R4
   \   00000188   ........           BL       _DrawBitLine2BPP
    710                pData += BytesPerLine;
   \   0000018C   0BB085E0           ADD      R11,R5,R11
   \   00000190   017087E2           ADD      R7,R7,#+1
   \                     ??_DrawBitmap_9:
   \   00000194   A880B0E1           LSRS     R8,R8,#+1
   \   00000198   8E00000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_10:
   \   0000019C   18009DE5           LDR      R0,[SP, #+24]
   \   000001A0   08608DE5           STR      R6,[SP, #+8]
   \   000001A4   04008DE5           STR      R0,[SP, #+4]
   \   000001A8   50009DE5           LDR      R0,[SP, #+80]
   \   000001AC   0B30A0E1           MOV      R3,R11
   \   000001B0   00008DE5           STR      R0,[SP, #+0]
   \   000001B4   0720A0E1           MOV      R2,R7
   \   000001B8   0910A0E1           MOV      R1,R9
   \   000001BC   0400A0E1           MOV      R0,R4
   \   000001C0   ........           BL       _DrawBitLine2BPP
   \   000001C4   18009DE5           LDR      R0,[SP, #+24]
   \   000001C8   0BA085E0           ADD      R10,R5,R11
   \   000001CC   04008DE5           STR      R0,[SP, #+4]
   \   000001D0   50009DE5           LDR      R0,[SP, #+80]
   \   000001D4   08608DE5           STR      R6,[SP, #+8]
   \   000001D8   00008DE5           STR      R0,[SP, #+0]
   \   000001DC   0A30A0E1           MOV      R3,R10
   \   000001E0   012087E2           ADD      R2,R7,#+1
   \   000001E4   0910A0E1           MOV      R1,R9
   \   000001E8   0400A0E1           MOV      R0,R4
   \   000001EC   ........           BL       _DrawBitLine2BPP
    711              }
   \   000001F0   018048E2           SUB      R8,R8,#+1
   \   000001F4   0AB085E0           ADD      R11,R5,R10
   \   000001F8   027087E2           ADD      R7,R7,#+2
   \   000001FC   000058E3           CMP      R8,#+0
   \   00000200   E5FFFF1A           BNE      ??_DrawBitmap_10
   \   00000204   730000EA           B        ??_DrawBitmap_1
    712              break;
    713            case 4:
    714              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_4:
   \   00000208   010058E3           CMP      R8,#+1
   \   0000020C   710000BA           BLT      ??_DrawBitmap_1
   \   00000210   010018E3           TST      R8,#0x1
   \   00000214   0800000A           BEQ      ??_DrawBitmap_11
    715                _DrawBitLine4BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   00000218   50009DE5           LDR      R0,[SP, #+80]
   \   0000021C   04308DE5           STR      R3,[SP, #+4]
   \   00000220   00008DE5           STR      R0,[SP, #+0]
   \   00000224   08608DE5           STR      R6,[SP, #+8]
   \   00000228   0B30A0E1           MOV      R3,R11
   \   0000022C   0400A0E1           MOV      R0,R4
   \   00000230   ........           BL       _DrawBitLine4BPP
    716                pData += BytesPerLine;
   \   00000234   0BB085E0           ADD      R11,R5,R11
   \   00000238   017087E2           ADD      R7,R7,#+1
   \                     ??_DrawBitmap_11:
   \   0000023C   A880B0E1           LSRS     R8,R8,#+1
   \   00000240   6400000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_12:
   \   00000244   18009DE5           LDR      R0,[SP, #+24]
   \   00000248   08608DE5           STR      R6,[SP, #+8]
   \   0000024C   04008DE5           STR      R0,[SP, #+4]
   \   00000250   50009DE5           LDR      R0,[SP, #+80]
   \   00000254   0B30A0E1           MOV      R3,R11
   \   00000258   00008DE5           STR      R0,[SP, #+0]
   \   0000025C   0720A0E1           MOV      R2,R7
   \   00000260   0910A0E1           MOV      R1,R9
   \   00000264   0400A0E1           MOV      R0,R4
   \   00000268   ........           BL       _DrawBitLine4BPP
   \   0000026C   18009DE5           LDR      R0,[SP, #+24]
   \   00000270   0BA085E0           ADD      R10,R5,R11
   \   00000274   04008DE5           STR      R0,[SP, #+4]
   \   00000278   50009DE5           LDR      R0,[SP, #+80]
   \   0000027C   08608DE5           STR      R6,[SP, #+8]
   \   00000280   00008DE5           STR      R0,[SP, #+0]
   \   00000284   0A30A0E1           MOV      R3,R10
   \   00000288   012087E2           ADD      R2,R7,#+1
   \   0000028C   0910A0E1           MOV      R1,R9
   \   00000290   0400A0E1           MOV      R0,R4
   \   00000294   ........           BL       _DrawBitLine4BPP
    717              }
   \   00000298   018048E2           SUB      R8,R8,#+1
   \   0000029C   0AB085E0           ADD      R11,R5,R10
   \   000002A0   027087E2           ADD      R7,R7,#+2
   \   000002A4   000058E3           CMP      R8,#+0
   \   000002A8   E5FFFF1A           BNE      ??_DrawBitmap_12
   \   000002AC   490000EA           B        ??_DrawBitmap_1
    718              break;
    719            case 8:
    720              for (i = 0; i < xSize; i++) {
   \                     ??_DrawBitmap_5:
   \   000002B0   010053E3           CMP      R3,#+1
   \   000002B4   470000BA           BLT      ??_DrawBitmap_1
   \   000002B8   03A0A0E1           MOV      R10,R3
   \   000002BC   01001AE3           TST      R10,#0x1
   \   000002C0   0700000A           BEQ      ??_DrawBitmap_13
    721                _DrawBitLine8BPP_Swap(pDevice, x0 + i, y0, pData + i, ySize, pTrans, BytesPerLine);
   \   000002C4   08508DE5           STR      R5,[SP, #+8]
   \   000002C8   04608DE5           STR      R6,[SP, #+4]
   \   000002CC   00808DE5           STR      R8,[SP, #+0]
   \   000002D0   0B30A0E1           MOV      R3,R11
   \   000002D4   0400A0E1           MOV      R0,R4
   \   000002D8   ........           BL       _DrawBitLine8BPP_Swap
   \   000002DC   019089E2           ADD      R9,R9,#+1
   \   000002E0   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_13:
   \   000002E4   AAA0B0E1           LSRS     R10,R10,#+1
   \   000002E8   3A00000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_14:
   \   000002EC   08508DE5           STR      R5,[SP, #+8]
   \   000002F0   04608DE5           STR      R6,[SP, #+4]
   \   000002F4   00808DE5           STR      R8,[SP, #+0]
   \   000002F8   0B30A0E1           MOV      R3,R11
   \   000002FC   0720A0E1           MOV      R2,R7
   \   00000300   0910A0E1           MOV      R1,R9
   \   00000304   0400A0E1           MOV      R0,R4
   \   00000308   ........           BL       _DrawBitLine8BPP_Swap
   \   0000030C   08508DE5           STR      R5,[SP, #+8]
   \   00000310   04608DE5           STR      R6,[SP, #+4]
   \   00000314   00808DE5           STR      R8,[SP, #+0]
   \   00000318   01308BE2           ADD      R3,R11,#+1
   \   0000031C   0720A0E1           MOV      R2,R7
   \   00000320   011089E2           ADD      R1,R9,#+1
   \   00000324   0400A0E1           MOV      R0,R4
   \   00000328   ........           BL       _DrawBitLine8BPP_Swap
    722              }
   \   0000032C   01A04AE2           SUB      R10,R10,#+1
   \   00000330   029089E2           ADD      R9,R9,#+2
   \   00000334   02B08BE2           ADD      R11,R11,#+2
   \   00000338   00005AE3           CMP      R10,#+0
   \   0000033C   EAFFFF1A           BNE      ??_DrawBitmap_14
   \   00000340   240000EA           B        ??_DrawBitmap_1
    723              break;
    724            case 16:
    725              for (i = Diff; i < xSize; i++) {
   \                     ??_DrawBitmap_6:
   \   00000344   50A09DE5           LDR      R10,[SP, #+80]
   \   00000348   03005AE1           CMP      R10,R3
   \   0000034C   210000AA           BGE      ??_DrawBitmap_1
   \   00000350   8A608BE0           ADD      R6,R11,R10, LSL #+1
   \   00000354   0AB043E0           SUB      R11,R3,R10
   \   00000358   01001BE3           TST      R11,#0x1
   \   0000035C   0700000A           BEQ      ??_DrawBitmap_15
    726                _DrawBitLine16BPP_Swap(pDevice, x0 + i, y0, (U16 *)(pData + (i << 1)), ySize, BytesPerLine);
   \   00000360   04508DE5           STR      R5,[SP, #+4]
   \   00000364   00808DE5           STR      R8,[SP, #+0]
   \   00000368   0630A0E1           MOV      R3,R6
   \   0000036C   09108AE0           ADD      R1,R10,R9
   \   00000370   0400A0E1           MOV      R0,R4
   \   00000374   ........           BL       _DrawBitLine16BPP_Swap
   \   00000378   01A08AE2           ADD      R10,R10,#+1
   \   0000037C   026086E2           ADD      R6,R6,#+2
   \                     ??_DrawBitmap_15:
   \   00000380   ABB0B0E1           LSRS     R11,R11,#+1
   \   00000384   1300000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_16:
   \   00000388   04508DE5           STR      R5,[SP, #+4]
   \   0000038C   00808DE5           STR      R8,[SP, #+0]
   \   00000390   0630A0E1           MOV      R3,R6
   \   00000394   0720A0E1           MOV      R2,R7
   \   00000398   09108AE0           ADD      R1,R10,R9
   \   0000039C   0400A0E1           MOV      R0,R4
   \   000003A0   ........           BL       _DrawBitLine16BPP_Swap
   \   000003A4   01A08AE2           ADD      R10,R10,#+1
   \   000003A8   04508DE5           STR      R5,[SP, #+4]
   \   000003AC   00808DE5           STR      R8,[SP, #+0]
   \   000003B0   023086E2           ADD      R3,R6,#+2
   \   000003B4   0720A0E1           MOV      R2,R7
   \   000003B8   09108AE0           ADD      R1,R10,R9
   \   000003BC   0400A0E1           MOV      R0,R4
   \   000003C0   ........           BL       _DrawBitLine16BPP_Swap
    727              }
   \   000003C4   01B04BE2           SUB      R11,R11,#+1
   \   000003C8   01A08AE2           ADD      R10,R10,#+1
   \   000003CC   046086E2           ADD      R6,R6,#+4
   \   000003D0   00005BE3           CMP      R11,#+0
   \   000003D4   EBFFFF1A           BNE      ??_DrawBitmap_16
    728              break;
    729            }
    730          }
   \                     ??_DrawBitmap_1:
   \   000003D8   1CD08DE2           ADD      SP,SP,#+28       ;; stack cleaning
   \   000003DC   F08FBDE8           POP      {R4-R11,PC}      ;; return
    731          
    732          /*********************************************************************
    733          *
    734          *       _SetOrg
    735          */

   \                                 In section .text, align 4, keep-with-next
    736          static void _SetOrg(GUI_DEVICE * pDevice, int x, int y) {
   \                     _SetOrg:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    737            LCD_X_SETORG_INFO Data = {0};
   \   00000004   ............       ADRL     R12,`?<Constant {0}>`
   \              ....        
   \   0000000C   0CD04DE2           SUB      SP,SP,#+12
   \   00000010   00409CE5           LDR      R4,[R12, #+0]
   \   00000014   04509CE5           LDR      R5,[R12, #+4]
   \   00000018   0D30A0E1           MOV      R3,SP
   \   0000001C   300083E8           STM      R3,{R4,R5}
    738          
    739            #ifdef WIN32
    740              LCDSIM_SetOrg(x, y, pDevice->LayerIndex);
    741            #else
    742              Data.xPos = y;
   \   00000020   00208DE5           STR      R2,[SP, #+0]
    743              Data.yPos = x;
   \   00000024   04108DE5           STR      R1,[SP, #+4]
    744              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETORG, (void *)&Data);
   \   00000028   0D20A0E1           MOV      R2,SP
   \   0000002C   0310A0E3           MOV      R1,#+3
   \   00000030   180090E5           LDR      R0,[R0, #+24]
   \   00000034   ........           BL       LCD_X_DisplayDriver
    745            #endif
    746          }
   \   00000038   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   0000003C   3080BDE8           POP      {R4,R5,PC}       ;; return
    747          
    748          /*********************************************************************
    749          *
    750          *       _InitOnce
    751          *
    752          * Purpose:
    753          *   Allocates a fixed block for the context of the driver
    754          *
    755          * Return value:
    756          *   0 on success, 1 on error
    757          */
    758          static int _InitOnce(GUI_DEVICE * pDevice) {
    759            if (pDevice->u.pContext == NULL) {
    760              pDevice->u.pContext = GUI_ALLOC_GetFixedBlock(sizeof(DRIVER_CONTEXT));
    761              GUI__memset((U8 *)pDevice->u.pContext, 0, sizeof(DRIVER_CONTEXT));
    762            }
    763            return pDevice->u.pContext ? 0 : 1;
    764          }
    765          
    766          /*********************************************************************
    767          *
    768          *       _GetRect
    769          */

   \                                 In section .text, align 4, keep-with-next
    770          static void _GetRect(GUI_DEVICE * pDevice, LCD_RECT * pRect) {
    771            DRIVER_CONTEXT * pContext;
    772          
    773            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetRect:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    774            pRect->x0 = 0;
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   B020C1E1           STRH     R2,[R1, #+0]
    775            pRect->y0 = 0;
   \   0000000C   B220C1E1           STRH     R2,[R1, #+2]
    776            pRect->x1 = pContext->vxSize - 1;
   \   00000010   0C2090E5           LDR      R2,[R0, #+12]
   \   00000014   012042E2           SUB      R2,R2,#+1
   \   00000018   B420C1E1           STRH     R2,[R1, #+4]
    777            pRect->y1 = pContext->vySize - 1;
   \   0000001C   100090E5           LDR      R0,[R0, #+16]
   \   00000020   010040E2           SUB      R0,R0,#+1
   \   00000024   B600C1E1           STRH     R0,[R1, #+6]
    778          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
    779          
    780          /*********************************************************************
    781          *
    782          *       _GetDevProp
    783          */

   \                                 In section .text, align 4, keep-with-next
    784          static I32 _GetDevProp(GUI_DEVICE * pDevice, int Index) {
    785            DRIVER_CONTEXT * pContext;
    786          
    787            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    788            switch (Index) {
   \                     _GetDevProp:
   \   00000000   011041E2           SUB      R1,R1,#+1
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   0D0051E3           CMP      R1,#+13
   \   0000000C   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevProp_0:
   \   00000010   1B00008A           BHI      ??_GetDevProp_1
   \   00000014   0C0000EA           B        ??_GetDevProp_2
   \   00000018   0D0000EA           B        ??_GetDevProp_3
   \   0000001C   0E0000EA           B        ??_GetDevProp_4
   \   00000020   0F0000EA           B        ??_GetDevProp_5
   \   00000024   160000EA           B        ??_GetDevProp_1
   \   00000028   150000EA           B        ??_GetDevProp_1
   \   0000002C   140000EA           B        ??_GetDevProp_1
   \   00000030   0D0000EA           B        ??_GetDevProp_6
   \   00000034   0E0000EA           B        ??_GetDevProp_7
   \   00000038   0F0000EA           B        ??_GetDevProp_8
   \   0000003C   0E0000EA           B        ??_GetDevProp_8
   \   00000040   0B0000EA           B        ??_GetDevProp_7
   \   00000044   0A0000EA           B        ??_GetDevProp_7
   \   00000048   0B0000EA           B        ??_GetDevProp_8
    789            case LCD_DEVCAP_XSIZE:
    790              return pContext->xSize;
   \                     ??_GetDevProp_2:
   \   0000004C   040090E5           LDR      R0,[R0, #+4]
   \   00000050   1EFF2FE1           BX       LR
    791            case LCD_DEVCAP_YSIZE:
    792              return pContext->ySize;
   \                     ??_GetDevProp_3:
   \   00000054   080090E5           LDR      R0,[R0, #+8]
   \   00000058   1EFF2FE1           BX       LR
    793            case LCD_DEVCAP_VXSIZE:
    794              return pContext->vxSize;
   \                     ??_GetDevProp_4:
   \   0000005C   0C0090E5           LDR      R0,[R0, #+12]
   \   00000060   1EFF2FE1           BX       LR
    795            case LCD_DEVCAP_VYSIZE:
    796              return pContext->vySize;
   \                     ??_GetDevProp_5:
   \   00000064   100090E5           LDR      R0,[R0, #+16]
   \   00000068   1EFF2FE1           BX       LR
    797            case LCD_DEVCAP_BITSPERPIXEL:
    798              return 16;
   \                     ??_GetDevProp_6:
   \   0000006C   1000A0E3           MOV      R0,#+16
   \   00000070   1EFF2FE1           BX       LR
    799            case LCD_DEVCAP_NUMCOLORS:
    800              return 0;
   \                     ??_GetDevProp_7:
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   1EFF2FE1           BX       LR
    801            case LCD_DEVCAP_XMAG:
    802              return 1;
   \                     ??_GetDevProp_8:
   \   0000007C   0100A0E3           MOV      R0,#+1
   \   00000080   1EFF2FE1           BX       LR
    803            case LCD_DEVCAP_YMAG:
    804              return 1;
    805            case LCD_DEVCAP_MIRROR_X:
    806              return 0;
    807            case LCD_DEVCAP_MIRROR_Y:
    808              return 0;
    809            case LCD_DEVCAP_SWAP_XY:
    810              return 1;
    811            }
    812            return -1;
   \                     ??_GetDevProp_1:
   \   00000084   0000E0E3           MVN      R0,#+0
   \   00000088   1EFF2FE1           BX       LR               ;; return
    813          }
    814          
    815          /*********************************************************************
    816          *
    817          *       _GetDevData
    818          */

   \                                 In section .text, align 4, keep-with-next
    819          static void * _GetDevData(GUI_DEVICE * pDevice, int Index) {
    820            GUI_USE_PARA(pDevice);
    821            switch (Index) {
   \                     _GetDevData:
   \   00000000   010051E3           CMP      R1,#+1
   \   00000004   0100001A           BNE      ??_GetDevData_0
    822            #if GUI_SUPPORT_MEMDEV
    823              case LCD_DEVDATA_MEMDEV:
    824                return (void *)&GUI_MEMDEV_DEVICE_16;
   \   00000008   ........           LDR      R0,??DataTable16
   \   0000000C   1EFF2FE1           BX       LR
    825            #endif
    826            }
    827            return NULL;
   \                     ??_GetDevData_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
    828          }
    829          
    830          /*********************************************************************
    831          *
    832          *       Static code: Functions available by _GetDevFunc()
    833          *
    834          **********************************************************************
    835          */
    836          /*********************************************************************
    837          *
    838          *       _SetVRAMAddr
    839          */

   \                                 In section .text, align 4, keep-with-next
    840          static void _SetVRAMAddr(GUI_DEVICE * pDevice, void * pVRAM) {
   \                     _SetVRAMAddr:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    841            DRIVER_CONTEXT * pContext;
    842            LCD_X_SETVRAMADDR_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {(void *)0}>`
   \              ....        
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   001091E5           LDR      R1,[R1, #+0]
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
    843          
    844            _InitOnce(pDevice);
   \   00000020   080094E5           LDR      R0,[R4, #+8]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0500001A           BNE      ??_SetVRAMAddr_0
   \   0000002C   2C00A0E3           MOV      R0,#+44
   \   00000030   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000034   080084E5           STR      R0,[R4, #+8]
   \   00000038   2C20A0E3           MOV      R2,#+44
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   ........           BL       GUI__memset
    845            if (pDevice->u.pContext) {
   \                     ??_SetVRAMAddr_0:
   \   00000044   080094E5           LDR      R0,[R4, #+8]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0500000A           BEQ      ??_SetVRAMAddr_1
    846              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    847              pContext->VRAMAddr = (U32)pVRAM;
   \   00000050   005080E5           STR      R5,[R0, #+0]
    848              Data.pVRAM = pVRAM;
   \   00000054   00508DE5           STR      R5,[SP, #+0]
    849              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVRAMADDR, (void *)&Data);
   \   00000058   0D20A0E1           MOV      R2,SP
   \   0000005C   0210A0E3           MOV      R1,#+2
   \   00000060   180094E5           LDR      R0,[R4, #+24]
   \   00000064   ........           BL       LCD_X_DisplayDriver
    850            }
    851            #ifdef WIN32
    852              SIM_Lin_SetVRAMAddr(pDevice->LayerIndex, pVRAM);
    853            #endif
    854          }
   \                     ??_SetVRAMAddr_1:
   \   00000068   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000006C   3080BDE8           POP      {R4,R5,PC}       ;; return
    855          
    856          /*********************************************************************
    857          *
    858          *       _SetVSize
    859          */

   \                                 In section .text, align 4, keep-with-next
    860          static void _SetVSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetVSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    861            DRIVER_CONTEXT * pContext;
    862          
    863            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetVSize_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
    864            if (pDevice->u.pContext) {
   \                     ??_SetVSize_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
    865              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    866              pContext->vxSize = xSize;
   \   0000003C   0C508015           STRNE    R5,[R0, #+12]
    867              pContext->vySize = ySize;
   \   00000040   10608015           STRNE    R6,[R0, #+16]
    868              pContext->vxSizePhys = ySize;
   \   00000044   14608015           STRNE    R6,[R0, #+20]
    869            }
    870            #ifdef WIN32
    871              SIM_Lin_SetVRAMSize(pDevice->LayerIndex, xSize, ySize);
    872            #endif
    873          }
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
    874          
    875          /*********************************************************************
    876          *
    877          *       _SetSize
    878          */

   \                                 In section .text, align 4, keep-with-next
    879          static void _SetSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    880            DRIVER_CONTEXT * pContext;
    881            LCD_X_SETSIZE_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_1`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
    882          
    883            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetSize_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
    884            if (pDevice->u.pContext) {
   \                     ??_SetSize_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0A00000A           BEQ      ??_SetSize_1
    885              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    886              if (pContext->vxSizePhys == 0) {
   \   0000005C   141090E5           LDR      R1,[R0, #+20]
    887                pContext->vxSizePhys = ySize;
    888              }
    889              pContext->xSize = xSize;
    890              pContext->ySize = ySize;
    891              Data.xSize = xSize;
    892              Data.ySize = ySize;
    893              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETSIZE, (void *)&Data);
   \   00000060   0D20A0E1           MOV      R2,SP
   \   00000064   000051E3           CMP      R1,#+0
   \   00000068   14608005           STREQ    R6,[R0, #+20]
   \   0000006C   045080E5           STR      R5,[R0, #+4]
   \   00000070   086080E5           STR      R6,[R0, #+8]
   \   00000074   00508DE5           STR      R5,[SP, #+0]
   \   00000078   04608DE5           STR      R6,[SP, #+4]
   \   0000007C   0710A0E3           MOV      R1,#+7
   \   00000080   180094E5           LDR      R0,[R4, #+24]
   \   00000084   ........           BL       LCD_X_DisplayDriver
    894            }
    895          }
   \                     ??_SetSize_1:
   \   00000088   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   0000008C   7080BDE8           POP      {R4-R6,PC}       ;; return
    896          
    897          /*********************************************************************
    898          *
    899          *       _SetPos
    900          */

   \                                 In section .text, align 4, keep-with-next
    901          static void _SetPos(GUI_DEVICE * pDevice, int xPos, int yPos) {
   \                     _SetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    902            DRIVER_CONTEXT * pContext;
    903            LCD_X_SETPOS_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_2`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
    904          
    905            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetPos_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
    906            if (pDevice->u.pContext) {
   \                     ??_SetPos_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0700000A           BEQ      ??_SetPos_1
    907              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    908              pContext->xPos = xPos;
   \   0000005C   185080E5           STR      R5,[R0, #+24]
    909              pContext->yPos = yPos;
   \   00000060   1C6080E5           STR      R6,[R0, #+28]
    910              Data.xPos = xPos;
   \   00000064   00508DE5           STR      R5,[SP, #+0]
    911              Data.yPos = yPos;
   \   00000068   04608DE5           STR      R6,[SP, #+4]
    912              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETPOS, (void *)&Data);
   \   0000006C   0D20A0E1           MOV      R2,SP
   \   00000070   0810A0E3           MOV      R1,#+8
   \   00000074   180094E5           LDR      R0,[R4, #+24]
   \   00000078   ........           BL       LCD_X_DisplayDriver
    913            }
    914          }
   \                     ??_SetPos_1:
   \   0000007C   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000080   7080BDE8           POP      {R4-R6,PC}       ;; return
    915          
    916          /*********************************************************************
    917          *
    918          *       _GetPos
    919          */

   \                                 In section .text, align 4, keep-with-next
    920          static void _GetPos(GUI_DEVICE * pDevice, int * pxPos, int * pyPos) {
   \                     _GetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    921            DRIVER_CONTEXT * pContext;
    922          
    923            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_GetPos_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
    924            if (pDevice->u.pContext) {
   \                     ??_GetPos_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0300000A           BEQ      ??_GetPos_1
    925              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    926              *pxPos = pContext->xPos;
   \   00000040   181090E5           LDR      R1,[R0, #+24]
   \   00000044   001085E5           STR      R1,[R5, #+0]
    927              *pyPos = pContext->yPos;
   \   00000048   1C0090E5           LDR      R0,[R0, #+28]
   \   0000004C   000086E5           STR      R0,[R6, #+0]
    928            }
    929          }
   \                     ??_GetPos_1:
   \   00000050   7080BDE8           POP      {R4-R6,PC}       ;; return
    930          
    931          /*********************************************************************
    932          *
    933          *       _SetAlpha
    934          */

   \                                 In section .text, align 4, keep-with-next
    935          static void _SetAlpha(GUI_DEVICE * pDevice, int Alpha) {
   \                     _SetAlpha:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    936            DRIVER_CONTEXT * pContext;
    937            LCD_X_SETALPHA_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_3`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
    938          
    939            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetAlpha_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
    940            if (pDevice->u.pContext) {
   \                     ??_SetAlpha_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetAlpha_1
    941              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    942              pContext->Alpha = Alpha;
   \   0000004C   205080E5           STR      R5,[R0, #+32]
    943              Data.Alpha = Alpha;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
    944              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHA, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0A10A0E3           MOV      R1,#+10
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
    945            }
    946          }
   \                     ??_SetAlpha_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
    947          
    948          /*********************************************************************
    949          *
    950          *       _SetVis
    951          */

   \                                 In section .text, align 4, keep-with-next
    952          static void _SetVis(GUI_DEVICE * pDevice, int OnOff) {
   \                     _SetVis:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    953            DRIVER_CONTEXT * pContext;
    954            LCD_X_SETVIS_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_4`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
    955          
    956            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetVis_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
    957            if (pDevice->u.pContext) {
   \                     ??_SetVis_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetVis_1
    958              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    959              pContext->IsVisible = OnOff;
   \   0000004C   245080E5           STR      R5,[R0, #+36]
    960              Data.OnOff = OnOff;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
    961              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVIS, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0910A0E3           MOV      R1,#+9
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
    962            }
    963          }
   \                     ??_SetVis_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
    964          
    965          /*********************************************************************
    966          *
    967          *       _Init
    968          */

   \                                 In section .text, align 4, keep-with-next
    969          static int  _Init(GUI_DEVICE * pDevice) {
   \                     _Init:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    970            int r;
    971          
    972            r = _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0500001A           BNE      ??_Init_0
   \   00000018   2C00A0E3           MOV      R0,#+44
   \   0000001C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000020   080084E5           STR      R0,[R4, #+8]
   \   00000024   2C20A0E3           MOV      R2,#+44
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   ........           BL       GUI__memset
   \                     ??_Init_0:
   \   00000030   080094E5           LDR      R0,[R4, #+8]
    973            r |= LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_INITCONTROLLER, NULL);
    974            return r;
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0150A003           MOVEQ    R5,#+1
   \   00000040   0050A013           MOVNE    R5,#+0
   \   00000044   0110A0E3           MOV      R1,#+1
   \   00000048   180094E5           LDR      R0,[R4, #+24]
   \   0000004C   ........           BL       LCD_X_DisplayDriver
   \   00000050   050080E1           ORR      R0,R0,R5
   \   00000054   04D08DE2           ADD      SP,SP,#+4
   \   00000058   3080BDE8           POP      {R4,R5,PC}       ;; return
    975          }
    976          
    977          /*********************************************************************
    978          *
    979          *       _On
    980          */

   \                                 In section .text, align 4, keep-with-next
    981          static void _On (GUI_DEVICE * pDevice) {
    982            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_ON, NULL);
   \                     _On:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0510A0E3           MOV      R1,#+5
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
    983          }
    984          
    985          /*********************************************************************
    986          *
    987          *       _Off
    988          */

   \                                 In section .text, align 4, keep-with-next
    989          static void _Off (GUI_DEVICE * pDevice) {
    990            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_OFF, NULL);
   \                     _Off:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0610A0E3           MOV      R1,#+6
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
    991          }
    992          
    993          /*********************************************************************
    994          *
    995          *       _SetLUTEntry
    996          */

   \                                 In section .text, align 4, keep-with-next
    997          static void _SetLUTEntry(GUI_DEVICE * pDevice, U8 Pos, LCD_COLOR Color) {
   \                     _SetLUTEntry:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    998            LCD_X_SETLUTENTRY_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
    999          
   1000            Data.Pos   = Pos;
   \   0000001C   0410CDE5           STRB     R1,[SP, #+4]
   1001            Data.Color = Color;
   \   00000020   00208DE5           STR      R2,[SP, #+0]
   1002            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETLUTENTRY, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0410A0E3           MOV      R1,#+4
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
   1003          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
   1004          
   1005          /*********************************************************************
   1006          *
   1007          *       _SetAlphaMode
   1008          */

   \                                 In section .text, align 4, keep-with-next
   1009          static void _SetAlphaMode(GUI_DEVICE * pDevice, int AlphaMode) {
   \                     _SetAlphaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1010            LCD_X_SETALPHAMODE_INFO Data = {0};
   1011          
   1012            Data.AlphaMode = AlphaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
   1013            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0B10A0E3           MOV      R1,#+11
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
   1014          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1015          
   1016          /*********************************************************************
   1017          *
   1018          *       _SetChromaMode
   1019          */

   \                                 In section .text, align 4, keep-with-next
   1020          static void _SetChromaMode(GUI_DEVICE * pDevice, int ChromaMode) {
   \                     _SetChromaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1021            LCD_X_SETCHROMAMODE_INFO Data = {0};
   1022          
   1023            Data.ChromaMode = ChromaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
   1024            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0C10A0E3           MOV      R1,#+12
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
   1025          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1026          
   1027          /*********************************************************************
   1028          *
   1029          *       _SetChroma
   1030          */

   \                                 In section .text, align 4, keep-with-next
   1031          static void _SetChroma(GUI_DEVICE * pDevice, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax) {
   \                     _SetChroma:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1032            LCD_X_SETCHROMA_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>_1`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
   1033          
   1034            Data.ChromaMin = ChromaMin;
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
   1035            Data.ChromaMax = ChromaMax;
   \   00000020   04208DE5           STR      R2,[SP, #+4]
   1036            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMA, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0D10A0E3           MOV      R1,#+13
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
   1037          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
   1038          
   1039          /*********************************************************************
   1040          *
   1041          *       _SetFunc
   1042          */

   \                                 In section .text, align 4, keep-with-next
   1043          static void _SetFunc(GUI_DEVICE * pDevice, int Index, void (* pFunc)(void)) {
   \                     _SetFunc:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1044            DRIVER_CONTEXT * pContext;
   1045          
   1046            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetFunc_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
   1047            if (pDevice->u.pContext) {
   \                     ??_SetFunc_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0100000A           BEQ      ??_SetFunc_1
   1048              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1049              switch (Index) {
   \   00000040   170055E3           CMP      R5,#+23
   1050              case LCD_DEVFUNC_FILLRECT:
   1051                pContext->pfFillRect = (void (*)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex))pFunc;
   \   00000044   28608005           STREQ    R6,[R0, #+40]
   1052                break;
   1053              }
   1054            }
   1055          }
   \                     ??_SetFunc_1:
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1056          
   1057          /*********************************************************************
   1058          *
   1059          *       _GetDevFunc
   1060          */

   \                                 In section .text, align 4, keep-with-next
   1061          static void (* _GetDevFunc(GUI_DEVICE ** ppDevice, int Index))(void) {
   1062            GUI_USE_PARA(ppDevice);
   1063            switch (Index) {
   \                     _GetDevFunc:
   \   00000000   021041E2           SUB      R1,R1,#+2
   \   00000004   140051E3           CMP      R1,#+20
   \   00000008   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevFunc_0:
   \   0000000C   1400008A           BHI      ??_GetDevFunc_1
   \   00000010   1F0000EA           B        ??_GetDevFunc_2
   \   00000014   1A0000EA           B        ??_GetDevFunc_3
   \   00000018   1B0000EA           B        ??_GetDevFunc_4
   \   0000001C   100000EA           B        ??_GetDevFunc_1
   \   00000020   1D0000EA           B        ??_GetDevFunc_5
   \   00000024   0E0000EA           B        ??_GetDevFunc_1
   \   00000028   0D0000EA           B        ??_GetDevFunc_1
   \   0000002C   0E0000EA           B        ??_GetDevFunc_6
   \   00000030   0F0000EA           B        ??_GetDevFunc_7
   \   00000034   100000EA           B        ??_GetDevFunc_8
   \   00000038   190000EA           B        ??_GetDevFunc_9
   \   0000003C   080000EA           B        ??_GetDevFunc_1
   \   00000040   190000EA           B        ??_GetDevFunc_10
   \   00000044   1A0000EA           B        ??_GetDevFunc_11
   \   00000048   1B0000EA           B        ??_GetDevFunc_12
   \   0000004C   040000EA           B        ??_GetDevFunc_1
   \   00000050   030000EA           B        ??_GetDevFunc_1
   \   00000054   1A0000EA           B        ??_GetDevFunc_13
   \   00000058   1B0000EA           B        ??_GetDevFunc_14
   \   0000005C   1C0000EA           B        ??_GetDevFunc_15
   \   00000060   1D0000EA           B        ??_GetDevFunc_16
   1064            case LCD_DEVFUNC_READRECT:
   1065              return (void (*)(void))NULL;
   \                     ??_GetDevFunc_1:
   \   00000064   0000A0E3           MOV      R0,#+0
   \   00000068   1EFF2FE1           BX       LR
   1066            case LCD_DEVFUNC_SET_VRAM_ADDR:
   1067              return (void (*)(void))_SetVRAMAddr;
   \                     ??_GetDevFunc_6:
   \   0000006C   ........           LDR      R0,??DataTable16_1
   \   00000070   1EFF2FE1           BX       LR
   1068            case LCD_DEVFUNC_SET_VSIZE:
   1069              return (void (*)(void))_SetVSize;
   \                     ??_GetDevFunc_7:
   \   00000074   ........           LDR      R0,??DataTable16_2
   \   00000078   1EFF2FE1           BX       LR
   1070            case LCD_DEVFUNC_SET_SIZE:
   1071              return (void (*)(void))_SetSize;
   \                     ??_GetDevFunc_8:
   \   0000007C   ........           LDR      R0,??DataTable16_3
   \   00000080   1EFF2FE1           BX       LR
   1072            case LCD_DEVFUNC_SETPOS:
   1073              return (void (*)(void))_SetPos;
   \                     ??_GetDevFunc_3:
   \   00000084   ........           LDR      R0,??DataTable16_4
   \   00000088   1EFF2FE1           BX       LR
   1074            case LCD_DEVFUNC_GETPOS:
   1075              return (void (*)(void))_GetPos;
   \                     ??_GetDevFunc_4:
   \   0000008C   ........           LDR      R0,??DataTable16_5
   \   00000090   1EFF2FE1           BX       LR
   1076            case LCD_DEVFUNC_SETALPHA:
   1077              return (void (*)(void))_SetAlpha;
   \                     ??_GetDevFunc_2:
   \   00000094   ........           LDR      R0,??DataTable16_6
   \   00000098   1EFF2FE1           BX       LR
   1078            case LCD_DEVFUNC_SETVIS:
   1079              return (void (*)(void))_SetVis;
   \                     ??_GetDevFunc_5:
   \   0000009C   ........           LDR      R0,??DataTable16_7
   \   000000A0   1EFF2FE1           BX       LR
   1080            case LCD_DEVFUNC_INIT:
   1081              return (void (*)(void))_Init;
   \                     ??_GetDevFunc_9:
   \   000000A4   ........           LDR      R0,??DataTable16_8
   \   000000A8   1EFF2FE1           BX       LR
   1082            case LCD_DEVFUNC_ON:
   1083              return (void (*)(void))_On;
   \                     ??_GetDevFunc_10:
   \   000000AC   ........           LDR      R0,??DataTable16_9
   \   000000B0   1EFF2FE1           BX       LR
   1084            case LCD_DEVFUNC_OFF:
   1085              return (void (*)(void))_Off;
   \                     ??_GetDevFunc_11:
   \   000000B4   ........           LDR      R0,??DataTable16_10
   \   000000B8   1EFF2FE1           BX       LR
   1086            case LCD_DEVFUNC_SETLUTENTRY:
   1087              return (void (*)(void))_SetLUTEntry;
   \                     ??_GetDevFunc_12:
   \   000000BC   ........           LDR      R0,??DataTable16_11
   \   000000C0   1EFF2FE1           BX       LR
   1088          
   1089            case LCD_DEVFUNC_ALPHAMODE:
   1090              return (void (*)(void))_SetAlphaMode;
   \                     ??_GetDevFunc_13:
   \   000000C4   ........           LDR      R0,??DataTable16_12
   \   000000C8   1EFF2FE1           BX       LR
   1091            case LCD_DEVFUNC_CHROMAMODE:
   1092              return (void (*)(void))_SetChromaMode;
   \                     ??_GetDevFunc_14:
   \   000000CC   ........           LDR      R0,??DataTable16_13
   \   000000D0   1EFF2FE1           BX       LR
   1093            case LCD_DEVFUNC_CHROMA:
   1094              return (void (*)(void))_SetChroma;
   \                     ??_GetDevFunc_15:
   \   000000D4   ........           LDR      R0,??DataTable16_14
   \   000000D8   1EFF2FE1           BX       LR
   1095            
   1096            case LCD_DEVFUNC_SETFUNC:
   1097              return (void (*)(void))_SetFunc;
   \                     ??_GetDevFunc_16:
   \   000000DC   ........           LDR      R0,??DataTable16_15
   \   000000E0   1EFF2FE1           BX       LR               ;; return
   1098            }
   1099            return NULL;
   1100          }
   1101          
   1102          /*********************************************************************
   1103          *
   1104          *       Public data
   1105          *
   1106          **********************************************************************
   1107          */
   1108          /*********************************************************************
   1109          *
   1110          *       GUI_DEVICE_API structure
   1111          */

   \                                 In section .rodata, align 4, keep-with-next
   1112          const GUI_DEVICE_API GUIDRV_Lin_OS_16_API = {
   \                     GUIDRV_Lin_OS_16_API:
   \   00000000                      ; Initializer data, 52 bytes
   \   00000000   00000000....       DC32 0, _DrawBitmap, _DrawHLine, _DrawVLine, _FillRect, _GetPixelIndex, _SetPixelIndex, _XorPixel, _SetOrg, _GetDevFunc
   \              ............
   \              ............
   \              ............
   \              ............
   \              ............
   \              ........    
   \   00000028   ............       DC32 _GetDevProp, _GetDevData, _GetRect
   \              ............

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     GUI_MEMDEV_DEVICE_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   ........           DC32     _SetVRAMAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   ........           DC32     _SetVSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   ........           DC32     _SetSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   ........           DC32     _SetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   ........           DC32     _GetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   ........           DC32     _SetAlpha

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   ........           DC32     _SetVis

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   ........           DC32     _Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   ........           DC32     _On

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   ........           DC32     _Off

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   ........           DC32     _SetLUTEntry

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   ........           DC32     _SetAlphaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   ........           DC32     _SetChromaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   ........           DC32     _SetChroma

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   ........           DC32     _SetFunc

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {(void *)0}>`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_2`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_3`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_4`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0
   1113            //
   1114            // Data
   1115            //
   1116            DEVICE_CLASS_DRIVER,
   1117            //
   1118            // Drawing functions
   1119            //
   1120            _DrawBitmap,
   1121            _DrawHLine,
   1122            _DrawVLine,
   1123            _FillRect,
   1124            _GetPixelIndex,
   1125            _SetPixelIndex,
   1126            _XorPixel,
   1127            //
   1128            // Set origin
   1129            //
   1130            _SetOrg,
   1131            //
   1132            // Request information
   1133            //
   1134            _GetDevFunc,
   1135            _GetDevProp,
   1136            _GetDevData,
   1137            _GetRect,
   1138          };
   1139          
   1140          #else
   1141          
   1142          void GUIDRV_Lin_OS_16_C(void);   // Avoid empty object files
   1143          void GUIDRV_Lin_OS_16_C(void) {}
   1144          
   1145          #endif
   1146          
   1147          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     _DrawBitLine16BPP_Swap      8
     _DrawBitLine1BPP_Swap      40
     _DrawBitLine2BPP           32
     _DrawBitLine4BPP           32
     _DrawBitLine8BPP_Swap      12
     _DrawBitmap                64
     _DrawHLine                 24
     _DrawVLine                 24
     _FillRect                  24
     _GetDevData                 0
     _GetDevFunc                 0
     _GetDevProp                 0
     _GetPixelIndex              0
     _GetPos                    16
     _GetRect                    0
     _Init                      16
     _Off                        8
     _On                         8
     _SetAlpha                  16
     _SetAlphaMode               8
     _SetChroma                 24
     _SetChromaMode              8
     _SetFunc                   16
     _SetLUTEntry               24
     _SetOrg                    24
     _SetPixelIndex              0
     _SetPos                    24
     _SetSize                   24
     _SetVRAMAddr               16
     _SetVSize                  16
     _SetVis                    16
     _XorPixel                  24


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     _SetPixelIndex            28
     _GetPixelIndex            28
     _XorPixel                 92
     _DrawHLine               184
     _DrawVLine               320
     _FillRect                 68
     _DrawBitLine1BPP_Swap    492
     _DrawBitLine2BPP         412
     _DrawBitLine4BPP         412
     _DrawBitLine8BPP_Swap    356
     _DrawBitLine16BPP_Swap   140
     _DrawBitmap              992
     _SetOrg                   64
     _GetRect                  44
     _GetDevProp              140
     _GetDevData               24
     _SetVRAMAddr             112
     _SetVSize                 76
     _SetSize                 144
     _SetPos                  132
     _GetPos                   84
     _SetAlpha                108
     _SetVis                  108
     _Init                     92
     _On                       16
     _Off                      16
     _SetLUTEntry              60
     _SetAlphaMode             36
     _SetChromaMode            36
     _SetChroma                60
     _SetFunc                  76
     _GetDevFunc              228
     GUIDRV_Lin_OS_16_API      52
     ??DataTable15              4
     ??DataTable15_1            4
     ??DataTable16              4
     ??DataTable16_1            4
     ??DataTable16_2            4
     ??DataTable16_3            4
     ??DataTable16_4            4
     ??DataTable16_5            4
     ??DataTable16_6            4
     ??DataTable16_7            4
     ??DataTable16_8            4
     ??DataTable16_9            4
     ??DataTable16_10           4
     ??DataTable16_11           4
     ??DataTable16_12           4
     ??DataTable16_13           4
     ??DataTable16_14           4
     ??DataTable16_15           4
     ?<Constant {0}>            8
     ?<Constant {(void *)0}>    4
     ?<Constant {0}>_1          8
     ?<Constant {0}>_2          8
     ?<Constant {0}>_3          4
     ?<Constant {0}>_4          4
     ?<Constant {0L}>           8
     ?<Constant {0L}>_1         8

 
    52 bytes in section .rodata
 5 304 bytes in section .text
 
 5 304 bytes of CODE  memory
    52 bytes of CONST memory

Errors: none
Warnings: none
