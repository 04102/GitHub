###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:12:12 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\FS\MMC_Drv.c                            #
#    Command line =  C:\DUII\TargetHW\FS\MMC_Drv.c -D DEBUG=1 -D              #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\MMC_Drv.lst                #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\MMC_Drv.o                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\FS\MMC_Drv.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          **** emFile file system for embedded applications ****
     13          emFile is protected by international copyright laws. Knowledge of the
     14          source code may not be used to write a similar product. This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : MMC_Drv.c
     19          Purpose     : File system generic MMC/SD driver using SPI mode
     20          ---------------------------END-OF-HEADER------------------------------
     21          
     22          Literature:
     23          [1]  SD Specifications, Part 1, PHYSICAL LAYER, Simplified Specification Version 2.00, September 25, 2006
     24          [2]  The MultiMediaCard System Specification Version 3.2
     25          [3]  SD Specifications, Part 1, PHYSICAL LAYER Specification, Version 2.00, May 9, 2006
     26          */
     27          
     28          /*********************************************************************
     29          *
     30          *             #include Section
     31          *
     32          **********************************************************************
     33          */
     34          
     35          #include <stdio.h>
     36          
     37          #include "FS_Int.h"
     38          #include "MMC_X_HW.h"
     39          
     40          /*********************************************************************
     41          *
     42          *       Config defaults
     43          *
     44          **********************************************************************
     45          */
     46          
     47          #ifdef FS_MMC_MAXUNIT
     48            #define NUM_UNITS FS_MMC_MAXUNIT
     49          #else
     50            #define NUM_UNITS   1
     51          #endif
     52          
     53          #ifndef   FS_MMC_SUPPORT_HIGH_SPEED
     54            #define FS_MMC_SUPPORT_HIGH_SPEED           0                   // Support for high-speed mode for SD card in SPI mode is currently disabled
     55                                                                            // and shall not be activated yet. For some reason different SD-HC cards do not
     56                                                                            // answer or return with an illegal command which needs to be further investigated.
     57                                                                            // Such cards are: SanDisk extremeIII 16GB SDHC, extreme memory 8GB performance,
     58                                                                            //                 Transcend miniSD-HC 16GB
     59          #endif
     60          
     61          #ifndef    FS_MMC_NUM_RETRIES
     62            #define  FS_MMC_NUM_RETRIES      3
     63          #endif
     64          
     65          /*********************************************************************
     66          *
     67          *             #define constants
     68          *
     69          **********************************************************************
     70          */
     71          /* Default sector size */
     72          #define BYTES_PER_SECTOR       (512)
     73          
     74          /* Time-out values. The maximum read/write timeout values are documented in
     75           * [1]: 4.6.2 Read, Write and Erase Timeout Conditions.
     76           */
     77          #define NAC_CSD_MAX             (50000) /* max read cycles for CSD read */
     78          #define TIME_NAC_READ_MAX       (100000) /* max read time (usec) */
     79          #define TIME_NAC_WRITE_MAX      (250000) /* max write time (usec) */
     80          #define TIME_NCR_MAX            (8)
     81          
     82          /* hardware specific defines */
     83          #define VOLT_LOWMIN             (1650)  /* Low Voltage mode minimum value */
     84          #define VOLT_LOWMAX             (1950)  /* Low Voltage mode maximum value */
     85          #define STARTUPFREQ              (400)  /* Max. startup frequency (KHz) */
     86          /*
     87            The following constant defines the number of empty byte cycles that are transferred to
     88            the card before any command is issued. Referring to the specifications of SDA, this period
     89            must be at least 74 cycles, but it is recommended to send more that just the minimum value.
     90            The value here is a byte count so is multiplied by 8 to get cycle count.
     91          */
     92          #define BOOTUPCYCLES            (10) /* Cycles sent to the card before initialization starts */
     93          #define MAX_RETRIES             (5)
     94          
     95          #define CARD_TYPE_MMC           (0)
     96          #define CARD_TYPE_SD            (1)
     97          #define CARD_TYPE_SDHC          (2)
     98          /*********************************************************************
     99          *
    100          *       MMC/SD response tokens
    101          */
    102          #define TOKEN_MULTI_BLOCK_WRITE_START     0xFC
    103          #define TOKEN_MULTI_BLOCK_WRITE_STOP      0xFD
    104          #define TOKEN_BLOCK_READ_START            0xFE                   /* read start token */
    105          #define TOKEN_BLOCK_WRITE_START           0xFE                   /* write start token */
    106          #define TOKEN_MULTI_BLOCK_READ_START      0xFE
    107          
    108          /*********************************************************************
    109          *
    110          *       MMC/SD card commands
    111          */
    112          #define CMD_GO_IDLE_STATE         0
    113          #define CMD_SEND_OP_COND          1
    114          #define CMD_ALL_SEND_CID          2
    115          #define CMD_SET_REL_ADDR          3
    116          #define CMD_SWITCH_FUNC           6
    117          #define CMD_SELECT_CARD           7
    118          #define CMD_SEND_IF_COND          8
    119          #define CMD_SEND_CSD              9
    120          #define CMD_SEND_CID             10
    121          #define CMD_STOP_TRANSMISSION    12
    122          #define CMD_SEND_STATUS          13
    123          #define CMD_SET_BLOCKLEN         16
    124          #define CMD_READ_SINGLE_BLOCK    17
    125          #define CMD_READ_MULTIPLE_BLOCKS 18
    126          #define CMD_WRITE_BLOCK          24
    127          #define CMD_WRITE_MULTIPLE_BLOCK 25
    128          #define CMD_ACMD_CMD             55
    129          #define CMD_READ_OCR             58
    130          #define ACMD_SEND_OP_COND        41
    131          #define ACMD_SEND_SCR            51
    132          
    133          #define CMD_LEN                   6
    134          
    135          #define SD_SPEC_VER_100           0
    136          #define SD_SPEC_VER_110           1
    137          #define SD_SPEC_VER_200           2
    138          
    139          /*********************************************************************
    140          *
    141          *       CSD register access macros
    142          */
    143          #define CSD_STRUCTURE(pCSD)            _GetFromCSD(pCSD, 126, 127)
    144          #define CSD_WRITE_PROTECT(pCSD)        _GetFromCSD(pCSD,  12,  13)
    145          #define CSD_CCC_CLASSES(pCSD)          _GetFromCSD(pCSD,  84,  95)
    146          #define CSD_FILE_FORMAT_GRP(pCSD)      _GetFromCSD(pCSD,  15,  15)
    147          #define CSD_WRITE_BL_LEN(pCSD)         _GetFromCSD(pCSD,  22,  25)
    148          #define CSD_R2W_FACTOR(pCSD)           _GetFromCSD(pCSD,  26,  28)
    149          #define CSD_C_SIZE_MULT(pCSD)          _GetFromCSD(pCSD,  47,  49)
    150          #define CSD_C_SIZE(pCSD)               _GetFromCSD(pCSD,  62,  73)
    151          #define CSD_READ_BL_LEN(pCSD)          _GetFromCSD(pCSD,  80,  83)
    152          #define CSD_TRAN_SPEED(pCSD)           (pCSD->aData[3])   // Same as, but more efficient than: _GetFromCSD(pCSD,  96, 103)
    153          #define CSD_NSAC(pCSD)                 (pCSD->aData[2])   // Same as, but more efficient than: _GetFromCSD(pCSD, 104, 111)
    154          #define CSD_TAAC(pCSD)                 (pCSD->aData[1])   // Same as, but more efficient than: _GetFromCSD(pCSD, 112, 119)
    155          #define CSD_C_SIZE_V2(pCSD)            _GetFromCSD(pCSD,  48, 69)
    156          
    157          /*********************************************************************
    158          *
    159          *       Types
    160          *
    161          **********************************************************************
    162          */
    163          typedef struct {           /* CSD register structure */
    164            U8 aData[16];            /* Size is 128 bit */
    165          } CSD;
    166          
    167          typedef struct {
    168            U8           IsInited;
    169            U8           IsWriteProtected;
    170            U8           Unit;
    171            U8           CardType;
    172            U16          BytesPerSector;
    173            U32          NumSectors;
    174            U32          Nac;
    175            U32          Nwrite;
    176          } MMC_INST;
    177          
    178          /*********************************************************************
    179          *
    180          *       Prototypes
    181          *
    182          **********************************************************************
    183          */
    184          static U16 _CalcDataCRC16Dummy   (const U8 * p, unsigned NumBytes);
    185          
    186          /*********************************************************************
    187          *
    188          *       Static data
    189          *
    190          **********************************************************************
    191          */

   \                                 In section .bss, align 4
    192          static MMC_INST * _apInst[NUM_UNITS];                                           // per Unit card info
   \                     _apInst:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
    193          static int        _NumUnits;

   \                                 In section .data, align 4
    194          static U16 (*_pfCalcCRC)(const U8 * p, unsigned NumBytes) = _CalcDataCRC16Dummy;  // Function pointer for CRC check code for all cards
   \                     _pfCalcCRC:
   \   00000000   ........           DC32 _CalcDataCRC16Dummy
    195          
    196          /*********************************************************************
    197          *
    198          *       static const
    199          *
    200          **********************************************************************
    201          */
    202          
    203          /* Time value conversion factors for CSD TAAC and TRAN_SPEED values from
    204           * [1]: 5.3.2. Values here are 10x the spec values.
    205           */

   \                                 In section .text, align 4, keep-with-next
    206          static const U8 _aFactor[16] = {
   \                     _aFactor:
   \   00000000                      ; Initializer data, 16 bytes
   \   00000000   000A0C0D0F14       DC8 0, 10, 12, 13, 15, 20, 25, 30, 35, 40
   \              191E2328    
   \   0000000A   2D32373C4150       DC8 45, 50, 55, 60, 65, 80
    207            0,    /* 0: reserved - not supported */
    208            10,   /* 1 */
    209            12,   /* 2 */
    210            13,   /* 3 */
    211            15,   /* 4 */
    212            20,   /* 5 */
    213            25,   /* 6 */
    214            30,   /* 7 */
    215            35,   /* 8 */
    216            40,   /* 9 */
    217            45,   /* 10 */
    218            50,   /* 11 */
    219            55,   /* 12 */
    220            60,   /* 13 */
    221            65,   /* 14 */
    222            80    /* 15 */
    223          };
    224          
    225          /* Time unit conversion factors for CSD TAAC values from [1]: 5.3.2.
    226           * Values here are divisors that are 1/100 of the spec values (ie. the
    227           * result of dividing by them is 100 times larger than it should be).
    228           */

   \                                 In section .text, align 4, keep-with-next
    229          static const U32 _aUnit[8] = {
   \                     _aUnit:
   \   00000000                      ; Initializer data, 32 bytes
   \   00000000   809698004042       DC32 10000000, 1000000, 100000, 10000, 1000, 100, 10, 1
   \              0F00A0860100
   \              10270000E803
   \              000064000000
   \              0A0000000100
   \              0000        
    230            10000000UL,  /* 0 -   1ns */
    231            1000000UL,   /* 1 -  10ns */
    232            100000UL,    /* 2 - 100ns */
    233            10000UL,     /* 3 -   1us */
    234            1000UL,      /* 4 -  10us */
    235            100UL,       /* 5 - 100us */
    236            10UL,        /* 6 -   1ms */
    237            1UL,         /* 7 -  10ms */
    238          };
    239          
    240          /* Transfer rate conversion factors for CSD TRAN_SPEED values from [1]: 5.3.2.
    241           * Values here are multipliers that are 1/10 the value needed to convert to
    242           * kbits/s.
    243           */

   \                                 In section .text, align 4, keep-with-next
    244          static const U32 _aRateUnit[4] = {
   \                     _aRateUnit:
   \   00000000                      ; Initializer data, 16 bytes
   \   00000000   0A0000006400       DC32 10, 100, 1000, 10000
   \              0000E8030000
   \              10270000    
    245            10UL,        /* 0 - 100 kbits/s */
    246            100UL,       /* 1 -   1 Mbits/s */
    247            1000UL,      /* 2 -  10 Mbits/s */
    248            10000UL,     /* 3 - 100 Mbits/s */
    249          };
    250          
    251          
    252          /*********************************************************************
    253          *
    254          *       Static code
    255          *
    256          **********************************************************************
    257          */
    258          
    259          
    260          /*********************************************************************
    261          *
    262          *       _GetBits
    263          *
    264          *  Function description
    265          *    Returns a value from the bit field.
    266          */
    267          static unsigned _GetBits(const U8 * pData, unsigned FirstBit, unsigned LastBit, unsigned NumBytesAvailable) {
    268            unsigned Off;
    269            unsigned OffLast;
    270            unsigned NumBytes;
    271            U32 Data;
    272          
    273          
    274            Off      = FirstBit / 8;
    275            OffLast  = LastBit / 8;
    276            NumBytes = OffLast - Off + 1;
    277            Off      = (NumBytesAvailable - 1) - OffLast;                      // Bytes are reversed in CSD
    278            Data = 0;
    279            //
    280            // Read data into 32 bits
    281            //
    282            do {
    283              Data <<= 8;
    284              Data |= pData[Off++];
    285            } while (--NumBytes);
    286            //
    287            // Shift and mask result
    288            //
    289            Data >>= (FirstBit & 7);
    290            Data &= (2 << (LastBit - FirstBit)) - 1;                // Mask out bits that are outside of given bit range
    291            return Data;
    292          }
    293          
    294          
    295          /*********************************************************************
    296          *
    297          *       _GetFromCSD
    298          *
    299          *  Function description
    300          *    Returns a value from the CSD field. These values are stored in
    301          *    a 128 bit array; the bit-indices documented in [1]: 5.3 CSD register, page 69
    302          *    can be used as parameters when calling the function
    303          */
    304          static unsigned _GetFromCSD(const CSD * pCSD, unsigned FirstBit, unsigned LastBit) {
    305            U32 Data;
    306            Data = _GetBits(pCSD->aData, FirstBit, LastBit, sizeof(pCSD->aData));
    307            return Data;
    308          }
    309          
    310          /*********************************************************************
    311          *
    312          *       _CalcCRC7
    313          *
    314          *  Function Description
    315          *    Returns the 7 bit CRC generated with the 1021 polynom using a table.
    316          */
    317          static U8 _CalcCRC7(U8 * pData, unsigned NumBytes) {
    318            U8       crc;
    319            unsigned iBit;
    320            unsigned iByte;
    321            U8       Data;
    322          
    323            crc=0;
    324            for (iByte = 0; iByte < NumBytes; iByte++) {
    325              Data = *pData++;
    326              for (iBit = 0;iBit < 8; iBit++) {
    327                crc <<= 1;
    328                if ((Data & 0x80)^(crc & 0x80))
    329                crc ^=0x09;
    330                Data <<= 1;
    331              }
    332            }
    333            crc = (crc << 1) | 1;
    334            return crc;
    335          }
    336          
    337          /*********************************************************************
    338          *
    339          *       _CalcDataCRC16ViaTable
    340          *
    341          *  Function Description
    342          *    Returns the 16 bit CRC generated with the 1021 polynom using a table.
    343          *    Using the table is about 10 times as fast as computing the CRC on a bit by bit basis,
    344          *    which is the reason why it is used here.
    345          *    The CRC algorithm is described in some detail in [1]: 4.5, page 40.
    346          *
    347          *  Notes
    348          *    (1) Code verification
    349          *        The table has been generated automatically, so typos can be ruled out.
    350          *        Code verification is difficult if tables are used; but in this case,
    351          *        the table can be verified also by running the "CRC Sample":
    352          *        512 bytes with 0xFF data --> CRC16 = 0x7FA1
    353          */

   \                                 In section .text, align 4, keep-with-next
    354          static U16 _CalcDataCRC16ViaTable(const U8 * pData, unsigned NumBytes) {
    355            U16 Crc;
    356          
    357            Crc = FS_CRC16_Calc(pData, NumBytes, 0);
    358            return Crc;
   \                     _CalcDataCRC16ViaTable:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   ........           B        FS_CRC16_Calc    ;; tailcall
    359          }
    360          
    361          /*********************************************************************
    362          *
    363          *       _CalcDataCRC16Dummy
    364          *
    365          *  Function Description
    366          *    Returns a dummy value (0xFFFF) which indicates that CRC has not been computed.
    367          */

   \                                 In section .text, align 4, keep-with-next
    368          static U16 _CalcDataCRC16Dummy(const U8 * p, unsigned NumBytes) {
    369            FS_USE_PARA(p);
    370            FS_USE_PARA(NumBytes);
    371            return 0xFFFF;
   \                     _CalcDataCRC16Dummy:
   \   00000000   FF00A0E3           MOV      R0,#+255
   \   00000004   FF0C80E3           ORR      R0,R0,#0xFF00
   \   00000008   1EFF2FE1           BX       LR               ;; return
    372          }
    373          
    374          /*********************************************************************
    375          *
    376          *       _CalcDataCRC16
    377          *
    378          *  Function Description
    379          *    Is used to compute the 16-bit CRC for data.
    380          *    It calls the actual computation routine via function pointer.
    381          *    The function pointer is either the "Dummy" routine returning the
    382          *    0xFFFF or a routine computing the correct 16-bit CRC
    383          */
    384          static U16 _CalcDataCRC16(const void * p, unsigned NumBytes) {
    385            return _pfCalcCRC((const U8*)p, NumBytes);
    386          }
    387          
    388          /*********************************************************************
    389          *
    390          *       _SendEmptyCycles
    391          *
    392          *  Description:
    393          *    After each transaction, the MMC card
    394          *    needs at least one empty cycle phase. During this 8 clock cycle phase
    395          *    data line must be at high level.
    396          *
    397          *  Parameters:
    398          *    Unit                 - Device index number
    399          */
    400          static void _SendEmptyCycles(U8 Unit, int n) {
    401            U8  c;
    402          
    403            c = 0xFF; /* data line must be kept high */
    404            for (; n > 0; n--) {
    405              FS_MMC_HW_X_Write(Unit, &c, 1);
    406            }
    407          }
    408          
    409          /*********************************************************************
    410          *
    411          *       _CheckR1
    412          *
    413          *  Description:
    414          *    Read the R1 response,assert that no error occurred
    415          *    and returns the response R1.
    416          *    Bit definition of R1:
    417          *      Bit 0:    In idle state
    418          *      Bit 1:    Erase Reset
    419          *      Bit 2:    Illegal command
    420          *      Bit 3:    Communication CRC error
    421          *      Bit 4:    Erase sequence error
    422          *      Bit 5:    Address error
    423          *      Bit 6:    Parameter error
    424          *      Bit 7:    Always 0.
    425          *
    426          *  Parameters:
    427          *    Unit                    - Device Index
    428          *
    429          *  Notes
    430          *    (1) The response is as follows:
    431          *        NCR bits of value 1 (up to 8 bits)
    432          *        single byte, response format R1 (MMC spec [2]: 7.6.2)
    433          *        The bit 7 is always 0, the other bits indicate errors if set.
    434          *        In other words: The response consists of 8 - 16 bits.
    435          *        The last 8 bits are relevant; of these bit 7 is always 0.
    436          *
    437          *
    438          *
    439          */
    440          static U8 _CheckR1(U8 Unit) {
    441            U8  Response;
    442            U8  LoopRem;
    443          
    444            /* Read NCR bits and response token */
    445            FS_MMC_HW_X_Read(Unit, &Response, 1);            // First byte is always NCR, never a valid response
    446            if (Response != 0xff) {
    447              LoopRem = 10;
    448            } else {
    449              LoopRem = 7;
    450            }
    451            do {
    452              FS_MMC_HW_X_Read(Unit, &Response, 1);          /* Note 1 */
    453              if (Response != 0xff) {
    454                break;
    455              }
    456              if (--LoopRem == 0) {
    457                return 0xff;                                 /* Error: More than 8 bytes NCR (0xff) */
    458              }
    459            } while (1);
    460            return Response;                        /* No error if 0 */
    461          }
    462          
    463          /*********************************************************************
    464          *
    465          *       _WaitUntilReady
    466          *
    467          *  Description:
    468          *    Wait for the busy flag to be deactivated (DOUT == 1)
    469          *
    470          *  Parameters:
    471          *    Unit              - Device Index
    472          *
    473          *  Return value:
    474          *    0:     O.K.
    475          *    else   Error condition (time out)
    476          *
    477          *
    478          */
    479          static char _WaitUntilReady(MMC_INST * pInst) {
    480            U32 LoopRem;
    481            U8  aData[2];
    482            U8  Unit;
    483          
    484            Unit = pInst->Unit;
    485            /* Wait for the card to report ready (Note 2) */
    486            LoopRem = pInst->Nac ;     /* Timeout value in loops */
    487            do {
    488              FS_MMC_HW_X_Read(Unit, aData, 1);
    489              if (aData[0] == 0xFF) {
    490                return 0;                          /* O.K., Card is ready */
    491              }
    492            } while (LoopRem-- > 0);
    493            return 1;                              /* Time out error */
    494          }
    495          
    496          /*********************************************************************
    497          *
    498          *       _ExecCmdR1
    499          *
    500          *  Description:
    501          *    MMC/SD driver internal function. Execute a command sequence with R1
    502          *    response and return the card's response.
    503          *
    504          *  Parameters:
    505          *    Unit            - Unit number.
    506          *    Cmd             - Command index.
    507          *    Arg             - Command argument.
    508          *
    509          *  Return value:
    510          *    Card response token type R1.
    511          */

   \                                 In section .text, align 4, keep-with-next
    512          static unsigned char _ExecCmdR1(MMC_INST * pInst, unsigned char Cmd, U32 Arg) {
   \                     _ExecCmdR1:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    513            U8 r;
    514            U8 Unit;
    515            U8 aCmdBuffer[CMD_LEN];
    516            Unit = pInst->Unit;
    517            //
    518            // Build setup command token (48 bit)
    519            //
    520            aCmdBuffer[0] = (U8)(0x40 | (Cmd & 0x3F));
   \   00000004   3F1001E2           AND      R1,R1,#0x3F
   \   00000008   10D04DE2           SUB      SP,SP,#+16
   \   0000000C   0240D0E5           LDRB     R4,[R0, #+2]
   \   00000010   401081E3           ORR      R1,R1,#0x40
   \   00000014   0410CDE5           STRB     R1,[SP, #+4]
    521            aCmdBuffer[1] = (U8)((Arg >> 24) & 0xFF);
   \   00000018   04108DE2           ADD      R1,SP,#+4
   \   0000001C   223CA0E1           LSR      R3,R2,#+24
   \   00000020   0130C1E5           STRB     R3,[R1, #+1]
    522            aCmdBuffer[2] = (U8)((Arg >> 16) & 0xFF);
   \   00000024   2238A0E1           LSR      R3,R2,#+16
   \   00000028   0230C1E5           STRB     R3,[R1, #+2]
    523            aCmdBuffer[3] = (U8)((Arg >>  8) & 0xFF);
   \   0000002C   2234A0E1           LSR      R3,R2,#+8
   \   00000030   0730CDE5           STRB     R3,[SP, #+7]
    524            aCmdBuffer[4] = (U8)( Arg        & 0xFF);
   \   00000034   0820CDE5           STRB     R2,[SP, #+8]
    525            aCmdBuffer[5] = _CalcCRC7(&aCmdBuffer[0], 5);  /* SPI default mode, no use for CRC */
   \   00000038   04208DE2           ADD      R2,SP,#+4
   \   0000003C   0030A0E3           MOV      R3,#+0
   \   00000040   05C0A0E3           MOV      R12,#+5
   \                     ??_ExecCmdR1_0:
   \   00000044   01E0D2E4           LDRB     LR,[R2], #+1
   \   00000048   0850A0E3           MOV      R5,#+8
   \                     ??_ExecCmdR1_1:
   \   0000004C   8330A0E1           LSL      R3,R3,#+1
   \   00000050   0E6023E0           EOR      R6,R3,LR
   \   00000054   800016E3           TST      R6,#0x80
   \   00000058   09302312           EORNE    R3,R3,#0x9
   \   0000005C   8EE0A0E1           LSL      LR,LR,#+1
   \   00000060   015055E2           SUBS     R5,R5,#+1
   \   00000064   F8FFFF1A           BNE      ??_ExecCmdR1_1
   \   00000068   01C05CE2           SUBS     R12,R12,#+1
   \   0000006C   F4FFFF1A           BNE      ??_ExecCmdR1_0
   \   00000070   0120A0E3           MOV      R2,#+1
   \   00000074   832082E1           ORR      R2,R2,R3, LSL #+1
   \   00000078   0520C1E5           STRB     R2,[R1, #+5]
    526          
    527            /* Make sure the card is ready */
    528            r = _WaitUntilReady(pInst);
   \   0000007C   0250D0E5           LDRB     R5,[R0, #+2]
   \   00000080   0C6090E5           LDR      R6,[R0, #+12]
   \                     ??_ExecCmdR1_2:
   \   00000084   0120A0E3           MOV      R2,#+1
   \   00000088   02108DE2           ADD      R1,SP,#+2
   \   0000008C   0500A0E1           MOV      R0,R5
   \   00000090   ........           BL       FS_MMC_HW_X_Read
   \   00000094   0200DDE5           LDRB     R0,[SP, #+2]
   \   00000098   FF0050E3           CMP      R0,#+255
   \   0000009C   0500000A           BEQ      ??_ExecCmdR1_3
   \   000000A0   0600A0E1           MOV      R0,R6
   \   000000A4   016040E2           SUB      R6,R0,#+1
   \   000000A8   000050E3           CMP      R0,#+0
   \   000000AC   F4FFFF1A           BNE      ??_ExecCmdR1_2
    529            if (r) {
    530              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: _ExecCmdR1: Timeout occurred when receiving the response.\n"));
    531              return 0xff;                           /* Time out waiting for ready */
   \   000000B0   FF00A0E3           MOV      R0,#+255
   \   000000B4   150000EA           B        ??_ExecCmdR1_4
    532            }
    533            FS_MMC_HW_X_Write(Unit, aCmdBuffer, CMD_LEN);
   \                     ??_ExecCmdR1_3:
   \   000000B8   0620A0E3           MOV      R2,#+6
   \   000000BC   04108DE2           ADD      R1,SP,#+4
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   ........           BL       FS_MMC_HW_X_Write
    534            r = _CheckR1(Unit);   /* Receive response */
   \   000000C8   0120A0E3           MOV      R2,#+1
   \   000000CC   0D10A0E1           MOV      R1,SP
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   ........           BL       FS_MMC_HW_X_Read
   \   000000D8   0000DDE5           LDRB     R0,[SP, #+0]
   \   000000DC   FF0050E3           CMP      R0,#+255
   \   000000E0   0A50A013           MOVNE    R5,#+10
   \   000000E4   0750A003           MOVEQ    R5,#+7
   \                     ??_ExecCmdR1_5:
   \   000000E8   0120A0E3           MOV      R2,#+1
   \   000000EC   0D10A0E1           MOV      R1,SP
   \   000000F0   0400A0E1           MOV      R0,R4
   \   000000F4   ........           BL       FS_MMC_HW_X_Read
   \   000000F8   0000DDE5           LDRB     R0,[SP, #+0]
   \   000000FC   FF0050E3           CMP      R0,#+255
   \   00000100   0200001A           BNE      ??_ExecCmdR1_4
   \   00000104   015045E2           SUB      R5,R5,#+1
   \   00000108   FF5015E2           ANDS     R5,R5,#0xFF
   \   0000010C   F5FFFF1A           BNE      ??_ExecCmdR1_5
    535            return r; /* return received response token */
   \                     ??_ExecCmdR1_4:
   \   00000110   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   00000114   7080BDE8           POP      {R4-R6,PC}       ;; return
    536          }
    537          
    538          
    539          /*********************************************************************
    540          *
    541          *       _ReadCSD
    542          *
    543          *  Description:
    544          *    MMC/SD driver internal function.
    545          *    Read the card's CSD (card specific data) register.
    546          *
    547          *  Parameters:
    548          *    Unit      - Device index number
    549          *
    550          *  Return value:
    551          *    ==0           - CSD has been read and all parameters are valid.
    552          *    <0            - An error has occurred.
    553          */

   \                                 In section .text, align 4, keep-with-next
    554          static U8 _ReadCSD(MMC_INST * pInst, CSD * pCSD) {
   \                     _ReadCSD:
   \   00000000   F0422DE9           PUSH     {R4-R7,R9,LR}
   \   00000004   0070A0E1           MOV      R7,R0
    555            U8   a;
    556            U8   c;
    557            U32  to;
    558            U16  i;
    559            U8   r;
    560            U8   Unit;
    561          
    562            Unit = pInst->Unit;
   \   00000008   0250D7E5           LDRB     R5,[R7, #+2]
   \   0000000C   08D04DE2           SUB      SP,SP,#+8
   \   00000010   0140A0E1           MOV      R4,R1
    563            r = 0xff;
   \   00000014   FF60A0E3           MOV      R6,#+255
    564            _SendEmptyCycles(Unit, 1);
   \   00000018   0160CDE5           STRB     R6,[SP, #+1]
   \   0000001C   0120A0E3           MOV      R2,#+1
   \   00000020   01108DE2           ADD      R1,SP,#+1
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           BL       FS_MMC_HW_X_Write
    565            /* Execute CMD9 (SEND_CSD) */
    566            FS_MMC_HW_X_EnableCS(Unit);  /* CS on */
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   ........           BL       FS_MMC_HW_X_EnableCS
    567            a = _ExecCmdR1(pInst, CMD_SEND_CSD, 0);  /* Do not handle clock & CS automatically */
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   0910A0E3           MOV      R1,#+9
   \   0000003C   0700A0E1           MOV      R0,R7
   \   00000040   ........           BL       _ExecCmdR1
   \   00000044   0000CDE5           STRB     R0,[SP, #+0]
    568            if (a != 0) {
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   1B00001A           BNE      ??_ReadCSD_0
    569              goto End;
    570          
    571            }
    572            /* wait for CSD transfer to begin */
    573            i = 0;
   \   00000050   0090A0E3           MOV      R9,#+0
    574            to = pInst->Nac ;
   \   00000054   0C7097E5           LDR      R7,[R7, #+12]
    575            do {
    576              FS_MMC_HW_X_Read(Unit, &c, 1);
   \                     ??_ReadCSD_1:
   \   00000058   0120A0E3           MOV      R2,#+1
   \   0000005C   02108DE2           ADD      R1,SP,#+2
   \   00000060   0500A0E1           MOV      R0,R5
   \   00000064   ........           BL       FS_MMC_HW_X_Read
    577              if (c == TOKEN_BLOCK_READ_START) {
   \   00000068   0200DDE5           LDRB     R0,[SP, #+2]
   \   0000006C   FE0050E3           CMP      R0,#+254
    578                break;
    579              }
    580              /* a = c & 0x3F; filter CSD signature bits */
    581              if (c == 0xFC) {
   \   00000070   FC005013           CMPNE    R0,#+252
   \   00000074   0400000A           BEQ      ??_ReadCSD_2
    582                break;
    583              }
    584              if (++i == to) { /* timeout reached */
   \   00000078   019089E2           ADD      R9,R9,#+1
   \   0000007C   0908A0E1           MOV      R0,R9, LSL #+16
   \   00000080   200857E1           CMP      R7,R0, LSR #+16
   \   00000084   F3FFFF1A           BNE      ??_ReadCSD_1
   \   00000088   0C0000EA           B        ??_ReadCSD_0
    585                goto End;
    586              }
    587            } while (1);
    588          
    589            /* Read the CSD */
    590            FS_MMC_HW_X_Read(Unit, pCSD->aData, sizeof(CSD));
   \                     ??_ReadCSD_2:
   \   0000008C   1020A0E3           MOV      R2,#+16
   \   00000090   0410A0E1           MOV      R1,R4
   \   00000094   0500A0E1           MOV      R0,R5
   \   00000098   ........           BL       FS_MMC_HW_X_Read
    591            FS_MMC_HW_X_Read(Unit, &a, 1); /* read CRC16 high part */
   \   0000009C   0120A0E3           MOV      R2,#+1
   \   000000A0   0D10A0E1           MOV      R1,SP
   \   000000A4   0500A0E1           MOV      R0,R5
   \   000000A8   ........           BL       FS_MMC_HW_X_Read
    592            FS_MMC_HW_X_Read(Unit, &a, 1); /* read CRC16 low part */
   \   000000AC   0120A0E3           MOV      R2,#+1
   \   000000B0   0D10A0E1           MOV      R1,SP
   \   000000B4   0500A0E1           MOV      R0,R5
   \   000000B8   ........           BL       FS_MMC_HW_X_Read
    593            r = 0;
   \   000000BC   0060A0E3           MOV      R6,#+0
    594          End:
    595            FS_MMC_HW_X_DisableCS(Unit);  /* CS off */
   \                     ??_ReadCSD_0:
   \   000000C0   0500A0E1           MOV      R0,R5
   \   000000C4   ........           BL       FS_MMC_HW_X_DisableCS
    596            _SendEmptyCycles(Unit, 1);  /* Clock card after command */
   \   000000C8   FF10A0E3           MOV      R1,#+255
   \   000000CC   0110CDE5           STRB     R1,[SP, #+1]
   \   000000D0   0120A0E3           MOV      R2,#+1
   \   000000D4   01108DE2           ADD      R1,SP,#+1
   \   000000D8   0500A0E1           MOV      R0,R5
   \   000000DC   ........           BL       FS_MMC_HW_X_Write
    597            return r;     /* No problem ! */
   \   000000E0   0600A0E1           MOV      R0,R6
   \   000000E4   08D08DE2           ADD      SP,SP,#+8
   \   000000E8   F082BDE8           POP      {R4-R7,R9,PC}    ;; return
    598          }
    599          
    600          
    601          /*********************************************************************
    602          *
    603          *       _WaitToGetReady
    604          *
    605          *  Description:
    606          *    Waits until the card returns from busy state.
    607          *    This function only waits _nwrite[Unit] cycles,
    608          *    if the card is still in busy after this cycles, a timeout occurs.
    609          *
    610          *  Return value:
    611          *    ==  0            - Card is ready to accept data/commands.
    612          *    == -1            - timeout occurred.
    613          */
    614          static int _WaitToGetReady(MMC_INST * pInst) {
    615            U8  BusyState;
    616            U8  Unit;
    617            U32 LoopRem;
    618          
    619            Unit    = pInst->Unit;
    620            LoopRem = pInst->Nwrite ; /* get timeout from description block */
    621            do {
    622              FS_MMC_HW_X_Read(Unit, &BusyState, 1);
    623              if (BusyState != 0) {
    624                break;
    625              }
    626              if (--LoopRem == 0) {
    627                return -1;                  /* Error */
    628              }
    629            } while (1);
    630            return 0;
    631          }
    632          
    633          /*********************************************************************
    634          *
    635          *       _WaitBlockRdTok
    636          *
    637          *  Description:
    638          *    Wait for valid block read confirmation token.
    639          *
    640          *  Parameters:
    641          *    Unit  - Device Index
    642          *
    643          *  Return value:
    644          *    0xfe     - Success
    645          *    0xff     - Error, time-out
    646          */
    647          static U8 _WaitBlockRdTok(MMC_INST * pInst) {
    648            U8  c;
    649            U32 i;
    650            U32 to;
    651            U8  Unit;
    652          
    653            Unit = pInst->Unit;
    654            to   = pInst->Nac ; /* get timeout from description block */
    655            for (i = 0; i < to; i++) {
    656              FS_MMC_HW_X_Read(Unit, &c, 1);
    657              if (c == TOKEN_BLOCK_READ_START) {
    658                return c;
    659              }
    660            }
    661            FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: MMC: _WaitBlockRdTok timed out.\n"));
    662            return 0xff;
    663          }
    664          
    665          /*********************************************************************
    666          *
    667          *       _ExecCmdInit
    668          *
    669          *  Description:
    670          *    Send init command (CMD0)
    671          *
    672          *  Parameters:
    673          *    Unit        - Unit number.
    674          *    Cmd         - Command index.
    675          *    Arg         - Command argument.
    676          *
    677          *  Notes:
    678          *    The sequence is very similar, but not identical to the CmdR1 sequence.
    679          *    Main difference is that we do not "Wait until ready" because the card's
    680          *    output may not be enabled for SD cards.
    681          */
    682          static U8 _ExecCmdInit(U8 Unit) {
    683            U8 r;
    684            const U8 CmdBuffer[6] = { 0x40, 0, 0, 0, 0, 0x95 };
    685          
    686            FS_MMC_HW_X_EnableCS(Unit);
    687            FS_MMC_HW_X_Write(Unit, CmdBuffer, 6);
    688            r = _CheckR1(Unit);   /* Receive response */
    689            FS_MMC_HW_X_DisableCS(Unit); /* CS (SPI) off */
    690            _SendEmptyCycles(Unit, 1);
    691            return r; /* return received response token */
    692          }
    693          
    694          /*********************************************************************
    695          *
    696          *       _CheckCardOCR
    697          *
    698          *  Description:
    699          *    MMC/SD driver driver internal function. Read the card's OCR register and checks,
    700          *    if the provided voltage is supported.
    701          *
    702          *  Parameters:
    703          *    Unit        - Unit number.
    704          *    pCCS        - Pointer to variable to receive CCS bit (if CCS is valid)
    705          *
    706          *  Return value:
    707          *    ==0         - Voltage is supported.
    708          *    !=0         - An error has occurred.
    709          */

   \                                 In section .text, align 4, keep-with-next
    710          static U8 _CheckCardOCR(MMC_INST * pInst, U8 * pCCS) {
   \                     _CheckCardOCR:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    711            unsigned uitmp; /* temporary word */
    712            unsigned Vmax;
    713            unsigned Vmin;
    714            unsigned i;
    715            U8       a[4];
    716            U8       c;
    717            U8       r;
    718            U32      ocr;
    719            U16      mask;
    720            U8       Unit;
    721          
    722            Unit    = pInst->Unit;
   \   00000008   0240D5E5           LDRB     R4,[R5, #+2]
   \   0000000C   0CD04DE2           SUB      SP,SP,#+12
   \   00000010   0160A0E1           MOV      R6,R1
    723            FS_MMC_HW_X_EnableCS(Unit);  /* CS on */
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   ........           BL       FS_MMC_HW_X_EnableCS
    724            r = _ExecCmdR1(pInst, CMD_READ_OCR, 0);
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   3A10A0E3           MOV      R1,#+58
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           BL       _ExecCmdR1
   \   0000002C   0050B0E1           MOVS     R5,R0
    725            if (r != 0) {
   \   00000030   0900000A           BEQ      ??_CheckCardOCR_0
    726              FS_MMC_HW_X_DisableCS(Unit);  /* CS off */
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       FS_MMC_HW_X_DisableCS
    727              _SendEmptyCycles(Unit, 1);
   \   0000003C   FF10A0E3           MOV      R1,#+255
   \   00000040   0010CDE5           STRB     R1,[SP, #+0]
   \   00000044   0120A0E3           MOV      R2,#+1
   \   00000048   0D10A0E1           MOV      R1,SP
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       FS_MMC_HW_X_Write
    728              return 0xff;
   \                     ??_CheckCardOCR_1:
   \   00000054   FF00A0E3           MOV      R0,#+255
   \   00000058   450000EA           B        ??_CheckCardOCR_2
    729            }
    730            /* Get OCR */
    731            FS_MMC_HW_X_Read(Unit, &a[0], 4);
   \                     ??_CheckCardOCR_0:
   \   0000005C   0420A0E3           MOV      R2,#+4
   \   00000060   04108DE2           ADD      R1,SP,#+4
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           BL       FS_MMC_HW_X_Read
    732            ocr =  FS_LoadU32BE(&a[0]);
   \   0000006C   04008DE2           ADD      R0,SP,#+4
   \   00000070   ........           BL       FS_LoadU32BE
   \   00000074   0070A0E1           MOV      R7,R0
    733            FS_MMC_HW_X_DisableCS(Unit);  /* CS off */
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   ........           BL       FS_MMC_HW_X_DisableCS
    734            _SendEmptyCycles(Unit, 1);
   \   00000080   FF10A0E3           MOV      R1,#+255
   \   00000084   0010CDE5           STRB     R1,[SP, #+0]
   \   00000088   0120A0E3           MOV      R2,#+1
   \   0000008C   0D10A0E1           MOV      R1,SP
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   ........           BL       FS_MMC_HW_X_Write
    735          
    736            /* Return CCS bit value if caller wants it. It's only valid if power
    737             * status bit is set.
    738             */
    739            if (pCCS && ((ocr >> 31) & 1)) {
   \   00000098   000056E3           CMP      R6,#+0
   \   0000009C   A70FB011           LSRSNE   R0,R7,#+31
    740              *pCCS = (U8)((ocr >> 30) & 1);
   \   000000A0   270FA011           LSRNE    R0,R7,#+30
   \   000000A4   01000012           ANDNE    R0,R0,#0x1
   \   000000A8   0000C615           STRBNE   R0,[R6, #+0]
    741            }
    742          
    743            /* test for low voltage mode support */
    744            r = (U8)(ocr & 0x80);
    745            if (r != 0) {
   \   000000AC   800017E3           TST      R7,#0x80
    746              Vmin = VOLT_LOWMIN;
   \   000000B0   7210A013           MOVNE    R1,#+114
    747              Vmax = VOLT_LOWMAX;
    748            } else {
    749              Vmin = 0;
    750              Vmax = 0;
    751            }
    752            /* filter voltage flags to uitmp */
    753            uitmp = (U16) (ocr >> 8) & 0xFFFF;
   \   000000B4   2704A0E1           LSR      R0,R7,#+8
   \   000000B8   601E8113           ORRNE    R1,R1,#0x600
   \   000000BC   0010A003           MOVEQ    R1,#+0
   \   000000C0   0008A0E1           LSL      R0,R0,#+16
    754            /* calculate lower voltage limit */
    755            mask = 0x0001;
   \   000000C4   0120A0E3           MOV      R2,#+1
    756            r = 0;
    757            for (c = 0; c < 16; c++) {
   \   000000C8   0030A0E3           MOV      R3,#+0
    758              i = uitmp & mask;
    759              if (i != 0) {
   \                     ??_CheckCardOCR_3:
   \   000000CC   02E8A0E1           LSL      LR,R2,#+16
   \   000000D0   2EE8A0E1           LSR      LR,LR,#+16
   \   000000D4   20081EE1           TST      LR,R0, LSR #+16
   \   000000D8   0500001A           BNE      ??_CheckCardOCR_4
    760                break;
    761              }
    762              mask <<= 1;
    763              r++;
    764            }
   \   000000DC   013083E2           ADD      R3,R3,#+1
   \   000000E0   FF3003E2           AND      R3,R3,#0xFF
   \   000000E4   8220A0E1           LSL      R2,R2,#+1
   \   000000E8   015085E2           ADD      R5,R5,#+1
   \   000000EC   100053E3           CMP      R3,#+16
   \   000000F0   F5FFFF3A           BCC      ??_CheckCardOCR_3
    765            /* Calculate voltage from OCR field.
    766               Bit position means 100mV, offset is 2000mV */
    767            if (Vmin < VOLT_LOWMIN) {
   \                     ??_CheckCardOCR_4:
   \   000000F4   72C0A0E3           MOV      R12,#+114
   \   000000F8   60CE8CE3           ORR      R12,R12,#0x600
   \   000000FC   0C0051E1           CMP      R1,R12
   \   00000100   0700002A           BCS      ??_CheckCardOCR_5
    768              Vmin = 2000 + (r * 100);
   \   00000104   FF1005E2           AND      R1,R5,#0xFF
   \   00000108   64C0A0E3           MOV      R12,#+100
   \   0000010C   8C0161E1           SMULBB   R1,R12,R1
   \   00000110   7D1E81E2           ADD      R1,R1,#+2000
   \   00000114   020000EA           B        ??_CheckCardOCR_5
    769            }
    770            /* calculate high voltage limit */
    771            for (; c < 16; c++) {
    772              i = uitmp & mask;
    773              if (i == 0) {
    774                break;
    775              }
    776              mask <<= 1;
   \                     ??_CheckCardOCR_6:
   \   00000118   8220A0E1           LSL      R2,R2,#+1
    777              r++;
   \   0000011C   015085E2           ADD      R5,R5,#+1
   \   00000120   013083E2           ADD      R3,R3,#+1
   \                     ??_CheckCardOCR_5:
   \   00000124   FF3003E2           AND      R3,R3,#0xFF
   \   00000128   100053E3           CMP      R3,#+16
   \   0000012C   0300002A           BCS      ??_CheckCardOCR_7
   \   00000130   02E8A0E1           LSL      LR,R2,#+16
   \   00000134   2EE8A0E1           LSR      LR,LR,#+16
   \   00000138   20081EE1           TST      LR,R0, LSR #+16
   \   0000013C   F5FFFF1A           BNE      ??_CheckCardOCR_6
    778            }
    779            Vmax = (2000 + (r * 100));
    780            c = FS_MMC_HW_X_SetVoltage(Unit, (U16)Vmin, (U16)Vmax);
    781            /* Indicate error if card didn't support requested voltage range */
    782            if (c == 0) {
   \                     ??_CheckCardOCR_7:
   \   00000140   FF5005E2           AND      R5,R5,#0xFF
   \   00000144   6400A0E3           MOV      R0,#+100
   \   00000148   800562E1           SMULBB   R2,R0,R5
   \   0000014C   0118A0E1           LSL      R1,R1,#+16
   \   00000150   7D2E82E2           ADD      R2,R2,#+2000
   \   00000154   0228A0E1           LSL      R2,R2,#+16
   \   00000158   2228A0E1           LSR      R2,R2,#+16
   \   0000015C   2118A0E1           LSR      R1,R1,#+16
   \   00000160   0400A0E1           MOV      R0,R4
   \   00000164   ........           BL       FS_MMC_HW_X_SetVoltage
   \   00000168   000CB0E1           LSLS     R0,R0,#+24
   \   0000016C   B8FFFF0A           BEQ      ??_CheckCardOCR_1
    783              return 0xff;
    784            }
    785            return 0;
   \   00000170   0000A0E3           MOV      R0,#+0
   \                     ??_CheckCardOCR_2:
   \   00000174   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000178   F080BDE8           POP      {R4-R7,PC}       ;; return
    786          }
    787          
    788          
    789          #if FS_MMC_SUPPORT_HIGH_SPEED
    790          /*********************************************************************
    791          *
    792          *       _ExecSwitchFunc
    793          *
    794          *  Function description:
    795          *
    796          *
    797          *  Parameters:
    798          *    pInst    -
    799          *    Mode    -
    800          *    Group    -
    801          *    Value    -
    802          *    pResp    -
    803          *
    804          *  Return value:
    805          *    0        - Success
    806          *
    807          */
    808          static int _ExecSwitchFunc(MMC_INST * pInst, int Mode, int Group, U8 Value, U8 * pResp) {
    809            U32      Arg;
    810            unsigned Response;
    811            U8       aCRC[2];
    812            U8       Unit;
    813            int      r;
    814          
    815            Unit     = pInst->Unit;
    816            Arg = Mode << 31 | 0x00FFFFFF;
    817            Arg &= ~(0x0FUL << (Group * 4));
    818            Arg |= Value << (Group * 4);
    819            FS_MMC_HW_X_EnableCS(Unit);
    820            Response = _ExecCmdR1(pInst, CMD_SWITCH_FUNC, Arg);
    821            if (Response == 0xff) {
    822              r = -1;                   // Error
    823              goto End;
    824            }
    825            Response = _WaitBlockRdTok(pInst);                // Wait for data block to begin
    826            if (Response == 0xFF) {
    827              r = -1;                   // Error
    828              goto End;
    829            }
    830            r = 0;
    831            FS_MMC_HW_X_Read(Unit, pResp, 64);                // read SCR data
    832            FS_MMC_HW_X_Read(Unit, aCRC, 2);                // read CRC16
    833          End:
    834            FS_MMC_HW_X_DisableCS(Unit);
    835            return r;
    836          }
    837          #endif
    838          
    839          /*********************************************************************
    840          *
    841          *      _ApplyCSD
    842          *
    843          *  Description:
    844          *    MMC/SD driver internal function.
    845          *    Read the card's CSD (card specific data) registers and check
    846          *    its contents.
    847          *
    848          *  Parameters:
    849          *    Unit      - Device index number
    850          *
    851          *  Return value:
    852          *    ==0           - CSD has been read and all parameters are valid.
    853          *    <0            - An error has occurred.
    854          *
    855          *  Notes
    856          *    (1) SectorSize
    857          *        Newer SD card (4 GByte-card) return a block size larger than 512.
    858          *        Sector Size used however is always 512 bytes.
    859          */

   \                                 In section .text, align 4, keep-with-next
    860          static int _ApplyCSD(MMC_INST * pInst, CSD * pCSD) {
   \                     _ApplyCSD:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0040A0E1           MOV      R4,R0
    861            int   c;
    862            int   tmp;
    863            U32   TimeUnit;
    864            U32   Factor;        // R2W_FACTOR value
    865            U32   Freq;          // Card transfer rate in kbit/s
    866            U32   TimeValue;
    867            U32   Nac;           // Max configured byte transfer cycles for read access
    868            U32   NacRead;       // Max byte transfer cycles to allow for read access
    869            U32   NacWrite;      // Max byte transfer cycles to allow for write access
    870            U32   CardSize;
    871            U8       Unit;
    872            U8       ccs;
    873            unsigned CSDVersion;
    874            unsigned AllowHighSpeed = 0;
    875          
    876            c = _CheckCardOCR(pInst, &ccs);
    877            if (c != 0) {
   \   00000010   0D10A0E1           MOV      R1,SP
   \   00000014   ........           BL       _CheckCardOCR
   \   00000018   000050E3           CMP      R0,#+0
    878              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: _ApplyCSD: OCR invalid.\n"));
    879              return -1;
   \   0000001C   0000E013           MVNNE    R0,#+0
   \   00000020   5B00001A           BNE      ??_ApplyCSD_0
    880            }
    881            Unit = pInst->Unit;
    882            //
    883            // CSD version is only checked for SD card. MMC card have almost the same
    884            // CSD structure as SD V1 cards.
    885            if (pInst->CardType == CARD_TYPE_SD) {
   \   00000024   0300D4E5           LDRB     R0,[R4, #+3]
    886              CSDVersion = CSD_STRUCTURE(pCSD);
    887            } else {
    888              CSDVersion = 0;
    889            }
    890          #if FS_MMC_SUPPORT_HIGH_SPEED
    891            {
    892              U32      CCCSupported;
    893              //
    894              //  If the switch function is supported, we
    895              //  ask the card whether it supports high speed mode.
    896              //  This is only true for SD-Cards.
    897              //  MMCs do not support such a command class
    898              //
    899              CCCSupported = CSD_CCC_CLASSES(pCSD);
    900              if ((CCCSupported & (1 << 10)) && (pInst->CardType == CARD_TYPE_SD)) {
    901                unsigned Response;
    902                U8       aSCR[8];
    903                U8       aCRC[2];
    904                U8       ScrVersion;
    905                //
    906                //  Retrieve the SCR (SD card register)
    907                //
    908                FS_MMC_HW_X_EnableCS(Unit);
    909                Response = _ExecCmdR1(pInst, CMD_ACMD_CMD, 0);    // Prepare for advanced command
    910                _SendEmptyCycles(Unit, 1); /* Clock card before next command */
    911                Response = _ExecCmdR1(pInst, ACMD_SEND_SCR, 0);   // Send ACMD51 (SD_SEND_SCR)
    912                Response = _WaitBlockRdTok(pInst);                // Wait for data block to begin
    913                if (Response == 0xFF) {
    914                  FS_MMC_HW_X_DisableCS(Unit);
    915                  goto Continue;                   // Error
    916                }
    917                FS_MMC_HW_X_Read(Unit, aSCR, 8);                // read SCR data
    918                FS_MMC_HW_X_Read(Unit, aCRC, 2);                // read CRC16
    919                FS_MMC_HW_X_DisableCS(Unit);
    920                ScrVersion = _GetBits(aSCR, 56, 59, sizeof(aSCR));
    921                if (ScrVersion >= SD_SPEC_VER_200) {
    922                  U8 aSwitch[64];
    923                  U32 Data;
    924                  if (_ExecSwitchFunc(pInst, 0, 0, 1, aSwitch) == 0) {
    925                    Data = _GetBits(aSwitch, 400, 415, 64);
    926                    if (Data & 1) {
    927                      if (_ExecSwitchFunc(pInst, 1, 0, 1, aSwitch) == 0) {
    928                        Data = _GetBits(aSwitch, 376, 379, 64);
    929                        if ((Data & 0xF) == 1) {
    930                          AllowHighSpeed = 1;
    931                        }
    932                      }
    933                    }
    934                  }
    935                }
    936              }
    937          Continue:;
    938            }
    939          #endif
    940            //
    941            // Interpret card parameters. Some of this code has to differ depending on
    942            // the card's CSD version (1 or 2). However, we can use the same code to
    943            // calculate timeout values for any card. We can use the same logic for
    944            // either CSD version 1 or 2 because version 2 cards supply hard coded timing
    945            // parameters that are guaranteed to match or exceed the maximum allowed
    946            // timeouts. Thus, for version 2 cards the timeouts will always be set to
    947            // the maximum allowed values. This is correct behavior according to the
    948            // spec. See [1] 5.3.3 CSD Register (CSD Version 2.0), TAAC description.
    949            //
    950            //
    951            // Calculate maximum communication speed according to card specification.
    952            // Determine transfer rate unit and then combine with time value to get
    953            // rate in kbit/s.
    954            //
    955            if (AllowHighSpeed) {
    956              _ReadCSD(pInst, pCSD);
    957            }
    958            tmp  = CSD_TRAN_SPEED(pCSD);
   \   00000028   0310D5E5           LDRB     R1,[R5, #+3]
    959            c    = tmp & 0x03;
    960            Freq = _aRateUnit[c];
    961            c    = (tmp & 0x78) >> 3; /* filter frequency bits */
    962            Freq *= _aFactor[c];
    963            //
    964            //  Set the rate that will be used to talk to card to highest supported rate
    965            //  that is less than max allowed rate. Freq is set to that actual rate.
    966            //
    967            Freq = FS_MMC_HW_X_SetMaxSpeed(Unit, (U16)Freq);
   \   0000002C   ............       ADRL     R2,_aRateUnit
   \              ....        
   \   00000034   010050E3           CMP      R0,#+1
   \   00000038   0000D505           LDRBEQ   R0,[R5, #+0]
   \   0000003C   ............       ADRL     R9,_aFactor
   \              ....        
   \   00000044   0260D4E5           LDRB     R6,[R4, #+2]
   \   00000048   2073A001           LSREQ    R7,R0,#+6
   \   0000004C   030001E2           AND      R0,R1,#0x3
   \   00000050   000192E7           LDR      R0,[R2, +R0, LSL #+2]
   \   00000054   0F20A0E3           MOV      R2,#+15
   \   00000058   C11102E0           AND      R1,R2,R1, ASR #+3
   \   0000005C   0910D1E7           LDRB     R1,[R1, +R9]
   \   00000060   0070A013           MOVNE    R7,#+0
   \   00000064   800161E1           SMULBB   R1,R0,R1
   \   00000068   0600A0E1           MOV      R0,R6
   \   0000006C   0118A0E1           LSL      R1,R1,#+16
   \   00000070   2118A0E1           LSR      R1,R1,#+16
   \   00000074   ........           BL       FS_MMC_HW_X_SetMaxSpeed
   \   00000078   0080B0E1           MOVS     R8,R0
    968            if (Freq == 0) {
   \   0000007C   0100001A           BNE      ??_ApplyCSD_1
    969              return 0xff;
   \                     ??_ApplyCSD_2:
   \   00000080   FF00A0E3           MOV      R0,#+255
   \   00000084   420000EA           B        ??_ApplyCSD_0
    970            }
    971            //
    972            // Determine asynchronous (ie. time based) part of data access time by
    973            // decoding TAAC value. We determine a numerator and denominator that when
    974            // combined, via division, yield the access time as fractions of a second.
    975            // The numerator (stored in TimeValue) is based on the "time value" spec
    976            // quantity. The denominator (stored in TimeUnit) is based on the "time
    977            // unit" spec quantity. Because the TimeValue is 10 times what it should
    978            // be and the TimeUnit is 1/100 what it should be, when we do the division
    979            // the result is 1000 times what it should be. This means it yields an
    980            // access time in msec.
    981            //
    982            tmp       = CSD_TAAC(pCSD);
   \                     ??_ApplyCSD_1:
   \   00000088   0110D5E5           LDRB     R1,[R5, #+1]
    983            TimeUnit  = _aUnit[tmp & 0x07];
    984            TimeValue = _aFactor[(tmp >> 3) & 0x0F];
   \   0000008C   0F00A0E3           MOV      R0,#+15
   \   00000090   C10100E0           AND      R0,R0,R1, ASR #+3
   \   00000094   0920D0E7           LDRB     R2,[R0, +R9]
    985            if (TimeValue == 0) {
   \   00000098   000052E3           CMP      R2,#+0
   \   0000009C   F7FFFF0A           BEQ      ??_ApplyCSD_2
    986              return 0xff;        /* Error, illegal value */
    987            }
    988            //
    989            // According to [1] the description of NSAC says the total typical read
    990            // access time is "the sum of TAAC and NSAC". [3] clarifies that the values
    991            // are combined "according to Table 4.47". That table specifies the
    992            // equation for the maximum read access time as 100 times the typical
    993            // access time:
    994            //     Nac(max) = 100(TAAC*FOP + 100*NSAC)
    995            // Because of the units used in the earlier calculations, we can compute
    996            // TAAC*FOP by combining the quantities already determined to get a value
    997            // in cycles.
    998            //
    999            Nac = Freq * TimeValue / TimeUnit;
   1000            Nac += 100 * CSD_NSAC(pCSD);            // Add in the "clock dependent" factor of the access time
   1001            Nac *= 100;                             // Worst case value is 100 times typical value.
   1002            Nac >>= 3;                              // We want timeout as a count of byte transfers, not bit transfers
   \   000000A0   920800E0           MUL      R0,R2,R8
   \   000000A4   ............       ADRL     R2,_aUnit
   \              ....        
   \   000000AC   071001E2           AND      R1,R1,#0x7
   \   000000B0   011192E7           LDR      R1,[R2, +R1, LSL #+2]
   \   000000B4   ........           BL       __aeabi_uidiv
   \   000000B8   0210D5E5           LDRB     R1,[R5, #+2]
   \   000000BC   6490A0E3           MOV      R9,#+100
   1003            //
   1004            // According to [1]: "4.6.2.1 Read" (Timeout Conditions), the maximum read
   1005            // timeout needs to be limited to 100 msec. Convert 100 msec to byte
   1006            // transfers using the FOP.
   1007            //
   1008            NacRead = 100 * Freq;
   1009            NacRead >>= 3;
   1010            if (NacRead > Nac) {
   1011              NacRead = Nac;
   1012            }
   1013            // Calculate the write timeout which is calculated from Nac using the
   1014            // R2W_FACTOR. R2W_FACTOR is a power-of-2 value so we can use a simple
   1015            // shift to apply it. Note that even with all the configuration parameters
   1016            // at their maximum values, we can be sure this calculation won't overflow
   1017            // 32 bits.
   1018            //
   1019            Factor = CSD_R2W_FACTOR(pCSD);
   1020            Nac <<= Factor;
   \   000000C0   0C20D5E5           LDRB     R2,[R5, #+12]
   \   000000C4   890100E1           SMLABB   R0,R9,R1,R0
   \   000000C8   990000E0           MUL      R0,R9,R0
   \   000000CC   2221A0E1           LSR      R2,R2,#+2
   \   000000D0   A011A0E1           LSR      R1,R0,#+3
   \   000000D4   990800E0           MUL      R0,R9,R8
   \   000000D8   072002E2           AND      R2,R2,#0x7
   \   000000DC   A001A0E1           LSR      R0,R0,#+3
   \   000000E0   000051E1           CMP      R1,R0
   \   000000E4   0100A091           MOVLS    R0,R1
   \   000000E8   1112A0E1           LSL      R1,R1,R2
   1021            //
   1022            // According to [1]: "4.6.2.2 Write" (Timeout Conditions), the maximum
   1023            // write timeout needs to be limited to 250 msec. Convert 250 msec to
   1024            // byte transfers using the FOP.
   1025            //
   1026            NacWrite = 250 * Freq;
   1027            NacWrite >>= 3;
   \   000000EC   FA20A0E3           MOV      R2,#+250
   \   000000F0   920803E0           MUL      R3,R2,R8
   \   000000F4   A321A0E1           LSR      R2,R3,#+3
   1028            if (NacWrite > Nac) {
   \   000000F8   020051E1           CMP      R1,R2
   \   000000FC   0210A081           MOVHI    R1,R2
   1029              NacWrite = Nac;
   1030            }
   1031            /* Decode the version-specific parameters */
   1032            if (CSDVersion == 0) {
   \   00000100   000057E3           CMP      R7,#+0
   \   00000104   2400001A           BNE      ??_ApplyCSD_3
   1033              /* Calculate number of sectors available on the medium */
   1034              Factor     = (U16)(1 << CSD_READ_BL_LEN(pCSD)) / BYTES_PER_SECTOR;
   1035              Factor     *= 1 << (CSD_C_SIZE_MULT(pCSD) + 2);
   1036              CardSize   = CSD_C_SIZE(pCSD) + 1;
   1037              CardSize   *= Factor;
   \   00000108   0630D5E5           LDRB     R3,[R5, #+6]
   \   0000010C   07C0D5E5           LDRB     R12,[R5, #+7]
   \   00000110   05E0D5E5           LDRB     LR,[R5, #+5]
   \   00000114   0120A0E3           MOV      R2,#+1
   \   00000118   03348CE1           ORR      R3,R12,R3, LSL #+8
   \   0000011C   08C0D5E5           LDRB     R12,[R5, #+8]
   \   00000120   0FE00EE2           AND      LR,LR,#0xF
   \   00000124   03348CE1           ORR      R3,R12,R3, LSL #+8
   \   00000128   12CEA0E1           LSL      R12,R2,LR
   \   0000012C   0337A0E1           LSL      R3,R3,#+14
   \   00000130   0CC8A0E1           LSL      R12,R12,#+16
   \   00000134   233A82E0           ADD      R3,R2,R3, LSR #+20
   \   00000138   ACCCA0E1           LSR      R12,R12,#+25
   \   0000013C   8C0363E1           SMULBB   R3,R12,R3
   \   00000140   09C0D5E5           LDRB     R12,[R5, #+9]
   \   00000144   0AE0D5E5           LDRB     LR,[R5, #+10]
   \   00000148   0CC48EE1           ORR      R12,LR,R12, LSL #+8
   \   0000014C   ACC3A0E1           LSR      R12,R12,#+7
   \   00000150   07C00CE2           AND      R12,R12,#0x7
   \   00000154   02C08CE2           ADD      R12,R12,#+2
   \   00000158   122CA0E1           LSL      R2,R2,R12
   \   0000015C   920307E0           MUL      R7,R2,R3
   1038            } else if (CSDVersion == 1){  // Newer SD V2 cards.
   1039              /* Calculate number of sectors available on the medium */
   1040              CardSize   = CSD_C_SIZE_V2(pCSD) << 10;
   1041              /* Version 2 cards use CCS to specify SDHC support */
   1042              if (ccs) {
   1043                pInst->CardType = CARD_TYPE_SDHC;
   1044              }
   1045            } else {
   1046              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: _ApplyCSD: Unsupported CSD version.\n"));
   1047              return 1;
   1048            }
   1049            //
   1050            //  Store calculated values into medium's instance structure.
   1051            //
   1052            pInst->Nac              = NacRead;
   \                     ??_ApplyCSD_4:
   \   00000160   0C0084E5           STR      R0,[R4, #+12]
   1053            pInst->Nwrite           = NacWrite;
   \   00000164   101084E5           STR      R1,[R4, #+16]
   1054            pInst->IsWriteProtected = CSD_WRITE_PROTECT(pCSD) | FS_MMC_HW_X_IsWriteProtected(Unit);
   \   00000168   0E00D5E5           LDRB     R0,[R5, #+14]
   \   0000016C   2002A0E1           LSR      R0,R0,#+4
   \   00000170   035000E2           AND      R5,R0,#0x3
   \   00000174   0600A0E1           MOV      R0,R6
   \   00000178   ........           BL       FS_MMC_HW_X_IsWriteProtected
   \   0000017C   050080E1           ORR      R0,R0,R5
   \   00000180   0100C4E5           STRB     R0,[R4, #+1]
   1055            pInst->BytesPerSector   = BYTES_PER_SECTOR;
   \   00000184   800FA0E3           MOV      R0,#+512
   \   00000188   B400C4E1           STRH     R0,[R4, #+4]
   1056            pInst->NumSectors       = CardSize;
   \   0000018C   087084E5           STR      R7,[R4, #+8]
   1057            return 0;
   \   00000190   0000A0E3           MOV      R0,#+0
   \                     ??_ApplyCSD_0:
   \   00000194   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000198   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??_ApplyCSD_3:
   \   0000019C   010057E3           CMP      R7,#+1
   \   000001A0   0B00001A           BNE      ??_ApplyCSD_5
   \   000001A4   0720D5E5           LDRB     R2,[R5, #+7]
   \   000001A8   0830D5E5           LDRB     R3,[R5, #+8]
   \   000001AC   022483E1           ORR      R2,R3,R2, LSL #+8
   \   000001B0   0930D5E5           LDRB     R3,[R5, #+9]
   \   000001B4   022483E1           ORR      R2,R3,R2, LSL #+8
   \   000001B8   0275A0E1           LSL      R7,R2,#+10
   \   000001BC   0020DDE5           LDRB     R2,[SP, #+0]
   \   000001C0   000052E3           CMP      R2,#+0
   \   000001C4   E5FFFF0A           BEQ      ??_ApplyCSD_4
   \   000001C8   0220A0E3           MOV      R2,#+2
   \   000001CC   0320C4E5           STRB     R2,[R4, #+3]
   \   000001D0   E2FFFFEA           B        ??_ApplyCSD_4
   \                     ??_ApplyCSD_5:
   \   000001D4   0100A0E3           MOV      R0,#+1
   \   000001D8   EDFFFFEA           B        ??_ApplyCSD_0
   1058          }
   1059          
   1060          /*********************************************************************
   1061          *
   1062          *       _InitMMCSD
   1063          *
   1064          *  Description:
   1065          *    Initializes SD V1.xx and all MMC card in order to get all necessary
   1066          *    information from card.
   1067          *
   1068          *  Return value:
   1069          *    ==0           - CSD has been read and all parameters are okay.
   1070          *    <0            - An error has occurred.
   1071          *
   1072          *  Notes
   1073          *    (1)           MMC Specs says (sect 6.3, power up) that it takes max. 1 ms
   1074          *                  for the card to be ready (leave idle/init)
   1075          *                  At 400 kHz, this equals 9 loops.
   1076          *                  At lower speeds, less repetitions would be o.k.,
   1077          *                  but a few more ms. should not hurt (only in case the
   1078          *                  card is not present)
   1079          */

   \                                 In section .text, align 4, keep-with-next
   1080          static int _InitMMCSD(MMC_INST * pInst) {
   \                     _InitMMCSD:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   14D04DE2           SUB      SP,SP,#+20
   1081            CSD csd;
   1082            int i;
   1083            U8  Response;
   1084            U8  r;
   1085            U8  Unit;
   1086          
   1087            Unit = pInst->Unit;
   \   0000000C   0250D4E5           LDRB     R5,[R4, #+2]
   1088            i = 2000;       /* Note 1 */
   \   00000010   7D6EA0E3           MOV      R6,#+2000
   1089            do {   /* Try initializing as SD card first. Note (1) */
   1090              FS_MMC_HW_X_EnableCS(Unit);
   \                     ??_InitMMCSD_0:
   \   00000014   0500A0E1           MOV      R0,R5
   \   00000018   ........           BL       FS_MMC_HW_X_EnableCS
   1091              Response = _ExecCmdR1(pInst, CMD_ACMD_CMD, 0); /* Prepare for advanced command */
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   3710A0E3           MOV      R1,#+55
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       _ExecCmdR1
   1092              _SendEmptyCycles(Unit, 1); /* Clock card before next command */
   \   0000002C   FF10A0E3           MOV      R1,#+255
   \   00000030   0110CDE5           STRB     R1,[SP, #+1]
   \   00000034   0120A0E3           MOV      R2,#+1
   \   00000038   01108DE2           ADD      R1,SP,#+1
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   ........           BL       FS_MMC_HW_X_Write
   1093              Response = _ExecCmdR1(pInst, ACMD_SEND_OP_COND, 0); /* Send ACMD41 (SD_SEND_OP_COND) */
   \   00000044   0020A0E3           MOV      R2,#+0
   \   00000048   2910A0E3           MOV      R1,#+41
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       _ExecCmdR1
   \   00000054   0070A0E1           MOV      R7,R0
   1094              FS_MMC_HW_X_DisableCS(Unit);
   \   00000058   0500A0E1           MOV      R0,R5
   \   0000005C   ........           BL       FS_MMC_HW_X_DisableCS
   1095              _SendEmptyCycles(Unit, 1); /* Clock card before next command */
   \   00000060   FF10A0E3           MOV      R1,#+255
   \   00000064   0010CDE5           STRB     R1,[SP, #+0]
   \   00000068   0120A0E3           MOV      R2,#+1
   \   0000006C   0D10A0E1           MOV      R1,SP
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   ........           BL       FS_MMC_HW_X_Write
   1096          
   1097              if (Response == 0) { /* SD card is now ready */
   \   00000078   000057E3           CMP      R7,#+0
   \   0000007C   0800001A           BNE      ??_InitMMCSD_1
   1098                pInst->CardType = CARD_TYPE_SD;
   \   00000080   0100A0E3           MOV      R0,#+1
   \                     ??_InitMMCSD_2:
   \   00000084   0300C4E5           STRB     R0,[R4, #+3]
   1099                break;
   1100              }
   1101              if (Response & 4) {
   1102                break; /* command not accepted */
   1103              }
   1104              if (--i == 0) {
   1105                Response = 0xff; // Report time-out
   1106                break;
   1107              }
   1108            } while (1);
   1109            if (Response != 0) {                /* We need to try to init it as MMC */
   1110              i = 2000;                    /* Note 1 */
   1111              do {
   1112                FS_MMC_HW_X_EnableCS(Unit);
   1113                Response = _ExecCmdR1(pInst, CMD_SEND_OP_COND, 0); /* Send CMD1 (SEND_OP_COND) until ready or timeout. */
   1114                FS_MMC_HW_X_DisableCS(Unit);
   1115                _SendEmptyCycles(Unit, 1); /* Clock card before next command */
   1116                if (Response == 0) {
   1117                  pInst->CardType = CARD_TYPE_MMC;
   1118                  break;          /* Card is ready ! */
   1119          
   1120                }
   1121                if (Response != 1) {
   1122                  FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: _InitMMCSD: Illegal response.\n"));
   1123                  return -1;
   1124                }
   1125                if  (--i == 0) {
   1126                  FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: _InitMMCSD: Time out during init.\n"));
   1127                  return -1;
   1128                }
   1129              } while (1);
   1130            }
   1131            r = _ReadCSD(pInst, &csd);
   1132            if (r != 0) {
   \                     ??_InitMMCSD_3:
   \   00000088   04108DE2           ADD      R1,SP,#+4
   \   0000008C   0400A0E1           MOV      R0,R4
   \   00000090   ........           BL       _ReadCSD
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   2000000A           BEQ      ??_InitMMCSD_4
   1133              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: _InitMMCSD: CSD (card spec. data) invalid.\n"));
   1134              return -1;       /* Error */
   \                     ??_InitMMCSD_5:
   \   0000009C   0000E0E3           MVN      R0,#+0
   \   000000A0   260000EA           B        ??_InitMMCSD_6
   1135            }
   \                     ??_InitMMCSD_1:
   \   000000A4   040017E3           TST      R7,#0x4
   \   000000A8   0200001A           BNE      ??_InitMMCSD_7
   \   000000AC   016056E2           SUBS     R6,R6,#+1
   \   000000B0   D7FFFF1A           BNE      ??_InitMMCSD_0
   \   000000B4   010000EA           B        ??_InitMMCSD_8
   \                     ??_InitMMCSD_7:
   \   000000B8   000057E3           CMP      R7,#+0
   \   000000BC   F1FFFF0A           BEQ      ??_InitMMCSD_3
   \                     ??_InitMMCSD_8:
   \   000000C0   7D6EA0E3           MOV      R6,#+2000
   \                     ??_InitMMCSD_9:
   \   000000C4   0500A0E1           MOV      R0,R5
   \   000000C8   ........           BL       FS_MMC_HW_X_EnableCS
   \   000000CC   0020A0E3           MOV      R2,#+0
   \   000000D0   0110A0E3           MOV      R1,#+1
   \   000000D4   0400A0E1           MOV      R0,R4
   \   000000D8   ........           BL       _ExecCmdR1
   \   000000DC   0070A0E1           MOV      R7,R0
   \   000000E0   0500A0E1           MOV      R0,R5
   \   000000E4   ........           BL       FS_MMC_HW_X_DisableCS
   \   000000E8   FF10A0E3           MOV      R1,#+255
   \   000000EC   0010CDE5           STRB     R1,[SP, #+0]
   \   000000F0   0120A0E3           MOV      R2,#+1
   \   000000F4   0D10A0E1           MOV      R1,SP
   \   000000F8   0500A0E1           MOV      R0,R5
   \   000000FC   ........           BL       FS_MMC_HW_X_Write
   \   00000100   000057E3           CMP      R7,#+0
   \   00000104   0000A003           MOVEQ    R0,#+0
   \   00000108   DDFFFF0A           BEQ      ??_InitMMCSD_2
   \   0000010C   010057E3           CMP      R7,#+1
   \   00000110   E1FFFF1A           BNE      ??_InitMMCSD_5
   \   00000114   016056E2           SUBS     R6,R6,#+1
   \   00000118   E9FFFF1A           BNE      ??_InitMMCSD_9
   \   0000011C   DEFFFFEA           B        ??_InitMMCSD_5
   1136            r = _ApplyCSD(pInst, &csd);
   1137            if (r != 0) {
   \                     ??_InitMMCSD_4:
   \   00000120   04108DE2           ADD      R1,SP,#+4
   \   00000124   0400A0E1           MOV      R0,R4
   \   00000128   ........           BL       _ApplyCSD
   \   0000012C   000CB0E1           LSLS     R0,R0,#+24
   \   00000130   D9FFFF1A           BNE      ??_InitMMCSD_5
   1138              return -1;       /* Error */
   1139            }
   1140            pInst->IsInited = 1;
   \   00000134   0100A0E3           MOV      R0,#+1
   \   00000138   0000C4E5           STRB     R0,[R4, #+0]
   1141            return 0;
   \   0000013C   0000A0E3           MOV      R0,#+0
   \                     ??_InitMMCSD_6:
   \   00000140   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000144   F080BDE8           POP      {R4-R7,PC}       ;; return
   1142          }
   1143          
   1144          /*********************************************************************
   1145          *
   1146          *       _InitSDV2
   1147          *
   1148          *  Description:
   1149          *
   1150          *    and set it to SPI mode.
   1151          *
   1152          *  Parameters:
   1153          *    Unit      - Device index number
   1154          *
   1155          *  Return value:
   1156          *    ==0           - CSD has been read and all parameters are OK.
   1157          *    <0            - An error has occurred.
   1158          *
   1159          *  Notes
   1160          *    (1)           MMC Specs says (sect 6.3, power up) that it takes max. 1 ms
   1161          *                  for the card to be ready (leave idle/init)
   1162          *                  At 400 kHz, this equals 9 loops.
   1163          *                  At lower speeds, less repetitions would be o.k.,
   1164          *                  but a few more ms. should not hurt (only in case the
   1165          *                  card is not present)
   1166          */

   \                                 In section .text, align 4, keep-with-next
   1167          static int _InitSDV2(MMC_INST * pInst) {
   \                     _InitSDV2:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   14D04DE2           SUB      SP,SP,#+20
   1168            CSD csd;
   1169            int i;
   1170            U8  c;
   1171            U8  Unit;
   1172          
   1173            Unit = pInst->Unit;
   \   0000000C   0250D4E5           LDRB     R5,[R4, #+2]
   1174            i = 2000;       /* Note 1 */
   \   00000010   7D6EA0E3           MOV      R6,#+2000
   1175            do {   /* Try initializing as SD card first. Note (1) */
   1176              FS_MMC_HW_X_EnableCS(Unit);
   \                     ??_InitSDV2_0:
   \   00000014   0500A0E1           MOV      R0,R5
   \   00000018   ........           BL       FS_MMC_HW_X_EnableCS
   1177              //
   1178              // Prepare for advanced command
   1179              //
   1180              c = _ExecCmdR1(pInst, CMD_ACMD_CMD, 0);
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   3710A0E3           MOV      R1,#+55
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       _ExecCmdR1
   1181              _SendEmptyCycles(Unit, 1); /* Clock card before next command */
   \   0000002C   FF10A0E3           MOV      R1,#+255
   \   00000030   0110CDE5           STRB     R1,[SP, #+1]
   \   00000034   0120A0E3           MOV      R2,#+1
   \   00000038   01108DE2           ADD      R1,SP,#+1
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   ........           BL       FS_MMC_HW_X_Write
   1182              //
   1183              // Send ACMD41 (SD_SEND_OP_COND), set argument, that host supports HC.
   1184              //
   1185              c = _ExecCmdR1(pInst, ACMD_SEND_OP_COND, (1UL << 30));
   \   00000044   4024A0E3           MOV      R2,#+1073741824
   \   00000048   2910A0E3           MOV      R1,#+41
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       _ExecCmdR1
   \   00000054   0070A0E1           MOV      R7,R0
   1186              FS_MMC_HW_X_DisableCS(Unit);
   \   00000058   0500A0E1           MOV      R0,R5
   \   0000005C   ........           BL       FS_MMC_HW_X_DisableCS
   1187              _SendEmptyCycles(Unit, 1); /* Clock card before next command */
   \   00000060   FF10A0E3           MOV      R1,#+255
   \   00000064   0010CDE5           STRB     R1,[SP, #+0]
   \   00000068   0120A0E3           MOV      R2,#+1
   \   0000006C   0D10A0E1           MOV      R1,SP
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   ........           BL       FS_MMC_HW_X_Write
   1188          
   1189              if (c == 0) { /* SD card is now ready */
   \   00000078   000057E3           CMP      R7,#+0
   1190                break;
   1191              }
   1192            } while (--i);
   \   0000007C   01605612           SUBSNE   R6,R6,#+1
   \   00000080   E3FFFF1A           BNE      ??_InitSDV2_0
   1193            c = _ReadCSD(pInst, &csd);
   1194            if (c != 0) {
   \   00000084   04108DE2           ADD      R1,SP,#+4
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   ........           BL       _ReadCSD
   \   00000090   000050E3           CMP      R0,#+0
   1195              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: _InitSDV2: CSD (card spec. data) invalid.\n"));
   1196              return -1;       /* Error */
   \   00000094   0000E013           MVNNE    R0,#+0
   \   00000098   0800001A           BNE      ??_InitSDV2_1
   1197            }
   1198            //
   1199            // Card is identified as SD card
   1200            // We check later whether it is a standard or HC card.
   1201            pInst->CardType = CARD_TYPE_SD;
   \   0000009C   0150A0E3           MOV      R5,#+1
   \   000000A0   0350C4E5           STRB     R5,[R4, #+3]
   1202            c = _ApplyCSD(pInst, &csd);
   1203            if (c != 0) {
   \   000000A4   04108DE2           ADD      R1,SP,#+4
   \   000000A8   0400A0E1           MOV      R0,R4
   \   000000AC   ........           BL       _ApplyCSD
   \   000000B0   000CB0E1           LSLS     R0,R0,#+24
   1204              return -1;       /* Error */
   \   000000B4   00006512           RSBNE    R0,R5,#+0
   1205            }
   1206            pInst->IsInited = 1;
   \   000000B8   0050C405           STRBEQ   R5,[R4, #+0]
   1207            return 0;
   \   000000BC   0000A003           MOVEQ    R0,#+0
   \                     ??_InitSDV2_1:
   \   000000C0   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000000C4   F080BDE8           POP      {R4-R7,PC}       ;; return
   1208          }
   1209          
   1210          
   1211          
   1212          /*********************************************************************
   1213          *
   1214          *       _MMC_Init
   1215          *
   1216          *  Description:
   1217          *    MMC driver internal function. Reset the card, reset SPI clock speed
   1218          *    and set it to SPI mode.
   1219          *
   1220          *  Parameters:
   1221          *    Unit      - Device index number
   1222          *
   1223          *  Return value:
   1224          *    ==0           - CSD has been read and all parameters are okay.
   1225          *    <0            - An error has occurred.
   1226          *
   1227          *  Notes
   1228          *    (1)   Argument structure for CMD8 (SEND_IF_COND)
   1229          *           [31..12] - Shall be zero
   1230          *           [11.. 8] - Voltage Supply (VHS):
   1231          *                      Defined Voltage Supplied Values (VHS defined by SDCard Spec V2.00)
   1232          *                        0x00 - Not Defined
   1233          *                        0x01 - 2.7-3.6V
   1234          *                        0x02 - Reserved for Low Voltage Range
   1235          *                        0x04 - Reserved
   1236          *                        0x08 - Reserved
   1237          *                        Others Not Defined
   1238          *           [ 7.. 0] - Check Pattern. It is recommended to use the value 0xAA as pattern.
   1239          *
   1240          *
   1241          */

   \                                 In section .text, align 4, keep-with-next
   1242          static int _MMC_Init(MMC_INST * pInst) {
   \                     _MMC_Init:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1243            int i;
   1244            U8  Response;
   1245            U16 CurrFreq;
   1246            U8  Unit;
   1247            U8  aResponse7[4];
   1248            int r;
   1249          
   1250            Unit     = pInst->Unit;
   \   00000008   0250D4E5           LDRB     R5,[R4, #+2]
   \   0000000C   14D04DE2           SUB      SP,SP,#+20
   1251            Response = 0;
   1252            r        = -1;
   \   00000010   0060E0E3           MVN      R6,#+0
   1253            CurrFreq = FS_MMC_HW_X_SetMaxSpeed(Unit, STARTUPFREQ); /* set initial speed for SPI */
   1254            if (CurrFreq > STARTUPFREQ) {
   \   00000014   641FA0E3           MOV      R1,#+400
   \   00000018   0500A0E1           MOV      R0,R5
   \   0000001C   ........           BL       FS_MMC_HW_X_SetMaxSpeed
   \   00000020   9110A0E3           MOV      R1,#+145
   \   00000024   401F81E3           ORR      R1,R1,#0x100
   \   00000028   010050E1           CMP      R0,R1
   \   0000002C   5100002A           BCS      ??_MMC_Init_0
   1255              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: _MMC_Init: Frequency is greater than allowed for initialization.\n"));
   1256              return -1;
   1257            }
   1258            pInst->Nac = NAC_CSD_MAX;
   \   00000030   5000A0E3           MOV      R0,#+80
   \   00000034   C30C80E3           ORR      R0,R0,#0xC300
   \   00000038   0C0084E5           STR      R0,[R4, #+12]
   1259            //
   1260            // Send empty cycles and CMD0 (GO_IDLE_STATE) until card responds with 0x01 = OK.
   1261            // Allow multiple tries.
   1262            //
   1263            i = 0;
   \   0000003C   0070A0E3           MOV      R7,#+0
   \   00000040   ............       ADRL     R8,`?<Constant {64, 0, 0, 0, 0, 149}>`
   \              ....        
   1264            do {
   1265              FS_MMC_HW_X_DisableCS(Unit);
   \                     ??_MMC_Init_1:
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   ........           BL       FS_MMC_HW_X_DisableCS
   1266              _SendEmptyCycles(Unit, BOOTUPCYCLES); /* Clock card before reset sequence */
   \   00000050   FF10A0E3           MOV      R1,#+255
   \   00000054   0010CDE5           STRB     R1,[SP, #+0]
   \   00000058   0A90A0E3           MOV      R9,#+10
   \                     ??_MMC_Init_2:
   \   0000005C   0120A0E3           MOV      R2,#+1
   \   00000060   0D10A0E1           MOV      R1,SP
   \   00000064   0500A0E1           MOV      R0,R5
   \   00000068   ........           BL       FS_MMC_HW_X_Write
   \   0000006C   019059E2           SUBS     R9,R9,#+1
   \   00000070   F9FFFF1A           BNE      ??_MMC_Init_2
   1267              Response = _ExecCmdInit(Unit); /* CMD0 (GO_IDLE_STATE) */
   \   00000074   0600B8E8           LDM      R8!,{R1,R2}
   \   00000078   08008DE2           ADD      R0,SP,#+8
   \   0000007C   0600A0E8           STM      R0!,{R1,R2}
   \   00000080   088048E2           SUB      R8,R8,#+8
   \   00000084   0500A0E1           MOV      R0,R5
   \   00000088   ........           BL       FS_MMC_HW_X_EnableCS
   \   0000008C   0620A0E3           MOV      R2,#+6
   \   00000090   08108DE2           ADD      R1,SP,#+8
   \   00000094   0500A0E1           MOV      R0,R5
   \   00000098   ........           BL       FS_MMC_HW_X_Write
   \   0000009C   0120A0E3           MOV      R2,#+1
   \   000000A0   0D10A0E1           MOV      R1,SP
   \   000000A4   0500A0E1           MOV      R0,R5
   \   000000A8   ........           BL       FS_MMC_HW_X_Read
   \   000000AC   0000DDE5           LDRB     R0,[SP, #+0]
   \   000000B0   FF0050E3           CMP      R0,#+255
   \   000000B4   0A90A013           MOVNE    R9,#+10
   \   000000B8   0790A003           MOVEQ    R9,#+7
   \                     ??_MMC_Init_3:
   \   000000BC   0120A0E3           MOV      R2,#+1
   \   000000C0   0D10A0E1           MOV      R1,SP
   \   000000C4   0500A0E1           MOV      R0,R5
   \   000000C8   ........           BL       FS_MMC_HW_X_Read
   \   000000CC   0000DDE5           LDRB     R0,[SP, #+0]
   \   000000D0   FF0050E3           CMP      R0,#+255
   \   000000D4   0090A011           MOVNE    R9,R0
   \   000000D8   0300001A           BNE      ??_MMC_Init_4
   \   000000DC   019049E2           SUB      R9,R9,#+1
   \   000000E0   FF9019E2           ANDS     R9,R9,#0xFF
   \   000000E4   F4FFFF1A           BNE      ??_MMC_Init_3
   \   000000E8   FF90A0E3           MOV      R9,#+255
   \                     ??_MMC_Init_4:
   \   000000EC   0500A0E1           MOV      R0,R5
   \   000000F0   ........           BL       FS_MMC_HW_X_DisableCS
   \   000000F4   FF10A0E3           MOV      R1,#+255
   \   000000F8   0010CDE5           STRB     R1,[SP, #+0]
   \   000000FC   0120A0E3           MOV      R2,#+1
   \   00000100   0D10A0E1           MOV      R1,SP
   \   00000104   0500A0E1           MOV      R0,R5
   \   00000108   ........           BL       FS_MMC_HW_X_Write
   1268              if (Response & 1) { /* if card is not in idle state, return with error */
   \   0000010C   010019E3           TST      R9,#0x1
   \   00000110   1B00000A           BEQ      ??_MMC_Init_5
   1269                break;
   1270              }
   1271              if (++i == MAX_RETRIES) {
   1272                FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: Init: Card is not in idle state.\n"));
   1273                return -1;  /* now you may need to power cycle the card */
   1274              }
   1275            } while (1);
   1276            //
   1277            // Send CMD8 to card, SD HC or SD cards V2.00 card will accept the command
   1278            // all other cards will reply that this is an illegal command.
   1279            // Initially we will only read one byte from card.
   1280            // If it is not an illegal command, we will do further reading.
   1281            //
   1282            FS_MMC_HW_X_EnableCS(Unit);
   \   00000114   0500A0E1           MOV      R0,R5
   \   00000118   ........           BL       FS_MMC_HW_X_EnableCS
   1283            Response = _ExecCmdR1(pInst, CMD_SEND_IF_COND, (0x01 << 8) | 0xAA); // Note 1
   1284            if ((Response & 4)) {  // Illegal command, not a SD V2 card.
   \   0000011C   AA20A0E3           MOV      R2,#+170
   \   00000120   402F82E3           ORR      R2,R2,#0x100
   \   00000124   0810A0E3           MOV      R1,#+8
   \   00000128   0400A0E1           MOV      R0,R4
   \   0000012C   ........           BL       _ExecCmdR1
   \   00000130   040010E3           TST      R0,#0x4
   \   00000134   1600001A           BNE      ??_MMC_Init_6
   1285              FS_MMC_HW_X_DisableCS(Unit);
   1286              r = _InitMMCSD(pInst);
   1287            } else {
   1288              FS_MMC_HW_X_Read(pInst->Unit, &aResponse7[0], sizeof(aResponse7));
   \   00000138   0420A0E3           MOV      R2,#+4
   \   0000013C   04108DE2           ADD      R1,SP,#+4
   \   00000140   0200D4E5           LDRB     R0,[R4, #+2]
   \   00000144   ........           BL       FS_MMC_HW_X_Read
   1289              FS_MMC_HW_X_DisableCS(Unit);
   \   00000148   0500A0E1           MOV      R0,R5
   \   0000014C   ........           BL       FS_MMC_HW_X_DisableCS
   1290              //
   1291              // Did the card return the correct pattern?
   1292              //
   1293              if ((aResponse7[3] == 0xAA) && ((aResponse7[2] & 0xF) == 0x01)) {
   \   00000150   0700DDE5           LDRB     R0,[SP, #+7]
   \   00000154   AA0050E3           CMP      R0,#+170
   \   00000158   0600001A           BNE      ??_MMC_Init_0
   \   0000015C   0600DDE5           LDRB     R0,[SP, #+6]
   \   00000160   0F0000E2           AND      R0,R0,#0xF
   \   00000164   010050E3           CMP      R0,#+1
   \   00000168   0200001A           BNE      ??_MMC_Init_0
   1294                r = _InitSDV2(pInst);
   \   0000016C   0400A0E1           MOV      R0,R4
   \   00000170   ........           BL       _InitSDV2
   \                     ??_MMC_Init_7:
   \   00000174   0060A0E1           MOV      R6,R0
   1295              }
   1296            }
   1297            return r;
   \                     ??_MMC_Init_0:
   \   00000178   0600A0E1           MOV      R0,R6
   \   0000017C   14D08DE2           ADD      SP,SP,#+20
   \   00000180   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??_MMC_Init_5:
   \   00000184   017087E2           ADD      R7,R7,#+1
   \   00000188   050057E3           CMP      R7,#+5
   \   0000018C   ADFFFF1A           BNE      ??_MMC_Init_1
   \   00000190   F8FFFFEA           B        ??_MMC_Init_0
   \                     ??_MMC_Init_6:
   \   00000194   0500A0E1           MOV      R0,R5
   \   00000198   ........           BL       FS_MMC_HW_X_DisableCS
   \   0000019C   0400A0E1           MOV      R0,R4
   \   000001A0   ........           BL       _InitMMCSD
   \   000001A4   F2FFFFEA           B        ??_MMC_Init_7
   1298          }
   1299          
   1300          
   1301          /*********************************************************************
   1302          *
   1303          *       Semi-public Code called through function pointer
   1304          *
   1305          **********************************************************************
   1306          */
   1307          
   1308          
   1309          /*********************************************************************
   1310          *
   1311          *       _MMC_GetStatus
   1312          *
   1313          *  Description:
   1314          *    FS driver function. Get status of the media,
   1315          *    Initialize the card if necessary.
   1316          *
   1317          *  Parameters:
   1318          *    Unit        - Unit number.
   1319          *
   1320          *  Return value:
   1321          *    FS_MEDIA_STATE_UNKNOWN - if the state of the media is unknown.
   1322          *    FS_MEDIA_NOT_PRESENT   - if no card is present.
   1323          *    FS_MEDIA_IS_PRESENT    - if a card is present.
   1324          */

   \                                 In section .text, align 4, keep-with-next
   1325          static int _MMC_GetStatus(U8 Unit) {
   1326            return FS_MMC_HW_X_IsPresent(Unit);
   \                     _MMC_GetStatus:
   \   00000000   ........           B        FS_MMC_HW_X_IsPresent  ;; tailcall
   1327          }
   1328          
   1329          /*********************************************************************
   1330          *
   1331          *       _MMC_IoCtl
   1332          *
   1333          *  Description:
   1334          *    FS driver function. Execute device command.
   1335          *
   1336          *  Parameters:
   1337          *    Unit      - Device Index.
   1338          *    Cmd         - Command to be executed.
   1339          *    Aux         - Parameter depending on command.
   1340          *    pBuffer     - Pointer to a buffer used for the command.
   1341          *
   1342          *  Return value:
   1343          *    Command specific. In general a negative value means an error.
   1344          */

   \                                 In section .text, align 4, keep-with-next
   1345          static int _MMC_IoCtl(U8 Unit, I32 Cmd, I32 Aux, void *pBuffer) {
   \                     _MMC_IoCtl:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1346            FS_DEV_INFO * pDevInfo;
   1347            MMC_INST    * pInst;
   1348          
   1349            FS_USE_PARA(Aux);
   1350            pInst = _apInst[Unit];
   \   00000004   ........           LDR      R2,??DataTable17_1
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0340A0E1           MOV      R4,R3
   \   00000010   005192E7           LDR      R5,[R2, +R0, LSL #+2]
   1351            switch (Cmd) {
   \   00000014   FB1F51E2           SUBS     R1,R1,#+1004
   \   00000018   0800000A           BEQ      ??_MMC_IoCtl_0
   \   0000001C   041041E2           SUB      R1,R1,#+4
   \   00000020   010051E3           CMP      R1,#+1
   \   00000024   1100008A           BHI      ??_MMC_IoCtl_1
   1352            case FS_CMD_UNMOUNT:
   1353            case FS_CMD_UNMOUNT_FORCED:
   1354              FS_MEMSET(pInst, 0, sizeof(MMC_INST));
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   0020A0E3           MOV      R2,#+0
   \   00000034   0700A5E8           STM      R5!,{R0-R2}
   \   00000038   0300A5E8           STM      R5!,{R0,R1}
   1355              break;
   \   0000003C   0B0000EA           B        ??_MMC_IoCtl_1
   1356            case FS_CMD_GET_DEVINFO: /* Get general device information */
   1357              if (pInst->IsInited == 0) {
   \                     ??_MMC_IoCtl_0:
   \   00000040   0000D5E5           LDRB     R0,[R5, #+0]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0400001A           BNE      ??_MMC_IoCtl_2
   1358                if (_MMC_Init(pInst)) {
   \   0000004C   0500A0E1           MOV      R0,R5
   \   00000050   ........           BL       _MMC_Init
   \   00000054   000050E3           CMP      R0,#+0
   1359                  return -1;
   \   00000058   0000E013           MVNNE    R0,#+0
   \   0000005C   0400001A           BNE      ??_MMC_IoCtl_3
   1360                }
   1361              }
   1362              pDevInfo = (FS_DEV_INFO *)pBuffer;
   1363              pDevInfo->BytesPerSector = pInst->BytesPerSector;
   \                     ??_MMC_IoCtl_2:
   \   00000060   B400D5E1           LDRH     R0,[R5, #+4]
   \   00000064   B800C4E1           STRH     R0,[R4, #+8]
   1364              pDevInfo->NumSectors     = pInst->NumSectors;
   \   00000068   080095E5           LDR      R0,[R5, #+8]
   \   0000006C   040084E5           STR      R0,[R4, #+4]
   1365              break;
   1366          #if FS_SUPPORT_DEINIT
   1367            case FS_CMD_DEINIT:
   1368              FS_FREE(pInst);
   1369              _NumUnits--;
   1370              return 0;
   1371          #endif
   1372            }
   1373            return 0;
   \                     ??_MMC_IoCtl_1:
   \   00000070   0000A0E3           MOV      R0,#+0
   \                     ??_MMC_IoCtl_3:
   \   00000074   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000078   3080BDE8           POP      {R4,R5,PC}       ;; return
   1374          }
   1375          
   1376          /*********************************************************************
   1377          *
   1378          *       _ReadSectors
   1379          *
   1380          */

   \                                 In section .text, align 4, keep-with-next
   1381          static int _ReadSectors(MMC_INST * pInst, U32 SectorNo, U8 * pBuffer, U32 NumSectors) {
   \                     _ReadSectors:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0360A0E1           MOV      R6,R3
   1382            U8         a;
   1383            U8         aCRC[2];
   1384            U16        Crc;
   1385            U16        CalcedCrc;
   1386            U8         Cmd;
   1387            int        r;
   1388            U8         Unit;
   1389          
   1390            Unit  = pInst->Unit;
   1391            r     = -1;                       // Default is to return error
   1392            Cmd   = (NumSectors == 1) ? CMD_READ_SINGLE_BLOCK : CMD_READ_MULTIPLE_BLOCKS;
   1393            if (pInst->CardType != CARD_TYPE_SDHC) {
   \   0000000C   0300D4E5           LDRB     R0,[R4, #+3]
   \   00000010   0270D4E5           LDRB     R7,[R4, #+2]
   \   00000014   010056E3           CMP      R6,#+1
   \   00000018   1190A003           MOVEQ    R9,#+17
   \   0000001C   1290A013           MOVNE    R9,#+18
   \   00000020   01A0A0E1           MOV      R10,R1
   \   00000024   020050E3           CMP      R0,#+2
   \   00000028   04D04DE2           SUB      SP,SP,#+4
   \   0000002C   0250A0E1           MOV      R5,R2
   \   00000030   0080E0E3           MVN      R8,#+0
   1394              SectorNo *= BYTES_PER_SECTOR;
   \   00000034   8AA4A011           LSLNE    R10,R10,#+9
   1395            }
   1396            //
   1397            // Send command
   1398            //
   1399            FS_MMC_HW_X_DisableCS(Unit);
   \   00000038   0700A0E1           MOV      R0,R7
   \   0000003C   ........           BL       FS_MMC_HW_X_DisableCS
   1400            _SendEmptyCycles(Unit, 1);
   \   00000040   FF10A0E3           MOV      R1,#+255
   \   00000044   0010CDE5           STRB     R1,[SP, #+0]
   \   00000048   0120A0E3           MOV      R2,#+1
   \   0000004C   0D10A0E1           MOV      R1,SP
   \   00000050   0700A0E1           MOV      R0,R7
   \   00000054   ........           BL       FS_MMC_HW_X_Write
   1401            FS_MMC_HW_X_EnableCS(Unit);
   \   00000058   0700A0E1           MOV      R0,R7
   \   0000005C   ........           BL       FS_MMC_HW_X_EnableCS
   1402            a = _ExecCmdR1(pInst, Cmd, SectorNo);  /* Do not handle clock&CS automatically */
   1403            //
   1404            // Read sector by sector
   1405            //
   1406            if (a == 0) {
   \   00000060   0A20A0E1           MOV      R2,R10
   \   00000064   0910A0E1           MOV      R1,R9
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   ........           BL       _ExecCmdR1
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   4400001A           BNE      ??_ReadSectors_0
   1407              do {
   1408                a = _WaitBlockRdTok(pInst); /* wait for data block to begin */
   \                     ??_ReadSectors_1:
   \   00000078   0CB094E5           LDR      R11,[R4, #+12]
   \   0000007C   02A0D4E5           LDRB     R10,[R4, #+2]
   \   00000080   00005BE3           CMP      R11,#+0
   \   00000084   4000000A           BEQ      ??_ReadSectors_0
   \   00000088   01001BE3           TST      R11,#0x1
   \   0000008C   0600000A           BEQ      ??_ReadSectors_2
   \   00000090   0120A0E3           MOV      R2,#+1
   \   00000094   0D10A0E1           MOV      R1,SP
   \   00000098   0A00A0E1           MOV      R0,R10
   \   0000009C   ........           BL       FS_MMC_HW_X_Read
   \   000000A0   0000DDE5           LDRB     R0,[SP, #+0]
   \   000000A4   FE0050E3           CMP      R0,#+254
   \   000000A8   1200000A           BEQ      ??_ReadSectors_3
   \                     ??_ReadSectors_2:
   \   000000AC   ABB0B0E1           LSRS     R11,R11,#+1
   \   000000B0   3500000A           BEQ      ??_ReadSectors_0
   \                     ??_ReadSectors_4:
   \   000000B4   0120A0E3           MOV      R2,#+1
   \   000000B8   0D10A0E1           MOV      R1,SP
   \   000000BC   0A00A0E1           MOV      R0,R10
   \   000000C0   ........           BL       FS_MMC_HW_X_Read
   \   000000C4   0000DDE5           LDRB     R0,[SP, #+0]
   \   000000C8   FE0050E3           CMP      R0,#+254
   \   000000CC   0900000A           BEQ      ??_ReadSectors_3
   \   000000D0   0120A0E3           MOV      R2,#+1
   \   000000D4   0D10A0E1           MOV      R1,SP
   \   000000D8   0A00A0E1           MOV      R0,R10
   \   000000DC   ........           BL       FS_MMC_HW_X_Read
   \   000000E0   0000DDE5           LDRB     R0,[SP, #+0]
   \   000000E4   FE0050E3           CMP      R0,#+254
   \   000000E8   0200000A           BEQ      ??_ReadSectors_3
   \   000000EC   01B05BE2           SUBS     R11,R11,#+1
   \   000000F0   EFFFFF1A           BNE      ??_ReadSectors_4
   \   000000F4   240000EA           B        ??_ReadSectors_0
   1409                if (a == 0xFF) {
   1410                  break;                   // Error
   1411                }
   1412                FS_MMC_HW_X_Read(Unit, pBuffer, BYTES_PER_SECTOR); // read one sector
   \                     ??_ReadSectors_3:
   \   000000F8   802FA0E3           MOV      R2,#+512
   \   000000FC   0510A0E1           MOV      R1,R5
   \   00000100   0700A0E1           MOV      R0,R7
   \   00000104   ........           BL       FS_MMC_HW_X_Read
   1413                FS_MMC_HW_X_Read(Unit, aCRC, 2);                   // read CRC16
   \   00000108   0220A0E3           MOV      R2,#+2
   \   0000010C   02108DE2           ADD      R1,SP,#+2
   \   00000110   0700A0E1           MOV      R0,R7
   \   00000114   ........           BL       FS_MMC_HW_X_Read
   1414                Crc = (aCRC[0] << 8) | (aCRC[1]);
   \   00000118   0200DDE5           LDRB     R0,[SP, #+2]
   \   0000011C   0310DDE5           LDRB     R1,[SP, #+3]
   1415                CalcedCrc = _CalcDataCRC16(pBuffer, BYTES_PER_SECTOR);
   \   00000120   ........           LDR      R2,??DataTable17_2
   \   00000124   00A481E1           ORR      R10,R1,R0, LSL #+8
   \   00000128   801FA0E3           MOV      R1,#+512
   \   0000012C   0500A0E1           MOV      R0,R5
   \   00000130   002092E5           LDR      R2,[R2, #+0]
   \   00000134   32FF2FE1           BLX      R2
   1416                if ((CalcedCrc != 0xffff) && (CalcedCrc != Crc)) {
   \   00000138   2818A0E1           MOV      R1,R8, LSR #+16
   \   0000013C   010050E1           CMP      R0,R1
   \   00000140   0A005011           CMPNE    R0,R10
   \   00000144   0600000A           BEQ      ??_ReadSectors_5
   1417                  FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "Received wrong CRC, received 0x%8x, expected 0x%8x @Sector 0x%8x", Crc, CalcedCrc, SectorNo));
   1418                  if (Cmd == CMD_READ_MULTIPLE_BLOCKS) {
   \   00000148   120059E3           CMP      R9,#+18
   \   0000014C   0E00001A           BNE      ??_ReadSectors_0
   1419                    _ExecCmdR1(pInst, CMD_STOP_TRANSMISSION, 0);  /* Do not handle clock&CS automatically */
   \   00000150   0020A0E3           MOV      R2,#+0
   \   00000154   0C10A0E3           MOV      R1,#+12
   \   00000158   0400A0E1           MOV      R0,R4
   \   0000015C   ........           BL       _ExecCmdR1
   \   00000160   090000EA           B        ??_ReadSectors_0
   1420                  }
   1421                  break;
   1422                }
   1423                pBuffer += BYTES_PER_SECTOR;
   \                     ??_ReadSectors_5:
   \   00000164   805F85E2           ADD      R5,R5,#+512
   1424                if (--NumSectors == 0) {                           // Are we done ?
   \   00000168   016056E2           SUBS     R6,R6,#+1
   \   0000016C   C1FFFF1A           BNE      ??_ReadSectors_1
   1425                  if (Cmd == CMD_READ_MULTIPLE_BLOCKS) {
   \   00000170   120059E3           CMP      R9,#+18
   \   00000174   0300001A           BNE      ??_ReadSectors_6
   1426                    _ExecCmdR1(pInst, CMD_STOP_TRANSMISSION, 0);  /* Do not handle clock&CS automatically */
   \   00000178   0020A0E3           MOV      R2,#+0
   \   0000017C   0C10A0E3           MOV      R1,#+12
   \   00000180   0400A0E1           MOV      R0,R4
   \   00000184   ........           BL       _ExecCmdR1
   1427                  }
   1428                  r = 0;
   \                     ??_ReadSectors_6:
   \   00000188   0080A0E3           MOV      R8,#+0
   1429                  break;
   1430                }
   1431              } while (1);
   1432            }
   1433            //
   1434            // We are done. Disable CS and send some dummy clocks.
   1435            //
   1436            FS_MMC_HW_X_DisableCS(Unit);
   \                     ??_ReadSectors_0:
   \   0000018C   0700A0E1           MOV      R0,R7
   \   00000190   ........           BL       FS_MMC_HW_X_DisableCS
   1437            _SendEmptyCycles(Unit, 1);
   \   00000194   FF10A0E3           MOV      R1,#+255
   \   00000198   0010CDE5           STRB     R1,[SP, #+0]
   \   0000019C   0120A0E3           MOV      R2,#+1
   \   000001A0   0D10A0E1           MOV      R1,SP
   \   000001A4   0700A0E1           MOV      R0,R7
   \   000001A8   ........           BL       FS_MMC_HW_X_Write
   1438            return r;
   \   000001AC   0800A0E1           MOV      R0,R8
   \   000001B0   04D08DE2           ADD      SP,SP,#+4
   \   000001B4   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1439          }
   1440          
   1441          /*********************************************************************
   1442          *
   1443          *       _MMC_Read
   1444          *
   1445          *  Description:
   1446          *    Reads one or more sectors from the media.
   1447          *
   1448          *    Unit          - Device index number
   1449          *    Sector        - Sector to be read from the device.
   1450          *    NumSectors    - Number of sectors to be transferred
   1451          *    pBuffer       - Pointer to buffer to be stored.
   1452          *    RepeatSame    - Shall be the same data written
   1453          *
   1454          *  Return value:
   1455          *    ==0         - All sector(s) have been read
   1456          *    <0          - An error has occurred.
   1457          */

   \                                 In section .text, align 4, keep-with-next
   1458          static int _MMC_Read(U8 Unit, U32 SectorNo, void * p, U32 NumSectors) {
   \                     _MMC_Read:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   1459            int           r;
   1460            U8       * pBuffer;
   1461            MMC_INST * pInst;
   1462            int        Retry = FS_MMC_NUM_RETRIES;
   1463          
   1464            pInst   = _apInst[Unit];
   \   00000008   ........           LDR      R1,??DataTable17_1
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   0360A0E1           MOV      R6,R3
   \   00000014   0370A0E3           MOV      R7,#+3
   \   00000018   008191E7           LDR      R8,[R1, +R0, LSL #+2]
   1465            pBuffer = (U8 *)p;
   \   0000001C   000000EA           B        ??_MMC_Read_0
   1466          
   1467          OnRetry:
   1468            r = _ReadSectors(pInst, SectorNo, pBuffer, NumSectors);
   1469            if (r && Retry) {
   1470              --Retry;
   \                     ??_MMC_Read_1:
   \   00000020   017047E2           SUB      R7,R7,#+1
   1471              goto OnRetry;
   1472            }
   \                     ??_MMC_Read_0:
   \   00000024   0630A0E1           MOV      R3,R6
   \   00000028   0520A0E1           MOV      R2,R5
   \   0000002C   0410A0E1           MOV      R1,R4
   \   00000030   0800A0E1           MOV      R0,R8
   \   00000034   ........           BL       _ReadSectors
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   00005713           CMPNE    R7,#+0
   \   00000040   F6FFFF1A           BNE      ??_MMC_Read_1
   1473            return r;
   \   00000044   F081BDE8           POP      {R4-R8,PC}       ;; return
   1474          
   1475          }
   1476          
   1477          
   1478          
   1479          /*********************************************************************
   1480          *
   1481          *       _MMC_Write
   1482          *
   1483          *  Description:
   1484          *    Write one ore more sectors to the media.
   1485          *
   1486          *  Parameters:
   1487          *    Unit          - Device index number
   1488          *    Sector        - Sector to be written to the device.
   1489          *    NumSectors    - Number of sectors to be transferred
   1490          *    pBuffer       - Pointer to data to be stored.
   1491          *    RepeatSame    - Shall be the same data written
   1492          *
   1493          *  Return value:
   1494          *    ==0           - Sector has been written to the device.
   1495          *    <0            - An error has occurred.
   1496          */

   \                                 In section .text, align 4, keep-with-next
   1497          static int _WriteSectors(MMC_INST * pInst, U32 SectorNo, const U8 * pBuffer, U32 NumSectors, U8 RepeatSame) {
   \                     _WriteSectors:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0360A0E1           MOV      R6,R3
   1498            U8         c;
   1499            int        r;
   1500            U8         aCRC[2];
   1501            U16        crc;
   1502            U8         Cmd;
   1503            U8         Unit;
   1504          
   1505            Unit    = pInst->Unit;
   1506            r       = -1;
   1507            Cmd     = (NumSectors == 1) ? CMD_WRITE_BLOCK : CMD_WRITE_MULTIPLE_BLOCK;
   1508            if (pInst->CardType != CARD_TYPE_SDHC) {
   \   0000000C   0300D4E5           LDRB     R0,[R4, #+3]
   \   00000010   0270D4E5           LDRB     R7,[R4, #+2]
   \   00000014   010056E3           CMP      R6,#+1
   \   00000018   1890A003           MOVEQ    R9,#+24
   \   0000001C   1990A013           MOVNE    R9,#+25
   \   00000020   01A0A0E1           MOV      R10,R1
   \   00000024   020050E3           CMP      R0,#+2
   \   00000028   0CD04DE2           SUB      SP,SP,#+12
   \   0000002C   0250A0E1           MOV      R5,R2
   \   00000030   0080E0E3           MVN      R8,#+0
   1509              SectorNo *= BYTES_PER_SECTOR;
   \   00000034   8AA4A011           LSLNE    R10,R10,#+9
   1510            }
   1511            //
   1512            // Send command
   1513            //
   1514            FS_MMC_HW_X_DisableCS(Unit);
   \   00000038   0700A0E1           MOV      R0,R7
   \   0000003C   ........           BL       FS_MMC_HW_X_DisableCS
   1515            _SendEmptyCycles(Unit, 1);
   \   00000040   FF10A0E3           MOV      R1,#+255
   \   00000044   0110CDE5           STRB     R1,[SP, #+1]
   \   00000048   0120A0E3           MOV      R2,#+1
   \   0000004C   01108DE2           ADD      R1,SP,#+1
   \   00000050   0700A0E1           MOV      R0,R7
   \   00000054   ........           BL       FS_MMC_HW_X_Write
   1516            FS_MMC_HW_X_EnableCS(Unit);  /* CS on */
   \   00000058   0700A0E1           MOV      R0,R7
   \   0000005C   ........           BL       FS_MMC_HW_X_EnableCS
   1517            c = _ExecCmdR1(pInst, Cmd, SectorNo);
   \   00000060   0A20A0E1           MOV      R2,R10
   \   00000064   0910A0E1           MOV      R1,R9
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   ........           BL       _ExecCmdR1
   \   00000070   0000CDE5           STRB     R0,[SP, #+0]
   1518            if (c != 0) {
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   4C00001A           BNE      ??_WriteSectors_0
   1519              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: _Write: Write failed.\n"));
   1520              goto End;
   1521            }
   1522            _SendEmptyCycles(Unit, 1); /* Nwr */
   \   0000007C   FF10A0E3           MOV      R1,#+255
   \   00000080   0110CDE5           STRB     R1,[SP, #+1]
   \   00000084   0120A0E3           MOV      R2,#+1
   \   00000088   01108DE2           ADD      R1,SP,#+1
   \   0000008C   0700A0E1           MOV      R0,R7
   \   00000090   ........           BL       FS_MMC_HW_X_Write
   1523            //
   1524            // Transfer data one sector at a time
   1525            //
   1526            do {
   1527              crc = _CalcDataCRC16(pBuffer, BYTES_PER_SECTOR);
   \                     ??_WriteSectors_1:
   \   00000094   ........           LDR      R2,??DataTable17_2
   \   00000098   801FA0E3           MOV      R1,#+512
   \   0000009C   0500A0E1           MOV      R0,R5
   \   000000A0   002092E5           LDR      R2,[R2, #+0]
   \   000000A4   32FF2FE1           BLX      R2
   1528              aCRC[0] = (U8)(crc >> 8);
   \   000000A8   4014A0E1           ASR      R1,R0,#+8
   \   000000AC   0210CDE5           STRB     R1,[SP, #+2]
   1529              aCRC[1] = (U8)crc;
   1530              c = (Cmd == CMD_WRITE_BLOCK) ? TOKEN_BLOCK_WRITE_START : TOKEN_MULTI_BLOCK_WRITE_START;   /* Send data token */
   \   000000B0   180059E3           CMP      R9,#+24
   \   000000B4   FE10A003           MOVEQ    R1,#+254
   \   000000B8   FC10A013           MOVNE    R1,#+252
   \   000000BC   0300CDE5           STRB     R0,[SP, #+3]
   \   000000C0   0010CDE5           STRB     R1,[SP, #+0]
   1531              FS_MMC_HW_X_Write(Unit, &c, 1);
   \   000000C4   0120A0E3           MOV      R2,#+1
   \   000000C8   0D10A0E1           MOV      R1,SP
   \   000000CC   0700A0E1           MOV      R0,R7
   \   000000D0   ........           BL       FS_MMC_HW_X_Write
   1532              FS_MMC_HW_X_Write(Unit, pBuffer, BYTES_PER_SECTOR);
   \   000000D4   802FA0E3           MOV      R2,#+512
   \   000000D8   0510A0E1           MOV      R1,R5
   \   000000DC   0700A0E1           MOV      R0,R7
   \   000000E0   ........           BL       FS_MMC_HW_X_Write
   1533              FS_MMC_HW_X_Write(Unit, aCRC, 2);
   \   000000E4   0220A0E3           MOV      R2,#+2
   \   000000E8   02108DE2           ADD      R1,SP,#+2
   \   000000EC   0700A0E1           MOV      R0,R7
   \   000000F0   ........           BL       FS_MMC_HW_X_Write
   1534              //
   1535              // Get data response token (MMC spec 7.6.2, Figure 52)
   1536              // Should be XXX00101
   1537              //
   1538              FS_MMC_HW_X_Read(Unit, &c, 1);
   \   000000F4   0120A0E3           MOV      R2,#+1
   \   000000F8   0D10A0E1           MOV      R1,SP
   \   000000FC   0700A0E1           MOV      R0,R7
   \   00000100   ........           BL       FS_MMC_HW_X_Read
   1539              if ((c & 0x1f) != 5) {
   \   00000104   0000DDE5           LDRB     R0,[SP, #+0]
   \   00000108   1F0000E2           AND      R0,R0,#0x1F
   \   0000010C   050050E3           CMP      R0,#+5
   \   00000110   2600001A           BNE      ??_WriteSectors_0
   1540                FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: _Write: Write failed, data not accepted.\n"));
   1541                goto End;
   1542              }
   1543              //
   1544              // Wait for card to get ready
   1545              //
   1546              if (_WaitToGetReady(pInst)) {
   \   00000114   02A0D4E5           LDRB     R10,[R4, #+2]
   \   00000118   10B094E5           LDR      R11,[R4, #+16]
   \                     ??_WriteSectors_2:
   \   0000011C   0120A0E3           MOV      R2,#+1
   \   00000120   01108DE2           ADD      R1,SP,#+1
   \   00000124   0A00A0E1           MOV      R0,R10
   \   00000128   ........           BL       FS_MMC_HW_X_Read
   \   0000012C   0100DDE5           LDRB     R0,[SP, #+1]
   \   00000130   000050E3           CMP      R0,#+0
   \   00000134   1600000A           BEQ      ??_WriteSectors_3
   1547                FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: _Write: Write failed (timeout).\n"));
   1548                goto End;
   1549              }
   1550              if (RepeatSame == 0) {
   \   00000138   3000DDE5           LDRB     R0,[SP, #+48]
   \   0000013C   000050E3           CMP      R0,#+0
   1551                pBuffer += BYTES_PER_SECTOR;
   \   00000140   805F8502           ADDEQ    R5,R5,#+512
   1552              }
   1553            } while (--NumSectors);
   \   00000144   016056E2           SUBS     R6,R6,#+1
   \   00000148   D1FFFF1A           BNE      ??_WriteSectors_1
   1554            //
   1555            // Send the stop token to card, this indicates, that we are finished sending data to card
   1556            //
   1557            if (Cmd == CMD_WRITE_MULTIPLE_BLOCK) {
   \   0000014C   190059E3           CMP      R9,#+25
   \   00000150   1500001A           BNE      ??_WriteSectors_4
   1558              c = TOKEN_MULTI_BLOCK_WRITE_STOP;
   \   00000154   FD10A0E3           MOV      R1,#+253
   \   00000158   0010CDE5           STRB     R1,[SP, #+0]
   1559              FS_MMC_HW_X_Write(Unit, &c, 1);
   \   0000015C   0120A0E3           MOV      R2,#+1
   \   00000160   0D10A0E1           MOV      R1,SP
   \   00000164   0700A0E1           MOV      R0,R7
   \   00000168   ........           BL       FS_MMC_HW_X_Write
   1560              if (_WaitToGetReady(pInst) == 0) {
   \   0000016C   0250D4E5           LDRB     R5,[R4, #+2]
   \   00000170   104094E5           LDR      R4,[R4, #+16]
   \                     ??_WriteSectors_5:
   \   00000174   0120A0E3           MOV      R2,#+1
   \   00000178   04108DE2           ADD      R1,SP,#+4
   \   0000017C   0500A0E1           MOV      R0,R5
   \   00000180   ........           BL       FS_MMC_HW_X_Read
   \   00000184   0400DDE5           LDRB     R0,[SP, #+4]
   \   00000188   000050E3           CMP      R0,#+0
   \   0000018C   0300000A           BEQ      ??_WriteSectors_6
   1561                r = 0;                                    // Success !
   \   00000190   050000EA           B        ??_WriteSectors_4
   1562              }
   1563            } else {
   \                     ??_WriteSectors_3:
   \   00000194   01B05BE2           SUBS     R11,R11,#+1
   \   00000198   DFFFFF1A           BNE      ??_WriteSectors_2
   \   0000019C   030000EA           B        ??_WriteSectors_0
   \                     ??_WriteSectors_6:
   \   000001A0   014054E2           SUBS     R4,R4,#+1
   \   000001A4   F2FFFF1A           BNE      ??_WriteSectors_5
   \   000001A8   000000EA           B        ??_WriteSectors_0
   1564              r = 0;
   \                     ??_WriteSectors_4:
   \   000001AC   0080A0E3           MOV      R8,#+0
   1565            }
   1566          End:
   1567            FS_MMC_HW_X_DisableCS(Unit);
   \                     ??_WriteSectors_0:
   \   000001B0   0700A0E1           MOV      R0,R7
   \   000001B4   ........           BL       FS_MMC_HW_X_DisableCS
   1568            _SendEmptyCycles(Unit, 1);
   \   000001B8   FF10A0E3           MOV      R1,#+255
   \   000001BC   0110CDE5           STRB     R1,[SP, #+1]
   \   000001C0   0120A0E3           MOV      R2,#+1
   \   000001C4   01108DE2           ADD      R1,SP,#+1
   \   000001C8   0700A0E1           MOV      R0,R7
   \   000001CC   ........           BL       FS_MMC_HW_X_Write
   1569            if (r) {
   1570              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER,  "MMC SPI: _Write: Write failed.\n"));
   1571            }
   1572            return r;
   \   000001D0   0800A0E1           MOV      R0,R8
   \   000001D4   0CD08DE2           ADD      SP,SP,#+12
   \   000001D8   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1573          }
   1574          
   1575          
   1576          /*********************************************************************
   1577          *
   1578          *       _MMC_Write
   1579          *
   1580          *  Description:
   1581          *    Write one ore more sectors to the media.
   1582          *
   1583          *  Parameters:
   1584          *    Unit          - Device index number
   1585          *    Sector        - Sector to be written to the device.
   1586          *    NumSectors    - Number of sectors to be transferred
   1587          *    pBuffer       - Pointer to data to be stored.
   1588          *    RepeatSame    - Shall be the same data written
   1589          *
   1590          *  Return value:
   1591          *    ==0           - Sector has been written to the device.
   1592          *    <0            - An error has occurred.
   1593          */

   \                                 In section .text, align 4, keep-with-next
   1594          static int _MMC_Write(U8 Unit, U32 SectorNo, const void * p, U32 NumSectors, U8 RepeatSame) {
   \                     _MMC_Write:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   1595            const U8 * pBuffer;
   1596            MMC_INST * pInst;
   1597            int           r;
   1598            int           Retry = FS_MMC_NUM_RETRIES;
   1599          
   1600            pInst = _apInst[Unit];
   \   00000008   ........           LDR      R1,??DataTable17_1
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   009191E7           LDR      R9,[R1, +R0, LSL #+2]
   \   00000014   0250A0E1           MOV      R5,R2
   1601            if (pInst->IsWriteProtected) {
   \   00000018   0100D9E5           LDRB     R0,[R9, #+1]
   \   0000001C   0360A0E1           MOV      R6,R3
   \   00000020   2070DDE5           LDRB     R7,[SP, #+32]
   \   00000024   0380A0E3           MOV      R8,#+3
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0200000A           BEQ      ??_MMC_Write_0
   1602              return -1;
   \   00000030   0000E0E3           MVN      R0,#+0
   \   00000034   090000EA           B        ??_MMC_Write_1
   1603            }
   1604            pBuffer = (const U8 *)p;
   1605          OnRetry:
   1606            r = _WriteSectors(pInst, SectorNo, pBuffer, NumSectors, RepeatSame);
   1607            if (r && Retry) {
   1608              --Retry;
   \                     ??_MMC_Write_2:
   \   00000038   018048E2           SUB      R8,R8,#+1
   1609              goto OnRetry;
   1610            }
   \                     ??_MMC_Write_0:
   \   0000003C   00708DE5           STR      R7,[SP, #+0]
   \   00000040   0630A0E1           MOV      R3,R6
   \   00000044   0520A0E1           MOV      R2,R5
   \   00000048   0410A0E1           MOV      R1,R4
   \   0000004C   0900A0E1           MOV      R0,R9
   \   00000050   ........           BL       _WriteSectors
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   00005813           CMPNE    R8,#+0
   \   0000005C   F5FFFF1A           BNE      ??_MMC_Write_2
   1611            return r;
   \                     ??_MMC_Write_1:
   \   00000060   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000064   F083BDE8           POP      {R4-R9,PC}       ;; return
   1612          
   1613          
   1614          }
   1615          /*********************************************************************
   1616          *
   1617          *       _MMC_InitMedium
   1618          *
   1619          *  Description:
   1620          *    Initialize the card.
   1621          *
   1622          *  Parameters:
   1623          *    Unit        - Unit number.
   1624          *
   1625          *  Return value:
   1626          *    == 0                       - Device OK and ready for operation.
   1627          *    <  0                       - An error has occurred.
   1628          */

   \                                 In section .text, align 4, keep-with-next
   1629          static int _MMC_InitMedium(U8 Unit) {
   \                     _MMC_InitMedium:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1630            int        r;
   1631            MMC_INST * pInst;
   1632          
   1633            pInst = _apInst[Unit];
   \   00000004   ........           LDR      R2,??DataTable17_1
   \   00000008   0010A0E1           MOV      R1,R0
   \   0000000C   014192E7           LDR      R4,[R2, +R1, LSL #+2]
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   1634            r     = -1;
   1635            if (pInst->IsInited == 0) {
   \   00000014   0010D4E5           LDRB     R1,[R4, #+0]
   \   00000018   0050E0E3           MVN      R5,#+0
   \   0000001C   000051E3           CMP      R1,#+0
   \   00000020   0500001A           BNE      ??_MMC_InitMedium_0
   1636              if (_MMC_GetStatus(Unit) != FS_MEDIA_NOT_PRESENT) {
   \   00000024   ........           BL       FS_MMC_HW_X_IsPresent
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0200000A           BEQ      ??_MMC_InitMedium_0
   1637                r = _MMC_Init(pInst);
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       _MMC_Init
   \   00000038   0050A0E1           MOV      R5,R0
   1638                if (r < 0) { /* init failed, no valid card in slot */
   1639                  FS_DEBUG_WARN((FS_MTYPE_DRIVER, "MMC: Init failure, no valid card found"));
   1640                }
   1641              }
   1642            }
   1643            return r;
   \                     ??_MMC_InitMedium_0:
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   04D08DE2           ADD      SP,SP,#+4
   \   00000044   3080BDE8           POP      {R4,R5,PC}       ;; return
   1644          }
   1645          
   1646          
   1647          /*********************************************************************
   1648          *
   1649          *       _MMC_AddDevice
   1650          *
   1651          *  Description:
   1652          *    Initializes the low-level driver object.
   1653          *
   1654          *  Return value:
   1655          *    >= 0                       - Command successfully executed, Unit no.
   1656          *    <  0                       - Error, could not add device
   1657          *
   1658          */

   \                                 In section .text, align 4, keep-with-next
   1659          static int _MMC_AddDevice(void) {
   \                     _MMC_AddDevice:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1660            U8         Unit;
   1661            MMC_INST * pInst;
   1662          
   1663            if (_NumUnits >= NUM_UNITS) {
   \   00000004   ........           LDR      R4,??DataTable17_1
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   040094E5           LDR      R0,[R4, #+4]
   \   00000010   010050E3           CMP      R0,#+1
   1664              return -1;
   \   00000014   0000E0A3           MVNGE    R0,#+0
   \   00000018   080000AA           BGE      ??_MMC_AddDevice_0
   1665            }
   1666            Unit = _NumUnits++;
   \   0000001C   0050A0E1           MOV      R5,R0
   \   00000020   010080E2           ADD      R0,R0,#+1
   \   00000024   040084E5           STR      R0,[R4, #+4]
   1667            pInst = (MMC_INST *)FS_AllocZeroed(sizeof(MMC_INST));   // Alloc memory. This is guaranteed to work by the memory module.
   \   00000028   1400A0E3           MOV      R0,#+20
   \   0000002C   ........           BL       FS_AllocZeroed
   1668            _apInst[Unit] = pInst;
   \   00000030   FF1005E2           AND      R1,R5,#0xFF
   \   00000034   010184E7           STR      R0,[R4, +R1, LSL #+2]
   1669            pInst->Unit   = Unit;
   \   00000038   0250C0E5           STRB     R5,[R0, #+2]
   1670            return Unit;
   \   0000003C   0100A0E1           MOV      R0,R1
   \                     ??_MMC_AddDevice_0:
   \   00000040   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000044   3080BDE8           POP      {R4,R5,PC}       ;; return
   1671          }
   1672          
   1673          /*********************************************************************
   1674          *
   1675          *       _MMC_GetNumUnits
   1676          */

   \                                 In section .text, align 4, keep-with-next
   1677          static int _MMC_GetNumUnits(void) {
   1678            return _NumUnits;
   \                     _MMC_GetNumUnits:
   \   00000000   ........           LDR      R0,??DataTable17_1
   \   00000004   040090E5           LDR      R0,[R0, #+4]
   \   00000008   1EFF2FE1           BX       LR               ;; return
   1679          }
   1680          
   1681          /*********************************************************************
   1682          *
   1683          *       _MMC_GetDriverName
   1684          */

   \                                 In section .text, align 4, keep-with-next
   1685          static const char * _MMC_GetDriverName(U8 Unit) {
   1686            FS_USE_PARA(Unit);
   1687            return "mmc";
   \                     _MMC_GetDriverName:
   \   00000000   ........           ADR      R0,??DataTable17  ;; "mmc"
   \   00000004   1EFF2FE1           BX       LR               ;; return
   1688          }
   1689          
   1690          /*********************************************************************
   1691          *
   1692          *       Public code
   1693          *
   1694          **********************************************************************
   1695          */
   1696          
   1697          /*********************************************************************
   1698          *
   1699          *      FS_MMC_GetCardId
   1700          *
   1701          *  Description:
   1702          *    This function retrieves the card Id of SD/MMC card.
   1703          *
   1704          *  Parameters:
   1705          *    Unit          - Device index number.
   1706          *    pCardID       - Pointer to a MMC_CARD_ID structure.
   1707          *
   1708          *  Return value:
   1709          *    ==0           - CardId has been read.
   1710          *    !=0           - An error has occurred.
   1711          */

   \                                 In section .text, align 4, keep-with-next
   1712          int FS_MMC_GetCardId(U8 Unit, MMC_CARD_ID * pCardId) {
   \                     FS_MMC_GetCardId:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1713            U8   Response;
   1714            U32  i;
   1715            U32  TimeOut;
   1716            U8   aData[2];
   1717            int  r;
   1718            MMC_INST * pInst;
   1719          
   1720            r = 0;
   1721            pInst = _apInst[Unit];
   \   00000008   ........           LDR      R1,??DataTable17_1
   \   0000000C   08D04DE2           SUB      SP,SP,#+8
   \   00000010   008191E7           LDR      R8,[R1, +R0, LSL #+2]
   1722            _SendEmptyCycles(Unit, 1);
   \   00000014   FF10A0E3           MOV      R1,#+255
   \   00000018   0210CDE5           STRB     R1,[SP, #+2]
   \   0000001C   0040A0E1           MOV      R4,R0
   \   00000020   0060A0E3           MOV      R6,#+0
   \   00000024   0120A0E3           MOV      R2,#+1
   \   00000028   02108DE2           ADD      R1,SP,#+2
   \   0000002C   ........           BL       FS_MMC_HW_X_Write
   1723            FS_MMC_HW_X_EnableCS(Unit);  /* CS on */
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       FS_MMC_HW_X_EnableCS
   1724          
   1725            /* Execute CMD10 (SEND_CID) */
   1726            Response = _ExecCmdR1(pInst, CMD_SEND_CID, 0);  /* Do not handle clock & CS automatically */
   1727            if (Response != 0) {
   \   00000038   0020A0E3           MOV      R2,#+0
   \   0000003C   0A10A0E3           MOV      R1,#+10
   \   00000040   0800A0E1           MOV      R0,R8
   \   00000044   ........           BL       _ExecCmdR1
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0100000A           BEQ      ??FS_MMC_GetCardId_0
   1728              r = 1;                // Error
   \                     ??FS_MMC_GetCardId_1:
   \   00000050   0160A0E3           MOV      R6,#+1
   1729              goto End;
   \   00000054   150000EA           B        ??FS_MMC_GetCardId_2
   1730            }
   1731            /* wait for CardId transfer to begin */
   1732            i = 0;
   \                     ??FS_MMC_GetCardId_0:
   \   00000058   0070A0E3           MOV      R7,#+0
   1733            TimeOut = pInst->Nac ;
   \   0000005C   0C8098E5           LDR      R8,[R8, #+12]
   1734            do {
   1735              FS_MMC_HW_X_Read(Unit, aData, 1);
   \                     ??FS_MMC_GetCardId_3:
   \   00000060   0120A0E3           MOV      R2,#+1
   \   00000064   0D10A0E1           MOV      R1,SP
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   ........           BL       FS_MMC_HW_X_Read
   1736              if (aData[0] == TOKEN_BLOCK_READ_START) {
   \   00000070   0000DDE5           LDRB     R0,[SP, #+0]
   \   00000074   FE0050E3           CMP      R0,#+254
   1737                break;
   1738              }
   1739              if (aData[0] == TOKEN_MULTI_BLOCK_WRITE_START) {
   \   00000078   FC005013           CMPNE    R0,#+252
   \   0000007C   0300000A           BEQ      ??FS_MMC_GetCardId_4
   1740                break;
   1741              }
   1742              if (++i == TimeOut) { /* timeout reached */
   \   00000080   017087E2           ADD      R7,R7,#+1
   \   00000084   080057E1           CMP      R7,R8
   \   00000088   F4FFFF1A           BNE      ??FS_MMC_GetCardId_3
   \   0000008C   EFFFFFEA           B        ??FS_MMC_GetCardId_1
   1743                r = 1;                // Error
   1744                goto End;
   1745              }
   1746            } while (1);
   1747          
   1748            /* Read the CardID */
   1749            FS_MMC_HW_X_Read(Unit, (U8*)pCardId, sizeof(MMC_CARD_ID));
   \                     ??FS_MMC_GetCardId_4:
   \   00000090   1020A0E3           MOV      R2,#+16
   \   00000094   0510A0E1           MOV      R1,R5
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   ........           BL       FS_MMC_HW_X_Read
   1750            FS_MMC_HW_X_Read(Unit, aData, 2);                       // Read CRC16
   \   000000A0   0220A0E3           MOV      R2,#+2
   \   000000A4   0D10A0E1           MOV      R1,SP
   \   000000A8   0400A0E1           MOV      R0,R4
   \   000000AC   ........           BL       FS_MMC_HW_X_Read
   1751          End:
   1752            FS_MMC_HW_X_DisableCS(Unit);
   \                     ??FS_MMC_GetCardId_2:
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   ........           BL       FS_MMC_HW_X_DisableCS
   1753            _SendEmptyCycles(Unit, 1);                             // Clock card after command
   \   000000B8   FF10A0E3           MOV      R1,#+255
   \   000000BC   0210CDE5           STRB     R1,[SP, #+2]
   \   000000C0   0120A0E3           MOV      R2,#+1
   \   000000C4   02108DE2           ADD      R1,SP,#+2
   \   000000C8   0400A0E1           MOV      R0,R4
   \   000000CC   ........           BL       FS_MMC_HW_X_Write
   1754            return r;
   \   000000D0   0600A0E1           MOV      R0,R6
   \   000000D4   08D08DE2           ADD      SP,SP,#+8
   \   000000D8   F081BDE8           POP      {R4-R8,PC}       ;; return
   1755          }
   1756          
   1757          /*********************************************************************
   1758          *
   1759          *       FS_MMC_ActivateCRC
   1760          */

   \                                 In section .text, align 4, keep-with-next
   1761          void FS_MMC_ActivateCRC(void) {
   1762            _pfCalcCRC = _CalcDataCRC16ViaTable;
   \                     FS_MMC_ActivateCRC:
   \   00000000   ........           LDR      R0,??DataTable17_2
   \   00000004   ........           LDR      R1,??DataTable17_3
   \   00000008   001080E5           STR      R1,[R0, #+0]
   1763          }
   \   0000000C   1EFF2FE1           BX       LR               ;; return
   1764          
   1765          /*********************************************************************
   1766          *
   1767          *       FS_MMC_DeactivateCRC
   1768          */

   \                                 In section .text, align 4, keep-with-next
   1769          void FS_MMC_DeactivateCRC(void) {
   1770            _pfCalcCRC = _CalcDataCRC16Dummy;
   \                     FS_MMC_DeactivateCRC:
   \   00000000   ........           LDR      R0,??DataTable17_2
   \   00000004   ........           LDR      R1,??DataTable17_4
   \   00000008   001080E5           STR      R1,[R0, #+0]
   1771          }
   \   0000000C   1EFF2FE1           BX       LR               ;; return
   1772          
   1773          /*********************************************************************
   1774          *
   1775          *       Public data
   1776          *
   1777          **********************************************************************
   1778          */

   \                                 In section .rodata, align 4, keep-with-next
   1779          const FS_DEVICE_TYPE FS_MMC_SPI_Driver = {
   \                     FS_MMC_SPI_Driver:
   \   00000000                      ; Initializer data, 32 bytes
   \   00000000   ............       DC32 _MMC_GetDriverName, _MMC_AddDevice, _MMC_Read, _MMC_Write, _MMC_IoCtl, _MMC_InitMedium, _MMC_GetStatus, _MMC_GetNumUnits
   \              ............
   \              ............
   \              ............
   \              ............
   \              ....        

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   6D6D6300           DC8      "mmc"

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   ........           DC32     _apInst

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   ........           DC32     _pfCalcCRC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   ........           DC32     _CalcDataCRC16ViaTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   ........           DC32     _CalcDataCRC16Dummy

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "mmc">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   6D6D6300           DC8 109, 109, 99, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {64, 0, 0, 0, 0, 149}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   400000000095       DC8 64, 0, 0, 0, 0, 149, 0, 0
   \              0000        
   1780            _MMC_GetDriverName,
   1781            _MMC_AddDevice,
   1782            _MMC_Read,
   1783            _MMC_Write,
   1784            _MMC_IoCtl,
   1785            _MMC_InitMedium,
   1786            _MMC_GetStatus,
   1787            _MMC_GetNumUnits
   1788          };
   1789          
   1790          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     FS_MMC_ActivateCRC          0
     FS_MMC_DeactivateCRC        0
     FS_MMC_GetCardId           32
     _ApplyCSD                  32
     _CalcDataCRC16Dummy         0
     _CalcDataCRC16ViaTable      8
     _CheckCardOCR              32
     _ExecCmdR1                 32
     _InitMMCSD                 40
     _InitSDV2                  40
     _MMC_AddDevice             16
     _MMC_GetDriverName          0
     _MMC_GetNumUnits            0
     _MMC_GetStatus              8
     _MMC_Init                  48
     _MMC_InitMedium            16
     _MMC_IoCtl                 16
     _MMC_Read                  24
     _MMC_Write                 32
     _ReadCSD                   32
     _ReadSectors               40
     _WriteSectors              48


   Section sizes:

     Function/Label                    Bytes
     --------------                    -----
     _apInst                              8
     _NumUnits
     _pfCalcCRC                           4
     _aFactor                            16
     _aUnit                              32
     _aRateUnit                          16
     _CalcDataCRC16ViaTable               8
     _CalcDataCRC16Dummy                 12
     _ExecCmdR1                         280
     _ReadCSD                           236
     _CheckCardOCR                      380
     _ApplyCSD                          476
     _InitMMCSD                         328
     _InitSDV2                          200
     _MMC_Init                          424
     _MMC_GetStatus                       4
     _MMC_IoCtl                         124
     _ReadSectors                       440
     _MMC_Read                           72
     _WriteSectors                      476
     _MMC_Write                         104
     _MMC_InitMedium                     72
     _MMC_AddDevice                      72
     _MMC_GetNumUnits                    12
     _MMC_GetDriverName                   8
     FS_MMC_GetCardId                   220
     FS_MMC_ActivateCRC                  16
     FS_MMC_DeactivateCRC                16
     FS_MMC_SPI_Driver                   32
     ??DataTable17                        4
     ??DataTable17_1                      4
     ??DataTable17_2                      4
     ??DataTable17_3                      4
     ??DataTable17_4                      4
     ?<Constant "mmc">                    4
     ?<Constant {64, 0, 0, 0, 0, 149}>    8

 
     8 bytes in section .bss
     4 bytes in section .data
    36 bytes in section .rodata
 4 072 bytes in section .text
 
 4 072 bytes of CODE  memory
    36 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: none
