###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:10:55 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDEV_AA.c                         #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDEV_AA.c -D DEBUG=1 -D           #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUIDEV_AA.lst              #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUIDEV_AA.o                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDEV_AA.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDEV_AA.c
     19          Purpose     : Memory device drawing with Antialiasing
     20          ----------------------------------------------------------------------
     21          Version-Date---Author-Explanation
     22          ----------------------------------------------------------------------
     23          1.02    000804 RS     LCD_CopyFromLCDAA added
     24          1.00a   000804 RS     Fix for odd X-sizes
     25          1.00    000728 RS     First release
     26          ----------------------------------------------------------------------
     27          Known problems or limitations with current version
     28          ----------------------------------------------------------------------
     29          None.
     30          ---------------------------END-OF-HEADER------------------------------
     31          */
     32          
     33          #include <string.h>
     34          
     35          #include "GUI_Private.h"
     36          
     37          #if GUI_SUPPORT_MEMDEV
     38          
     39          /*********************************************************************
     40          *
     41          *       defines
     42          *
     43          **********************************************************************
     44          */
     45          
     46          #define SETPIXEL(x,y,colorindex) _SetPixel(x,y,colorindex);
     47          #define BKCOLORINDEX GUI_Context.pDevData->aColorIndex[0]
     48          #define COLORINDEX   GUI_Context.pDevData->aColorIndex[1]
     49          
     50          /*********************************************************************
     51          *
     52          *       public code
     53          *
     54          **********************************************************************
     55          */
     56          /*********************************************************************
     57          *
     58          *       GUI_MEMDEV_CopyToLCDAA
     59          */

   \                                 In section .text, align 4, keep-with-next
     60          void GUI_MEMDEV_CopyToLCDAA(GUI_MEMDEV_Handle hMem) {
   \                     GUI_MEMDEV_CopyToLCDAA:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   2CD04DE2           SUB      SP,SP,#+44
   \   00000008   0040A0E1           MOV      R4,R0
     61            #if 1
     62          
     63            GUI_LOCK();
   \   0000000C   ........           BL       GUI_Lock
     64            /* Make sure memory handle is valid */
     65            if (hMem) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   4201000A           BEQ      ??GUI_MEMDEV_CopyToLCDAA_0
     66              GUI_MEMDEV_Handle hMemPrev;
     67            #if GUI_NUM_LAYERS > 1
     68              int PrevLayer;
     69            #endif
     70              int x, y;
     71              GUI_MEMDEV * pDev;
     72              int LineOff;
     73              int x0;
     74              int y0;
     75              int XMax;
     76              int YMax;
     77              int BitsPerPixel;
     78              int BytesPerPixel;
     79              unsigned PixelIndex;
     80              int ColorSep[3];
     81              U32 Color;
     82          
     83              pDev     = (GUI_MEMDEV *)GUI_ALLOC_h2p(hMem);  /* Convert to pointer */
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           BL       GUI_ALLOC_h2p
   \   00000020   0040A0E1           MOV      R4,R0
     84              LineOff  = pDev->XSize;
   \   00000024   F800D4E1           LDRSH    R0,[R4, #+8]
     85              x0       = pDev->x0;
     86              y0       = pDev->y0;
     87              XMax     = pDev->XSize / 2;
     88              YMax     = pDev->YSize / 2;
     89              hMemPrev = GUI_Context.hDevData;
   \   00000028   ........           LDR      R1,??DataTable1
   \   0000002C   18008DE5           STR      R0,[SP, #+24]
   \   00000030   F420D4E1           LDRSH    R2,[R4, #+4]
   \   00000034   0008A0E1           LSL      R0,R0,#+16
   \   00000038   2008A0E1           LSR      R0,R0,#+16
   \   0000003C   A00780E0           ADD      R0,R0,R0, LSR #+15
   \   00000040   1C208DE5           STR      R2,[SP, #+28]
   \   00000044   0008A0E1           LSL      R0,R0,#+16
   \   00000048   F6B0D4E1           LDRSH    R11,[R4, #+6]
   \   0000004C   C008A0E1           ASR      R0,R0,#+17
   \   00000050   14008DE5           STR      R0,[SP, #+20]
   \   00000054   FA00D4E1           LDRSH    R0,[R4, #+10]
   \   00000058   881091E5           LDR      R1,[R1, #+136]
   \   0000005C   0008A0E1           LSL      R0,R0,#+16
   \   00000060   2008A0E1           LSR      R0,R0,#+16
   \   00000064   A00780E0           ADD      R0,R0,R0, LSR #+15
   \   00000068   0008A0E1           LSL      R0,R0,#+16
   \   0000006C   C068A0E1           ASR      R6,R0,#+17
   \   00000070   24108DE5           STR      R1,[SP, #+36]
     90            #if GUI_NUM_LAYERS > 1
     91              PrevLayer = GUI_SelectLayer(pDev->pDevice->LayerIndex);   /* Should not we switch back to the orig. layer when done ? */
   \   00000074   000094E5           LDR      R0,[R4, #+0]
   \   00000078   180090E5           LDR      R0,[R0, #+24]
   \   0000007C   ........           BL       GUI_SelectLayer
   \   00000080   20008DE5           STR      R0,[SP, #+32]
     92            #else
     93              GUI_SelectLCD();  /* Activate LCD */
     94            #endif
     95              BitsPerPixel = pDev->BitsPerPixel;
   \   00000084   100094E5           LDR      R0,[R4, #+16]
     96              if (BitsPerPixel <= 8) {
   \   00000088   090050E3           CMP      R0,#+9
   \   0000008C   5F0000AA           BGE      ??GUI_MEMDEV_CopyToLCDAA_1
     97                BytesPerPixel = 1;
     98              } else if (BitsPerPixel <= 16) {
     99                BytesPerPixel = 2;
    100              } else {
    101                BytesPerPixel = 4;
    102              }
    103              switch (BytesPerPixel) {
    104              case 1: {
    105                  U8 * pData0;
    106                  pData0   = (U8 *)(pDev + 1);
   \   00000090   181084E2           ADD      R1,R4,#+24
   \   00000094   04108DE5           STR      R1,[SP, #+4]
    107                  for (y = 0; y < YMax; y++) {
   \   00000098   010056E3           CMP      R6,#+1
   \   0000009C   1C0100BA           BLT      ??GUI_MEMDEV_CopyToLCDAA_2
   \   000000A0   00608DE5           STR      R6,[SP, #+0]
   \   000000A4   08408DE2           ADD      R4,SP,#+8
    108                    U8 * pData;
    109                    pData = (U8 *)pData0;
    110                    for (x = 0; x < XMax; x++) {
   \                     ??GUI_MEMDEV_CopyToLCDAA_3:
   \   000000A8   14009DE5           LDR      R0,[SP, #+20]
   \   000000AC   04509DE5           LDR      R5,[SP, #+4]
   \   000000B0   010050E3           CMP      R0,#+1
   \   000000B4   4A0000BA           BLT      ??GUI_MEMDEV_CopyToLCDAA_4
   \   000000B8   18009DE5           LDR      R0,[SP, #+24]
   \   000000BC   1C609DE5           LDR      R6,[SP, #+28]
   \   000000C0   057080E0           ADD      R7,R0,R5
   \   000000C4   14809DE5           LDR      R8,[SP, #+20]
    111                      PixelIndex = *pData;
    112                      Color = LCD_Index2Color(PixelIndex);
   \                     ??GUI_MEMDEV_CopyToLCDAA_5:
   \   000000C8   0100D5E4           LDRB     R0,[R5], #+1
   \   000000CC   ........           BL       LCD_Index2Color
    113                      ColorSep[0] = Color & 255;
   \   000000D0   FF1000E2           AND      R1,R0,#0xFF
   \   000000D4   08108DE5           STR      R1,[SP, #+8]
    114                      ColorSep[1] = (Color >> 8)  & 255;
   \   000000D8   FF10A0E3           MOV      R1,#+255
   \   000000DC   201401E0           AND      R1,R1,R0, LSR #+8
   \   000000E0   041084E5           STR      R1,[R4, #+4]
    115                      ColorSep[2] = (Color >> 16) & 255;
   \   000000E4   FF10A0E3           MOV      R1,#+255
   \   000000E8   200801E0           AND      R0,R1,R0, LSR #+16
   \   000000EC   080084E5           STR      R0,[R4, #+8]
    116                      PixelIndex = *(pData + 1);
    117                      Color = LCD_Index2Color(PixelIndex);
   \   000000F0   0100D5E4           LDRB     R0,[R5], #+1
   \   000000F4   ........           BL       LCD_Index2Color
    118                      ColorSep[0] += Color & 255;
   \   000000F8   08109DE5           LDR      R1,[SP, #+8]
   \   000000FC   FF2000E2           AND      R2,R0,#0xFF
   \   00000100   011082E0           ADD      R1,R2,R1
   \   00000104   08108DE5           STR      R1,[SP, #+8]
   \   00000108   041094E5           LDR      R1,[R4, #+4]
   \   0000010C   FF20A0E3           MOV      R2,#+255
   \   00000110   202402E0           AND      R2,R2,R0, LSR #+8
   \   00000114   019082E0           ADD      R9,R2,R1
   \   00000118   081094E5           LDR      R1,[R4, #+8]
   \   0000011C   FF20A0E3           MOV      R2,#+255
   \   00000120   200802E0           AND      R0,R2,R0, LSR #+16
   \   00000124   01A080E0           ADD      R10,R0,R1
   \   00000128   049084E5           STR      R9,[R4, #+4]
   \   0000012C   08A084E5           STR      R10,[R4, #+8]
    119                      ColorSep[1] += (Color >> 8)  & 255;
    120                      ColorSep[2] += (Color >> 16) & 255;
    121                      PixelIndex = *(pData + LineOff);
    122                      Color = LCD_Index2Color(PixelIndex);
   \   00000130   0100D7E4           LDRB     R0,[R7], #+1
   \   00000134   ........           BL       LCD_Index2Color
    123                      ColorSep[0] += Color & 255;
   \   00000138   08109DE5           LDR      R1,[SP, #+8]
   \   0000013C   FF2000E2           AND      R2,R0,#0xFF
   \   00000140   011082E0           ADD      R1,R2,R1
   \   00000144   08108DE5           STR      R1,[SP, #+8]
    124                      ColorSep[1] += (Color >> 8)  & 255;
   \   00000148   FF10A0E3           MOV      R1,#+255
   \   0000014C   201401E0           AND      R1,R1,R0, LSR #+8
   \   00000150   099081E0           ADD      R9,R1,R9
    125                      ColorSep[2] += (Color >> 16) & 255;
   \   00000154   FF10A0E3           MOV      R1,#+255
   \   00000158   200801E0           AND      R0,R1,R0, LSR #+16
   \   0000015C   0AA080E0           ADD      R10,R0,R10
   \   00000160   049084E5           STR      R9,[R4, #+4]
   \   00000164   08A084E5           STR      R10,[R4, #+8]
    126                      PixelIndex = *(pData + LineOff + 1);
    127                      Color = LCD_Index2Color(PixelIndex);
   \   00000168   0100D7E4           LDRB     R0,[R7], #+1
   \   0000016C   ........           BL       LCD_Index2Color
    128                      ColorSep[0] += Color & 255;
   \   00000170   08109DE5           LDR      R1,[SP, #+8]
   \   00000174   FF2000E2           AND      R2,R0,#0xFF
   \   00000178   011082E0           ADD      R1,R2,R1
   \   0000017C   08108DE5           STR      R1,[SP, #+8]
    129                      ColorSep[1] += (Color >> 8)  & 255;
   \   00000180   FF10A0E3           MOV      R1,#+255
   \   00000184   201401E0           AND      R1,R1,R0, LSR #+8
   \   00000188   091081E0           ADD      R1,R1,R9
    130                      ColorSep[2] += (Color >> 16) & 255;
   \   0000018C   FF20A0E3           MOV      R2,#+255
   \   00000190   041084E5           STR      R1,[R4, #+4]
   \   00000194   200802E0           AND      R0,R2,R0, LSR #+16
   \   00000198   0A0080E0           ADD      R0,R0,R10
    131                      Color  =  (ColorSep[0] + 2) >> 2;
    132                      Color |= ((ColorSep[1] + 2) >> 2) << 8;
    133                      Color |= ((U32)((ColorSep[2] + 2) >> 2)) << 16;
    134                      PixelIndex = LCD_Color2Index(Color);
   \   0000019C   08209DE5           LDR      R2,[SP, #+8]
   \   000001A0   021081E2           ADD      R1,R1,#+2
   \   000001A4   080084E5           STR      R0,[R4, #+8]
   \   000001A8   4111A0E1           ASR      R1,R1,#+2
   \   000001AC   022082E2           ADD      R2,R2,#+2
   \   000001B0   0114A0E1           LSL      R1,R1,#+8
   \   000001B4   020080E2           ADD      R0,R0,#+2
   \   000001B8   421181E1           ORR      R1,R1,R2, ASR #+2
   \   000001BC   4001A0E1           ASR      R0,R0,#+2
   \   000001C0   000881E1           ORR      R0,R1,R0, LSL #+16
   \   000001C4   ........           BL       LCD_Color2Index
    135                      LCD_SetPixelIndex(x + x0, y + y0, PixelIndex);
   \   000001C8   0020A0E1           MOV      R2,R0
   \   000001CC   0B10A0E1           MOV      R1,R11
   \   000001D0   0600A0E1           MOV      R0,R6
   \   000001D4   ........           BL       LCD_SetPixelIndex
    136                      pData += 2;
    137                    }
   \   000001D8   016086E2           ADD      R6,R6,#+1
   \   000001DC   018058E2           SUBS     R8,R8,#+1
   \   000001E0   B8FFFF1A           BNE      ??GUI_MEMDEV_CopyToLCDAA_5
    138                    pData0 += 2 * LineOff;
   \                     ??GUI_MEMDEV_CopyToLCDAA_4:
   \   000001E4   18109DE5           LDR      R1,[SP, #+24]
   \   000001E8   04209DE5           LDR      R2,[SP, #+4]
    139                  }
   \   000001EC   01B08BE2           ADD      R11,R11,#+1
   \   000001F0   811082E0           ADD      R1,R2,R1, LSL #+1
   \   000001F4   04108DE5           STR      R1,[SP, #+4]
   \   000001F8   00109DE5           LDR      R1,[SP, #+0]
   \   000001FC   011041E2           SUB      R1,R1,#+1
   \   00000200   00108DE5           STR      R1,[SP, #+0]
   \   00000204   000051E3           CMP      R1,#+0
   \   00000208   C100000A           BEQ      ??GUI_MEMDEV_CopyToLCDAA_2
   \   0000020C   A5FFFFEA           B        ??GUI_MEMDEV_CopyToLCDAA_3
    140                }
   \                     ??GUI_MEMDEV_CopyToLCDAA_1:
   \   00000210   110050E3           CMP      R0,#+17
   \   00000214   181084E2           ADD      R1,R4,#+24
   \   00000218   5E0000AA           BGE      ??GUI_MEMDEV_CopyToLCDAA_6
    141                break;
    142              case 2: {
    143                  U16 * pData0;
    144                  pData0 = (U16 *)(pDev + 1);
   \   0000021C   00108DE5           STR      R1,[SP, #+0]
    145                  for (y = 0; y < YMax; y++) {
   \   00000220   010056E3           CMP      R6,#+1
   \   00000224   BA0000BA           BLT      ??GUI_MEMDEV_CopyToLCDAA_2
   \   00000228   04608DE5           STR      R6,[SP, #+4]
   \   0000022C   08408DE2           ADD      R4,SP,#+8
    146                    U16 * pData;
    147                    pData = (U16 *)pData0;
    148                    for (x = 0; x < XMax; x++) {
   \                     ??GUI_MEMDEV_CopyToLCDAA_7:
   \   00000230   14009DE5           LDR      R0,[SP, #+20]
   \   00000234   00509DE5           LDR      R5,[SP, #+0]
   \   00000238   010050E3           CMP      R0,#+1
   \   0000023C   4A0000BA           BLT      ??GUI_MEMDEV_CopyToLCDAA_8
   \   00000240   18009DE5           LDR      R0,[SP, #+24]
   \   00000244   1C609DE5           LDR      R6,[SP, #+28]
   \   00000248   807085E0           ADD      R7,R5,R0, LSL #+1
   \   0000024C   14809DE5           LDR      R8,[SP, #+20]
    149                      PixelIndex = *pData;
    150                      Color = LCD_Index2Color(PixelIndex);
   \                     ??GUI_MEMDEV_CopyToLCDAA_9:
   \   00000250   B200D5E0           LDRH     R0,[R5], #+2
   \   00000254   ........           BL       LCD_Index2Color
    151                      ColorSep[0] = Color & 255;
   \   00000258   FF1000E2           AND      R1,R0,#0xFF
   \   0000025C   08108DE5           STR      R1,[SP, #+8]
    152                      ColorSep[1] = (Color >> 8)  & 255;
   \   00000260   FF10A0E3           MOV      R1,#+255
   \   00000264   201401E0           AND      R1,R1,R0, LSR #+8
   \   00000268   041084E5           STR      R1,[R4, #+4]
    153                      ColorSep[2] = (Color >> 16) & 255;
   \   0000026C   FF10A0E3           MOV      R1,#+255
   \   00000270   200801E0           AND      R0,R1,R0, LSR #+16
   \   00000274   080084E5           STR      R0,[R4, #+8]
    154                      PixelIndex = *(pData + 1);
    155                      Color = LCD_Index2Color(PixelIndex);
   \   00000278   B200D5E0           LDRH     R0,[R5], #+2
   \   0000027C   ........           BL       LCD_Index2Color
    156                      ColorSep[0] += Color & 255;
   \   00000280   08109DE5           LDR      R1,[SP, #+8]
   \   00000284   FF2000E2           AND      R2,R0,#0xFF
   \   00000288   011082E0           ADD      R1,R2,R1
   \   0000028C   08108DE5           STR      R1,[SP, #+8]
   \   00000290   041094E5           LDR      R1,[R4, #+4]
   \   00000294   FF20A0E3           MOV      R2,#+255
   \   00000298   202402E0           AND      R2,R2,R0, LSR #+8
   \   0000029C   019082E0           ADD      R9,R2,R1
   \   000002A0   081094E5           LDR      R1,[R4, #+8]
   \   000002A4   FF20A0E3           MOV      R2,#+255
   \   000002A8   200802E0           AND      R0,R2,R0, LSR #+16
   \   000002AC   01A080E0           ADD      R10,R0,R1
   \   000002B0   049084E5           STR      R9,[R4, #+4]
   \   000002B4   08A084E5           STR      R10,[R4, #+8]
    157                      ColorSep[1] += (Color >> 8)  & 255;
    158                      ColorSep[2] += (Color >> 16) & 255;
    159                      PixelIndex = *(pData + LineOff);
    160                      Color = LCD_Index2Color(PixelIndex);
   \   000002B8   B200D7E0           LDRH     R0,[R7], #+2
   \   000002BC   ........           BL       LCD_Index2Color
    161                      ColorSep[0] += Color & 255;
   \   000002C0   08109DE5           LDR      R1,[SP, #+8]
   \   000002C4   FF2000E2           AND      R2,R0,#0xFF
   \   000002C8   011082E0           ADD      R1,R2,R1
   \   000002CC   08108DE5           STR      R1,[SP, #+8]
    162                      ColorSep[1] += (Color >> 8)  & 255;
   \   000002D0   FF10A0E3           MOV      R1,#+255
   \   000002D4   201401E0           AND      R1,R1,R0, LSR #+8
   \   000002D8   099081E0           ADD      R9,R1,R9
    163                      ColorSep[2] += (Color >> 16) & 255;
   \   000002DC   FF10A0E3           MOV      R1,#+255
   \   000002E0   200801E0           AND      R0,R1,R0, LSR #+16
   \   000002E4   0AA080E0           ADD      R10,R0,R10
   \   000002E8   049084E5           STR      R9,[R4, #+4]
   \   000002EC   08A084E5           STR      R10,[R4, #+8]
    164                      PixelIndex = *(pData + LineOff + 1);
    165                      Color = LCD_Index2Color(PixelIndex);
   \   000002F0   B200D7E0           LDRH     R0,[R7], #+2
   \   000002F4   ........           BL       LCD_Index2Color
    166                      ColorSep[0] += Color & 255;
   \   000002F8   08109DE5           LDR      R1,[SP, #+8]
   \   000002FC   FF2000E2           AND      R2,R0,#0xFF
   \   00000300   011082E0           ADD      R1,R2,R1
   \   00000304   08108DE5           STR      R1,[SP, #+8]
    167                      ColorSep[1] += (Color >> 8)  & 255;
   \   00000308   FF10A0E3           MOV      R1,#+255
   \   0000030C   201401E0           AND      R1,R1,R0, LSR #+8
   \   00000310   091081E0           ADD      R1,R1,R9
    168                      ColorSep[2] += (Color >> 16) & 255;
   \   00000314   FF20A0E3           MOV      R2,#+255
   \   00000318   041084E5           STR      R1,[R4, #+4]
   \   0000031C   200802E0           AND      R0,R2,R0, LSR #+16
   \   00000320   0A0080E0           ADD      R0,R0,R10
    169                      Color  =  (ColorSep[0] + 2) >> 2;
    170                      Color |= ((ColorSep[1] + 2) >> 2) << 8;
    171                      Color |= ((U32)((ColorSep[2] + 2) >> 2)) << 16;
    172                      PixelIndex = LCD_Color2Index(Color);
   \   00000324   08209DE5           LDR      R2,[SP, #+8]
   \   00000328   021081E2           ADD      R1,R1,#+2
   \   0000032C   080084E5           STR      R0,[R4, #+8]
   \   00000330   4111A0E1           ASR      R1,R1,#+2
   \   00000334   022082E2           ADD      R2,R2,#+2
   \   00000338   0114A0E1           LSL      R1,R1,#+8
   \   0000033C   020080E2           ADD      R0,R0,#+2
   \   00000340   421181E1           ORR      R1,R1,R2, ASR #+2
   \   00000344   4001A0E1           ASR      R0,R0,#+2
   \   00000348   000881E1           ORR      R0,R1,R0, LSL #+16
   \   0000034C   ........           BL       LCD_Color2Index
    173                      LCD_SetPixelIndex(x + x0, y + y0, PixelIndex);
   \   00000350   0020A0E1           MOV      R2,R0
   \   00000354   0B10A0E1           MOV      R1,R11
   \   00000358   0600A0E1           MOV      R0,R6
   \   0000035C   ........           BL       LCD_SetPixelIndex
    174                      pData += 2;
    175                    }
   \   00000360   016086E2           ADD      R6,R6,#+1
   \   00000364   018058E2           SUBS     R8,R8,#+1
   \   00000368   B8FFFF1A           BNE      ??GUI_MEMDEV_CopyToLCDAA_9
    176                    pData0 += 2 * LineOff;
   \                     ??GUI_MEMDEV_CopyToLCDAA_8:
   \   0000036C   18109DE5           LDR      R1,[SP, #+24]
   \   00000370   00209DE5           LDR      R2,[SP, #+0]
    177                  }
   \   00000374   01B08BE2           ADD      R11,R11,#+1
   \   00000378   011182E0           ADD      R1,R2,R1, LSL #+2
   \   0000037C   00108DE5           STR      R1,[SP, #+0]
   \   00000380   04109DE5           LDR      R1,[SP, #+4]
   \   00000384   011041E2           SUB      R1,R1,#+1
   \   00000388   04108DE5           STR      R1,[SP, #+4]
   \   0000038C   000051E3           CMP      R1,#+0
   \   00000390   5F00000A           BEQ      ??GUI_MEMDEV_CopyToLCDAA_2
   \   00000394   A5FFFFEA           B        ??GUI_MEMDEV_CopyToLCDAA_7
    178                }
    179                break;
    180              case 4: {
    181                  U32 * pData0;
    182                  pData0   = (U32 *)(pDev + 1);
   \                     ??GUI_MEMDEV_CopyToLCDAA_6:
   \   00000398   04108DE5           STR      R1,[SP, #+4]
    183                  for (y = 0; y < YMax; y++) {
   \   0000039C   010056E3           CMP      R6,#+1
   \   000003A0   5B0000BA           BLT      ??GUI_MEMDEV_CopyToLCDAA_2
   \   000003A4   0B50A0E1           MOV      R5,R11
   \   000003A8   00608DE5           STR      R6,[SP, #+0]
   \   000003AC   08408DE2           ADD      R4,SP,#+8
    184                    U32 * pData;
    185                    pData = (U32 *)pData0;
    186                    for (x = 0; x < XMax; x++) {
   \                     ??GUI_MEMDEV_CopyToLCDAA_10:
   \   000003B0   14009DE5           LDR      R0,[SP, #+20]
   \   000003B4   04609DE5           LDR      R6,[SP, #+4]
   \   000003B8   010050E3           CMP      R0,#+1
   \   000003BC   4A0000BA           BLT      ??GUI_MEMDEV_CopyToLCDAA_11
   \   000003C0   18009DE5           LDR      R0,[SP, #+24]
   \   000003C4   1C709DE5           LDR      R7,[SP, #+28]
   \   000003C8   008186E0           ADD      R8,R6,R0, LSL #+2
   \   000003CC   14909DE5           LDR      R9,[SP, #+20]
    187                      PixelIndex = *pData;
    188                      Color = LCD_Index2Color(PixelIndex);
   \                     ??GUI_MEMDEV_CopyToLCDAA_12:
   \   000003D0   040096E4           LDR      R0,[R6], #+4
   \   000003D4   ........           BL       LCD_Index2Color
    189                      ColorSep[0] = Color & 255;
   \   000003D8   FF1000E2           AND      R1,R0,#0xFF
   \   000003DC   08108DE5           STR      R1,[SP, #+8]
    190                      ColorSep[1] = (Color >> 8)  & 255;
   \   000003E0   FF10A0E3           MOV      R1,#+255
   \   000003E4   201401E0           AND      R1,R1,R0, LSR #+8
   \   000003E8   041084E5           STR      R1,[R4, #+4]
    191                      ColorSep[2] = (Color >> 16) & 255;
   \   000003EC   FF10A0E3           MOV      R1,#+255
   \   000003F0   200801E0           AND      R0,R1,R0, LSR #+16
   \   000003F4   080084E5           STR      R0,[R4, #+8]
    192                      PixelIndex = *(pData + 1);
    193                      Color = LCD_Index2Color(PixelIndex);
   \   000003F8   040096E4           LDR      R0,[R6], #+4
   \   000003FC   ........           BL       LCD_Index2Color
    194                      ColorSep[0] += Color & 255;
   \   00000400   08109DE5           LDR      R1,[SP, #+8]
   \   00000404   FF2000E2           AND      R2,R0,#0xFF
   \   00000408   011082E0           ADD      R1,R2,R1
   \   0000040C   08108DE5           STR      R1,[SP, #+8]
   \   00000410   041094E5           LDR      R1,[R4, #+4]
   \   00000414   FF20A0E3           MOV      R2,#+255
   \   00000418   202402E0           AND      R2,R2,R0, LSR #+8
   \   0000041C   01A082E0           ADD      R10,R2,R1
   \   00000420   081094E5           LDR      R1,[R4, #+8]
   \   00000424   FF20A0E3           MOV      R2,#+255
   \   00000428   200802E0           AND      R0,R2,R0, LSR #+16
   \   0000042C   01B080E0           ADD      R11,R0,R1
   \   00000430   04A084E5           STR      R10,[R4, #+4]
   \   00000434   08B084E5           STR      R11,[R4, #+8]
    195                      ColorSep[1] += (Color >> 8)  & 255;
    196                      ColorSep[2] += (Color >> 16) & 255;
    197                      PixelIndex = *(pData + LineOff);
    198                      Color = LCD_Index2Color(PixelIndex);
   \   00000438   040098E4           LDR      R0,[R8], #+4
   \   0000043C   ........           BL       LCD_Index2Color
    199                      ColorSep[0] += Color & 255;
   \   00000440   08109DE5           LDR      R1,[SP, #+8]
   \   00000444   FF2000E2           AND      R2,R0,#0xFF
   \   00000448   011082E0           ADD      R1,R2,R1
   \   0000044C   08108DE5           STR      R1,[SP, #+8]
    200                      ColorSep[1] += (Color >> 8)  & 255;
   \   00000450   FF10A0E3           MOV      R1,#+255
   \   00000454   201401E0           AND      R1,R1,R0, LSR #+8
   \   00000458   0AA081E0           ADD      R10,R1,R10
    201                      ColorSep[2] += (Color >> 16) & 255;
   \   0000045C   FF10A0E3           MOV      R1,#+255
   \   00000460   200801E0           AND      R0,R1,R0, LSR #+16
   \   00000464   0BB080E0           ADD      R11,R0,R11
   \   00000468   04A084E5           STR      R10,[R4, #+4]
   \   0000046C   08B084E5           STR      R11,[R4, #+8]
    202                      PixelIndex = *(pData + LineOff + 1);
    203                      Color = LCD_Index2Color(PixelIndex);
   \   00000470   040098E4           LDR      R0,[R8], #+4
   \   00000474   ........           BL       LCD_Index2Color
    204                      ColorSep[0] += Color & 255;
   \   00000478   08109DE5           LDR      R1,[SP, #+8]
   \   0000047C   FF2000E2           AND      R2,R0,#0xFF
   \   00000480   011082E0           ADD      R1,R2,R1
   \   00000484   08108DE5           STR      R1,[SP, #+8]
    205                      ColorSep[1] += (Color >> 8)  & 255;
   \   00000488   FF10A0E3           MOV      R1,#+255
   \   0000048C   201401E0           AND      R1,R1,R0, LSR #+8
   \   00000490   0A1081E0           ADD      R1,R1,R10
    206                      ColorSep[2] += (Color >> 16) & 255;
   \   00000494   FF20A0E3           MOV      R2,#+255
   \   00000498   041084E5           STR      R1,[R4, #+4]
   \   0000049C   200802E0           AND      R0,R2,R0, LSR #+16
   \   000004A0   0B0080E0           ADD      R0,R0,R11
    207                      Color  =  (ColorSep[0] + 2) >> 2;
    208                      Color |= ((ColorSep[1] + 2) >> 2) << 8;
    209                      Color |= ((U32)((ColorSep[2] + 2) >> 2)) << 16;
    210                      PixelIndex = LCD_Color2Index(Color);
   \   000004A4   08209DE5           LDR      R2,[SP, #+8]
   \   000004A8   021081E2           ADD      R1,R1,#+2
   \   000004AC   080084E5           STR      R0,[R4, #+8]
   \   000004B0   4111A0E1           ASR      R1,R1,#+2
   \   000004B4   022082E2           ADD      R2,R2,#+2
   \   000004B8   0114A0E1           LSL      R1,R1,#+8
   \   000004BC   020080E2           ADD      R0,R0,#+2
   \   000004C0   421181E1           ORR      R1,R1,R2, ASR #+2
   \   000004C4   4001A0E1           ASR      R0,R0,#+2
   \   000004C8   000881E1           ORR      R0,R1,R0, LSL #+16
   \   000004CC   ........           BL       LCD_Color2Index
    211                      LCD_SetPixelIndex(x + x0, y + y0, PixelIndex);
   \   000004D0   0020A0E1           MOV      R2,R0
   \   000004D4   0510A0E1           MOV      R1,R5
   \   000004D8   0700A0E1           MOV      R0,R7
   \   000004DC   ........           BL       LCD_SetPixelIndex
    212                      pData += 2;
    213                    }
   \   000004E0   017087E2           ADD      R7,R7,#+1
   \   000004E4   019059E2           SUBS     R9,R9,#+1
   \   000004E8   B8FFFF1A           BNE      ??GUI_MEMDEV_CopyToLCDAA_12
    214                    pData0 += 2 * LineOff;
   \                     ??GUI_MEMDEV_CopyToLCDAA_11:
   \   000004EC   18109DE5           LDR      R1,[SP, #+24]
   \   000004F0   04209DE5           LDR      R2,[SP, #+4]
    215                  }
   \   000004F4   015085E2           ADD      R5,R5,#+1
   \   000004F8   811182E0           ADD      R1,R2,R1, LSL #+3
   \   000004FC   04108DE5           STR      R1,[SP, #+4]
   \   00000500   00109DE5           LDR      R1,[SP, #+0]
   \   00000504   011041E2           SUB      R1,R1,#+1
   \   00000508   00108DE5           STR      R1,[SP, #+0]
   \   0000050C   000051E3           CMP      R1,#+0
   \   00000510   A6FFFF1A           BNE      ??GUI_MEMDEV_CopyToLCDAA_10
    216                }
    217                break;
    218              }
    219            #if GUI_NUM_LAYERS > 1
    220              GUI_SelectLayer(PrevLayer);
   \                     ??GUI_MEMDEV_CopyToLCDAA_2:
   \   00000514   20009DE5           LDR      R0,[SP, #+32]
   \   00000518   ........           BL       GUI_SelectLayer
    221            #endif
    222              /* Reactivate previously used device */
    223              GUI_MEMDEV_Select(hMemPrev);
   \   0000051C   24009DE5           LDR      R0,[SP, #+36]
   \   00000520   ........           BL       GUI_MEMDEV_Select
    224            }
    225            GUI_UNLOCK();
   \                     ??GUI_MEMDEV_CopyToLCDAA_0:
   \   00000524   ........           BL       GUI_Unlock
    226          
    227            #else
    228          
    229            GUI_LOCK();
    230            /* Make sure memory handle is valid */
    231            if (hMem) {
    232              GUI_MEMDEV_Handle hMemPrev;
    233            #if GUI_NUM_LAYERS > 1
    234              int PrevLayer;
    235            #endif
    236              int x, y;
    237              GUI_MEMDEV     * pDev;
    238              LCD_PIXELINDEX * pData0;
    239              int LineOff;
    240              int x0;
    241              int y0;
    242              int XMax;
    243              int YMax;
    244          
    245              pDev     = (GUI_MEMDEV *)GUI_ALLOC_h2p(hMem);  /* Convert to pointer */
    246              pData0   = (LCD_PIXELINDEX *)(pDev + 1);
    247              LineOff  = pDev->XSize;
    248              x0       = pDev->x0;
    249              y0       = pDev->y0;
    250              XMax     = pDev->XSize / 2;
    251              YMax     = pDev->YSize / 2;
    252              hMemPrev = GUI_Context.hDevData;
    253            #if GUI_NUM_LAYERS > 1
    254              PrevLayer = GUI_SelectLayer(pDev->LayerIndex);   /* Should not we switch back to the orig. layer when done ? */
    255            #else
    256              GUI_SelectLCD();  /* Activate LCD */
    257            #endif
    258              for (y = 0; y < YMax; y++) {
    259                LCD_PIXELINDEX * pData;
    260                pData = pData0;
    261                for (x = 0; x < XMax; x++) {
    262                  LCD_PIXELINDEX PixelIndex;
    263                  int ColorSep[3];
    264                  U32 Color;
    265          
    266                  Color = LCD_Index2Color(*pData);
    267                  ColorSep[0] = Color & 255;
    268                  ColorSep[1] = (Color >> 8)  & 255;
    269                  ColorSep[2] = (Color >> 16) & 255;
    270                  Color = LCD_Index2Color(*(pData + 1));
    271                  ColorSep[0] += Color & 255;
    272                  ColorSep[1] += (Color >> 8)  & 255;
    273                  ColorSep[2] += (Color >> 16) & 255;
    274                  Color = LCD_Index2Color(*(pData + LineOff));
    275                  ColorSep[0] += Color & 255;
    276                  ColorSep[1] += (Color >> 8)  & 255;
    277                  ColorSep[2] += (Color >> 16) & 255;
    278                  Color = LCD_Index2Color(*(pData + LineOff + 1));
    279                  ColorSep[0] += Color & 255;
    280                  ColorSep[1] += (Color >> 8)  & 255;
    281                  ColorSep[2] += (Color >> 16) & 255;
    282                  Color  =  (ColorSep[0] + 2) >> 2;
    283                  Color |= ((ColorSep[1] + 2) >> 2) << 8;
    284                  Color |= ((U32)((ColorSep[2] + 2) >> 2)) << 16;
    285                  PixelIndex = LCD_Color2Index(Color);
    286                  LCD_SetPixelIndex(x + x0, y + y0, PixelIndex);
    287                  pData += 2;
    288                }
    289                pData0 += 2 * LineOff;
    290              }
    291            #if GUI_NUM_LAYERS > 1
    292              GUI_SelectLayer(PrevLayer);
    293            #endif
    294              /* Reactivate previously used device */
    295              GUI_MEMDEV_Select(hMemPrev);
    296            }
    297            GUI_UNLOCK();
    298          
    299            #endif
    300          }
   \   00000528   2CD08DE2           ADD      SP,SP,#+44       ;; stack cleaning
   \   0000052C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    301          
    302          /*********************************************************************
    303          *
    304          *       GUI_MEMDEV_CopyFromLCDAA
    305          */

   \                                 In section .text, align 4, keep-with-next
    306          void GUI_MEMDEV_CopyFromLCDAA(GUI_MEMDEV_Handle hMem) {
   \                     GUI_MEMDEV_CopyFromLCDAA:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0040A0E1           MOV      R4,R0
    307            /* Make sure memory handle is valid */
    308            GUI_LOCK();
   \   0000000C   ........           BL       GUI_Lock
    309            if (!hMem) {
   \   00000010   000054E3           CMP      R4,#+0
    310              hMem = GUI_Context.hDevData;
   \   00000014   ........           LDREQ    R0,??DataTable1
   \   00000018   88409005           LDREQ    R4,[R0, #+136]
    311            }
    312            if (hMem) {
   \   0000001C   000054E3           CMP      R4,#+0
   \   00000020   6700000A           BEQ      ??GUI_MEMDEV_CopyFromLCDAA_0
    313              int x, y;
    314              GUI_MEMDEV* pDevData = (GUI_MEMDEV*) GUI_ALLOC_h2p(hMem);  /* Convert to pointer */
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       GUI_ALLOC_h2p
   \   0000002C   0040A0E1           MOV      R4,R0
    315              GUI_USAGE* pUsage = 0;
    316              int x0 = pDevData->x0;
   \   00000030   F410D4E1           LDRSH    R1,[R4, #+4]
   \   00000034   0070A0E3           MOV      R7,#+0
   \   00000038   0050A0E3           MOV      R5,#+0
   \   0000003C   10108DE5           STR      R1,[SP, #+16]
    317              int y0 = pDevData->y0;
    318              int XMax = pDevData->XSize/2;
   \   00000040   F800D4E1           LDRSH    R0,[R4, #+8]
   \   00000044   F660D4E1           LDRSH    R6,[R4, #+6]
    319              int YMax = pDevData->YSize/2;
    320              LCD_PIXELINDEX* pData = (LCD_PIXELINDEX*)(pDevData+1);
   \   00000048   188084E2           ADD      R8,R4,#+24
   \   0000004C   0008A0E1           LSL      R0,R0,#+16
   \   00000050   2008A0E1           LSR      R0,R0,#+16
   \   00000054   A00780E0           ADD      R0,R0,R0, LSR #+15
   \   00000058   0008A0E1           LSL      R0,R0,#+16
   \   0000005C   C008A0E1           ASR      R0,R0,#+17
   \   00000060   0C008DE5           STR      R0,[SP, #+12]
   \   00000064   FA00D4E1           LDRSH    R0,[R4, #+10]
   \   00000068   0008A0E1           LSL      R0,R0,#+16
   \   0000006C   2008A0E1           LSR      R0,R0,#+16
   \   00000070   A00780E0           ADD      R0,R0,R0, LSR #+15
   \   00000074   0008A0E1           LSL      R0,R0,#+16
   \   00000078   C008A0E1           ASR      R0,R0,#+17
   \   0000007C   08008DE5           STR      R0,[SP, #+8]
    321              int LineOff = pDevData->BytesPerLine;
   \   00000080   0C1094E5           LDR      R1,[R4, #+12]
   \   00000084   04108DE5           STR      R1,[SP, #+4]
    322              if (pDevData->hUsage) 
   \   00000088   140094E5           LDR      R0,[R4, #+20]
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   0100000A           BEQ      ??GUI_MEMDEV_CopyFromLCDAA_1
    323                pUsage = GUI_USAGE_H2P(pDevData->hUsage);
   \   00000094   ........           BL       GUI_ALLOC_h2p
   \   00000098   0050A0E1           MOV      R5,R0
    324              for (y=0; y< YMax; y++) {
   \                     ??GUI_MEMDEV_CopyFromLCDAA_1:
   \   0000009C   08009DE5           LDR      R0,[SP, #+8]
   \   000000A0   00708DE5           STR      R7,[SP, #+0]
   \   000000A4   010050E3           CMP      R0,#+1
   \   000000A8   450000BA           BLT      ??GUI_MEMDEV_CopyFromLCDAA_0
   \   000000AC   0170A0E3           MOV      R7,#+1
    325                if (pUsage) {
   \                     ??GUI_MEMDEV_CopyFromLCDAA_2:
   \   000000B0   000055E3           CMP      R5,#+0
   \   000000B4   0E00000A           BEQ      ??GUI_MEMDEV_CopyFromLCDAA_3
    326                  GUI_USAGE_AddHLine(pUsage, 0, y*2, pDevData->XSize);
   \   000000B8   00009DE5           LDR      R0,[SP, #+0]
   \   000000BC   08C095E5           LDR      R12,[R5, #+8]
   \   000000C0   8020A0E1           LSL      R2,R0,#+1
   \   000000C4   F830D4E1           LDRSH    R3,[R4, #+8]
   \   000000C8   0010A0E3           MOV      R1,#+0
   \   000000CC   0500A0E1           MOV      R0,R5
   \   000000D0   04C09CE5           LDR      R12,[R12, #+4]
   \   000000D4   3CFF2FE1           BLX      R12
    327                  GUI_USAGE_AddHLine(pUsage, 0, y*2+1, pDevData->XSize);
   \   000000D8   08C095E5           LDR      R12,[R5, #+8]
   \   000000DC   F830D4E1           LDRSH    R3,[R4, #+8]
   \   000000E0   0720A0E1           MOV      R2,R7
   \   000000E4   0010A0E3           MOV      R1,#+0
   \   000000E8   0500A0E1           MOV      R0,R5
   \   000000EC   04C09CE5           LDR      R12,[R12, #+4]
   \   000000F0   3CFF2FE1           BLX      R12
    328                }
    329                for (x=0; x< XMax; x++) {
   \                     ??GUI_MEMDEV_CopyFromLCDAA_3:
   \   000000F4   0C009DE5           LDR      R0,[SP, #+12]
   \   000000F8   010050E3           CMP      R0,#+1
   \   000000FC   220000BA           BLT      ??GUI_MEMDEV_CopyFromLCDAA_4
   \   00000100   04009DE5           LDR      R0,[SP, #+4]
   \   00000104   0C909DE5           LDR      R9,[SP, #+12]
   \   00000108   10A09DE5           LDR      R10,[SP, #+16]
   \   0000010C   00B188E0           ADD      R11,R8,R0, LSL #+2
   \   00000110   010019E3           TST      R9,#0x1
   \   00000114   0700000A           BEQ      ??GUI_MEMDEV_CopyFromLCDAA_5
    330                  *pData = *(pData+1) = *(pData+LineOff) = *(pData+LineOff+1) = LCD_GetPixelIndex(x+x0,y+y0);
   \   00000118   0610A0E1           MOV      R1,R6
   \   0000011C   0A00A0E1           MOV      R0,R10
   \   00000120   ........           BL       LCD_GetPixelIndex
   \   00000124   04008BE5           STR      R0,[R11, #+4]
   \   00000128   08008BE4           STR      R0,[R11], #+8
   \   0000012C   040088E5           STR      R0,[R8, #+4]
   \   00000130   080088E4           STR      R0,[R8], #+8
    331                  pData+=2;
   \   00000134   01A08AE2           ADD      R10,R10,#+1
   \                     ??GUI_MEMDEV_CopyFromLCDAA_5:
   \   00000138   A990B0E1           LSRS     R9,R9,#+1
   \   0000013C   1200000A           BEQ      ??GUI_MEMDEV_CopyFromLCDAA_4
   \                     ??GUI_MEMDEV_CopyFromLCDAA_6:
   \   00000140   0610A0E1           MOV      R1,R6
   \   00000144   0A00A0E1           MOV      R0,R10
   \   00000148   ........           BL       LCD_GetPixelIndex
   \   0000014C   04008BE5           STR      R0,[R11, #+4]
   \   00000150   00008BE5           STR      R0,[R11, #+0]
   \   00000154   040088E5           STR      R0,[R8, #+4]
   \   00000158   080088E4           STR      R0,[R8], #+8
   \   0000015C   0610A0E1           MOV      R1,R6
   \   00000160   01008AE2           ADD      R0,R10,#+1
   \   00000164   ........           BL       LCD_GetPixelIndex
   \   00000168   0C008BE5           STR      R0,[R11, #+12]
   \   0000016C   08008BE5           STR      R0,[R11, #+8]
   \   00000170   040088E5           STR      R0,[R8, #+4]
    332                }
   \   00000174   019049E2           SUB      R9,R9,#+1
   \   00000178   080088E4           STR      R0,[R8], #+8
   \   0000017C   10B08BE2           ADD      R11,R11,#+16
   \   00000180   02A08AE2           ADD      R10,R10,#+2
   \   00000184   000059E3           CMP      R9,#+0
   \   00000188   ECFFFF1A           BNE      ??GUI_MEMDEV_CopyFromLCDAA_6
    333                pData += LineOff + (pDevData->XSize&1);
   \                     ??GUI_MEMDEV_CopyFromLCDAA_4:
   \   0000018C   0810D4E5           LDRB     R1,[R4, #+8]
   \   00000190   04009DE5           LDR      R0,[SP, #+4]
    334              }
   \   00000194   027087E2           ADD      R7,R7,#+2
   \   00000198   011001E2           AND      R1,R1,#0x1
   \   0000019C   000081E0           ADD      R0,R1,R0
   \   000001A0   00109DE5           LDR      R1,[SP, #+0]
   \   000001A4   008188E0           ADD      R8,R8,R0, LSL #+2
   \   000001A8   011081E2           ADD      R1,R1,#+1
   \   000001AC   00108DE5           STR      R1,[SP, #+0]
   \   000001B0   0100A0E1           MOV      R0,R1
   \   000001B4   08109DE5           LDR      R1,[SP, #+8]
   \   000001B8   016086E2           ADD      R6,R6,#+1
   \   000001BC   010050E1           CMP      R0,R1
   \   000001C0   BAFFFFBA           BLT      ??GUI_MEMDEV_CopyFromLCDAA_2
    335            }
    336            GUI_UNLOCK();
   \                     ??GUI_MEMDEV_CopyFromLCDAA_0:
   \   000001C4   14D08DE2           ADD      SP,SP,#+20
   \   000001C8   F04FBDE8           POP      {R4-R11,LR}
   \   000001CC   ........           B        GUI_Unlock       ;; tailcall
    337          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     GUI_Context
    338          
    339          #else
    340          
    341          void GUIDEV_AA(void);
    342          void GUIDEV_AA(void) {} /* avoid empty object files */
    343          
    344          #endif /* GUI_MEMDEV_SUPPORT */
    345          
    346          /*************************** end of file ****************************/

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     GUI_MEMDEV_CopyFromLCDAA     56
     GUI_MEMDEV_CopyToLCDAA       80


   Section sizes:

     Function/Label           Bytes
     --------------           -----
     GUI_MEMDEV_CopyToLCDAA   1328
     GUI_MEMDEV_CopyFromLCDAA  464
     ??DataTable1                4

 
 1 796 bytes in section .text
 
 1 796 bytes of CODE memory

Errors: none
Warnings: none
