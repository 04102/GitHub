###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:11:15 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDEV_Rotate.c                     #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDEV_Rotate.c -D DEBUG=1 -D       #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUIDEV_Rotate.lst          #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUIDEV_Rotate.o             #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDEV_Rotate.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDEV_Rotate.c
     19          Purpose     : Rotation of memory devices
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <math.h>
     24          
     25          #include "GUI_Private.h"
     26          
     27          /* Memory device capabilities are compiled only if support for them is enabled.*/ 
     28          #if GUI_SUPPORT_MEMDEV
     29          
     30          /*********************************************************************
     31          *
     32          *       Defines
     33          *
     34          **********************************************************************
     35          */
     36          #define NUM_BITS 12
     37          
     38          /*********************************************************************
     39          *
     40          *       Types
     41          *
     42          **********************************************************************
     43          */
     44          typedef struct {
     45            U32 r, g, b, a, Sum, SumAlpha;
     46          } PIXEL;
     47          
     48          typedef struct {
     49            int xMin, xMax, yMin, yMax;
     50          } RECT_MIN_MAX;
     51          
     52          /*********************************************************************
     53          *
     54          *       Static code
     55          *
     56          **********************************************************************
     57          */
     58          /*********************************************************************
     59          *
     60          *       _GetMinMax
     61          */

   \                                 In section .text, align 4, keep-with-next
     62          static void _GetMinMax(I32 x0SrcHQ, I32 y0SrcHQ, I32 sinHQ, I32 cosHQ, int xSize, int ySize, int Mag, RECT_MIN_MAX * pRectMinMax) {
   \                     _GetMinMax:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   20E09DE5           LDR      LR,[SP, #+32]
     63            int xMinHQ, xMaxHQ, yMinHQ, yMaxHQ;
     64            I32 x0HQ, x1HQ, x2HQ, x3HQ, y0HQ, y1HQ, y2HQ, y3HQ;
     65            I32 cosMagHQ;
     66            I32 sinMagHQ;
     67          
     68            cosMagHQ = cosHQ * Mag / 1000;
   \   00000008   ........           LDR      R6,??DataTable2  ;; 0x10624dd3
   \   0000000C   9E0303E0           MUL      R3,LR,R3
   \   00000010   9376C6E0           SMULL    R7,R6,R3,R6
     69            sinMagHQ = sinHQ * Mag / 1000;
   \   00000014   9E0202E0           MUL      R2,LR,R2
   \   00000018   ........           LDR      LR,??DataTable2  ;; 0x10624dd3
   \   0000001C   4633B0E1           ASRS     R3,R6,#+6
   \   00000020   926ECEE0           SMULL    R6,LR,R2,LR
   \   00000024   18509DE5           LDR      R5,[SP, #+24]
   \   00000028   01308342           ADDMI    R3,R3,#+1
   \   0000002C   4E63B0E1           ASRS     R6,LR,#+6
     70            x0HQ = x0SrcHQ;
     71            y0HQ = y0SrcHQ;
     72            x1HQ = x0HQ + (cosMagHQ * xSize);
   \   00000030   950307E0           MUL      R7,R5,R3
   \   00000034   01608642           ADDMI    R6,R6,#+1
   \   00000038   1C409DE5           LDR      R4,[SP, #+28]
     73            y1HQ = y0HQ - (sinMagHQ * xSize);
   \   0000003C   950608E0           MUL      R8,R5,R6
   \   00000040   00E087E0           ADD      LR,R7,R0
     74            x2HQ = x1HQ + (sinMagHQ * ySize);
   \   00000044   94E625E0           MLA      R5,R4,R6,LR
     75            y2HQ = y1HQ + (cosMagHQ * ySize);
     76            x3HQ = x2HQ - (cosMagHQ * xSize);
     77            y3HQ = y2HQ + (sinMagHQ * xSize);
     78            xMinHQ = x0HQ;
     79            if (xMinHQ > x1HQ) {
   \   00000048   00005EE1           CMP      LR,R0
   \   0000004C   076045E0           SUB      R6,R5,R7
   \   00000050   0E70A0E1           MOV      R7,LR
   \   00000054   0070A0C1           MOVGT    R7,R0
     80              xMinHQ = x1HQ;
     81            }
     82            if (xMinHQ > x2HQ) {
   \   00000058   070055E1           CMP      R5,R7
   \   0000005C   0570A0D1           MOVLE    R7,R5
     83              xMinHQ = x2HQ;
     84            }
     85            if (xMinHQ > x3HQ) {
   \   00000060   070056E1           CMP      R6,R7
   \   00000064   0670A0D1           MOVLE    R7,R6
     86              xMinHQ = x3HQ;
     87            }
     88            xMaxHQ = x0HQ;
     89            if (xMaxHQ < x1HQ) {
   \   00000068   0E0050E1           CMP      R0,LR
   \   0000006C   0E00A0B1           MOVLT    R0,LR
     90              xMaxHQ = x1HQ;
     91            }
     92            if (xMaxHQ < x2HQ) {
   \   00000070   050050E1           CMP      R0,R5
   \   00000074   0500A0B1           MOVLT    R0,R5
   \   00000078   082041E0           SUB      R2,R1,R8
     93              xMaxHQ = x2HQ;
     94            }
     95            if (xMaxHQ < x3HQ) {
   \   0000007C   060050E1           CMP      R0,R6
   \   00000080   942323E0           MLA      R3,R4,R3,R2
   \   00000084   0600A0B1           MOVLT    R0,R6
     96              xMaxHQ = x3HQ;
     97            }
     98            yMinHQ = y0HQ;
     99            if (yMinHQ > y1HQ) {
   \   00000088   02E0A0E1           MOV      LR,R2
   \   0000008C   010052E1           CMP      R2,R1
   \   00000090   01E0A0C1           MOVGT    LR,R1
    100              yMinHQ = y1HQ;
    101            }
    102            if (yMinHQ > y2HQ) {
   \   00000094   0E0053E1           CMP      R3,LR
   \   00000098   034088E0           ADD      R4,R8,R3
   \   0000009C   03E0A0D1           MOVLE    LR,R3
    103              yMinHQ = y2HQ;
    104            }
    105            if (yMinHQ > y3HQ) {
   \   000000A0   0E0054E1           CMP      R4,LR
   \   000000A4   04E0A0D1           MOVLE    LR,R4
    106              yMinHQ = y3HQ;
    107            }
    108            yMaxHQ = y0HQ;
    109            if (yMaxHQ < y1HQ) {
   \   000000A8   020051E1           CMP      R1,R2
   \   000000AC   0210A0B1           MOVLT    R1,R2
   \   000000B0   24C09DE5           LDR      R12,[SP, #+36]
    110              yMaxHQ = y1HQ;
    111            }
    112            if (yMaxHQ < y2HQ) {
    113              yMaxHQ = y2HQ;
    114            }
    115            if (yMaxHQ < y3HQ) {
    116              yMaxHQ = y3HQ;
    117            }
    118            pRectMinMax->xMin = (xMinHQ + (1L << 15)) >> 16;
   \   000000B4   802C87E2           ADD      R2,R7,#+32768
   \   000000B8   4228A0E1           ASR      R2,R2,#+16
   \   000000BC   00208CE5           STR      R2,[R12, #+0]
   \   000000C0   030051E1           CMP      R1,R3
    119            pRectMinMax->yMin = (yMinHQ + (1L << 15)) >> 16;
   \   000000C4   802C8EE2           ADD      R2,LR,#+32768
   \   000000C8   0310A0B1           MOVLT    R1,R3
   \   000000CC   4228A0E1           ASR      R2,R2,#+16
    120            pRectMinMax->xMax = (xMaxHQ - (1L << 15)) >> 16;
   \   000000D0   800C40E2           SUB      R0,R0,#+32768
   \   000000D4   040051E1           CMP      R1,R4
   \   000000D8   08208CE5           STR      R2,[R12, #+8]
   \   000000DC   4008A0E1           ASR      R0,R0,#+16
   \   000000E0   0410A0B1           MOVLT    R1,R4
   \   000000E4   04008CE5           STR      R0,[R12, #+4]
    121            pRectMinMax->yMax = (yMaxHQ - (1L << 15)) >> 16;
   \   000000E8   800C41E2           SUB      R0,R1,#+32768
   \   000000EC   4008A0E1           ASR      R0,R0,#+16
   \   000000F0   0C008CE5           STR      R0,[R12, #+12]
    122          }
   \   000000F4   F081BDE8           POP      {R4-R8,PC}       ;; return
    123          
    124          /*********************************************************************
    125          *
    126          *       _GetColor
    127          */
    128          static U32 _GetColor(GUI_MEMDEV * pMem, U32 * pData, I32 xOffHQ, I32 yOffHQ) {
    129            U32 Color;
    130            int xOff, yOff;
    131            Color = 0xFF000000;
    132            /*
    133            * Calculate real values
    134            */
    135            xOff = (xOffHQ + (1 << 15)) >> 16;
    136            yOff = (yOffHQ + (1 << 15)) >> 16;
    137            /*
    138            * Return transparency if position is outside
    139            */
    140            if ((xOff < 0) || (yOff < 0)) {
    141              return Color;
    142            }
    143            if ((xOff >= pMem->XSize) || (yOff >= pMem->YSize)) {
    144              return Color;
    145            }
    146            /*
    147            * Return color value if position is inside
    148            */
    149            Color = *(pData + yOff * pMem->XSize + xOff);
    150            return Color;
    151          }
    152          
    153          /*********************************************************************
    154          *
    155          *       _Rotate32
    156          */

   \                                 In section .text, align 4, keep-with-next
    157          static void _Rotate32(GUI_MEMDEV_Handle hMemSrc, GUI_MEMDEV_Handle hMemDst, int dx, int dy, int a, int Mag, U32 AndMask) {
   \                     _Rotate32:
   \   00000000   FC4F2DE9           PUSH     {R2-R11,LR}
   \   00000004   3CD04DE2           SUB      SP,SP,#+60
   \   00000008   6C409DE5           LDR      R4,[SP, #+108]
   \   0000000C   0070A0E1           MOV      R7,R0
   \   00000010   0160A0E1           MOV      R6,R1
   \   00000014   68809DE5           LDR      R8,[SP, #+104]
    158            I32 cosMagHQ, sinMagHQ;
    159            I32 cosHQ, sinHQ;
    160            I32 xPosHQ, yPosHQ;
    161            int xSizeSrc, ySizeSrc;
    162            I32 x0SrcHQ, y0SrcHQ;
    163            int xDst, yDst;
    164            GUI_MEMDEV * pMemSrc;
    165            GUI_MEMDEV * pMemDst;
    166            U32 * pDataSrc;
    167            U32 * pDataDst;
    168            RECT_MIN_MAX RectMinMax;
    169            I32 x0DstHQ, y0DstHQ;
    170            int xStart, yStart, xEnd, yEnd;
    171          
    172            if (Mag == 0) {
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   C200000A           BEQ      ??_Rotate32_0
    173              return;
    174            }
    175            /*
    176            * Get data pointers
    177            */
    178            pMemSrc   = (GUI_MEMDEV *)GUI_LOCK_H(hMemSrc);
   \   00000020   ........           BL       GUI_ALLOC_LockH
   \   00000024   0050A0E1           MOV      R5,R0
    179            pMemDst   = (GUI_MEMDEV *)GUI_LOCK_H(hMemDst);
   \   00000028   0600A0E1           MOV      R0,R6
   \   0000002C   ........           BL       GUI_ALLOC_LockH
   \   00000030   14008DE5           STR      R0,[SP, #+20]
    180            pDataSrc  = (U32 *)GUI_MEMDEV_GetDataPtr(hMemSrc);
   \   00000034   0700A0E1           MOV      R0,R7
   \   00000038   ........           BL       GUI_MEMDEV_GetDataPtr
   \   0000003C   24008DE5           STR      R0,[SP, #+36]
    181            pDataDst  = (U32 *)GUI_MEMDEV_GetDataPtr(hMemDst);
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   ........           BL       GUI_MEMDEV_GetDataPtr
   \   00000048   20008DE5           STR      R0,[SP, #+32]
    182            /*
    183            * Calculate start position in source device
    184            */
    185            xSizeSrc    = pMemSrc->XSize - 1;
   \   0000004C   F810D5E1           LDRSH    R1,[R5, #+8]
   \   00000050   011041E2           SUB      R1,R1,#+1
   \   00000054   10108DE5           STR      R1,[SP, #+16]
    186            ySizeSrc    = pMemSrc->YSize - 1;
   \   00000058   FA00D5E1           LDRSH    R0,[R5, #+10]
   \   0000005C   016040E2           SUB      R6,R0,#+1
    187            cosHQ       = GUI__CosHQ(a);
   \   00000060   0800A0E1           MOV      R0,R8
   \   00000064   ........           BL       GUI__CosHQ
   \   00000068   0070A0E1           MOV      R7,R0
    188            sinHQ       = GUI__SinHQ(a);
   \   0000006C   0800A0E1           MOV      R0,R8
   \   00000070   ........           BL       GUI__SinHQ
   \   00000074   0080A0E1           MOV      R8,R0
    189            cosMagHQ    = (cosHQ * 1000) / Mag;
   \   00000078   FAAFA0E3           MOV      R10,#+1000
   \   0000007C   9A0700E0           MUL      R0,R10,R7
   \   00000080   0410A0E1           MOV      R1,R4
   \   00000084   ........           BL       __aeabi_idiv
   \   00000088   0090A0E1           MOV      R9,R0
    190            sinMagHQ    = (sinHQ * 1000) / Mag;
   \   0000008C   9A0800E0           MUL      R0,R10,R8
   \   00000090   0410A0E1           MOV      R1,R4
   \   00000094   ........           BL       __aeabi_idiv
   \   00000098   00A0A0E1           MOV      R10,R0
   \   0000009C   960A01E0           MUL      R1,R6,R10
   \   000000A0   10009DE5           LDR      R0,[SP, #+16]
   \   000000A4   C110A0E1           ASR      R1,R1,#+1
   \   000000A8   800781E0           ADD      R0,R1,R0, LSL #+15
   \   000000AC   10109DE5           LDR      R1,[SP, #+16]
   \   000000B0   910902E0           MUL      R2,R1,R9
   \   000000B4   40109DE5           LDR      R1,[SP, #+64]
   \   000000B8   C20040E0           SUB      R0,R0,R2, ASR #+1
   \   000000BC   910A20E0           MLA      R0,R1,R10,R0
   \   000000C0   3C109DE5           LDR      R1,[SP, #+60]
   \   000000C4   910902E0           MUL      R2,R1,R9
   \   000000C8   960901E0           MUL      R1,R6,R9
   \   000000CC   020040E0           SUB      R0,R0,R2
   \   000000D0   1C008DE5           STR      R0,[SP, #+28]
   \   000000D4   8607A0E1           LSL      R0,R6,#+15
   \   000000D8   C10040E0           SUB      R0,R0,R1, ASR #+1
   \   000000DC   10109DE5           LDR      R1,[SP, #+16]
   \   000000E0   910A02E0           MUL      R2,R1,R10
   \   000000E4   40109DE5           LDR      R1,[SP, #+64]
   \   000000E8   C20040E0           SUB      R0,R0,R2, ASR #+1
   \   000000EC   910902E0           MUL      R2,R1,R9
   \   000000F0   3C109DE5           LDR      R1,[SP, #+60]
   \   000000F4   020040E0           SUB      R0,R0,R2
   \   000000F8   910A02E0           MUL      R2,R1,R10
   \   000000FC   940801E0           MUL      R1,R4,R8
   \   00000100   020040E0           SUB      R0,R0,R2
   \   00000104   ........           LDR      R2,??DataTable2  ;; 0x10624dd3
   \   00000108   18008DE5           STR      R0,[SP, #+24]
   \   0000010C   9132C2E0           SMULL    R3,R2,R1,R2
   \   00000110   940701E0           MUL      R1,R4,R7
   \   00000114   42E3B0E1           ASRS     LR,R2,#+6
   \   00000118   ........           LDR      R2,??DataTable2  ;; 0x10624dd3
   \   0000011C   FAC0D5E1           LDRSH    R12,[R5, #+10]
   \   00000120   9132C2E0           SMULL    R3,R2,R1,R2
   \   00000124   01E08E42           ADDMI    LR,LR,#+1
   \   00000128   F800D5E1           LDRSH    R0,[R5, #+8]
   \   0000012C   42B3B0E1           ASRS     R11,R2,#+6
   \   00000130   01B08B42           ADDMI    R11,R11,#+1
   \   00000134   08408DE5           STR      R4,[SP, #+8]
   \   00000138   28108DE2           ADD      R1,SP,#+40
   \   0000013C   9C0B04E0           MUL      R4,R12,R11
   \   00000140   0C108DE5           STR      R1,[SP, #+12]
   \   00000144   8617A0E1           LSL      R1,R6,#+15
   \   00000148   C41041E0           SUB      R1,R1,R4, ASR #+1
   \   0000014C   900E04E0           MUL      R4,R0,LR
   \   00000150   C41081E0           ADD      R1,R1,R4, ASR #+1
   \   00000154   40409DE5           LDR      R4,[SP, #+64]
   \   00000158   041881E0           ADD      R1,R1,R4, LSL #+16
   \   0000015C   10409DE5           LDR      R4,[SP, #+16]
   \   00000160   9C0E0EE0           MUL      LR,R12,LR
   \   00000164   04C08DE5           STR      R12,[SP, #+4]
   \   00000168   8447A0E1           LSL      R4,R4,#+15
   \   0000016C   CEC044E0           SUB      R12,R4,LR, ASR #+1
   \   00000170   900B0EE0           MUL      LR,R0,R11
   \   00000174   00008DE5           STR      R0,[SP, #+0]
   \   00000178   CE004CE0           SUB      R0,R12,LR, ASR #+1
   \   0000017C   3CC09DE5           LDR      R12,[SP, #+60]
   \   00000180   0730A0E1           MOV      R3,R7
   \   00000184   0820A0E1           MOV      R2,R8
   \   00000188   0C0880E0           ADD      R0,R0,R12, LSL #+16
    191            x0SrcHQ     = (xSizeSrc << 15) 
    192                        + ((sinMagHQ * ySizeSrc) >> 1) 
    193                        - ((cosMagHQ * xSizeSrc) >> 1) 
    194                        + sinMagHQ * dy 
    195                        - cosMagHQ * dx;
    196            y0SrcHQ     = (ySizeSrc << 15) 
    197                        - ((cosMagHQ * ySizeSrc) >> 1) 
    198                        - ((sinMagHQ * xSizeSrc) >> 1) 
    199                        - cosMagHQ * dy 
    200                        - sinMagHQ * dx;
    201            x0DstHQ     = (xSizeSrc << 15)
    202                        - ((((sinHQ * Mag) / 1000) * pMemSrc->YSize) >> 1) 
    203                        - ((((cosHQ * Mag) / 1000) * pMemSrc->XSize) >> 1)
    204                        + ((U32)dx << 16);
    205            y0DstHQ     = (ySizeSrc << 15)
    206                        - ((((cosHQ * Mag) / 1000) * pMemSrc->YSize) >> 1) 
    207                        + ((((sinHQ * Mag) / 1000) * pMemSrc->XSize) >> 1)
    208                        + ((U32)dy << 16);
    209            _GetMinMax(x0DstHQ, y0DstHQ, sinHQ, cosHQ, pMemSrc->XSize, pMemSrc->YSize, Mag, &RectMinMax);
   \   0000018C   ........           BL       _GetMinMax
    210            /*
    211            * Clip y
    212            */
    213            yStart = RectMinMax.yMin;
    214            yEnd   = RectMinMax.yMax;
   \   00000190   34109DE5           LDR      R1,[SP, #+52]
   \   00000194   30009DE5           LDR      R0,[SP, #+48]
   \   00000198   08108DE5           STR      R1,[SP, #+8]
    215            if (yStart < 0) {
    216              yStart = 0;
   \   0000019C   14109DE5           LDR      R1,[SP, #+20]
   \   000001A0   000050E3           CMP      R0,#+0
   \   000001A4   FA10D1E1           LDRSH    R1,[R1, #+10]
   \   000001A8   08209DE5           LDR      R2,[SP, #+8]
   \   000001AC   0000A043           MOVMI    R0,#+0
   \   000001B0   010052E1           CMP      R2,R1
    217            }
    218            if (yEnd >= pMemDst->YSize) {
    219              yEnd = pMemDst->YSize - 1;
   \   000001B4   011041A2           SUBGE    R1,R1,#+1
    220            }
    221            x0SrcHQ -= sinMagHQ * yStart;
    222            y0SrcHQ += cosMagHQ * yStart;
    223            /*
    224            * Clip x
    225            */
    226            xStart = RectMinMax.xMin;
   \   000001B8   28C09DE5           LDR      R12,[SP, #+40]
   \   000001BC   08108DA5           STRGE    R1,[SP, #+8]
   \   000001C0   00C08DE5           STR      R12,[SP, #+0]
    227            xEnd   = RectMinMax.xMax;
    228            if (xStart < 0) {
   \   000001C4   00005CE3           CMP      R12,#+0
   \   000001C8   900A02E0           MUL      R2,R0,R10
    229              xStart = 0;
   \   000001CC   00C0A043           MOVMI    R12,#+0
   \   000001D0   1C109DE5           LDR      R1,[SP, #+28]
   \   000001D4   00C08D45           STRMI    R12,[SP, #+0]
    230            }
    231            if (xEnd >= pMemDst->XSize) {
    232              xEnd = pMemDst->XSize - 1;
    233            }
    234            x0SrcHQ  += cosMagHQ * xStart;
   \   000001D8   00C09DE5           LDR      R12,[SP, #+0]
   \   000001DC   021041E0           SUB      R1,R1,R2
   \   000001E0   14309DE5           LDR      R3,[SP, #+20]
   \   000001E4   9C1921E0           MLA      R1,R12,R9,R1
   \   000001E8   F830D3E1           LDRSH    R3,[R3, #+8]
   \   000001EC   18209DE5           LDR      R2,[SP, #+24]
   \   000001F0   10108DE5           STR      R1,[SP, #+16]
   \   000001F4   902922E0           MLA      R2,R0,R9,R2
    235            y0SrcHQ  += sinMagHQ * xStart;
   \   000001F8   00109DE5           LDR      R1,[SP, #+0]
   \   000001FC   2C409DE5           LDR      R4,[SP, #+44]
   \   00000200   912A22E0           MLA      R2,R1,R10,R2
    236            /*
    237            * Iterate over the lines of the destination device
    238            */
    239            pDataDst += pMemDst->XSize * yStart;
   \   00000204   900301E0           MUL      R1,R0,R3
   \   00000208   0C208DE5           STR      R2,[SP, #+12]
   \   0000020C   20209DE5           LDR      R2,[SP, #+32]
    240            for (yDst = yStart; yDst <= yEnd; yDst++) {
   \   00000210   04008DE5           STR      R0,[SP, #+4]
   \   00000214   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000218   030054E1           CMP      R4,R3
   \   0000021C   08009DE5           LDR      R0,[SP, #+8]
   \   00000220   04209DE5           LDR      R2,[SP, #+4]
   \   00000224   014043A2           SUBGE    R4,R3,#+1
   \   00000228   020050E1           CMP      R0,R2
   \   0000022C   3C0000BA           BLT      ??_Rotate32_1
    241              xPosHQ = x0SrcHQ;
    242              yPosHQ = y0SrcHQ;
    243              /*
    244              * Iterate over all pixels of the line
    245              */
    246              pDataDst += xStart;
   \                     ??_Rotate32_2:
   \   00000230   00009DE5           LDR      R0,[SP, #+0]
   \   00000234   10609DE5           LDR      R6,[SP, #+16]
    247              for (xDst = xStart; xDst <= xEnd; xDst++) {
   \   00000238   00B0A0E1           MOV      R11,R0
   \   0000023C   0C709DE5           LDR      R7,[SP, #+12]
   \   00000240   008181E0           ADD      R8,R1,R0, LSL #+2
   \   00000244   0B0054E1           CMP      R4,R11
   \   00000248   230000BA           BLT      ??_Rotate32_3
    248                U32 Color, BkColor;
    249                U8 Alpha;
    250                Color = _GetColor(pMemSrc, pDataSrc, xPosHQ, yPosHQ);
   \                     ??_Rotate32_4:
   \   0000024C   800C86E2           ADD      R0,R6,#+32768
   \   00000250   4008A0E1           ASR      R0,R0,#+16
   \   00000254   801C87E2           ADD      R1,R7,#+32768
   \   00000258   4118A0E1           ASR      R1,R1,#+16
   \   0000025C   000050E3           CMP      R0,#+0
   \   00000260   00005153           CMPPL    R1,#+0
   \   00000264   0900004A           BMI      ??_Rotate32_5
   \   00000268   F820D5E1           LDRSH    R2,[R5, #+8]
   \   0000026C   020050E1           CMP      R0,R2
   \   00000270   FA30D5B1           LDRSHLT  R3,[R5, #+10]
   \   00000274   030051B1           CMPLT    R1,R3
   \   00000278   040000AA           BGE      ??_Rotate32_5
   \   0000027C   820161E1           SMULBB   R1,R2,R1
   \   00000280   24209DE5           LDR      R2,[SP, #+36]
   \   00000284   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000288   000191E7           LDR      R0,[R1, +R0, LSL #+2]
   \   0000028C   000000EA           B        ??_Rotate32_6
   \                     ??_Rotate32_5:
   \   00000290   FF04A0E3           MOV      R0,#-16777216
    251                Alpha = Color >> 24;
   \                     ??_Rotate32_6:
   \   00000294   201CB0E1           LSRS     R1,R0,#+24
    252                if (Alpha == 0) {
   \   00000298   0800000A           BEQ      ??_Rotate32_7
    253                  /*
    254                  * No alpha blending
    255                  */
    256                  *pDataDst = Color;
    257                } else if (Alpha < 255) {
   \   0000029C   012041E2           SUB      R2,R1,#+1
   \   000002A0   FE0052E3           CMP      R2,#+254
   \   000002A4   0600002A           BCS      ??_Rotate32_8
    258                  if (Alpha > 0) {
    259                    /*
    260                    * Manage alpha blending
    261                    */
    262                    BkColor   = *pDataDst;
    263                    Color     = GUI__MixColors(Color, BkColor, 255 - Alpha);
    264                    Color    &= AndMask;
    265                    *pDataDst = Color;
   \   000002A8   FF2061E2           RSB      R2,R1,#+255
   \   000002AC   FF2002E2           AND      R2,R2,#0xFF
   \   000002B0   001098E5           LDR      R1,[R8, #+0]
   \   000002B4   ........           BL       GUI__MixColors
   \   000002B8   70109DE5           LDR      R1,[SP, #+112]
   \   000002BC   000001E0           AND      R0,R1,R0
   \                     ??_Rotate32_7:
   \   000002C0   000088E5           STR      R0,[R8, #+0]
    266                  }
    267                }
    268                #if 0 /* Please leave code for test purpose */
    269                if (xDst == RectMinMax.xMin) {
    270                  *pDataDst = GUI_RED;
    271                }
    272                if (xDst == RectMinMax.xMax) {
    273                  *pDataDst = GUI_RED;
    274                }
    275                if (yDst == RectMinMax.yMin) {
    276                  *pDataDst = GUI_RED;
    277                }
    278                if (yDst == RectMinMax.yMax) {
    279                  *pDataDst = GUI_RED;
    280                }
    281                #endif
    282                xPosHQ += cosMagHQ;
    283                yPosHQ += sinMagHQ;
    284                pDataDst++;
    285              }
   \                     ??_Rotate32_8:
   \   000002C4   01B08BE2           ADD      R11,R11,#+1
   \   000002C8   066089E0           ADD      R6,R9,R6
   \   000002CC   07708AE0           ADD      R7,R10,R7
   \   000002D0   048088E2           ADD      R8,R8,#+4
   \   000002D4   0B0054E1           CMP      R4,R11
   \   000002D8   DBFFFFAA           BGE      ??_Rotate32_4
    286              pDataDst += (pMemDst->XSize - xEnd) - 1;
   \                     ??_Rotate32_3:
   \   000002DC   14009DE5           LDR      R0,[SP, #+20]
   \   000002E0   F800D0E1           LDRSH    R0,[R0, #+8]
   \   000002E4   040040E0           SUB      R0,R0,R4
   \   000002E8   000188E0           ADD      R0,R8,R0, LSL #+2
   \   000002EC   041040E2           SUB      R1,R0,#+4
    287              x0SrcHQ -= sinMagHQ;
   \   000002F0   10009DE5           LDR      R0,[SP, #+16]
   \   000002F4   0A0040E0           SUB      R0,R0,R10
   \   000002F8   10008DE5           STR      R0,[SP, #+16]
    288              y0SrcHQ += cosMagHQ;
   \   000002FC   0C009DE5           LDR      R0,[SP, #+12]
   \   00000300   000089E0           ADD      R0,R9,R0
   \   00000304   0C008DE5           STR      R0,[SP, #+12]
    289            }
   \   00000308   04009DE5           LDR      R0,[SP, #+4]
   \   0000030C   010080E2           ADD      R0,R0,#+1
   \   00000310   04008DE5           STR      R0,[SP, #+4]
   \   00000314   08009DE5           LDR      R0,[SP, #+8]
   \   00000318   04209DE5           LDR      R2,[SP, #+4]
   \   0000031C   020050E1           CMP      R0,R2
   \   00000320   C2FFFFAA           BGE      ??_Rotate32_2
    290            /*
    291            * Unlock pointers
    292            */
    293            GUI_UNLOCK_H(pMemSrc);
   \                     ??_Rotate32_1:
   \   00000324   ........           BL       GUI_ALLOC_UnlockH
    294            GUI_UNLOCK_H(pMemDst);
   \   00000328   ........           BL       GUI_ALLOC_UnlockH
    295          }
   \                     ??_Rotate32_0:
   \   0000032C   44D08DE2           ADD      SP,SP,#+68       ;; stack cleaning
   \   00000330   F08FBDE8           POP      {R4-R11,PC}      ;; return
    296          
    297          /*********************************************************************
    298          *
    299          *       _GetColorHQ
    300          */

   \                                 In section .text, align 4, keep-with-next
    301          static U32 _GetColorHQ(GUI_MEMDEV * pMem, U32 * pData, I32 xOffHQ, I32 yOffHQ, I32 Size) {
   \                     _GetColorHQ:
   \   00000000   F34F2DE9           PUSH     {R0,R1,R4-R11,LR}
   \   00000004   34D04DE2           SUB      SP,SP,#+52
   \   00000008   60009DE5           LDR      R0,[SP, #+96]
    302            U32 Color;
    303            int xOff, yOff;
    304            I32 x0HQ, y0HQ, x1HQ, y1HQ, xPosHQ, yPosHQ, xNextHQ, yNextHQ;
    305            U32 xPart, yPart;
    306            PIXEL Pixel = {0};
    307            U32 r, g, b, a, f;
    308          
    309            x0HQ = xOffHQ - (Size >> 1);
   \   0000000C   C02042E0           SUB      R2,R2,R0, ASR #+1
    310            y0HQ = yOffHQ - (Size >> 1);
   \   00000010   C01043E0           SUB      R1,R3,R0, ASR #+1
    311            x1HQ = x0HQ + Size - 1;
   \   00000014   023080E0           ADD      R3,R0,R2
   \   00000018   013043E2           SUB      R3,R3,#+1
   \   0000001C   10308DE5           STR      R3,[SP, #+16]
    312            y1HQ = y0HQ + Size - 1;
   \   00000020   010080E0           ADD      R0,R0,R1
    313            /*
    314            * Iterate over the lines
    315            */
    316            yPosHQ = y0HQ;
   \   00000024   00108DE5           STR      R1,[SP, #+0]
   \   00000028   10109DE5           LDR      R1,[SP, #+16]
   \   0000002C   010040E2           SUB      R0,R0,#+1
   \   00000030   011081E2           ADD      R1,R1,#+1
   \   00000034   0C008DE5           STR      R0,[SP, #+12]
   \   00000038   2C108DE5           STR      R1,[SP, #+44]
   \   0000003C   0C109DE5           LDR      R1,[SP, #+12]
   \   00000040   0040A0E3           MOV      R4,#+0
   \   00000044   011081E2           ADD      R1,R1,#+1
   \   00000048   0050A0E3           MOV      R5,#+0
   \   0000004C   0060A0E3           MOV      R6,#+0
   \   00000050   0070A0E3           MOV      R7,#+0
   \   00000054   0080A0E3           MOV      R8,#+0
   \   00000058   0090A0E3           MOV      R9,#+0
   \   0000005C   24208DE5           STR      R2,[SP, #+36]
   \   00000060   28108DE5           STR      R1,[SP, #+40]
    317            do {
    318              /*
    319              * Calculate next y position
    320              */
    321              yOff    = (yPosHQ >> 16);
   \                     ??_GetColorHQ_0:
   \   00000064   00109DE5           LDR      R1,[SP, #+0]
    322              yNextHQ = ((I32)yOff + 1) << 16;
    323              if (yNextHQ > y1HQ) {
   \   00000068   0C009DE5           LDR      R0,[SP, #+12]
   \   0000006C   4118A0E1           ASR      R1,R1,#+16
   \   00000070   08108DE5           STR      R1,[SP, #+8]
   \   00000074   011081E2           ADD      R1,R1,#+1
   \   00000078   0118A0E1           LSL      R1,R1,#+16
   \   0000007C   04108DE5           STR      R1,[SP, #+4]
   \   00000080   04109DE5           LDR      R1,[SP, #+4]
    324                yNextHQ = y1HQ + 1;
    325              }
    326              /*
    327              * Calculate y part
    328              */
    329              yPart = (yNextHQ - yPosHQ) >> (16 - NUM_BITS);
   \   00000084   00209DE5           LDR      R2,[SP, #+0]
   \   00000088   010050E1           CMP      R0,R1
   \   0000008C   28109DB5           LDRLT    R1,[SP, #+40]
   \   00000090   04108DB5           STRLT    R1,[SP, #+4]
   \   00000094   04109DE5           LDR      R1,[SP, #+4]
   \   00000098   021041E0           SUB      R1,R1,R2
   \   0000009C   4112A0E1           ASR      R1,R1,#+4
   \   000000A0   20108DE5           STR      R1,[SP, #+32]
    330              /*
    331              * Iterate over one line
    332              */
    333              xPosHQ = x0HQ;
   \   000000A4   24109DE5           LDR      R1,[SP, #+36]
    334              do {
    335                /*
    336                * Calculate next x position
    337                */
    338                xOff    = (xPosHQ >> 16);
   \                     ??_GetColorHQ_1:
   \   000000A8   4108A0E1           ASR      R0,R1,#+16
    339                xNextHQ = ((I32)xOff + 1) << 16;
   \   000000AC   012080E2           ADD      R2,R0,#+1
   \   000000B0   02A8A0E1           LSL      R10,R2,#+16
    340                if (xNextHQ > x1HQ) {
   \   000000B4   10209DE5           LDR      R2,[SP, #+16]
    341                  xNextHQ = x1HQ + 1;
    342                }
    343                /*
    344                * Calculate x part
    345                */
    346                xPart = (xNextHQ - xPosHQ) >> (16 - NUM_BITS);
    347                if (yPart < (1 << NUM_BITS)) {
   \   000000B8   20309DE5           LDR      R3,[SP, #+32]
   \   000000BC   0A0052E1           CMP      R2,R10
   \   000000C0   2CA09DB5           LDRLT    R10,[SP, #+44]
   \   000000C4   400D53E3           CMP      R3,#+4096
   \   000000C8   01204AE0           SUB      R2,R10,R1
   \   000000CC   4222A0E1           ASR      R2,R2,#+4
    348                  xPart = (xPart * yPart) >> NUM_BITS;
   \   000000D0   93020230           MULCC    R2,R3,R2
   \   000000D4   2226A031           LSRCC    R2,R2,#+12
    349                }
    350                /*
    351                * Add current color
    352                */
    353                if ((xPosHQ >= 0) && (xOff < pMem->XSize) && (yPosHQ >= 0) && (yOff < pMem->YSize)) {
   \   000000D8   000051E3           CMP      R1,#+0
   \   000000DC   1000004A           BMI      ??_GetColorHQ_2
   \   000000E0   34109DE5           LDR      R1,[SP, #+52]
   \   000000E4   F810D1E1           LDRSH    R1,[R1, #+8]
   \   000000E8   010050E1           CMP      R0,R1
   \   000000EC   0C0000AA           BGE      ??_GetColorHQ_2
   \   000000F0   00309DE5           LDR      R3,[SP, #+0]
   \   000000F4   000053E3           CMP      R3,#+0
   \   000000F8   0900004A           BMI      ??_GetColorHQ_2
   \   000000FC   34C09DE5           LDR      R12,[SP, #+52]
   \   00000100   08309DE5           LDR      R3,[SP, #+8]
   \   00000104   FAC0DCE1           LDRSH    R12,[R12, #+10]
   \   00000108   0C0053E1           CMP      R3,R12
   \   0000010C   040000AA           BGE      ??_GetColorHQ_2
    354                  /*
    355                  * We are inside of the source memory device, so use its data
    356                  */
    357                  Color = *(pData + yOff * pMem->XSize + xOff);
   \   00000110   910303E0           MUL      R3,R1,R3
   \   00000114   38109DE5           LDR      R1,[SP, #+56]
   \   00000118   031181E0           ADD      R1,R1,R3, LSL #+2
   \   0000011C   000191E7           LDR      R0,[R1, +R0, LSL #+2]
   \   00000120   000000EA           B        ??_GetColorHQ_3
    358                } else {
    359                  /*
    360                  * We are outside, so use transparency
    361                  */
    362                  Color = GUI_TRANSPARENT;
   \                     ??_GetColorHQ_2:
   \   00000124   FF04A0E3           MOV      R0,#-16777216
    363                }
    364                a = (Color & GUI_TRANSPARENT) >> 24;
   \                     ??_GetColorHQ_3:
   \   00000128   20BCA0E1           LSR      R11,R0,#+24
    365                if (a < 255) {
   \   0000012C   FF005BE3           CMP      R11,#+255
   \   00000130   1E00002A           BCS      ??_GetColorHQ_4
    366                  r = (Color & 0x000000FF) >>  0;
   \   00000134   FF3000E2           AND      R3,R0,#0xFF
   \   00000138   1C308DE5           STR      R3,[SP, #+28]
    367                  g = (Color & 0x0000FF00) >>  8;
   \   0000013C   FF30A0E3           MOV      R3,#+255
   \   00000140   203403E0           AND      R3,R3,R0, LSR #+8
   \   00000144   18308DE5           STR      R3,[SP, #+24]
    368                  b = (Color & 0x00FF0000) >> 16;
   \   00000148   FF30A0E3           MOV      R3,#+255
   \   0000014C   200803E0           AND      R0,R3,R0, LSR #+16
   \   00000150   14008DE5           STR      R0,[SP, #+20]
    369                  if (a == 0) {
   \   00000154   00005BE3           CMP      R11,#+0
   \   00000158   0700001A           BNE      ??_GetColorHQ_5
    370                    /*
    371                    * No alpha value, so use full intensity
    372                    */
    373                    r = (r * xPart);
    374                    g = (g * xPart);
    375                    b = (b * xPart);
    376                    Pixel.r += r;
   \   0000015C   1C009DE5           LDR      R0,[SP, #+28]
    377                    Pixel.g += g;
    378                    Pixel.b += b;
    379                    Pixel.Sum      += xPart;
   \   00000160   088082E0           ADD      R8,R2,R8
   \   00000164   924024E0           MLA      R4,R2,R0,R4
   \   00000168   18009DE5           LDR      R0,[SP, #+24]
   \   0000016C   925025E0           MLA      R5,R2,R0,R5
   \   00000170   14009DE5           LDR      R0,[SP, #+20]
   \   00000174   926026E0           MLA      R6,R2,R0,R6
    380                    Pixel.SumAlpha += xPart;
   \   00000178   0D0000EA           B        ??_GetColorHQ_6
    381                  } else {
    382                    /*
    383                    * Reduce part by alpha value
    384                    */
    385                    f = GUI__DivideRound32(xPart * a, 255);
   \                     ??_GetColorHQ_5:
   \   0000017C   9B0200E0           MUL      R0,R11,R2
   \   00000180   FF10A0E3           MOV      R1,#+255
   \   00000184   ........           BL       GUI__DivideRound32
    386                    r = (r * f);
    387                    g = (g * f);
    388                    b = (b * f);
    389                    a = (a * f);
    390                    Pixel.r += r;
   \   00000188   1C109DE5           LDR      R1,[SP, #+28]
   \   0000018C   904124E0           MLA      R4,R0,R1,R4
    391                    Pixel.g += g;
   \   00000190   18109DE5           LDR      R1,[SP, #+24]
   \   00000194   905125E0           MLA      R5,R0,R1,R5
    392                    Pixel.b += b;
   \   00000198   14109DE5           LDR      R1,[SP, #+20]
    393                    Pixel.a += a;
   \   0000019C   907B27E0           MLA      R7,R0,R11,R7
   \   000001A0   906126E0           MLA      R6,R0,R1,R6
    394                    Pixel.Sum      += f;
   \   000001A4   088080E0           ADD      R8,R0,R8
    395                    Pixel.SumAlpha += f;
   \   000001A8   099080E0           ADD      R9,R0,R9
   \   000001AC   010000EA           B        ??_GetColorHQ_7
    396                  }
    397                } else {
    398                  /*
    399                  * Completely transparent
    400                  */
    401                  a = (a * xPart);
    402                  Pixel.a += a;
   \                     ??_GetColorHQ_4:
   \   000001B0   927B27E0           MLA      R7,R2,R11,R7
    403                  Pixel.SumAlpha += xPart;
   \                     ??_GetColorHQ_6:
   \   000001B4   099082E0           ADD      R9,R2,R9
    404                }
    405                /*
    406                * Next x positon
    407                */
    408                xPosHQ = xNextHQ;
    409              } while (xPosHQ < x1HQ);
   \                     ??_GetColorHQ_7:
   \   000001B8   10009DE5           LDR      R0,[SP, #+16]
   \   000001BC   0A10A0E1           MOV      R1,R10
   \   000001C0   000051E1           CMP      R1,R0
   \   000001C4   B7FFFFBA           BLT      ??_GetColorHQ_1
    410              /*
    411              * Next y positon
    412              */
    413              yPosHQ = yNextHQ;
   \   000001C8   04109DE5           LDR      R1,[SP, #+4]
   \   000001CC   00108DE5           STR      R1,[SP, #+0]
    414            } while (yPosHQ < y1HQ);
   \   000001D0   0100A0E1           MOV      R0,R1
   \   000001D4   0C109DE5           LDR      R1,[SP, #+12]
   \   000001D8   010050E1           CMP      R0,R1
   \   000001DC   A0FFFFBA           BLT      ??_GetColorHQ_0
    415            /*
    416            * Calculate resulting color
    417            */
    418            if (Pixel.Sum) {
   \   000001E0   000058E3           CMP      R8,#+0
   \   000001E4   1200000A           BEQ      ??_GetColorHQ_8
    419              Pixel.r = GUI__DivideRound32(Pixel.r, Pixel.Sum);
   \   000001E8   0810A0E1           MOV      R1,R8
   \   000001EC   0400A0E1           MOV      R0,R4
   \   000001F0   ........           BL       GUI__DivideRound32
   \   000001F4   0040A0E1           MOV      R4,R0
    420              Pixel.g = GUI__DivideRound32(Pixel.g, Pixel.Sum);
   \   000001F8   0810A0E1           MOV      R1,R8
   \   000001FC   0500A0E1           MOV      R0,R5
   \   00000200   ........           BL       GUI__DivideRound32
   \   00000204   0050A0E1           MOV      R5,R0
    421              Pixel.b = GUI__DivideRound32(Pixel.b, Pixel.Sum);
   \   00000208   0810A0E1           MOV      R1,R8
   \   0000020C   0600A0E1           MOV      R0,R6
   \   00000210   ........           BL       GUI__DivideRound32
   \   00000214   0060A0E1           MOV      R6,R0
    422              if (Pixel.a) {
   \   00000218   000057E3           CMP      R7,#+0
   \   0000021C   0500000A           BEQ      ??_GetColorHQ_9
    423                Pixel.a = GUI__DivideRound32(Pixel.a, Pixel.SumAlpha);
   \   00000220   0910A0E1           MOV      R1,R9
   \   00000224   0700A0E1           MOV      R0,R7
   \   00000228   ........           BL       GUI__DivideRound32
   \   0000022C   0070A0E1           MOV      R7,R0
   \   00000230   000000EA           B        ??_GetColorHQ_9
    424              }
    425            } else {
    426              Pixel.a = 0xff;
   \                     ??_GetColorHQ_8:
   \   00000234   FF70A0E3           MOV      R7,#+255
    427            }
    428            if (Pixel.r > 0xff) {
   \                     ??_GetColorHQ_9:
   \   00000238   400F54E3           CMP      R4,#+256
    429              Pixel.r = 0xff;
   \   0000023C   FF40A023           MOVCS    R4,#+255
    430            }
    431            if (Pixel.g > 0xff) {
   \   00000240   400F55E3           CMP      R5,#+256
    432              Pixel.g = 0xff;
   \   00000244   FF50A023           MOVCS    R5,#+255
    433            }
    434            if (Pixel.b > 0xff) {
   \   00000248   400F56E3           CMP      R6,#+256
    435              Pixel.b = 0xff;
   \   0000024C   FF60A023           MOVCS    R6,#+255
    436            }
    437            Color = Pixel.r | (Pixel.g << 8) | (Pixel.b << 16) | (Pixel.a << 24);
    438            return Color;
   \   00000250   050484E1           ORR      R0,R4,R5, LSL #+8
   \   00000254   060880E1           ORR      R0,R0,R6, LSL #+16
   \   00000258   070C80E1           ORR      R0,R0,R7, LSL #+24
   \   0000025C   3CD08DE2           ADD      SP,SP,#+60
   \   00000260   F08FBDE8           POP      {R4-R11,PC}      ;; return
    439          }
    440          
    441          /*********************************************************************
    442          *
    443          *       _Rotate32HQ
    444          */

   \                                 In section .text, align 4, keep-with-next
    445          static void _Rotate32HQ(GUI_MEMDEV_Handle hMemSrc, GUI_MEMDEV_Handle hMemDst, int dx, int dy, int a, int Mag) {
   \                     _Rotate32HQ:
   \   00000000   FC4F2DE9           PUSH     {R2-R11,LR}
   \   00000004   3CD04DE2           SUB      SP,SP,#+60
   \   00000008   6CA09DE5           LDR      R10,[SP, #+108]
   \   0000000C   0050A0E1           MOV      R5,R0
   \   00000010   0160A0E1           MOV      R6,R1
   \   00000014   68809DE5           LDR      R8,[SP, #+104]
    446            I32 cosMagHQ, sinMagHQ;
    447            I32 cosHQ, sinHQ;
    448            I32 xPosHQ, yPosHQ;
    449            int xSizeSrc, ySizeSrc;
    450            I32 x0SrcHQ, y0SrcHQ;
    451            int xDst, yDst;
    452            I32 PixelSizeHQ;
    453            GUI_MEMDEV * pMemSrc;
    454            GUI_MEMDEV * pMemDst;
    455            U32 * pDataSrc;
    456            U32 * pDataDst;
    457            RECT_MIN_MAX RectMinMax;
    458            I32 x0DstHQ, y0DstHQ;
    459            int xStart, yStart, xEnd, yEnd;
    460          
    461            if (Mag == 0) {
   \   00000018   00005AE3           CMP      R10,#+0
   \   0000001C   BD00000A           BEQ      ??_Rotate32HQ_0
    462              return;
    463            }
    464            /*
    465            * Get data pointers
    466            */
    467            pMemSrc   = (GUI_MEMDEV *)GUI_LOCK_H(hMemSrc);
   \   00000020   ........           BL       GUI_ALLOC_LockH
   \   00000024   0040A0E1           MOV      R4,R0
    468            pMemDst   = (GUI_MEMDEV *)GUI_LOCK_H(hMemDst);
   \   00000028   0600A0E1           MOV      R0,R6
   \   0000002C   ........           BL       GUI_ALLOC_LockH
   \   00000030   1C008DE5           STR      R0,[SP, #+28]
    469            pDataSrc  = (U32 *)GUI_MEMDEV_GetDataPtr(hMemSrc);
   \   00000034   0500A0E1           MOV      R0,R5
   \   00000038   ........           BL       GUI_MEMDEV_GetDataPtr
   \   0000003C   0050A0E1           MOV      R5,R0
    470            pDataDst  = (U32 *)GUI_MEMDEV_GetDataPtr(hMemDst);
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   ........           BL       GUI_MEMDEV_GetDataPtr
   \   00000048   24008DE5           STR      R0,[SP, #+36]
    471            /*
    472            * Calculate start position in source device
    473            */
    474            PixelSizeHQ = (1000L << 16) / Mag;
   \   0000004C   FA07A0E3           MOV      R0,#+65536000
   \   00000050   0A10A0E1           MOV      R1,R10
   \   00000054   ........           BL       __aeabi_idiv
   \   00000058   20008DE5           STR      R0,[SP, #+32]
    475            xSizeSrc    = pMemSrc->XSize;
   \   0000005C   F860D4E1           LDRSH    R6,[R4, #+8]
    476            ySizeSrc    = pMemSrc->YSize;
   \   00000060   FA70D4E1           LDRSH    R7,[R4, #+10]
    477            cosHQ       = GUI__CosHQ(a);
   \   00000064   0800A0E1           MOV      R0,R8
   \   00000068   ........           BL       GUI__CosHQ
   \   0000006C   10008DE5           STR      R0,[SP, #+16]
    478            sinHQ       = GUI__SinHQ(a);
   \   00000070   0800A0E1           MOV      R0,R8
   \   00000074   ........           BL       GUI__SinHQ
   \   00000078   00B0A0E1           MOV      R11,R0
    479            cosMagHQ    = (cosHQ * 1000) / Mag;
   \   0000007C   10009DE5           LDR      R0,[SP, #+16]
   \   00000080   FA9FA0E3           MOV      R9,#+1000
   \   00000084   990000E0           MUL      R0,R9,R0
   \   00000088   0A10A0E1           MOV      R1,R10
   \   0000008C   ........           BL       __aeabi_idiv
   \   00000090   0080A0E1           MOV      R8,R0
    480            sinMagHQ    = (sinHQ * 1000) / Mag;
   \   00000094   990B00E0           MUL      R0,R9,R11
   \   00000098   0A10A0E1           MOV      R1,R10
   \   0000009C   ........           BL       __aeabi_idiv
   \   000000A0   0090A0E1           MOV      R9,R0
    481            x0SrcHQ     = (xSizeSrc << 15) 
    482                        + ((sinMagHQ * ySizeSrc) >> 1) 
    483                        - ((cosMagHQ * xSizeSrc) >> 1) 
    484                        - (sinMagHQ >> 1)
    485                        + (cosMagHQ >> 1)
    486                        + sinMagHQ * dy 
    487                        - cosMagHQ * dx;
   \   000000A4   970901E0           MUL      R1,R7,R9
   \   000000A8   960803E0           MUL      R3,R6,R8
   \   000000AC   C110A0E1           ASR      R1,R1,#+1
   \   000000B0   861781E0           ADD      R1,R1,R6, LSL #+15
   \   000000B4   C920A0E1           ASR      R2,R9,#+1
   \   000000B8   C31041E0           SUB      R1,R1,R3, ASR #+1
   \   000000BC   021041E0           SUB      R1,R1,R2
   \   000000C0   40309DE5           LDR      R3,[SP, #+64]
   \   000000C4   C81081E0           ADD      R1,R1,R8, ASR #+1
   \   000000C8   931921E0           MLA      R1,R3,R9,R1
   \   000000CC   3C309DE5           LDR      R3,[SP, #+60]
    488            y0SrcHQ     = (ySizeSrc << 15) 
    489                        - ((cosMagHQ * ySizeSrc) >> 1) 
    490                        - ((sinMagHQ * xSizeSrc) >> 1) 
    491                        + (cosMagHQ >> 1)
    492                        + (sinMagHQ >> 1)
    493                        - cosMagHQ * dy 
    494                        - sinMagHQ * dx;
    495          
    496            x0DstHQ     = (xSizeSrc << 15)
    497                        - ((((sinHQ * Mag) / 1000) * ySizeSrc) >> 1) 
    498                        - ((((cosHQ * Mag) / 1000) * xSizeSrc) >> 1)
    499                        + ((U32)dx << 16);
    500            y0DstHQ     = (ySizeSrc << 15)
    501                        - ((((cosHQ * Mag) / 1000) * ySizeSrc) >> 1) 
    502                        + ((((sinHQ * Mag) / 1000) * xSizeSrc) >> 1)
    503                        + ((U32)dy << 16);
    504            _GetMinMax(x0DstHQ, y0DstHQ, sinHQ, cosHQ, xSizeSrc, ySizeSrc, Mag, &RectMinMax);
   \   000000D0   08A08DE5           STR      R10,[SP, #+8]
   \   000000D4   93080CE0           MUL      R12,R3,R8
   \   000000D8   970803E0           MUL      R3,R7,R8
   \   000000DC   0C1041E0           SUB      R1,R1,R12
   \   000000E0   18108DE5           STR      R1,[SP, #+24]
   \   000000E4   96090CE0           MUL      R12,R6,R9
   \   000000E8   8717A0E1           LSL      R1,R7,#+15
   \   000000EC   C33041E0           SUB      R3,R1,R3, ASR #+1
   \   000000F0   CC3043E0           SUB      R3,R3,R12, ASR #+1
   \   000000F4   C80083E0           ADD      R0,R3,R8, ASR #+1
   \   000000F8   000082E0           ADD      R0,R2,R0
   \   000000FC   40209DE5           LDR      R2,[SP, #+64]
   \   00000100   04708DE5           STR      R7,[SP, #+4]
   \   00000104   920803E0           MUL      R3,R2,R8
   \   00000108   3C209DE5           LDR      R2,[SP, #+60]
   \   0000010C   030040E0           SUB      R0,R0,R3
   \   00000110   920903E0           MUL      R3,R2,R9
   \   00000114   ........           LDR      R2,??DataTable2  ;; 0x10624dd3
   \   00000118   030040E0           SUB      R0,R0,R3
   \   0000011C   14008DE5           STR      R0,[SP, #+20]
   \   00000120   9A0B00E0           MUL      R0,R10,R11
   \   00000124   00608DE5           STR      R6,[SP, #+0]
   \   00000128   9032C2E0           SMULL    R3,R2,R0,R2
   \   0000012C   ........           LDR      R3,??DataTable2  ;; 0x10624dd3
   \   00000130   4203B0E1           ASRS     R0,R2,#+6
   \   00000134   10209DE5           LDR      R2,[SP, #+16]
   \   00000138   01008042           ADDMI    R0,R0,#+1
   \   0000013C   9A0202E0           MUL      R2,R10,R2
   \   00000140   92C3C3E0           SMULL    R12,R3,R2,R3
   \   00000144   28208DE2           ADD      R2,SP,#+40
   \   00000148   43C3B0E1           ASRS     R12,R3,#+6
   \   0000014C   01C08C42           ADDMI    R12,R12,#+1
   \   00000150   970C0EE0           MUL      LR,R7,R12
   \   00000154   CE1041E0           SUB      R1,R1,LR, ASR #+1
   \   00000158   96000EE0           MUL      LR,R6,R0
   \   0000015C   CE1081E0           ADD      R1,R1,LR, ASR #+1
   \   00000160   40E09DE5           LDR      LR,[SP, #+64]
   \   00000164   970000E0           MUL      R0,R7,R0
   \   00000168   0E1881E0           ADD      R1,R1,LR, LSL #+16
   \   0000016C   960C0CE0           MUL      R12,R6,R12
   \   00000170   86E7A0E1           LSL      LR,R6,#+15
   \   00000174   C0004EE0           SUB      R0,LR,R0, ASR #+1
   \   00000178   CC0040E0           SUB      R0,R0,R12, ASR #+1
   \   0000017C   3CC09DE5           LDR      R12,[SP, #+60]
   \   00000180   0C208DE5           STR      R2,[SP, #+12]
   \   00000184   10309DE5           LDR      R3,[SP, #+16]
   \   00000188   0B20A0E1           MOV      R2,R11
   \   0000018C   0C0880E0           ADD      R0,R0,R12, LSL #+16
   \   00000190   ........           BL       _GetMinMax
    505            /*
    506            * Clip y
    507            */
    508            yStart = RectMinMax.yMin;
    509            yEnd   = RectMinMax.yMax;
   \   00000194   34109DE5           LDR      R1,[SP, #+52]
   \   00000198   30009DE5           LDR      R0,[SP, #+48]
   \   0000019C   10108DE5           STR      R1,[SP, #+16]
    510            if (yStart < 0) {
    511              yStart = 0;
   \   000001A0   1C109DE5           LDR      R1,[SP, #+28]
   \   000001A4   000050E3           CMP      R0,#+0
   \   000001A8   FA10D1E1           LDRSH    R1,[R1, #+10]
   \   000001AC   10209DE5           LDR      R2,[SP, #+16]
    512            }
    513            if (yEnd >= pMemDst->YSize) {
    514              yEnd = pMemDst->YSize - 1;
    515            }
    516            x0SrcHQ -= sinMagHQ * yStart;
    517            y0SrcHQ += cosMagHQ * yStart;
    518            /*
    519            * Clip x
    520            */
    521            xStart = RectMinMax.xMin;
   \   000001B0   28C09DE5           LDR      R12,[SP, #+40]
    522            xEnd   = RectMinMax.xMax;
   \   000001B4   2C309DE5           LDR      R3,[SP, #+44]
   \   000001B8   0000A043           MOVMI    R0,#+0
   \   000001BC   010052E1           CMP      R2,R1
   \   000001C0   04C08DE5           STR      R12,[SP, #+4]
   \   000001C4   08308DE5           STR      R3,[SP, #+8]
   \   000001C8   011041A2           SUBGE    R1,R1,#+1
    523            if (xStart < 0) {
   \   000001CC   04309DE5           LDR      R3,[SP, #+4]
   \   000001D0   10108DA5           STRGE    R1,[SP, #+16]
   \   000001D4   000053E3           CMP      R3,#+0
    524              xStart = 0;
   \   000001D8   00C0A043           MOVMI    R12,#+0
   \   000001DC   1C309DE5           LDR      R3,[SP, #+28]
   \   000001E0   04C08D45           STRMI    R12,[SP, #+4]
   \   000001E4   F830D3E1           LDRSH    R3,[R3, #+8]
   \   000001E8   08C09DE5           LDR      R12,[SP, #+8]
   \   000001EC   03005CE1           CMP      R12,R3
   \   000001F0   900902E0           MUL      R2,R0,R9
    525            }
    526            if (xEnd >= pMemDst->XSize) {
    527              xEnd = pMemDst->XSize - 1;
   \   000001F4   01C043A2           SUBGE    R12,R3,#+1
   \   000001F8   18109DE5           LDR      R1,[SP, #+24]
   \   000001FC   08C08DA5           STRGE    R12,[SP, #+8]
    528            }
    529            x0SrcHQ  += cosMagHQ * xStart;
   \   00000200   04C09DE5           LDR      R12,[SP, #+4]
   \   00000204   021041E0           SUB      R1,R1,R2
   \   00000208   9C1821E0           MLA      R1,R12,R8,R1
   \   0000020C   14209DE5           LDR      R2,[SP, #+20]
   \   00000210   18108DE5           STR      R1,[SP, #+24]
   \   00000214   902822E0           MLA      R2,R0,R8,R2
    530            y0SrcHQ  += sinMagHQ * xStart;
   \   00000218   04109DE5           LDR      R1,[SP, #+4]
    531            /*
    532            * Iterate over the lines of the destination device
    533            */
    534            pDataDst += pMemDst->XSize * yStart;
    535            for (yDst = yStart; yDst <= yEnd; yDst++) {
   \   0000021C   0C008DE5           STR      R0,[SP, #+12]
   \   00000220   912922E0           MLA      R2,R1,R9,R2
   \   00000224   900301E0           MUL      R1,R0,R3
   \   00000228   14208DE5           STR      R2,[SP, #+20]
   \   0000022C   24209DE5           LDR      R2,[SP, #+36]
   \   00000230   10009DE5           LDR      R0,[SP, #+16]
   \   00000234   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000238   0C209DE5           LDR      R2,[SP, #+12]
   \   0000023C   020050E1           CMP      R0,R2
   \   00000240   320000BA           BLT      ??_Rotate32HQ_1
    536              xPosHQ = x0SrcHQ;
    537              yPosHQ = y0SrcHQ;
    538              /*
    539              * Iterate over all pixels of the line
    540              */
    541              pDataDst += xStart;
   \                     ??_Rotate32HQ_2:
   \   00000244   04009DE5           LDR      R0,[SP, #+4]
   \   00000248   00A181E0           ADD      R10,R1,R0, LSL #+2
    542              for (xDst = xStart; xDst <= xEnd; xDst++) {
   \   0000024C   00B0A0E1           MOV      R11,R0
   \   00000250   08009DE5           LDR      R0,[SP, #+8]
   \   00000254   18609DE5           LDR      R6,[SP, #+24]
   \   00000258   14709DE5           LDR      R7,[SP, #+20]
   \   0000025C   0B0050E1           CMP      R0,R11
   \   00000260   170000BA           BLT      ??_Rotate32HQ_3
    543                U32 Color, BkColor;
    544                U8 Alpha;
    545                Color = _GetColorHQ(pMemSrc, pDataSrc, xPosHQ, yPosHQ, PixelSizeHQ);
   \                     ??_Rotate32HQ_4:
   \   00000264   20009DE5           LDR      R0,[SP, #+32]
   \   00000268   0730A0E1           MOV      R3,R7
   \   0000026C   00008DE5           STR      R0,[SP, #+0]
   \   00000270   0620A0E1           MOV      R2,R6
   \   00000274   0510A0E1           MOV      R1,R5
   \   00000278   0400A0E1           MOV      R0,R4
   \   0000027C   ........           BL       _GetColorHQ
    546                Alpha = Color >> 24;
   \   00000280   201CB0E1           LSRS     R1,R0,#+24
    547                if (Alpha == 0) {
   \   00000284   0600000A           BEQ      ??_Rotate32HQ_5
    548                  /*
    549                  * No alpha blending
    550                  */
    551                  *pDataDst = Color;
    552                } else if (Alpha < 255) {
   \   00000288   012041E2           SUB      R2,R1,#+1
   \   0000028C   FE0052E3           CMP      R2,#+254
   \   00000290   0400002A           BCS      ??_Rotate32HQ_6
    553                  if (Alpha > 0) {
    554                    /*
    555                    * Manage alpha blending
    556                    */
    557                    BkColor   = *pDataDst;
    558                    Color     = GUI__MixColors(Color, BkColor, 255 - Alpha);
    559                    *pDataDst = Color;
   \   00000294   FF2061E2           RSB      R2,R1,#+255
   \   00000298   FF2002E2           AND      R2,R2,#0xFF
   \   0000029C   00109AE5           LDR      R1,[R10, #+0]
   \   000002A0   ........           BL       GUI__MixColors
   \                     ??_Rotate32HQ_5:
   \   000002A4   00008AE5           STR      R0,[R10, #+0]
    560                  }
    561                }
    562                #if 0 /* Please leave code for test purpose */
    563                if (xDst == RectMinMax.xMin) {
    564                  *pDataDst = GUI_RED;
    565                }
    566                if (xDst == RectMinMax.xMax) {
    567                  *pDataDst = GUI_RED;
    568                }
    569                if (yDst == RectMinMax.yMin) {
    570                  *pDataDst = GUI_RED;
    571                }
    572                if (yDst == RectMinMax.yMax) {
    573                  *pDataDst = GUI_RED;
    574                }
    575                #endif
    576                xPosHQ += cosMagHQ;
    577                yPosHQ += sinMagHQ;
    578                pDataDst++;
    579              }
   \                     ??_Rotate32HQ_6:
   \   000002A8   08009DE5           LDR      R0,[SP, #+8]
   \   000002AC   01B08BE2           ADD      R11,R11,#+1
   \   000002B0   066088E0           ADD      R6,R8,R6
   \   000002B4   077089E0           ADD      R7,R9,R7
   \   000002B8   04A08AE2           ADD      R10,R10,#+4
   \   000002BC   0B0050E1           CMP      R0,R11
   \   000002C0   E7FFFFAA           BGE      ??_Rotate32HQ_4
    580              pDataDst += (pMemDst->XSize - xEnd) - 1;
   \                     ??_Rotate32HQ_3:
   \   000002C4   1C009DE5           LDR      R0,[SP, #+28]
   \   000002C8   08109DE5           LDR      R1,[SP, #+8]
   \   000002CC   F800D0E1           LDRSH    R0,[R0, #+8]
   \   000002D0   010040E0           SUB      R0,R0,R1
   \   000002D4   00018AE0           ADD      R0,R10,R0, LSL #+2
   \   000002D8   041040E2           SUB      R1,R0,#+4
    581              x0SrcHQ -= sinMagHQ;
   \   000002DC   18009DE5           LDR      R0,[SP, #+24]
   \   000002E0   090040E0           SUB      R0,R0,R9
   \   000002E4   18008DE5           STR      R0,[SP, #+24]
    582              y0SrcHQ += cosMagHQ;
   \   000002E8   14009DE5           LDR      R0,[SP, #+20]
   \   000002EC   000088E0           ADD      R0,R8,R0
   \   000002F0   14008DE5           STR      R0,[SP, #+20]
    583            }
   \   000002F4   0C009DE5           LDR      R0,[SP, #+12]
   \   000002F8   010080E2           ADD      R0,R0,#+1
   \   000002FC   0C008DE5           STR      R0,[SP, #+12]
   \   00000300   10009DE5           LDR      R0,[SP, #+16]
   \   00000304   0C209DE5           LDR      R2,[SP, #+12]
   \   00000308   020050E1           CMP      R0,R2
   \   0000030C   CCFFFFAA           BGE      ??_Rotate32HQ_2
    584            /*
    585            * Unlock pointers
    586            */
    587            GUI_UNLOCK_H(pMemSrc);
   \                     ??_Rotate32HQ_1:
   \   00000310   ........           BL       GUI_ALLOC_UnlockH
    588            GUI_UNLOCK_H(pMemDst);
   \   00000314   ........           BL       GUI_ALLOC_UnlockH
    589          }
   \                     ??_Rotate32HQ_0:
   \   00000318   44D08DE2           ADD      SP,SP,#+68       ;; stack cleaning
   \   0000031C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    590          
    591          /*********************************************************************
    592          *
    593          *       _Check
    594          */
    595          static int _Check(GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst) {
    596            int BppSrc, BppDst;
    597          
    598            BppSrc = GUI_MEMDEV_GetBitsPerPixel(hSrc);
    599            BppDst = GUI_MEMDEV_GetBitsPerPixel(hDst);
    600            if ((BppSrc == 32) && (BppDst == 32)) {
    601              return 0;
    602            }
    603            return 1;
    604          }
    605          
    606          /*********************************************************************
    607          *
    608          *       Public code
    609          *
    610          **********************************************************************
    611          */
    612          /*********************************************************************
    613          *
    614          *       GUI_MEMDEV__Rotate
    615          */

   \                                 In section .text, align 4, keep-with-next
    616          void GUI_MEMDEV__Rotate(GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, U32 AndMask) {
   \                     GUI_MEMDEV__Rotate:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   0370A0E1           MOV      R7,R3
   \   00000018   30809DE5           LDR      R8,[SP, #+48]
   \   0000001C   34909DE5           LDR      R9,[SP, #+52]
   \   00000020   38A09DE5           LDR      R10,[SP, #+56]
    617            GUI_LOCK();
   \   00000024   ........           BL       GUI_Lock
    618            if (_Check(hSrc, hDst) == 0) {
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       GUI_MEMDEV_GetBitsPerPixel
   \   00000030   00B0A0E1           MOV      R11,R0
   \   00000034   0500A0E1           MOV      R0,R5
   \   00000038   ........           BL       GUI_MEMDEV_GetBitsPerPixel
   \   0000003C   20005BE3           CMP      R11,#+32
   \   00000040   20005003           CMPEQ    R0,#+32
   \   00000044   0700001A           BNE      ??GUI_MEMDEV__Rotate_0
    619              /*
    620              * Works only if both devices are 32bpp devices
    621              */
    622              _Rotate32(hSrc, hDst, dx, dy, a, Mag, AndMask);
   \   00000048   08A08DE5           STR      R10,[SP, #+8]
   \   0000004C   04908DE5           STR      R9,[SP, #+4]
   \   00000050   00808DE5           STR      R8,[SP, #+0]
   \   00000054   0730A0E1           MOV      R3,R7
   \   00000058   0620A0E1           MOV      R2,R6
   \   0000005C   0510A0E1           MOV      R1,R5
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       _Rotate32
    623            }
    624            GUI_UNLOCK();
   \                     ??GUI_MEMDEV__Rotate_0:
   \   00000068   0CD08DE2           ADD      SP,SP,#+12
   \   0000006C   F04FBDE8           POP      {R4-R11,LR}
   \   00000070   ........           B        GUI_Unlock       ;; tailcall
    625            return;
    626          }
    627          
    628          /*********************************************************************
    629          *
    630          *       GUI_MEMDEV_Rotate
    631          */

   \                                 In section .text, align 4, keep-with-next
    632          void GUI_MEMDEV_Rotate(GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag) {
   \                     GUI_MEMDEV_Rotate:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   0370A0E1           MOV      R7,R3
   \   00000018   30809DE5           LDR      R8,[SP, #+48]
   \   0000001C   34909DE5           LDR      R9,[SP, #+52]
    633            GUI_MEMDEV__Rotate(hSrc, hDst, dx, dy, a, Mag, 0xFFFFFFFF);
   \   00000020   ........           BL       GUI_Lock
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       GUI_MEMDEV_GetBitsPerPixel
   \   0000002C   00A0A0E1           MOV      R10,R0
   \   00000030   0500A0E1           MOV      R0,R5
   \   00000034   ........           BL       GUI_MEMDEV_GetBitsPerPixel
   \   00000038   20005AE3           CMP      R10,#+32
   \   0000003C   20005003           CMPEQ    R0,#+32
   \   00000040   0800001A           BNE      ??GUI_MEMDEV_Rotate_0
   \   00000044   0000E0E3           MVN      R0,#+0
   \   00000048   08008DE5           STR      R0,[SP, #+8]
   \   0000004C   04908DE5           STR      R9,[SP, #+4]
   \   00000050   00808DE5           STR      R8,[SP, #+0]
   \   00000054   0730A0E1           MOV      R3,R7
   \   00000058   0620A0E1           MOV      R2,R6
   \   0000005C   0510A0E1           MOV      R1,R5
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       _Rotate32
   \                     ??GUI_MEMDEV_Rotate_0:
   \   00000068   10D08DE2           ADD      SP,SP,#+16
   \   0000006C   F047BDE8           POP      {R4-R10,LR}
   \   00000070   ........           B        GUI_Unlock       ;; tailcall
    634          }
    635          
    636          /*********************************************************************
    637          *
    638          *       GUI_MEMDEV_RotateHQ
    639          */

   \                                 In section .text, align 4, keep-with-next
    640          void GUI_MEMDEV_RotateHQ(GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag) {
   \                     GUI_MEMDEV_RotateHQ:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   0370A0E1           MOV      R7,R3
   \   00000018   28809DE5           LDR      R8,[SP, #+40]
   \   0000001C   2C909DE5           LDR      R9,[SP, #+44]
    641            GUI_LOCK();
   \   00000020   ........           BL       GUI_Lock
    642            if (_Check(hSrc, hDst) == 0) {
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       GUI_MEMDEV_GetBitsPerPixel
   \   0000002C   00A0A0E1           MOV      R10,R0
   \   00000030   0500A0E1           MOV      R0,R5
   \   00000034   ........           BL       GUI_MEMDEV_GetBitsPerPixel
   \   00000038   20005AE3           CMP      R10,#+32
   \   0000003C   20005003           CMPEQ    R0,#+32
   \   00000040   0600001A           BNE      ??GUI_MEMDEV_RotateHQ_0
    643              /*
    644              * Works only if both devices are 32bpp devices
    645              */
    646              _Rotate32HQ(hSrc, hDst, dx, dy, a, Mag);
   \   00000044   04908DE5           STR      R9,[SP, #+4]
   \   00000048   00808DE5           STR      R8,[SP, #+0]
   \   0000004C   0730A0E1           MOV      R3,R7
   \   00000050   0620A0E1           MOV      R2,R6
   \   00000054   0510A0E1           MOV      R1,R5
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           BL       _Rotate32HQ
    647            }
    648            GUI_UNLOCK();
   \                     ??GUI_MEMDEV_RotateHQ_0:
   \   00000060   08D08DE2           ADD      SP,SP,#+8
   \   00000064   F047BDE8           POP      {R4-R10,LR}
   \   00000068   ........           B        GUI_Unlock       ;; tailcall
    649            return;
    650          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   D34D6210           DC32     0x10624dd3
    651          
    652          #else
    653          
    654          void GUIDEV_Rotate_C(void);
    655          void GUIDEV_Rotate_C(void) {}
    656          
    657          #endif /* GUI_SUPPORT_MEMDEV */
    658          
    659          /*************************** end of file ****************************/

   Maximum stack usage in bytes:

     Function            .cstack
     --------            -------
     GUI_MEMDEV_Rotate       48
     GUI_MEMDEV_RotateHQ     40
     GUI_MEMDEV__Rotate      48
     _GetColorHQ             96
     _GetMinMax              24
     _Rotate32              104
     _Rotate32HQ            104


   Section sizes:

     Function/Label      Bytes
     --------------      -----
     _GetMinMax           248
     _Rotate32            820
     _GetColorHQ          612
     _Rotate32HQ          800
     GUI_MEMDEV__Rotate   116
     GUI_MEMDEV_Rotate    116
     GUI_MEMDEV_RotateHQ  108
     ??DataTable2           4

 
 2 824 bytes in section .text
 
 2 824 bytes of CODE memory

Errors: none
Warnings: none
