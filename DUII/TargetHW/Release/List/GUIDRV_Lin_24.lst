###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:13:16 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_24.c                     #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_24.c -D DEBUG=1 -D       #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUIDRV_Lin_24.lst          #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUIDRV_Lin_24.o             #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDRV_Lin_24.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDRV_Lin_24.c
     19          Purpose     : Driver for accessing linear video memory
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stddef.h>
     24          
     25          #include "LCD_Private.h"
     26          #include "GUI_Private.h"
     27          #include "LCD_SIM.h"
     28          #include "LCD_ConfDefaults.h"
     29          
     30          #include "GUIDRV_Lin.h"
     31          
     32          #if (!defined(WIN32) | defined(LCD_SIMCONTROLLER))
     33          
     34          /*********************************************************************
     35          *
     36          *       Defines
     37          *
     38          **********************************************************************
     39          */
     40          #ifdef WIN32
     41            //
     42            // Simulation prototypes
     43            //
     44            U16  SIM_Lin_ReadMem16  (unsigned int Off);
     45            U32  SIM_Lin_ReadMem32  (unsigned int Off);
     46            U32  SIM_Lin_ReadMem32p (U32 * p);
     47            void SIM_Lin_WriteMem16 (unsigned int Off, U16 Data);
     48            void SIM_Lin_WriteMem32 (unsigned int Off, U32 Data);
     49            void SIM_Lin_WriteMem16p(U16 * p, U16 Data);
     50            void SIM_Lin_WriteMem32p(U32 * p, U32 Data);
     51            void SIM_Lin_memcpy     (void * pDst, const void * pSrc, int Len);
     52            void SIM_Lin_SetVRAMAddr(int LayerIndex, void * pVRAM);
     53            void SIM_Lin_SetVRAMSize(int LayerIndex, int xSize, int ySize);
     54            //
     55            // Access macro definition for internal simulation
     56            //
     57            #define LCD_READ_MEM16(VRAMAddr, Off)        SIM_Lin_ReadMem16(Off)
     58            #define LCD_READ_MEM32(VRAMAddr, Off)        SIM_Lin_ReadMem32(Off)
     59            #define LCD_READ_MEM32P(p)                   SIM_Lin_ReadMem32p(p)
     60            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) SIM_Lin_WriteMem16(Off, Data)
     61            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) SIM_Lin_WriteMem32(Off, Data)
     62            #define LCD_WRITE_MEM16P(p, Data)            SIM_Lin_WriteMem16p(p, Data)
     63            #define LCD_WRITE_MEM32P(p, Data)            SIM_Lin_WriteMem32p(p, Data)
     64            #undef  GUI_MEMCPY
     65            #define GUI_MEMCPY(pDst, pSrc, Len) SIM_Lin_memcpy(pDst, pSrc, Len)
     66          #else
     67            //
     68            // Access macro definition for hardware
     69            //
     70            #define LCD_READ_MEM16(VRAMAddr, Off)        (*((U16 *)VRAMAddr + (U32)Off))
     71            #define LCD_READ_MEM32(VRAMAddr, Off)        (*((U32 *)VRAMAddr + (U32)Off))
     72            #define LCD_READ_MEM32P(p)                   (*((U32 *)p))
     73            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) *((U16 *)VRAMAddr + (U32)Off) = Data
     74            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) *((U32 *)VRAMAddr + (U32)Off) = Data
     75            #define LCD_WRITE_MEM16P(p, Data)            *((U16 *)p) = Data
     76            #define LCD_WRITE_MEM32P(p, Data)            *((U32 *)p) = Data
     77          #endif
     78          
     79          #define WRITE_MEM16(VRAMAddr, Off, Data) LCD_WRITE_MEM16(VRAMAddr, Off, Data)
     80          #define WRITE_MEM32(VRAMAddr, Off, Data) LCD_WRITE_MEM32(VRAMAddr, Off, Data)
     81          #define READ_MEM16(VRAMAddr, Off)        LCD_READ_MEM16(VRAMAddr, Off)
     82          #define READ_MEM32(VRAMAddr, Off)        LCD_READ_MEM32(VRAMAddr, Off)
     83          #define READ_MEM32P(p)                   LCD_READ_MEM32P(p)
     84          #define WRITE_MEM16P(p, Data)            LCD_WRITE_MEM16P(p, Data)
     85          #define WRITE_MEM32P(p, Data)            LCD_WRITE_MEM32P(p, Data)
     86          
     87          #define OFF2PTR16(VRAMAddr, Off)     (U16 *)((U8 *)VRAMAddr + (Off << 1))
     88          #define OFF2PTR32(VRAMAddr, Off)     (U32 *)((U8 *)VRAMAddr + (Off << 2))
     89          
     90          #define XY2OFF32(vxSizePhys, x, y)      (((U32)(y * (vxSizePhys + vxSizePhys + vxSizePhys)) + ((unsigned)(x + x + x))) >> 2)
     91          
     92          /*********************************************************************
     93          *
     94          *       Types
     95          *
     96          **********************************************************************
     97          */
     98          typedef struct {
     99            U32 VRAMAddr;
    100            int xSize, ySize;
    101            int vxSize, vySize;
    102            int vxSizePhys;
    103            int xPos, yPos;
    104            int Alpha;
    105            int IsVisible;
    106            void (* pfFillRect)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex);
    107          } DRIVER_CONTEXT;
    108          
    109          /*********************************************************************
    110          *
    111          *       Static functions
    112          *
    113          **********************************************************************
    114          */
    115          /*********************************************************************
    116          *
    117          *       _SetPixelIndex
    118          *
    119          * Purpose:
    120          *   Sets the index of the given pixel. The upper layers
    121          *   calling this routine make sure that the coordinates are in range, so
    122          *   that no check on the parameters needs to be performed.
    123          */

   \                                 In section .text, align 4, keep-with-next
    124          static void _SetPixelIndex(GUI_DEVICE * pDevice, int x, int y, int PixelIndex) {
   \                     _SetPixelIndex:
   \   00000000   00402DE9           PUSH     {LR}
    125            DRIVER_CONTEXT * pContext;
    126            U32 Off, Data;
    127          
    128            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000004   080090E5           LDR      R0,[R0, #+8]
    129            Off      = XY2OFF32(pContext->vxSizePhys, x, y);
    130            Data     = READ_MEM32(pContext->VRAMAddr, Off);
    131            PixelIndex &= 0xFFFFFF;
   \   00000008   0334A0E1           LSL      R3,R3,#+8
   \   0000000C   14C090E5           LDR      R12,[R0, #+20]
   \   00000010   2334A0E1           LSR      R3,R3,#+8
   \   00000014   9C0202E0           MUL      R2,R12,R2
   \   00000018   81C081E0           ADD      R12,R1,R1, LSL #+1
   \   0000001C   822082E0           ADD      R2,R2,R2, LSL #+1
   \   00000020   02208CE0           ADD      R2,R12,R2
   \   00000024   00C090E5           LDR      R12,[R0, #+0]
   \   00000028   2221A0E1           LSR      R2,R2,#+2
    132            switch (x & 3) {
   \   0000002C   031001E2           AND      R1,R1,#0x3
   \   00000030   02E19CE7           LDR      LR,[R12, +R2, LSL #+2]
   \   00000034   030051E3           CMP      R1,#+3
   \   00000038   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_SetPixelIndex_0:
   \   0000003C   1D00008A           BHI      ??_SetPixelIndex_1
   \   00000040   020000EA           B        ??_SetPixelIndex_2
   \   00000044   040000EA           B        ??_SetPixelIndex_3
   \   00000048   0E0000EA           B        ??_SetPixelIndex_4
   \   0000004C   170000EA           B        ??_SetPixelIndex_5
    133            case 0:
    134              Data &= 0xFF000000;
    135              Data |= PixelIndex;
   \                     ??_SetPixelIndex_2:
   \   00000050   FF140EE2           AND      R1,LR,#0xFF000000
   \   00000054   01E083E1           ORR      LR,R3,R1
    136              break;
   \   00000058   160000EA           B        ??_SetPixelIndex_1
    137            case 1:
    138              Data &= 0x00FFFFFF;
    139              Data |= (PixelIndex << 24);
    140              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_SetPixelIndex_3:
   \   0000005C   0E14A0E1           LSL      R1,LR,#+8
   \   00000060   03ECA0E1           LSL      LR,R3,#+24
   \   00000064   21148EE1           ORR      R1,LR,R1, LSR #+8
   \   00000068   02118CE7           STR      R1,[R12, +R2, LSL #+2]
    141              Off++;
    142              Data = READ_MEM32(pContext->VRAMAddr, Off);
    143              Data &= 0xFFFF0000;
    144              Data |= (PixelIndex >> 8);
   \   0000006C   001090E5           LDR      R1,[R0, #+0]
   \   00000070   012082E2           ADD      R2,R2,#+1
   \   00000074   021191E7           LDR      R1,[R1, +R2, LSL #+2]
   \   00000078   4334A0E1           ASR      R3,R3,#+8
   \   0000007C   2118A0E1           LSR      R1,R1,#+16
   \   00000080   01E883E1           ORR      LR,R3,R1, LSL #+16
    145              break;
   \   00000084   0B0000EA           B        ??_SetPixelIndex_1
    146            case 2:
    147              Data &= 0x0000FFFF;
    148              Data |= (PixelIndex << 16);
    149              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_SetPixelIndex_4:
   \   00000088   0E18A0E1           LSL      R1,LR,#+16
   \   0000008C   03E8A0E1           LSL      LR,R3,#+16
   \   00000090   21188EE1           ORR      R1,LR,R1, LSR #+16
   \   00000094   02118CE7           STR      R1,[R12, +R2, LSL #+2]
    150              Off++;
    151              Data = READ_MEM32(pContext->VRAMAddr, Off);
    152              Data &= 0xFFFFFF00;
    153              Data |= (PixelIndex >> 16);
   \   00000098   001090E5           LDR      R1,[R0, #+0]
   \   0000009C   012082E2           ADD      R2,R2,#+1
   \   000000A0   021191E7           LDR      R1,[R1, +R2, LSL #+2]
   \   000000A4   FF10C1E3           BIC      R1,R1,#0xFF
   \   000000A8   43E881E1           ORR      LR,R1,R3, ASR #+16
    154              break;
   \   000000AC   010000EA           B        ??_SetPixelIndex_1
    155            case 3:
    156              Data &= 0x000000FF;
    157              Data |= (PixelIndex << 8);
   \                     ??_SetPixelIndex_5:
   \   000000B0   FF100EE2           AND      R1,LR,#0xFF
   \   000000B4   03E481E1           ORR      LR,R1,R3, LSL #+8
    158              break;
    159            }
    160            WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_SetPixelIndex_1:
   \   000000B8   000090E5           LDR      R0,[R0, #+0]
   \   000000BC   02E180E7           STR      LR,[R0, +R2, LSL #+2]
    161          }
   \   000000C0   0080BDE8           POP      {PC}             ;; return
    162          
    163          /*********************************************************************
    164          *
    165          *       _GetPixelIndex
    166          *
    167          * Purpose:
    168          *   Returns the index of the given pixel. The upper layers
    169          *   calling this routine make sure that the coordinates are in range, so
    170          *   that no check on the parameters needs to be performed.
    171          */

   \                                 In section .text, align 4, keep-with-next
    172          static unsigned int _GetPixelIndex(GUI_DEVICE * pDevice, int x, int y) {
    173            DRIVER_CONTEXT * pContext;
    174            U32 Off, Data, PixelIndex;
    175          
    176            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetPixelIndex:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
   \   00000004   0230A0E1           MOV      R3,R2
    177            Off      = XY2OFF32(pContext->vxSizePhys, x, y);
   \   00000008   14C090E5           LDR      R12,[R0, #+20]
   \   0000000C   9C0303E0           MUL      R3,R12,R3
   \   00000010   81C081E0           ADD      R12,R1,R1, LSL #+1
   \   00000014   833083E0           ADD      R3,R3,R3, LSL #+1
   \   00000018   03308CE0           ADD      R3,R12,R3
    178            Data     = READ_MEM32(pContext->VRAMAddr, Off);
   \   0000001C   00C090E5           LDR      R12,[R0, #+0]
   \   00000020   2331A0E1           LSR      R3,R3,#+2
    179            switch (x & 3) {
   \   00000024   031001E2           AND      R1,R1,#0x3
   \   00000028   03019CE7           LDR      R0,[R12, +R3, LSL #+2]
   \   0000002C   030051E3           CMP      R1,#+3
   \   00000030   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetPixelIndex_0:
   \   00000034   1200008A           BHI      ??_GetPixelIndex_1
   \   00000038   020000EA           B        ??_GetPixelIndex_2
   \   0000003C   030000EA           B        ??_GetPixelIndex_3
   \   00000040   090000EA           B        ??_GetPixelIndex_4
   \   00000044   0D0000EA           B        ??_GetPixelIndex_5
    180            case 0:
    181              PixelIndex  = (Data & 0x00FFFFFF);
   \                     ??_GetPixelIndex_2:
   \   00000048   0004A0E1           LSL      R0,R0,#+8
   \   0000004C   0B0000EA           B        ??_GetPixelIndex_5
    182              break;
    183            case 1:
    184              PixelIndex  = (Data & 0xFF000000) >> 24;
    185              Off++;
    186              Data        = READ_MEM32(pContext->VRAMAddr, Off);
    187              PixelIndex |= (Data & 0x0000FFFF) << 8;
   \                     ??_GetPixelIndex_3:
   \   00000050   03118CE0           ADD      R1,R12,R3, LSL #+2
   \   00000054   B410D1E1           LDRH     R1,[R1, #+4]
   \   00000058   0118A0E1           LSL      R1,R1,#+16
   \   0000005C   2118A0E1           LSR      R1,R1,#+16
   \   00000060   0114A0E1           LSL      R1,R1,#+8
   \   00000064   202C81E1           ORR      R2,R1,R0, LSR #+24
    188              break;
   \   00000068   050000EA           B        ??_GetPixelIndex_1
    189            case 2:
    190              PixelIndex  = (Data & 0xFFFF0000) >> 16;
    191              Off++;
    192              Data        = READ_MEM32(pContext->VRAMAddr, Off);
    193              PixelIndex |= (Data & 0x000000FF) << 16;
   \                     ??_GetPixelIndex_4:
   \   0000006C   03118CE0           ADD      R1,R12,R3, LSL #+2
   \   00000070   0410D1E5           LDRB     R1,[R1, #+4]
   \   00000074   0118A0E1           LSL      R1,R1,#+16
   \   00000078   202881E1           ORR      R2,R1,R0, LSR #+16
    194              break;
   \   0000007C   000000EA           B        ??_GetPixelIndex_1
    195            case 3:
    196              PixelIndex  = (Data & 0xFFFFFF00) >> 8;
   \                     ??_GetPixelIndex_5:
   \   00000080   2024A0E1           LSR      R2,R0,#+8
    197              break;
    198            }
    199            return PixelIndex;
   \                     ??_GetPixelIndex_1:
   \   00000084   0200A0E1           MOV      R0,R2
   \   00000088   1EFF2FE1           BX       LR               ;; return
    200          }
    201          
    202          /*********************************************************************
    203          *
    204          *       _XorPixel
    205          */

   \                                 In section .text, align 4, keep-with-next
    206          static void _XorPixel(GUI_DEVICE * pDevice, int x, int y) {
   \                     _XorPixel:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    207            LCD_PIXELINDEX PixelIndex;
    208            LCD_PIXELINDEX IndexMask;
    209          
    210            PixelIndex = _GetPixelIndex(pDevice, x, y);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   141090E5           LDR      R1,[R0, #+20]
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   910602E0           MUL      R2,R1,R6
   \   0000001C   033005E2           AND      R3,R5,#0x3
   \   00000020   821082E0           ADD      R1,R2,R2, LSL #+1
   \   00000024   852085E0           ADD      R2,R5,R5, LSL #+1
   \   00000028   011082E0           ADD      R1,R2,R1
   \   0000002C   002090E5           LDR      R2,[R0, #+0]
   \   00000030   2111A0E1           LSR      R1,R1,#+2
   \   00000034   04D04DE2           SUB      SP,SP,#+4
   \   00000038   010192E7           LDR      R0,[R2, +R1, LSL #+2]
   \   0000003C   030053E3           CMP      R3,#+3
   \   00000040   03F18F90           ADDLS    PC,PC,R3, LSL #+2
   \                     ??_XorPixel_0:
   \   00000044   1100008A           BHI      ??_XorPixel_1
   \   00000048   0E0000EA           B        ??_XorPixel_2
   \   0000004C   060000EA           B        ??_XorPixel_3
   \   00000050   000000EA           B        ??_XorPixel_4
   \   00000054   0C0000EA           B        ??_XorPixel_5
   \                     ??_XorPixel_4:
   \   00000058   011182E0           ADD      R1,R2,R1, LSL #+2
   \   0000005C   0410D1E5           LDRB     R1,[R1, #+4]
   \   00000060   0118A0E1           LSL      R1,R1,#+16
   \   00000064   207881E1           ORR      R7,R1,R0, LSR #+16
   \   00000068   080000EA           B        ??_XorPixel_1
   \                     ??_XorPixel_3:
   \   0000006C   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000070   B410D1E1           LDRH     R1,[R1, #+4]
   \   00000074   0118A0E1           LSL      R1,R1,#+16
   \   00000078   2118A0E1           LSR      R1,R1,#+16
   \   0000007C   0114A0E1           LSL      R1,R1,#+8
   \   00000080   207C81E1           ORR      R7,R1,R0, LSR #+24
   \   00000084   010000EA           B        ??_XorPixel_1
   \                     ??_XorPixel_2:
   \   00000088   0004A0E1           LSL      R0,R0,#+8
   \                     ??_XorPixel_5:
   \   0000008C   2074A0E1           LSR      R7,R0,#+8
    211            IndexMask  = pDevice->pColorConvAPI->pfGetIndexMask();
   \                     ??_XorPixel_1:
   \   00000090   100094E5           LDR      R0,[R4, #+16]
   \   00000094   080090E5           LDR      R0,[R0, #+8]
   \   00000098   30FF2FE1           BLX      R0
    212            _SetPixelIndex(pDevice, x, y, PixelIndex ^ IndexMask);
   \   0000009C   073020E0           EOR      R3,R0,R7
   \   000000A0   0620A0E1           MOV      R2,R6
   \   000000A4   0510A0E1           MOV      R1,R5
   \   000000A8   0400A0E1           MOV      R0,R4
   \   000000AC   04D08DE2           ADD      SP,SP,#+4
   \   000000B0   F040BDE8           POP      {R4-R7,LR}
   \   000000B4   ........           B        _SetPixelIndex   ;; tailcall
    213          }
    214          
    215          /*********************************************************************
    216          *
    217          *       _DrawHLine
    218          */

   \                                 In section .text, align 4, keep-with-next
    219          static void _DrawHLine  (GUI_DEVICE * pDevice, int x0, int y,  int x1) {
   \                     _DrawHLine:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0070A0E1           MOV      R7,R0
    220            DRIVER_CONTEXT * pContext;
    221            int Off, RemPixels, Odd;
    222            U32 Data;
    223            LCD_PIXELINDEX ColorIndex;
    224          
    225            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable12
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0150A0E1           MOV      R5,R1
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   0340A0E1           MOV      R4,R3
   \   00000020   010010E3           TST      R0,#0x1
   \   00000024   2D00000A           BEQ      ??_DrawHLine_1
   \   00000028   050054E1           CMP      R4,R5
   \   0000002C   970000BA           BLT      ??_DrawHLine_2
   \   00000030   FF80A0E3           MOV      R8,#+255
   \   00000034   FF8C88E3           ORR      R8,R8,#0xFF00
    226              for (; x0 <= x1; x0++) {
    227                _XorPixel(pDevice, x0, y);
   \                     ??_DrawHLine_3:
   \   00000038   080097E5           LDR      R0,[R7, #+8]
   \   0000003C   033005E2           AND      R3,R5,#0x3
   \   00000040   141090E5           LDR      R1,[R0, #+20]
   \   00000044   030053E3           CMP      R3,#+3
   \   00000048   910602E0           MUL      R2,R1,R6
   \   0000004C   821082E0           ADD      R1,R2,R2, LSL #+1
   \   00000050   852085E0           ADD      R2,R5,R5, LSL #+1
   \   00000054   011082E0           ADD      R1,R2,R1
   \   00000058   002090E5           LDR      R2,[R0, #+0]
   \   0000005C   2111A0E1           LSR      R1,R1,#+2
   \   00000060   010192E7           LDR      R0,[R2, +R1, LSL #+2]
   \   00000064   03F18F90           ADDLS    PC,PC,R3, LSL #+2
   \                     ??_DrawHLine_0:
   \   00000068   1000008A           BHI      ??_DrawHLine_4
   \   0000006C   0D0000EA           B        ??_DrawHLine_5
   \   00000070   060000EA           B        ??_DrawHLine_6
   \   00000074   000000EA           B        ??_DrawHLine_7
   \   00000078   0B0000EA           B        ??_DrawHLine_8
   \                     ??_DrawHLine_7:
   \   0000007C   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000080   0410D1E5           LDRB     R1,[R1, #+4]
   \   00000084   0118A0E1           LSL      R1,R1,#+16
   \   00000088   209881E1           ORR      R9,R1,R0, LSR #+16
   \   0000008C   070000EA           B        ??_DrawHLine_4
   \                     ??_DrawHLine_6:
   \   00000090   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000094   041091E5           LDR      R1,[R1, #+4]
   \   00000098   011008E0           AND      R1,R8,R1
   \   0000009C   0114A0E1           LSL      R1,R1,#+8
   \   000000A0   209C81E1           ORR      R9,R1,R0, LSR #+24
   \   000000A4   010000EA           B        ??_DrawHLine_4
   \                     ??_DrawHLine_5:
   \   000000A8   0004A0E1           LSL      R0,R0,#+8
   \                     ??_DrawHLine_8:
   \   000000AC   2094A0E1           LSR      R9,R0,#+8
   \                     ??_DrawHLine_4:
   \   000000B0   100097E5           LDR      R0,[R7, #+16]
   \   000000B4   080090E5           LDR      R0,[R0, #+8]
   \   000000B8   30FF2FE1           BLX      R0
   \   000000BC   093020E0           EOR      R3,R0,R9
   \   000000C0   0620A0E1           MOV      R2,R6
   \   000000C4   0510A0E1           MOV      R1,R5
   \   000000C8   0700A0E1           MOV      R0,R7
   \   000000CC   ........           BL       _SetPixelIndex
    228              }
   \   000000D0   015085E2           ADD      R5,R5,#+1
   \   000000D4   050054E1           CMP      R4,R5
   \   000000D8   D6FFFFAA           BGE      ??_DrawHLine_3
   \   000000DC   6B0000EA           B        ??_DrawHLine_2
    229            } else {
    230              ColorIndex = LCD__GetColorIndex();
    231              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     ??_DrawHLine_1:
   \   000000E0   081097E5           LDR      R1,[R7, #+8]
   \   000000E4   ........           LDR      R0,??DataTable13
    232              Off = XY2OFF32(pContext->vxSizePhys, x0, y);
   \   000000E8   142091E5           LDR      R2,[R1, #+20]
   \   000000EC   000090E5           LDR      R0,[R0, #+0]
   \   000000F0   920603E0           MUL      R3,R2,R6
   \   000000F4   000090E5           LDR      R0,[R0, #+0]
   \   000000F8   832083E0           ADD      R2,R3,R3, LSL #+1
   \   000000FC   853085E0           ADD      R3,R5,R5, LSL #+1
   \   00000100   022083E0           ADD      R2,R3,R2
    233              RemPixels = x1 - x0 + 1;
   \   00000104   053044E0           SUB      R3,R4,R5
   \   00000108   2221A0E1           LSR      R2,R2,#+2
   \   0000010C   013083E2           ADD      R3,R3,#+1
    234              //
    235              // First triple DWORD
    236              //
    237              Odd = x0 & 3;
   \   00000110   03C015E2           ANDS     R12,R5,#0x3
    238              if (Odd) {
   \   00000114   2900000A           BEQ      ??_DrawHLine_9
    239                Data  = READ_MEM32(pContext->VRAMAddr, Off);
   \   00000118   00E091E5           LDR      LR,[R1, #+0]
    240                switch (Odd) {
   \   0000011C   01005CE3           CMP      R12,#+1
   \   00000120   02419EE7           LDR      R4,[LR, +R2, LSL #+2]
   \   00000124   0400000A           BEQ      ??_DrawHLine_10
   \   00000128   2400003A           BCC      ??_DrawHLine_9
   \   0000012C   03005CE3           CMP      R12,#+3
   \   00000130   1C00000A           BEQ      ??_DrawHLine_11
   \   00000134   0F00003A           BCC      ??_DrawHLine_12
   \   00000138   200000EA           B        ??_DrawHLine_9
    241                case 1:
    242                  Data &= 0x00FFFFFF;
    243                  Data |= ColorIndex << 24;
    244                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_10:
   \   0000013C   04C4A0E1           LSL      R12,R4,#+8
   \   00000140   004CA0E1           LSL      R4,R0,#+24
   \   00000144   2CC484E1           ORR      R12,R4,R12, LSR #+8
   \   00000148   02C18EE7           STR      R12,[LR, +R2, LSL #+2]
    245                  Off++;
    246                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    247                  Data &= 0xFFFF0000;
    248                  Data |= ColorIndex >> 8;
   \   0000014C   00C091E5           LDR      R12,[R1, #+0]
   \   00000150   012082E2           ADD      R2,R2,#+1
   \   00000154   02C19CE7           LDR      R12,[R12, +R2, LSL #+2]
   \   00000158   20E4A0E1           LSR      LR,R0,#+8
   \   0000015C   2CC8A0E1           LSR      R12,R12,#+16
   \   00000160   0C488EE1           ORR      R4,LR,R12, LSL #+16
    249                  RemPixels--;
   \   00000164   013053E2           SUBS     R3,R3,#+1
    250                  if (!RemPixels) {
   \   00000168   0200001A           BNE      ??_DrawHLine_12
    251                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_13:
   \   0000016C   00C091E5           LDR      R12,[R1, #+0]
   \   00000170   02418CE7           STR      R4,[R12, +R2, LSL #+2]
    252                    break;
   \   00000174   110000EA           B        ??_DrawHLine_9
    253                  }
    254                  //
    255                  // no break at this position required...
    256                  //
    257                case 2:
    258                  Data &= 0x0000FFFF;
    259                  Data |= ColorIndex << 16;
    260                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_12:
   \   00000178   04C8A0E1           LSL      R12,R4,#+16
   \   0000017C   00E8A0E1           LSL      LR,R0,#+16
   \   00000180   2CC88EE1           ORR      R12,LR,R12, LSR #+16
   \   00000184   00E091E5           LDR      LR,[R1, #+0]
    261                  Off++;
    262                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    263                  Data &= 0xFFFFFF00;
    264                  Data |= ColorIndex >> 16;
    265                  RemPixels--;
   \   00000188   013053E2           SUBS     R3,R3,#+1
   \   0000018C   02C18EE7           STR      R12,[LR, +R2, LSL #+2]
   \   00000190   00C091E5           LDR      R12,[R1, #+0]
   \   00000194   012082E2           ADD      R2,R2,#+1
   \   00000198   02C19CE7           LDR      R12,[R12, +R2, LSL #+2]
   \   0000019C   FFC0CCE3           BIC      R12,R12,#0xFF
   \   000001A0   20488CE1           ORR      R4,R12,R0, LSR #+16
    266                  if (!RemPixels) {
   \   000001A4   F0FFFF0A           BEQ      ??_DrawHLine_13
    267                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    268                    break;
    269                  }
    270                  //
    271                  // no break at this position required...
    272                  //
    273                case 3:
    274                  Data &= 0x000000FF;
    275                  Data |= ColorIndex << 8;
    276                  RemPixels--;
    277                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_11:
   \   000001A8   FFC004E2           AND      R12,R4,#0xFF
   \   000001AC   00E091E5           LDR      LR,[R1, #+0]
   \   000001B0   00C48CE1           ORR      R12,R12,R0, LSL #+8
   \   000001B4   02C18EE7           STR      R12,[LR, +R2, LSL #+2]
   \   000001B8   013043E2           SUB      R3,R3,#+1
    278                  Off++;
   \   000001BC   012082E2           ADD      R2,R2,#+1
    279                }
    280              }
    281              //
    282              // Complete triple DWORDS
    283              //
    284              if (RemPixels >= 4) {
   \                     ??_DrawHLine_9:
   \   000001C0   040053E3           CMP      R3,#+4
   \   000001C4   100000BA           BLT      ??_DrawHLine_14
    285                U32 Data0, Data1, Data2;
    286                Data0 = (ColorIndex      ) | (ColorIndex << 24);
    287                Data1 = (ColorIndex >>  8) | (ColorIndex << 16);
   \   000001C8   00E8A0E1           LSL      LR,R0,#+16
    288                Data2 = (ColorIndex >> 16) | (ColorIndex <<  8);
   \   000001CC   0044A0E1           LSL      R4,R0,#+8
   \   000001D0   00CC80E1           ORR      R12,R0,R0, LSL #+24
   \   000001D4   20E48EE1           ORR      LR,LR,R0, LSR #+8
   \   000001D8   204884E1           ORR      R4,R4,R0, LSR #+16
    289                do {
    290                  WRITE_MEM32(pContext->VRAMAddr, Off + 0, Data0);
   \                     ??_DrawHLine_15:
   \   000001DC   005091E5           LDR      R5,[R1, #+0]
    291                  WRITE_MEM32(pContext->VRAMAddr, Off + 1, Data1);
    292                  WRITE_MEM32(pContext->VRAMAddr, Off + 2, Data2);
    293                  Off += 3;
    294                } while ((RemPixels -= 4) >= 4);
   \   000001E0   043043E2           SUB      R3,R3,#+4
   \   000001E4   02C185E7           STR      R12,[R5, +R2, LSL #+2]
   \   000001E8   005091E5           LDR      R5,[R1, #+0]
   \   000001EC   040053E3           CMP      R3,#+4
   \   000001F0   025185E0           ADD      R5,R5,R2, LSL #+2
   \   000001F4   04E085E5           STR      LR,[R5, #+4]
   \   000001F8   005091E5           LDR      R5,[R1, #+0]
   \   000001FC   025185E0           ADD      R5,R5,R2, LSL #+2
   \   00000200   084085E5           STR      R4,[R5, #+8]
   \   00000204   032082E2           ADD      R2,R2,#+3
   \   00000208   F3FFFFAA           BGE      ??_DrawHLine_15
    295              }
    296              //
    297              // Last triple DWORD
    298              //
    299              if (RemPixels) {
   \                     ??_DrawHLine_14:
   \   0000020C   000053E3           CMP      R3,#+0
   \   00000210   1E00000A           BEQ      ??_DrawHLine_2
    300                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    301                Data &= 0xFF000000;
    302                Data |= ColorIndex;
   \   00000214   00C091E5           LDR      R12,[R1, #+0]
    303                RemPixels--;
   \   00000218   013053E2           SUBS     R3,R3,#+1
   \   0000021C   02E19CE7           LDR      LR,[R12, +R2, LSL #+2]
   \   00000220   FFE40EE2           AND      LR,LR,#0xFF000000
   \   00000224   0E4080E1           ORR      R4,R0,LR
    304                if (!RemPixels) {
   \   00000228   0200001A           BNE      ??_DrawHLine_16
    305                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_17:
   \   0000022C   000091E5           LDR      R0,[R1, #+0]
   \   00000230   024180E7           STR      R4,[R0, +R2, LSL #+2]
    306                  return;
   \   00000234   150000EA           B        ??_DrawHLine_2
    307                }
    308                Data &= 0x00FFFFFF;
    309                Data |= ColorIndex << 24;
    310                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_16:
   \   00000238   04E4A0E1           LSL      LR,R4,#+8
   \   0000023C   004CA0E1           LSL      R4,R0,#+24
   \   00000240   2EE484E1           ORR      LR,R4,LR, LSR #+8
   \   00000244   02E18CE7           STR      LR,[R12, +R2, LSL #+2]
    311                Off++;
    312                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    313                Data &= 0xFFFF0000;
    314                Data |= ColorIndex >> 8;
   \   00000248   00C091E5           LDR      R12,[R1, #+0]
   \   0000024C   012082E2           ADD      R2,R2,#+1
   \   00000250   02E19CE7           LDR      LR,[R12, +R2, LSL #+2]
   \   00000254   2044A0E1           LSR      R4,R0,#+8
   \   00000258   2EE8A0E1           LSR      LR,LR,#+16
   \   0000025C   0E4884E1           ORR      R4,R4,LR, LSL #+16
    315                RemPixels--;
    316                if (!RemPixels) {
   \   00000260   013053E2           SUBS     R3,R3,#+1
   \   00000264   F0FFFF0A           BEQ      ??_DrawHLine_17
    317                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    318                  return;
    319                }
    320                Data &= 0x0000FFFF;
    321                Data |= ColorIndex << 16;
    322                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000268   0438A0E1           LSL      R3,R4,#+16
   \   0000026C   00E8A0E1           LSL      LR,R0,#+16
   \   00000270   23388EE1           ORR      R3,LR,R3, LSR #+16
   \   00000274   02318CE7           STR      R3,[R12, +R2, LSL #+2]
    323                Off++;
    324                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    325                Data &= 0xFFFFFF00;
    326                Data |= ColorIndex >> 16;
    327                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000278   001091E5           LDR      R1,[R1, #+0]
   \   0000027C   012082E2           ADD      R2,R2,#+1
   \   00000280   023191E7           LDR      R3,[R1, +R2, LSL #+2]
   \   00000284   FF30C3E3           BIC      R3,R3,#0xFF
   \   00000288   200883E1           ORR      R0,R3,R0, LSR #+16
   \   0000028C   020181E7           STR      R0,[R1, +R2, LSL #+2]
   \                     ??_DrawHLine_2:
   \   00000290   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000294   F083BDE8           POP      {R4-R9,PC}       ;; return
    328              }
    329            }
    330          }
    331          
    332          /*********************************************************************
    333          *
    334          *       _DrawVLine, not optimized
    335          */

   \                                 In section .text, align 4, keep-with-next
    336          static void _DrawVLine  (GUI_DEVICE * pDevice, int x, int y0,  int y1) {
   \                     _DrawVLine:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    337            LCD_PIXELINDEX ColorIndex;
    338          
    339            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable12
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0160A0E1           MOV      R6,R1
   \   00000018   0270A0E1           MOV      R7,R2
   \   0000001C   0380A0E1           MOV      R8,R3
   \   00000020   010010E3           TST      R0,#0x1
   \   00000024   2D00000A           BEQ      ??_DrawVLine_1
   \   00000028   070058E1           CMP      R8,R7
   \   0000002C   380000BA           BLT      ??_DrawVLine_2
   \   00000030   FFA0A0E3           MOV      R10,#+255
   \   00000034   039006E2           AND      R9,R6,#0x3
   \   00000038   864086E0           ADD      R4,R6,R6, LSL #+1
   \   0000003C   FFAC8AE3           ORR      R10,R10,#0xFF00
    340              for (; y0 <= y1; y0++) {
    341                _XorPixel(pDevice, x, y0);
   \                     ??_DrawVLine_3:
   \   00000040   080095E5           LDR      R0,[R5, #+8]
   \   00000044   030059E3           CMP      R9,#+3
   \   00000048   141090E5           LDR      R1,[R0, #+20]
   \   0000004C   002090E5           LDR      R2,[R0, #+0]
   \   00000050   970101E0           MUL      R1,R7,R1
   \   00000054   811081E0           ADD      R1,R1,R1, LSL #+1
   \   00000058   011084E0           ADD      R1,R4,R1
   \   0000005C   2111A0E1           LSR      R1,R1,#+2
   \   00000060   010192E7           LDR      R0,[R2, +R1, LSL #+2]
   \   00000064   09F18F90           ADDLS    PC,PC,R9, LSL #+2
   \                     ??_DrawVLine_0:
   \   00000068   1000008A           BHI      ??_DrawVLine_4
   \   0000006C   0D0000EA           B        ??_DrawVLine_5
   \   00000070   060000EA           B        ??_DrawVLine_6
   \   00000074   000000EA           B        ??_DrawVLine_7
   \   00000078   0B0000EA           B        ??_DrawVLine_8
   \                     ??_DrawVLine_7:
   \   0000007C   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000080   0410D1E5           LDRB     R1,[R1, #+4]
   \   00000084   0118A0E1           LSL      R1,R1,#+16
   \   00000088   20B881E1           ORR      R11,R1,R0, LSR #+16
   \   0000008C   070000EA           B        ??_DrawVLine_4
   \                     ??_DrawVLine_6:
   \   00000090   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000094   041091E5           LDR      R1,[R1, #+4]
   \   00000098   01100AE0           AND      R1,R10,R1
   \   0000009C   0114A0E1           LSL      R1,R1,#+8
   \   000000A0   20BC81E1           ORR      R11,R1,R0, LSR #+24
   \   000000A4   010000EA           B        ??_DrawVLine_4
   \                     ??_DrawVLine_5:
   \   000000A8   0004A0E1           LSL      R0,R0,#+8
   \                     ??_DrawVLine_8:
   \   000000AC   20B4A0E1           LSR      R11,R0,#+8
   \                     ??_DrawVLine_4:
   \   000000B0   100095E5           LDR      R0,[R5, #+16]
   \   000000B4   080090E5           LDR      R0,[R0, #+8]
   \   000000B8   30FF2FE1           BLX      R0
   \   000000BC   0B3020E0           EOR      R3,R0,R11
   \   000000C0   0720A0E1           MOV      R2,R7
   \   000000C4   0610A0E1           MOV      R1,R6
   \   000000C8   0500A0E1           MOV      R0,R5
   \   000000CC   ........           BL       _SetPixelIndex
    342              }
   \   000000D0   017087E2           ADD      R7,R7,#+1
   \   000000D4   070058E1           CMP      R8,R7
   \   000000D8   D8FFFFAA           BGE      ??_DrawVLine_3
   \   000000DC   0C0000EA           B        ??_DrawVLine_2
    343            } else {
    344              ColorIndex = LCD__GetColorIndex();
   \                     ??_DrawVLine_1:
   \   000000E0   ........           LDR      R0,??DataTable13
   \   000000E4   070058E1           CMP      R8,R7
   \   000000E8   000090E5           LDR      R0,[R0, #+0]
   \   000000EC   004090E5           LDR      R4,[R0, #+0]
   \   000000F0   070000BA           BLT      ??_DrawVLine_2
    345              for (; y0 <= y1; y0++) {
    346                _SetPixelIndex(pDevice, x, y0, ColorIndex);
   \                     ??_DrawVLine_9:
   \   000000F4   0430A0E1           MOV      R3,R4
   \   000000F8   0720A0E1           MOV      R2,R7
   \   000000FC   0610A0E1           MOV      R1,R6
   \   00000100   0500A0E1           MOV      R0,R5
   \   00000104   ........           BL       _SetPixelIndex
    347              }
   \   00000108   017087E2           ADD      R7,R7,#+1
   \   0000010C   070058E1           CMP      R8,R7
   \   00000110   F7FFFFAA           BGE      ??_DrawVLine_9
    348            }
    349          }
   \                     ??_DrawVLine_2:
   \   00000114   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000118   F08FBDE8           POP      {R4-R11,PC}      ;; return
    350          
    351          /*********************************************************************
    352          *
    353          *       _FillRect
    354          */

   \                                 In section .text, align 4, keep-with-next
    355          static void _FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   18809DE5           LDR      R8,[SP, #+24]
   \   00000008   0260A0E1           MOV      R6,R2
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0370A0E1           MOV      R7,R3
   \   00000018   060058E1           CMP      R8,R6
   \   0000001C   070000BA           BLT      ??_FillRect_0
    356            #ifdef LCD_FILL_RECT
    357               LCD_FILL_RECT(x0, y0, x1, y1, LCD__GetColorIndex());
    358            #else
    359              for (; y0 <= y1; y0++) {
    360                _DrawHLine(pDevice, x0, y0, x1);
   \                     ??_FillRect_1:
   \   00000020   0730A0E1           MOV      R3,R7
   \   00000024   0620A0E1           MOV      R2,R6
   \   00000028   0510A0E1           MOV      R1,R5
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       _DrawHLine
    361              }
   \   00000034   016086E2           ADD      R6,R6,#+1
   \   00000038   060058E1           CMP      R8,R6
   \   0000003C   F7FFFFAA           BGE      ??_FillRect_1
    362            #endif
    363          }
   \                     ??_FillRect_0:
   \   00000040   F081BDE8           POP      {R4-R8,PC}       ;; return
    364          
    365          /*********************************************************************
    366          *
    367          *       Draw Bitmap 1 BPP
    368          */

   \                                 In section .text, align 4, keep-with-next
    369          static void _DrawBitLine1BPP(GUI_DEVICE * pDevice, unsigned x, unsigned y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine1BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0370A0E1           MOV      R7,R3
    370            #define GET_PIXEL_INDEX(Index) {               \
    371              Index = ((Pixels & 1) ? Index1 : Index0);    \
    372              PixelCnt--;                                  \
    373              Pixels >>= 1;                                \
    374              if (PixelCnt == 0) {                         \
    375                Pixels |= LCD_aMirror[*(++p)] << PixelCnt; \
    376                PixelCnt += 8;                             \
    377              }                                            \
    378            }
    379            #define GET_PIXEL_INDEX_TRANS(Index, Bit) {    \
    380              Bit = Pixels & 1;                            \
    381              GET_PIXEL_INDEX(Index);                      \
    382            }
    383            DRIVER_CONTEXT * pContext;
    384            LCD_PIXELINDEX Index0, Index1;
    385            LCD_PIXELINDEX IndexMask;
    386            U32 Off, Data, Data0, Data1, Data2, Index;
    387            unsigned Pixels, PixelCnt, Odd, Bit;
    388          
    389            //U32 Data, Data0, Data1, Data2, Index;
    390            //unsigned Pixels, PixelCnt, Off, Odd, Bit;
    391          
    392            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    393            Index0 = *(pTrans + 0);
    394            Index1 = *(pTrans + 1);
    395            x += Diff;
    396            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000008   ........           LDR      R3,??DataTable12
   \   0000000C   0CD04DE2           SUB      SP,SP,#+12
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   1030D3E5           LDRB     R3,[R3, #+16]
   \   00000018   38209DE5           LDR      R2,[SP, #+56]
   \   0000001C   01C0A0E1           MOV      R12,R1
   \   00000020   30809DE5           LDR      R8,[SP, #+48]
   \   00000024   0050A0E1           MOV      R5,R0
   \   00000028   001092E5           LDR      R1,[R2, #+0]
   \   0000002C   033003E2           AND      R3,R3,#0x3
   \   00000030   34909DE5           LDR      R9,[SP, #+52]
   \   00000034   080095E5           LDR      R0,[R5, #+8]
   \   00000038   042092E5           LDR      R2,[R2, #+4]
   \   0000003C   0C4088E0           ADD      R4,R8,R12
   \   00000040   030053E3           CMP      R3,#+3
   \   00000044   03F18F90           ADDLS    PC,PC,R3, LSL #+2
   \                     ??_DrawBitLine1BPP_0:
   \   00000048   1002008A           BHI      ??_DrawBitLine1BPP_2
   \   0000004C   020000EA           B        ??_DrawBitLine1BPP_3
   \   00000050   D80100EA           B        ??_DrawBitLine1BPP_4
   \   00000054   CE0000EA           B        ??_DrawBitLine1BPP_5
   \   00000058   D60100EA           B        ??_DrawBitLine1BPP_4
    397            case 0:
    398              PixelCnt = 8 - Diff;
    399              Pixels   = LCD_aMirror[*p] >> Diff;
   \                     ??_DrawBitLine1BPP_3:
   \   0000005C   00E0D7E5           LDRB     LR,[R7, #+0]
   \   00000060   ........           LDR      R3,??DataTable14
    400              Off      = XY2OFF32(pContext->vxSizePhys, x, y);
   \   00000064   145090E5           LDR      R5,[R0, #+20]
   \   00000068   03E0DEE7           LDRB     LR,[LR, +R3]
   \   0000006C   08C068E2           RSB      R12,R8,#+8
   \   00000070   855085E0           ADD      R5,R5,R5, LSL #+1
   \   00000074   5EE8A0E1           ASR      LR,LR,R8
   \   00000078   848084E0           ADD      R8,R4,R4, LSL #+1
   \   0000007C   958626E0           MLA      R6,R5,R6,R8
    401              //
    402              // First triple DWORD
    403              //
    404              Odd = x & 3;
   \   00000080   038014E2           ANDS     R8,R4,#0x3
   \   00000084   2651A0E1           LSR      R5,R6,#+2
    405              if (Odd) {                    
   \   00000088   4A00000A           BEQ      ??_DrawBitLine1BPP_6
    406                Data    = READ_MEM32(pContext->VRAMAddr, Off);
   \   0000008C   004090E5           LDR      R4,[R0, #+0]
    407                switch (Odd) {
   \   00000090   010058E3           CMP      R8,#+1
   \   00000094   056194E7           LDR      R6,[R4, +R5, LSL #+2]
   \   00000098   0400000A           BEQ      ??_DrawBitLine1BPP_7
   \   0000009C   4500003A           BCC      ??_DrawBitLine1BPP_6
   \   000000A0   030058E3           CMP      R8,#+3
   \   000000A4   3200000A           BEQ      ??_DrawBitLine1BPP_8
   \   000000A8   1A00003A           BCC      ??_DrawBitLine1BPP_9
   \   000000AC   410000EA           B        ??_DrawBitLine1BPP_6
    408                case 1:
    409                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_7:
   \   000000B0   01001EE3           TST      LR,#0x1
   \   000000B4   02B0A011           MOVNE    R11,R2
   \   000000B8   01B0A001           MOVEQ    R11,R1
   \   000000BC   01C04CE2           SUB      R12,R12,#+1
   \   000000C0   AEE0A0E1           LSR      LR,LR,#+1
   \   000000C4   00005CE3           CMP      R12,#+0
   \   000000C8   0300001A           BNE      ??_DrawBitLine1BPP_10
   \   000000CC   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   000000D0   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000000D4   0EE08CE1           ORR      LR,R12,LR
   \   000000D8   08C0A0E3           MOV      R12,#+8
    410                  Data &= 0x00FFFFFF;
    411                  Data |= Index << 24;
    412                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_10:
   \   000000DC   0664A0E1           LSL      R6,R6,#+8
   \   000000E0   0B8CA0E1           LSL      R8,R11,#+24
   \   000000E4   266488E1           ORR      R6,R8,R6, LSR #+8
   \   000000E8   056184E7           STR      R6,[R4, +R5, LSL #+2]
    413                  Off++;
    414                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    415                  Data &= 0xFFFF0000;
    416                  Data |= Index >> 8;
   \   000000EC   004090E5           LDR      R4,[R0, #+0]
   \   000000F0   015085E2           ADD      R5,R5,#+1
   \   000000F4   054194E7           LDR      R4,[R4, +R5, LSL #+2]
   \   000000F8   2B64A0E1           LSR      R6,R11,#+8
   \   000000FC   2448A0E1           LSR      R4,R4,#+16
   \   00000100   046886E1           ORR      R6,R6,R4, LSL #+16
    417                  xsize--;
   \   00000104   019059E2           SUBS     R9,R9,#+1
    418                  if (!xsize) {
   \   00000108   0200001A           BNE      ??_DrawBitLine1BPP_9
    419                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_11:
   \   0000010C   004090E5           LDR      R4,[R0, #+0]
   \   00000110   056184E7           STR      R6,[R4, +R5, LSL #+2]
    420                    break;
   \   00000114   270000EA           B        ??_DrawBitLine1BPP_6
    421                  }
    422                case 2:
    423                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_9:
   \   00000118   01001EE3           TST      LR,#0x1
   \   0000011C   02B0A011           MOVNE    R11,R2
   \   00000120   01B0A001           MOVEQ    R11,R1
   \   00000124   01C04CE2           SUB      R12,R12,#+1
   \   00000128   AEE0A0E1           LSR      LR,LR,#+1
   \   0000012C   00005CE3           CMP      R12,#+0
   \   00000130   0300001A           BNE      ??_DrawBitLine1BPP_12
   \   00000134   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   00000138   03C0DCE7           LDRB     R12,[R12, +R3]
   \   0000013C   0EE08CE1           ORR      LR,R12,LR
   \   00000140   08C0A0E3           MOV      R12,#+8
    424                  Data &= 0x0000FFFF;
    425                  Data |= Index << 16;
    426                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_12:
   \   00000144   0648A0E1           LSL      R4,R6,#+16
   \   00000148   0B68A0E1           LSL      R6,R11,#+16
   \   0000014C   244886E1           ORR      R4,R6,R4, LSR #+16
   \   00000150   006090E5           LDR      R6,[R0, #+0]
    427                  Off++;
    428                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    429                  Data &= 0xFFFFFF00;
    430                  Data |= Index >> 16;
    431                  xsize--;
   \   00000154   019059E2           SUBS     R9,R9,#+1
   \   00000158   054186E7           STR      R4,[R6, +R5, LSL #+2]
   \   0000015C   004090E5           LDR      R4,[R0, #+0]
   \   00000160   015085E2           ADD      R5,R5,#+1
   \   00000164   054194E7           LDR      R4,[R4, +R5, LSL #+2]
   \   00000168   FF40C4E3           BIC      R4,R4,#0xFF
   \   0000016C   2B6884E1           ORR      R6,R4,R11, LSR #+16
    432                  if (!xsize) {
   \   00000170   E5FFFF0A           BEQ      ??_DrawBitLine1BPP_11
    433                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    434                    break;
    435                  }
    436                case 3:
    437                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_8:
   \   00000174   01001EE3           TST      LR,#0x1
   \   00000178   02B0A011           MOVNE    R11,R2
   \   0000017C   01B0A001           MOVEQ    R11,R1
   \   00000180   01C04CE2           SUB      R12,R12,#+1
   \   00000184   AEE0A0E1           LSR      LR,LR,#+1
   \   00000188   00005CE3           CMP      R12,#+0
   \   0000018C   0300001A           BNE      ??_DrawBitLine1BPP_13
   \   00000190   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   00000194   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000198   0EE08CE1           ORR      LR,R12,LR
   \   0000019C   08C0A0E3           MOV      R12,#+8
    438                  Data &= 0x000000FF;
    439                  Data |= Index << 8;
    440                  xsize--;
    441                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_13:
   \   000001A0   FF4006E2           AND      R4,R6,#0xFF
   \   000001A4   006090E5           LDR      R6,[R0, #+0]
   \   000001A8   0B4484E1           ORR      R4,R4,R11, LSL #+8
   \   000001AC   054186E7           STR      R4,[R6, +R5, LSL #+2]
   \   000001B0   019049E2           SUB      R9,R9,#+1
    442                  Off++;
   \   000001B4   015085E2           ADD      R5,R5,#+1
    443                }
    444              }
    445              //
    446              // Complete triple DWORDS
    447              //
    448              if (xsize >= 4) {
   \                     ??_DrawBitLine1BPP_6:
   \   000001B8   040059E3           CMP      R9,#+4
   \   000001BC   3C0000BA           BLT      ??_DrawBitLine1BPP_14
    449                do {
    450                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_15:
   \   000001C0   01001EE3           TST      LR,#0x1
   \   000001C4   0240A011           MOVNE    R4,R2
   \   000001C8   0140A001           MOVEQ    R4,R1
   \   000001CC   01C04CE2           SUB      R12,R12,#+1
   \   000001D0   AEE0A0E1           LSR      LR,LR,#+1
   \   000001D4   00005CE3           CMP      R12,#+0
   \   000001D8   0300001A           BNE      ??_DrawBitLine1BPP_16
   \   000001DC   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   000001E0   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000001E4   0EE08CE1           ORR      LR,R12,LR
   \   000001E8   08C0A0E3           MOV      R12,#+8
    451                  Data0  = (Index      );
    452                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_16:
   \   000001EC   01001EE3           TST      LR,#0x1
   \   000001F0   0280A011           MOVNE    R8,R2
   \   000001F4   0180A001           MOVEQ    R8,R1
   \   000001F8   01C04CE2           SUB      R12,R12,#+1
   \   000001FC   AEE0A0E1           LSR      LR,LR,#+1
   \   00000200   00005CE3           CMP      R12,#+0
   \   00000204   0300001A           BNE      ??_DrawBitLine1BPP_17
   \   00000208   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   0000020C   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000210   0EE08CE1           ORR      LR,R12,LR
   \   00000214   08C0A0E3           MOV      R12,#+8
    453                  Data0 |= (Index << 24);
   \                     ??_DrawBitLine1BPP_17:
   \   00000218   086C84E1           ORR      R6,R4,R8, LSL #+24
    454                  Data1  = (Index >>  8);
    455                  GET_PIXEL_INDEX(Index);
   \   0000021C   01001EE3           TST      LR,#0x1
   \   00000220   0240A011           MOVNE    R4,R2
   \   00000224   0140A001           MOVEQ    R4,R1
   \   00000228   01C04CE2           SUB      R12,R12,#+1
   \   0000022C   2884A0E1           LSR      R8,R8,#+8
   \   00000230   AEE0A0E1           LSR      LR,LR,#+1
   \   00000234   00005CE3           CMP      R12,#+0
   \   00000238   0300001A           BNE      ??_DrawBitLine1BPP_18
   \   0000023C   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   00000240   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000244   0EE08CE1           ORR      LR,R12,LR
   \   00000248   08C0A0E3           MOV      R12,#+8
    456                  Data1 |= (Index << 16);
    457                  Data2  = (Index >> 16);
    458                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_18:
   \   0000024C   01001EE3           TST      LR,#0x1
   \   00000250   048888E1           ORR      R8,R8,R4, LSL #+16
   \   00000254   02B0A011           MOVNE    R11,R2
   \   00000258   01B0A001           MOVEQ    R11,R1
   \   0000025C   01C04CE2           SUB      R12,R12,#+1
   \   00000260   2448A0E1           LSR      R4,R4,#+16
   \   00000264   AEE0A0E1           LSR      LR,LR,#+1
   \   00000268   00005CE3           CMP      R12,#+0
   \   0000026C   0300001A           BNE      ??_DrawBitLine1BPP_19
   \   00000270   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   00000274   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000278   0EE08CE1           ORR      LR,R12,LR
   \   0000027C   08C0A0E3           MOV      R12,#+8
    459                  Data2 |= (Index <<  8);
    460                  WRITE_MEM32(pContext->VRAMAddr, Off + 0, Data0);
   \                     ??_DrawBitLine1BPP_19:
   \   00000280   00A090E5           LDR      R10,[R0, #+0]
    461                  WRITE_MEM32(pContext->VRAMAddr, Off + 1, Data1);
    462                  WRITE_MEM32(pContext->VRAMAddr, Off + 2, Data2);
   \   00000284   0B4484E1           ORR      R4,R4,R11, LSL #+8
   \   00000288   05618AE7           STR      R6,[R10, +R5, LSL #+2]
   \   0000028C   006090E5           LDR      R6,[R0, #+0]
    463                  Off += 3;
    464                } while ((xsize -= 4) >= 4);
   \   00000290   049049E2           SUB      R9,R9,#+4
   \   00000294   056186E0           ADD      R6,R6,R5, LSL #+2
   \   00000298   048086E5           STR      R8,[R6, #+4]
   \   0000029C   006090E5           LDR      R6,[R0, #+0]
   \   000002A0   040059E3           CMP      R9,#+4
   \   000002A4   056186E0           ADD      R6,R6,R5, LSL #+2
   \   000002A8   084086E5           STR      R4,[R6, #+8]
   \   000002AC   035085E2           ADD      R5,R5,#+3
   \   000002B0   C2FFFFAA           BGE      ??_DrawBitLine1BPP_15
    465              }
    466              //
    467              // Last triple DWORD
    468              //
    469              if (xsize) {
   \                     ??_DrawBitLine1BPP_14:
   \   000002B4   000059E3           CMP      R9,#+0
   \   000002B8   7401000A           BEQ      ??_DrawBitLine1BPP_2
    470                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    471                Data &= 0xFF000000;
   \   000002BC   004090E5           LDR      R4,[R0, #+0]
    472                GET_PIXEL_INDEX(Index);
   \   000002C0   01001EE3           TST      LR,#0x1
   \   000002C4   056194E7           LDR      R6,[R4, +R5, LSL #+2]
   \   000002C8   02B0A011           MOVNE    R11,R2
   \   000002CC   01B0A001           MOVEQ    R11,R1
   \   000002D0   01C04CE2           SUB      R12,R12,#+1
   \   000002D4   FF6406E2           AND      R6,R6,#0xFF000000
   \   000002D8   AEE0A0E1           LSR      LR,LR,#+1
   \   000002DC   00005CE3           CMP      R12,#+0
   \   000002E0   0300001A           BNE      ??_DrawBitLine1BPP_20
   \   000002E4   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   000002E8   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000002EC   0EE08CE1           ORR      LR,R12,LR
   \   000002F0   08C0A0E3           MOV      R12,#+8
    473                Data |= Index;
   \                     ??_DrawBitLine1BPP_20:
   \   000002F4   06608BE1           ORR      R6,R11,R6
    474                xsize--;
   \   000002F8   019059E2           SUBS     R9,R9,#+1
    475                if (!xsize) {
   \   000002FC   0200001A           BNE      ??_DrawBitLine1BPP_21
    476                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_22:
   \   00000300   000090E5           LDR      R0,[R0, #+0]
   \   00000304   056180E7           STR      R6,[R0, +R5, LSL #+2]
    477                  return;
   \   00000308   600100EA           B        ??_DrawBitLine1BPP_2
    478                }
    479                Data &= 0x00FFFFFF;
    480                GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_21:
   \   0000030C   01001EE3           TST      LR,#0x1
   \   00000310   02B0A011           MOVNE    R11,R2
   \   00000314   01B0A001           MOVEQ    R11,R1
   \   00000318   01C05CE2           SUBS     R12,R12,#+1
   \   0000031C   01C0D705           LDRBEQ   R12,[R7, #+1]
   \   00000320   0664A0E1           LSL      R6,R6,#+8
   \   00000324   AEE0A0E1           LSR      LR,LR,#+1
   \   00000328   0330DC07           LDRBEQ   R3,[R12, +R3]
   \   0000032C   2664A0E1           LSR      R6,R6,#+8
   \   00000330   0EE08301           ORREQ    LR,R3,LR
    481                Data |= Index << 24;
    482                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000334   0B3C86E1           ORR      R3,R6,R11, LSL #+24
   \   00000338   053184E7           STR      R3,[R4, +R5, LSL #+2]
    483                Off++;
    484                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    485                Data &= 0xFFFF0000;
    486                Data |= Index >> 8;
   \   0000033C   003090E5           LDR      R3,[R0, #+0]
   \   00000340   015085E2           ADD      R5,R5,#+1
   \   00000344   05C193E7           LDR      R12,[R3, +R5, LSL #+2]
   \   00000348   2B44A0E1           LSR      R4,R11,#+8
   \   0000034C   2CC8A0E1           LSR      R12,R12,#+16
   \   00000350   0C6884E1           ORR      R6,R4,R12, LSL #+16
    487                xsize--;
    488                if (!xsize) {
   \   00000354   01C059E2           SUBS     R12,R9,#+1
   \   00000358   E8FFFF0A           BEQ      ??_DrawBitLine1BPP_22
    489                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    490                  return;
    491                }
    492                Data &= 0x0000FFFF;
   \   0000035C   06C8A0E1           LSL      R12,R6,#+16
    493                GET_PIXEL_INDEX(Index);
   \   00000360   01001EE3           TST      LR,#0x1
   \   00000364   2C68A0E1           LSR      R6,R12,#+16
   \   00000368   02B0A011           MOVNE    R11,R2
   \   0000036C   01B0A001           MOVEQ    R11,R1
    494                Data |= Index << 16;
    495                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000370   0B1886E1           ORR      R1,R6,R11, LSL #+16
   \   00000374   051183E7           STR      R1,[R3, +R5, LSL #+2]
    496                Off++;
    497                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    498                Data &= 0xFFFFFF00;
    499                Data |= Index >> 16;
    500                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_23:
   \   00000378   000090E5           LDR      R0,[R0, #+0]
   \   0000037C   015085E2           ADD      R5,R5,#+1
   \   00000380   051190E7           LDR      R1,[R0, +R5, LSL #+2]
   \   00000384   FF10C1E3           BIC      R1,R1,#0xFF
   \   00000388   2B1881E1           ORR      R1,R1,R11, LSR #+16
   \   0000038C   051180E7           STR      R1,[R0, +R5, LSL #+2]
   \   00000390   3E0100EA           B        ??_DrawBitLine1BPP_2
    501              }
    502              break;
    503            case LCD_DRAWMODE_TRANS:
    504              PixelCnt = 8 - Diff;
    505              Pixels   = LCD_aMirror[*p] >> Diff;
   \                     ??_DrawBitLine1BPP_5:
   \   00000394   00E0D7E5           LDRB     LR,[R7, #+0]
   \   00000398   ........           LDR      R3,??DataTable14
    506              Off      = XY2OFF32(pContext->vxSizePhys, x, y);
   \   0000039C   145090E5           LDR      R5,[R0, #+20]
   \   000003A0   03E0DEE7           LDRB     LR,[LR, +R3]
   \   000003A4   08C068E2           RSB      R12,R8,#+8
   \   000003A8   855085E0           ADD      R5,R5,R5, LSL #+1
   \   000003AC   5EE8A0E1           ASR      LR,LR,R8
   \   000003B0   848084E0           ADD      R8,R4,R4, LSL #+1
   \   000003B4   958626E0           MLA      R6,R5,R6,R8
    507              //
    508              // First triple DWORD
    509              //
    510              Odd = x & 3;
   \   000003B8   038014E2           ANDS     R8,R4,#0x3
   \   000003BC   2651A0E1           LSR      R5,R6,#+2
    511              if (Odd) {
   \   000003C0   5E00000A           BEQ      ??_DrawBitLine1BPP_24
    512                Data    = READ_MEM32(pContext->VRAMAddr, Off);
   \   000003C4   004090E5           LDR      R4,[R0, #+0]
    513                switch (Odd) {
   \   000003C8   010058E3           CMP      R8,#+1
   \   000003CC   056194E7           LDR      R6,[R4, +R5, LSL #+2]
   \   000003D0   0400000A           BEQ      ??_DrawBitLine1BPP_25
   \   000003D4   5900003A           BCC      ??_DrawBitLine1BPP_24
   \   000003D8   030058E3           CMP      R8,#+3
   \   000003DC   4500000A           BEQ      ??_DrawBitLine1BPP_26
   \   000003E0   2200003A           BCC      ??_DrawBitLine1BPP_27
   \   000003E4   550000EA           B        ??_DrawBitLine1BPP_24
    514                case 1:
    515                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_25:
   \   000003E8   01A01EE2           ANDS     R10,LR,#0x1
   \   000003EC   02B0A011           MOVNE    R11,R2
   \   000003F0   01B0A001           MOVEQ    R11,R1
   \   000003F4   01C04CE2           SUB      R12,R12,#+1
   \   000003F8   AEE0A0E1           LSR      LR,LR,#+1
   \   000003FC   00005CE3           CMP      R12,#+0
   \   00000400   0300001A           BNE      ??_DrawBitLine1BPP_28
   \   00000404   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   00000408   03C0DCE7           LDRB     R12,[R12, +R3]
   \   0000040C   0EE08CE1           ORR      LR,R12,LR
   \   00000410   08C0A0E3           MOV      R12,#+8
    516                  if (Bit) {
   \                     ??_DrawBitLine1BPP_28:
   \   00000414   018085E2           ADD      R8,R5,#+1
   \   00000418   019049E2           SUB      R9,R9,#+1
   \   0000041C   00005AE3           CMP      R10,#+0
   \   00000420   0E00000A           BEQ      ??_DrawBitLine1BPP_29
    517                    Data &= 0x00FFFFFF;
    518                    Data |= Index << 24;
    519                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000424   0664A0E1           LSL      R6,R6,#+8
   \   00000428   0BACA0E1           LSL      R10,R11,#+24
   \   0000042C   26648AE1           ORR      R6,R10,R6, LSR #+8
   \   00000430   056184E7           STR      R6,[R4, +R5, LSL #+2]
    520                    Off++;
    521                    Data  = READ_MEM32(pContext->VRAMAddr, Off);
    522                    Data &= 0xFFFF0000;
    523                    Data |= Index >> 8;
   \   00000434   004090E5           LDR      R4,[R0, #+0]
   \   00000438   0850A0E1           MOV      R5,R8
   \   0000043C   054194E7           LDR      R4,[R4, +R5, LSL #+2]
   \   00000440   2B64A0E1           LSR      R6,R11,#+8
   \   00000444   2448A0E1           LSR      R4,R4,#+16
   \   00000448   046886E1           ORR      R6,R6,R4, LSL #+16
    524                    xsize--;
    525                    if (!xsize) {
   \   0000044C   000059E3           CMP      R9,#+0
   \   00000450   0600001A           BNE      ??_DrawBitLine1BPP_27
    526                      WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_30:
   \   00000454   004090E5           LDR      R4,[R0, #+0]
   \   00000458   056184E7           STR      R6,[R4, +R5, LSL #+2]
    527                      break;
   \   0000045C   370000EA           B        ??_DrawBitLine1BPP_24
    528                    }
    529                  } else {
    530                    Off++;
   \                     ??_DrawBitLine1BPP_29:
   \   00000460   0850A0E1           MOV      R5,R8
    531                    xsize--;
    532                    if (!xsize) {
   \   00000464   000059E3           CMP      R9,#+0
   \   00000468   0801000A           BEQ      ??_DrawBitLine1BPP_2
    533                      break;
    534                    }
    535                    Data = READ_MEM32(pContext->VRAMAddr, Off);
   \   0000046C   056194E7           LDR      R6,[R4, +R5, LSL #+2]
    536                  }
    537                case 2:
    538                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_27:
   \   00000470   01A01EE2           ANDS     R10,LR,#0x1
   \   00000474   02B0A011           MOVNE    R11,R2
   \   00000478   01B0A001           MOVEQ    R11,R1
   \   0000047C   01C04CE2           SUB      R12,R12,#+1
   \   00000480   AEE0A0E1           LSR      LR,LR,#+1
   \   00000484   00005CE3           CMP      R12,#+0
   \   00000488   0300001A           BNE      ??_DrawBitLine1BPP_31
   \   0000048C   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   00000490   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000494   0EE08CE1           ORR      LR,R12,LR
   \   00000498   08C0A0E3           MOV      R12,#+8
    539                  if (Bit) {
   \                     ??_DrawBitLine1BPP_31:
   \   0000049C   004090E5           LDR      R4,[R0, #+0]
   \   000004A0   019049E2           SUB      R9,R9,#+1
   \   000004A4   018085E2           ADD      R8,R5,#+1
   \   000004A8   00005AE3           CMP      R10,#+0
   \   000004AC   0B00000A           BEQ      ??_DrawBitLine1BPP_32
    540                    Data &= 0x0000FFFF;
    541                    Data |= Index << 16;
    542                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000004B0   0668A0E1           LSL      R6,R6,#+16
   \   000004B4   0BA8A0E1           LSL      R10,R11,#+16
   \   000004B8   26688AE1           ORR      R6,R10,R6, LSR #+16
   \   000004BC   056184E7           STR      R6,[R4, +R5, LSL #+2]
    543                    Off++;
    544                    Data  = READ_MEM32(pContext->VRAMAddr, Off);
    545                    Data &= 0xFFFFFF00;
    546                    Data |= Index >> 16;
   \   000004C0   004090E5           LDR      R4,[R0, #+0]
   \   000004C4   0850A0E1           MOV      R5,R8
   \   000004C8   054194E7           LDR      R4,[R4, +R5, LSL #+2]
    547                    xsize--;
    548                    if (!xsize) {
   \   000004CC   000059E3           CMP      R9,#+0
   \   000004D0   FF40C4E3           BIC      R4,R4,#0xFF
   \   000004D4   2B6884E1           ORR      R6,R4,R11, LSR #+16
   \   000004D8   0600001A           BNE      ??_DrawBitLine1BPP_26
   \   000004DC   DCFFFFEA           B        ??_DrawBitLine1BPP_30
    549                      WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    550                      break;
    551                    }
    552                  } else {
    553                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_32:
   \   000004E0   056184E7           STR      R6,[R4, +R5, LSL #+2]
    554                    Off++;
   \   000004E4   0850A0E1           MOV      R5,R8
    555                    xsize--;
    556                    if (!xsize) {
   \   000004E8   000059E3           CMP      R9,#+0
   \   000004EC   E700000A           BEQ      ??_DrawBitLine1BPP_2
    557                      break;
    558                    }
    559                    Data = READ_MEM32(pContext->VRAMAddr, Off);
   \   000004F0   004090E5           LDR      R4,[R0, #+0]
   \   000004F4   056194E7           LDR      R6,[R4, +R5, LSL #+2]
    560                  }
    561                case 3:
    562                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_26:
   \   000004F8   01A01EE2           ANDS     R10,LR,#0x1
   \   000004FC   02B0A011           MOVNE    R11,R2
   \   00000500   01B0A001           MOVEQ    R11,R1
   \   00000504   01C04CE2           SUB      R12,R12,#+1
   \   00000508   AEE0A0E1           LSR      LR,LR,#+1
   \   0000050C   00005CE3           CMP      R12,#+0
   \   00000510   0300001A           BNE      ??_DrawBitLine1BPP_33
   \   00000514   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   00000518   03C0DCE7           LDRB     R12,[R12, +R3]
   \   0000051C   0EE08CE1           ORR      LR,R12,LR
   \   00000520   08C0A0E3           MOV      R12,#+8
    563                  if (Bit) {
   \                     ??_DrawBitLine1BPP_33:
   \   00000524   00005AE3           CMP      R10,#+0
    564                    Data &= 0x000000FF;
    565                    Data |= Index << 8;
   \   00000528   FF400612           ANDNE    R4,R6,#0xFF
   \   0000052C   0B648411           ORRNE    R6,R4,R11, LSL #+8
    566                  }
    567                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000530   004090E5           LDR      R4,[R0, #+0]
    568                  xsize--;
   \   00000534   019049E2           SUB      R9,R9,#+1
   \   00000538   056184E7           STR      R6,[R4, +R5, LSL #+2]
    569                  Off++;
   \   0000053C   015085E2           ADD      R5,R5,#+1
    570                }
    571              }
    572              //
    573              // Complete triple DWORDS
    574              //
    575              if (xsize >= 4) {
   \                     ??_DrawBitLine1BPP_24:
   \   00000540   040059E3           CMP      R9,#+4
   \   00000544   590000BA           BLT      ??_DrawBitLine1BPP_34
    576                do {
    577                  Data0  = READ_MEM32(pContext->VRAMAddr, Off + 0);
   \                     ??_DrawBitLine1BPP_35:
   \   00000548   006090E5           LDR      R6,[R0, #+0]
   \   0000054C   04608DE5           STR      R6,[SP, #+4]
   \   00000550   0640A0E1           MOV      R4,R6
   \   00000554   056194E7           LDR      R6,[R4, +R5, LSL #+2]
    578                  Data1  = READ_MEM32(pContext->VRAMAddr, Off + 1);
   \   00000558   054184E0           ADD      R4,R4,R5, LSL #+2
   \   0000055C   048094E5           LDR      R8,[R4, #+4]
    579                  Data2  = READ_MEM32(pContext->VRAMAddr, Off + 2);
   \   00000560   084094E5           LDR      R4,[R4, #+8]
    580                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \   00000564   01A01EE2           ANDS     R10,LR,#0x1
   \   00000568   00A08DE5           STR      R10,[SP, #+0]
   \   0000056C   02B0A011           MOVNE    R11,R2
   \   00000570   01B0A001           MOVEQ    R11,R1
   \   00000574   01A04CE2           SUB      R10,R12,#+1
   \   00000578   AEE0A0E1           LSR      LR,LR,#+1
   \   0000057C   00005AE3           CMP      R10,#+0
   \   00000580   0300001A           BNE      ??_DrawBitLine1BPP_36
   \   00000584   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   00000588   08A0A0E3           MOV      R10,#+8
   \   0000058C   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000590   0EE08CE1           ORR      LR,R12,LR
    581                  if (Bit) {
   \                     ??_DrawBitLine1BPP_36:
   \   00000594   00C09DE5           LDR      R12,[SP, #+0]
   \   00000598   00005CE3           CMP      R12,#+0
    582                    Data0 &= 0xFF000000;
    583                    Data0 |= (Index      );
   \   0000059C   FFC40612           ANDNE    R12,R6,#0xFF000000
   \   000005A0   0C608B11           ORRNE    R6,R11,R12
    584                  }
    585                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \   000005A4   01C01EE2           ANDS     R12,LR,#0x1
   \   000005A8   00C08DE5           STR      R12,[SP, #+0]
   \   000005AC   02C0A011           MOVNE    R12,R2
   \   000005B0   01C0A001           MOVEQ    R12,R1
   \   000005B4   01B04AE2           SUB      R11,R10,#+1
   \   000005B8   AEE0A0E1           LSR      LR,LR,#+1
   \   000005BC   00005BE3           CMP      R11,#+0
   \   000005C0   0300001A           BNE      ??_DrawBitLine1BPP_37
   \   000005C4   01A0F7E5           LDRB     R10,[R7, #+1]!
   \   000005C8   08B0A0E3           MOV      R11,#+8
   \   000005CC   03A0DAE7           LDRB     R10,[R10, +R3]
   \   000005D0   0EE08AE1           ORR      LR,R10,LR
    586                  if (Bit) {
   \                     ??_DrawBitLine1BPP_37:
   \   000005D4   00A09DE5           LDR      R10,[SP, #+0]
   \   000005D8   00005AE3           CMP      R10,#+0
   \   000005DC   0500000A           BEQ      ??_DrawBitLine1BPP_38
    587                    Data0 &= 0x00FFFFFF;
    588                    Data0 |= (Index << 24);
   \   000005E0   0CACA0E1           LSL      R10,R12,#+24
   \   000005E4   0664A0E1           LSL      R6,R6,#+8
    589                    Data1 &= 0xFFFF0000;
    590                    Data1 |= (Index >>  8);
   \   000005E8   2888A0E1           LSR      R8,R8,#+16
   \   000005EC   2CC4A0E1           LSR      R12,R12,#+8
   \   000005F0   26648AE1           ORR      R6,R10,R6, LSR #+8
   \   000005F4   08888CE1           ORR      R8,R12,R8, LSL #+16
    591                  }
    592                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_38:
   \   000005F8   01C01EE2           ANDS     R12,LR,#0x1
   \   000005FC   00C08DE5           STR      R12,[SP, #+0]
   \   00000600   02A0A011           MOVNE    R10,R2
   \   00000604   01A0A001           MOVEQ    R10,R1
   \   00000608   01C04BE2           SUB      R12,R11,#+1
   \   0000060C   AEE0A0E1           LSR      LR,LR,#+1
   \   00000610   00005CE3           CMP      R12,#+0
   \   00000614   0300001A           BNE      ??_DrawBitLine1BPP_39
   \   00000618   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   0000061C   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000620   0EE08CE1           ORR      LR,R12,LR
   \   00000624   08C0A0E3           MOV      R12,#+8
    593                  if (Bit) {
   \                     ??_DrawBitLine1BPP_39:
   \   00000628   00B09DE5           LDR      R11,[SP, #+0]
   \   0000062C   00005BE3           CMP      R11,#+0
   \   00000630   0400000A           BEQ      ??_DrawBitLine1BPP_40
    594                    Data1 &= 0x0000FFFF;
    595                    Data1 |= (Index << 16);
   \   00000634   0888A0E1           LSL      R8,R8,#+16
   \   00000638   0AB8A0E1           LSL      R11,R10,#+16
    596                    Data2 &= 0xFFFFFF00;
    597                    Data2 |= (Index >> 16);
   \   0000063C   FF40C4E3           BIC      R4,R4,#0xFF
   \   00000640   28888BE1           ORR      R8,R11,R8, LSR #+16
   \   00000644   2A4884E1           ORR      R4,R4,R10, LSR #+16
    598                  }
    599                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_40:
   \   00000648   01A01EE2           ANDS     R10,LR,#0x1
   \   0000064C   02B0A011           MOVNE    R11,R2
   \   00000650   01B0A001           MOVEQ    R11,R1
   \   00000654   01C04CE2           SUB      R12,R12,#+1
   \   00000658   AEE0A0E1           LSR      LR,LR,#+1
   \   0000065C   00005CE3           CMP      R12,#+0
   \   00000660   0300001A           BNE      ??_DrawBitLine1BPP_41
   \   00000664   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   00000668   03C0DCE7           LDRB     R12,[R12, +R3]
   \   0000066C   0EE08CE1           ORR      LR,R12,LR
   \   00000670   08C0A0E3           MOV      R12,#+8
    600                  if (Bit) {
   \                     ??_DrawBitLine1BPP_41:
   \   00000674   00005AE3           CMP      R10,#+0
    601                    Data2 &= 0x000000FF;
    602                    Data2 |= (Index <<  8);
    603                  }
    604                  WRITE_MEM32(pContext->VRAMAddr, Off + 0, Data0);
   \   00000678   04A09DE5           LDR      R10,[SP, #+4]
   \   0000067C   FF400412           ANDNE    R4,R4,#0xFF
   \   00000680   05618AE7           STR      R6,[R10, +R5, LSL #+2]
    605                  WRITE_MEM32(pContext->VRAMAddr, Off + 1, Data1);
   \   00000684   006090E5           LDR      R6,[R0, #+0]
   \   00000688   0B448411           ORRNE    R4,R4,R11, LSL #+8
   \   0000068C   056186E0           ADD      R6,R6,R5, LSL #+2
   \   00000690   048086E5           STR      R8,[R6, #+4]
    606                  WRITE_MEM32(pContext->VRAMAddr, Off + 2, Data2);
   \   00000694   006090E5           LDR      R6,[R0, #+0]
    607                  Off += 3;
    608                } while ((xsize -= 4) >= 4);
   \   00000698   049049E2           SUB      R9,R9,#+4
   \   0000069C   056186E0           ADD      R6,R6,R5, LSL #+2
   \   000006A0   084086E5           STR      R4,[R6, #+8]
   \   000006A4   035085E2           ADD      R5,R5,#+3
   \   000006A8   040059E3           CMP      R9,#+4
   \   000006AC   A5FFFFAA           BGE      ??_DrawBitLine1BPP_35
    609              }
    610              //
    611              // Last triple DWORD
    612              //
    613              if (xsize) {
   \                     ??_DrawBitLine1BPP_34:
   \   000006B0   000059E3           CMP      R9,#+0
   \   000006B4   7500000A           BEQ      ??_DrawBitLine1BPP_2
    614                Data  = READ_MEM32(pContext->VRAMAddr, Off);
   \   000006B8   004090E5           LDR      R4,[R0, #+0]
    615                GET_PIXEL_INDEX_TRANS(Index, Bit);
   \   000006BC   01A01EE2           ANDS     R10,LR,#0x1
   \   000006C0   02B0A011           MOVNE    R11,R2
   \   000006C4   01B0A001           MOVEQ    R11,R1
   \   000006C8   01C04CE2           SUB      R12,R12,#+1
   \   000006CC   056194E7           LDR      R6,[R4, +R5, LSL #+2]
   \   000006D0   AEE0A0E1           LSR      LR,LR,#+1
   \   000006D4   00005CE3           CMP      R12,#+0
   \   000006D8   0300001A           BNE      ??_DrawBitLine1BPP_42
   \   000006DC   01C0F7E5           LDRB     R12,[R7, #+1]!
   \   000006E0   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000006E4   0EE08CE1           ORR      LR,R12,LR
   \   000006E8   08C0A0E3           MOV      R12,#+8
    616                if (Bit) {
   \                     ??_DrawBitLine1BPP_42:
   \   000006EC   019049E2           SUB      R9,R9,#+1
   \   000006F0   00005AE3           CMP      R10,#+0
   \   000006F4   0400000A           BEQ      ??_DrawBitLine1BPP_43
    617                  Data &= 0xFF000000;
    618                  Data |= Index;
   \   000006F8   FF6406E2           AND      R6,R6,#0xFF000000
   \   000006FC   06608BE1           ORR      R6,R11,R6
    619                  xsize--;
    620                  if (!xsize) {
   \   00000700   000059E3           CMP      R9,#+0
   \   00000704   0200001A           BNE      ??_DrawBitLine1BPP_44
   \   00000708   FCFEFFEA           B        ??_DrawBitLine1BPP_22
    621                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    622                    return;
    623                  }
    624                } else {
    625                  xsize--;
    626                  if (!xsize) {
   \                     ??_DrawBitLine1BPP_43:
   \   0000070C   000059E3           CMP      R9,#+0
   \   00000710   5E00000A           BEQ      ??_DrawBitLine1BPP_2
    627                    return;
    628                  }
    629                }
    630                GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_44:
   \   00000714   01A01EE2           ANDS     R10,LR,#0x1
   \   00000718   02B0A011           MOVNE    R11,R2
   \   0000071C   01B0A001           MOVEQ    R11,R1
   \   00000720   01C05CE2           SUBS     R12,R12,#+1
   \   00000724   01C0D705           LDRBEQ   R12,[R7, #+1]
   \   00000728   AEE0A0E1           LSR      LR,LR,#+1
   \   0000072C   0330DC07           LDRBEQ   R3,[R12, +R3]
    631                if (Bit) {
   \   00000730   01C085E2           ADD      R12,R5,#+1
   \   00000734   0EE08301           ORREQ    LR,R3,LR
   \   00000738   013049E2           SUB      R3,R9,#+1
   \   0000073C   00005AE3           CMP      R10,#+0
   \   00000740   0C00000A           BEQ      ??_DrawBitLine1BPP_45
    632                  Data &= 0x00FFFFFF;
    633                  Data |= Index << 24;
    634                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000744   0664A0E1           LSL      R6,R6,#+8
   \   00000748   0B7CA0E1           LSL      R7,R11,#+24
   \   0000074C   266487E1           ORR      R6,R7,R6, LSR #+8
   \   00000750   056184E7           STR      R6,[R4, +R5, LSL #+2]
    635                  Off++;
   \   00000754   0C50A0E1           MOV      R5,R12
    636                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    637                  Data &= 0xFFFF0000;
    638                  Data |= Index >> 8;
   \   00000758   00C090E5           LDR      R12,[R0, #+0]
   \   0000075C   2B44A0E1           LSR      R4,R11,#+8
   \   00000760   05C19CE7           LDR      R12,[R12, +R5, LSL #+2]
    639                  xsize--;
    640                  if (!xsize) {
   \   00000764   000053E3           CMP      R3,#+0
   \   00000768   2CC8A0E1           LSR      R12,R12,#+16
   \   0000076C   0C6884E1           ORR      R6,R4,R12, LSL #+16
   \   00000770   0600001A           BNE      ??_DrawBitLine1BPP_46
   \   00000774   E1FEFFEA           B        ??_DrawBitLine1BPP_22
    641                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    642                    return;
    643                  }
    644                } else {
    645                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_45:
   \   00000778   056184E7           STR      R6,[R4, +R5, LSL #+2]
    646                  Off++;
   \   0000077C   0C50A0E1           MOV      R5,R12
    647                  xsize--;
    648                  if (!xsize) {
   \   00000780   000053E3           CMP      R3,#+0
   \   00000784   4100000A           BEQ      ??_DrawBitLine1BPP_2
    649                    return;
    650                  }
    651                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
   \   00000788   003090E5           LDR      R3,[R0, #+0]
   \   0000078C   056193E7           LDR      R6,[R3, +R5, LSL #+2]
    652                }
    653                GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_46:
   \   00000790   01A01EE2           ANDS     R10,LR,#0x1
   \   00000794   02B0A011           MOVNE    R11,R2
   \   00000798   01B0A001           MOVEQ    R11,R1
    654                if (Bit) {
   \   0000079C   D7FEFF0A           BEQ      ??_DrawBitLine1BPP_22
    655                  Data &= 0x0000FFFF;
    656                  Data |= Index << 16;
    657                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000007A0   0618A0E1           LSL      R1,R6,#+16
   \   000007A4   0B28A0E1           LSL      R2,R11,#+16
   \   000007A8   211882E1           ORR      R1,R2,R1, LSR #+16
   \   000007AC   002090E5           LDR      R2,[R0, #+0]
   \   000007B0   051182E7           STR      R1,[R2, +R5, LSL #+2]
    658                  Off++;
   \   000007B4   EFFEFFEA           B        ??_DrawBitLine1BPP_23
    659                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    660                  Data &= 0xFFFFFF00;
    661                  Data |= Index >> 16;
    662                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    663                } else {
    664                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    665                }
    666              }
    667              break;
    668            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    669            case LCD_DRAWMODE_XOR:
    670              IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \                     ??_DrawBitLine1BPP_4:
   \   000007B8   100095E5           LDR      R0,[R5, #+16]
   \   000007BC   080090E5           LDR      R0,[R0, #+8]
   \   000007C0   30FF2FE1           BLX      R0
   \   000007C4   00A0A0E1           MOV      R10,R0
   \   000007C8   80B0A0E3           MOV      R11,#+128
    671              do {
    672                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_47:
   \   000007CC   0000D7E5           LDRB     R0,[R7, #+0]
   \   000007D0   5B18A0E1           ASR      R1,R11,R8
   \   000007D4   000011E1           TST      R1,R0
   \   000007D8   2500000A           BEQ      ??_DrawBitLine1BPP_48
    673                  int Pixel = _GetPixelIndex(pDevice, x, y);
   \   000007DC   082095E5           LDR      R2,[R5, #+8]
   \   000007E0   030004E2           AND      R0,R4,#0x3
   \   000007E4   143092E5           LDR      R3,[R2, #+20]
   \   000007E8   002092E5           LDR      R2,[R2, #+0]
   \   000007EC   93060CE0           MUL      R12,R3,R6
   \   000007F0   030050E3           CMP      R0,#+3
   \   000007F4   8C308CE0           ADD      R3,R12,R12, LSL #+1
   \   000007F8   84C084E0           ADD      R12,R4,R4, LSL #+1
   \   000007FC   03308CE0           ADD      R3,R12,R3
   \   00000800   2331A0E1           LSR      R3,R3,#+2
   \   00000804   03C192E7           LDR      R12,[R2, +R3, LSL #+2]
   \   00000808   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_DrawBitLine1BPP_1:
   \   0000080C   1300008A           BHI      ??_DrawBitLine1BPP_49
   \   00000810   100000EA           B        ??_DrawBitLine1BPP_50
   \   00000814   080000EA           B        ??_DrawBitLine1BPP_51
   \   00000818   020000EA           B        ??_DrawBitLine1BPP_52
   \   0000081C   FFFFFFEA           B        ??_DrawBitLine1BPP_53
   \                     ??_DrawBitLine1BPP_53:
   \   00000820   2C14A0E1           LSR      R1,R12,#+8
   \   00000824   0D0000EA           B        ??_DrawBitLine1BPP_49
   \                     ??_DrawBitLine1BPP_52:
   \   00000828   030182E0           ADD      R0,R2,R3, LSL #+2
   \   0000082C   0400D0E5           LDRB     R0,[R0, #+4]
   \   00000830   0008A0E1           LSL      R0,R0,#+16
   \   00000834   2C1880E1           ORR      R1,R0,R12, LSR #+16
   \   00000838   080000EA           B        ??_DrawBitLine1BPP_49
   \                     ??_DrawBitLine1BPP_51:
   \   0000083C   030182E0           ADD      R0,R2,R3, LSL #+2
   \   00000840   B400D0E1           LDRH     R0,[R0, #+4]
   \   00000844   0008A0E1           LSL      R0,R0,#+16
   \   00000848   2008A0E1           LSR      R0,R0,#+16
   \   0000084C   0004A0E1           LSL      R0,R0,#+8
   \   00000850   2C1C80E1           ORR      R1,R0,R12, LSR #+24
   \   00000854   010000EA           B        ??_DrawBitLine1BPP_49
   \                     ??_DrawBitLine1BPP_50:
   \   00000858   0C04A0E1           LSL      R0,R12,#+8
   \   0000085C   2014A0E1           LSR      R1,R0,#+8
    674                  _SetPixelIndex(pDevice, x, y, Pixel ^ IndexMask);
   \                     ??_DrawBitLine1BPP_49:
   \   00000860   01302AE0           EOR      R3,R10,R1
   \   00000864   0620A0E1           MOV      R2,R6
   \   00000868   0410A0E1           MOV      R1,R4
   \   0000086C   0500A0E1           MOV      R0,R5
   \   00000870   ........           BL       _SetPixelIndex
    675                }
    676                x++;
    677                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_48:
   \   00000874   018088E2           ADD      R8,R8,#+1
   \   00000878   080058E3           CMP      R8,#+8
    678                  Diff = 0;
   \   0000087C   0080A003           MOVEQ    R8,#+0
    679                  p++;
   \   00000880   01708702           ADDEQ    R7,R7,#+1
   \   00000884   014084E2           ADD      R4,R4,#+1
    680                }
    681              } while (--xsize);
   \   00000888   019059E2           SUBS     R9,R9,#+1
   \   0000088C   CEFFFF1A           BNE      ??_DrawBitLine1BPP_47
   \                     ??_DrawBitLine1BPP_2:
   \   00000890   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000894   F08FBDE8           POP      {R4-R11,PC}      ;; return
    682              break;
    683            }
    684            #undef GET_PIXEL_INDEX
    685            #undef GET_PIXEL_INDEX_TRANS
    686          }
    687          
    688          /*********************************************************************
    689          *
    690          *       Draw Bitmap 2 BPP
    691          */

   \                                 In section .text, align 4, keep-with-next
    692          static void  _DrawBitLine2BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine2BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    693            LCD_PIXELINDEX Pixels, PixelIndex;
    694            int CurrentPixel, Shift, Index;
    695          
    696            Pixels = *p;
    697            CurrentPixel = Diff;
    698            x += Diff;
    699            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000008   ........           LDR      R0,??DataTable12
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   28409DE5           LDR      R4,[SP, #+40]
   \   00000018   0370A0E1           MOV      R7,R3
   \   0000001C   0260A0E1           MOV      R6,R2
   \   00000020   2C809DE5           LDR      R8,[SP, #+44]
   \   00000024   0090D7E5           LDRB     R9,[R7, #+0]
   \   00000028   01A084E0           ADD      R10,R4,R1
   \   0000002C   030010E2           ANDS     R0,R0,#0x3
   \   00000030   0200000A           BEQ      ??_DrawBitLine2BPP_0
   \   00000034   020050E2           SUBS     R0,R0,#+2
   \   00000038   2A00000A           BEQ      ??_DrawBitLine2BPP_1
   \   0000003C   540000EA           B        ??_DrawBitLine2BPP_2
    700            case 0:
    701              if (pTrans) {
   \                     ??_DrawBitLine2BPP_0:
   \   00000040   30009DE5           LDR      R0,[SP, #+48]
   \   00000044   C0B0A0E3           MOV      R11,#+192
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   1300000A           BEQ      ??_DrawBitLine2BPP_3
    702                do {
    703                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_4:
   \   00000050   030064E2           RSB      R0,R4,#+3
   \   00000054   8000A0E1           LSL      R0,R0,#+1
    704                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    705                  PixelIndex = *(pTrans + Index);
    706                  _SetPixelIndex(pDevice, x++, y, PixelIndex);
   \   00000058   0010A0E1           MOV      R1,R0
   \   0000005C   061061E2           RSB      R1,R1,#+6
   \   00000060   5B1109E0           AND      R1,R9,R11, ASR R1
   \   00000064   3100A0E1           LSR      R0,R1,R0
   \   00000068   30109DE5           LDR      R1,[SP, #+48]
   \   0000006C   0620A0E1           MOV      R2,R6
   \   00000070   003191E7           LDR      R3,[R1, +R0, LSL #+2]
   \   00000074   0A10A0E1           MOV      R1,R10
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           BL       _SetPixelIndex
    707                  if (++CurrentPixel == 4) {
   \   00000080   014084E2           ADD      R4,R4,#+1
   \   00000084   040054E3           CMP      R4,#+4
    708                    CurrentPixel = 0;
   \   00000088   0040A003           MOVEQ    R4,#+0
    709                    Pixels = *(++p);
   \   0000008C   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   00000090   01A08AE2           ADD      R10,R10,#+1
    710                  }
    711                } while (--xsize);
   \   00000094   018058E2           SUBS     R8,R8,#+1
   \   00000098   ECFFFF1A           BNE      ??_DrawBitLine2BPP_4
   \   0000009C   3C0000EA           B        ??_DrawBitLine2BPP_2
    712              } else {
    713                do {
    714                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_3:
   \   000000A0   030064E2           RSB      R0,R4,#+3
   \   000000A4   8000A0E1           LSL      R0,R0,#+1
    715                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    716                  _SetPixelIndex(pDevice, x++, y, Index);
   \   000000A8   0010A0E1           MOV      R1,R0
   \   000000AC   061061E2           RSB      R1,R1,#+6
   \   000000B0   5B1109E0           AND      R1,R9,R11, ASR R1
   \   000000B4   3130A0E1           LSR      R3,R1,R0
   \   000000B8   0620A0E1           MOV      R2,R6
   \   000000BC   0A10A0E1           MOV      R1,R10
   \   000000C0   0500A0E1           MOV      R0,R5
   \   000000C4   ........           BL       _SetPixelIndex
    717                  if (++CurrentPixel == 4) {
   \   000000C8   014084E2           ADD      R4,R4,#+1
   \   000000CC   040054E3           CMP      R4,#+4
    718                    CurrentPixel = 0;
   \   000000D0   0040A003           MOVEQ    R4,#+0
    719                    Pixels = *(++p);
   \   000000D4   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   000000D8   01A08AE2           ADD      R10,R10,#+1
    720                  }
    721                } while (--xsize);
   \   000000DC   018058E2           SUBS     R8,R8,#+1
   \   000000E0   EEFFFF1A           BNE      ??_DrawBitLine2BPP_3
   \   000000E4   2A0000EA           B        ??_DrawBitLine2BPP_2
    722              }
    723              break;
    724            case LCD_DRAWMODE_TRANS:
    725              if (pTrans) {
   \                     ??_DrawBitLine2BPP_1:
   \   000000E8   30009DE5           LDR      R0,[SP, #+48]
   \   000000EC   C0B0A0E3           MOV      R11,#+192
   \   000000F0   000050E3           CMP      R0,#+0
   \   000000F4   1400000A           BEQ      ??_DrawBitLine2BPP_5
    726                do {
    727                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_6:
   \   000000F8   030064E2           RSB      R0,R4,#+3
   \   000000FC   8000A0E1           LSL      R0,R0,#+1
    728                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000100   0010A0E1           MOV      R1,R0
   \   00000104   061061E2           RSB      R1,R1,#+6
   \   00000108   5B1109E0           AND      R1,R9,R11, ASR R1
   \   0000010C   3130B0E1           LSRS     R3,R1,R0
    729                  if (Index) {
   \   00000110   0500000A           BEQ      ??_DrawBitLine2BPP_7
    730                    PixelIndex = *(pTrans + Index);
    731                    _SetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000114   30009DE5           LDR      R0,[SP, #+48]
   \   00000118   0620A0E1           MOV      R2,R6
   \   0000011C   033190E7           LDR      R3,[R0, +R3, LSL #+2]
   \   00000120   0A10A0E1           MOV      R1,R10
   \   00000124   0500A0E1           MOV      R0,R5
   \   00000128   ........           BL       _SetPixelIndex
    732                  }
    733                  x++;
    734                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_7:
   \   0000012C   014084E2           ADD      R4,R4,#+1
   \   00000130   040054E3           CMP      R4,#+4
    735                    CurrentPixel = 0;
   \   00000134   0040A003           MOVEQ    R4,#+0
    736                    Pixels = *(++p);
   \   00000138   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   0000013C   01A08AE2           ADD      R10,R10,#+1
    737                  }
    738                } while (--xsize);
   \   00000140   018058E2           SUBS     R8,R8,#+1
   \   00000144   EBFFFF1A           BNE      ??_DrawBitLine2BPP_6
   \   00000148   110000EA           B        ??_DrawBitLine2BPP_2
    739              } else {
    740                do {
    741                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_5:
   \   0000014C   030064E2           RSB      R0,R4,#+3
   \   00000150   8000A0E1           LSL      R0,R0,#+1
    742                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000154   0010A0E1           MOV      R1,R0
   \   00000158   061061E2           RSB      R1,R1,#+6
   \   0000015C   5B1109E0           AND      R1,R9,R11, ASR R1
   \   00000160   3130B0E1           LSRS     R3,R1,R0
    743                  if (Index) {
   \   00000164   0300000A           BEQ      ??_DrawBitLine2BPP_8
    744                    _SetPixelIndex(pDevice, x, y, Index);
   \   00000168   0620A0E1           MOV      R2,R6
   \   0000016C   0A10A0E1           MOV      R1,R10
   \   00000170   0500A0E1           MOV      R0,R5
   \   00000174   ........           BL       _SetPixelIndex
    745                  }
    746                  x++;
    747                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_8:
   \   00000178   014084E2           ADD      R4,R4,#+1
   \   0000017C   040054E3           CMP      R4,#+4
    748                    CurrentPixel = 0;
   \   00000180   0040A003           MOVEQ    R4,#+0
    749                    Pixels = *(++p);
   \   00000184   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   00000188   01A08AE2           ADD      R10,R10,#+1
    750                  }
    751                } while (--xsize);
   \   0000018C   018058E2           SUBS     R8,R8,#+1
   \   00000190   EDFFFF1A           BNE      ??_DrawBitLine2BPP_5
    752              }
    753              break;
    754            }
    755          }
   \                     ??_DrawBitLine2BPP_2:
   \   00000194   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000198   F08FBDE8           POP      {R4-R11,PC}      ;; return
    756          
    757          /*********************************************************************
    758          *
    759          *       Draw Bitmap 4 BPP
    760          */

   \                                 In section .text, align 4, keep-with-next
    761          static void  _DrawBitLine4BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine4BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    762            LCD_PIXELINDEX Pixels, PixelIndex;
    763            int CurrentPixel, Shift, Index;
    764          
    765            Pixels = *p;
    766            CurrentPixel = Diff;
    767            x += Diff;
    768            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000008   ........           LDR      R0,??DataTable15
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   28409DE5           LDR      R4,[SP, #+40]
   \   00000018   0370A0E1           MOV      R7,R3
   \   0000001C   0260A0E1           MOV      R6,R2
   \   00000020   2C809DE5           LDR      R8,[SP, #+44]
   \   00000024   0090D7E5           LDRB     R9,[R7, #+0]
   \   00000028   01A084E0           ADD      R10,R4,R1
   \   0000002C   030010E2           ANDS     R0,R0,#0x3
   \   00000030   0200000A           BEQ      ??_DrawBitLine4BPP_0
   \   00000034   020050E2           SUBS     R0,R0,#+2
   \   00000038   2A00000A           BEQ      ??_DrawBitLine4BPP_1
   \   0000003C   540000EA           B        ??_DrawBitLine4BPP_2
    769            case 0:
    770              if (pTrans) {
   \                     ??_DrawBitLine4BPP_0:
   \   00000040   30009DE5           LDR      R0,[SP, #+48]
   \   00000044   F0B0A0E3           MOV      R11,#+240
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   1300000A           BEQ      ??_DrawBitLine4BPP_3
    771                do {
    772                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_4:
   \   00000050   010064E2           RSB      R0,R4,#+1
   \   00000054   0001A0E1           LSL      R0,R0,#+2
    773                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    774                  PixelIndex = *(pTrans + Index);
    775                  _SetPixelIndex(pDevice, x++, y, PixelIndex);
   \   00000058   0010A0E1           MOV      R1,R0
   \   0000005C   041061E2           RSB      R1,R1,#+4
   \   00000060   5B1109E0           AND      R1,R9,R11, ASR R1
   \   00000064   3100A0E1           LSR      R0,R1,R0
   \   00000068   30109DE5           LDR      R1,[SP, #+48]
   \   0000006C   0620A0E1           MOV      R2,R6
   \   00000070   003191E7           LDR      R3,[R1, +R0, LSL #+2]
   \   00000074   0A10A0E1           MOV      R1,R10
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           BL       _SetPixelIndex
    776                  if (++CurrentPixel == 2) {
   \   00000080   014084E2           ADD      R4,R4,#+1
   \   00000084   020054E3           CMP      R4,#+2
    777                    CurrentPixel = 0;
   \   00000088   0040A003           MOVEQ    R4,#+0
    778                    Pixels = *(++p);
   \   0000008C   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   00000090   01A08AE2           ADD      R10,R10,#+1
    779                  }
    780                } while (--xsize);
   \   00000094   018058E2           SUBS     R8,R8,#+1
   \   00000098   ECFFFF1A           BNE      ??_DrawBitLine4BPP_4
   \   0000009C   3C0000EA           B        ??_DrawBitLine4BPP_2
    781              } else {
    782                do {
    783                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_3:
   \   000000A0   010064E2           RSB      R0,R4,#+1
   \   000000A4   0001A0E1           LSL      R0,R0,#+2
    784                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    785                  _SetPixelIndex(pDevice, x++, y, Index);
   \   000000A8   0010A0E1           MOV      R1,R0
   \   000000AC   041061E2           RSB      R1,R1,#+4
   \   000000B0   5B1109E0           AND      R1,R9,R11, ASR R1
   \   000000B4   3130A0E1           LSR      R3,R1,R0
   \   000000B8   0620A0E1           MOV      R2,R6
   \   000000BC   0A10A0E1           MOV      R1,R10
   \   000000C0   0500A0E1           MOV      R0,R5
   \   000000C4   ........           BL       _SetPixelIndex
    786                  if (++CurrentPixel == 2) {
   \   000000C8   014084E2           ADD      R4,R4,#+1
   \   000000CC   020054E3           CMP      R4,#+2
    787                    CurrentPixel = 0;
   \   000000D0   0040A003           MOVEQ    R4,#+0
    788                    Pixels = *(++p);
   \   000000D4   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   000000D8   01A08AE2           ADD      R10,R10,#+1
    789                  }
    790                } while (--xsize);
   \   000000DC   018058E2           SUBS     R8,R8,#+1
   \   000000E0   EEFFFF1A           BNE      ??_DrawBitLine4BPP_3
   \   000000E4   2A0000EA           B        ??_DrawBitLine4BPP_2
    791              }
    792              break;
    793            case LCD_DRAWMODE_TRANS:
    794              if (pTrans) {
   \                     ??_DrawBitLine4BPP_1:
   \   000000E8   30009DE5           LDR      R0,[SP, #+48]
   \   000000EC   F0B0A0E3           MOV      R11,#+240
   \   000000F0   000050E3           CMP      R0,#+0
   \   000000F4   1400000A           BEQ      ??_DrawBitLine4BPP_5
    795                do {
    796                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_6:
   \   000000F8   010064E2           RSB      R0,R4,#+1
   \   000000FC   0001A0E1           LSL      R0,R0,#+2
    797                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000100   0010A0E1           MOV      R1,R0
   \   00000104   041061E2           RSB      R1,R1,#+4
   \   00000108   5B1109E0           AND      R1,R9,R11, ASR R1
   \   0000010C   3130B0E1           LSRS     R3,R1,R0
    798                  if (Index) {
   \   00000110   0500000A           BEQ      ??_DrawBitLine4BPP_7
    799                    PixelIndex = *(pTrans + Index);
    800                    _SetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000114   30009DE5           LDR      R0,[SP, #+48]
   \   00000118   0620A0E1           MOV      R2,R6
   \   0000011C   033190E7           LDR      R3,[R0, +R3, LSL #+2]
   \   00000120   0A10A0E1           MOV      R1,R10
   \   00000124   0500A0E1           MOV      R0,R5
   \   00000128   ........           BL       _SetPixelIndex
    801                  }
    802                  x++;
    803                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_7:
   \   0000012C   014084E2           ADD      R4,R4,#+1
   \   00000130   020054E3           CMP      R4,#+2
    804                    CurrentPixel = 0;
   \   00000134   0040A003           MOVEQ    R4,#+0
    805                    Pixels = *(++p);
   \   00000138   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   0000013C   01A08AE2           ADD      R10,R10,#+1
    806                  }
    807                } while (--xsize);
   \   00000140   018058E2           SUBS     R8,R8,#+1
   \   00000144   EBFFFF1A           BNE      ??_DrawBitLine4BPP_6
   \   00000148   110000EA           B        ??_DrawBitLine4BPP_2
    808              } else {
    809                do {
    810                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_5:
   \   0000014C   010064E2           RSB      R0,R4,#+1
   \   00000150   0001A0E1           LSL      R0,R0,#+2
    811                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000154   0010A0E1           MOV      R1,R0
   \   00000158   041061E2           RSB      R1,R1,#+4
   \   0000015C   5B1109E0           AND      R1,R9,R11, ASR R1
   \   00000160   3130B0E1           LSRS     R3,R1,R0
    812                  if (Index) {
   \   00000164   0300000A           BEQ      ??_DrawBitLine4BPP_8
    813                    _SetPixelIndex(pDevice, x, y, Index);
   \   00000168   0620A0E1           MOV      R2,R6
   \   0000016C   0A10A0E1           MOV      R1,R10
   \   00000170   0500A0E1           MOV      R0,R5
   \   00000174   ........           BL       _SetPixelIndex
    814                  }
    815                  x++;
    816                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_8:
   \   00000178   014084E2           ADD      R4,R4,#+1
   \   0000017C   020054E3           CMP      R4,#+2
    817                    CurrentPixel = 0;
   \   00000180   0040A003           MOVEQ    R4,#+0
    818                    Pixels = *(++p);
   \   00000184   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   00000188   01A08AE2           ADD      R10,R10,#+1
    819                  }
    820                } while (--xsize);
   \   0000018C   018058E2           SUBS     R8,R8,#+1
   \   00000190   EDFFFF1A           BNE      ??_DrawBitLine4BPP_5
    821              }
    822              break;
    823            }
    824          }
   \                     ??_DrawBitLine4BPP_2:
   \   00000194   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000198   F08FBDE8           POP      {R4-R11,PC}      ;; return
    825          
    826          /*********************************************************************
    827          *
    828          *       Draw Bitmap 8 BPP
    829          */

   \                                 In section .text, align 4, keep-with-next
    830          static void  _DrawBitLine8BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine8BPP:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    831            LCD_PIXELINDEX Pixel;
    832          
    833            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000008   ........           LDR      R0,??DataTable15
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0170A0E1           MOV      R7,R1
   \   00000018   0250A0E1           MOV      R5,R2
   \   0000001C   0360A0E1           MOV      R6,R3
   \   00000020   20909DE5           LDR      R9,[SP, #+32]
   \   00000024   24809DE5           LDR      R8,[SP, #+36]
   \   00000028   030010E2           ANDS     R0,R0,#0x3
   \   0000002C   0200000A           BEQ      ??_DrawBitLine8BPP_0
   \   00000030   020050E2           SUBS     R0,R0,#+2
   \   00000034   3700000A           BEQ      ??_DrawBitLine8BPP_1
   \   00000038   850000EA           B        ??_DrawBitLine8BPP_2
    834            case 0:
    835              if (pTrans) {
   \                     ??_DrawBitLine8BPP_0:
   \   0000003C   000058E3           CMP      R8,#+0
   \   00000040   1B00000A           BEQ      ??_DrawBitLine8BPP_3
   \   00000044   010059E3           CMP      R9,#+1
   \   00000048   810000BA           BLT      ??_DrawBitLine8BPP_2
   \   0000004C   010019E3           TST      R9,#0x1
   \   00000050   0400000A           BEQ      ??_DrawBitLine8BPP_4
    836                for (; xsize > 0; xsize--, x++, p++) {
    837                  Pixel = *p;
    838                  _SetPixelIndex(pDevice, x, y, *(pTrans + Pixel));
   \   00000054   0100D6E4           LDRB     R0,[R6], #+1
   \   00000058   003198E7           LDR      R3,[R8, +R0, LSL #+2]
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           BL       _SetPixelIndex
   \   00000064   017087E2           ADD      R7,R7,#+1
   \                     ??_DrawBitLine8BPP_4:
   \   00000068   A990B0E1           LSRS     R9,R9,#+1
   \   0000006C   7800000A           BEQ      ??_DrawBitLine8BPP_2
   \                     ??_DrawBitLine8BPP_5:
   \   00000070   0100D6E4           LDRB     R0,[R6], #+1
   \   00000074   0520A0E1           MOV      R2,R5
   \   00000078   0710A0E1           MOV      R1,R7
   \   0000007C   003198E7           LDR      R3,[R8, +R0, LSL #+2]
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   ........           BL       _SetPixelIndex
   \   00000088   0100D6E4           LDRB     R0,[R6], #+1
   \   0000008C   017087E2           ADD      R7,R7,#+1
   \   00000090   0520A0E1           MOV      R2,R5
   \   00000094   003198E7           LDR      R3,[R8, +R0, LSL #+2]
   \   00000098   0710A0E1           MOV      R1,R7
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   ........           BL       _SetPixelIndex
    839                }
   \   000000A4   017087E2           ADD      R7,R7,#+1
   \   000000A8   019059E2           SUBS     R9,R9,#+1
   \   000000AC   EFFFFF1A           BNE      ??_DrawBitLine8BPP_5
   \   000000B0   670000EA           B        ??_DrawBitLine8BPP_2
    840              } else {
   \                     ??_DrawBitLine8BPP_3:
   \   000000B4   010059E3           CMP      R9,#+1
   \   000000B8   650000BA           BLT      ??_DrawBitLine8BPP_2
   \   000000BC   010019E3           TST      R9,#0x1
   \   000000C0   0300000A           BEQ      ??_DrawBitLine8BPP_6
    841                for (; xsize > 0; xsize--, x++, p++) {
    842                  _SetPixelIndex(pDevice, x, y, *p);
   \   000000C4   0130D6E4           LDRB     R3,[R6], #+1
   \   000000C8   0400A0E1           MOV      R0,R4
   \   000000CC   ........           BL       _SetPixelIndex
   \   000000D0   017087E2           ADD      R7,R7,#+1
   \                     ??_DrawBitLine8BPP_6:
   \   000000D4   A980B0E1           LSRS     R8,R9,#+1
   \   000000D8   5D00000A           BEQ      ??_DrawBitLine8BPP_2
   \                     ??_DrawBitLine8BPP_7:
   \   000000DC   0130D6E4           LDRB     R3,[R6], #+1
   \   000000E0   0520A0E1           MOV      R2,R5
   \   000000E4   0710A0E1           MOV      R1,R7
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       _SetPixelIndex
   \   000000F0   017087E2           ADD      R7,R7,#+1
   \   000000F4   0130D6E4           LDRB     R3,[R6], #+1
   \   000000F8   0520A0E1           MOV      R2,R5
   \   000000FC   0710A0E1           MOV      R1,R7
   \   00000100   0400A0E1           MOV      R0,R4
   \   00000104   ........           BL       _SetPixelIndex
    843                }
   \   00000108   017087E2           ADD      R7,R7,#+1
   \   0000010C   018058E2           SUBS     R8,R8,#+1
   \   00000110   F1FFFF1A           BNE      ??_DrawBitLine8BPP_7
   \   00000114   4E0000EA           B        ??_DrawBitLine8BPP_2
    844              }
    845              break;
    846            case LCD_DRAWMODE_TRANS:
    847              if (pTrans) {
   \                     ??_DrawBitLine8BPP_1:
   \   00000118   000058E3           CMP      R8,#+0
   \   0000011C   2600000A           BEQ      ??_DrawBitLine8BPP_8
   \   00000120   010059E3           CMP      R9,#+1
   \   00000124   4A0000BA           BLT      ??_DrawBitLine8BPP_2
   \   00000128   019049E2           SUB      R9,R9,#+1
   \   0000012C   0030D6E5           LDRB     R3,[R6, #+0]
   \   00000130   010019E3           TST      R9,#0x1
   \   00000134   0600000A           BEQ      ??_DrawBitLine8BPP_9
    848                for (; xsize > 0; xsize--, x++, p++) {
    849                  Pixel = *p;
    850                  if (Pixel) {
   \   00000138   000053E3           CMP      R3,#+0
   \   0000013C   0200000A           BEQ      ??_DrawBitLine8BPP_10
    851                    _SetPixelIndex(pDevice, x, y, *(pTrans + Pixel));
   \   00000140   033198E7           LDR      R3,[R8, +R3, LSL #+2]
   \   00000144   0400A0E1           MOV      R0,R4
   \   00000148   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_10:
   \   0000014C   017087E2           ADD      R7,R7,#+1
   \   00000150   0130F6E5           LDRB     R3,[R6, #+1]!
   \                     ??_DrawBitLine8BPP_9:
   \   00000154   A990B0E1           LSRS     R9,R9,#+1
   \   00000158   1300000A           BEQ      ??_DrawBitLine8BPP_11
   \                     ??_DrawBitLine8BPP_12:
   \   0000015C   000053E3           CMP      R3,#+0
   \   00000160   0400000A           BEQ      ??_DrawBitLine8BPP_13
   \   00000164   033198E7           LDR      R3,[R8, +R3, LSL #+2]
   \   00000168   0520A0E1           MOV      R2,R5
   \   0000016C   0710A0E1           MOV      R1,R7
   \   00000170   0400A0E1           MOV      R0,R4
   \   00000174   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_13:
   \   00000178   0130F6E5           LDRB     R3,[R6, #+1]!
   \   0000017C   017087E2           ADD      R7,R7,#+1
   \   00000180   000053E3           CMP      R3,#+0
   \   00000184   0400000A           BEQ      ??_DrawBitLine8BPP_14
   \   00000188   033198E7           LDR      R3,[R8, +R3, LSL #+2]
   \   0000018C   0520A0E1           MOV      R2,R5
   \   00000190   0710A0E1           MOV      R1,R7
   \   00000194   0400A0E1           MOV      R0,R4
   \   00000198   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_14:
   \   0000019C   017087E2           ADD      R7,R7,#+1
   \   000001A0   0130F6E5           LDRB     R3,[R6, #+1]!
   \   000001A4   019059E2           SUBS     R9,R9,#+1
   \   000001A8   EBFFFF1A           BNE      ??_DrawBitLine8BPP_12
   \                     ??_DrawBitLine8BPP_11:
   \   000001AC   000053E3           CMP      R3,#+0
   \   000001B0   2700000A           BEQ      ??_DrawBitLine8BPP_2
   \   000001B4   033198E7           LDR      R3,[R8, +R3, LSL #+2]
   \   000001B8   210000EA           B        ??_DrawBitLine8BPP_15
    852                  }
    853                }
    854              } else {
   \                     ??_DrawBitLine8BPP_8:
   \   000001BC   010059E3           CMP      R9,#+1
   \   000001C0   230000BA           BLT      ??_DrawBitLine8BPP_2
   \   000001C4   018049E2           SUB      R8,R9,#+1
   \   000001C8   0030D6E5           LDRB     R3,[R6, #+0]
   \   000001CC   010018E3           TST      R8,#0x1
   \   000001D0   0500000A           BEQ      ??_DrawBitLine8BPP_16
    855                for (; xsize > 0; xsize--, x++, p++) {
    856                  Pixel = *p;
    857                  if (Pixel) {
   \   000001D4   000053E3           CMP      R3,#+0
   \   000001D8   0100000A           BEQ      ??_DrawBitLine8BPP_17
    858                    _SetPixelIndex(pDevice, x, y, Pixel);
   \   000001DC   0400A0E1           MOV      R0,R4
   \   000001E0   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_17:
   \   000001E4   017087E2           ADD      R7,R7,#+1
   \   000001E8   0130F6E5           LDRB     R3,[R6, #+1]!
   \                     ??_DrawBitLine8BPP_16:
   \   000001EC   A880B0E1           LSRS     R8,R8,#+1
   \   000001F0   1100000A           BEQ      ??_DrawBitLine8BPP_18
   \                     ??_DrawBitLine8BPP_19:
   \   000001F4   000053E3           CMP      R3,#+0
   \   000001F8   0300000A           BEQ      ??_DrawBitLine8BPP_20
   \   000001FC   0520A0E1           MOV      R2,R5
   \   00000200   0710A0E1           MOV      R1,R7
   \   00000204   0400A0E1           MOV      R0,R4
   \   00000208   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_20:
   \   0000020C   0130F6E5           LDRB     R3,[R6, #+1]!
   \   00000210   017087E2           ADD      R7,R7,#+1
   \   00000214   000053E3           CMP      R3,#+0
   \   00000218   0300000A           BEQ      ??_DrawBitLine8BPP_21
   \   0000021C   0520A0E1           MOV      R2,R5
   \   00000220   0710A0E1           MOV      R1,R7
   \   00000224   0400A0E1           MOV      R0,R4
   \   00000228   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_21:
   \   0000022C   017087E2           ADD      R7,R7,#+1
   \   00000230   0130F6E5           LDRB     R3,[R6, #+1]!
   \   00000234   018058E2           SUBS     R8,R8,#+1
   \   00000238   EDFFFF1A           BNE      ??_DrawBitLine8BPP_19
   \                     ??_DrawBitLine8BPP_18:
   \   0000023C   000053E3           CMP      R3,#+0
   \   00000240   0300000A           BEQ      ??_DrawBitLine8BPP_2
   \                     ??_DrawBitLine8BPP_15:
   \   00000244   0520A0E1           MOV      R2,R5
   \   00000248   0710A0E1           MOV      R1,R7
   \   0000024C   0400A0E1           MOV      R0,R4
   \   00000250   ........           BL       _SetPixelIndex
    859                  }
    860                }
    861              }
    862              break;
    863            }
    864          }
   \                     ??_DrawBitLine8BPP_2:
   \   00000254   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000258   F083BDE8           POP      {R4-R9,PC}       ;; return
    865          
    866          /*********************************************************************
    867          *
    868          *       Draw Bitmap 32 BPP
    869          */

   \                                 In section .text, align 4, keep-with-next
    870          static void _DrawBitLine32BPP(GUI_DEVICE * pDevice, int x, int y, U32 const GUI_UNI_PTR * p, int xsize) {
   \                     _DrawBitLine32BPP:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    871            //#define GET_PIXEL_INDEX(Index) Index = (*p++)
    872            #define GET_PIXEL_INDEX(Index) Index = (*p++) & 0xFFFFFF // Only quickfix!!!
    873            DRIVER_CONTEXT * pContext;
    874            U32 Data, Data0, Data1, Data2, Index;
    875            unsigned Off, Odd;
    876          
    877            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   10C09DE5           LDR      R12,[SP, #+16]
    878            //
    879            // First triple DWORD
    880            //
    881            Off = XY2OFF32(pContext->vxSizePhys, x, y);
   \   0000000C   14E090E5           LDR      LR,[R0, #+20]
   \   00000010   9E0202E0           MUL      R2,LR,R2
   \   00000014   81E081E0           ADD      LR,R1,R1, LSL #+1
   \   00000018   822082E0           ADD      R2,R2,R2, LSL #+1
   \   0000001C   02208EE0           ADD      R2,LR,R2
   \   00000020   2221A0E1           LSR      R2,R2,#+2
    882            Odd = x & 3;
   \   00000024   031011E2           ANDS     R1,R1,#0x3
    883            if (Odd) {
   \   00000028   3200000A           BEQ      ??_DrawBitLine32BPP_0
    884              Data    = READ_MEM32(pContext->VRAMAddr, Off);
   \   0000002C   004090E5           LDR      R4,[R0, #+0]
    885              switch (Odd) {
   \   00000030   010051E3           CMP      R1,#+1
   \   00000034   02E194E7           LDR      LR,[R4, +R2, LSL #+2]
   \   00000038   0400000A           BEQ      ??_DrawBitLine32BPP_1
   \   0000003C   2D00003A           BCC      ??_DrawBitLine32BPP_0
   \   00000040   030051E3           CMP      R1,#+3
   \   00000044   2200000A           BEQ      ??_DrawBitLine32BPP_2
   \   00000048   1200003A           BCC      ??_DrawBitLine32BPP_3
   \   0000004C   290000EA           B        ??_DrawBitLine32BPP_0
    886              case 1:
    887                GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine32BPP_1:
   \   00000050   041093E4           LDR      R1,[R3], #+4
    888                Data &= 0x00FFFFFF;
    889                Data |= Index << 24;
    890                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000054   0EE4A0E1           LSL      LR,LR,#+8
   \   00000058   0114A0E1           LSL      R1,R1,#+8
   \   0000005C   2114A0E1           LSR      R1,R1,#+8
   \   00000060   015CA0E1           LSL      R5,R1,#+24
   \   00000064   2EE485E1           ORR      LR,R5,LR, LSR #+8
   \   00000068   02E184E7           STR      LR,[R4, +R2, LSL #+2]
    891                Off++;
    892                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    893                Data &= 0xFFFF0000;
    894                Data |= Index >> 8;
   \   0000006C   00E090E5           LDR      LR,[R0, #+0]
   \   00000070   012082E2           ADD      R2,R2,#+1
   \   00000074   02E19EE7           LDR      LR,[LR, +R2, LSL #+2]
   \   00000078   2114A0E1           LSR      R1,R1,#+8
   \   0000007C   2EE8A0E1           LSR      LR,LR,#+16
   \   00000080   0EE881E1           ORR      LR,R1,LR, LSL #+16
    895                xsize--;
   \   00000084   01C05CE2           SUBS     R12,R12,#+1
    896                if (!xsize) {
   \   00000088   0200001A           BNE      ??_DrawBitLine32BPP_3
    897                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine32BPP_4:
   \   0000008C   001090E5           LDR      R1,[R0, #+0]
   \   00000090   02E181E7           STR      LR,[R1, +R2, LSL #+2]
    898                  break;
   \   00000094   170000EA           B        ??_DrawBitLine32BPP_0
    899                }
    900              case 2:
    901                GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine32BPP_3:
   \   00000098   041093E4           LDR      R1,[R3], #+4
    902                Data &= 0x0000FFFF;
    903                Data |= Index << 16;
    904                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   0000009C   0EE8A0E1           LSL      LR,LR,#+16
   \   000000A0   0114A0E1           LSL      R1,R1,#+8
   \   000000A4   2114A0E1           LSR      R1,R1,#+8
   \   000000A8   0148A0E1           LSL      R4,R1,#+16
   \   000000AC   2EE884E1           ORR      LR,R4,LR, LSR #+16
   \   000000B0   004090E5           LDR      R4,[R0, #+0]
    905                Off++;
    906                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    907                Data &= 0xFFFFFF00;
    908                Data |= Index >> 16;
    909                xsize--;
   \   000000B4   01C05CE2           SUBS     R12,R12,#+1
   \   000000B8   02E184E7           STR      LR,[R4, +R2, LSL #+2]
   \   000000BC   00E090E5           LDR      LR,[R0, #+0]
   \   000000C0   012082E2           ADD      R2,R2,#+1
   \   000000C4   02E19EE7           LDR      LR,[LR, +R2, LSL #+2]
   \   000000C8   FFE0CEE3           BIC      LR,LR,#0xFF
   \   000000CC   21E88EE1           ORR      LR,LR,R1, LSR #+16
    910                if (!xsize) {
   \   000000D0   EDFFFF0A           BEQ      ??_DrawBitLine32BPP_4
    911                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    912                  break;
    913                }
    914              case 3:
    915                GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine32BPP_2:
   \   000000D4   041093E4           LDR      R1,[R3], #+4
    916                Data &= 0x000000FF;
    917                Data |= Index << 8;
    918                xsize--;
    919                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000000D8   FFE00EE2           AND      LR,LR,#0xFF
   \   000000DC   0114A0E1           LSL      R1,R1,#+8
   \   000000E0   2114A0E1           LSR      R1,R1,#+8
   \   000000E4   01148EE1           ORR      R1,LR,R1, LSL #+8
   \   000000E8   00E090E5           LDR      LR,[R0, #+0]
   \   000000EC   01C04CE2           SUB      R12,R12,#+1
   \   000000F0   02118EE7           STR      R1,[LR, +R2, LSL #+2]
    920                Off++;
   \   000000F4   012082E2           ADD      R2,R2,#+1
    921              }
    922            }
    923            //
    924            // Complete triple DWORDS
    925            //
    926            if (xsize >= 4) {
   \                     ??_DrawBitLine32BPP_0:
   \   000000F8   04005CE3           CMP      R12,#+4
   \   000000FC   1C0000BA           BLT      ??_DrawBitLine32BPP_5
    927              do {
    928                GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine32BPP_6:
   \   00000100   041093E4           LDR      R1,[R3], #+4
    929                Data0  = (Index      );
    930                GET_PIXEL_INDEX(Index);
   \   00000104   04E093E4           LDR      LR,[R3], #+4
   \   00000108   0114A0E1           LSL      R1,R1,#+8
   \   0000010C   0EE4A0E1           LSL      LR,LR,#+8
   \   00000110   2114A0E1           LSR      R1,R1,#+8
   \   00000114   2E44A0E1           LSR      R4,LR,#+8
    931                Data0 |= (Index << 24);
   \   00000118   04EC81E1           ORR      LR,R1,R4, LSL #+24
    932                Data1  = (Index >>  8);
   \   0000011C   2414A0E1           LSR      R1,R4,#+8
    933                GET_PIXEL_INDEX(Index);
   \   00000120   044093E4           LDR      R4,[R3], #+4
    934                Data1 |= (Index << 16);
    935                Data2  = (Index >> 16);
    936                GET_PIXEL_INDEX(Index);
    937                Data2 |= (Index <<  8);
    938                WRITE_MEM32(pContext->VRAMAddr, Off + 0, Data0);
   \   00000124   006090E5           LDR      R6,[R0, #+0]
   \   00000128   0444A0E1           LSL      R4,R4,#+8
   \   0000012C   2444A0E1           LSR      R4,R4,#+8
   \   00000130   045881E1           ORR      R5,R1,R4, LSL #+16
   \   00000134   041093E4           LDR      R1,[R3], #+4
   \   00000138   02E186E7           STR      LR,[R6, +R2, LSL #+2]
    939                WRITE_MEM32(pContext->VRAMAddr, Off + 1, Data1);
   \   0000013C   00E090E5           LDR      LR,[R0, #+0]
   \   00000140   0114A0E1           LSL      R1,R1,#+8
   \   00000144   02E18EE0           ADD      LR,LR,R2, LSL #+2
   \   00000148   04508EE5           STR      R5,[LR, #+4]
    940                WRITE_MEM32(pContext->VRAMAddr, Off + 2, Data2);
   \   0000014C   00E090E5           LDR      LR,[R0, #+0]
   \   00000150   2448A0E1           LSR      R4,R4,#+16
   \   00000154   2114A0E1           LSR      R1,R1,#+8
   \   00000158   02E18EE0           ADD      LR,LR,R2, LSL #+2
   \   0000015C   011484E1           ORR      R1,R4,R1, LSL #+8
    941                Off += 3;
    942              } while ((xsize -= 4) >= 4);
   \   00000160   04C04CE2           SUB      R12,R12,#+4
   \   00000164   08108EE5           STR      R1,[LR, #+8]
   \   00000168   032082E2           ADD      R2,R2,#+3
   \   0000016C   04005CE3           CMP      R12,#+4
   \   00000170   E2FFFFAA           BGE      ??_DrawBitLine32BPP_6
    943            }
    944            //
    945            // Last triple DWORD
    946            //
    947            if (xsize) {
   \                     ??_DrawBitLine32BPP_5:
   \   00000174   00005CE3           CMP      R12,#+0
   \   00000178   2600000A           BEQ      ??_DrawBitLine32BPP_7
    948              Data  = READ_MEM32(pContext->VRAMAddr, Off);
    949              Data &= 0xFF000000;
    950              GET_PIXEL_INDEX(Index);
    951              Data |= Index;
   \   0000017C   004090E5           LDR      R4,[R0, #+0]
   \   00000180   041093E4           LDR      R1,[R3], #+4
   \   00000184   02E194E7           LDR      LR,[R4, +R2, LSL #+2]
   \   00000188   0114A0E1           LSL      R1,R1,#+8
   \   0000018C   FFE40EE2           AND      LR,LR,#0xFF000000
   \   00000190   21E48EE1           ORR      LR,LR,R1, LSR #+8
    952              xsize--;
   \   00000194   01C05CE2           SUBS     R12,R12,#+1
    953              if (!xsize) {
   \   00000198   0200001A           BNE      ??_DrawBitLine32BPP_8
    954                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine32BPP_9:
   \   0000019C   000090E5           LDR      R0,[R0, #+0]
   \   000001A0   02E180E7           STR      LR,[R0, +R2, LSL #+2]
    955                return;
   \   000001A4   7080BDE8           POP      {R4-R6,PC}
    956              }
    957              Data &= 0x00FFFFFF;
    958              GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine32BPP_8:
   \   000001A8   041093E4           LDR      R1,[R3], #+4
    959              Data |= Index << 24;
    960              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000001AC   0EE4A0E1           LSL      LR,LR,#+8
   \   000001B0   0114A0E1           LSL      R1,R1,#+8
   \   000001B4   2114A0E1           LSR      R1,R1,#+8
   \   000001B8   015CA0E1           LSL      R5,R1,#+24
   \   000001BC   2EE485E1           ORR      LR,R5,LR, LSR #+8
   \   000001C0   02E184E7           STR      LR,[R4, +R2, LSL #+2]
    961              Off++;
    962              Data  = READ_MEM32(pContext->VRAMAddr, Off);
    963              Data &= 0xFFFF0000;
    964              Data |= Index >> 8;
   \   000001C4   004090E5           LDR      R4,[R0, #+0]
   \   000001C8   012082E2           ADD      R2,R2,#+1
   \   000001CC   02E194E7           LDR      LR,[R4, +R2, LSL #+2]
   \   000001D0   2114A0E1           LSR      R1,R1,#+8
   \   000001D4   2EE8A0E1           LSR      LR,LR,#+16
   \   000001D8   0EE881E1           ORR      LR,R1,LR, LSL #+16
    965              xsize--;
    966              if (!xsize) {
   \   000001DC   01105CE2           SUBS     R1,R12,#+1
   \   000001E0   EDFFFF0A           BEQ      ??_DrawBitLine32BPP_9
    967                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    968                return;
    969              }
    970              Data &= 0x0000FFFF;
    971              GET_PIXEL_INDEX(Index);
   \   000001E4   001093E5           LDR      R1,[R3, #+0]
    972              Data |= Index << 16;
    973              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000001E8   0E38A0E1           LSL      R3,LR,#+16
   \   000001EC   0114A0E1           LSL      R1,R1,#+8
   \   000001F0   2114A0E1           LSR      R1,R1,#+8
   \   000001F4   01C8A0E1           LSL      R12,R1,#+16
   \   000001F8   23388CE1           ORR      R3,R12,R3, LSR #+16
   \   000001FC   023184E7           STR      R3,[R4, +R2, LSL #+2]
    974              Off++;
    975              Data  = READ_MEM32(pContext->VRAMAddr, Off);
    976              Data &= 0xFFFFFF00;
    977              Data |= Index >> 16;
    978              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000200   000090E5           LDR      R0,[R0, #+0]
   \   00000204   012082E2           ADD      R2,R2,#+1
   \   00000208   023190E7           LDR      R3,[R0, +R2, LSL #+2]
   \   0000020C   FF30C3E3           BIC      R3,R3,#0xFF
   \   00000210   211883E1           ORR      R1,R3,R1, LSR #+16
   \   00000214   021180E7           STR      R1,[R0, +R2, LSL #+2]
   \                     ??_DrawBitLine32BPP_7:
   \   00000218   7080BDE8           POP      {R4-R6,PC}       ;; return
    979            }
    980            #undef GET_PIXEL_INDEX
    981          }
    982          
    983          /*********************************************************************
    984          *
    985          *       _DrawBitmap
    986          */

   \                                 In section .text, align 4, keep-with-next
    987          static void _DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0,
    988                                 int xSize, int ySize,
    989                                 int BitsPerPixel, 
    990                                 int BytesPerLine,
    991                                 const U8 GUI_UNI_PTR * pData, int Diff,
    992                                 const LCD_PIXELINDEX* pTrans) {
   \                     _DrawBitmap:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   3C109DE5           LDR      R1,[SP, #+60]
   \   00000010   0040A0E1           MOV      R4,R0
    993            int i;
    994          
    995            //
    996            // Use _DrawBitLineXBPP and _DrawBitLineXBPP_Swap
    997            //
    998            switch (BitsPerPixel) {
   \   00000014   011041E2           SUB      R1,R1,#+1
   \   00000018   0360A0E1           MOV      R6,R3
   \   0000001C   38009DE5           LDR      R0,[SP, #+56]
   \   00000020   40709DE5           LDR      R7,[SP, #+64]
   \   00000024   44809DE5           LDR      R8,[SP, #+68]
   \   00000028   48909DE5           LDR      R9,[SP, #+72]
   \   0000002C   4CA09DE5           LDR      R10,[SP, #+76]
   \   00000030   1F0051E3           CMP      R1,#+31
   \   00000034   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitmap_0:
   \   00000038   EC00008A           BHI      ??_DrawBitmap_1
   \   0000003C   1E0000EA           B        ??_DrawBitmap_2
   \   00000040   4A0000EA           B        ??_DrawBitmap_3
   \   00000044   E90000EA           B        ??_DrawBitmap_1
   \   00000048   750000EA           B        ??_DrawBitmap_4
   \   0000004C   E70000EA           B        ??_DrawBitmap_1
   \   00000050   E60000EA           B        ??_DrawBitmap_1
   \   00000054   E50000EA           B        ??_DrawBitmap_1
   \   00000058   9E0000EA           B        ??_DrawBitmap_5
   \   0000005C   E30000EA           B        ??_DrawBitmap_1
   \   00000060   E20000EA           B        ??_DrawBitmap_1
   \   00000064   E10000EA           B        ??_DrawBitmap_1
   \   00000068   E00000EA           B        ??_DrawBitmap_1
   \   0000006C   DF0000EA           B        ??_DrawBitmap_1
   \   00000070   DE0000EA           B        ??_DrawBitmap_1
   \   00000074   DD0000EA           B        ??_DrawBitmap_1
   \   00000078   DC0000EA           B        ??_DrawBitmap_1
   \   0000007C   DB0000EA           B        ??_DrawBitmap_1
   \   00000080   DA0000EA           B        ??_DrawBitmap_1
   \   00000084   D90000EA           B        ??_DrawBitmap_1
   \   00000088   D80000EA           B        ??_DrawBitmap_1
   \   0000008C   D70000EA           B        ??_DrawBitmap_1
   \   00000090   D60000EA           B        ??_DrawBitmap_1
   \   00000094   D50000EA           B        ??_DrawBitmap_1
   \   00000098   D40000EA           B        ??_DrawBitmap_1
   \   0000009C   D30000EA           B        ??_DrawBitmap_1
   \   000000A0   D20000EA           B        ??_DrawBitmap_1
   \   000000A4   D10000EA           B        ??_DrawBitmap_1
   \   000000A8   D00000EA           B        ??_DrawBitmap_1
   \   000000AC   CF0000EA           B        ??_DrawBitmap_1
   \   000000B0   CE0000EA           B        ??_DrawBitmap_1
   \   000000B4   CD0000EA           B        ??_DrawBitmap_1
   \   000000B8   AB0000EA           B        ??_DrawBitmap_6
    999            case 1:
   1000              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_2:
   \   000000BC   010050E3           CMP      R0,#+1
   \   000000C0   CA0000BA           BLT      ??_DrawBitmap_1
   \   000000C4   02B0A0E1           MOV      R11,R2
   \   000000C8   10008DE5           STR      R0,[SP, #+16]
   \   000000CC   010010E3           TST      R0,#0x1
   \   000000D0   0800000A           BEQ      ??_DrawBitmap_7
   1001                _DrawBitLine1BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   000000D4   08A08DE5           STR      R10,[SP, #+8]
   \   000000D8   04608DE5           STR      R6,[SP, #+4]
   \   000000DC   00908DE5           STR      R9,[SP, #+0]
   \   000000E0   0830A0E1           MOV      R3,R8
   \   000000E4   0510A0E1           MOV      R1,R5
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       _DrawBitLine1BPP
   1002                pData += BytesPerLine;
   \   000000F0   088087E0           ADD      R8,R7,R8
   \   000000F4   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_7:
   \   000000F8   10109DE5           LDR      R1,[SP, #+16]
   \   000000FC   A110A0E1           LSR      R1,R1,#+1
   \   00000100   0C108DE5           STR      R1,[SP, #+12]
   \   00000104   000051E3           CMP      R1,#+0
   \   00000108   B800000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_8:
   \   0000010C   08A08DE5           STR      R10,[SP, #+8]
   \   00000110   04608DE5           STR      R6,[SP, #+4]
   \   00000114   00908DE5           STR      R9,[SP, #+0]
   \   00000118   0830A0E1           MOV      R3,R8
   \   0000011C   0B20A0E1           MOV      R2,R11
   \   00000120   0510A0E1           MOV      R1,R5
   \   00000124   0400A0E1           MOV      R0,R4
   \   00000128   ........           BL       _DrawBitLine1BPP
   \   0000012C   088087E0           ADD      R8,R7,R8
   \   00000130   08A08DE5           STR      R10,[SP, #+8]
   \   00000134   04608DE5           STR      R6,[SP, #+4]
   \   00000138   00908DE5           STR      R9,[SP, #+0]
   \   0000013C   0830A0E1           MOV      R3,R8
   \   00000140   01208BE2           ADD      R2,R11,#+1
   \   00000144   0510A0E1           MOV      R1,R5
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   ........           BL       _DrawBitLine1BPP
   1003              }
   \   00000150   0C109DE5           LDR      R1,[SP, #+12]
   \   00000154   088087E0           ADD      R8,R7,R8
   \   00000158   011041E2           SUB      R1,R1,#+1
   \   0000015C   0C108DE5           STR      R1,[SP, #+12]
   \   00000160   02B08BE2           ADD      R11,R11,#+2
   \   00000164   000051E3           CMP      R1,#+0
   \   00000168   E7FFFF1A           BNE      ??_DrawBitmap_8
   \   0000016C   9F0000EA           B        ??_DrawBitmap_1
   1004              break;
   1005            case 2:
   1006              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_3:
   \   00000170   010050E3           CMP      R0,#+1
   \   00000174   9D0000BA           BLT      ??_DrawBitmap_1
   \   00000178   02B0A0E1           MOV      R11,R2
   \   0000017C   10008DE5           STR      R0,[SP, #+16]
   \   00000180   010010E3           TST      R0,#0x1
   \   00000184   0800000A           BEQ      ??_DrawBitmap_9
   1007                _DrawBitLine2BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   00000188   08A08DE5           STR      R10,[SP, #+8]
   \   0000018C   04608DE5           STR      R6,[SP, #+4]
   \   00000190   00908DE5           STR      R9,[SP, #+0]
   \   00000194   0830A0E1           MOV      R3,R8
   \   00000198   0510A0E1           MOV      R1,R5
   \   0000019C   0400A0E1           MOV      R0,R4
   \   000001A0   ........           BL       _DrawBitLine2BPP
   1008                pData += BytesPerLine;
   \   000001A4   088087E0           ADD      R8,R7,R8
   \   000001A8   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_9:
   \   000001AC   10109DE5           LDR      R1,[SP, #+16]
   \   000001B0   A110A0E1           LSR      R1,R1,#+1
   \   000001B4   0C108DE5           STR      R1,[SP, #+12]
   \   000001B8   000051E3           CMP      R1,#+0
   \   000001BC   8B00000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_10:
   \   000001C0   08A08DE5           STR      R10,[SP, #+8]
   \   000001C4   04608DE5           STR      R6,[SP, #+4]
   \   000001C8   00908DE5           STR      R9,[SP, #+0]
   \   000001CC   0830A0E1           MOV      R3,R8
   \   000001D0   0B20A0E1           MOV      R2,R11
   \   000001D4   0510A0E1           MOV      R1,R5
   \   000001D8   0400A0E1           MOV      R0,R4
   \   000001DC   ........           BL       _DrawBitLine2BPP
   \   000001E0   088087E0           ADD      R8,R7,R8
   \   000001E4   08A08DE5           STR      R10,[SP, #+8]
   \   000001E8   04608DE5           STR      R6,[SP, #+4]
   \   000001EC   00908DE5           STR      R9,[SP, #+0]
   \   000001F0   0830A0E1           MOV      R3,R8
   \   000001F4   01208BE2           ADD      R2,R11,#+1
   \   000001F8   0510A0E1           MOV      R1,R5
   \   000001FC   0400A0E1           MOV      R0,R4
   \   00000200   ........           BL       _DrawBitLine2BPP
   1009              }
   \   00000204   0C109DE5           LDR      R1,[SP, #+12]
   \   00000208   088087E0           ADD      R8,R7,R8
   \   0000020C   011041E2           SUB      R1,R1,#+1
   \   00000210   0C108DE5           STR      R1,[SP, #+12]
   \   00000214   02B08BE2           ADD      R11,R11,#+2
   \   00000218   000051E3           CMP      R1,#+0
   \   0000021C   E7FFFF1A           BNE      ??_DrawBitmap_10
   \   00000220   720000EA           B        ??_DrawBitmap_1
   1010              break;
   1011            case 4:
   1012              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_4:
   \   00000224   010050E3           CMP      R0,#+1
   \   00000228   700000BA           BLT      ??_DrawBitmap_1
   \   0000022C   02B0A0E1           MOV      R11,R2
   \   00000230   10008DE5           STR      R0,[SP, #+16]
   \   00000234   010010E3           TST      R0,#0x1
   \   00000238   0800000A           BEQ      ??_DrawBitmap_11
   1013                _DrawBitLine4BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   0000023C   08A08DE5           STR      R10,[SP, #+8]
   \   00000240   04608DE5           STR      R6,[SP, #+4]
   \   00000244   00908DE5           STR      R9,[SP, #+0]
   \   00000248   0830A0E1           MOV      R3,R8
   \   0000024C   0510A0E1           MOV      R1,R5
   \   00000250   0400A0E1           MOV      R0,R4
   \   00000254   ........           BL       _DrawBitLine4BPP
   1014                pData += BytesPerLine;
   \   00000258   088087E0           ADD      R8,R7,R8
   \   0000025C   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_11:
   \   00000260   10109DE5           LDR      R1,[SP, #+16]
   \   00000264   A110A0E1           LSR      R1,R1,#+1
   \   00000268   0C108DE5           STR      R1,[SP, #+12]
   \   0000026C   000051E3           CMP      R1,#+0
   \   00000270   5E00000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_12:
   \   00000274   08A08DE5           STR      R10,[SP, #+8]
   \   00000278   04608DE5           STR      R6,[SP, #+4]
   \   0000027C   00908DE5           STR      R9,[SP, #+0]
   \   00000280   0830A0E1           MOV      R3,R8
   \   00000284   0B20A0E1           MOV      R2,R11
   \   00000288   0510A0E1           MOV      R1,R5
   \   0000028C   0400A0E1           MOV      R0,R4
   \   00000290   ........           BL       _DrawBitLine4BPP
   \   00000294   088087E0           ADD      R8,R7,R8
   \   00000298   08A08DE5           STR      R10,[SP, #+8]
   \   0000029C   04608DE5           STR      R6,[SP, #+4]
   \   000002A0   00908DE5           STR      R9,[SP, #+0]
   \   000002A4   0830A0E1           MOV      R3,R8
   \   000002A8   01208BE2           ADD      R2,R11,#+1
   \   000002AC   0510A0E1           MOV      R1,R5
   \   000002B0   0400A0E1           MOV      R0,R4
   \   000002B4   ........           BL       _DrawBitLine4BPP
   1015              }
   \   000002B8   0C109DE5           LDR      R1,[SP, #+12]
   \   000002BC   088087E0           ADD      R8,R7,R8
   \   000002C0   011041E2           SUB      R1,R1,#+1
   \   000002C4   0C108DE5           STR      R1,[SP, #+12]
   \   000002C8   02B08BE2           ADD      R11,R11,#+2
   \   000002CC   000051E3           CMP      R1,#+0
   \   000002D0   E7FFFF1A           BNE      ??_DrawBitmap_12
   \   000002D4   450000EA           B        ??_DrawBitmap_1
   1016              break;
   1017            case 8:
   1018              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_5:
   \   000002D8   010050E3           CMP      R0,#+1
   \   000002DC   430000BA           BLT      ??_DrawBitmap_1
   \   000002E0   00B0A0E1           MOV      R11,R0
   \   000002E4   0290A0E1           MOV      R9,R2
   \   000002E8   01001BE3           TST      R11,#0x1
   \   000002EC   0700000A           BEQ      ??_DrawBitmap_13
   1019                _DrawBitLine8BPP(pDevice, x0, i + y0, pData, xSize, pTrans);
   \   000002F0   04A08DE5           STR      R10,[SP, #+4]
   \   000002F4   00608DE5           STR      R6,[SP, #+0]
   \   000002F8   0830A0E1           MOV      R3,R8
   \   000002FC   0510A0E1           MOV      R1,R5
   \   00000300   0400A0E1           MOV      R0,R4
   \   00000304   ........           BL       _DrawBitLine8BPP
   1020                pData += BytesPerLine;
   \   00000308   088087E0           ADD      R8,R7,R8
   \   0000030C   019089E2           ADD      R9,R9,#+1
   \                     ??_DrawBitmap_13:
   \   00000310   ABB0B0E1           LSRS     R11,R11,#+1
   \   00000314   3500000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_14:
   \   00000318   04A08DE5           STR      R10,[SP, #+4]
   \   0000031C   00608DE5           STR      R6,[SP, #+0]
   \   00000320   0830A0E1           MOV      R3,R8
   \   00000324   0920A0E1           MOV      R2,R9
   \   00000328   0510A0E1           MOV      R1,R5
   \   0000032C   0400A0E1           MOV      R0,R4
   \   00000330   ........           BL       _DrawBitLine8BPP
   \   00000334   088087E0           ADD      R8,R7,R8
   \   00000338   04A08DE5           STR      R10,[SP, #+4]
   \   0000033C   00608DE5           STR      R6,[SP, #+0]
   \   00000340   0830A0E1           MOV      R3,R8
   \   00000344   012089E2           ADD      R2,R9,#+1
   \   00000348   0510A0E1           MOV      R1,R5
   \   0000034C   0400A0E1           MOV      R0,R4
   \   00000350   ........           BL       _DrawBitLine8BPP
   1021              }
   \   00000354   01B04BE2           SUB      R11,R11,#+1
   \   00000358   088087E0           ADD      R8,R7,R8
   \   0000035C   029089E2           ADD      R9,R9,#+2
   \   00000360   00005BE3           CMP      R11,#+0
   \   00000364   EBFFFF1A           BNE      ??_DrawBitmap_14
   \   00000368   200000EA           B        ??_DrawBitmap_1
   1022              break;
   1023            case 32:
   1024              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_6:
   \   0000036C   010050E3           CMP      R0,#+1
   \   00000370   1E0000BA           BLT      ??_DrawBitmap_1
   \   00000374   00A0A0E1           MOV      R10,R0
   \   00000378   0290A0E1           MOV      R9,R2
   \   0000037C   01001AE3           TST      R10,#0x1
   \   00000380   0600000A           BEQ      ??_DrawBitmap_15
   1025                _DrawBitLine32BPP(pDevice, x0, i + y0, (const U32 *)pData, xSize);
   \   00000384   00608DE5           STR      R6,[SP, #+0]
   \   00000388   0830A0E1           MOV      R3,R8
   \   0000038C   0510A0E1           MOV      R1,R5
   \   00000390   0400A0E1           MOV      R0,R4
   \   00000394   ........           BL       _DrawBitLine32BPP
   1026                pData += BytesPerLine;
   \   00000398   088087E0           ADD      R8,R7,R8
   \   0000039C   019089E2           ADD      R9,R9,#+1
   \                     ??_DrawBitmap_15:
   \   000003A0   AAA0B0E1           LSRS     R10,R10,#+1
   \   000003A4   1100000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_16:
   \   000003A8   00608DE5           STR      R6,[SP, #+0]
   \   000003AC   0830A0E1           MOV      R3,R8
   \   000003B0   0920A0E1           MOV      R2,R9
   \   000003B4   0510A0E1           MOV      R1,R5
   \   000003B8   0400A0E1           MOV      R0,R4
   \   000003BC   ........           BL       _DrawBitLine32BPP
   \   000003C0   088087E0           ADD      R8,R7,R8
   \   000003C4   00608DE5           STR      R6,[SP, #+0]
   \   000003C8   0830A0E1           MOV      R3,R8
   \   000003CC   012089E2           ADD      R2,R9,#+1
   \   000003D0   0510A0E1           MOV      R1,R5
   \   000003D4   0400A0E1           MOV      R0,R4
   \   000003D8   ........           BL       _DrawBitLine32BPP
   1027              }
   \   000003DC   01A04AE2           SUB      R10,R10,#+1
   \   000003E0   088087E0           ADD      R8,R7,R8
   \   000003E4   029089E2           ADD      R9,R9,#+2
   \   000003E8   00005AE3           CMP      R10,#+0
   \   000003EC   EDFFFF1A           BNE      ??_DrawBitmap_16
   1028              break;
   1029            }
   1030          }
   \                     ??_DrawBitmap_1:
   \   000003F0   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000003F4   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1031          
   1032          /*********************************************************************
   1033          *
   1034          *       _SetOrg
   1035          */

   \                                 In section .text, align 4, keep-with-next
   1036          static void _SetOrg(GUI_DEVICE * pDevice, int x, int y) {
   \                     _SetOrg:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1037            LCD_X_SETORG_INFO Data = {0};
   \   00000004   ............       ADRL     R12,`?<Constant {0}>`
   \              ....        
   \   0000000C   0CD04DE2           SUB      SP,SP,#+12
   \   00000010   00409CE5           LDR      R4,[R12, #+0]
   \   00000014   04509CE5           LDR      R5,[R12, #+4]
   \   00000018   0D30A0E1           MOV      R3,SP
   \   0000001C   300083E8           STM      R3,{R4,R5}
   1038          
   1039            #ifdef WIN32
   1040              LCDSIM_SetOrg(x, y, pDevice->LayerIndex);
   1041            #else
   1042              Data.xPos = x;
   \   00000020   00108DE5           STR      R1,[SP, #+0]
   1043              Data.yPos = y;
   \   00000024   04208DE5           STR      R2,[SP, #+4]
   1044              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETORG, (void *)&Data);
   \   00000028   0D20A0E1           MOV      R2,SP
   \   0000002C   0310A0E3           MOV      R1,#+3
   \   00000030   180090E5           LDR      R0,[R0, #+24]
   \   00000034   ........           BL       LCD_X_DisplayDriver
   1045            #endif
   1046          }
   \   00000038   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   0000003C   3080BDE8           POP      {R4,R5,PC}       ;; return
   1047          
   1048          /*********************************************************************
   1049          *
   1050          *       _InitOnce
   1051          *
   1052          * Purpose:
   1053          *   Allocates a fixed block for the context of the driver
   1054          *
   1055          * Return value:
   1056          *   0 on success, 1 on error
   1057          */
   1058          static int _InitOnce(GUI_DEVICE * pDevice) {
   1059            if (pDevice->u.pContext == NULL) {
   1060              pDevice->u.pContext = GUI_ALLOC_GetFixedBlock(sizeof(DRIVER_CONTEXT));
   1061              GUI__memset((U8 *)pDevice->u.pContext, 0, sizeof(DRIVER_CONTEXT));
   1062            }
   1063            return pDevice->u.pContext ? 0 : 1;
   1064          }
   1065          
   1066          /*********************************************************************
   1067          *
   1068          *       _GetRect
   1069          */

   \                                 In section .text, align 4, keep-with-next
   1070          static void _GetRect(GUI_DEVICE * pDevice, LCD_RECT * pRect) {
   1071            DRIVER_CONTEXT * pContext;
   1072          
   1073            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetRect:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
   1074            pRect->x0 = 0;
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   B020C1E1           STRH     R2,[R1, #+0]
   1075            pRect->y0 = 0;
   \   0000000C   B220C1E1           STRH     R2,[R1, #+2]
   1076            pRect->x1 = pContext->vxSize - 1;
   \   00000010   0C2090E5           LDR      R2,[R0, #+12]
   \   00000014   012042E2           SUB      R2,R2,#+1
   \   00000018   B420C1E1           STRH     R2,[R1, #+4]
   1077            pRect->y1 = pContext->vySize - 1;
   \   0000001C   100090E5           LDR      R0,[R0, #+16]
   \   00000020   010040E2           SUB      R0,R0,#+1
   \   00000024   B600C1E1           STRH     R0,[R1, #+6]
   1078          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
   1079          
   1080          /*********************************************************************
   1081          *
   1082          *       _GetDevProp
   1083          */

   \                                 In section .text, align 4, keep-with-next
   1084          static I32 _GetDevProp(GUI_DEVICE * pDevice, int Index) {
   1085            DRIVER_CONTEXT * pContext;
   1086          
   1087            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1088            switch (Index) {
   \                     _GetDevProp:
   \   00000000   011041E2           SUB      R1,R1,#+1
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   0D0051E3           CMP      R1,#+13
   \   0000000C   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevProp_0:
   \   00000010   1B00008A           BHI      ??_GetDevProp_1
   \   00000014   0C0000EA           B        ??_GetDevProp_2
   \   00000018   0D0000EA           B        ??_GetDevProp_3
   \   0000001C   0E0000EA           B        ??_GetDevProp_4
   \   00000020   0F0000EA           B        ??_GetDevProp_5
   \   00000024   160000EA           B        ??_GetDevProp_1
   \   00000028   150000EA           B        ??_GetDevProp_1
   \   0000002C   140000EA           B        ??_GetDevProp_1
   \   00000030   0D0000EA           B        ??_GetDevProp_6
   \   00000034   0E0000EA           B        ??_GetDevProp_7
   \   00000038   0F0000EA           B        ??_GetDevProp_8
   \   0000003C   0E0000EA           B        ??_GetDevProp_8
   \   00000040   0B0000EA           B        ??_GetDevProp_7
   \   00000044   0A0000EA           B        ??_GetDevProp_7
   \   00000048   090000EA           B        ??_GetDevProp_7
   1089            case LCD_DEVCAP_XSIZE:
   1090              return pContext->xSize;
   \                     ??_GetDevProp_2:
   \   0000004C   040090E5           LDR      R0,[R0, #+4]
   \   00000050   1EFF2FE1           BX       LR
   1091            case LCD_DEVCAP_YSIZE:
   1092              return pContext->ySize;
   \                     ??_GetDevProp_3:
   \   00000054   080090E5           LDR      R0,[R0, #+8]
   \   00000058   1EFF2FE1           BX       LR
   1093            case LCD_DEVCAP_VXSIZE:
   1094              return pContext->vxSize;
   \                     ??_GetDevProp_4:
   \   0000005C   0C0090E5           LDR      R0,[R0, #+12]
   \   00000060   1EFF2FE1           BX       LR
   1095            case LCD_DEVCAP_VYSIZE:
   1096              return pContext->vySize;
   \                     ??_GetDevProp_5:
   \   00000064   100090E5           LDR      R0,[R0, #+16]
   \   00000068   1EFF2FE1           BX       LR
   1097            case LCD_DEVCAP_BITSPERPIXEL:
   1098              return 24;
   \                     ??_GetDevProp_6:
   \   0000006C   1800A0E3           MOV      R0,#+24
   \   00000070   1EFF2FE1           BX       LR
   1099            case LCD_DEVCAP_NUMCOLORS:
   1100              return 0;
   \                     ??_GetDevProp_7:
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   1EFF2FE1           BX       LR
   1101            case LCD_DEVCAP_XMAG:
   1102              return 1;
   \                     ??_GetDevProp_8:
   \   0000007C   0100A0E3           MOV      R0,#+1
   \   00000080   1EFF2FE1           BX       LR
   1103            case LCD_DEVCAP_YMAG:
   1104              return 1;
   1105            case LCD_DEVCAP_MIRROR_X:
   1106              return 0;
   1107            case LCD_DEVCAP_MIRROR_Y:
   1108              return 0;
   1109            case LCD_DEVCAP_SWAP_XY:
   1110              return 0;
   1111            }
   1112            return -1;
   \                     ??_GetDevProp_1:
   \   00000084   0000E0E3           MVN      R0,#+0
   \   00000088   1EFF2FE1           BX       LR               ;; return
   1113          }
   1114          
   1115          /*********************************************************************
   1116          *
   1117          *       _GetDevData
   1118          */

   \                                 In section .text, align 4, keep-with-next
   1119          static void * _GetDevData(GUI_DEVICE * pDevice, int Index) {
   1120            GUI_USE_PARA(pDevice);
   1121            switch (Index) {
   \                     _GetDevData:
   \   00000000   010051E3           CMP      R1,#+1
   \   00000004   0100001A           BNE      ??_GetDevData_0
   1122            #if GUI_SUPPORT_MEMDEV
   1123              case LCD_DEVDATA_MEMDEV:
   1124                return (void *)&GUI_MEMDEV_DEVICE_32;
   \   00000008   ........           LDR      R0,??DataTable16
   \   0000000C   1EFF2FE1           BX       LR
   1125            #endif
   1126            }
   1127            return NULL;
   \                     ??_GetDevData_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
   1128          }
   1129          
   1130          /*********************************************************************
   1131          *
   1132          *       Static code: Functions available by _GetDevFunc()
   1133          *
   1134          **********************************************************************
   1135          */
   1136          /*********************************************************************
   1137          *
   1138          *       _SetVRAMAddr
   1139          */

   \                                 In section .text, align 4, keep-with-next
   1140          static void _SetVRAMAddr(GUI_DEVICE * pDevice, void * pVRAM) {
   \                     _SetVRAMAddr:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1141            DRIVER_CONTEXT * pContext;
   1142            LCD_X_SETVRAMADDR_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {(void *)0}>`
   \              ....        
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   001091E5           LDR      R1,[R1, #+0]
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
   1143          
   1144            _InitOnce(pDevice);
   \   00000020   080094E5           LDR      R0,[R4, #+8]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0500001A           BNE      ??_SetVRAMAddr_0
   \   0000002C   2C00A0E3           MOV      R0,#+44
   \   00000030   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000034   080084E5           STR      R0,[R4, #+8]
   \   00000038   2C20A0E3           MOV      R2,#+44
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   ........           BL       GUI__memset
   1145            if (pDevice->u.pContext) {
   \                     ??_SetVRAMAddr_0:
   \   00000044   080094E5           LDR      R0,[R4, #+8]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0500000A           BEQ      ??_SetVRAMAddr_1
   1146              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1147              pContext->VRAMAddr = (U32)pVRAM;
   \   00000050   005080E5           STR      R5,[R0, #+0]
   1148              Data.pVRAM = pVRAM;
   \   00000054   00508DE5           STR      R5,[SP, #+0]
   1149              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVRAMADDR, (void *)&Data);
   \   00000058   0D20A0E1           MOV      R2,SP
   \   0000005C   0210A0E3           MOV      R1,#+2
   \   00000060   180094E5           LDR      R0,[R4, #+24]
   \   00000064   ........           BL       LCD_X_DisplayDriver
   1150            }
   1151            #ifdef WIN32
   1152              SIM_Lin_SetVRAMAddr(pDevice->LayerIndex, pVRAM);
   1153            #endif
   1154          }
   \                     ??_SetVRAMAddr_1:
   \   00000068   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000006C   3080BDE8           POP      {R4,R5,PC}       ;; return
   1155          
   1156          /*********************************************************************
   1157          *
   1158          *       _SetVSize
   1159          */

   \                                 In section .text, align 4, keep-with-next
   1160          static void _SetVSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetVSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1161            DRIVER_CONTEXT * pContext;
   1162          
   1163            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetVSize_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
   1164            if (pDevice->u.pContext) {
   \                     ??_SetVSize_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   1165              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1166              pContext->vxSize = xSize;
   \   0000003C   0C508015           STRNE    R5,[R0, #+12]
   1167              pContext->vySize = ySize;
   \   00000040   10608015           STRNE    R6,[R0, #+16]
   1168              pContext->vxSizePhys = xSize;
   \   00000044   14508015           STRNE    R5,[R0, #+20]
   1169            }
   1170            #ifdef WIN32
   1171              SIM_Lin_SetVRAMSize(pDevice->LayerIndex, xSize, ySize);
   1172            #endif
   1173          }
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1174          
   1175          /*********************************************************************
   1176          *
   1177          *       _SetSize
   1178          */

   \                                 In section .text, align 4, keep-with-next
   1179          static void _SetSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1180            DRIVER_CONTEXT * pContext;
   1181            LCD_X_SETSIZE_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_1`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
   1182          
   1183            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetSize_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
   1184            if (pDevice->u.pContext) {
   \                     ??_SetSize_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0A00000A           BEQ      ??_SetSize_1
   1185              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1186              if (pContext->vxSizePhys == 0) {
   \   0000005C   141090E5           LDR      R1,[R0, #+20]
   1187                pContext->vxSizePhys = xSize;
   1188              }
   1189              pContext->xSize = xSize;
   1190              pContext->ySize = ySize;
   1191              Data.xSize = xSize;
   1192              Data.ySize = ySize;
   1193              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETSIZE, (void *)&Data);
   \   00000060   0D20A0E1           MOV      R2,SP
   \   00000064   000051E3           CMP      R1,#+0
   \   00000068   14508005           STREQ    R5,[R0, #+20]
   \   0000006C   045080E5           STR      R5,[R0, #+4]
   \   00000070   086080E5           STR      R6,[R0, #+8]
   \   00000074   00508DE5           STR      R5,[SP, #+0]
   \   00000078   04608DE5           STR      R6,[SP, #+4]
   \   0000007C   0710A0E3           MOV      R1,#+7
   \   00000080   180094E5           LDR      R0,[R4, #+24]
   \   00000084   ........           BL       LCD_X_DisplayDriver
   1194            }
   1195          }
   \                     ??_SetSize_1:
   \   00000088   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   0000008C   7080BDE8           POP      {R4-R6,PC}       ;; return
   1196          
   1197          /*********************************************************************
   1198          *
   1199          *       _SetPos
   1200          */

   \                                 In section .text, align 4, keep-with-next
   1201          static void _SetPos(GUI_DEVICE * pDevice, int xPos, int yPos) {
   \                     _SetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1202            DRIVER_CONTEXT * pContext;
   1203            LCD_X_SETPOS_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_2`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
   1204          
   1205            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetPos_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
   1206            if (pDevice->u.pContext) {
   \                     ??_SetPos_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0700000A           BEQ      ??_SetPos_1
   1207              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1208              pContext->xPos = xPos;
   \   0000005C   185080E5           STR      R5,[R0, #+24]
   1209              pContext->yPos = yPos;
   \   00000060   1C6080E5           STR      R6,[R0, #+28]
   1210              Data.xPos = xPos;
   \   00000064   00508DE5           STR      R5,[SP, #+0]
   1211              Data.yPos = yPos;
   \   00000068   04608DE5           STR      R6,[SP, #+4]
   1212              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETPOS, (void *)&Data);
   \   0000006C   0D20A0E1           MOV      R2,SP
   \   00000070   0810A0E3           MOV      R1,#+8
   \   00000074   180094E5           LDR      R0,[R4, #+24]
   \   00000078   ........           BL       LCD_X_DisplayDriver
   1213            }
   1214          }
   \                     ??_SetPos_1:
   \   0000007C   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000080   7080BDE8           POP      {R4-R6,PC}       ;; return
   1215          
   1216          /*********************************************************************
   1217          *
   1218          *       _GetPos
   1219          */

   \                                 In section .text, align 4, keep-with-next
   1220          static void _GetPos(GUI_DEVICE * pDevice, int * pxPos, int * pyPos) {
   \                     _GetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1221            DRIVER_CONTEXT * pContext;
   1222          
   1223            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_GetPos_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
   1224            if (pDevice->u.pContext) {
   \                     ??_GetPos_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0300000A           BEQ      ??_GetPos_1
   1225              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1226              *pxPos = pContext->xPos;
   \   00000040   181090E5           LDR      R1,[R0, #+24]
   \   00000044   001085E5           STR      R1,[R5, #+0]
   1227              *pyPos = pContext->yPos;
   \   00000048   1C0090E5           LDR      R0,[R0, #+28]
   \   0000004C   000086E5           STR      R0,[R6, #+0]
   1228            }
   1229          }
   \                     ??_GetPos_1:
   \   00000050   7080BDE8           POP      {R4-R6,PC}       ;; return
   1230          
   1231          /*********************************************************************
   1232          *
   1233          *       _SetAlpha
   1234          */

   \                                 In section .text, align 4, keep-with-next
   1235          static void _SetAlpha(GUI_DEVICE * pDevice, int Alpha) {
   \                     _SetAlpha:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1236            DRIVER_CONTEXT * pContext;
   1237            LCD_X_SETALPHA_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_3`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
   1238          
   1239            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetAlpha_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
   1240            if (pDevice->u.pContext) {
   \                     ??_SetAlpha_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetAlpha_1
   1241              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1242              pContext->Alpha = Alpha;
   \   0000004C   205080E5           STR      R5,[R0, #+32]
   1243              Data.Alpha = Alpha;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
   1244              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHA, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0A10A0E3           MOV      R1,#+10
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
   1245            }
   1246          }
   \                     ??_SetAlpha_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
   1247          
   1248          /*********************************************************************
   1249          *
   1250          *       _SetVis
   1251          */

   \                                 In section .text, align 4, keep-with-next
   1252          static void _SetVis(GUI_DEVICE * pDevice, int OnOff) {
   \                     _SetVis:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1253            DRIVER_CONTEXT * pContext;
   1254            LCD_X_SETVIS_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_4`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
   1255          
   1256            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetVis_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
   1257            if (pDevice->u.pContext) {
   \                     ??_SetVis_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetVis_1
   1258              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1259              pContext->IsVisible = OnOff;
   \   0000004C   245080E5           STR      R5,[R0, #+36]
   1260              Data.OnOff = OnOff;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
   1261              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVIS, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0910A0E3           MOV      R1,#+9
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
   1262            }
   1263          }
   \                     ??_SetVis_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
   1264          
   1265          /*********************************************************************
   1266          *
   1267          *       _Init
   1268          */

   \                                 In section .text, align 4, keep-with-next
   1269          static int  _Init(GUI_DEVICE * pDevice) {
   \                     _Init:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1270            int r;
   1271          
   1272            r = _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0500001A           BNE      ??_Init_0
   \   00000018   2C00A0E3           MOV      R0,#+44
   \   0000001C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000020   080084E5           STR      R0,[R4, #+8]
   \   00000024   2C20A0E3           MOV      R2,#+44
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   ........           BL       GUI__memset
   \                     ??_Init_0:
   \   00000030   080094E5           LDR      R0,[R4, #+8]
   1273            r |= LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_INITCONTROLLER, NULL);
   1274            return r;
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0150A003           MOVEQ    R5,#+1
   \   00000040   0050A013           MOVNE    R5,#+0
   \   00000044   0110A0E3           MOV      R1,#+1
   \   00000048   180094E5           LDR      R0,[R4, #+24]
   \   0000004C   ........           BL       LCD_X_DisplayDriver
   \   00000050   050080E1           ORR      R0,R0,R5
   \   00000054   04D08DE2           ADD      SP,SP,#+4
   \   00000058   3080BDE8           POP      {R4,R5,PC}       ;; return
   1275          }
   1276          
   1277          /*********************************************************************
   1278          *
   1279          *       _On
   1280          */

   \                                 In section .text, align 4, keep-with-next
   1281          static void _On (GUI_DEVICE * pDevice) {
   1282            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_ON, NULL);
   \                     _On:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0510A0E3           MOV      R1,#+5
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
   1283          }
   1284          
   1285          /*********************************************************************
   1286          *
   1287          *       _Off
   1288          */

   \                                 In section .text, align 4, keep-with-next
   1289          static void _Off (GUI_DEVICE * pDevice) {
   1290            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_OFF, NULL);
   \                     _Off:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0610A0E3           MOV      R1,#+6
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
   1291          }
   1292          
   1293          /*********************************************************************
   1294          *
   1295          *       _SetLUTEntry
   1296          */

   \                                 In section .text, align 4, keep-with-next
   1297          static void _SetLUTEntry(GUI_DEVICE * pDevice, U8 Pos, LCD_COLOR Color) {
   \                     _SetLUTEntry:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1298            LCD_X_SETLUTENTRY_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
   1299          
   1300            Data.Pos   = Pos;
   \   0000001C   0410CDE5           STRB     R1,[SP, #+4]
   1301            Data.Color = Color;
   \   00000020   00208DE5           STR      R2,[SP, #+0]
   1302            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETLUTENTRY, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0410A0E3           MOV      R1,#+4
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
   1303          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
   1304          
   1305          /*********************************************************************
   1306          *
   1307          *       _SetAlphaMode
   1308          */

   \                                 In section .text, align 4, keep-with-next
   1309          static void _SetAlphaMode(GUI_DEVICE * pDevice, int AlphaMode) {
   \                     _SetAlphaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1310            LCD_X_SETALPHAMODE_INFO Data = {0};
   1311          
   1312            Data.AlphaMode = AlphaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
   1313            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0B10A0E3           MOV      R1,#+11
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
   1314          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1315          
   1316          /*********************************************************************
   1317          *
   1318          *       _SetChromaMode
   1319          */

   \                                 In section .text, align 4, keep-with-next
   1320          static void _SetChromaMode(GUI_DEVICE * pDevice, int ChromaMode) {
   \                     _SetChromaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1321            LCD_X_SETCHROMAMODE_INFO Data = {0};
   1322          
   1323            Data.ChromaMode = ChromaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
   1324            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0C10A0E3           MOV      R1,#+12
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
   1325          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1326          
   1327          /*********************************************************************
   1328          *
   1329          *       _SetChroma
   1330          */

   \                                 In section .text, align 4, keep-with-next
   1331          static void _SetChroma(GUI_DEVICE * pDevice, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax) {
   \                     _SetChroma:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1332            LCD_X_SETCHROMA_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>_1`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
   1333          
   1334            Data.ChromaMin = ChromaMin;
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
   1335            Data.ChromaMax = ChromaMax;
   \   00000020   04208DE5           STR      R2,[SP, #+4]
   1336            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMA, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0D10A0E3           MOV      R1,#+13
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
   1337          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
   1338          
   1339          /*********************************************************************
   1340          *
   1341          *       _SetFunc
   1342          */

   \                                 In section .text, align 4, keep-with-next
   1343          static void _SetFunc(GUI_DEVICE * pDevice, int Index, void (* pFunc)(void)) {
   \                     _SetFunc:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1344            DRIVER_CONTEXT * pContext;
   1345          
   1346            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetFunc_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
   1347            if (pDevice->u.pContext) {
   \                     ??_SetFunc_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0100000A           BEQ      ??_SetFunc_1
   1348              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1349              switch (Index) {
   \   00000040   170055E3           CMP      R5,#+23
   1350              case LCD_DEVFUNC_FILLRECT:
   1351                pContext->pfFillRect = (void (*)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex))pFunc;
   \   00000044   28608005           STREQ    R6,[R0, #+40]
   1352                break;
   1353              }
   1354            }
   1355          }
   \                     ??_SetFunc_1:
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1356          
   1357          /*********************************************************************
   1358          *
   1359          *       _GetDevFunc
   1360          */

   \                                 In section .text, align 4, keep-with-next
   1361          static void (* _GetDevFunc(GUI_DEVICE ** ppDevice, int Index))(void) {
   1362            GUI_USE_PARA(ppDevice);
   1363            switch (Index) {
   \                     _GetDevFunc:
   \   00000000   021041E2           SUB      R1,R1,#+2
   \   00000004   140051E3           CMP      R1,#+20
   \   00000008   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevFunc_0:
   \   0000000C   3200008A           BHI      ??_GetDevFunc_1
   \   00000010   1D0000EA           B        ??_GetDevFunc_2
   \   00000014   180000EA           B        ??_GetDevFunc_3
   \   00000018   190000EA           B        ??_GetDevFunc_4
   \   0000001C   2E0000EA           B        ??_GetDevFunc_1
   \   00000020   1B0000EA           B        ??_GetDevFunc_5
   \   00000024   2C0000EA           B        ??_GetDevFunc_1
   \   00000028   2B0000EA           B        ??_GetDevFunc_1
   \   0000002C   0C0000EA           B        ??_GetDevFunc_6
   \   00000030   0D0000EA           B        ??_GetDevFunc_7
   \   00000034   0E0000EA           B        ??_GetDevFunc_8
   \   00000038   170000EA           B        ??_GetDevFunc_9
   \   0000003C   260000EA           B        ??_GetDevFunc_1
   \   00000040   170000EA           B        ??_GetDevFunc_10
   \   00000044   180000EA           B        ??_GetDevFunc_11
   \   00000048   190000EA           B        ??_GetDevFunc_12
   \   0000004C   220000EA           B        ??_GetDevFunc_1
   \   00000050   210000EA           B        ??_GetDevFunc_1
   \   00000054   180000EA           B        ??_GetDevFunc_13
   \   00000058   190000EA           B        ??_GetDevFunc_14
   \   0000005C   1A0000EA           B        ??_GetDevFunc_15
   \   00000060   1B0000EA           B        ??_GetDevFunc_16
   1364            case LCD_DEVFUNC_SET_VRAM_ADDR:
   1365              return (void (*)(void))_SetVRAMAddr;
   \                     ??_GetDevFunc_6:
   \   00000064   ........           LDR      R0,??DataTable16_1
   \   00000068   1EFF2FE1           BX       LR
   1366            case LCD_DEVFUNC_SET_VSIZE:
   1367              return (void (*)(void))_SetVSize;
   \                     ??_GetDevFunc_7:
   \   0000006C   ........           LDR      R0,??DataTable16_2
   \   00000070   1EFF2FE1           BX       LR
   1368            case LCD_DEVFUNC_SET_SIZE:
   1369              return (void (*)(void))_SetSize;
   \                     ??_GetDevFunc_8:
   \   00000074   ........           LDR      R0,??DataTable16_3
   \   00000078   1EFF2FE1           BX       LR
   1370            case LCD_DEVFUNC_SETPOS:
   1371              return (void (*)(void))_SetPos;
   \                     ??_GetDevFunc_3:
   \   0000007C   ........           LDR      R0,??DataTable16_4
   \   00000080   1EFF2FE1           BX       LR
   1372            case LCD_DEVFUNC_GETPOS:
   1373              return (void (*)(void))_GetPos;
   \                     ??_GetDevFunc_4:
   \   00000084   ........           LDR      R0,??DataTable16_5
   \   00000088   1EFF2FE1           BX       LR
   1374            case LCD_DEVFUNC_SETALPHA:
   1375              return (void (*)(void))_SetAlpha;
   \                     ??_GetDevFunc_2:
   \   0000008C   ........           LDR      R0,??DataTable16_6
   \   00000090   1EFF2FE1           BX       LR
   1376            case LCD_DEVFUNC_SETVIS:
   1377              return (void (*)(void))_SetVis;
   \                     ??_GetDevFunc_5:
   \   00000094   ........           LDR      R0,??DataTable16_7
   \   00000098   1EFF2FE1           BX       LR
   1378            case LCD_DEVFUNC_INIT:
   1379              return (void (*)(void))_Init;
   \                     ??_GetDevFunc_9:
   \   0000009C   ........           LDR      R0,??DataTable16_8
   \   000000A0   1EFF2FE1           BX       LR
   1380            case LCD_DEVFUNC_ON:
   1381              return (void (*)(void))_On;
   \                     ??_GetDevFunc_10:
   \   000000A4   ........           LDR      R0,??DataTable16_9
   \   000000A8   1EFF2FE1           BX       LR
   1382            case LCD_DEVFUNC_OFF:
   1383              return (void (*)(void))_Off;
   \                     ??_GetDevFunc_11:
   \   000000AC   ........           LDR      R0,??DataTable16_10
   \   000000B0   1EFF2FE1           BX       LR
   1384            case LCD_DEVFUNC_SETLUTENTRY:
   1385              return (void (*)(void))_SetLUTEntry;
   \                     ??_GetDevFunc_12:
   \   000000B4   ........           LDR      R0,??DataTable16_11
   \   000000B8   1EFF2FE1           BX       LR
   1386          
   1387            case LCD_DEVFUNC_ALPHAMODE:
   1388              return (void (*)(void))_SetAlphaMode;
   \                     ??_GetDevFunc_13:
   \   000000BC   ........           LDR      R0,??DataTable16_12
   \   000000C0   1EFF2FE1           BX       LR
   1389            case LCD_DEVFUNC_CHROMAMODE:
   1390              return (void (*)(void))_SetChromaMode;
   \                     ??_GetDevFunc_14:
   \   000000C4   ........           LDR      R0,??DataTable16_13
   \   000000C8   1EFF2FE1           BX       LR
   1391            case LCD_DEVFUNC_CHROMA:
   1392              return (void (*)(void))_SetChroma;
   \                     ??_GetDevFunc_15:
   \   000000CC   ........           LDR      R0,??DataTable16_14
   \   000000D0   1EFF2FE1           BX       LR
   1393            
   1394            case LCD_DEVFUNC_SETFUNC:
   1395              return (void (*)(void))_SetFunc;
   \                     ??_GetDevFunc_16:
   \   000000D4   ........           LDR      R0,??DataTable16_15
   \   000000D8   1EFF2FE1           BX       LR
   1396            }
   1397            return NULL;
   \                     ??_GetDevFunc_1:
   \   000000DC   0000A0E3           MOV      R0,#+0
   \   000000E0   1EFF2FE1           BX       LR               ;; return
   1398          }
   1399          
   1400          /*********************************************************************
   1401          *
   1402          *       Public data
   1403          *
   1404          **********************************************************************
   1405          */
   1406          /*********************************************************************
   1407          *
   1408          *       GUI_DEVICE_API structure
   1409          */

   \                                 In section .rodata, align 4, keep-with-next
   1410          const GUI_DEVICE_API GUIDRV_Lin_24_API = {
   \                     GUIDRV_Lin_24_API:
   \   00000000                      ; Initializer data, 52 bytes
   \   00000000   00000000....       DC32 0, _DrawBitmap, _DrawHLine, _DrawVLine, _FillRect, _GetPixelIndex, _SetPixelIndex, _XorPixel, _SetOrg, _GetDevFunc
   \              ............
   \              ............
   \              ............
   \              ............
   \              ............
   \              ........    
   \   00000028   ............       DC32 _GetDevProp, _GetDevData, _GetRect
   \              ............

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   ........           DC32     LCD_aMirror

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     GUI_MEMDEV_DEVICE_32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   ........           DC32     _SetVRAMAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   ........           DC32     _SetVSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   ........           DC32     _SetSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   ........           DC32     _SetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   ........           DC32     _GetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   ........           DC32     _SetAlpha

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   ........           DC32     _SetVis

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   ........           DC32     _Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   ........           DC32     _On

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   ........           DC32     _Off

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   ........           DC32     _SetLUTEntry

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   ........           DC32     _SetAlphaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   ........           DC32     _SetChromaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   ........           DC32     _SetChroma

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   ........           DC32     _SetFunc

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {(void *)0}>`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_2`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_3`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_4`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0
   1411            //
   1412            // Data
   1413            //
   1414            DEVICE_CLASS_DRIVER,
   1415            //
   1416            // Drawing functions
   1417            //
   1418            _DrawBitmap,
   1419            _DrawHLine,
   1420            _DrawVLine,
   1421            _FillRect,
   1422            _GetPixelIndex,
   1423            _SetPixelIndex,
   1424            _XorPixel,
   1425            //
   1426            // Set origin
   1427            //
   1428            _SetOrg,
   1429            //
   1430            // Request information
   1431            //
   1432            _GetDevFunc,
   1433            _GetDevProp,
   1434            _GetDevData,
   1435            _GetRect,
   1436          };
   1437          
   1438          #else
   1439          
   1440          void GUIDRV_Lin_24_C(void);   // Avoid empty object files
   1441          void GUIDRV_Lin_24_C(void) {}
   1442          
   1443          #endif
   1444          
   1445          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function          .cstack
     --------          -------
     _DrawBitLine1BPP      48
     _DrawBitLine2BPP      40
     _DrawBitLine32BPP     16
     _DrawBitLine4BPP      40
     _DrawBitLine8BPP      32
     _DrawBitmap           56
     _DrawHLine            32
     _DrawVLine            40
     _FillRect             24
     _GetDevData            0
     _GetDevFunc            0
     _GetDevProp            0
     _GetPixelIndex         4
     _GetPos               16
     _GetRect               0
     _Init                 16
     _Off                   8
     _On                    8
     _SetAlpha             16
     _SetAlphaMode          8
     _SetChroma            24
     _SetChromaMode         8
     _SetFunc              16
     _SetLUTEntry          24
     _SetOrg               24
     _SetPixelIndex         8
     _SetPos               24
     _SetSize              24
     _SetVRAMAddr          16
     _SetVSize             16
     _SetVis               16
     _XorPixel             24


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     _SetPixelIndex           196
     _GetPixelIndex           140
     _XorPixel                184
     _DrawHLine               664
     _DrawVLine               284
     _FillRect                 68
     _DrawBitLine1BPP        2200
     _DrawBitLine2BPP         412
     _DrawBitLine4BPP         412
     _DrawBitLine8BPP         604
     _DrawBitLine32BPP        540
     _DrawBitmap             1016
     _SetOrg                   64
     _GetRect                  44
     _GetDevProp              140
     _GetDevData               24
     _SetVRAMAddr             112
     _SetVSize                 76
     _SetSize                 144
     _SetPos                  132
     _GetPos                   84
     _SetAlpha                108
     _SetVis                  108
     _Init                     92
     _On                       16
     _Off                      16
     _SetLUTEntry              60
     _SetAlphaMode             36
     _SetChromaMode            36
     _SetChroma                60
     _SetFunc                  76
     _GetDevFunc              228
     GUIDRV_Lin_24_API         52
     ??DataTable12              4
     ??DataTable13              4
     ??DataTable14              4
     ??DataTable15              4
     ??DataTable16              4
     ??DataTable16_1            4
     ??DataTable16_2            4
     ??DataTable16_3            4
     ??DataTable16_4            4
     ??DataTable16_5            4
     ??DataTable16_6            4
     ??DataTable16_7            4
     ??DataTable16_8            4
     ??DataTable16_9            4
     ??DataTable16_10           4
     ??DataTable16_11           4
     ??DataTable16_12           4
     ??DataTable16_13           4
     ??DataTable16_14           4
     ??DataTable16_15           4
     ?<Constant {0}>            8
     ?<Constant {(void *)0}>    4
     ?<Constant {0}>_1          8
     ?<Constant {0}>_2          8
     ?<Constant {0}>_3          4
     ?<Constant {0}>_4          4
     ?<Constant {0L}>           8
     ?<Constant {0L}>_1         8

 
    52 bytes in section .rodata
 8 508 bytes in section .text
 
 8 508 bytes of CODE  memory
    52 bytes of CONST memory

Errors: none
Warnings: none
