###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:15:36 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDRV_NoOpt_1_8.c                  #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDRV_NoOpt_1_8.c -D DEBUG=1 -D    #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUIDRV_NoOpt_1_8.lst       #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUIDRV_NoOpt_1_8.o          #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDRV_NoOpt_1_8.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDRV_NoOpt_1_8.c
     19          Purpose     : Non optimized drawing functions
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include "GUIDRV_NoOpt_1_8.h"
     24          
     25          /*********************************************************************
     26          *
     27          *       Static code
     28          *
     29          **********************************************************************
     30          */
     31          /*********************************************************************
     32          *
     33          *       Draw Bitmap 1 BPP
     34          */

   \                                 In section .text, align 4, keep-with-next
     35          static void _DrawBitLine1BPP(GUI_DEVICE * pDevice, unsigned x, unsigned y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine1BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   28709DE5           LDR      R7,[SP, #+40]
   \   0000000C   0250A0E1           MOV      R5,R2
     36            LCD_PIXELINDEX IndexMask, Index0, Index1, Pixel;
     37            unsigned (* pfGetPixelIndex)(GUI_DEVICE * pDevice, int x, int y);
     38            void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
     39          
     40            pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
     41            Index0 = *(pTrans + 0);
     42            Index1 = *(pTrans + 1);
     43            x += Diff;
   \   00000010   01B087E0           ADD      R11,R7,R1
     44            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000014   ........           LDR      R1,??DataTable6
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   30209DE5           LDR      R2,[SP, #+48]
   \   00000020   0C0094E5           LDR      R0,[R4, #+12]
   \   00000024   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000028   00C092E5           LDR      R12,[R2, #+0]
   \   0000002C   189090E5           LDR      R9,[R0, #+24]
   \   00000030   00C08DE5           STR      R12,[SP, #+0]
   \   00000034   031001E2           AND      R1,R1,#0x3
   \   00000038   0360A0E1           MOV      R6,R3
   \   0000003C   2C809DE5           LDR      R8,[SP, #+44]
   \   00000040   04A092E5           LDR      R10,[R2, #+4]
   \   00000044   030051E3           CMP      R1,#+3
   \   00000048   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitLine1BPP_0:
   \   0000004C   3F00008A           BHI      ??_DrawBitLine1BPP_1
   \   00000050   020000EA           B        ??_DrawBitLine1BPP_2
   \   00000054   230000EA           B        ??_DrawBitLine1BPP_3
   \   00000058   110000EA           B        ??_DrawBitLine1BPP_4
   \   0000005C   210000EA           B        ??_DrawBitLine1BPP_3
     45            case 0:
     46              do {
     47                pfSetPixelIndex(pDevice, x++, y, (*p & (0x80 >> Diff)) ? Index1 : Index0);
   \                     ??_DrawBitLine1BPP_2:
   \   00000060   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000064   8010A0E3           MOV      R1,#+128
   \   00000068   0520A0E1           MOV      R2,R5
   \   0000006C   510710E1           TST      R0,R1, ASR R7
   \   00000070   0A30A011           MOVNE    R3,R10
   \   00000074   00309D05           LDREQ    R3,[SP, #+0]
   \   00000078   0B10A0E1           MOV      R1,R11
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   39FF2FE1           BLX      R9
     48                if (++Diff == 8) {
   \   00000084   017087E2           ADD      R7,R7,#+1
   \   00000088   080057E3           CMP      R7,#+8
     49                  Diff = 0;
   \   0000008C   0070A003           MOVEQ    R7,#+0
     50                  p++;
   \   00000090   01608602           ADDEQ    R6,R6,#+1
   \   00000094   01B08BE2           ADD      R11,R11,#+1
     51                }
     52              } while (--xsize);
   \   00000098   018058E2           SUBS     R8,R8,#+1
   \   0000009C   EFFFFF1A           BNE      ??_DrawBitLine1BPP_2
   \   000000A0   2A0000EA           B        ??_DrawBitLine1BPP_1
     53              break;
     54            case LCD_DRAWMODE_TRANS:
     55              do {
     56                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_4:
   \   000000A4   0000D6E5           LDRB     R0,[R6, #+0]
   \   000000A8   8010A0E3           MOV      R1,#+128
   \   000000AC   510710E1           TST      R0,R1, ASR R7
   \   000000B0   0400000A           BEQ      ??_DrawBitLine1BPP_5
     57                  pfSetPixelIndex(pDevice, x, y, Index1);
   \   000000B4   0A30A0E1           MOV      R3,R10
   \   000000B8   0520A0E1           MOV      R2,R5
   \   000000BC   0B10A0E1           MOV      R1,R11
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   39FF2FE1           BLX      R9
     58                }
     59                x++;
     60                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_5:
   \   000000C8   017087E2           ADD      R7,R7,#+1
   \   000000CC   080057E3           CMP      R7,#+8
     61                  Diff = 0;
   \   000000D0   0070A003           MOVEQ    R7,#+0
     62                  p++;
   \   000000D4   01608602           ADDEQ    R6,R6,#+1
   \   000000D8   01B08BE2           ADD      R11,R11,#+1
     63                }
     64              } while (--xsize);
   \   000000DC   018058E2           SUBS     R8,R8,#+1
   \   000000E0   EFFFFF1A           BNE      ??_DrawBitLine1BPP_4
   \   000000E4   190000EA           B        ??_DrawBitLine1BPP_1
     65              break;
     66            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
     67            case LCD_DRAWMODE_XOR:
     68              pfGetPixelIndex = pDevice->pDeviceAPI->pfGetPixelIndex;
   \                     ??_DrawBitLine1BPP_3:
   \   000000E8   14A090E5           LDR      R10,[R0, #+20]
     69              IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \   000000EC   100094E5           LDR      R0,[R4, #+16]
   \   000000F0   080090E5           LDR      R0,[R0, #+8]
   \   000000F4   30FF2FE1           BLX      R0
   \   000000F8   00008DE5           STR      R0,[SP, #+0]
     70              do {
     71                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_6:
   \   000000FC   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000100   8010A0E3           MOV      R1,#+128
   \   00000104   510710E1           TST      R0,R1, ASR R7
   \   00000108   0900000A           BEQ      ??_DrawBitLine1BPP_7
     72                  Pixel = pfGetPixelIndex(pDevice, x, y);
   \   0000010C   0520A0E1           MOV      R2,R5
   \   00000110   0B10A0E1           MOV      R1,R11
   \   00000114   0400A0E1           MOV      R0,R4
   \   00000118   3AFF2FE1           BLX      R10
     73                  pfSetPixelIndex(pDevice, x, y, Pixel ^ IndexMask);
   \   0000011C   00109DE5           LDR      R1,[SP, #+0]
   \   00000120   0520A0E1           MOV      R2,R5
   \   00000124   003021E0           EOR      R3,R1,R0
   \   00000128   0B10A0E1           MOV      R1,R11
   \   0000012C   0400A0E1           MOV      R0,R4
   \   00000130   39FF2FE1           BLX      R9
     74                }
     75                x++;
     76                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_7:
   \   00000134   017087E2           ADD      R7,R7,#+1
   \   00000138   080057E3           CMP      R7,#+8
     77                  Diff = 0;
   \   0000013C   0070A003           MOVEQ    R7,#+0
     78                  p++;
   \   00000140   01608602           ADDEQ    R6,R6,#+1
   \   00000144   01B08BE2           ADD      R11,R11,#+1
     79                }
     80              } while (--xsize);
   \   00000148   018058E2           SUBS     R8,R8,#+1
   \   0000014C   EAFFFF1A           BNE      ??_DrawBitLine1BPP_6
     81              break;
     82            }
     83          }
   \                     ??_DrawBitLine1BPP_1:
   \   00000150   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000154   F08FBDE8           POP      {R4-R11,PC}      ;; return
     84          
     85          /*********************************************************************
     86          *
     87          *       Draw Bitmap 2 BPP
     88          */

   \                                 In section .text, align 4, keep-with-next
     89          static void _DrawBitLine2BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine2BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
     90            LCD_PIXELINDEX Pixels, PixelIndex;
     91            int CurrentPixel, Shift, Index;
     92            void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
     93          
     94            pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
   \   00000008   0C0095E5           LDR      R0,[R5, #+12]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   189090E5           LDR      R9,[R0, #+24]
     95            Pixels = *p;
     96            CurrentPixel = Diff;
     97            x += Diff;
     98            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000014   ........           LDR      R0,??DataTable6
   \   00000018   28409DE5           LDR      R4,[SP, #+40]
   \   0000001C   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000020   0370A0E1           MOV      R7,R3
   \   00000024   0260A0E1           MOV      R6,R2
   \   00000028   2C809DE5           LDR      R8,[SP, #+44]
   \   0000002C   00A0D7E5           LDRB     R10,[R7, #+0]
   \   00000030   01B084E0           ADD      R11,R4,R1
   \   00000034   030010E2           ANDS     R0,R0,#0x3
   \   00000038   0200000A           BEQ      ??_DrawBitLine2BPP_0
   \   0000003C   020050E2           SUBS     R0,R0,#+2
   \   00000040   2B00000A           BEQ      ??_DrawBitLine2BPP_1
   \   00000044   560000EA           B        ??_DrawBitLine2BPP_2
   \                     ??_DrawBitLine2BPP_0:
   \   00000048   30009DE5           LDR      R0,[SP, #+48]
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   1400000A           BEQ      ??_DrawBitLine2BPP_3
     99            case 0:
    100              if (pTrans) {
    101                do {
    102                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_4:
   \   00000054   030064E2           RSB      R0,R4,#+3
   \   00000058   8000A0E1           LSL      R0,R0,#+1
    103                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    104                  PixelIndex = *(pTrans + Index);
    105                  pfSetPixelIndex(pDevice, x++, y, PixelIndex);
   \   0000005C   0020A0E1           MOV      R2,R0
   \   00000060   C010A0E3           MOV      R1,#+192
   \   00000064   062062E2           RSB      R2,R2,#+6
   \   00000068   51120AE0           AND      R1,R10,R1, ASR R2
   \   0000006C   3100A0E1           LSR      R0,R1,R0
   \   00000070   30109DE5           LDR      R1,[SP, #+48]
   \   00000074   0620A0E1           MOV      R2,R6
   \   00000078   003191E7           LDR      R3,[R1, +R0, LSL #+2]
   \   0000007C   0B10A0E1           MOV      R1,R11
   \   00000080   0500A0E1           MOV      R0,R5
   \   00000084   39FF2FE1           BLX      R9
    106                  if (++CurrentPixel == 4) {
   \   00000088   014084E2           ADD      R4,R4,#+1
   \   0000008C   040054E3           CMP      R4,#+4
    107                    CurrentPixel = 0;
   \   00000090   0040A003           MOVEQ    R4,#+0
    108                    Pixels = *(++p);
   \   00000094   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   00000098   01B08BE2           ADD      R11,R11,#+1
    109                  }
    110                } while (--xsize);
   \   0000009C   018058E2           SUBS     R8,R8,#+1
   \   000000A0   EBFFFF1A           BNE      ??_DrawBitLine2BPP_4
   \   000000A4   3E0000EA           B        ??_DrawBitLine2BPP_2
    111              } else {
    112                do {
    113                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_3:
   \   000000A8   030064E2           RSB      R0,R4,#+3
   \   000000AC   8000A0E1           LSL      R0,R0,#+1
    114                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    115                  pfSetPixelIndex(pDevice, x++, y, Index);
   \   000000B0   0020A0E1           MOV      R2,R0
   \   000000B4   C010A0E3           MOV      R1,#+192
   \   000000B8   062062E2           RSB      R2,R2,#+6
   \   000000BC   51120AE0           AND      R1,R10,R1, ASR R2
   \   000000C0   3130A0E1           LSR      R3,R1,R0
   \   000000C4   0620A0E1           MOV      R2,R6
   \   000000C8   0B10A0E1           MOV      R1,R11
   \   000000CC   0500A0E1           MOV      R0,R5
   \   000000D0   39FF2FE1           BLX      R9
    116                  if (++CurrentPixel == 4) {
   \   000000D4   014084E2           ADD      R4,R4,#+1
   \   000000D8   040054E3           CMP      R4,#+4
    117                    CurrentPixel = 0;
   \   000000DC   0040A003           MOVEQ    R4,#+0
    118                    Pixels = *(++p);
   \   000000E0   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   000000E4   01B08BE2           ADD      R11,R11,#+1
    119                  }
    120                } while (--xsize);
   \   000000E8   018058E2           SUBS     R8,R8,#+1
   \   000000EC   EDFFFF1A           BNE      ??_DrawBitLine2BPP_3
   \   000000F0   2B0000EA           B        ??_DrawBitLine2BPP_2
    121              }
   \                     ??_DrawBitLine2BPP_1:
   \   000000F4   30009DE5           LDR      R0,[SP, #+48]
   \   000000F8   000050E3           CMP      R0,#+0
   \   000000FC   1500000A           BEQ      ??_DrawBitLine2BPP_5
    122              break;
    123            case LCD_DRAWMODE_TRANS:
    124              if (pTrans) {
    125                do {
    126                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_6:
   \   00000100   030064E2           RSB      R0,R4,#+3
   \   00000104   8000A0E1           LSL      R0,R0,#+1
    127                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000108   0020A0E1           MOV      R2,R0
   \   0000010C   C010A0E3           MOV      R1,#+192
   \   00000110   062062E2           RSB      R2,R2,#+6
   \   00000114   51120AE0           AND      R1,R10,R1, ASR R2
   \   00000118   3130B0E1           LSRS     R3,R1,R0
    128                  if (Index) {
   \   0000011C   0500000A           BEQ      ??_DrawBitLine2BPP_7
    129                    PixelIndex = *(pTrans + Index);
    130                    pfSetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000120   30009DE5           LDR      R0,[SP, #+48]
   \   00000124   0620A0E1           MOV      R2,R6
   \   00000128   033190E7           LDR      R3,[R0, +R3, LSL #+2]
   \   0000012C   0B10A0E1           MOV      R1,R11
   \   00000130   0500A0E1           MOV      R0,R5
   \   00000134   39FF2FE1           BLX      R9
    131                  }
    132                  x++;
    133                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_7:
   \   00000138   014084E2           ADD      R4,R4,#+1
   \   0000013C   040054E3           CMP      R4,#+4
    134                    CurrentPixel = 0;
   \   00000140   0040A003           MOVEQ    R4,#+0
    135                    Pixels = *(++p);
   \   00000144   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   00000148   01B08BE2           ADD      R11,R11,#+1
    136                  }
    137                } while (--xsize);
   \   0000014C   018058E2           SUBS     R8,R8,#+1
   \   00000150   EAFFFF1A           BNE      ??_DrawBitLine2BPP_6
   \   00000154   120000EA           B        ??_DrawBitLine2BPP_2
    138              } else {
    139                do {
    140                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_5:
   \   00000158   030064E2           RSB      R0,R4,#+3
   \   0000015C   8000A0E1           LSL      R0,R0,#+1
    141                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000160   0020A0E1           MOV      R2,R0
   \   00000164   C010A0E3           MOV      R1,#+192
   \   00000168   062062E2           RSB      R2,R2,#+6
   \   0000016C   51120AE0           AND      R1,R10,R1, ASR R2
   \   00000170   3130B0E1           LSRS     R3,R1,R0
    142                  if (Index) {
   \   00000174   0300000A           BEQ      ??_DrawBitLine2BPP_8
    143                    pfSetPixelIndex(pDevice, x, y, Index);
   \   00000178   0620A0E1           MOV      R2,R6
   \   0000017C   0B10A0E1           MOV      R1,R11
   \   00000180   0500A0E1           MOV      R0,R5
   \   00000184   39FF2FE1           BLX      R9
    144                  }
    145                  x++;
    146                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_8:
   \   00000188   014084E2           ADD      R4,R4,#+1
   \   0000018C   040054E3           CMP      R4,#+4
    147                    CurrentPixel = 0;
   \   00000190   0040A003           MOVEQ    R4,#+0
    148                    Pixels = *(++p);
   \   00000194   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   00000198   01B08BE2           ADD      R11,R11,#+1
    149                  }
    150                } while (--xsize);
   \   0000019C   018058E2           SUBS     R8,R8,#+1
   \   000001A0   ECFFFF1A           BNE      ??_DrawBitLine2BPP_5
    151              }
    152              break;
    153            }
    154          }
   \                     ??_DrawBitLine2BPP_2:
   \   000001A4   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000001A8   F08FBDE8           POP      {R4-R11,PC}      ;; return
    155          
    156          /*********************************************************************
    157          *
    158          *       Draw Bitmap 4 BPP
    159          */

   \                                 In section .text, align 4, keep-with-next
    160          static void _DrawBitLine4BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine4BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    161            LCD_PIXELINDEX Pixels, PixelIndex;
    162            int CurrentPixel, Shift, Index;
    163            void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
    164          
    165            pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
   \   00000008   0C0095E5           LDR      R0,[R5, #+12]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   189090E5           LDR      R9,[R0, #+24]
    166            Pixels = *p;
    167            CurrentPixel = Diff;
    168            x += Diff;
    169            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000014   ........           LDR      R0,??DataTable6
   \   00000018   28409DE5           LDR      R4,[SP, #+40]
   \   0000001C   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000020   0370A0E1           MOV      R7,R3
   \   00000024   0260A0E1           MOV      R6,R2
   \   00000028   2C809DE5           LDR      R8,[SP, #+44]
   \   0000002C   00A0D7E5           LDRB     R10,[R7, #+0]
   \   00000030   01B084E0           ADD      R11,R4,R1
   \   00000034   030010E2           ANDS     R0,R0,#0x3
   \   00000038   0200000A           BEQ      ??_DrawBitLine4BPP_0
   \   0000003C   020050E2           SUBS     R0,R0,#+2
   \   00000040   2B00000A           BEQ      ??_DrawBitLine4BPP_1
   \   00000044   560000EA           B        ??_DrawBitLine4BPP_2
   \                     ??_DrawBitLine4BPP_0:
   \   00000048   30009DE5           LDR      R0,[SP, #+48]
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   1400000A           BEQ      ??_DrawBitLine4BPP_3
    170            case 0:
    171              if (pTrans) {
    172                do {
    173                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_4:
   \   00000054   010064E2           RSB      R0,R4,#+1
   \   00000058   0001A0E1           LSL      R0,R0,#+2
    174                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    175                  PixelIndex = *(pTrans + Index);
    176                  pfSetPixelIndex(pDevice, x++, y, PixelIndex);
   \   0000005C   0020A0E1           MOV      R2,R0
   \   00000060   F010A0E3           MOV      R1,#+240
   \   00000064   042062E2           RSB      R2,R2,#+4
   \   00000068   51120AE0           AND      R1,R10,R1, ASR R2
   \   0000006C   3100A0E1           LSR      R0,R1,R0
   \   00000070   30109DE5           LDR      R1,[SP, #+48]
   \   00000074   0620A0E1           MOV      R2,R6
   \   00000078   003191E7           LDR      R3,[R1, +R0, LSL #+2]
   \   0000007C   0B10A0E1           MOV      R1,R11
   \   00000080   0500A0E1           MOV      R0,R5
   \   00000084   39FF2FE1           BLX      R9
    177                  if (++CurrentPixel == 2) {
   \   00000088   014084E2           ADD      R4,R4,#+1
   \   0000008C   020054E3           CMP      R4,#+2
    178                    CurrentPixel = 0;
   \   00000090   0040A003           MOVEQ    R4,#+0
    179                    Pixels = *(++p);
   \   00000094   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   00000098   01B08BE2           ADD      R11,R11,#+1
    180                  }
    181                } while (--xsize);
   \   0000009C   018058E2           SUBS     R8,R8,#+1
   \   000000A0   EBFFFF1A           BNE      ??_DrawBitLine4BPP_4
   \   000000A4   3E0000EA           B        ??_DrawBitLine4BPP_2
    182              } else {
    183                do {
    184                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_3:
   \   000000A8   010064E2           RSB      R0,R4,#+1
   \   000000AC   0001A0E1           LSL      R0,R0,#+2
    185                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    186                  pfSetPixelIndex(pDevice, x++, y, Index);
   \   000000B0   0020A0E1           MOV      R2,R0
   \   000000B4   F010A0E3           MOV      R1,#+240
   \   000000B8   042062E2           RSB      R2,R2,#+4
   \   000000BC   51120AE0           AND      R1,R10,R1, ASR R2
   \   000000C0   3130A0E1           LSR      R3,R1,R0
   \   000000C4   0620A0E1           MOV      R2,R6
   \   000000C8   0B10A0E1           MOV      R1,R11
   \   000000CC   0500A0E1           MOV      R0,R5
   \   000000D0   39FF2FE1           BLX      R9
    187                  if (++CurrentPixel == 2) {
   \   000000D4   014084E2           ADD      R4,R4,#+1
   \   000000D8   020054E3           CMP      R4,#+2
    188                    CurrentPixel = 0;
   \   000000DC   0040A003           MOVEQ    R4,#+0
    189                    Pixels = *(++p);
   \   000000E0   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   000000E4   01B08BE2           ADD      R11,R11,#+1
    190                  }
    191                } while (--xsize);
   \   000000E8   018058E2           SUBS     R8,R8,#+1
   \   000000EC   EDFFFF1A           BNE      ??_DrawBitLine4BPP_3
   \   000000F0   2B0000EA           B        ??_DrawBitLine4BPP_2
    192              }
   \                     ??_DrawBitLine4BPP_1:
   \   000000F4   30009DE5           LDR      R0,[SP, #+48]
   \   000000F8   000050E3           CMP      R0,#+0
   \   000000FC   1500000A           BEQ      ??_DrawBitLine4BPP_5
    193              break;
    194            case LCD_DRAWMODE_TRANS:
    195              if (pTrans) {
    196                do {
    197                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_6:
   \   00000100   010064E2           RSB      R0,R4,#+1
   \   00000104   0001A0E1           LSL      R0,R0,#+2
    198                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000108   0020A0E1           MOV      R2,R0
   \   0000010C   F010A0E3           MOV      R1,#+240
   \   00000110   042062E2           RSB      R2,R2,#+4
   \   00000114   51120AE0           AND      R1,R10,R1, ASR R2
   \   00000118   3130B0E1           LSRS     R3,R1,R0
    199                  if (Index) {
   \   0000011C   0500000A           BEQ      ??_DrawBitLine4BPP_7
    200                    PixelIndex = *(pTrans + Index);
    201                    pfSetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000120   30009DE5           LDR      R0,[SP, #+48]
   \   00000124   0620A0E1           MOV      R2,R6
   \   00000128   033190E7           LDR      R3,[R0, +R3, LSL #+2]
   \   0000012C   0B10A0E1           MOV      R1,R11
   \   00000130   0500A0E1           MOV      R0,R5
   \   00000134   39FF2FE1           BLX      R9
    202                  }
    203                  x++;
    204                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_7:
   \   00000138   014084E2           ADD      R4,R4,#+1
   \   0000013C   020054E3           CMP      R4,#+2
    205                    CurrentPixel = 0;
   \   00000140   0040A003           MOVEQ    R4,#+0
    206                    Pixels = *(++p);
   \   00000144   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   00000148   01B08BE2           ADD      R11,R11,#+1
    207                  }
    208                } while (--xsize);
   \   0000014C   018058E2           SUBS     R8,R8,#+1
   \   00000150   EAFFFF1A           BNE      ??_DrawBitLine4BPP_6
   \   00000154   120000EA           B        ??_DrawBitLine4BPP_2
    209              } else {
    210                do {
    211                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_5:
   \   00000158   010064E2           RSB      R0,R4,#+1
   \   0000015C   0001A0E1           LSL      R0,R0,#+2
    212                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000160   0020A0E1           MOV      R2,R0
   \   00000164   F010A0E3           MOV      R1,#+240
   \   00000168   042062E2           RSB      R2,R2,#+4
   \   0000016C   51120AE0           AND      R1,R10,R1, ASR R2
   \   00000170   3130B0E1           LSRS     R3,R1,R0
    213                  if (Index) {
   \   00000174   0300000A           BEQ      ??_DrawBitLine4BPP_8
    214                    pfSetPixelIndex(pDevice, x, y, Index);
   \   00000178   0620A0E1           MOV      R2,R6
   \   0000017C   0B10A0E1           MOV      R1,R11
   \   00000180   0500A0E1           MOV      R0,R5
   \   00000184   39FF2FE1           BLX      R9
    215                  }
    216                  x++;
    217                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_8:
   \   00000188   014084E2           ADD      R4,R4,#+1
   \   0000018C   020054E3           CMP      R4,#+2
    218                    CurrentPixel = 0;
   \   00000190   0040A003           MOVEQ    R4,#+0
    219                    Pixels = *(++p);
   \   00000194   01A0F705           LDRBEQ   R10,[R7, #+1]!
   \   00000198   01B08BE2           ADD      R11,R11,#+1
    220                  }
    221                } while (--xsize);
   \   0000019C   018058E2           SUBS     R8,R8,#+1
   \   000001A0   ECFFFF1A           BNE      ??_DrawBitLine4BPP_5
    222              }
    223              break;
    224            }
    225          }
   \                     ??_DrawBitLine4BPP_2:
   \   000001A4   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000001A8   F08FBDE8           POP      {R4-R11,PC}      ;; return
    226          
    227          /*********************************************************************
    228          *
    229          *       Draw Bitmap 8 BPP
    230          */

   \                                 In section .text, align 4, keep-with-next
    231          static void _DrawBitLine8BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine8BPP:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    232            LCD_PIXELINDEX Pixel;
    233            void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
    234          
    235            pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
   \   00000008   0C0094E5           LDR      R0,[R4, #+12]
   \   0000000C   0190A0E1           MOV      R9,R1
   \   00000010   188090E5           LDR      R8,[R0, #+24]
    236            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000014   ........           LDR      R0,??DataTable6
   \   00000018   0250A0E1           MOV      R5,R2
   \   0000001C   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000020   0360A0E1           MOV      R6,R3
   \   00000024   20A09DE5           LDR      R10,[SP, #+32]
   \   00000028   24709DE5           LDR      R7,[SP, #+36]
   \   0000002C   030010E2           ANDS     R0,R0,#0x3
   \   00000030   0200000A           BEQ      ??_DrawBitLine8BPP_0
   \   00000034   020050E2           SUBS     R0,R0,#+2
   \   00000038   3700000A           BEQ      ??_DrawBitLine8BPP_1
   \   0000003C   F087BDE8           POP      {R4-R10,PC}
    237            case 0:
    238              if (pTrans) {
   \                     ??_DrawBitLine8BPP_0:
   \   00000040   000057E3           CMP      R7,#+0
   \   00000044   1B00000A           BEQ      ??_DrawBitLine8BPP_2
   \   00000048   01005AE3           CMP      R10,#+1
   \   0000004C   810000BA           BLT      ??_DrawBitLine8BPP_3
   \   00000050   01001AE3           TST      R10,#0x1
   \   00000054   0400000A           BEQ      ??_DrawBitLine8BPP_4
    239                for (; xsize > 0; xsize--, x++, p++) {
    240                  Pixel = *p;
    241                  pfSetPixelIndex(pDevice, x, y, *(pTrans + Pixel));
   \   00000058   0100D6E4           LDRB     R0,[R6], #+1
   \   0000005C   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   38FF2FE1           BLX      R8
   \   00000068   019089E2           ADD      R9,R9,#+1
   \                     ??_DrawBitLine8BPP_4:
   \   0000006C   AAA0B0E1           LSRS     R10,R10,#+1
   \   00000070   7800000A           BEQ      ??_DrawBitLine8BPP_3
   \                     ??_DrawBitLine8BPP_5:
   \   00000074   0100D6E4           LDRB     R0,[R6], #+1
   \   00000078   0520A0E1           MOV      R2,R5
   \   0000007C   0910A0E1           MOV      R1,R9
   \   00000080   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   38FF2FE1           BLX      R8
   \   0000008C   0100D6E4           LDRB     R0,[R6], #+1
   \   00000090   019089E2           ADD      R9,R9,#+1
   \   00000094   0520A0E1           MOV      R2,R5
   \   00000098   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   0000009C   0910A0E1           MOV      R1,R9
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   38FF2FE1           BLX      R8
    242                }
   \   000000A8   019089E2           ADD      R9,R9,#+1
   \   000000AC   01A05AE2           SUBS     R10,R10,#+1
   \   000000B0   EFFFFF1A           BNE      ??_DrawBitLine8BPP_5
   \   000000B4   F087BDE8           POP      {R4-R10,PC}
    243              } else {
   \                     ??_DrawBitLine8BPP_2:
   \   000000B8   01005AE3           CMP      R10,#+1
   \   000000BC   650000BA           BLT      ??_DrawBitLine8BPP_3
   \   000000C0   01001AE3           TST      R10,#0x1
   \   000000C4   0300000A           BEQ      ??_DrawBitLine8BPP_6
    244                for (; xsize > 0; xsize--, x++, p++) {
    245                  pfSetPixelIndex(pDevice, x, y, *p);
   \   000000C8   0130D6E4           LDRB     R3,[R6], #+1
   \   000000CC   0400A0E1           MOV      R0,R4
   \   000000D0   38FF2FE1           BLX      R8
   \   000000D4   019089E2           ADD      R9,R9,#+1
   \                     ??_DrawBitLine8BPP_6:
   \   000000D8   AA70B0E1           LSRS     R7,R10,#+1
   \   000000DC   5D00000A           BEQ      ??_DrawBitLine8BPP_3
   \                     ??_DrawBitLine8BPP_7:
   \   000000E0   0130D6E4           LDRB     R3,[R6], #+1
   \   000000E4   0520A0E1           MOV      R2,R5
   \   000000E8   0910A0E1           MOV      R1,R9
   \   000000EC   0400A0E1           MOV      R0,R4
   \   000000F0   38FF2FE1           BLX      R8
   \   000000F4   019089E2           ADD      R9,R9,#+1
   \   000000F8   0130D6E4           LDRB     R3,[R6], #+1
   \   000000FC   0520A0E1           MOV      R2,R5
   \   00000100   0910A0E1           MOV      R1,R9
   \   00000104   0400A0E1           MOV      R0,R4
   \   00000108   38FF2FE1           BLX      R8
    246                }
   \   0000010C   019089E2           ADD      R9,R9,#+1
   \   00000110   017057E2           SUBS     R7,R7,#+1
   \   00000114   F1FFFF1A           BNE      ??_DrawBitLine8BPP_7
   \   00000118   F087BDE8           POP      {R4-R10,PC}
    247              }
    248              break;
    249            case LCD_DRAWMODE_TRANS:
    250              if (pTrans) {
   \                     ??_DrawBitLine8BPP_1:
   \   0000011C   000057E3           CMP      R7,#+0
   \   00000120   2600000A           BEQ      ??_DrawBitLine8BPP_8
   \   00000124   01005AE3           CMP      R10,#+1
   \   00000128   4A0000BA           BLT      ??_DrawBitLine8BPP_3
   \   0000012C   01A04AE2           SUB      R10,R10,#+1
   \   00000130   0030D6E5           LDRB     R3,[R6, #+0]
   \   00000134   01001AE3           TST      R10,#0x1
   \   00000138   0600000A           BEQ      ??_DrawBitLine8BPP_9
    251                for (; xsize > 0; xsize--, x++, p++) {
    252                  Pixel = *p;
    253                  if (Pixel) {
   \   0000013C   000053E3           CMP      R3,#+0
   \   00000140   0200000A           BEQ      ??_DrawBitLine8BPP_10
    254                    pfSetPixelIndex(pDevice, x, y, *(pTrans + Pixel));
   \   00000144   033197E7           LDR      R3,[R7, +R3, LSL #+2]
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   38FF2FE1           BLX      R8
   \                     ??_DrawBitLine8BPP_10:
   \   00000150   019089E2           ADD      R9,R9,#+1
   \   00000154   0130F6E5           LDRB     R3,[R6, #+1]!
   \                     ??_DrawBitLine8BPP_9:
   \   00000158   AAA0B0E1           LSRS     R10,R10,#+1
   \   0000015C   1300000A           BEQ      ??_DrawBitLine8BPP_11
   \                     ??_DrawBitLine8BPP_12:
   \   00000160   000053E3           CMP      R3,#+0
   \   00000164   0400000A           BEQ      ??_DrawBitLine8BPP_13
   \   00000168   033197E7           LDR      R3,[R7, +R3, LSL #+2]
   \   0000016C   0520A0E1           MOV      R2,R5
   \   00000170   0910A0E1           MOV      R1,R9
   \   00000174   0400A0E1           MOV      R0,R4
   \   00000178   38FF2FE1           BLX      R8
   \                     ??_DrawBitLine8BPP_13:
   \   0000017C   0130F6E5           LDRB     R3,[R6, #+1]!
   \   00000180   019089E2           ADD      R9,R9,#+1
   \   00000184   000053E3           CMP      R3,#+0
   \   00000188   0400000A           BEQ      ??_DrawBitLine8BPP_14
   \   0000018C   033197E7           LDR      R3,[R7, +R3, LSL #+2]
   \   00000190   0520A0E1           MOV      R2,R5
   \   00000194   0910A0E1           MOV      R1,R9
   \   00000198   0400A0E1           MOV      R0,R4
   \   0000019C   38FF2FE1           BLX      R8
   \                     ??_DrawBitLine8BPP_14:
   \   000001A0   019089E2           ADD      R9,R9,#+1
   \   000001A4   0130F6E5           LDRB     R3,[R6, #+1]!
   \   000001A8   01A05AE2           SUBS     R10,R10,#+1
   \   000001AC   EBFFFF1A           BNE      ??_DrawBitLine8BPP_12
   \                     ??_DrawBitLine8BPP_11:
   \   000001B0   000053E3           CMP      R3,#+0
   \   000001B4   2700000A           BEQ      ??_DrawBitLine8BPP_3
   \   000001B8   033197E7           LDR      R3,[R7, +R3, LSL #+2]
   \   000001BC   210000EA           B        ??_DrawBitLine8BPP_15
    255                  }
    256                }
    257              } else {
   \                     ??_DrawBitLine8BPP_8:
   \   000001C0   01005AE3           CMP      R10,#+1
   \   000001C4   230000BA           BLT      ??_DrawBitLine8BPP_3
   \   000001C8   01704AE2           SUB      R7,R10,#+1
   \   000001CC   0030D6E5           LDRB     R3,[R6, #+0]
   \   000001D0   010017E3           TST      R7,#0x1
   \   000001D4   0500000A           BEQ      ??_DrawBitLine8BPP_16
    258                for (; xsize > 0; xsize--, x++, p++) {
    259                  Pixel = *p;
    260                  if (Pixel) {
   \   000001D8   000053E3           CMP      R3,#+0
   \   000001DC   0100000A           BEQ      ??_DrawBitLine8BPP_17
    261                    pfSetPixelIndex(pDevice, x, y, Pixel);
   \   000001E0   0400A0E1           MOV      R0,R4
   \   000001E4   38FF2FE1           BLX      R8
   \                     ??_DrawBitLine8BPP_17:
   \   000001E8   019089E2           ADD      R9,R9,#+1
   \   000001EC   0130F6E5           LDRB     R3,[R6, #+1]!
   \                     ??_DrawBitLine8BPP_16:
   \   000001F0   A770B0E1           LSRS     R7,R7,#+1
   \   000001F4   1100000A           BEQ      ??_DrawBitLine8BPP_18
   \                     ??_DrawBitLine8BPP_19:
   \   000001F8   000053E3           CMP      R3,#+0
   \   000001FC   0300000A           BEQ      ??_DrawBitLine8BPP_20
   \   00000200   0520A0E1           MOV      R2,R5
   \   00000204   0910A0E1           MOV      R1,R9
   \   00000208   0400A0E1           MOV      R0,R4
   \   0000020C   38FF2FE1           BLX      R8
   \                     ??_DrawBitLine8BPP_20:
   \   00000210   0130F6E5           LDRB     R3,[R6, #+1]!
   \   00000214   019089E2           ADD      R9,R9,#+1
   \   00000218   000053E3           CMP      R3,#+0
   \   0000021C   0300000A           BEQ      ??_DrawBitLine8BPP_21
   \   00000220   0520A0E1           MOV      R2,R5
   \   00000224   0910A0E1           MOV      R1,R9
   \   00000228   0400A0E1           MOV      R0,R4
   \   0000022C   38FF2FE1           BLX      R8
   \                     ??_DrawBitLine8BPP_21:
   \   00000230   019089E2           ADD      R9,R9,#+1
   \   00000234   0130F6E5           LDRB     R3,[R6, #+1]!
   \   00000238   017057E2           SUBS     R7,R7,#+1
   \   0000023C   EDFFFF1A           BNE      ??_DrawBitLine8BPP_19
   \                     ??_DrawBitLine8BPP_18:
   \   00000240   000053E3           CMP      R3,#+0
   \   00000244   0300000A           BEQ      ??_DrawBitLine8BPP_3
   \                     ??_DrawBitLine8BPP_15:
   \   00000248   0520A0E1           MOV      R2,R5
   \   0000024C   0910A0E1           MOV      R1,R9
   \   00000250   0400A0E1           MOV      R0,R4
   \   00000254   38FF2FE1           BLX      R8
    262                  }
    263                }
    264              }
    265              break;
    266            }
    267          }
   \                     ??_DrawBitLine8BPP_3:
   \   00000258   F087BDE8           POP      {R4-R10,PC}      ;; return
    268          
    269          /*********************************************************************
    270          *
    271          *       Draw Bitmap 16 BPP
    272          */
    273          static void _DrawBitLine16BPP(GUI_DEVICE * pDevice, int x, int y, U16 const GUI_UNI_PTR * p, int xSize) {
    274            void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
    275          
    276            pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
    277            for (; xSize > 0; xSize--, x++, p++) {
    278              pfSetPixelIndex(pDevice, x, y, *p);
    279            }
    280          }
    281          
    282          /*********************************************************************
    283          *
    284          *       Draw Bitmap 32 BPP
    285          */
    286          static void _DrawBitLine32BPP(GUI_DEVICE * pDevice, int x, int y, U32 const GUI_UNI_PTR * p, int xSize) {
    287            void     (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
    288          
    289            pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
    290            for (; xSize > 0; xSize--, x++, p++) {
    291              pfSetPixelIndex(pDevice, x, y, *p);
    292            }
    293          }
    294          
    295          /*********************************************************************
    296          *
    297          *       Public code
    298          *
    299          **********************************************************************
    300          */
    301          /*********************************************************************
    302          *
    303          *       GUIDRV__NoOpt_XorPixel
    304          */

   \                                 In section .text, align 4, keep-with-next
    305          void GUIDRV__NoOpt_XorPixel(GUI_DEVICE * pDevice, int x, int y) {
   \                     GUIDRV__NoOpt_XorPixel:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    306            LCD_PIXELINDEX PixelIndex;
    307            LCD_PIXELINDEX IndexMask;
    308            
    309            PixelIndex = pDevice->pDeviceAPI->pfGetPixelIndex(pDevice, x, y);
   \   00000008   0C3094E5           LDR      R3,[R4, #+12]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   143093E5           LDR      R3,[R3, #+20]
   \   0000001C   33FF2FE1           BLX      R3
   \   00000020   0070A0E1           MOV      R7,R0
    310            IndexMask  = pDevice->pColorConvAPI->pfGetIndexMask();
   \   00000024   100094E5           LDR      R0,[R4, #+16]
   \   00000028   080090E5           LDR      R0,[R0, #+8]
   \   0000002C   30FF2FE1           BLX      R0
    311            pDevice->pDeviceAPI->pfSetPixelIndex(pDevice, x, y, PixelIndex ^ IndexMask);
   \   00000030   073020E0           EOR      R3,R0,R7
   \   00000034   0620A0E1           MOV      R2,R6
   \   00000038   0510A0E1           MOV      R1,R5
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   0CC094E5           LDR      R12,[R4, #+12]
   \   00000044   04D08DE2           ADD      SP,SP,#+4
   \   00000048   F040BDE8           POP      {R4-R7,LR}
   \   0000004C   18C09CE5           LDR      R12,[R12, #+24]
   \   00000050   1CFF2FE1           BX       R12              ;; tailcall
    312          }
    313          
    314          /*********************************************************************
    315          *
    316          *       GUIDRV__NoOpt_DrawHLine
    317          */

   \                                 In section .text, align 4, keep-with-next
    318          void GUIDRV__NoOpt_DrawHLine(GUI_DEVICE * pDevice, int x0, int y,  int x1) {
   \                     GUIDRV__NoOpt_DrawHLine:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    319            LCD_PIXELINDEX ColorIndex;
    320            void (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
    321            void (* pfXorPixel     )(GUI_DEVICE * pDevice, int x, int y);
    322          
    323            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R1,??DataTable6
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000014   04D04DE2           SUB      SP,SP,#+4
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   0370A0E1           MOV      R7,R3
   \   00000020   0C0094E5           LDR      R0,[R4, #+12]
   \   00000024   010011E3           TST      R1,#0x1
   \   00000028   0A00000A           BEQ      ??GUIDRV__NoOpt_DrawHLine_0
    324              pfXorPixel = pDevice->pDeviceAPI->pfXorPixel;
   \   0000002C   1C8090E5           LDR      R8,[R0, #+28]
   \   00000030   050057E1           CMP      R7,R5
   \   00000034   150000BA           BLT      ??GUIDRV__NoOpt_DrawHLine_1
    325              for (; x0 <= x1; x0++) {
    326                pfXorPixel(pDevice, x0, y);
   \                     ??GUIDRV__NoOpt_DrawHLine_2:
   \   00000038   0620A0E1           MOV      R2,R6
   \   0000003C   0510A0E1           MOV      R1,R5
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   38FF2FE1           BLX      R8
    327              }
   \   00000048   015085E2           ADD      R5,R5,#+1
   \   0000004C   050057E1           CMP      R7,R5
   \   00000050   F8FFFFAA           BGE      ??GUIDRV__NoOpt_DrawHLine_2
   \   00000054   0D0000EA           B        ??GUIDRV__NoOpt_DrawHLine_1
    328            } else {
    329              pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
   \                     ??GUIDRV__NoOpt_DrawHLine_0:
   \   00000058   188090E5           LDR      R8,[R0, #+24]
    330              ColorIndex = LCD__GetColorIndex();
   \   0000005C   ........           LDR      R0,??DataTable6_1
   \   00000060   050057E1           CMP      R7,R5
   \   00000064   000090E5           LDR      R0,[R0, #+0]
   \   00000068   009090E5           LDR      R9,[R0, #+0]
   \   0000006C   070000BA           BLT      ??GUIDRV__NoOpt_DrawHLine_1
    331              for (; x0 <= x1; x0++) {
    332                pfSetPixelIndex(pDevice, x0, y, ColorIndex);
   \                     ??GUIDRV__NoOpt_DrawHLine_3:
   \   00000070   0930A0E1           MOV      R3,R9
   \   00000074   0620A0E1           MOV      R2,R6
   \   00000078   0510A0E1           MOV      R1,R5
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   38FF2FE1           BLX      R8
    333              }
   \   00000084   015085E2           ADD      R5,R5,#+1
   \   00000088   050057E1           CMP      R7,R5
   \   0000008C   F7FFFFAA           BGE      ??GUIDRV__NoOpt_DrawHLine_3
    334            }
    335          }
   \                     ??GUIDRV__NoOpt_DrawHLine_1:
   \   00000090   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000094   F083BDE8           POP      {R4-R9,PC}       ;; return
    336          
    337          /*********************************************************************
    338          *
    339          *       GUIDRV__NoOpt_DrawVLine, not optimized
    340          */

   \                                 In section .text, align 4, keep-with-next
    341          void GUIDRV__NoOpt_DrawVLine  (GUI_DEVICE * pDevice, int x, int y0,  int y1) {
   \                     GUIDRV__NoOpt_DrawVLine:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    342            LCD_PIXELINDEX ColorIndex;
    343            void (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, int ColorIndex);
    344            void (* pfXorPixel     )(GUI_DEVICE * pDevice, int x, int y);
    345          
    346            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R1,??DataTable6
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000014   04D04DE2           SUB      SP,SP,#+4
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   0370A0E1           MOV      R7,R3
   \   00000020   0C0094E5           LDR      R0,[R4, #+12]
   \   00000024   010011E3           TST      R1,#0x1
   \   00000028   0A00000A           BEQ      ??GUIDRV__NoOpt_DrawVLine_0
    347              pfXorPixel = pDevice->pDeviceAPI->pfXorPixel;
   \   0000002C   1C8090E5           LDR      R8,[R0, #+28]
   \   00000030   060057E1           CMP      R7,R6
   \   00000034   150000BA           BLT      ??GUIDRV__NoOpt_DrawVLine_1
    348              for (; y0 <= y1; y0++) {
    349                pfXorPixel(pDevice, x, y0);
   \                     ??GUIDRV__NoOpt_DrawVLine_2:
   \   00000038   0620A0E1           MOV      R2,R6
   \   0000003C   0510A0E1           MOV      R1,R5
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   38FF2FE1           BLX      R8
    350              }
   \   00000048   016086E2           ADD      R6,R6,#+1
   \   0000004C   060057E1           CMP      R7,R6
   \   00000050   F8FFFFAA           BGE      ??GUIDRV__NoOpt_DrawVLine_2
   \   00000054   0D0000EA           B        ??GUIDRV__NoOpt_DrawVLine_1
    351            } else {
    352              pfSetPixelIndex = pDevice->pDeviceAPI->pfSetPixelIndex;
   \                     ??GUIDRV__NoOpt_DrawVLine_0:
   \   00000058   188090E5           LDR      R8,[R0, #+24]
    353              ColorIndex = LCD__GetColorIndex();
   \   0000005C   ........           LDR      R0,??DataTable6_1
   \   00000060   060057E1           CMP      R7,R6
   \   00000064   000090E5           LDR      R0,[R0, #+0]
   \   00000068   009090E5           LDR      R9,[R0, #+0]
   \   0000006C   070000BA           BLT      ??GUIDRV__NoOpt_DrawVLine_1
    354              for (; y0 <= y1; y0++) {
    355                pfSetPixelIndex(pDevice, x, y0, ColorIndex);
   \                     ??GUIDRV__NoOpt_DrawVLine_3:
   \   00000070   0930A0E1           MOV      R3,R9
   \   00000074   0620A0E1           MOV      R2,R6
   \   00000078   0510A0E1           MOV      R1,R5
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   38FF2FE1           BLX      R8
    356              }
   \   00000084   016086E2           ADD      R6,R6,#+1
   \   00000088   060057E1           CMP      R7,R6
   \   0000008C   F7FFFFAA           BGE      ??GUIDRV__NoOpt_DrawVLine_3
    357            }
    358          }
   \                     ??GUIDRV__NoOpt_DrawVLine_1:
   \   00000090   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000094   F083BDE8           POP      {R4-R9,PC}       ;; return
    359          
    360          /*********************************************************************
    361          *
    362          *       GUIDRV__NoOpt_FillRect
    363          */

   \                                 In section .text, align 4, keep-with-next
    364          void GUIDRV__NoOpt_FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     GUIDRV__NoOpt_FillRect:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   28709DE5           LDR      R7,[SP, #+40]
   \   00000008   0250A0E1           MOV      R5,R2
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0360A0E1           MOV      R6,R3
   \   00000014   050057E1           CMP      R7,R5
   \   00000018   190000BA           BLT      ??GUIDRV__NoOpt_FillRect_0
   \   0000001C   ........           LDR      R8,??DataTable6
    365            for (; y0 <= y1; y0++) {
    366              GUIDRV__NoOpt_DrawHLine(pDevice, x0, y0, x1);
   \                     ??GUIDRV__NoOpt_FillRect_1:
   \   00000020   1010D8E5           LDRB     R1,[R8, #+16]
   \   00000024   00909DE5           LDR      R9,[SP, #+0]
   \   00000028   0C0094E5           LDR      R0,[R4, #+12]
   \   0000002C   010011E3           TST      R1,#0x1
   \   00000030   0A00000A           BEQ      ??GUIDRV__NoOpt_FillRect_2
   \   00000034   1CA090E5           LDR      R10,[R0, #+28]
   \   00000038   090056E1           CMP      R6,R9
   \   0000003C   0D0000BA           BLT      ??GUIDRV__NoOpt_FillRect_3
   \                     ??GUIDRV__NoOpt_FillRect_4:
   \   00000040   0520A0E1           MOV      R2,R5
   \   00000044   0910A0E1           MOV      R1,R9
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   3AFF2FE1           BLX      R10
   \   00000050   019089E2           ADD      R9,R9,#+1
   \   00000054   090056E1           CMP      R6,R9
   \   00000058   F8FFFFAA           BGE      ??GUIDRV__NoOpt_FillRect_4
   \   0000005C   050000EA           B        ??GUIDRV__NoOpt_FillRect_3
   \                     ??GUIDRV__NoOpt_FillRect_2:
   \   00000060   18A090E5           LDR      R10,[R0, #+24]
   \   00000064   ........           LDR      R0,??DataTable6_1
   \   00000068   090056E1           CMP      R6,R9
   \   0000006C   000090E5           LDR      R0,[R0, #+0]
   \   00000070   00B090E5           LDR      R11,[R0, #+0]
   \   00000074   040000AA           BGE      ??GUIDRV__NoOpt_FillRect_5
   \                     ??GUIDRV__NoOpt_FillRect_3:
   \   00000078   015085E2           ADD      R5,R5,#+1
   \   0000007C   050057E1           CMP      R7,R5
   \   00000080   E6FFFFAA           BGE      ??GUIDRV__NoOpt_FillRect_1
    367            }
    368          }
   \                     ??GUIDRV__NoOpt_FillRect_0:
   \   00000084   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000088   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??GUIDRV__NoOpt_FillRect_5:
   \   0000008C   0B30A0E1           MOV      R3,R11
   \   00000090   0520A0E1           MOV      R2,R5
   \   00000094   0910A0E1           MOV      R1,R9
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   3AFF2FE1           BLX      R10
   \   000000A0   019089E2           ADD      R9,R9,#+1
   \   000000A4   090056E1           CMP      R6,R9
   \   000000A8   F7FFFFAA           BGE      ??GUIDRV__NoOpt_FillRect_5
   \   000000AC   F1FFFFEA           B        ??GUIDRV__NoOpt_FillRect_3
    369          
    370          /*********************************************************************
    371          *
    372          *       GUIDRV__NoOpt_DrawBitmap
    373          */

   \                                 In section .text, align 4, keep-with-next
    374          void GUIDRV__NoOpt_DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0,
    375                                 int xSize, int ySize,
    376                                 int BitsPerPixel, 
    377                                 int BytesPerLine,
    378                                 const U8 GUI_UNI_PTR * pData, int Diff,
    379                                 const LCD_PIXELINDEX * pTrans) {
   \                     GUIDRV__NoOpt_DrawBitmap:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   3C009DE5           LDR      R0,[SP, #+60]
   \   00000010   0160A0E1           MOV      R6,R1
    380            int i;
    381          
    382            switch (BitsPerPixel) {
   \   00000014   010040E2           SUB      R0,R0,#+1
   \   00000018   0240A0E1           MOV      R4,R2
   \   0000001C   44909DE5           LDR      R9,[SP, #+68]
   \   00000020   48709DE5           LDR      R7,[SP, #+72]
   \   00000024   4C809DE5           LDR      R8,[SP, #+76]
   \   00000028   1F0050E3           CMP      R0,#+31
   \   0000002C   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??GUIDRV__NoOpt_DrawBitmap_0:
   \   00000030   3701008A           BHI      ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000034   1E0000EA           B        ??GUIDRV__NoOpt_DrawBitmap_2
   \   00000038   4A0000EA           B        ??GUIDRV__NoOpt_DrawBitmap_3
   \   0000003C   340100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000040   750000EA           B        ??GUIDRV__NoOpt_DrawBitmap_4
   \   00000044   320100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000048   310100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   0000004C   300100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000050   9E0000EA           B        ??GUIDRV__NoOpt_DrawBitmap_5
   \   00000054   2E0100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000058   2D0100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   0000005C   2C0100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000060   2B0100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000064   2A0100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000068   290100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   0000006C   280100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000070   C00000EA           B        ??GUIDRV__NoOpt_DrawBitmap_6
   \   00000074   260100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000078   250100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   0000007C   240100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000080   230100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000084   220100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000088   210100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   0000008C   200100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000090   1F0100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000094   1E0100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000098   1D0100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   0000009C   1C0100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   000000A0   1B0100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   000000A4   1A0100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   000000A8   190100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   000000AC   180100EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
   \   000000B0   E40000EA           B        ??GUIDRV__NoOpt_DrawBitmap_7
    383            case 1:
    384              for (i = 0; i < ySize; i++) {
   \                     ??GUIDRV__NoOpt_DrawBitmap_2:
   \   000000B4   38009DE5           LDR      R0,[SP, #+56]
   \   000000B8   010050E3           CMP      R0,#+1
   \   000000BC   140100BA           BLT      ??GUIDRV__NoOpt_DrawBitmap_1
   \   000000C0   00A0A0E1           MOV      R10,R0
   \   000000C4   01001AE3           TST      R10,#0x1
   \   000000C8   0900000A           BEQ      ??GUIDRV__NoOpt_DrawBitmap_8
    385                _DrawBitLine1BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   000000CC   10009DE5           LDR      R0,[SP, #+16]
   \   000000D0   08808DE5           STR      R8,[SP, #+8]
   \   000000D4   04008DE5           STR      R0,[SP, #+4]
   \   000000D8   00708DE5           STR      R7,[SP, #+0]
   \   000000DC   0930A0E1           MOV      R3,R9
   \   000000E0   0500A0E1           MOV      R0,R5
   \   000000E4   ........           BL       _DrawBitLine1BPP
    386                pData += BytesPerLine;
   \   000000E8   40009DE5           LDR      R0,[SP, #+64]
   \   000000EC   014084E2           ADD      R4,R4,#+1
   \   000000F0   099080E0           ADD      R9,R0,R9
   \                     ??GUIDRV__NoOpt_DrawBitmap_8:
   \   000000F4   AAA0B0E1           LSRS     R10,R10,#+1
   \   000000F8   0501000A           BEQ      ??GUIDRV__NoOpt_DrawBitmap_1
   \                     ??GUIDRV__NoOpt_DrawBitmap_9:
   \   000000FC   10009DE5           LDR      R0,[SP, #+16]
   \   00000100   08808DE5           STR      R8,[SP, #+8]
   \   00000104   04008DE5           STR      R0,[SP, #+4]
   \   00000108   00708DE5           STR      R7,[SP, #+0]
   \   0000010C   0930A0E1           MOV      R3,R9
   \   00000110   0420A0E1           MOV      R2,R4
   \   00000114   0610A0E1           MOV      R1,R6
   \   00000118   0500A0E1           MOV      R0,R5
   \   0000011C   ........           BL       _DrawBitLine1BPP
   \   00000120   40009DE5           LDR      R0,[SP, #+64]
   \   00000124   08808DE5           STR      R8,[SP, #+8]
   \   00000128   099080E0           ADD      R9,R0,R9
   \   0000012C   10009DE5           LDR      R0,[SP, #+16]
   \   00000130   00708DE5           STR      R7,[SP, #+0]
   \   00000134   04008DE5           STR      R0,[SP, #+4]
   \   00000138   0930A0E1           MOV      R3,R9
   \   0000013C   012084E2           ADD      R2,R4,#+1
   \   00000140   0610A0E1           MOV      R1,R6
   \   00000144   0500A0E1           MOV      R0,R5
   \   00000148   ........           BL       _DrawBitLine1BPP
   \   0000014C   40009DE5           LDR      R0,[SP, #+64]
    387              }
   \   00000150   01A04AE2           SUB      R10,R10,#+1
   \   00000154   099080E0           ADD      R9,R0,R9
   \   00000158   024084E2           ADD      R4,R4,#+2
   \   0000015C   00005AE3           CMP      R10,#+0
   \   00000160   E5FFFF1A           BNE      ??GUIDRV__NoOpt_DrawBitmap_9
   \   00000164   EA0000EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
    388              break;
    389            case 2:
    390              for (i = 0; i < ySize; i++) {
   \                     ??GUIDRV__NoOpt_DrawBitmap_3:
   \   00000168   38009DE5           LDR      R0,[SP, #+56]
   \   0000016C   010050E3           CMP      R0,#+1
   \   00000170   E70000BA           BLT      ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000174   00A0A0E1           MOV      R10,R0
   \   00000178   01001AE3           TST      R10,#0x1
   \   0000017C   0900000A           BEQ      ??GUIDRV__NoOpt_DrawBitmap_10
    391                _DrawBitLine2BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   00000180   10009DE5           LDR      R0,[SP, #+16]
   \   00000184   08808DE5           STR      R8,[SP, #+8]
   \   00000188   04008DE5           STR      R0,[SP, #+4]
   \   0000018C   00708DE5           STR      R7,[SP, #+0]
   \   00000190   0930A0E1           MOV      R3,R9
   \   00000194   0500A0E1           MOV      R0,R5
   \   00000198   ........           BL       _DrawBitLine2BPP
    392                pData += BytesPerLine;
   \   0000019C   40009DE5           LDR      R0,[SP, #+64]
   \   000001A0   014084E2           ADD      R4,R4,#+1
   \   000001A4   099080E0           ADD      R9,R0,R9
   \                     ??GUIDRV__NoOpt_DrawBitmap_10:
   \   000001A8   AAA0B0E1           LSRS     R10,R10,#+1
   \   000001AC   D800000A           BEQ      ??GUIDRV__NoOpt_DrawBitmap_1
   \                     ??GUIDRV__NoOpt_DrawBitmap_11:
   \   000001B0   10009DE5           LDR      R0,[SP, #+16]
   \   000001B4   08808DE5           STR      R8,[SP, #+8]
   \   000001B8   04008DE5           STR      R0,[SP, #+4]
   \   000001BC   00708DE5           STR      R7,[SP, #+0]
   \   000001C0   0930A0E1           MOV      R3,R9
   \   000001C4   0420A0E1           MOV      R2,R4
   \   000001C8   0610A0E1           MOV      R1,R6
   \   000001CC   0500A0E1           MOV      R0,R5
   \   000001D0   ........           BL       _DrawBitLine2BPP
   \   000001D4   40009DE5           LDR      R0,[SP, #+64]
   \   000001D8   08808DE5           STR      R8,[SP, #+8]
   \   000001DC   099080E0           ADD      R9,R0,R9
   \   000001E0   10009DE5           LDR      R0,[SP, #+16]
   \   000001E4   00708DE5           STR      R7,[SP, #+0]
   \   000001E8   04008DE5           STR      R0,[SP, #+4]
   \   000001EC   0930A0E1           MOV      R3,R9
   \   000001F0   012084E2           ADD      R2,R4,#+1
   \   000001F4   0610A0E1           MOV      R1,R6
   \   000001F8   0500A0E1           MOV      R0,R5
   \   000001FC   ........           BL       _DrawBitLine2BPP
   \   00000200   40009DE5           LDR      R0,[SP, #+64]
    393              }
   \   00000204   01A04AE2           SUB      R10,R10,#+1
   \   00000208   099080E0           ADD      R9,R0,R9
   \   0000020C   024084E2           ADD      R4,R4,#+2
   \   00000210   00005AE3           CMP      R10,#+0
   \   00000214   E5FFFF1A           BNE      ??GUIDRV__NoOpt_DrawBitmap_11
   \   00000218   BD0000EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
    394              break;
    395            case 4:
    396              for (i = 0; i < ySize; i++) {
   \                     ??GUIDRV__NoOpt_DrawBitmap_4:
   \   0000021C   38009DE5           LDR      R0,[SP, #+56]
   \   00000220   010050E3           CMP      R0,#+1
   \   00000224   BA0000BA           BLT      ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000228   00A0A0E1           MOV      R10,R0
   \   0000022C   01001AE3           TST      R10,#0x1
   \   00000230   0900000A           BEQ      ??GUIDRV__NoOpt_DrawBitmap_12
    397                _DrawBitLine4BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   00000234   10009DE5           LDR      R0,[SP, #+16]
   \   00000238   08808DE5           STR      R8,[SP, #+8]
   \   0000023C   04008DE5           STR      R0,[SP, #+4]
   \   00000240   00708DE5           STR      R7,[SP, #+0]
   \   00000244   0930A0E1           MOV      R3,R9
   \   00000248   0500A0E1           MOV      R0,R5
   \   0000024C   ........           BL       _DrawBitLine4BPP
    398                pData += BytesPerLine;
   \   00000250   40009DE5           LDR      R0,[SP, #+64]
   \   00000254   014084E2           ADD      R4,R4,#+1
   \   00000258   099080E0           ADD      R9,R0,R9
   \                     ??GUIDRV__NoOpt_DrawBitmap_12:
   \   0000025C   AAA0B0E1           LSRS     R10,R10,#+1
   \   00000260   AB00000A           BEQ      ??GUIDRV__NoOpt_DrawBitmap_1
   \                     ??GUIDRV__NoOpt_DrawBitmap_13:
   \   00000264   10009DE5           LDR      R0,[SP, #+16]
   \   00000268   08808DE5           STR      R8,[SP, #+8]
   \   0000026C   04008DE5           STR      R0,[SP, #+4]
   \   00000270   00708DE5           STR      R7,[SP, #+0]
   \   00000274   0930A0E1           MOV      R3,R9
   \   00000278   0420A0E1           MOV      R2,R4
   \   0000027C   0610A0E1           MOV      R1,R6
   \   00000280   0500A0E1           MOV      R0,R5
   \   00000284   ........           BL       _DrawBitLine4BPP
   \   00000288   40009DE5           LDR      R0,[SP, #+64]
   \   0000028C   08808DE5           STR      R8,[SP, #+8]
   \   00000290   099080E0           ADD      R9,R0,R9
   \   00000294   10009DE5           LDR      R0,[SP, #+16]
   \   00000298   00708DE5           STR      R7,[SP, #+0]
   \   0000029C   04008DE5           STR      R0,[SP, #+4]
   \   000002A0   0930A0E1           MOV      R3,R9
   \   000002A4   012084E2           ADD      R2,R4,#+1
   \   000002A8   0610A0E1           MOV      R1,R6
   \   000002AC   0500A0E1           MOV      R0,R5
   \   000002B0   ........           BL       _DrawBitLine4BPP
   \   000002B4   40009DE5           LDR      R0,[SP, #+64]
    399              }
   \   000002B8   01A04AE2           SUB      R10,R10,#+1
   \   000002BC   099080E0           ADD      R9,R0,R9
   \   000002C0   024084E2           ADD      R4,R4,#+2
   \   000002C4   00005AE3           CMP      R10,#+0
   \   000002C8   E5FFFF1A           BNE      ??GUIDRV__NoOpt_DrawBitmap_13
   \   000002CC   900000EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
    400              break;
    401            case 8:
    402              for (i = 0; i < ySize; i++) {
   \                     ??GUIDRV__NoOpt_DrawBitmap_5:
   \   000002D0   38009DE5           LDR      R0,[SP, #+56]
   \   000002D4   010050E3           CMP      R0,#+1
   \   000002D8   8D0000BA           BLT      ??GUIDRV__NoOpt_DrawBitmap_1
   \   000002DC   0070A0E1           MOV      R7,R0
   \   000002E0   010017E3           TST      R7,#0x1
   \   000002E4   0800000A           BEQ      ??GUIDRV__NoOpt_DrawBitmap_14
    403                _DrawBitLine8BPP(pDevice, x0, i + y0, pData, xSize, pTrans);
   \   000002E8   10009DE5           LDR      R0,[SP, #+16]
   \   000002EC   04808DE5           STR      R8,[SP, #+4]
   \   000002F0   00008DE5           STR      R0,[SP, #+0]
   \   000002F4   0930A0E1           MOV      R3,R9
   \   000002F8   0500A0E1           MOV      R0,R5
   \   000002FC   ........           BL       _DrawBitLine8BPP
    404                pData += BytesPerLine;
   \   00000300   40009DE5           LDR      R0,[SP, #+64]
   \   00000304   014084E2           ADD      R4,R4,#+1
   \   00000308   099080E0           ADD      R9,R0,R9
   \                     ??GUIDRV__NoOpt_DrawBitmap_14:
   \   0000030C   A770B0E1           LSRS     R7,R7,#+1
   \   00000310   7F00000A           BEQ      ??GUIDRV__NoOpt_DrawBitmap_1
   \                     ??GUIDRV__NoOpt_DrawBitmap_15:
   \   00000314   10009DE5           LDR      R0,[SP, #+16]
   \   00000318   04808DE5           STR      R8,[SP, #+4]
   \   0000031C   00008DE5           STR      R0,[SP, #+0]
   \   00000320   0930A0E1           MOV      R3,R9
   \   00000324   0420A0E1           MOV      R2,R4
   \   00000328   0610A0E1           MOV      R1,R6
   \   0000032C   0500A0E1           MOV      R0,R5
   \   00000330   ........           BL       _DrawBitLine8BPP
   \   00000334   40009DE5           LDR      R0,[SP, #+64]
   \   00000338   04808DE5           STR      R8,[SP, #+4]
   \   0000033C   099080E0           ADD      R9,R0,R9
   \   00000340   10009DE5           LDR      R0,[SP, #+16]
   \   00000344   0930A0E1           MOV      R3,R9
   \   00000348   00008DE5           STR      R0,[SP, #+0]
   \   0000034C   012084E2           ADD      R2,R4,#+1
   \   00000350   0610A0E1           MOV      R1,R6
   \   00000354   0500A0E1           MOV      R0,R5
   \   00000358   ........           BL       _DrawBitLine8BPP
   \   0000035C   40009DE5           LDR      R0,[SP, #+64]
    405              }
   \   00000360   017047E2           SUB      R7,R7,#+1
   \   00000364   099080E0           ADD      R9,R0,R9
   \   00000368   024084E2           ADD      R4,R4,#+2
   \   0000036C   000057E3           CMP      R7,#+0
   \   00000370   E7FFFF1A           BNE      ??GUIDRV__NoOpt_DrawBitmap_15
   \   00000374   660000EA           B        ??GUIDRV__NoOpt_DrawBitmap_1
    406              break;
    407            case 16:
    408              for (i = 0; i < ySize; i++) {
   \                     ??GUIDRV__NoOpt_DrawBitmap_6:
   \   00000378   38009DE5           LDR      R0,[SP, #+56]
   \   0000037C   0010A0E3           MOV      R1,#+0
   \   00000380   00108DE5           STR      R1,[SP, #+0]
   \   00000384   010050E3           CMP      R0,#+1
   \   00000388   610000BA           BLT      ??GUIDRV__NoOpt_DrawBitmap_1
   \   0000038C   04408DE5           STR      R4,[SP, #+4]
    409                _DrawBitLine16BPP(pDevice, x0, i + y0, (const U16 *)pData, xSize);
   \                     ??GUIDRV__NoOpt_DrawBitmap_16:
   \   00000390   0C0095E5           LDR      R0,[R5, #+12]
   \   00000394   0940A0E1           MOV      R4,R9
   \   00000398   18A090E5           LDR      R10,[R0, #+24]
   \   0000039C   10009DE5           LDR      R0,[SP, #+16]
   \   000003A0   04709DE5           LDR      R7,[SP, #+4]
   \   000003A4   0680A0E1           MOV      R8,R6
   \   000003A8   010050E3           CMP      R0,#+1
   \   000003AC   180000BA           BLT      ??GUIDRV__NoOpt_DrawBitmap_17
   \   000003B0   00B0A0E1           MOV      R11,R0
   \   000003B4   01001BE3           TST      R11,#0x1
   \   000003B8   0500000A           BEQ      ??GUIDRV__NoOpt_DrawBitmap_18
   \   000003BC   B230D4E0           LDRH     R3,[R4], #+2
   \   000003C0   0720A0E1           MOV      R2,R7
   \   000003C4   0810A0E1           MOV      R1,R8
   \   000003C8   0500A0E1           MOV      R0,R5
   \   000003CC   3AFF2FE1           BLX      R10
   \   000003D0   018088E2           ADD      R8,R8,#+1
   \                     ??GUIDRV__NoOpt_DrawBitmap_18:
   \   000003D4   ABB0B0E1           LSRS     R11,R11,#+1
   \   000003D8   0D00000A           BEQ      ??GUIDRV__NoOpt_DrawBitmap_17
   \                     ??GUIDRV__NoOpt_DrawBitmap_19:
   \   000003DC   B230D4E0           LDRH     R3,[R4], #+2
   \   000003E0   0720A0E1           MOV      R2,R7
   \   000003E4   0810A0E1           MOV      R1,R8
   \   000003E8   0500A0E1           MOV      R0,R5
   \   000003EC   3AFF2FE1           BLX      R10
   \   000003F0   018088E2           ADD      R8,R8,#+1
   \   000003F4   B230D4E0           LDRH     R3,[R4], #+2
   \   000003F8   0720A0E1           MOV      R2,R7
   \   000003FC   0810A0E1           MOV      R1,R8
   \   00000400   0500A0E1           MOV      R0,R5
   \   00000404   3AFF2FE1           BLX      R10
   \   00000408   018088E2           ADD      R8,R8,#+1
   \   0000040C   01B05BE2           SUBS     R11,R11,#+1
   \   00000410   F1FFFF1A           BNE      ??GUIDRV__NoOpt_DrawBitmap_19
    410                pData += BytesPerLine;
    411              }
   \                     ??GUIDRV__NoOpt_DrawBitmap_17:
   \   00000414   00109DE5           LDR      R1,[SP, #+0]
   \   00000418   40009DE5           LDR      R0,[SP, #+64]
   \   0000041C   011081E2           ADD      R1,R1,#+1
   \   00000420   00108DE5           STR      R1,[SP, #+0]
   \   00000424   04109DE5           LDR      R1,[SP, #+4]
   \   00000428   099080E0           ADD      R9,R0,R9
   \   0000042C   011081E2           ADD      R1,R1,#+1
   \   00000430   04108DE5           STR      R1,[SP, #+4]
   \   00000434   00009DE5           LDR      R0,[SP, #+0]
   \   00000438   38109DE5           LDR      R1,[SP, #+56]
   \   0000043C   010050E1           CMP      R0,R1
   \   00000440   330000AA           BGE      ??GUIDRV__NoOpt_DrawBitmap_1
   \   00000444   D1FFFFEA           B        ??GUIDRV__NoOpt_DrawBitmap_16
    412              break;
    413            case 32:
    414              for (i = 0; i < ySize; i++) {
   \                     ??GUIDRV__NoOpt_DrawBitmap_7:
   \   00000448   38009DE5           LDR      R0,[SP, #+56]
   \   0000044C   0010A0E3           MOV      R1,#+0
   \   00000450   00108DE5           STR      R1,[SP, #+0]
   \   00000454   010050E3           CMP      R0,#+1
   \   00000458   2D0000BA           BLT      ??GUIDRV__NoOpt_DrawBitmap_1
   \   0000045C   04408DE5           STR      R4,[SP, #+4]
    415                _DrawBitLine32BPP(pDevice, x0, i + y0, (const U32 *)pData, xSize);
   \                     ??GUIDRV__NoOpt_DrawBitmap_20:
   \   00000460   0C0095E5           LDR      R0,[R5, #+12]
   \   00000464   0940A0E1           MOV      R4,R9
   \   00000468   18A090E5           LDR      R10,[R0, #+24]
   \   0000046C   10009DE5           LDR      R0,[SP, #+16]
   \   00000470   04709DE5           LDR      R7,[SP, #+4]
   \   00000474   0680A0E1           MOV      R8,R6
   \   00000478   010050E3           CMP      R0,#+1
   \   0000047C   180000BA           BLT      ??GUIDRV__NoOpt_DrawBitmap_21
   \   00000480   00B0A0E1           MOV      R11,R0
   \   00000484   01001BE3           TST      R11,#0x1
   \   00000488   0500000A           BEQ      ??GUIDRV__NoOpt_DrawBitmap_22
   \   0000048C   043094E4           LDR      R3,[R4], #+4
   \   00000490   0720A0E1           MOV      R2,R7
   \   00000494   0810A0E1           MOV      R1,R8
   \   00000498   0500A0E1           MOV      R0,R5
   \   0000049C   3AFF2FE1           BLX      R10
   \   000004A0   018088E2           ADD      R8,R8,#+1
   \                     ??GUIDRV__NoOpt_DrawBitmap_22:
   \   000004A4   ABB0B0E1           LSRS     R11,R11,#+1
   \   000004A8   0D00000A           BEQ      ??GUIDRV__NoOpt_DrawBitmap_21
   \                     ??GUIDRV__NoOpt_DrawBitmap_23:
   \   000004AC   043094E4           LDR      R3,[R4], #+4
   \   000004B0   0720A0E1           MOV      R2,R7
   \   000004B4   0810A0E1           MOV      R1,R8
   \   000004B8   0500A0E1           MOV      R0,R5
   \   000004BC   3AFF2FE1           BLX      R10
   \   000004C0   018088E2           ADD      R8,R8,#+1
   \   000004C4   043094E4           LDR      R3,[R4], #+4
   \   000004C8   0720A0E1           MOV      R2,R7
   \   000004CC   0810A0E1           MOV      R1,R8
   \   000004D0   0500A0E1           MOV      R0,R5
   \   000004D4   3AFF2FE1           BLX      R10
   \   000004D8   018088E2           ADD      R8,R8,#+1
   \   000004DC   01B05BE2           SUBS     R11,R11,#+1
   \   000004E0   F1FFFF1A           BNE      ??GUIDRV__NoOpt_DrawBitmap_23
    416                pData += BytesPerLine;
    417              }
   \                     ??GUIDRV__NoOpt_DrawBitmap_21:
   \   000004E4   00109DE5           LDR      R1,[SP, #+0]
   \   000004E8   40009DE5           LDR      R0,[SP, #+64]
   \   000004EC   011081E2           ADD      R1,R1,#+1
   \   000004F0   00108DE5           STR      R1,[SP, #+0]
   \   000004F4   04109DE5           LDR      R1,[SP, #+4]
   \   000004F8   099080E0           ADD      R9,R0,R9
   \   000004FC   011081E2           ADD      R1,R1,#+1
   \   00000500   04108DE5           STR      R1,[SP, #+4]
   \   00000504   00009DE5           LDR      R0,[SP, #+0]
   \   00000508   38109DE5           LDR      R1,[SP, #+56]
   \   0000050C   010050E1           CMP      R0,R1
   \   00000510   D2FFFFBA           BLT      ??GUIDRV__NoOpt_DrawBitmap_20
    418              break;
    419            }
    420          }
   \                     ??GUIDRV__NoOpt_DrawBitmap_1:
   \   00000514   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000518   F08FBDE8           POP      {R4-R11,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   ........           DC32     LCD_pColorIndex
    421          
    422          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     GUIDRV__NoOpt_DrawBitmap     56
     GUIDRV__NoOpt_DrawHLine      32
     GUIDRV__NoOpt_DrawVLine      32
     GUIDRV__NoOpt_FillRect       40
     GUIDRV__NoOpt_XorPixel       24
     _DrawBitLine1BPP             40
     _DrawBitLine2BPP             40
     _DrawBitLine4BPP             40
     _DrawBitLine8BPP             32


   Section sizes:

     Function/Label           Bytes
     --------------           -----
     _DrawBitLine1BPP          344
     _DrawBitLine2BPP          428
     _DrawBitLine4BPP          428
     _DrawBitLine8BPP          604
     GUIDRV__NoOpt_XorPixel     84
     GUIDRV__NoOpt_DrawHLine   152
     GUIDRV__NoOpt_DrawVLine   152
     GUIDRV__NoOpt_FillRect    176
     GUIDRV__NoOpt_DrawBitmap 1308
     ??DataTable6                4
     ??DataTable6_1              4

 
 3 684 bytes in section .text
 
 3 684 bytes of CODE memory

Errors: none
Warnings: none
