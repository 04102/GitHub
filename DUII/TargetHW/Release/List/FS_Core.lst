###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:14:57 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\FS\FS_Core.c                            #
#    Command line =  C:\DUII\TargetHW\FS\FS_Core.c -D DEBUG=1 -D              #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\FS_Core.lst                #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\FS_Core.o                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\FS\FS_Core.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          **** emFile file system for embedded applications ****
     13          emFile is protected by international copyright laws. Knowledge of the
     14          source code may not be used to write a similar product. This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : FS_Core.c
     19          Purpose     : File system's Core routines
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          /*********************************************************************
     24          *
     25          *       #include Section
     26          *
     27          **********************************************************************
     28          */
     29          
     30          #define FS_CORE_C            // Identify this C-file for header
     31          
     32          #include <stdlib.h>
     33          #include "FS_Int.h"

   \                                 In section .bss, align 4
   \   __absolute FS_GLOBAL FS_Global
   \                     FS_Global:
   \   00000000                      DS8 136
     34          
     35          /*********************************************************************
     36          *
     37          *       #define constants
     38          *
     39          **********************************************************************
     40          */
     41          
     42          
     43          /*********************************************************************
     44          *
     45          *       Static data
     46          *
     47          **********************************************************************
     48          */
     49          #if FS_SUPPORT_EXT_MEM_MANAGER
     50          static FS_PF_ALLOC  *  _pfAlloc;
     51          static FS_PF_FREE   *  _pfFree;
     52          #else

   \                                 In section .bss, align 4
     53          static U32 * _pMem;
   \                     _pMem:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
     54          static U32   _NumBytesAvailable;
     55                 U32   FS_NumBytesAllocated;            // Public for diagnostic purposes only. Allows user to check how much memory was really needed.
   \                     FS_NumBytesAllocated:
   \   00000008                      DS8 4
   \   0000000C                      DS8 4
     56          static U32   _NumAllocs;
     57          #endif
     58          
     59          /*********************************************************************
     60          *
     61          *       Public data
     62          *
     63          **********************************************************************
     64          */
     65          
     66          /*********************************************************************
     67          *
     68          *       Public code
     69          *
     70          **********************************************************************
     71          */
     72          
     73          /*********************************************************************
     74          *
     75          *       FS__DivideU32Up
     76          */

   \                                 In section .text, align 4, keep-with-next
     77          U32 FS__DivideU32Up(U32 Nom, U32 Div) {
     78            return (Nom + Div - 1) / Div;
   \                     FS__DivideU32Up:
   \   00000000   000081E0           ADD      R0,R1,R0
   \   00000004   010040E2           SUB      R0,R0,#+1
   \   00000008   ........           B        __aeabi_uidiv
     79          }
     80          
     81          /*********************************************************************
     82          *
     83          *       FS__strchr
     84          *
     85          *  Description:
     86          *    FS internal function. Locate the first occurrence of c (converted
     87          *    to a char) in the string pointed to by s.
     88          *
     89          *  Parameters:
     90          *    s           - Pointer to a zero terminated string.
     91          *    c           - 'Character' value to find.
     92          *
     93          *  Return value:
     94          *    NULL        - c was not found
     95          *    != NULL     - Pointer to the located character in s.
     96          */

   \                                 In section .text, align 4, keep-with-next
     97          const char * FS__strchr(const char *s, int c) {
     98            const char ch = c;
   \                     FS__strchr:
   \   00000000   FF1001E2           AND      R1,R1,#0xFF
     99          
    100            for (; *s != ch; ++s) {
   \                     ??FS__strchr_0:
   \   00000004   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000008   010052E1           CMP      R2,R1
   \   0000000C   0300000A           BEQ      ??FS__strchr_1
    101              if (*s == '\0') {
   \   00000010   0120D0E4           LDRB     R2,[R0], #+1
   \   00000014   000052E3           CMP      R2,#+0
   \   00000018   F9FFFF1A           BNE      ??FS__strchr_0
    102                return (const char *)0;
   \   0000001C   0000A0E3           MOV      R0,#+0
    103              }
    104            }
    105            return s;
   \                     ??FS__strchr_1:
   \   00000020   1EFF2FE1           BX       LR               ;; return
    106          }
    107          
    108          /*********************************************************************
    109          *
    110          *       FS_SetBusyLEDCallback
    111          *
    112          */

   \                                 In section .text, align 4, keep-with-next
    113          void FS_SetBusyLEDCallback(const char * sVolumeName, FS_BUSY_LED_CALLBACK * pfBusyLEDCallback) {
    114          #if FS_SUPPORT_BUSY_LED
    115            FS_VOLUME * pVolume;
    116            FS_LOCK();
    117            if (sVolumeName) {
    118              pVolume = FS__FindVolume(sVolumeName, NULL);
    119              FS_LOCK_SYS();
    120              if (pVolume) {
    121                pVolume->Partition.Device.Data.pfSetBusyLED = pfBusyLEDCallback;
    122              }
    123              FS_UNLOCK_SYS();
    124            }
    125            FS_UNLOCK();
    126          #else
    127            FS_USE_PARA(sVolumeName);
    128            FS_USE_PARA(pfBusyLEDCallback);
    129            FS_DEBUG_WARN((FS_MTYPE_STORAGE,"FS_SetBusyLEDCallback() has no function because FS_SUPPORT_BUSY_LED is disabled."));
    130          #endif
    131          }
   \                     FS_SetBusyLEDCallback:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    132          
    133          /*********************************************************************
    134          *
    135          *       FS_SetMemAccessCallback
    136          *
    137          */

   \                                 In section .text, align 4, keep-with-next
    138          void FS_SetMemAccessCallback(const char * sVolumeName, FS_MEMORY_IS_ACCESSIBLE_CALLBACK * pfIsAccessibleCallback) {
    139          #if FS_SUPPORT_CHECK_MEMORY
    140            FS_VOLUME * pVolume;
    141            FS_LOCK();
    142            if (sVolumeName) {
    143              pVolume = FS__FindVolume(sVolumeName, NULL);
    144              FS_LOCK_SYS();
    145              if (pVolume) {
    146                pVolume->Partition.Device.Data.pfMemoryIsAccessible = pfIsAccessibleCallback;
    147              }
    148              FS_UNLOCK_SYS();
    149            }
    150            FS_UNLOCK();
    151          #else
    152            FS_USE_PARA(sVolumeName)
    153            FS_USE_PARA(pfIsAccessibleCallback);
    154            FS_DEBUG_WARN((FS_MTYPE_API, "FS_SetMemAccessCallback() has no function because FS_SUPPORT_CHECK_MEMORY is disabled."));
    155          #endif
    156          }
   \                     FS_SetMemAccessCallback:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    157          
    158          
    159          /*********************************************************************
    160          *
    161          *       FS_LoadU16BE
    162          *
    163          *  Function description:
    164          *    Reads a 16 bit value stored in big endian format from a byte array.
    165          */

   \                                 In section .text, align 4, keep-with-next
    166          U16 FS_LoadU16BE(const U8 *pBuffer) {
    167            U16 r;
    168            r = *pBuffer++;
   \                     FS_LoadU16BE:
   \   00000000   0010D0E5           LDRB     R1,[R0, #+0]
    169            r = (r << 8) | *pBuffer;
    170            return r;
   \   00000004   0120F0E5           LDRB     R2,[R0, #+1]!
   \   00000008   010482E1           ORR      R0,R2,R1, LSL #+8
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    171          }
    172          
    173          /*********************************************************************
    174          *
    175          *       FS_LoadU32BE
    176          *
    177          *  Function description:
    178          *    Reads a 32 bit value stored in big endian format from a byte array.
    179          */

   \                                 In section .text, align 4, keep-with-next
    180          U32 FS_LoadU32BE(const U8 *pBuffer) {
    181            U32 r;
    182            r = *pBuffer++;
   \                     FS_LoadU32BE:
   \   00000000   0010D0E5           LDRB     R1,[R0, #+0]
    183            r = (r << 8) | *pBuffer++;
   \   00000004   0120F0E5           LDRB     R2,[R0, #+1]!
   \   00000008   011482E1           ORR      R1,R2,R1, LSL #+8
    184            r = (r << 8) | *pBuffer++;
   \   0000000C   0120F0E5           LDRB     R2,[R0, #+1]!
   \   00000010   011482E1           ORR      R1,R2,R1, LSL #+8
    185            r = (r << 8) | *pBuffer;
    186            return r;
   \   00000014   0120F0E5           LDRB     R2,[R0, #+1]!
   \   00000018   010482E1           ORR      R0,R2,R1, LSL #+8
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    187          }
    188          
    189          /*********************************************************************
    190          *
    191          *       FS_StoreU16BE
    192          *
    193          *  Function description:
    194          *    Stores a 16 bit value in big endian format into a byte array.
    195          */

   \                                 In section .text, align 4, keep-with-next
    196          void FS_StoreU16BE(U8 *pBuffer, unsigned Data) {
    197            *pBuffer++ = (U8)(Data >> 8);
   \                     FS_StoreU16BE:
   \   00000000   2124A0E1           LSR      R2,R1,#+8
   \   00000004   0020C0E5           STRB     R2,[R0, #+0]
    198            *pBuffer   = (U8) Data;
   \   00000008   0110E0E5           STRB     R1,[R0, #+1]!
    199          }
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    200          
    201          /*********************************************************************
    202          *
    203          *       FS_StoreU32BE
    204          *
    205          *  Function description:
    206          *    Stores a 32 bit value in big endian format into a byte array.
    207          */

   \                                 In section .text, align 4, keep-with-next
    208          void FS_StoreU32BE(U8 *pBuffer, U32 Data) {
    209            *pBuffer++ = (U8)(Data >> 24);
   \                     FS_StoreU32BE:
   \   00000000   212CA0E1           LSR      R2,R1,#+24
   \   00000004   0020C0E5           STRB     R2,[R0, #+0]
    210            *pBuffer++ = (U8)(Data >> 16);
   \   00000008   2128A0E1           LSR      R2,R1,#+16
   \   0000000C   0120E0E5           STRB     R2,[R0, #+1]!
    211            *pBuffer++ = (U8)(Data >> 8);
   \   00000010   2124A0E1           LSR      R2,R1,#+8
   \   00000014   0120E0E5           STRB     R2,[R0, #+1]!
    212            *pBuffer   = (U8) Data;
   \   00000018   0110E0E5           STRB     R1,[R0, #+1]!
    213          }
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    214          
    215          
    216          /*********************************************************************
    217          *
    218          *       FS_LoadU32LE
    219          *
    220          *  Function description:
    221          *    Reads a 32 bit little endian from a char array.
    222          *
    223          *  Parameters:
    224          *    pBuffer     - Pointer to a char array.
    225          *
    226          *  Return value:
    227          *    result      - The value as U32 data type
    228          *
    229          */

   \                                 In section .text, align 4, keep-with-next
    230          U32 FS_LoadU32LE(const U8 *pBuffer) {
    231            U32 r;
    232            r = (U32)pBuffer[3] & 0x000000FF;
    233            r <<= 8;
    234            r += (U32)pBuffer[2] & 0x000000FF;
    235            r <<= 8;
    236            r += (U32)pBuffer[1] & 0x000000FF;
    237            r <<= 8;
    238            r += (U32)pBuffer[0] & 0x000000FF;
    239            return r;
   \                     FS_LoadU32LE:
   \   00000000   0310D0E5           LDRB     R1,[R0, #+3]
   \   00000004   0220D0E5           LDRB     R2,[R0, #+2]
   \   00000008   011482E0           ADD      R1,R2,R1, LSL #+8
   \   0000000C   0120D0E5           LDRB     R2,[R0, #+1]
   \   00000010   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000014   011482E0           ADD      R1,R2,R1, LSL #+8
   \   00000018   010480E0           ADD      R0,R0,R1, LSL #+8
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    240          }
    241          
    242          /*********************************************************************
    243          *
    244          *       FS_StoreU32LE
    245          *
    246          *  Function description:
    247          *    Stores 32 bits little endian into memory.
    248          */

   \                                 In section .text, align 4, keep-with-next
    249          void FS_StoreU32LE(U8 *pBuffer, U32 Data) {
    250            *pBuffer++ = (U8)Data;
   \                     FS_StoreU32LE:
   \   00000000   0010C0E5           STRB     R1,[R0, #+0]
    251            Data >>= 8;
   \   00000004   2114A0E1           LSR      R1,R1,#+8
    252            *pBuffer++ = (U8)Data;
   \   00000008   0110E0E5           STRB     R1,[R0, #+1]!
    253            Data >>= 8;
   \   0000000C   2114A0E1           LSR      R1,R1,#+8
    254            *pBuffer++ = (U8)Data;
   \   00000010   0110E0E5           STRB     R1,[R0, #+1]!
    255            Data >>= 8;
    256            *pBuffer   = (U8)Data;
   \   00000014   2114A0E1           LSR      R1,R1,#+8
   \   00000018   0110E0E5           STRB     R1,[R0, #+1]!
    257          }
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    258          
    259          /*********************************************************************
    260          *
    261          *       FS_StoreU24LE
    262          *
    263          *  Function description:
    264          *    Stores 24 bits little endian into memory.
    265          */

   \                                 In section .text, align 4, keep-with-next
    266          void FS_StoreU24LE(U8 *pBuffer, U32 Data) {
    267            *pBuffer++ = (U8)Data;
   \                     FS_StoreU24LE:
   \   00000000   0010C0E5           STRB     R1,[R0, #+0]
    268            Data >>= 8;
   \   00000004   2114A0E1           LSR      R1,R1,#+8
    269            *pBuffer++ = (U8)Data;
   \   00000008   0110E0E5           STRB     R1,[R0, #+1]!
    270            Data >>= 8;
    271            *pBuffer = (U8)Data;
   \   0000000C   2114A0E1           LSR      R1,R1,#+8
   \   00000010   0110E0E5           STRB     R1,[R0, #+1]!
    272          }
   \   00000014   1EFF2FE1           BX       LR               ;; return
    273          
    274          /*********************************************************************
    275          *
    276          *       FS_StoreU16LE
    277          *
    278          *  Function description:
    279          *    Writes 16 bit little endian.
    280          */

   \                                 In section .text, align 4, keep-with-next
    281          void FS_StoreU16LE(U8 *pBuffer, unsigned Data) {
    282            *pBuffer++ = (U8)Data;
   \                     FS_StoreU16LE:
   \   00000000   0010C0E5           STRB     R1,[R0, #+0]
    283            Data >>= 8;
    284            *pBuffer = (U8)Data;
   \   00000004   2114A0E1           LSR      R1,R1,#+8
   \   00000008   0110E0E5           STRB     R1,[R0, #+1]!
    285          }
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    286          
    287          /*********************************************************************
    288          *
    289          *       FS_LoadU16LE
    290          *
    291          *  Function description:
    292          *    Reads a 16 bit little endian from a char array.
    293          *
    294          *  Parameters:
    295          *    pBuffer     - Pointer to a char array.
    296          *
    297          *  Return value:
    298          *    The value as U16 data type
    299          *
    300          *  Notes
    301          *    (1) This cast should not be necessary, but on some compilers (NC30)
    302          *        it is required in higher opt. levels since otherwise the
    303          *        argument promotion to integer size is skipped, leading to wrong result of 0.
    304          *
    305          */

   \                                 In section .text, align 4, keep-with-next
    306          U16 FS_LoadU16LE(const U8 *pBuffer) {
    307            U16 r;
    308            r = (U16)(*pBuffer | ((unsigned)*(pBuffer + 1) << 8));
    309            return r;
   \                     FS_LoadU16LE:
   \   00000000   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000004   0100D0E5           LDRB     R0,[R0, #+1]
   \   00000008   000481E1           ORR      R0,R1,R0, LSL #+8
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    310          }
    311          
    312          /*********************************************************************
    313          *
    314          *       FS_STORAGE_Init
    315          *
    316          *  Function description:
    317          *    This function only initializes the driver and OS if necessary.
    318          *    It stores then the information of the drivers in FS__aVolume.
    319          *    This allows to use the file system as a pure sector read/write
    320          *    software. This can be useful when using the file system as
    321          *    USB mass storage client driver.
    322          *
    323          *  Return value:
    324          *    The return value is used to tell the high level init how many
    325          *    drivers can be used at the same time. The function will accordingly
    326          *    allocate the sectors buffers that are necessary for a FS operation.
    327          *
    328          */

   \                                 In section .text, align 4, keep-with-next
    329          unsigned FS_STORAGE_Init(void) {
   \                     FS_STORAGE_Init:
   \   00000000   10402DE9           PUSH     {R4,LR}
    330            unsigned NumDriverLocks;
    331            unsigned NumLocks;
    332          
    333            NumDriverLocks = 0;
    334            if (FS_Global.IsInited == 0) {
   \   00000004   ........           LDR      R4,??DataTable7
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   1210D4E5           LDRB     R1,[R4, #+18]
   \   00000010   000051E3           CMP      R1,#+0
   \   00000014   0800001A           BNE      ??FS_STORAGE_Init_0
    335              //
    336              // Setup the default value for max sector size
    337              //
    338              FS_Global.MaxSectorSize = 512;
   \   00000018   800FA0E3           MOV      R0,#+512
   \   0000001C   B001C4E1           STRH     R0,[R4, #+16]
    339              //
    340              //  Add all drivers that should be used
    341              //
    342              FS_X_AddDevices();
   \   00000020   ........           BL       FS_X_AddDevices
    343              //
    344              //  Calc the number of locks that are needed.
    345              //
    346              NumDriverLocks = FS_OS_GETNUM_DRIVERLOCKS();
    347              NumLocks       = FS_OS_GETNUM_SYSLOCKS() + NumDriverLocks;
    348              //
    349              //  Tell OS layer how many locks are necessary
    350              //
    351              FS_OS_INIT(NumLocks);
   \   00000024   0100A0E3           MOV      R0,#+1
   \   00000028   ........           BL       FS_OS_Init
    352              FS_USE_PARA(NumLocks);
    353          #if (FS_OS_LOCK_PER_DRIVER == 0)
    354              NumDriverLocks++;
    355          #endif
    356              FS_Global.IsInited |= (1 << 0);  // Set InitStatus to FS-Storage init state.
   \   0000002C   1210D4E5           LDRB     R1,[R4, #+18]
   \   00000030   0100A0E3           MOV      R0,#+1
   \   00000034   011081E3           ORR      R1,R1,#0x1
   \   00000038   1210C4E5           STRB     R1,[R4, #+18]
    357            }
    358            return NumDriverLocks;
   \                     ??FS_STORAGE_Init_0:
   \   0000003C   1080BDE8           POP      {R4,PC}          ;; return
    359          }
    360          
    361          /*********************************************************************
    362          *
    363          *       FS_SetMaxSectorSize
    364          *
    365          *  Function description:
    366          *    Sets the max sector size that can be used.
    367          *
    368          */

   \                                 In section .text, align 4, keep-with-next
    369          void FS_SetMaxSectorSize(unsigned MaxSectorSize) {
    370            if (FS_Global.IsInited != 3) {
   \                     FS_SetMaxSectorSize:
   \   00000000   ........           LDR      R1,??DataTable7
   \   00000004   1220D1E5           LDRB     R2,[R1, #+18]
   \   00000008   030052E3           CMP      R2,#+3
    371              if (MaxSectorSize & 0xFE00)
   \   0000000C   FE0C1013           TSTNE    R0,#0xFE00
    372              // ToDO: Check MaxSectorSize for valid value ( 512, 1024, 2048 ...)
    373              FS_Global.MaxSectorSize = MaxSectorSize;
   \   00000010   B001C111           STRHNE   R0,[R1, #+16]
    374            } else {
    375              FS_DEBUG_WARN((FS_MTYPE_API, "FS_SetMaxSectorSize() can only be called before FS_Init() or in FS_X_AddDevices()."));
    376            }
    377          }
   \   00000014   1EFF2FE1           BX       LR               ;; return
    378          
    379          #if FS_SUPPORT_DEINIT
    380          
    381          
    382          static void _RemoveFileHandles(void) {
    383            FS_FILE * pFile;
    384          
    385            pFile = FS_Global.pFirstFilehandle;
    386            while (pFile) {
    387              FS_FILE * pFileNext;
    388          
    389              pFileNext = pFile->pNext;
    390              FS_Free(pFile);
    391              pFile = pFileNext;
    392            }
    393          }
    394          
    395          static void _RemoveFileObjects(void) {
    396            FS_FILE_OBJ * pFileObj;
    397          
    398            pFileObj = FS_Global.pFirstFileObj;
    399            while (pFileObj) {
    400              FS_FILE_OBJ * pFileObjNext;
    401          
    402              pFileObjNext = pFileObj->pNext;
    403              FS_Free(pFileObj);
    404              pFileObj = pFileObjNext;
    405            }
    406          
    407          }
    408          
    409          /*********************************************************************
    410          *
    411          *       FS_STORAGE_DeInit
    412          *
    413          *  Function description:
    414          *    Deinitialize the storage layer.
    415          *
    416          */
    417          void FS_STORAGE_DeInit(void) {
    418            if (FS_Global.IsInited & 1) {
    419              FS__RemoveDevices();
    420              FS_OS_DEINIT();
    421              FS_Global.IsInited &= ~(1 << 0);  // Set InitStatus to FS-Storage init state.
    422            }
    423          }
    424          
    425          /*********************************************************************
    426          *
    427          *       FS_DeInit
    428          *
    429          *  Function description:
    430          *    Deinitialize the file system.
    431          *
    432          */
    433          void FS_DeInit(void) {
    434            //
    435            // Allocate memory for sector buffers
    436            //
    437            FS_STORAGE_DeInit();
    438            if (FS_Global.IsInited & 2) {
    439              //
    440              // Free memory that was used by sector buffers.
    441              //
    442              FS_Free(FS_Global.paSectorBuffer->pBuffer);
    443              FS_Free(FS_Global.paSectorBuffer);
    444              FS_Global.NumSectorBuffers = 0;
    445              _RemoveFileObjects();
    446              _RemoveFileHandles();
    447              FS_Global.IsInited &= ~(1 << 1);  // Set InitStatus to FS-Complete init state.
    448            }
    449          }
    450          
    451          #endif
    452          
    453          
    454          
    455          #if FS_SUPPORT_EXT_MEM_MANAGER
    456          
    457          /*********************************************************************
    458          *
    459          *       _Alloc
    460          *
    461          *  Function description
    462          *    As the name indicates, this function provides memory to the File system.
    463          *
    464          *
    465          */
    466          static void * _Alloc(I32 NumBytes) {
    467            void * p;
    468          
    469            p = NULL;
    470            FS_DEBUG_LOG((FS_MTYPE_MEM, "Allocating %ld bytes.\n", NumBytes));
    471            if (_pfAlloc) {
    472              p = (_pfAlloc)(NumBytes);
    473            }
    474            return p;
    475          }
    476          
    477          
    478          /*********************************************************************
    479          *
    480          *       FS_Alloc
    481          *
    482          *  Function description
    483          *    As the name indicates, this function provides memory to the File system.
    484          *    In case there is no memory or the allocation routine is not available/set
    485          *    this will cause a FS PANIC.
    486          *
    487          *
    488          */
    489          void * FS_Alloc(I32 NumBytes) {
    490            void * p;
    491          
    492            p = _Alloc(NumBytes);
    493            if (p == NULL) {
    494              FS_X_Panic(FS_ERROR_ALLOC);
    495            }
    496            return p;
    497          }
    498          #else
    499          
    500          /*********************************************************************
    501          *
    502          *       _Alloc
    503          *
    504          *  Function description
    505          *    Semi-dynamic memory allocation.
    506          *    This function is called during FS_Init() to allocate memory required
    507          *    for the different components of the file system.
    508          *    Since in a typical embedded application this process is not reversed,
    509          *    there is no counterpart such as "Free()", which helps us to keep the
    510          *    allocation function very simple and associated memory overhead small.
    511          */
    512          static void * _Alloc(U32 NumBytes) {
    513            void * p;
    514          
    515            FS_DEBUG_LOG((FS_MTYPE_MEM, "Allocating %ld bytes.\n", NumBytes));
    516            if (_pMem == NULL) {
    517              FS_DEBUG_ERROROUT((FS_MTYPE_API, "No memory assigned yet, FS_AssignMemory() must be called before!\n"));
    518          #if FS_DEBUG_LEVEL >= FS_DEBUG_LEVEL_CHECK_PARA
    519              FS_X_Panic(FS_ERROR_ALLOC);
    520          #endif
    521            }
    522            NumBytes = (NumBytes + 3) & ~3UL;     // Round upwards to a multiple of 4 (memory is managed in 32-bit units)
    523            if (NumBytes + FS_NumBytesAllocated > _NumBytesAvailable) {
    524              return NULL;                      // Out of memory. Fatal error caught in caller.
    525            }
    526            p                     = ((U8 *)(_pMem) + FS_NumBytesAllocated);
    527            FS_NumBytesAllocated += NumBytes;
    528            _NumAllocs++;
    529            return p;
    530          }
    531          
    532          /*********************************************************************
    533          *
    534          *       FS_Alloc
    535          *
    536          *  Function description
    537          *    As the name indicates, this function provides memory to the File system.
    538          *
    539          *  Notes
    540          *    (1)  Fragmentation
    541          *         The file system allocates memory only in the configuration phase, not during
    542          *         normal operation, so that fragmentation should not occur.
    543          *    (2)  Failure
    544          *         Since the memory is required for proper operation of the file system,
    545          *         this function does not return on failure.
    546          *         In case of a configuration problem where insufficient memory is available
    547          *         to the application, this is normally detected by the programmer in the debug phase.
    548          *
    549          */

   \                                 In section .text, align 4, keep-with-next
    550          void * FS_Alloc(I32 NumBytes) {
   \                     FS_Alloc:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    551            void * p;
    552          
    553            p = _Alloc(NumBytes);
   \   00000004   ........           LDR      R4,??DataTable7_1
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   000094E5           LDR      R0,[R4, #+0]
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0100001A           BNE      ??FS_Alloc_0
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   ........           BL       FS_X_Panic
   \                     ??FS_Alloc_0:
   \   00000024   030085E2           ADD      R0,R5,#+3
   \   00000028   081094E5           LDR      R1,[R4, #+8]
   \   0000002C   0300C0E3           BIC      R0,R0,#0x3
   \   00000030   002081E0           ADD      R2,R1,R0
   \   00000034   040094E5           LDR      R0,[R4, #+4]
   \   00000038   020050E1           CMP      R0,R2
   \   0000003C   0700003A           BCC      ??FS_Alloc_1
   \   00000040   000094E5           LDR      R0,[R4, #+0]
   \   00000044   082084E5           STR      R2,[R4, #+8]
   \   00000048   000081E0           ADD      R0,R1,R0
   \   0000004C   0C1094E5           LDR      R1,[R4, #+12]
    554            if (!p) {
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   011081E2           ADD      R1,R1,#+1
   \   00000058   0C1084E5           STR      R1,[R4, #+12]
   \   0000005C   0200001A           BNE      ??FS_Alloc_2
    555              FS_DEBUG_ERROROUT((FS_MTYPE_API, "Could not allocate memory!\n"));
    556          #if FS_DEBUG_LEVEL >= FS_DEBUG_LEVEL_CHECK_PARA
    557              FS_X_Panic(FS_ERROR_ALLOC);
   \                     ??FS_Alloc_1:
   \   00000060   0100A0E3           MOV      R0,#+1
   \   00000064   ........           BL       FS_X_Panic
    558          #endif
    559              while (1);                // Do NOT remove since the file system assumes allocation to work.
   \                     ??FS_Alloc_3:
   \   00000068   FEFFFFEA           B        ??FS_Alloc_3
    560            }
    561            return p;
   \                     ??FS_Alloc_2:
   \   0000006C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000070   3080BDE8           POP      {R4,R5,PC}       ;; return
    562          }
    563          #endif
    564          
    565          /*********************************************************************
    566          *
    567          *       FS_TryAlloc
    568          *
    569          *  Function description
    570          *    Semi-dynamic memory allocation.
    571          *    This function is called primarily during Init.
    572          *    by different components of the file system.
    573          *    Since in a typical embedded application this process is not reversed,
    574          *    there is no counterpart such as "Free()", which helps us to keep the
    575          *    allocation function very simple and associated memory overhead small.
    576          *
    577          */

   \                                 In section .text, align 4, keep-with-next
    578          void * FS_TryAlloc(I32 NumBytesReq) {
   \                     FS_TryAlloc:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    579            void * p;
    580          
    581            p = _Alloc(NumBytesReq);
   \   00000004   ........           LDR      R4,??DataTable7_1
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   000094E5           LDR      R0,[R4, #+0]
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0100001A           BNE      ??FS_TryAlloc_0
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   ........           BL       FS_X_Panic
   \                     ??FS_TryAlloc_0:
   \   00000024   030085E2           ADD      R0,R5,#+3
   \   00000028   081094E5           LDR      R1,[R4, #+8]
   \   0000002C   0300C0E3           BIC      R0,R0,#0x3
   \   00000030   002081E0           ADD      R2,R1,R0
   \   00000034   040094E5           LDR      R0,[R4, #+4]
   \   00000038   020050E1           CMP      R0,R2
   \   0000003C   0600003A           BCC      ??FS_TryAlloc_1
   \   00000040   000094E5           LDR      R0,[R4, #+0]
   \   00000044   082084E5           STR      R2,[R4, #+8]
   \   00000048   000081E0           ADD      R0,R1,R0
   \   0000004C   0C1094E5           LDR      R1,[R4, #+12]
   \   00000050   011081E2           ADD      R1,R1,#+1
   \   00000054   0C1084E5           STR      R1,[R4, #+12]
   \   00000058   000000EA           B        ??FS_TryAlloc_2
   \                     ??FS_TryAlloc_1:
   \   0000005C   0000A0E3           MOV      R0,#+0
    582            return p;
   \                     ??FS_TryAlloc_2:
   \   00000060   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000064   3080BDE8           POP      {R4,R5,PC}       ;; return
    583          }
    584          
    585          
    586          /*********************************************************************
    587          *
    588          *       FS_AllocZeroed
    589          */

   \                                 In section .text, align 4, keep-with-next
    590          void * FS_AllocZeroed(I32 NumBytes) {
   \                     FS_AllocZeroed:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    591            void * p;
    592          
    593            p = FS_Alloc(NumBytes);
   \   00000004   ........           LDR      R5,??DataTable7_1
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   000095E5           LDR      R0,[R5, #+0]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0100001A           BNE      ??FS_AllocZeroed_0
   \   00000018   0100A0E3           MOV      R0,#+1
   \   0000001C   ........           BL       FS_X_Panic
   \                     ??FS_AllocZeroed_0:
   \   00000020   030084E2           ADD      R0,R4,#+3
   \   00000024   081095E5           LDR      R1,[R5, #+8]
   \   00000028   0300C0E3           BIC      R0,R0,#0x3
   \   0000002C   042095E5           LDR      R2,[R5, #+4]
   \   00000030   000081E0           ADD      R0,R1,R0
   \   00000034   000052E1           CMP      R2,R0
   \   00000038   0C00003A           BCC      ??FS_AllocZeroed_1
   \   0000003C   080085E5           STR      R0,[R5, #+8]
   \   00000040   002095E5           LDR      R2,[R5, #+0]
   \   00000044   0C0095E5           LDR      R0,[R5, #+12]
   \   00000048   026081E0           ADD      R6,R1,R2
   \   0000004C   010080E2           ADD      R0,R0,#+1
   \   00000050   0C0085E5           STR      R0,[R5, #+12]
   \   00000054   000056E3           CMP      R6,#+0
   \   00000058   0400000A           BEQ      ??FS_AllocZeroed_1
    594            FS_MEMSET(p, 0, NumBytes);           // Note: p must be valid, no need to check.
   \   0000005C   0410A0E1           MOV      R1,R4
   \   00000060   0600A0E1           MOV      R0,R6
   \   00000064   ........           BL       __aeabi_memclr
    595            return p;
   \   00000068   0600A0E1           MOV      R0,R6
   \   0000006C   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??FS_AllocZeroed_1:
   \   00000070   0100A0E3           MOV      R0,#+1
   \   00000074   ........           BL       FS_X_Panic
   \                     ??FS_AllocZeroed_2:
   \   00000078   FEFFFFEA           B        ??FS_AllocZeroed_2
    596          }
    597          
    598          /*********************************************************************
    599          *
    600          *       FS_AllocZeroedPtr
    601          *
    602          *  Function description
    603          *    Makes sure that zeroed memory is allocated to the specified pointer.
    604          *    If pointer is NULL, memory is allocated and pointer is updated.
    605          *    In either case memory is zeroed.
    606          *
    607          */

   \                                 In section .text, align 4, keep-with-next
    608          void FS_AllocZeroedPtr(void ** pp, I32 NumBytes) {
   \                     FS_AllocZeroedPtr:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    609            void * p;
    610          
    611            p = *pp;
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   0150A0E1           MOV      R5,R1
    612            if (p == NULL) {
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   1500001A           BNE      ??FS_AllocZeroedPtr_0
    613              p   = FS_Alloc(NumBytes);
   \   00000018   ........           LDR      R6,??DataTable7_1
   \   0000001C   000096E5           LDR      R0,[R6, #+0]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0100001A           BNE      ??FS_AllocZeroedPtr_1
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   ........           BL       FS_X_Panic
   \                     ??FS_AllocZeroedPtr_1:
   \   00000030   030085E2           ADD      R0,R5,#+3
   \   00000034   081096E5           LDR      R1,[R6, #+8]
   \   00000038   0300C0E3           BIC      R0,R0,#0x3
   \   0000003C   002081E0           ADD      R2,R1,R0
   \   00000040   040096E5           LDR      R0,[R6, #+4]
   \   00000044   020050E1           CMP      R0,R2
   \   00000048   0B00003A           BCC      ??FS_AllocZeroedPtr_2
   \   0000004C   000096E5           LDR      R0,[R6, #+0]
   \   00000050   082086E5           STR      R2,[R6, #+8]
   \   00000054   000081E0           ADD      R0,R1,R0
   \   00000058   0C1096E5           LDR      R1,[R6, #+12]
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   011081E2           ADD      R1,R1,#+1
   \   00000064   0C1086E5           STR      R1,[R6, #+12]
   \   00000068   0300000A           BEQ      ??FS_AllocZeroedPtr_2
    614              *pp = p;
   \   0000006C   000084E5           STR      R0,[R4, #+0]
    615            }
    616            FS_MEMSET(p, 0, NumBytes);    // Note: p must be valid, no need to check.
   \                     ??FS_AllocZeroedPtr_0:
   \   00000070   0510A0E1           MOV      R1,R5
   \   00000074   7040BDE8           POP      {R4-R6,LR}
   \   00000078   ........           B        __aeabi_memclr   ;; tailcall
   \                     ??FS_AllocZeroedPtr_2:
   \   0000007C   0100A0E3           MOV      R0,#+1
   \   00000080   ........           BL       FS_X_Panic
   \                     ??FS_AllocZeroedPtr_3:
   \   00000084   FEFFFFEA           B        ??FS_AllocZeroedPtr_3
    617          }
    618          
    619          
    620          
    621          /*********************************************************************
    622          *
    623          *       FS_Free
    624          *
    625          *  Function description
    626          *    Frees a memory block, that was allocated by FS_Alloc().
    627          *
    628          */

   \                                 In section .text, align 4, keep-with-next
    629          void FS_Free(void * p) {
    630            FS_USE_PARA(p);
    631          #if FS_SUPPORT_DEINIT
    632          #if FS_SUPPORT_EXT_MEM_MANAGER
    633            if (_pfFree) {
    634              _pfFree(p);
    635            }
    636          #else
    637            if (p) {
    638              p = NULL;
    639              if (--_NumAllocs == 0) {
    640                FS_NumBytesAllocated = 0;
    641              }
    642            }
    643          #endif
    644          #endif
    645          }
   \                     FS_Free:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    646          
    647          /*********************************************************************
    648          *
    649          *       FS_AssignMemory
    650          *
    651          *  Function description
    652          *    This function is called in the init phase.
    653          */

   \                                 In section .text, align 4, keep-with-next
    654          void FS_AssignMemory(U32 *pMem, U32 NumBytes) {
    655          #if FS_SUPPORT_EXT_MEM_MANAGER == 0
    656            _pMem              = pMem;
   \                     FS_AssignMemory:
   \   00000000   ........           LDR      R2,??DataTable7_1
   \   00000004   000082E5           STR      R0,[R2, #+0]
    657            _NumBytesAvailable = NumBytes;
   \   00000008   041082E5           STR      R1,[R2, #+4]
    658          #else
    659            FS_DEBUG_WARN((FS_MTYPE_API, "FS_AssignMemory() shall only be used with the internal memory allocation routines.\n"));
    660          #endif
    661          }
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    662          
    663          /*********************************************************************
    664          *
    665          *       FS_SetMemHandler
    666          *
    667          *  Function description
    668          *    This function is called in the init phase.
    669          *    It sets the memory allocation handler.
    670          */

   \                                 In section .text, align 4, keep-with-next
    671          void FS_SetMemHandler(FS_PF_ALLOC * pfAlloc, FS_PF_FREE * pfFree) {
    672          #if FS_SUPPORT_EXT_MEM_MANAGER
    673            if (_pfAlloc) {
    674              FS_DEBUG_WARN((FS_MTYPE_API, "FS_SetMemHandler: pfAlloc already set\n"));
    675            }
    676            if (_pfFree) {
    677              FS_DEBUG_WARN((FS_MTYPE_API, "FS_SetMemHandler: pfFree already set\n"));
    678            }
    679            _pfAlloc = pfAlloc;
    680            _pfFree  = pfFree;
    681          #else
    682            FS_USE_PARA(pfAlloc);
    683            FS_USE_PARA(pfFree);
    684            FS_DEBUG_WARN((FS_MTYPE_API, "FS_SUPPORT_EXT_MEM_MANAGER == 0, FS_SetMemHandler() is disabled\n"));
    685          #endif
    686          }
   \                     FS_SetMemHandler:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    687          /*********************************************************************
    688          *
    689          *       FS_GetMaxSectorSize
    690          *
    691          *  Function description
    692          *    Returns the max sector size that was set by the user.
    693          *    Default value is 512 bytes.
    694          */

   \                                 In section .text, align 4, keep-with-next
    695          U32 FS_GetMaxSectorSize(void) {
    696            return FS_Global.MaxSectorSize;
   \                     FS_GetMaxSectorSize:
   \   00000000   ........           LDR      R0,??DataTable7
   \   00000004   B001D0E1           LDRH     R0,[R0, #+16]
   \   00000008   1EFF2FE1           BX       LR               ;; return
    697          }
    698          
    699          /*********************************************************************
    700          *
    701          *       FS_BITFIELD_CalcNumBitsUsed
    702          *
    703          *  Function description:
    704          *    Computes the number of bits used to store the give value
    705          */

   \                                 In section .text, align 4, keep-with-next
    706          unsigned FS_BITFIELD_CalcNumBitsUsed(U32 NumItems) {
    707            unsigned r;
    708          
    709            r = 0;
   \                     FS_BITFIELD_CalcNumBitsUsed:
   \   00000000   0010A0E3           MOV      R1,#+0
    710            do {
    711              r++;
   \                     ??FS_BITFIELD_CalcNumBitsUsed_0:
   \   00000004   011081E2           ADD      R1,R1,#+1
    712              NumItems >>= 1;
   \   00000008   A000B0E1           LSRS     R0,R0,#+1
    713            } while (NumItems);
   \   0000000C   FCFFFF1A           BNE      ??FS_BITFIELD_CalcNumBitsUsed_0
    714            return r;
   \   00000010   0100A0E1           MOV      R0,R1
   \   00000014   1EFF2FE1           BX       LR               ;; return
    715          }
    716          
    717          /**********************************************************
    718          *
    719          *      FS_BITFIELD_ReadEntry
    720          *
    721          *  Function description:
    722          *    Reads a single entry of <NumBits> from the bitfield
    723          */

   \                                 In section .text, align 4, keep-with-next
    724          U32 FS_BITFIELD_ReadEntry(const U8 * pBase, U32 Index, unsigned NumBits) {
    725            U32 v;
    726            U32 Off;
    727            U32 OffEnd;
    728            U32 Mask;
    729            U32 BitOff;
    730            int i;
    731          
    732            BitOff = Index * NumBits;
   \                     FS_BITFIELD_ReadEntry:
   \   00000000   920101E0           MUL      R1,R2,R1
   \   00000004   10402DE9           PUSH     {R4,LR}
    733            Off    = BitOff >> 3;
   \   00000008   A131A0E1           LSR      R3,R1,#+3
    734            OffEnd = (BitOff + NumBits - 1) >> 3;
    735            pBase += Off;
    736            i = OffEnd - Off;
   \   0000000C   01C082E0           ADD      R12,R2,R1
   \   00000010   000083E0           ADD      R0,R3,R0
   \   00000014   01C04CE2           SUB      R12,R12,#+1
   \   00000018   AC3173E0           RSBS     R3,R3,R12, LSR #+3
    737            //
    738            // Read data little endian
    739            //
    740            v = *pBase++;
   \   0000001C   01C0D0E4           LDRB     R12,[R0], #+1
    741            if (i) {
   \   00000020   0500000A           BEQ      ??FS_BITFIELD_ReadEntry_0
    742              unsigned Shift = 0;
   \   00000024   00E0A0E3           MOV      LR,#+0
    743              do {
    744                Shift += 8;
    745                v     |= (U32)*pBase++ << Shift;
   \                     ??FS_BITFIELD_ReadEntry_1:
   \   00000028   0140D0E4           LDRB     R4,[R0], #+1
   \   0000002C   08E08EE2           ADD      LR,LR,#+8
    746              } while (--i);
   \   00000030   013053E2           SUBS     R3,R3,#+1
   \   00000034   14CE8CE1           ORR      R12,R12,R4, LSL LR
   \   00000038   FAFFFF1A           BNE      ??FS_BITFIELD_ReadEntry_1
    747            }
    748            //
    749            // Shift, mask & return result
    750            //
    751            v    >>= (BitOff & 7);
    752            Mask   = (1UL << NumBits) - 1;
    753            v &= Mask;
    754            return v;
   \                     ??FS_BITFIELD_ReadEntry_0:
   \   0000003C   070001E2           AND      R0,R1,#0x7
   \   00000040   0110A0E3           MOV      R1,#+1
   \   00000044   003061E2           RSB      R3,R1,#+0
   \   00000048   111283E0           ADD      R1,R3,R1, LSL R2
   \   0000004C   3C0001E0           AND      R0,R1,R12, LSR R0
   \   00000050   1080BDE8           POP      {R4,PC}          ;; return
    755          }
    756          
    757          /**********************************************************
    758          *
    759          *      FS_BITFIELD_WriteEntry
    760          *
    761          *  Function Description
    762          *    Writes a single entry of <NumBits> into the bitfield
    763          */

   \                                 In section .text, align 4, keep-with-next
    764          void FS_BITFIELD_WriteEntry(U8 * pBase, U32 Index, unsigned NumBits, U32 v) {
   \                     FS_BITFIELD_WriteEntry:
   \   00000000   00402DE9           PUSH     {LR}
    765            U32   Mask;
    766            U8  * p;
    767            U32   u;
    768            U32   BitOff;
    769          
    770            BitOff = Index * NumBits;
   \   00000004   920101E0           MUL      R1,R2,R1
    771            p      = (U8 *)pBase + (BitOff >> 3);
    772            Mask   = (1UL << NumBits) - 1;
    773            Mask <<= (BitOff & 7);
   \   00000008   01C0A0E3           MOV      R12,#+1
   \   0000000C   00E06CE2           RSB      LR,R12,#+0
   \   00000010   A10180E0           ADD      R0,R0,R1, LSR #+3
   \   00000014   1C228EE0           ADD      R2,LR,R12, LSL R2
   \   00000018   071001E2           AND      R1,R1,#0x7
   \   0000001C   1221A0E1           LSL      R2,R2,R1
    774            v    <<= (BitOff & 7);
   \   00000020   1311A0E1           LSL      R1,R3,R1
    775            //
    776            // Read, mask, or and write data little endian byte by byte
    777            //
    778            do {
    779              u  = *p;
    780              u &= ~Mask;
    781              u |= v;
    782              *p = (U8)u;
   \                     ??FS_BITFIELD_WriteEntry_0:
   \   00000024   0030D0E5           LDRB     R3,[R0, #+0]
   \   00000028   0230C3E1           BIC      R3,R3,R2
   \   0000002C   033081E1           ORR      R3,R1,R3
    783              p++;
    784              Mask  >>= 8;
   \   00000030   2224A0E1           LSR      R2,R2,#+8
   \   00000034   0130C0E4           STRB     R3,[R0], #+1
    785              v     >>= 8;
   \   00000038   2114A0E1           LSR      R1,R1,#+8
    786            } while (Mask);
   \   0000003C   000052E3           CMP      R2,#+0
   \   00000040   F7FFFF1A           BNE      ??FS_BITFIELD_WriteEntry_0
    787          }
   \   00000044   0080BDE8           POP      {PC}             ;; return
    788          
    789          /*********************************************************************
    790          *
    791          *       FS_BITFIELD_CalcSize
    792          *
    793          *  Function Description
    794          *    Returns the size of bit field in bytes.
    795          */

   \                                 In section .text, align 4, keep-with-next
    796          unsigned FS_BITFIELD_CalcSize(U32 NumItems, unsigned BitsPerItem) {
    797            unsigned v;
    798            v =  NumItems * BitsPerItem;  // Compute the number of bits used for storage
    799            v = (v + 7) >> 3;             // Convert into bytes
    800            return v;
   \                     FS_BITFIELD_CalcSize:
   \   00000000   910000E0           MUL      R0,R1,R0
   \   00000004   070080E2           ADD      R0,R0,#+7
   \   00000008   A001A0E1           LSR      R0,R0,#+3
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    801          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     FS_Global

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   ........           DC32     _pMem
    802          
    803          /**************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     FS_Alloc                        16
     FS_AllocZeroed                  16
     FS_AllocZeroedPtr               24
     FS_AssignMemory                  0
     FS_BITFIELD_CalcNumBitsUsed      0
     FS_BITFIELD_CalcSize             0
     FS_BITFIELD_ReadEntry            8
     FS_BITFIELD_WriteEntry           4
     FS_Free                          0
     FS_GetMaxSectorSize              0
     FS_LoadU16BE                     0
     FS_LoadU16LE                     0
     FS_LoadU32BE                     0
     FS_LoadU32LE                     0
     FS_STORAGE_Init                  8
     FS_SetBusyLEDCallback            0
     FS_SetMaxSectorSize              0
     FS_SetMemAccessCallback          0
     FS_SetMemHandler                 0
     FS_StoreU16BE                    0
     FS_StoreU16LE                    0
     FS_StoreU24LE                    0
     FS_StoreU32BE                    0
     FS_StoreU32LE                    0
     FS_TryAlloc                     16
     FS__DivideU32Up                  4
     FS__strchr                       0


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     FS_Global                    136
     _pMem                         16
     _NumBytesAvailable
     FS_NumBytesAllocated
     _NumAllocs
     FS__DivideU32Up               12
     FS__strchr                    36
     FS_SetBusyLEDCallback          4
     FS_SetMemAccessCallback        4
     FS_LoadU16BE                  16
     FS_LoadU32BE                  32
     FS_StoreU16BE                 16
     FS_StoreU32BE                 32
     FS_LoadU32LE                  32
     FS_StoreU32LE                 32
     FS_StoreU24LE                 24
     FS_StoreU16LE                 16
     FS_LoadU16LE                  16
     FS_STORAGE_Init               64
     FS_SetMaxSectorSize           24
     FS_Alloc                     116
     FS_TryAlloc                  104
     FS_AllocZeroed               124
     FS_AllocZeroedPtr            136
     FS_Free                        4
     FS_AssignMemory               16
     FS_SetMemHandler               4
     FS_GetMaxSectorSize           12
     FS_BITFIELD_CalcNumBitsUsed   24
     FS_BITFIELD_ReadEntry         84
     FS_BITFIELD_WriteEntry        72
     FS_BITFIELD_CalcSize          16
     ??DataTable7                   4
     ??DataTable7_1                 4

 
   152 bytes in section .bss
 1 080 bytes in section .text
 
 1 080 bytes of CODE memory
   152 bytes of DATA memory

Errors: none
Warnings: none
