###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:15:37 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUI_Alloc.c                         #
#    Command line =  C:\DUII\TargetHW\GUI\GUI_Alloc.c -D DEBUG=1 -D           #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\GUI_Alloc.lst              #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\GUI_Alloc.o                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUI_Alloc.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIAllocX.c
     19          Purpose     : Dynamic memory management
     20          ----------------------------------------------------------------------
     21          */
     22          
     23          #include <stddef.h>
     24          #include <string.h>
     25          
     26          #include "GUI_Private.h"
     27          
     28          /*********************************************************************
     29          *
     30          *       Internal memory management
     31          *
     32          **********************************************************************
     33          */
     34          
     35          #ifndef GUI_ALLOC_ALLOC
     36          
     37          #ifndef   GUI_ALLOC_MIN_BLOCKSIZE
     38            #define GUI_ALLOC_MIN_BLOCKSIZE 16UL
     39          #endif
     40          
     41          /*********************************************************************
     42          *
     43          *       Defines
     44          *
     45          **********************************************************************
     46          */
     47          #define NET(x)   (U32)((U32)x - (U32)sizeof(MEM_TAG) - (U32)sizeof(U32))
     48          #define GROSS(x) (U32)((U32)x + (U32)sizeof(MEM_TAG) + (U32)sizeof(U32))
     49          
     50          /*********************************************************************
     51          *
     52          *       Types
     53          *
     54          **********************************************************************
     55          */
     56          /*********************************************************************
     57          *
     58          *       GUI_HEAP
     59          *
     60          * Purpose:
     61          *   32 bit aligned memory block to be managed by the memory management.
     62          */
     63          typedef struct {
     64            U8 abHeap[1];
     65          } GUI_HEAP;
     66          
     67          /*********************************************************************
     68          *
     69          *       MEM_TAG
     70          *
     71          * Purpose:
     72          *   Memory information structure.
     73          */
     74          typedef struct {
     75            U32 Block; /* Index of block which refers to this memory block */
     76            U32 Size;  /* Gross size of memory block */
     77          } MEM_TAG;
     78          
     79          /*********************************************************************
     80          *
     81          *       FREE_TAG
     82          *
     83          * Purpose:
     84          *   Used to link free blocks of memory. Locations of these tags are the
     85          *   unused memory areas of free blocks.
     86          */
     87          typedef struct FREE_TAG FREE_TAG;
     88          typedef struct TAG      TAG;
     89          
     90          struct FREE_TAG {
     91            FREE_TAG * pNext; /* Pointer to next free tag */
     92            FREE_TAG * pPrev; /* Pointer to previous free tag */
     93            TAG      * pTag;  /* Pointer to memory tag */
     94          };
     95          
     96          /*********************************************************************
     97          *
     98          *       TAG
     99          */
    100          struct TAG {
    101            MEM_TAG  MemTag;
    102            FREE_TAG FreeTag;
    103          };
    104          
    105          /*********************************************************************
    106          *
    107          *       BLOCK
    108          */
    109          typedef struct {
    110            #if GUI_DEBUG_LEVEL > 0
    111              U8 InUse;
    112            #endif
    113            union {
    114              GUI_HMEM NextBlock; /* If block is free, handle of next block */
    115              TAG *    pTag;      /* If block is in use, pointer to memory tag */
    116            } u;
    117          } BLOCK;
    118          
    119          /*********************************************************************
    120          *
    121          *       FREE_MEM
    122          */
    123          typedef struct {
    124            U32        MinSize;       /* Minimum size of memory blocks linked in the list */
    125            FREE_TAG * pFirstFreeTag; /* Pointer to first tag */
    126          } FREE_MEM;
    127          
    128          /*********************************************************************
    129          *
    130          *       CONFIG
    131          */
    132          typedef struct {
    133            void * pData;
    134            void * pBlocks;
    135            U32    NumBytes;
    136            U32    NumBlocks;
    137            U32    BlockSize;
    138            U8     Customized;
    139          } CONFIG;
    140          
    141          /*********************************************************************
    142          *
    143          *       Static data
    144          *
    145          **********************************************************************
    146          */

   \                                 In section .data, align 4
    147          static int _LockCnt;       /* If >0 moving of memory is not allowed */
    148          /*static*/ int _LockCntHandles;/* If >0 a pointer has been locked and moving memory is not allowed */
    149          static U8  _IsInitialized; /* 1 if already initialized */
    150          /*static*/ U32 _NumFreeBytes;  /* Number of free bytes */
    151          static U32 _NumFreeBlocks; /* Number of free blocks */
    152          static U32 _AllocSize;     /* Number of bytes available for memory management */
    153          static U32 _NumBlocks;     /* Number of available memory blocks */
    154          static U32 _NumFixedBytes; /* Number of bytes in fixed blocks */
    155          
    156          static int  _MaxRequestPercent = 90;
    157          
    158          static GUI_HEAP * _pHeap;
    159          static BLOCK    * _pBlocks;
    160          
    161          static GUI_HMEM _FirstFreeBlock;        /* Index of first free block */
    162          
    163          static FREE_MEM _aFreeMem[16];          /* List of free memory */
    164          
    165          static FREE_TAG * _pFirstFixedFreeTag;  /* Linked list of free fixed memory blocks */
    166          
    167          #ifndef   __NO_INIT
    168            #define __NO_INIT
    169          #endif
    170          
    171          static CONFIG _Config = {
   \                     _Config:
   \   00000000   000000000000       DC32 0H, 0H, 0, 0, 32
   \              000000000000
   \              000000002000
   \              0000        
   \   00000014   00000000           DC8 0, 0, 0, 0
   \   00000018   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000028   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000038   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000048   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000058   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000068   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000078   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000088   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000098   00000000           DC8 0, 0, 0, 0
   \                     _LockCntHandles:
   \   0000009C   00000000           DC8 0, 0, 0, 0
   \                     _NumFreeBytes:
   \   000000A0   00000000           DC8 0, 0, 0, 0
   \   000000A4   00000000           DC8 0, 0, 0, 0
   \   000000A8   00000000           DC8 0, 0, 0, 0
   \   000000AC   00000000           DC8 0, 0, 0, 0
   \   000000B0   00000000           DC8 0, 0, 0, 0
   \   000000B4   00000000           DC8 0, 0, 0, 0
   \   000000B8   00000000           DC8 0, 0, 0, 0
   \   000000BC   00000000           DC8 0, 0, 0, 0
   \   000000C0   00000000           DC8 0, 0, 0, 0
   \   000000C4   00                 DC8 0

   \                                 In section .data, align 4
   \   00000000   5A000000           DC32 90
    172            NULL,
    173            NULL,
    174            0,
    175            0,
    176            32,
    177            0
    178          };
    179          
    180          /*********************************************************************
    181          *
    182          *       Static code, internal
    183          *
    184          **********************************************************************
    185          */
    186          /*********************************************************************
    187          *
    188          *       _GetMinIndex
    189          *
    190          * Purpose:
    191          *   Calculates the index of the free memory list to be used to store
    192          *   memory of the given size.
    193          *
    194          * Return value:
    195          *   Index of the free memory list
    196          */
    197          static int _GetMinIndex(U32 Size) {
    198            int Index;
    199            for (Index = GUI_COUNTOF(_aFreeMem) - 1; Index >= 0; Index--) {
    200              if (Size >= _aFreeMem[Index].MinSize) {
    201                break;
    202              }
    203            }
    204            return Index;
    205          }
    206          
    207          /*********************************************************************
    208          *
    209          *       _GetFreeTag
    210          *
    211          * Purpose:
    212          *   Returns a free memory tag of the requested size or greater
    213          */
    214          static TAG * _GetFreeTag(U32 Size) {
    215            TAG * pTag = NULL;
    216            int Index;
    217            //
    218            // Iterate over free memory list
    219            //
    220            Index = _GetMinIndex(Size);
    221            for (; Index < GUI_COUNTOF(_aFreeMem); Index++) {
    222              //
    223              // Check if one or more entry exist
    224              //
    225              if (_aFreeMem[Index].pFirstFreeTag) {
    226                //
    227                // Set tag pointer to first entry
    228                //
    229                pTag = _aFreeMem[Index].pFirstFreeTag->pTag;
    230                //
    231                // Check if the requested size is larger than the size of the block
    232                //
    233                if (Size > pTag->MemTag.Size) {
    234                  //
    235                  // Iterate over list until size does match
    236                  //
    237                  while (Size > pTag->MemTag.Size) {
    238                    if (pTag->FreeTag.pNext) {
    239                      pTag = pTag->FreeTag.pNext->pTag;
    240                    } else {
    241                      if (Size > pTag->MemTag.Size) {
    242                        pTag = NULL;
    243                      }
    244                      break; /* No further pointer */
    245                    }
    246                  }
    247                } else {
    248                  break; /* Ok, we found one */
    249                }
    250              } else {
    251                //
    252                // No entry, no tag
    253                //
    254                pTag = NULL;
    255              }
    256            }
    257            return pTag;
    258          }
    259          
    260          /*********************************************************************
    261          *
    262          *       _WriteTagData
    263          *
    264          * Purpose:
    265          *   Routine to write the tag data: memory tag, free tag and 
    266          *   additional size information at end of block.
    267          */
    268          static void _WriteTagData(TAG * pTag, GUI_HMEM Block, U32 Size, FREE_TAG * pNext) {
    269            //
    270            // Memory tag info
    271            //
    272            pTag->MemTag.Block  = Block;
    273            pTag->MemTag.Size   = Size;
    274            //
    275            // Free tag info
    276            //
    277            pTag->FreeTag.pNext = pNext;
    278            pTag->FreeTag.pTag  = pTag;
    279            //
    280            // Additional size information at end of block
    281            //
    282            *((U32 *)((U32)pTag + Size - sizeof(U32))) = Size;
    283          }
    284          
    285          /*********************************************************************
    286          *
    287          *       _Unlink
    288          *
    289          * Purpose:
    290          *   Unkinks a free memory list entry from the list
    291          */
    292          static void _Unlink(FREE_TAG * pFreeTag, FREE_TAG ** ppFirstFreeTag) {
    293            FREE_TAG * pNext;
    294            FREE_TAG * pPrev;
    295            pNext = pFreeTag->pNext;
    296            pPrev = pFreeTag->pPrev;
    297            if (pNext) {
    298              pNext->pPrev = pPrev;
    299            }
    300            if (pPrev) {
    301              pPrev->pNext = pNext;
    302            } else {
    303              *(ppFirstFreeTag) = pNext;
    304            }
    305          }
    306          
    307          /*********************************************************************
    308          *
    309          *       _Append
    310          *
    311          * Purpose:
    312          *   Appends a free memory list entry to the list
    313          */
    314          static void _Append(FREE_TAG * pFreeTag, FREE_TAG ** ppFirstFreeTag) {
    315            FREE_TAG * pFirstFreeTag;
    316            pFirstFreeTag = *ppFirstFreeTag;
    317            if (pFirstFreeTag) {
    318              pFirstFreeTag->pPrev = pFreeTag;
    319            }
    320            pFreeTag->pNext     = pFirstFreeTag;
    321            pFreeTag->pPrev     = NULL;
    322            *(ppFirstFreeTag)   = pFreeTag;
    323          }
    324          
    325          /*********************************************************************
    326          *
    327          *       _RemoveFreeMemory
    328          *
    329          * Purpose:
    330          *   Removes the given memory block from the according list and subtracts
    331          *   the block size from the free bytes.
    332          */
    333          static void _RemoveFreeMemory(TAG * pTag) {
    334            int Index;
    335          
    336            //
    337            // Get index of free memory list
    338            //
    339            Index = _GetMinIndex(pTag->MemTag.Size);
    340            //
    341            // Subtract free bytes
    342            //
    343            _NumFreeBytes -= pTag->MemTag.Size;
    344            //
    345            // Unling from list
    346            //
    347            _Unlink(&pTag->FreeTag, &_aFreeMem[Index].pFirstFreeTag);
    348          }
    349          
    350          /*********************************************************************
    351          *
    352          *       _AddFreeMemory
    353          *
    354          * Purpose:
    355          *   Adds the given memory block to the free memory and adds the block size
    356          *   to the free bytes. If adjacent blocks at top or bottom are also free,
    357          *   the routine will merge them together with the given block.
    358          */

   \                                 In section .text, align 4, keep-with-next
    359          static void _AddFreeMemory(U32 Size, void * p) {
   \                     _AddFreeMemory:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    360            int Index;
    361            TAG * pTag;
    362            U32 AddrMem;
    363            U32 AddrEnd;
    364            
    365            //
    366            // End address of heap
    367            //
    368            AddrEnd = (U32)_pHeap->abHeap + _AllocSize - 1;
    369            //
    370            // Check if next adjacent block can be merged
    371            //
    372            AddrMem = (U32)p + Size;
    373            if (AddrMem <= AddrEnd) {
   \   00000004   ........           LDR      R2,??DataTable23
   \   00000008   B4E092E5           LDR      LR,[R2, #+180]
   \   0000000C   A84092E5           LDR      R4,[R2, #+168]
   \   00000010   013080E0           ADD      R3,R0,R1
   \   00000014   0E4084E0           ADD      R4,R4,LR
   \   00000018   014044E2           SUB      R4,R4,#+1
   \   0000001C   030054E1           CMP      R4,R3
   \   00000020   1700003A           BCC      ??_AddFreeMemory_0
    374              pTag = (TAG *)AddrMem;
    375              //
    376              // If block member of memory tag is 0, it is empty and should be merged
    377              //
    378              if (pTag->MemTag.Block == 0) {
   \   00000024   004093E5           LDR      R4,[R3, #+0]
   \   00000028   000054E3           CMP      R4,#+0
   \   0000002C   1400001A           BNE      ??_AddFreeMemory_0
    379                //
    380                // Add size of merged block
    381                //
    382                Size += pTag->MemTag.Size;
   \   00000030   044093E5           LDR      R4,[R3, #+4]
    383                //
    384                // Remove merged block
    385                //
    386                _RemoveFreeMemory(pTag);
   \   00000034   0F60A0E3           MOV      R6,#+15
   \   00000038   000084E0           ADD      R0,R4,R0
   \   0000003C   907082E2           ADD      R7,R2,#+144
   \                     ??_AddFreeMemory_1:
   \   00000040   088017E4           LDR      R8,[R7], #-8
   \   00000044   080054E1           CMP      R4,R8
   \   00000048   0100002A           BCS      ??_AddFreeMemory_2
   \   0000004C   016056E2           SUBS     R6,R6,#+1
   \   00000050   FAFFFF5A           BPL      ??_AddFreeMemory_1
   \                     ??_AddFreeMemory_2:
   \   00000054   A05092E5           LDR      R5,[R2, #+160]
   \   00000058   044045E0           SUB      R4,R5,R4
   \   0000005C   A04082E5           STR      R4,[R2, #+160]
   \   00000060   0850B3E5           LDR      R5,[R3, #+8]!
   \   00000064   043093E5           LDR      R3,[R3, #+4]
   \   00000068   000055E3           CMP      R5,#+0
   \   0000006C   864182E0           ADD      R4,R2,R6, LSL #+3
   \   00000070   04308515           STRNE    R3,[R5, #+4]
   \   00000074   1C4084E2           ADD      R4,R4,#+28
   \   00000078   000053E3           CMP      R3,#+0
   \   0000007C   00508405           STREQ    R5,[R4, #+0]
   \   00000080   00508315           STRNE    R5,[R3, #+0]
    387              }
    388            }
    389            //
    390            // Check if previous adjacent block can be merged
    391            //
    392            if ((U8 *)p > _pHeap->abHeap) {
   \                     ??_AddFreeMemory_0:
   \   00000084   01005EE1           CMP      LR,R1
   \   00000088   1B00002A           BCS      ??_AddFreeMemory_3
    393              U32 SizePrev;
    394              SizePrev = *(U32 *)((U32)p - sizeof(U32));
    395              AddrMem = (U32)p - SizePrev;
    396              pTag = (TAG *)AddrMem;
   \   0000008C   043011E5           LDR      R3,[R1, #-4]
   \   00000090   033041E0           SUB      R3,R1,R3
    397              //
    398              // If block member of memory tag is 0, it is empty and should be merged
    399              //
    400              if (pTag->MemTag.Block == 0) {
   \   00000094   00C093E5           LDR      R12,[R3, #+0]
   \   00000098   00005CE3           CMP      R12,#+0
   \   0000009C   1600001A           BNE      ??_AddFreeMemory_3
    401                //
    402                // Add size of merged block
    403                //
    404                Size += pTag->MemTag.Size;
   \   000000A0   041093E5           LDR      R1,[R3, #+4]
    405                //
    406                // Remove merged block
    407                //
    408                _RemoveFreeMemory(pTag);
   \   000000A4   0FE0A0E3           MOV      LR,#+15
   \   000000A8   000081E0           ADD      R0,R1,R0
   \   000000AC   904082E2           ADD      R4,R2,#+144
   \                     ??_AddFreeMemory_4:
   \   000000B0   085014E4           LDR      R5,[R4], #-8
   \   000000B4   050051E1           CMP      R1,R5
   \   000000B8   0100002A           BCS      ??_AddFreeMemory_5
   \   000000BC   01E05EE2           SUBS     LR,LR,#+1
   \   000000C0   FAFFFF5A           BPL      ??_AddFreeMemory_4
   \                     ??_AddFreeMemory_5:
   \   000000C4   A0C092E5           LDR      R12,[R2, #+160]
   \   000000C8   01104CE0           SUB      R1,R12,R1
   \   000000CC   A01082E5           STR      R1,[R2, #+160]
   \   000000D0   8E1182E0           ADD      R1,R2,LR, LSL #+3
   \   000000D4   08C083E2           ADD      R12,R3,#+8
   \   000000D8   00E09CE5           LDR      LR,[R12, #+0]
   \   000000DC   04C09CE5           LDR      R12,[R12, #+4]
   \   000000E0   00005EE3           CMP      LR,#+0
   \   000000E4   04C08E15           STRNE    R12,[LR, #+4]
   \   000000E8   1C1081E2           ADD      R1,R1,#+28
   \   000000EC   00005CE3           CMP      R12,#+0
   \   000000F0   00E08105           STREQ    LR,[R1, #+0]
   \   000000F4   00E08C15           STRNE    LR,[R12, #+0]
    409                //
    410                // Adjust pointer
    411                //
    412                p = pTag;
   \   000000F8   0310A0E1           MOV      R1,R3
    413              }
    414            }
    415            //
    416            // Get the index of the free memory list
    417            //
    418            Index = _GetMinIndex(Size);
   \                     ??_AddFreeMemory_3:
   \   000000FC   0F30A0E3           MOV      R3,#+15
   \   00000100   90C082E2           ADD      R12,R2,#+144
   \                     ??_AddFreeMemory_6:
   \   00000104   08E01CE4           LDR      LR,[R12], #-8
   \   00000108   0E0050E1           CMP      R0,LR
   \   0000010C   0100002A           BCS      ??_AddFreeMemory_7
   \   00000110   013053E2           SUBS     R3,R3,#+1
   \   00000114   FAFFFF5A           BPL      ??_AddFreeMemory_6
    419            //
    420            // Make tag pointer
    421            //
    422            pTag = (TAG *)p;
    423            //
    424            // Write memory tag information
    425            //
    426            _WriteTagData(pTag, 0, Size, _aFreeMem[Index].pFirstFreeTag);
   \                     ??_AddFreeMemory_7:
   \   00000118   833182E0           ADD      R3,R2,R3, LSL #+3
   \   0000011C   1CC093E5           LDR      R12,[R3, #+28]
   \   00000120   00E0A0E3           MOV      LR,#+0
   \   00000124   00E081E5           STR      LR,[R1, #+0]
   \   00000128   040081E5           STR      R0,[R1, #+4]
   \   0000012C   08C081E5           STR      R12,[R1, #+8]
   \   00000130   101081E5           STR      R1,[R1, #+16]
   \   00000134   01C080E0           ADD      R12,R0,R1
   \   00000138   04000CE5           STR      R0,[R12, #-4]
    427            //
    428            // Add to free memory list
    429            //
    430            _Append(&pTag->FreeTag, &_aFreeMem[Index].pFirstFreeTag);
   \   0000013C   1CC0B3E5           LDR      R12,[R3, #+28]!
   \   00000140   081081E2           ADD      R1,R1,#+8
   \   00000144   00005CE3           CMP      R12,#+0
   \   00000148   04108C15           STRNE    R1,[R12, #+4]
   \   0000014C   00C081E5           STR      R12,[R1, #+0]
   \   00000150   04E081E5           STR      LR,[R1, #+4]
   \   00000154   001083E5           STR      R1,[R3, #+0]
    431            //
    432            // Adjust free bytes
    433            //
    434            _NumFreeBytes += Size;
   \   00000158   A01092E5           LDR      R1,[R2, #+160]
   \   0000015C   010080E0           ADD      R0,R0,R1
   \   00000160   A00082E5           STR      R0,[R2, #+160]
    435          }
   \   00000164   F081BDE8           POP      {R4-R8,PC}       ;; return
    436          
    437          /*********************************************************************
    438          *
    439          *       _RemoveHoles
    440          *
    441          * Purpose:
    442          *   Removes all holes from memory and resets the list of free memory
    443          *
    444          * Return value:
    445          *   1 if no hole detected
    446          */

   \                                 In section .text, align 4, keep-with-next
    447          static int _RemoveHoles(void) {
   \                     _RemoveHoles:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    448            TAG * pTag;
    449            U32 Addr;
    450            U32 Size;
    451            U32 AddrCur;
    452            U32 AddrEnd;
    453            U32 FreeBytes;
    454            int NoHoleDetected;
    455            int i;
    456            
    457            NoHoleDetected = 1;
    458            FreeBytes      = 0;
    459            AddrCur        = (U32)_pHeap->abHeap;
   \   00000004   ........           LDR      R7,??DataTable23
   \   00000008   B48097E5           LDR      R8,[R7, #+180]
    460            AddrEnd        = AddrCur + _AllocSize - 1;
   \   0000000C   A80097E5           LDR      R0,[R7, #+168]
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   0110A0E3           MOV      R1,#+1
   \   00000018   080080E0           ADD      R0,R0,R8
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
   \   00000020   0050A0E3           MOV      R5,#+0
   \   00000024   0060A0E3           MOV      R6,#+0
   \   00000028   019040E2           SUB      R9,R0,#+1
    461            //
    462            // Iterate over whole heap
    463            //
    464            do {
    465              U32 SizeCur;
    466              pTag    = (TAG *)AddrCur;
    467              SizeCur = pTag->MemTag.Size;
   \                     ??_RemoveHoles_0:
   \   0000002C   04A098E5           LDR      R10,[R8, #+4]
    468              //
    469              // Check if we have a block at the current address
    470              //
    471              if ((pTag->MemTag.Block == 0) && ((AddrCur + SizeCur) < AddrEnd)) {
   \   00000030   000098E5           LDR      R0,[R8, #+0]
   \   00000034   08408AE0           ADD      R4,R10,R8
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   1100001A           BNE      ??_RemoveHoles_1
   \   00000040   090054E1           CMP      R4,R9
   \   00000044   0F00002A           BCS      ??_RemoveHoles_1
    472                U32 SizeBlock;
    473                U32 AddrBlock;
    474                NoHoleDetected = 0;
   \   00000048   00508DE5           STR      R5,[SP, #+0]
    475                AddrBlock = AddrCur + SizeCur;
    476                //
    477                // Move all blocks above the hole
    478                //
    479                do {
    480                  U32 AddrNew;
    481                  GUI_HMEM hBlock;
    482                  pTag                 = (TAG *)AddrBlock;
   \                     ??_RemoveHoles_2:
   \   0000004C   0410A0E1           MOV      R1,R4
    483                  hBlock               = pTag->MemTag.Block;
    484                  SizeBlock            = pTag->MemTag.Size;
    485                  AddrNew              = AddrBlock - SizeCur;
    486                  (_pBlocks + hBlock)->u.pTag = (TAG *)AddrNew;
   \   00000050   002091E5           LDR      R2,[R1, #+0]
   \   00000054   B83097E5           LDR      R3,[R7, #+184]
   \   00000058   04B091E5           LDR      R11,[R1, #+4]
   \   0000005C   0A0044E0           SUB      R0,R4,R10
   \   00000060   822183E0           ADD      R2,R3,R2, LSL #+3
   \   00000064   040082E5           STR      R0,[R2, #+4]
    487                  memmove((void *)(AddrNew), (void *)(AddrBlock), SizeBlock);
   \   00000068   0B20A0E1           MOV      R2,R11
   \   0000006C   ........           BL       __aeabi_memmove
    488                  AddrBlock += SizeBlock;
   \   00000070   04408BE0           ADD      R4,R11,R4
    489                } while (AddrBlock < AddrEnd);
   \   00000074   090054E1           CMP      R4,R9
   \   00000078   F3FFFF3A           BCC      ??_RemoveHoles_2
    490                FreeBytes += SizeCur;
   \   0000007C   06608AE0           ADD      R6,R10,R6
    491                AddrEnd   -= SizeCur;
   \   00000080   0A9049E0           SUB      R9,R9,R10
   \   00000084   000000EA           B        ??_RemoveHoles_3
    492              } else {
    493                AddrCur += SizeCur;
   \                     ??_RemoveHoles_1:
   \   00000088   0480A0E1           MOV      R8,R4
    494              }
    495            } while(AddrCur < AddrEnd);
   \                     ??_RemoveHoles_3:
   \   0000008C   090058E1           CMP      R8,R9
   \   00000090   E5FFFF3A           BCC      ??_RemoveHoles_0
    496            //
    497            // Continue only if at least one hole has been found
    498            //
    499            if (NoHoleDetected == 0) {
   \   00000094   00009DE5           LDR      R0,[SP, #+0]
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   1500001A           BNE      ??_RemoveHoles_4
    500              //
    501              // Check if last block is free memory. If yes add size to free bytes
    502              //
    503              Size = *(U32 *)(AddrEnd + 1 - sizeof(U32));
    504              Addr = AddrEnd + 1 - Size;
    505              pTag = (TAG *)Addr;
   \   000000A0   031019E5           LDR      R1,[R9, #-3]
   \   000000A4   010089E2           ADD      R0,R9,#+1
   \   000000A8   011040E0           SUB      R1,R0,R1
    506              if (pTag->MemTag.Block == 0) {
   \   000000AC   000091E5           LDR      R0,[R1, #+0]
   \   000000B0   000050E3           CMP      R0,#+0
    507                FreeBytes += pTag->MemTag.Size;
   \   000000B4   04009105           LDREQ    R0,[R1, #+4]
    508              }
    509              //
    510              // Clear free memory list
    511              //
    512              for (i = 0; i < GUI_COUNTOF(_aFreeMem); i++) {
   \   000000B8   0410A0E3           MOV      R1,#+4
   \   000000BC   06608000           ADDEQ    R6,R0,R6
   \   000000C0   1C0087E2           ADD      R0,R7,#+28
    513                _aFreeMem[i].pFirstFreeTag = NULL;
   \                     ??_RemoveHoles_5:
   \   000000C4   085080E4           STR      R5,[R0], #+8
   \   000000C8   085080E4           STR      R5,[R0], #+8
   \   000000CC   085080E4           STR      R5,[R0], #+8
   \   000000D0   085080E4           STR      R5,[R0], #+8
    514              }
   \   000000D4   011051E2           SUBS     R1,R1,#+1
   \   000000D8   F9FFFF1A           BNE      ??_RemoveHoles_5
    515              //
    516              // Set free bytes to 0
    517              //
    518              _NumFreeBytes = 0;
    519              //
    520              // Add the one and only free memory block
    521              //
    522              _AddFreeMemory(FreeBytes, (void *)((U32)_pHeap->abHeap + _AllocSize - FreeBytes));
   \   000000DC   B40097E5           LDR      R0,[R7, #+180]
   \   000000E0   A81097E5           LDR      R1,[R7, #+168]
   \   000000E4   A05087E5           STR      R5,[R7, #+160]
   \   000000E8   000081E0           ADD      R0,R1,R0
   \   000000EC   061040E0           SUB      R1,R0,R6
   \   000000F0   0600A0E1           MOV      R0,R6
   \   000000F4   ........           BL       _AddFreeMemory
    523            }
    524            return NoHoleDetected;
   \                     ??_RemoveHoles_4:
   \   000000F8   00009DE5           LDR      R0,[SP, #+0]
   \   000000FC   04D08DE2           ADD      SP,SP,#+4
   \   00000100   F08FBDE8           POP      {R4-R11,PC}      ;; return
    525          }
    526          
    527          /*********************************************************************
    528          *
    529          *       _TestRAM
    530          *
    531          * Purpose:
    532          *   Checks if the RAM can be accessed 32, 16 and 8 bit wise.
    533          *
    534          * Return value:
    535          *   0 on success, 1 on error
    536          *   1 on  8 bit access error
    537          *   2 on 16 bit access error
    538          *   3 on 32 bit access error
    539          */
    540          #if (GUI_DEBUG_LEVEL > 0)

   \                                 In section .text, align 4, keep-with-next
    541          static int _TestRAM(U32 Addr, U32 NumBytes) {
   \                     _TestRAM:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    542            U8 Byte;
    543            U8 Short;
    544            U8 Long;
    545            U8  * pByte;
    546            U16 * pShort;
    547            U32 * pLong;
    548            U32 NumItems;
    549            U32 i, j;
    550          
    551            //
    552            // Test 32 bit access
    553            //
    554            NumItems = NumBytes / 4;
   \   00000004   21E1A0E1           LSR      LR,R1,#+2
    555            for (j = 0; j < 2; j++) {
   \   00000008   00C0A0E3           MOV      R12,#+0
   \   0000000C   0020A0E1           MOV      R2,R0
    556              pLong = (U32 *)Addr;
   \                     ??_TestRAM_0:
   \   00000010   0200A0E1           MOV      R0,R2
    557              for (i = 0; i < NumItems; i++) {
   \   00000014   00005EE3           CMP      LR,#+0
   \   00000018   1A00000A           BEQ      ??_TestRAM_1
   \   0000001C   0C40A0E1           MOV      R4,R12
   \   00000020   01001EE3           TST      LR,#0x1
   \   00000024   0500000A           BEQ      ??_TestRAM_2
    558                Long = (i + j) % 255;
    559                *pLong++ = Long;
   \   00000028   ........           LDR      R7,??DataTable23_1  ;; 0x80808081
   \   0000002C   947786E0           UMULL    R7,R6,R4,R7
   \   00000030   A65384E0           ADD      R5,R4,R6, LSR #+7
   \   00000034   FF5005E2           AND      R5,R5,#0xFF
   \   00000038   045080E4           STR      R5,[R0], #+4
   \   0000003C   014084E2           ADD      R4,R4,#+1
   \                     ??_TestRAM_2:
   \   00000040   AE50B0E1           LSRS     R5,LR,#+1
   \   00000044   0F00000A           BEQ      ??_TestRAM_1
   \                     ??_TestRAM_3:
   \   00000048   ........           LDR      R8,??DataTable23_1  ;; 0x80808081
   \   0000004C   ........           LDR      R9,??DataTable23_1  ;; 0x80808081
   \   00000050   948887E0           UMULL    R8,R7,R4,R8
    560              }
   \   00000054   015045E2           SUB      R5,R5,#+1
   \   00000058   A76384E0           ADD      R6,R4,R7, LSR #+7
   \   0000005C   FF6006E2           AND      R6,R6,#0xFF
   \   00000060   046080E4           STR      R6,[R0], #+4
   \   00000064   016084E2           ADD      R6,R4,#+1
   \   00000068   969988E0           UMULL    R9,R8,R6,R9
   \   0000006C   0670A0E1           MOV      R7,R6
   \   00000070   A86387E0           ADD      R6,R7,R8, LSR #+7
   \   00000074   FF6006E2           AND      R6,R6,#0xFF
   \   00000078   046080E4           STR      R6,[R0], #+4
   \   0000007C   024084E2           ADD      R4,R4,#+2
   \   00000080   000055E3           CMP      R5,#+0
   \   00000084   EFFFFF1A           BNE      ??_TestRAM_3
    561              pLong = (U32 *)Addr;
   \                     ??_TestRAM_1:
   \   00000088   0200A0E1           MOV      R0,R2
    562              for (i = 0; i < NumItems; i++) {
   \   0000008C   0050A0E3           MOV      R5,#+0
   \   00000090   0C40A0E1           MOV      R4,R12
   \   00000094   010000EA           B        ??_TestRAM_4
   \                     ??_TestRAM_5:
   \   00000098   015085E2           ADD      R5,R5,#+1
   \   0000009C   014084E2           ADD      R4,R4,#+1
   \                     ??_TestRAM_4:
   \   000000A0   0E0055E1           CMP      R5,LR
   \   000000A4   0A00002A           BCS      ??_TestRAM_6
    563                Long = *pLong++;
    564                if (Long != ((i + j) % 255)) {
   \   000000A8   ........           LDR      R8,??DataTable23_1  ;; 0x80808081
   \   000000AC   046090E4           LDR      R6,[R0], #+4
   \   000000B0   948887E0           UMULL    R8,R7,R4,R8
   \   000000B4   066CA0E1           MOV      R6,R6, LSL #+24
   \   000000B8   A773A0E1           LSR      R7,R7,#+7
   \   000000BC   077467E0           RSB      R7,R7,R7, LSL #+8
   \   000000C0   077044E0           SUB      R7,R4,R7
   \   000000C4   260C57E1           CMP      R7,R6, LSR #+24
   \   000000C8   F2FFFF0A           BEQ      ??_TestRAM_5
    565                  return 3; /* 32 bit access error */
   \   000000CC   0300A0E3           MOV      R0,#+3
   \   000000D0   F087BDE8           POP      {R4-R10,PC}
    566                }
    567              }
    568            }
   \                     ??_TestRAM_6:
   \   000000D4   01C08CE2           ADD      R12,R12,#+1
   \   000000D8   02005CE3           CMP      R12,#+2
   \   000000DC   CBFFFF3A           BCC      ??_TestRAM_0
    569            //
    570            // Test 16 bit access
    571            //
    572            NumItems = NumBytes / 2;
   \   000000E0   A140A0E1           LSR      R4,R1,#+1
   \   000000E4   04E0A0E1           MOV      LR,R4
    573            for (j = 0; j < 2; j++) {
   \   000000E8   00C0A0E3           MOV      R12,#+0
    574              pShort = (U16 *)Addr;
   \                     ??_TestRAM_7:
   \   000000EC   0200A0E1           MOV      R0,R2
    575              for (i = 0; i < NumItems; i++) {
   \   000000F0   0060A0E3           MOV      R6,#+0
   \   000000F4   00005EE3           CMP      LR,#+0
   \   000000F8   1C00000A           BEQ      ??_TestRAM_8
   \   000000FC   0C50A0E1           MOV      R5,R12
   \   00000100   01001EE3           TST      LR,#0x1
   \   00000104   0600000A           BEQ      ??_TestRAM_9
    576                Short = (i + j) % 255;
    577                *pShort++ = Short;
   \   00000108   ........           LDR      R8,??DataTable23_1  ;; 0x80808081
   \   0000010C   0560A0E1           MOV      R6,R5
   \   00000110   958887E0           UMULL    R8,R7,R5,R8
   \   00000114   A75386E0           ADD      R5,R6,R7, LSR #+7
   \   00000118   FF5005E2           AND      R5,R5,#0xFF
   \   0000011C   B250C0E0           STRH     R5,[R0], #+2
   \   00000120   0160A0E3           MOV      R6,#+1
   \                     ??_TestRAM_9:
   \   00000124   AE50B0E1           LSRS     R5,LR,#+1
   \   00000128   1000000A           BEQ      ??_TestRAM_8
   \   0000012C   06608CE0           ADD      R6,R12,R6
   \                     ??_TestRAM_10:
   \   00000130   ........           LDR      R9,??DataTable23_1  ;; 0x80808081
   \   00000134   ........           LDR      R10,??DataTable23_1  ;; 0x80808081
   \   00000138   969988E0           UMULL    R9,R8,R6,R9
    578              }
   \   0000013C   015045E2           SUB      R5,R5,#+1
   \   00000140   A87386E0           ADD      R7,R6,R8, LSR #+7
   \   00000144   FF7007E2           AND      R7,R7,#0xFF
   \   00000148   B270C0E0           STRH     R7,[R0], #+2
   \   0000014C   017086E2           ADD      R7,R6,#+1
   \   00000150   97AA89E0           UMULL    R10,R9,R7,R10
   \   00000154   0780A0E1           MOV      R8,R7
   \   00000158   A97388E0           ADD      R7,R8,R9, LSR #+7
   \   0000015C   FF7007E2           AND      R7,R7,#0xFF
   \   00000160   B270C0E0           STRH     R7,[R0], #+2
   \   00000164   026086E2           ADD      R6,R6,#+2
   \   00000168   000055E3           CMP      R5,#+0
   \   0000016C   EFFFFF1A           BNE      ??_TestRAM_10
    579              pShort = (U16 *)Addr;
   \                     ??_TestRAM_8:
   \   00000170   0200A0E1           MOV      R0,R2
    580              for (i = 0; i < NumItems; i++) {
   \   00000174   0050A0E3           MOV      R5,#+0
   \   00000178   0C60A0E1           MOV      R6,R12
   \   0000017C   010000EA           B        ??_TestRAM_11
   \                     ??_TestRAM_12:
   \   00000180   015085E2           ADD      R5,R5,#+1
   \   00000184   016086E2           ADD      R6,R6,#+1
   \                     ??_TestRAM_11:
   \   00000188   0E0055E1           CMP      R5,LR
   \   0000018C   0A00002A           BCS      ??_TestRAM_13
    581                Short = *pShort++;
    582                if (Short != ((i + j) % 255)) {
   \   00000190   ........           LDR      R9,??DataTable23_1  ;; 0x80808081
   \   00000194   B270D0E0           LDRH     R7,[R0], #+2
   \   00000198   969988E0           UMULL    R9,R8,R6,R9
   \   0000019C   077CA0E1           MOV      R7,R7, LSL #+24
   \   000001A0   A883A0E1           LSR      R8,R8,#+7
   \   000001A4   088468E0           RSB      R8,R8,R8, LSL #+8
   \   000001A8   088046E0           SUB      R8,R6,R8
   \   000001AC   270C58E1           CMP      R8,R7, LSR #+24
   \   000001B0   F2FFFF0A           BEQ      ??_TestRAM_12
    583                  return 2; /* 16 bit access error */
   \   000001B4   0200A0E3           MOV      R0,#+2
   \   000001B8   F087BDE8           POP      {R4-R10,PC}
    584                }
    585              }
    586            }
   \                     ??_TestRAM_13:
   \   000001BC   01C08CE2           ADD      R12,R12,#+1
   \   000001C0   02005CE3           CMP      R12,#+2
   \   000001C4   C8FFFF3A           BCC      ??_TestRAM_7
    587            //
    588            // Test 8 bit access
    589            //
    590            NumItems = NumBytes;
    591            for (j = 0; j < 2; j++) {
   \   000001C8   00C0A0E3           MOV      R12,#+0
    592              pByte = (U8 *)Addr;
   \                     ??_TestRAM_14:
   \   000001CC   0200A0E1           MOV      R0,R2
    593              for (i = 0; i < NumItems; i++) {
   \   000001D0   0050A0E3           MOV      R5,#+0
   \   000001D4   000051E3           CMP      R1,#+0
   \   000001D8   1D00000A           BEQ      ??_TestRAM_15
   \   000001DC   0CE0A0E1           MOV      LR,R12
   \   000001E0   010011E3           TST      R1,#0x1
   \   000001E4   0600000A           BEQ      ??_TestRAM_16
    594                Byte = (i + j) % 255;
    595                *pByte++ = Byte;
   \   000001E8   ........           LDR      R6,??DataTable23_1  ;; 0x80808081
   \   000001EC   9E6685E0           UMULL    R6,R5,LR,R6
   \   000001F0   A553A0E1           LSR      R5,R5,#+7
   \   000001F4   055465E0           RSB      R5,R5,R5, LSL #+8
   \   000001F8   05E04EE0           SUB      LR,LR,R5
   \   000001FC   01E0C0E4           STRB     LR,[R0], #+1
   \   00000200   0150A0E3           MOV      R5,#+1
   \                     ??_TestRAM_16:
   \   00000204   04E0B0E1           MOVS     LR,R4
   \   00000208   1100000A           BEQ      ??_TestRAM_15
   \   0000020C   05508CE0           ADD      R5,R12,R5
   \                     ??_TestRAM_17:
   \   00000210   ........           LDR      R7,??DataTable23_1  ;; 0x80808081
   \   00000214   ........           LDR      R8,??DataTable23_1  ;; 0x80808081
   \   00000218   957786E0           UMULL    R7,R6,R5,R7
    596              }
   \   0000021C   01E04EE2           SUB      LR,LR,#+1
   \   00000220   A663A0E1           LSR      R6,R6,#+7
   \   00000224   066466E0           RSB      R6,R6,R6, LSL #+8
   \   00000228   066045E0           SUB      R6,R5,R6
   \   0000022C   0160C0E4           STRB     R6,[R0], #+1
   \   00000230   016085E2           ADD      R6,R5,#+1
   \   00000234   968887E0           UMULL    R8,R7,R6,R8
   \   00000238   025085E2           ADD      R5,R5,#+2
   \   0000023C   A773A0E1           LSR      R7,R7,#+7
   \   00000240   077467E0           RSB      R7,R7,R7, LSL #+8
   \   00000244   076046E0           SUB      R6,R6,R7
   \   00000248   0160C0E4           STRB     R6,[R0], #+1
   \   0000024C   00005EE3           CMP      LR,#+0
   \   00000250   EEFFFF1A           BNE      ??_TestRAM_17
    597              pByte = (U8 *)Addr;
   \                     ??_TestRAM_15:
   \   00000254   0200A0E1           MOV      R0,R2
    598              for (i = 0; i < NumItems; i++) {
   \   00000258   0050A0E3           MOV      R5,#+0
   \   0000025C   0CE0A0E1           MOV      LR,R12
   \   00000260   010000EA           B        ??_TestRAM_18
   \                     ??_TestRAM_19:
   \   00000264   015085E2           ADD      R5,R5,#+1
   \   00000268   01E08EE2           ADD      LR,LR,#+1
   \                     ??_TestRAM_18:
   \   0000026C   010055E1           CMP      R5,R1
   \   00000270   0900002A           BCS      ??_TestRAM_20
    599                Byte = *pByte++;
    600                if (Byte != ((i + j) % 255)) {
   \   00000274   ........           LDR      R8,??DataTable23_1  ;; 0x80808081
   \   00000278   0160D0E4           LDRB     R6,[R0], #+1
   \   0000027C   9E8887E0           UMULL    R8,R7,LR,R8
   \   00000280   A773A0E1           LSR      R7,R7,#+7
   \   00000284   077467E0           RSB      R7,R7,R7, LSL #+8
   \   00000288   07704EE0           SUB      R7,LR,R7
   \   0000028C   070056E1           CMP      R6,R7
   \   00000290   F3FFFF0A           BEQ      ??_TestRAM_19
    601                  return 1; /* 8 bit access error */
   \   00000294   0100A0E3           MOV      R0,#+1
   \   00000298   F087BDE8           POP      {R4-R10,PC}
    602                }
    603              }
    604            }
   \                     ??_TestRAM_20:
   \   0000029C   01C08CE2           ADD      R12,R12,#+1
   \   000002A0   02005CE3           CMP      R12,#+2
   \   000002A4   C8FFFF3A           BCC      ??_TestRAM_14
    605            //
    606            // Clear test area
    607            //
    608            NumItems = NumBytes;
    609            pByte = (U8 *)Addr;
   \   000002A8   0200A0E1           MOV      R0,R2
    610            for (i = 0; i < NumItems; i++) {
   \   000002AC   000051E3           CMP      R1,#+0
   \   000002B0   0000000A           BEQ      ??_TestRAM_21
    611              *pByte++ = 0;
   \   000002B4   ........           BL       __aeabi_memclr
    612            }
    613            return 0;
   \                     ??_TestRAM_21:
   \   000002B8   0000A0E3           MOV      R0,#+0
   \   000002BC   F087BDE8           POP      {R4-R10,PC}      ;; return
    614          }
    615          #endif
    616          
    617          /*********************************************************************
    618          *
    619          *       _AssignMemory
    620          */
    621          static int _AssignMemory(void) {
    622            if (_Config.pData == NULL) {
    623              while (1); /* No data available: Stop execution */
    624            }
    625            if (_Config.Customized == 0) {
    626              //
    627              // Default, use static arrays
    628              //
    629              GUI_DEBUG_ERROROUT("No memory available");
    630            } else {
    631              //
    632              // Customized, use given memory block only
    633              //
    634              _NumBlocks = _Config.NumBytes / (_Config.BlockSize + sizeof(BLOCK)) + 2;
    635              _AllocSize = _Config.NumBytes - _NumBlocks * sizeof(BLOCK);
    636              _pBlocks   = (BLOCK *)_Config.pData;
    637              _pHeap     = (GUI_HEAP *)((U8 *)_Config.pData + _NumBlocks * sizeof(BLOCK));
    638              //_pHeap     = (GUI_HEAP *)_Config.pData;
    639              //_pBlocks   = (BLOCK *)((U8 *)_Config.pData + _AllocSize);
    640              #if (GUI_DEBUG_LEVEL > 0)
    641                if (_TestRAM((U32)_Config.pData, (_Config.NumBytes > 0x2800) ? 0x2800 : _Config.NumBytes)) {
    642                  GUI_DEBUG_ERROROUT("Memory test failed");
    643                }
    644              #endif
    645            }
    646            return 0;
    647          }
    648          
    649          /*********************************************************************
    650          *
    651          *       _InitOnce
    652          *
    653          * Purpose:
    654          *   Initialization of memory management. Empty blocks will be joined
    655          *   together, the minimum size of the list of free blocks will be
    656          *   initialized and the one and only free memory block will be added.
    657          */

   \                                 In section .text, align 4, keep-with-next
    658          static void _InitOnce(void) {
   \                     _InitOnce:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    659            unsigned i;
    660            //
    661            // Return if already initialized
    662            //
    663            if (_IsInitialized) {
   \   00000004   ........           LDR      R4,??DataTable23
   \   00000008   C400D4E5           LDRB     R0,[R4, #+196]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   4100001A           BNE      ??_InitOnce_0
    664              return;
    665            }
    666            //
    667            // Assign memory
    668            //
    669            if (_AssignMemory()) {
   \   00000014   005094E5           LDR      R5,[R4, #+0]
   \   00000018   000055E3           CMP      R5,#+0
   \   0000001C   3F00000A           BEQ      ??_InitOnce_1
   \   00000020   1400D4E5           LDRB     R0,[R4, #+20]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   1200000A           BEQ      ??_InitOnce_2
   \   0000002C   086094E5           LDR      R6,[R4, #+8]
   \   00000030   101094E5           LDR      R1,[R4, #+16]
   \   00000034   0600A0E1           MOV      R0,R6
   \   00000038   081081E2           ADD      R1,R1,#+8
   \   0000003C   ........           BL       __aeabi_uidiv
   \   00000040   020080E2           ADD      R0,R0,#+2
   \   00000044   AC0084E5           STR      R0,[R4, #+172]
   \   00000048   801146E0           SUB      R1,R6,R0, LSL #+3
   \   0000004C   800185E0           ADD      R0,R5,R0, LSL #+3
   \   00000050   B40084E5           STR      R0,[R4, #+180]
   \   00000054   0100A0E3           MOV      R0,#+1
   \   00000058   A00D80E3           ORR      R0,R0,#0x2800
   \   0000005C   000056E1           CMP      R6,R0
   \   00000060   A81084E5           STR      R1,[R4, #+168]
   \   00000064   A06DA023           MOVCS    R6,#+10240
   \   00000068   B85084E5           STR      R5,[R4, #+184]
   \   0000006C   0610A0E1           MOV      R1,R6
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   ........           BL       _TestRAM
    670              return;
    671            }
    672            _IsInitialized = 1;
    673            //
    674            // Create linked list of empty blocks
    675            //
    676            for (i = 0; i < _NumBlocks - 1; i++) {
   \                     ??_InitOnce_2:
   \   00000078   AC2094E5           LDR      R2,[R4, #+172]
   \   0000007C   0100A0E3           MOV      R0,#+1
   \   00000080   C400C4E5           STRB     R0,[R4, #+196]
   \   00000084   0010A0E3           MOV      R1,#+0
   \   00000088   012052E2           SUBS     R2,R2,#+1
   \   0000008C   0C00000A           BEQ      ??_InitOnce_3
   \   00000090   B83094E5           LDR      R3,[R4, #+184]
   \   00000094   010012E3           TST      R2,#0x1
   \   00000098   043083E2           ADD      R3,R3,#+4
    677              (_pBlocks + i)->u.NextBlock = i + 1;
   \   0000009C   08008314           STRNE    R0,[R3], #+8
   \   000000A0   0110A013           MOVNE    R1,#+1
   \   000000A4   A2C0B0E1           LSRS     R12,R2,#+1
   \   000000A8   0500000A           BEQ      ??_InitOnce_3
   \                     ??_InitOnce_4:
   \   000000AC   011081E2           ADD      R1,R1,#+1
   \   000000B0   081083E4           STR      R1,[R3], #+8
   \   000000B4   011081E2           ADD      R1,R1,#+1
   \   000000B8   081083E4           STR      R1,[R3], #+8
    678            }
   \   000000BC   01C05CE2           SUBS     R12,R12,#+1
   \   000000C0   F9FFFF1A           BNE      ??_InitOnce_4
    679            _FirstFreeBlock = 1;
   \                     ??_InitOnce_3:
   \   000000C4   BC0084E5           STR      R0,[R4, #+188]
    680            _NumFreeBlocks  = _NumBlocks - 1;
   \   000000C8   A42084E5           STR      R2,[R4, #+164]
    681            //
    682            // Initialize list of free memory free blocks
    683            //
    684            for (i = 0; i < GUI_COUNTOF(_aFreeMem); i++) {
   \   000000CC   0000A0E3           MOV      R0,#+0
   \   000000D0   181084E2           ADD      R1,R4,#+24
    685              _aFreeMem[i].MinSize = GUI_ALLOC_MIN_BLOCKSIZE << i;
   \                     ??_InitOnce_5:
   \   000000D4   1020A0E3           MOV      R2,#+16
   \   000000D8   1230A0E1           LSL      R3,R2,R0
   \   000000DC   083081E4           STR      R3,[R1], #+8
   \   000000E0   010080E2           ADD      R0,R0,#+1
   \   000000E4   1230A0E1           LSL      R3,R2,R0
   \   000000E8   083081E4           STR      R3,[R1], #+8
   \   000000EC   010080E2           ADD      R0,R0,#+1
   \   000000F0   1230A0E1           LSL      R3,R2,R0
   \   000000F4   010080E2           ADD      R0,R0,#+1
   \   000000F8   1220A0E1           LSL      R2,R2,R0
   \   000000FC   083081E4           STR      R3,[R1], #+8
    686            }
   \   00000100   010080E2           ADD      R0,R0,#+1
   \   00000104   082081E4           STR      R2,[R1], #+8
   \   00000108   100050E3           CMP      R0,#+16
   \   0000010C   F0FFFF3A           BCC      ??_InitOnce_5
    687            //
    688            // Add the one and only initial memory block
    689            //
    690            _AddFreeMemory(_AllocSize, _pHeap->abHeap);
   \   00000110   B41094E5           LDR      R1,[R4, #+180]
   \   00000114   A80094E5           LDR      R0,[R4, #+168]
   \   00000118   ........           BL       _AddFreeMemory
    691          }
   \                     ??_InitOnce_0:
   \   0000011C   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??_InitOnce_1:
   \   00000120   FEFFFFEA           B        ??_InitOnce_1
    692          
    693          /*********************************************************************
    694          *
    695          *       _PopFreeBlock
    696          *
    697          * Purpose:
    698          *   Returns a free block index and removes it from the list of free blocks.
    699          */
    700          static GUI_HMEM _PopFreeBlock(void) {
    701            GUI_HMEM hMem;
    702            //
    703            // Return if no free block is available
    704            //
    705            if (_NumFreeBlocks == 0) {
    706              return 0;
    707            }
    708            _NumFreeBlocks--;
    709            hMem = _FirstFreeBlock;
    710            _FirstFreeBlock = (_pBlocks + _FirstFreeBlock)->u.NextBlock;
    711            #if GUI_DEBUG_LEVEL > 0
    712              (_pBlocks + hMem)->InUse = 1;
    713            #endif
    714            return hMem;
    715          }
    716          
    717          /*********************************************************************
    718          *
    719          *       _PushFreeBlock
    720          *
    721          * Purpose:
    722          *   Adds a free block index to the list of free blocks.
    723          */
    724          static void _PushFreeBlock(GUI_HMEM hMem) {
    725            _NumFreeBlocks++;
    726            (_pBlocks + hMem)->u.NextBlock = _FirstFreeBlock;
    727            #if GUI_DEBUG_LEVEL > 0
    728              (_pBlocks + hMem)->InUse = 0;
    729            #endif
    730            _FirstFreeBlock = hMem;
    731          }
    732          
    733          /*********************************************************************
    734          *
    735          *       _SizeToLegalSize
    736          *
    737          * Purpose:
    738          *   Makes sure, that the size is not smaller than the minimum block size.
    739          */
    740          static U32 _SizeToLegalSize(U32 Size) {
    741            Size = (Size < _aFreeMem[0].MinSize) ? _aFreeMem[0].MinSize : (Size + ((1 << 2) - 1)) & (U32)~((1 << 2) - 1);
    742            return GROSS(Size);
    743          }
    744          
    745          /*********************************************************************
    746          *
    747          *       Static code, used by public code
    748          *
    749          **********************************************************************
    750          */
    751          /*********************************************************************
    752          *
    753          *       _GetSize
    754          *
    755          * Purpose:
    756          *   Returns the number of available bytes of the given block.
    757          */
    758          static GUI_ALLOC_DATATYPE _GetSize(GUI_HMEM  hMem) {
    759            TAG * pTag;
    760            pTag = (_pBlocks + hMem)->u.pTag;
    761            return NET(pTag->MemTag.Size);
    762          }
    763          
    764          /*********************************************************************
    765          *
    766          *       _Alloc
    767          *
    768          * Purpose:
    769          *   Allocates a new memory block of the requested size. The minimum size 
    770          *   of a free block is the smallest legal size of a free block. If the 
    771          *   requested size is less it will be enlarged to the minimum legal size.
    772          *
    773          * Return value:
    774          *   Handle of the memory block, 0 if the requested number of bytes are not available
    775          */

   \                                 In section .text, align 4, keep-with-next
    776          static GUI_HMEM _Alloc(GUI_ALLOC_DATATYPE Size) {
   \                     _Alloc:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    777            GUI_HMEM hMem;
    778            GUI_ALLOC_DATATYPE OldSize;
    779            TAG * pTag;
    780            _InitOnce();
   \   00000008   ........           BL       _InitOnce
    781          
    782            if (_LockCntHandles > 0) {
    783              //
    784              // "Locked handles exist" means, that pointers are currently in use. In case of
    785              // allocating memory it can occur, that memory blocks are moved during allocation
    786              // and these pointers become invalid. Moving memory blocks is only required if the
    787              // the system is short on memory.
    788              //
    789              GUI_DEBUG_ERROROUT("Locked handles exist. More details can be found in GUI_Alloc.c");
    790            }
    791            //
    792            // Adjust size
    793            //
    794            Size = _SizeToLegalSize(Size);
   \   0000000C   ........           LDR      R5,??DataTable23
   \   00000010   180095E5           LDR      R0,[R5, #+24]
   \   00000014   000054E1           CMP      R4,R0
   \   00000018   03008422           ADDCS    R0,R4,#+3
   \   0000001C   0300C023           BICCS    R0,R0,#0x3
   \   00000020   0C4080E2           ADD      R4,R0,#+12
    795            //
    796            // Get pointer to free memory block
    797            //
    798            do {
    799              //
    800              // Get free memory tag
    801              //
    802              pTag = _GetFreeTag(Size);
   \                     ??_Alloc_0:
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   0F30A0E3           MOV      R3,#+15
   \   00000030   90C085E2           ADD      R12,R5,#+144
   \                     ??_Alloc_1:
   \   00000034   08E01CE4           LDR      LR,[R12], #-8
   \   00000038   0E0054E1           CMP      R4,LR
   \   0000003C   0100002A           BCS      ??_Alloc_2
   \   00000040   013053E2           SUBS     R3,R3,#+1
   \   00000044   FAFFFF5A           BPL      ??_Alloc_1
   \                     ??_Alloc_2:
   \   00000048   83C185E0           ADD      R12,R5,R3, LSL #+3
   \   0000004C   1CC08CE2           ADD      R12,R12,#+28
   \   00000050   0B0000EA           B        ??_Alloc_3
   \                     ??_Alloc_4:
   \   00000054   08109EE5           LDR      R1,[LR, #+8]
   \                     ??_Alloc_5:
   \   00000058   04E091E5           LDR      LR,[R1, #+4]
   \   0000005C   04005EE1           CMP      LR,R4
   \   00000060   0500002A           BCS      ??_Alloc_6
   \   00000064   08E091E5           LDR      LR,[R1, #+8]
   \   00000068   00005EE3           CMP      LR,#+0
   \   0000006C   F8FFFF1A           BNE      ??_Alloc_4
   \   00000070   04E091E5           LDR      LR,[R1, #+4]
   \   00000074   04005EE1           CMP      LR,R4
   \   00000078   0010A033           MOVCC    R1,#+0
   \                     ??_Alloc_6:
   \   0000007C   013083E2           ADD      R3,R3,#+1
   \   00000080   08C08CE2           ADD      R12,R12,#+8
   \                     ??_Alloc_3:
   \   00000084   100053E3           CMP      R3,#+16
   \   00000088   0600002A           BCS      ??_Alloc_7
   \   0000008C   00109CE5           LDR      R1,[R12, #+0]
   \   00000090   000051E3           CMP      R1,#+0
   \   00000094   F8FFFF0A           BEQ      ??_Alloc_6
   \   00000098   081091E5           LDR      R1,[R1, #+8]
   \   0000009C   04E091E5           LDR      LR,[R1, #+4]
   \   000000A0   04005EE1           CMP      LR,R4
   \   000000A4   EBFFFF3A           BCC      ??_Alloc_5
    803              if (pTag == NULL) {
   \                     ??_Alloc_7:
   \   000000A8   000051E3           CMP      R1,#+0
   \   000000AC   0900001A           BNE      ??_Alloc_8
    804                //
    805                // Check if the memory is locked
    806                //
    807                if (_LockCnt || _LockCntHandles) {
   \   000000B0   980095E5           LDR      R0,[R5, #+152]
   \   000000B4   9C1095E5           LDR      R1,[R5, #+156]
   \   000000B8   000091E1           ORRS     R0,R1,R0
   \   000000BC   0100000A           BEQ      ??_Alloc_9
    808                  //
    809                  // If memory or pointer are locked, return
    810                  //
    811                  return 0;
   \                     ??_Alloc_10:
   \   000000C0   0000A0E3           MOV      R0,#+0
   \   000000C4   F081BDE8           POP      {R4-R8,PC}
    812                } else {
    813                  //
    814                  // If there is no memory block available remove the holes
    815                  //
    816                  if (_RemoveHoles()) {
   \                     ??_Alloc_9:
   \   000000C8   ........           BL       _RemoveHoles
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   FAFFFF1A           BNE      ??_Alloc_10
   \   000000D4   D2FFFFEA           B        ??_Alloc_0
    817                    //
    818                    // If there is no hole of the requested size, return
    819                    //
    820                    return 0;
    821                  }
    822                }
    823              }
    824            } while (pTag == NULL);
    825            //
    826            // Get block index to be returned
    827            //
    828            hMem = _PopFreeBlock();
   \                     ??_Alloc_8:
   \   000000D8   A42095E5           LDR      R2,[R5, #+164]
   \   000000DC   000052E3           CMP      R2,#+0
   \   000000E0   0900000A           BEQ      ??_Alloc_11
   \   000000E4   012042E2           SUB      R2,R2,#+1
   \   000000E8   A42085E5           STR      R2,[R5, #+164]
   \   000000EC   BC6095E5           LDR      R6,[R5, #+188]
   \   000000F0   B82095E5           LDR      R2,[R5, #+184]
   \   000000F4   863182E0           ADD      R3,R2,R6, LSL #+3
   \   000000F8   043093E5           LDR      R3,[R3, #+4]
   \   000000FC   BC3085E5           STR      R3,[R5, #+188]
   \   00000100   0130A0E3           MOV      R3,#+1
   \   00000104   8631C2E7           STRB     R3,[R2, +R6, LSL #+3]
   \   00000108   000000EA           B        ??_Alloc_12
   \                     ??_Alloc_11:
   \   0000010C   0060A0E3           MOV      R6,#+0
    829            //
    830            // Save old size of memory block
    831            //
    832            OldSize = pTag->MemTag.Size;
   \                     ??_Alloc_12:
   \   00000110   043091E5           LDR      R3,[R1, #+4]
    833            //
    834            // Make sure rest of block is not too small
    835            //
    836            if ((U32)(OldSize - Size) < GROSS(_aFreeMem[0].MinSize)) {
   \   00000114   18E095E5           LDR      LR,[R5, #+24]
   \   00000118   0320A0E1           MOV      R2,R3
   \   0000011C   04C042E0           SUB      R12,R2,R4
   \   00000120   0CE08EE2           ADD      LR,LR,#+12
   \   00000124   0E005CE1           CMP      R12,LR
    837              Size = OldSize;
   \   00000128   0240A031           MOVCC    R4,R2
    838            }
    839            //
    840            // Remove block from free memory
    841            //
    842            _RemoveFreeMemory(pTag);
   \   0000012C   0FE0A0E3           MOV      LR,#+15
   \   00000130   907085E2           ADD      R7,R5,#+144
   \                     ??_Alloc_13:
   \   00000134   088017E4           LDR      R8,[R7], #-8
   \   00000138   080053E1           CMP      R3,R8
   \   0000013C   0100002A           BCS      ??_Alloc_14
   \   00000140   01E05EE2           SUBS     LR,LR,#+1
   \   00000144   FAFFFF5A           BPL      ??_Alloc_13
   \                     ??_Alloc_14:
   \   00000148   A0C095E5           LDR      R12,[R5, #+160]
   \   0000014C   03304CE0           SUB      R3,R12,R3
   \   00000150   A03085E5           STR      R3,[R5, #+160]
   \   00000154   8E3185E0           ADD      R3,R5,LR, LSL #+3
   \   00000158   08C081E2           ADD      R12,R1,#+8
   \   0000015C   00E09CE5           LDR      LR,[R12, #+0]
   \   00000160   04C09CE5           LDR      R12,[R12, #+4]
   \   00000164   00005EE3           CMP      LR,#+0
   \   00000168   04C08E15           STRNE    R12,[LR, #+4]
   \   0000016C   1C3083E2           ADD      R3,R3,#+28
   \   00000170   00005CE3           CMP      R12,#+0
   \   00000174   00E08305           STREQ    LR,[R3, #+0]
   \   00000178   00E08C15           STRNE    LR,[R12, #+0]
    843            //
    844            // Set memory pointer
    845            //
    846            (_pBlocks + hMem)->u.pTag = pTag;
   \   0000017C   B83095E5           LDR      R3,[R5, #+184]
    847            //
    848            // Write tag information
    849            //
    850            _WriteTagData(pTag, hMem, Size, NULL);
    851            //
    852            // Add rest of block to empty memory
    853            //
    854            if (OldSize > Size) {
   \   00000180   020054E1           CMP      R4,R2
   \   00000184   863183E0           ADD      R3,R3,R6, LSL #+3
   \   00000188   041083E5           STR      R1,[R3, #+4]
   \   0000018C   006081E5           STR      R6,[R1, #+0]
   \   00000190   044081E5           STR      R4,[R1, #+4]
   \   00000194   080081E5           STR      R0,[R1, #+8]
   \   00000198   101081E5           STR      R1,[R1, #+16]
   \   0000019C   011084E0           ADD      R1,R4,R1
   \   000001A0   044001E5           STR      R4,[R1, #-4]
   \   000001A4   010000AA           BGE      ??_Alloc_15
    855              _AddFreeMemory(OldSize - Size, (void *)((U32)pTag + Size));
   \   000001A8   040042E0           SUB      R0,R2,R4
   \   000001AC   ........           BL       _AddFreeMemory
    856            }
    857          
    858            return hMem;
   \                     ??_Alloc_15:
   \   000001B0   0600A0E1           MOV      R0,R6
   \   000001B4   F081BDE8           POP      {R4-R8,PC}       ;; return
    859          }
    860          
    861          /*********************************************************************
    862          *
    863          *       _Free
    864          *
    865          * Purpose:
    866          *   Adds the given memory block to the free memory.
    867          */
    868          static void _Free(GUI_HMEM hMem) {
    869            TAG * pTag;
    870            #if GUI_DEBUG_LEVEL > 0
    871            if ((_pBlocks + hMem)->InUse == 0) {
    872              GUI_DEBUG_ERROROUT("Block already free");
    873              return;
    874            }
    875            #endif
    876            pTag = (_pBlocks + hMem)->u.pTag;
    877            #ifdef WIN32
    878              GUI_MEMSET((U8 *)&pTag->FreeTag, 0xcc, NET(pTag->MemTag.Size));
    879            #endif
    880            //
    881            // Add block to free memory
    882            //
    883            _AddFreeMemory(pTag->MemTag.Size, pTag);
    884            //
    885            // Put block into list of free blocks
    886            //
    887            _PushFreeBlock(hMem);
    888          }
    889          
    890          /*********************************************************************
    891          *
    892          *       _GetFixedBlock
    893          */
    894          static void * _GetFixedBlock(GUI_ALLOC_DATATYPE Size) {
    895            FREE_TAG * pFree;
    896          
    897            pFree = _pFirstFixedFreeTag;
    898            while (pFree) {
    899              if (*((I32 *)pFree - 1) == Size) {
    900                return pFree;
    901              }
    902              pFree = pFree->pNext;
    903            }
    904            return NULL;
    905          }
    906          
    907          /*********************************************************************
    908          *
    909          *       Public code
    910          *
    911          **********************************************************************
    912          */
    913          /*********************************************************************
    914          *
    915          *       GUI_ALLOC_p2h
    916          */

   \                                 In section .text, align 4, keep-with-next
    917          GUI_HMEM GUI_ALLOC_p2h(void * p) {
    918            GUI_HMEM hMem;
    919            MEM_TAG * pTag;
    920            
    921            pTag = (MEM_TAG *)p - 1;
    922            hMem = pTag->Block;
    923            return hMem;
   \                     GUI_ALLOC_p2h:
   \   00000000   080010E5           LDR      R0,[R0, #-8]
   \   00000004   1EFF2FE1           BX       LR               ;; return
    924          }
    925          
    926          /*********************************************************************
    927          *
    928          *       GUI_ALLOC_FreeFixedBlock
    929          */

   \                                 In section .text, align 4, keep-with-next
    930          void GUI_ALLOC_FreeFixedBlock(void * pBlock) {
    931            FREE_TAG * pFree;
    932            
    933            pFree = (FREE_TAG *)pBlock;
    934            pFree->pNext = _pFirstFixedFreeTag;
   \                     GUI_ALLOC_FreeFixedBlock:
   \   00000000   ........           LDR      R1,??DataTable23
   \   00000004   C02091E5           LDR      R2,[R1, #+192]
   \   00000008   002080E5           STR      R2,[R0, #+0]
    935            if (pFree->pNext) {
   \   0000000C   000052E3           CMP      R2,#+0
    936              pFree->pNext->pPrev = pFree;
   \   00000010   04008215           STRNE    R0,[R2, #+4]
    937            }
    938            _pFirstFixedFreeTag = (FREE_TAG *)pBlock;
   \   00000014   C00081E5           STR      R0,[R1, #+192]
    939          }
   \   00000018   1EFF2FE1           BX       LR               ;; return
    940          
    941          /*********************************************************************
    942          *
    943          *       GUI_ALLOC_GetFixedBlock
    944          */

   \                                 In section .text, align 4, keep-with-next
    945          void * GUI_ALLOC_GetFixedBlock(GUI_ALLOC_DATATYPE Size) {
   \                     GUI_ALLOC_GetFixedBlock:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    946            void * p;
    947            TAG * pTag;
    948            FREE_TAG * pFree;
    949          
    950            if (_LockCntHandles > 0) {
    951              //
    952              // "Locked handles exist" means, that pointers are currently in use. In case of
    953              // allocating memory it can occur, that memory blocks are moved during allocation
    954              // and these pointers become invalid. Moving memory blocks is only required if the
    955              // the system is short on memory.
    956              //
    957              GUI_DEBUG_ERROROUT("Locked handles exist. More details can be found in GUI_Alloc.c");
    958            }
    959            _InitOnce();
   \   00000008   ........           BL       _InitOnce
    960            Size = (((Size + 3) >> 2) << 2) /* 4 byte alignment */
    961                   + sizeof(U32);           /* Additional size entry at bottom of block */
   \   0000000C   030084E2           ADD      R0,R4,#+3
   \   00000010   4001A0E1           ASR      R0,R0,#+2
   \   00000014   0410A0E3           MOV      R1,#+4
    962            if ((U32)Size < _aFreeMem[0].MinSize) {
   \   00000018   ........           LDR      R4,??DataTable23
   \   0000001C   005181E0           ADD      R5,R1,R0, LSL #+2
   \   00000020   180094E5           LDR      R0,[R4, #+24]
   \   00000024   000055E1           CMP      R5,R0
    963              Size = _aFreeMem[0].MinSize;
   \   00000028   0050A031           MOVCC    R5,R0
    964            }
    965            //
    966            // Try to get an already existing block
    967            //
    968            p = _GetFixedBlock(Size);
   \   0000002C   C00094E5           LDR      R0,[R4, #+192]
   \   00000030   0060A0E1           MOV      R6,R0
   \   00000034   000000EA           B        ??GUI_ALLOC_GetFixedBlock_0
   \                     ??GUI_ALLOC_GetFixedBlock_1:
   \   00000038   006096E5           LDR      R6,[R6, #+0]
   \                     ??GUI_ALLOC_GetFixedBlock_0:
   \   0000003C   000056E3           CMP      R6,#+0
   \   00000040   0B00001A           BNE      ??GUI_ALLOC_GetFixedBlock_2
    969            if (p) {
    970              //
    971              // Unlink free block from linked list
    972              //
    973              pFree = (FREE_TAG *)p;
    974              if (pFree->pNext) {
    975                pFree->pNext->pPrev = pFree->pPrev;
    976              }
    977              if (pFree->pPrev) {
    978                pFree->pPrev->pNext = pFree->pNext;
    979              }
    980              if (_pFirstFixedFreeTag == pFree) {
    981                _pFirstFixedFreeTag = pFree->pNext;
    982              }
    983            } else {
    984              //
    985              // Remove holes to make sure that there is only one free memory block
    986              //
    987              _RemoveHoles();
   \                     ??GUI_ALLOC_GetFixedBlock_3:
   \   00000044   ........           BL       _RemoveHoles
    988              //
    989              // Get tag of the one and only free memory block
    990              //
    991              pTag = _GetFreeTag(Size);
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   0F30A0E3           MOV      R3,#+15
   \   00000050   90C084E2           ADD      R12,R4,#+144
   \                     ??GUI_ALLOC_GetFixedBlock_4:
   \   00000054   08E01CE4           LDR      LR,[R12], #-8
   \   00000058   0E0055E1           CMP      R5,LR
   \   0000005C   0100002A           BCS      ??GUI_ALLOC_GetFixedBlock_5
   \   00000060   013053E2           SUBS     R3,R3,#+1
   \   00000064   FAFFFF5A           BPL      ??GUI_ALLOC_GetFixedBlock_4
   \                     ??GUI_ALLOC_GetFixedBlock_5:
   \   00000068   83C184E0           ADD      R12,R4,R3, LSL #+3
   \   0000006C   1CC08CE2           ADD      R12,R12,#+28
   \   00000070   1D0000EA           B        ??GUI_ALLOC_GetFixedBlock_6
   \                     ??GUI_ALLOC_GetFixedBlock_2:
   \   00000074   041016E5           LDR      R1,[R6, #-4]
   \   00000078   050051E1           CMP      R1,R5
   \   0000007C   EDFFFF1A           BNE      ??GUI_ALLOC_GetFixedBlock_1
   \   00000080   000056E3           CMP      R6,#+0
   \   00000084   EEFFFF0A           BEQ      ??GUI_ALLOC_GetFixedBlock_3
   \   00000088   001096E5           LDR      R1,[R6, #+0]
   \   0000008C   000051E3           CMP      R1,#+0
   \   00000090   04209615           LDRNE    R2,[R6, #+4]
   \   00000094   04208115           STRNE    R2,[R1, #+4]
   \   00000098   041096E5           LDR      R1,[R6, #+4]
   \   0000009C   000051E3           CMP      R1,#+0
   \   000000A0   00209615           LDRNE    R2,[R6, #+0]
   \   000000A4   00208115           STRNE    R2,[R1, #+0]
   \   000000A8   060050E1           CMP      R0,R6
   \   000000AC   3E00001A           BNE      ??GUI_ALLOC_GetFixedBlock_7
   \   000000B0   000096E5           LDR      R0,[R6, #+0]
   \   000000B4   C00084E5           STR      R0,[R4, #+192]
   \   000000B8   3B0000EA           B        ??GUI_ALLOC_GetFixedBlock_7
   \                     ??GUI_ALLOC_GetFixedBlock_8:
   \   000000BC   08109EE5           LDR      R1,[LR, #+8]
   \                     ??GUI_ALLOC_GetFixedBlock_9:
   \   000000C0   04E091E5           LDR      LR,[R1, #+4]
   \   000000C4   05005EE1           CMP      LR,R5
   \   000000C8   0500002A           BCS      ??GUI_ALLOC_GetFixedBlock_10
   \   000000CC   08E091E5           LDR      LR,[R1, #+8]
   \   000000D0   00005EE3           CMP      LR,#+0
   \   000000D4   F8FFFF1A           BNE      ??GUI_ALLOC_GetFixedBlock_8
   \   000000D8   04E091E5           LDR      LR,[R1, #+4]
   \   000000DC   05005EE1           CMP      LR,R5
   \   000000E0   0010A033           MOVCC    R1,#+0
   \                     ??GUI_ALLOC_GetFixedBlock_10:
   \   000000E4   013083E2           ADD      R3,R3,#+1
   \   000000E8   08C08CE2           ADD      R12,R12,#+8
   \                     ??GUI_ALLOC_GetFixedBlock_6:
   \   000000EC   100053E3           CMP      R3,#+16
   \   000000F0   0600002A           BCS      ??GUI_ALLOC_GetFixedBlock_11
   \   000000F4   00109CE5           LDR      R1,[R12, #+0]
   \   000000F8   000051E3           CMP      R1,#+0
   \   000000FC   F8FFFF0A           BEQ      ??GUI_ALLOC_GetFixedBlock_10
   \   00000100   081091E5           LDR      R1,[R1, #+8]
   \   00000104   04E091E5           LDR      LR,[R1, #+4]
   \   00000108   05005EE1           CMP      LR,R5
   \   0000010C   EBFFFF3A           BCC      ??GUI_ALLOC_GetFixedBlock_9
    992              //
    993              // Check available number of bytes
    994              //
    995              if (pTag) {
   \                     ??GUI_ALLOC_GetFixedBlock_11:
   \   00000110   000051E3           CMP      R1,#+0
   \   00000114   2400000A           BEQ      ??GUI_ALLOC_GetFixedBlock_7
    996                if (Size > (GUI_ALLOC_DATATYPE)pTag->MemTag.Size) {
   \   00000118   040091E5           LDR      R0,[R1, #+4]
   \   0000011C   050050E1           CMP      R0,R5
   \   00000120   210000BA           BLT      ??GUI_ALLOC_GetFixedBlock_7
    997                  p = NULL; /* Not enough memory available */
    998                } else {
    999                  //
   1000                  // Create pointer. Please note that at this point the whole 
   1001                  // existing free memory is referenced by pTag.
   1002                  //
   1003                  p = (void *)((U8 *)pTag                     /* First byte of the free memory block */
   1004                                     + pTag->MemTag.Size      /* Number of free bytes */
   1005                                     - (Size - sizeof(U32))); /* Number of requested bytes */
   \   00000124   042045E2           SUB      R2,R5,#+4
   \   00000128   002062E2           RSB      R2,R2,#+0
   \   0000012C   013080E0           ADD      R3,R0,R1
   \   00000130   036082E0           ADD      R6,R2,R3
   1006                  //
   1007                  // Remove complete free memory
   1008                  //
   1009                  _RemoveFreeMemory(pTag);
   \   00000134   0F30A0E3           MOV      R3,#+15
   \   00000138   90C084E2           ADD      R12,R4,#+144
   \                     ??GUI_ALLOC_GetFixedBlock_12:
   \   0000013C   08E01CE4           LDR      LR,[R12], #-8
   \   00000140   0E0050E1           CMP      R0,LR
   \   00000144   0100002A           BCS      ??GUI_ALLOC_GetFixedBlock_13
   \   00000148   013053E2           SUBS     R3,R3,#+1
   \   0000014C   FAFFFF5A           BPL      ??GUI_ALLOC_GetFixedBlock_12
   \                     ??GUI_ALLOC_GetFixedBlock_13:
   \   00000150   A02094E5           LDR      R2,[R4, #+160]
   \   00000154   000042E0           SUB      R0,R2,R0
   \   00000158   A00084E5           STR      R0,[R4, #+160]
   \   0000015C   830184E0           ADD      R0,R4,R3, LSL #+3
   \   00000160   082081E2           ADD      R2,R1,#+8
   \   00000164   003092E5           LDR      R3,[R2, #+0]
   \   00000168   042092E5           LDR      R2,[R2, #+4]
   \   0000016C   000053E3           CMP      R3,#+0
   \   00000170   04208315           STRNE    R2,[R3, #+4]
   \   00000174   1C0080E2           ADD      R0,R0,#+28
   \   00000178   000052E3           CMP      R2,#+0
   \   0000017C   00308005           STREQ    R3,[R0, #+0]
   \   00000180   00308215           STRNE    R3,[R2, #+0]
   1010                  //
   1011                  // Adjust sizes
   1012                  //
   1013                  _AllocSize     -= Size; /* Bytes are no longer available for dynamic memory access */
   \   00000184   A80094E5           LDR      R0,[R4, #+168]
   \   00000188   050040E0           SUB      R0,R0,R5
   \   0000018C   A80084E5           STR      R0,[R4, #+168]
   1014                  _NumFixedBytes += Size; /* Add them to the number of fixed bytes */
   \   00000190   B00094E5           LDR      R0,[R4, #+176]
   \   00000194   000085E0           ADD      R0,R5,R0
   \   00000198   B00084E5           STR      R0,[R4, #+176]
   1015                  //
   1016                  // Add remaining bytes to the free memory
   1017                  //
   1018                  _AddFreeMemory(pTag->MemTag.Size - Size, pTag);
   \   0000019C   040091E5           LDR      R0,[R1, #+4]
   \   000001A0   050040E0           SUB      R0,R0,R5
   \   000001A4   ........           BL       _AddFreeMemory
   1019                  //
   1020                  // Write block size below block
   1021                  //
   1022                  *((U32 *)p - 1) = Size;
   \   000001A8   045006E5           STR      R5,[R6, #-4]
   1023                }
   1024              }
   1025            }
   1026            return p;
   \                     ??GUI_ALLOC_GetFixedBlock_7:
   \   000001AC   0600A0E1           MOV      R0,R6
   \   000001B0   7080BDE8           POP      {R4-R6,PC}       ;; return
   1027          }
   1028          
   1029          /*********************************************************************
   1030          *
   1031          *       GUI_ALLOC_AllocNoInit
   1032          */

   \                                 In section .text, align 4, keep-with-next
   1033          GUI_HMEM GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE Size) {
   \                     GUI_ALLOC_AllocNoInit:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   1034            GUI_HMEM hMem;
   1035            if (Size == 0) {
   \   00000008   0100001A           BNE      ??GUI_ALLOC_AllocNoInit_0
   1036              return (GUI_HMEM)0;
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   1080BDE8           POP      {R4,PC}
   1037            }
   1038            GUI_LOCK();
   \                     ??GUI_ALLOC_AllocNoInit_0:
   \   00000014   ........           BL       GUI_Lock
   1039            GUI_DEBUG_LOG2("\nGUI_ALLOC_AllocNoInit... requesting %d, %d avail", Size, _NumFreeBytes);
   1040            hMem = _Alloc(Size);
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           BL       _Alloc
   \   00000020   0040A0E1           MOV      R4,R0
   1041            GUI_DEBUG_LOG1("\nGUI_ALLOC_AllocNoInit : Handle", hMem);
   1042            GUI_UNLOCK();
   \   00000024   ........           BL       GUI_Unlock
   1043            return hMem;
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   1080BDE8           POP      {R4,PC}          ;; return
   1044          }
   1045          
   1046          /*********************************************************************
   1047          *
   1048          *       GUI_ALLOC_h2p
   1049          */

   \                                 In section .text, align 4, keep-with-next
   1050          void * GUI_ALLOC_h2p(GUI_HMEM  hMem) {
   1051            GUI_ASSERT_LOCK();
   1052            #if GUI_DEBUG_LEVEL > 0
   1053              if (!hMem) {
   \                     GUI_ALLOC_h2p:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   0400000A           BEQ      ??GUI_ALLOC_h2p_0
   1054                GUI_DEBUG_ERROROUT("\n"__FILE__ " GUI_ALLOC_h2p: illegal argument (0 handle)");
   1055                return 0;
   1056              }
   1057              if ((_pBlocks + hMem)->InUse == 0) {
   1058                GUI_DEBUG_ERROROUT("Dereferencing free block");
   1059              }
   1060            #endif
   1061            return (void *)&(_pBlocks + hMem)->u.pTag->FreeTag;
   \   00000008   ........           LDR      R1,??DataTable23
   \   0000000C   B81091E5           LDR      R1,[R1, #+184]
   \   00000010   800181E0           ADD      R0,R1,R0, LSL #+3
   \   00000014   040090E5           LDR      R0,[R0, #+4]
   \   00000018   080080E2           ADD      R0,R0,#+8
   \                     ??GUI_ALLOC_h2p_0:
   \   0000001C   1EFF2FE1           BX       LR               ;; return
   1062          }
   1063          
   1064          /*********************************************************************
   1065          *
   1066          *       GUI_ALLOC_LockH
   1067          */

   \                                 In section .text, align 4, keep-with-next
   1068          void * GUI_ALLOC_LockH(GUI_HMEM hMem) {
   1069            _LockCntHandles++;
   \                     GUI_ALLOC_LockH:
   \   00000000   ........           LDR      R1,??DataTable23
   1070            return GUI_ALLOC_h2p(hMem);
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   9C2091E5           LDR      R2,[R1, #+156]
   \   0000000C   012082E2           ADD      R2,R2,#+1
   \   00000010   9C2081E5           STR      R2,[R1, #+156]
   \   00000014   0300000A           BEQ      ??GUI_ALLOC_LockH_0
   \   00000018   B81091E5           LDR      R1,[R1, #+184]
   \   0000001C   800181E0           ADD      R0,R1,R0, LSL #+3
   \   00000020   040090E5           LDR      R0,[R0, #+4]
   \   00000024   080080E2           ADD      R0,R0,#+8
   \                     ??GUI_ALLOC_LockH_0:
   \   00000028   1EFF2FE1           BX       LR               ;; return
   1071          }
   1072          
   1073          /*********************************************************************
   1074          *
   1075          *       GUI_ALLOC_UnlockH
   1076          */

   \                                 In section .text, align 4, keep-with-next
   1077          void * GUI_ALLOC_UnlockH(void) {
   1078            if (_LockCntHandles == 0) {
   \                     GUI_ALLOC_UnlockH:
   \   00000000   ........           LDR      R0,??DataTable23
   \   00000004   9C1090E5           LDR      R1,[R0, #+156]
   \   00000008   000051E3           CMP      R1,#+0
   1079              GUI_DEBUG_ERROROUT(__FILE__": Underflow of locked handles");
   1080            } else {
   1081              _LockCntHandles--;
   \   0000000C   01104112           SUBNE    R1,R1,#+1
   \   00000010   9C108015           STRNE    R1,[R0, #+156]
   1082            }
   1083            return NULL;
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   1EFF2FE1           BX       LR               ;; return
   1084          }
   1085          
   1086          /*********************************************************************
   1087          *
   1088          *       GUI_ALLOC_GetNumFreeBytes
   1089          */

   \                                 In section .text, align 4, keep-with-next
   1090          GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes(void) {
   \                     GUI_ALLOC_GetNumFreeBytes:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1091            _InitOnce();
   \   00000008   ........           BL       _InitOnce
   1092            return NET(_NumFreeBytes);
   \   0000000C   ........           LDR      R0,??DataTable23
   \   00000010   04D08DE2           ADD      SP,SP,#+4
   \   00000014   A00090E5           LDR      R0,[R0, #+160]
   \   00000018   0C0040E2           SUB      R0,R0,#+12
   \   0000001C   0080BDE8           POP      {PC}             ;; return
   1093          }
   1094          
   1095          /*********************************************************************
   1096          *
   1097          *       GUI_ALLOC_GetNumFreeBlocks
   1098          */

   \                                 In section .text, align 4, keep-with-next
   1099          GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBlocks(void) {
   \                     GUI_ALLOC_GetNumFreeBlocks:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1100            _InitOnce();
   \   00000008   ........           BL       _InitOnce
   1101            return _NumFreeBlocks;
   \   0000000C   ........           LDR      R0,??DataTable23
   \   00000010   04D08DE2           ADD      SP,SP,#+4
   \   00000014   A40090E5           LDR      R0,[R0, #+164]
   \   00000018   0080BDE8           POP      {PC}             ;; return
   1102          }
   1103          
   1104          /*********************************************************************
   1105          *
   1106          *       GUI_ALLOC_GetNumUsedBytes
   1107          */

   \                                 In section .text, align 4, keep-with-next
   1108          GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBytes(void) {
   \                     GUI_ALLOC_GetNumUsedBytes:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1109            _InitOnce();
   \   00000008   ........           BL       _InitOnce
   1110            return _AllocSize - _NumFreeBytes;
   \   0000000C   ........           LDR      R0,??DataTable23
   \   00000010   04D08DE2           ADD      SP,SP,#+4
   \   00000014   A81090E5           LDR      R1,[R0, #+168]
   \   00000018   A00090E5           LDR      R0,[R0, #+160]
   \   0000001C   000041E0           SUB      R0,R1,R0
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1111          }
   1112          
   1113          /*********************************************************************
   1114          *
   1115          *       GUI_ALLOC_GetNumUsedBlocks
   1116          */

   \                                 In section .text, align 4, keep-with-next
   1117          GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBlocks(void) {
   \                     GUI_ALLOC_GetNumUsedBlocks:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1118            _InitOnce();
   \   00000008   ........           BL       _InitOnce
   1119            return _NumBlocks - _NumFreeBlocks;
   \   0000000C   ........           LDR      R0,??DataTable23
   \   00000010   04D08DE2           ADD      SP,SP,#+4
   \   00000014   AC1090E5           LDR      R1,[R0, #+172]
   \   00000018   A40090E5           LDR      R0,[R0, #+164]
   \   0000001C   000041E0           SUB      R0,R1,R0
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1120          }
   1121          
   1122          /*********************************************************************
   1123          *
   1124          *       GUI_ALLOC_GetMaxSize
   1125          *
   1126          * Purpose:
   1127          *   Returns the biggest available blocksize (without relocation).
   1128          */

   \                                 In section .text, align 4, keep-with-next
   1129          GUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize(void) {
   \                     GUI_ALLOC_GetMaxSize:
   \   00000000   10402DE9           PUSH     {R4,LR}
   1130            GUI_ALLOC_DATATYPE MaxSize = 0;
   \   00000004   0040A0E3           MOV      R4,#+0
   1131            int Index;
   1132            TAG * pTag;
   1133            _InitOnce();
   \   00000008   ........           BL       _InitOnce
   1134            for (Index = GUI_COUNTOF(_aFreeMem) - 1; Index >= 0; Index--) {
   \   0000000C   ........           LDR      R1,??DataTable23
   \   00000010   0F00A0E3           MOV      R0,#+15
   \   00000014   942081E2           ADD      R2,R1,#+148
   1135              if (_aFreeMem[Index].pFirstFreeTag) {
   \                     ??GUI_ALLOC_GetMaxSize_0:
   \   00000018   083012E4           LDR      R3,[R2], #-8
   \   0000001C   000053E3           CMP      R3,#+0
   \   00000020   0D00000A           BEQ      ??GUI_ALLOC_GetMaxSize_1
   1136                pTag = _aFreeMem[Index].pFirstFreeTag->pTag;
   \   00000024   800181E0           ADD      R0,R1,R0, LSL #+3
   \   00000028   1C0090E5           LDR      R0,[R0, #+28]
   \   0000002C   083090E5           LDR      R3,[R0, #+8]
   1137                break;
   1138              } else {
   1139                pTag = NULL;
   1140              }
   1141            }
   1142            while (pTag) {
   \   00000030   000053E3           CMP      R3,#+0
   \   00000034   0A00000A           BEQ      ??GUI_ALLOC_GetMaxSize_2
   1143              if ((U32)MaxSize < pTag->MemTag.Size) {
   \                     ??GUI_ALLOC_GetMaxSize_3:
   \   00000038   040093E5           LDR      R0,[R3, #+4]
   \   0000003C   000054E1           CMP      R4,R0
   1144                MaxSize = pTag->MemTag.Size;
   \   00000040   0040A031           MOVCC    R4,R0
   1145              }
   1146              pTag = pTag->FreeTag.pNext ? pTag->FreeTag.pNext->pTag : NULL;
   \   00000044   080093E5           LDR      R0,[R3, #+8]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   08309015           LDRNE    R3,[R0, #+8]
   \   00000050   00005313           CMPNE    R3,#+0
   \   00000054   F7FFFF1A           BNE      ??GUI_ALLOC_GetMaxSize_3
   \   00000058   010000EA           B        ??GUI_ALLOC_GetMaxSize_2
   1147            }
   \                     ??GUI_ALLOC_GetMaxSize_1:
   \   0000005C   010050E2           SUBS     R0,R0,#+1
   \   00000060   ECFFFF5A           BPL      ??GUI_ALLOC_GetMaxSize_0
   1148            return NET(MaxSize);
   \                     ??GUI_ALLOC_GetMaxSize_2:
   \   00000064   0C0044E2           SUB      R0,R4,#+12
   \   00000068   1080BDE8           POP      {R4,PC}          ;; return
   1149          }
   1150          
   1151          /*********************************************************************
   1152          *
   1153          *       GUI_ALLOC_RequestSize
   1154          */

   \                                 In section .text, align 4, keep-with-next
   1155          GUI_ALLOC_DATATYPE GUI_ALLOC_RequestSize(void) {
   \                     GUI_ALLOC_RequestSize:
   \   00000000   10402DE9           PUSH     {R4,LR}
   1156            GUI_ALLOC_DATATYPE MaxSize;
   1157            GUI_LOCK();
   \   00000004   ........           BL       GUI_Lock
   1158            MaxSize = GUI_ALLOC_GetMaxSize();
   \   00000008   ........           BL       GUI_ALLOC_GetMaxSize
   1159            if ((U32)MaxSize > 0x400000L) {
   \   0000000C   0120A0E3           MOV      R2,#+1
   \   00000010   402882E3           ORR      R2,R2,#0x400000
   \   00000014   5A10A0E3           MOV      R1,#+90
   \   00000018   020050E1           CMP      R0,R2
   \   0000001C   0500003A           BCC      ??GUI_ALLOC_RequestSize_0
   1160              MaxSize = (MaxSize / 100) * _MaxRequestPercent;
   \   00000020   ........           LDR      R2,??DataTable23_2  ;; 0x51eb851f
   \   00000024   9032C2E0           SMULL    R3,R2,R0,R2
   \   00000028   C202B0E1           ASRS     R0,R2,#+5
   \   0000002C   01008042           ADDMI    R0,R0,#+1
   \   00000030   910004E0           MUL      R4,R1,R0
   \   00000034   030000EA           B        ??GUI_ALLOC_RequestSize_1
   1161            } else {
   1162              MaxSize = ((U32)MaxSize * _MaxRequestPercent) / 100;
   \                     ??GUI_ALLOC_RequestSize_0:
   \   00000038   910000E0           MUL      R0,R1,R0
   \   0000003C   ........           LDR      R2,??DataTable23_3  ;; 0xa3d70a3e
   \   00000040   902281E0           UMULL    R2,R1,R0,R2
   \   00000044   2143A0E1           LSR      R4,R1,#+6
   1163            }
   1164            GUI_UNLOCK();
   \                     ??GUI_ALLOC_RequestSize_1:
   \   00000048   ........           BL       GUI_Unlock
   1165            return MaxSize;
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   1080BDE8           POP      {R4,PC}          ;; return
   1166          }
   1167          
   1168          /*********************************************************************
   1169          *
   1170          *       GUI_ALLOC_Lock
   1171          *
   1172          * Purpose:
   1173          *   The function increments the lock counter. If the lock counter is >0
   1174          *   the internal memory management should not shift allocated memory.
   1175          */

   \                                 In section .text, align 4, keep-with-next
   1176          void GUI_ALLOC_Lock(void) {
   1177            _LockCnt++;
   \                     GUI_ALLOC_Lock:
   \   00000000   ........           LDR      R0,??DataTable23
   \   00000004   981090E5           LDR      R1,[R0, #+152]
   \   00000008   011081E2           ADD      R1,R1,#+1
   \   0000000C   981080E5           STR      R1,[R0, #+152]
   1178          }
   \   00000010   1EFF2FE1           BX       LR               ;; return
   1179          
   1180          /*********************************************************************
   1181          *
   1182          *       GUI_ALLOC_Unlock
   1183          *
   1184          * Purpose:
   1185          *   The function decrements the lock counter. If the lock counter is >0
   1186          *   the internal memory management should not shift allocated memory.
   1187          */

   \                                 In section .text, align 4, keep-with-next
   1188          void GUI_ALLOC_Unlock(void) {
   1189            _LockCnt--;
   \                     GUI_ALLOC_Unlock:
   \   00000000   ........           LDR      R0,??DataTable23
   \   00000004   981090E5           LDR      R1,[R0, #+152]
   \   00000008   011041E2           SUB      R1,R1,#+1
   \   0000000C   981080E5           STR      R1,[R0, #+152]
   1190          }
   \   00000010   1EFF2FE1           BX       LR               ;; return
   1191          
   1192          /*********************************************************************
   1193          *
   1194          *       GUI_ALLOC_AssignMemory
   1195          */

   \                                 In section .text, align 4, keep-with-next
   1196          void GUI_ALLOC_AssignMemory(void * p, U32 NumBytes) {
   1197            _Config.pData      = p;
   \                     GUI_ALLOC_AssignMemory:
   \   00000000   ........           LDR      R2,??DataTable23
   \   00000004   000082E5           STR      R0,[R2, #+0]
   1198            _Config.NumBytes   = NumBytes;
   1199            _Config.Customized = 1;
   \   00000008   0100A0E3           MOV      R0,#+1
   \   0000000C   081082E5           STR      R1,[R2, #+8]
   \   00000010   1400C2E5           STRB     R0,[R2, #+20]
   1200          }
   \   00000014   1EFF2FE1           BX       LR               ;; return
   1201          
   1202          /*********************************************************************
   1203          *
   1204          *       GUI_ALLOC_SetAvBlockSize
   1205          */

   \                                 In section .text, align 4, keep-with-next
   1206          void GUI_ALLOC_SetAvBlockSize(U32 BlockSize) {
   1207            _Config.BlockSize  = BlockSize;
   \                     GUI_ALLOC_SetAvBlockSize:
   \   00000000   ........           LDR      R1,??DataTable23
   \   00000004   100081E5           STR      R0,[R1, #+16]
   1208            _Config.NumBlocks  = 0;
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   0C0081E5           STR      R0,[R1, #+12]
   1209            _Config.Customized = 1;
   \   00000010   0100A0E3           MOV      R0,#+1
   \   00000014   1400C1E5           STRB     R0,[R1, #+20]
   1210          }
   \   00000018   1EFF2FE1           BX       LR               ;; return
   1211          
   1212          #else
   1213          
   1214          /*********************************************************************
   1215          *
   1216          *       External memory management functions
   1217          *
   1218          * The functions below will generate code only if the GUI memory
   1219          * management is not used (GUI_ALLOC_ALLOC defined).
   1220          *
   1221          * Note:
   1222          * The memory block allocated is bigger than the requested one, as we
   1223          * store some add. information (size of the memory block) there.
   1224          *
   1225          **********************************************************************
   1226          */
   1227          
   1228          typedef struct {
   1229            union {
   1230              GUI_ALLOC_DATATYPE Size;
   1231              int Dummy;               /* Needed to guarantee alignment on 32 / 64 bit CPUs */
   1232            } Info;      /* Unnamed would be best, but is not supported by all compilers */
   1233          } INFO;
   1234          
   1235          /*********************************************************************
   1236          *
   1237          *       _GetSize
   1238          */
   1239          static GUI_ALLOC_DATATYPE _GetSize(GUI_HMEM  hMem) {
   1240            INFO * pInfo;
   1241            pInfo = (INFO *)GUI_ALLOC_H2P(hMem);
   1242            return pInfo->Info.Size;
   1243          }
   1244          
   1245          /*********************************************************************
   1246          *
   1247          *       _Free
   1248          */
   1249          static void _Free(GUI_HMEM  hMem) {
   1250            GUI_ALLOC_FREE(hMem);
   1251          }
   1252          
   1253          /*********************************************************************
   1254          *
   1255          *       GUI_ALLOC_AllocNoInit
   1256          */
   1257          GUI_HMEM GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE Size) {
   1258            GUI_HMEM hMem;
   1259            if (Size == 0) {
   1260              return (GUI_HMEM)0;
   1261            }
   1262            hMem= GUI_ALLOC_ALLOC(Size + sizeof(INFO));
   1263            //
   1264            // Init info structure
   1265            //
   1266            if (hMem) {
   1267              INFO * pInfo;
   1268              pInfo = (INFO *)GUI_ALLOC_H2P(hMem);
   1269              pInfo->Info.Size = Size;
   1270            }
   1271            return hMem;
   1272          }
   1273          
   1274          /*********************************************************************
   1275          *
   1276          *       GUI_ALLOC_h2p
   1277          */
   1278          void* GUI_ALLOC_h2p(GUI_HMEM  hMem) {
   1279            U8 * p;
   1280            p = (U8*)GUI_ALLOC_H2P(hMem);    /* Pointer to memory block from memory manager */
   1281            p += sizeof(INFO);               /* Convert to pointer to usable area */
   1282            return p;
   1283          }
   1284          
   1285          /*********************************************************************
   1286          *
   1287          *       GUI_ALLOC_GetMaxSize
   1288          */
   1289          GUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize(void) {
   1290            return GUI_ALLOC_GETMAXSIZE();
   1291          }
   1292          
   1293          /*********************************************************************
   1294          *
   1295          *       GUI_ALLOC_RequestSize
   1296          */
   1297          GUI_ALLOC_DATATYPE GUI_ALLOC_RequestSize(void) {
   1298            return GUI_ALLOC_GETMAXSIZE();
   1299          }
   1300          
   1301          /*********************************************************************
   1302          *
   1303          *       GUI_ALLOC_Lock
   1304          */
   1305          void GUI_ALLOC_Lock(void) {
   1306          }
   1307          
   1308          /*********************************************************************
   1309          *
   1310          *       GUI_ALLOC_Unlock
   1311          */
   1312          void GUI_ALLOC_Unlock(void) {
   1313          }
   1314          
   1315          /*********************************************************************
   1316          *
   1317          *       GUI_ALLOC_LockH
   1318          */
   1319          void * GUI_ALLOC_LockH(GUI_HMEM hMem) {
   1320            return GUI_ALLOC_h2p(hMem);
   1321          }
   1322          
   1323          /*********************************************************************
   1324          *
   1325          *       GUI_ALLOC_UnlockH
   1326          */
   1327          void * GUI_ALLOC_UnlockH(void) {
   1328            return NULL;
   1329          }
   1330          
   1331          /*********************************************************************
   1332          *
   1333          *       GUI_ALLOC_AssignMemory
   1334          */
   1335          void GUI_ALLOC_AssignMemory(void * p, U32 NumBytes) {
   1336            GUI_USE_PARA(p);
   1337            GUI_USE_PARA(NumBytes);
   1338          }
   1339          
   1340          /*********************************************************************
   1341          *
   1342          *       GUI_ALLOC_SetAvBlockSize
   1343          */
   1344          void GUI_ALLOC_SetAvBlockSize(U32 BlockSize) {
   1345            GUI_USE_PARA(BlockSize);
   1346          }
   1347          
   1348          /*********************************************************************
   1349          *
   1350          *       GUI_ALLOC_GetFixedBlock
   1351          */
   1352          void * GUI_ALLOC_GetFixedBlock(GUI_ALLOC_DATATYPE Size) {
   1353            void * p = NULL;
   1354            p = GUI_ALLOC_ALLOC(Size);
   1355            GUI_MEMSET(p, 0, Size);
   1356            return p;
   1357          }
   1358          
   1359          /*********************************************************************
   1360          *
   1361          *       GUI_ALLOC_FreeFixedBlock
   1362          */
   1363          void GUI_ALLOC_FreeFixedBlock(void * pBlock) {
   1364            GUI_LOCK();
   1365            GUI_ALLOC_FREE(pBlock);
   1366            GUI_UNLOCK();
   1367          }
   1368          
   1369          #endif
   1370          
   1371          /*********************************************************************
   1372          *
   1373          *       Public code, common memory management functions
   1374          *
   1375          **********************************************************************
   1376          */
   1377          /*********************************************************************
   1378          *
   1379          *       GUI_ALLOC_GetSize
   1380          *
   1381          *  Parameter
   1382          *    hMem      Handle of the memory block. A 0-handle is permitted; return value is 0 in this case.
   1383          */

   \                                 In section .text, align 4, keep-with-next
   1384          GUI_ALLOC_DATATYPE GUI_ALLOC_GetSize(GUI_HMEM  hMem) {
   1385            GUI_ALLOC_DATATYPE r;
   1386          
   1387            r = 0;
   \                     GUI_ALLOC_GetSize:
   \   00000000   0010A0E3           MOV      R1,#+0
   1388            if (hMem) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0500000A           BEQ      ??GUI_ALLOC_GetSize_0
   1389              r = _GetSize(hMem);
   \   0000000C   ........           LDR      R1,??DataTable23
   \   00000010   B81091E5           LDR      R1,[R1, #+184]
   \   00000014   800181E0           ADD      R0,R1,R0, LSL #+3
   \   00000018   040090E5           LDR      R0,[R0, #+4]
   \   0000001C   040090E5           LDR      R0,[R0, #+4]
   \   00000020   0C1040E2           SUB      R1,R0,#+12
   1390            }
   1391            return r;
   \                     ??GUI_ALLOC_GetSize_0:
   \   00000024   0100A0E1           MOV      R0,R1
   \   00000028   1EFF2FE1           BX       LR               ;; return
   1392          }
   1393          
   1394          /*********************************************************************
   1395          *
   1396          *       GUI_ALLOC_Free
   1397          */

   \                                 In section .text, align 4, keep-with-next
   1398          void GUI_ALLOC_Free(GUI_HMEM hMem) {
   \                     GUI_ALLOC_Free:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
   1399            if (hMem == GUI_HMEM_NULL) { /* Note: This is not an error, it is permitted */
   \   0000000C   1400000A           BEQ      ??GUI_ALLOC_Free_0
   1400              return;
   1401            }
   1402            GUI_LOCK();
   \   00000010   ........           BL       GUI_Lock
   1403            GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
   1404            _Free(hMem);
   \   00000014   ........           LDR      R5,??DataTable23
   \   00000018   B80095E5           LDR      R0,[R5, #+184]
   \   0000001C   8411D0E7           LDRB     R1,[R0, +R4, LSL #+3]
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0D00000A           BEQ      ??GUI_ALLOC_Free_1
   \   00000028   840180E0           ADD      R0,R0,R4, LSL #+3
   \   0000002C   041090E5           LDR      R1,[R0, #+4]
   \   00000030   040091E5           LDR      R0,[R1, #+4]
   \   00000034   ........           BL       _AddFreeMemory
   \   00000038   A40095E5           LDR      R0,[R5, #+164]
   \   0000003C   BC2095E5           LDR      R2,[R5, #+188]
   \   00000040   010080E2           ADD      R0,R0,#+1
   \   00000044   A40085E5           STR      R0,[R5, #+164]
   \   00000048   B80095E5           LDR      R0,[R5, #+184]
   \   0000004C   841180E0           ADD      R1,R0,R4, LSL #+3
   \   00000050   042081E5           STR      R2,[R1, #+4]
   \   00000054   0010A0E3           MOV      R1,#+0
   \   00000058   8411C0E7           STRB     R1,[R0, +R4, LSL #+3]
   \   0000005C   BC4085E5           STR      R4,[R5, #+188]
   1405            GUI_UNLOCK();
   \                     ??GUI_ALLOC_Free_1:
   \   00000060   ........           BL       GUI_Unlock
   1406          }
   \                     ??GUI_ALLOC_Free_0:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
   1407          
   1408          
   1409          /*********************************************************************
   1410          *
   1411          *       GUI_ALLOC_FreePtr
   1412          */

   \                                 In section .text, align 4, keep-with-next
   1413          void GUI_ALLOC_FreePtr(GUI_HMEM *ph) {
   \                     GUI_ALLOC_FreePtr:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1414            GUI_LOCK();
   \   00000008   ........           BL       GUI_Lock
   1415            GUI_ALLOC_Free(*ph);
   \   0000000C   005094E5           LDR      R5,[R4, #+0]
   \   00000010   000055E3           CMP      R5,#+0
   \   00000014   1400000A           BEQ      ??GUI_ALLOC_FreePtr_0
   \   00000018   ........           BL       GUI_Lock
   \   0000001C   ........           LDR      R6,??DataTable23
   \   00000020   B80096E5           LDR      R0,[R6, #+184]
   \   00000024   8511D0E7           LDRB     R1,[R0, +R5, LSL #+3]
   \   00000028   000051E3           CMP      R1,#+0
   \   0000002C   0D00000A           BEQ      ??GUI_ALLOC_FreePtr_1
   \   00000030   850180E0           ADD      R0,R0,R5, LSL #+3
   \   00000034   041090E5           LDR      R1,[R0, #+4]
   \   00000038   040091E5           LDR      R0,[R1, #+4]
   \   0000003C   ........           BL       _AddFreeMemory
   \   00000040   A40096E5           LDR      R0,[R6, #+164]
   \   00000044   BC2096E5           LDR      R2,[R6, #+188]
   \   00000048   010080E2           ADD      R0,R0,#+1
   \   0000004C   A40086E5           STR      R0,[R6, #+164]
   \   00000050   B80096E5           LDR      R0,[R6, #+184]
   \   00000054   851180E0           ADD      R1,R0,R5, LSL #+3
   \   00000058   042081E5           STR      R2,[R1, #+4]
   \   0000005C   0010A0E3           MOV      R1,#+0
   \   00000060   8511C0E7           STRB     R1,[R0, +R5, LSL #+3]
   \   00000064   BC5086E5           STR      R5,[R6, #+188]
   \                     ??GUI_ALLOC_FreePtr_1:
   \   00000068   ........           BL       GUI_Unlock
   1416            *ph =0;
   \                     ??GUI_ALLOC_FreePtr_0:
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   000084E5           STR      R0,[R4, #+0]
   1417            GUI_UNLOCK();
   \   00000074   7040BDE8           POP      {R4-R6,LR}
   \   00000078   ........           B        GUI_Unlock       ;; tailcall
   1418          }
   1419          
   1420          /*********************************************************************
   1421          *
   1422          *       GUI_ALLOC_FreePtrArray
   1423          */

   \                                 In section .text, align 4, keep-with-next
   1424          void GUI_ALLOC_FreePtrArray(GUI_HMEM * pArray, int NumElems) {
   \                     GUI_ALLOC_FreePtrArray:
   \   00000000   B0432DE9           PUSH     {R4,R5,R7-R9,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0090A0E1           MOV      R9,R0
   1425            int i;
   1426            for (i = 0; i < NumElems; i++) {
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   010054E3           CMP      R4,#+1
   \   00000014   ........           LDR      R8,??DataTable23
   \   00000018   1D0000BA           BLT      ??GUI_ALLOC_FreePtrArray_0
   1427              GUI_ALLOC_FreePtr(&pArray[i]);
   \                     ??GUI_ALLOC_FreePtrArray_1:
   \   0000001C   ........           BL       GUI_Lock
   \   00000020   007099E5           LDR      R7,[R9, #+0]
   \   00000024   000057E3           CMP      R7,#+0
   \   00000028   1300000A           BEQ      ??GUI_ALLOC_FreePtrArray_2
   \   0000002C   ........           BL       GUI_Lock
   \   00000030   B80098E5           LDR      R0,[R8, #+184]
   \   00000034   8711D0E7           LDRB     R1,[R0, +R7, LSL #+3]
   \   00000038   000051E3           CMP      R1,#+0
   \   0000003C   0D00000A           BEQ      ??GUI_ALLOC_FreePtrArray_3
   \   00000040   870180E0           ADD      R0,R0,R7, LSL #+3
   \   00000044   041090E5           LDR      R1,[R0, #+4]
   \   00000048   040091E5           LDR      R0,[R1, #+4]
   \   0000004C   ........           BL       _AddFreeMemory
   \   00000050   A40098E5           LDR      R0,[R8, #+164]
   \   00000054   BC2098E5           LDR      R2,[R8, #+188]
   \   00000058   010080E2           ADD      R0,R0,#+1
   \   0000005C   A40088E5           STR      R0,[R8, #+164]
   \   00000060   B80098E5           LDR      R0,[R8, #+184]
   \   00000064   871180E0           ADD      R1,R0,R7, LSL #+3
   \   00000068   042081E5           STR      R2,[R1, #+4]
   \   0000006C   0010A0E3           MOV      R1,#+0
   \   00000070   8711C0E7           STRB     R1,[R0, +R7, LSL #+3]
   \   00000074   BC7088E5           STR      R7,[R8, #+188]
   \                     ??GUI_ALLOC_FreePtrArray_3:
   \   00000078   ........           BL       GUI_Unlock
   \                     ??GUI_ALLOC_FreePtrArray_2:
   \   0000007C   0000A0E3           MOV      R0,#+0
   \   00000080   040089E4           STR      R0,[R9], #+4
   \   00000084   ........           BL       GUI_Unlock
   1428            }
   \   00000088   015085E2           ADD      R5,R5,#+1
   \   0000008C   040055E1           CMP      R5,R4
   \   00000090   E1FFFFBA           BLT      ??GUI_ALLOC_FreePtrArray_1
   1429          }
   \                     ??GUI_ALLOC_FreePtrArray_0:
   \   00000094   B083BDE8           POP      {R4,R5,R7-R9,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   ........           DC32     _Config

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   81808080           DC32     0x80808081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   1F85EB51           DC32     0x51eb851f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   3E0AD7A3           DC32     0xa3d70a3e
   1430          
   1431          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function                   .cstack
     --------                   -------
     GUI_ALLOC_AllocNoInit           8
     GUI_ALLOC_AssignMemory          0
     GUI_ALLOC_Free                 16
     GUI_ALLOC_FreeFixedBlock        0
     GUI_ALLOC_FreePtr              16
     GUI_ALLOC_FreePtrArray         32
     GUI_ALLOC_GetFixedBlock        16
     GUI_ALLOC_GetMaxSize            8
     GUI_ALLOC_GetNumFreeBlocks      8
     GUI_ALLOC_GetNumFreeBytes       8
     GUI_ALLOC_GetNumUsedBlocks      8
     GUI_ALLOC_GetNumUsedBytes       8
     GUI_ALLOC_GetSize               0
     GUI_ALLOC_Lock                  0
     GUI_ALLOC_LockH                 0
     GUI_ALLOC_RequestSize           8
     GUI_ALLOC_SetAvBlockSize        0
     GUI_ALLOC_Unlock                0
     GUI_ALLOC_UnlockH               0
     GUI_ALLOC_h2p                   0
     GUI_ALLOC_p2h                   0
     _AddFreeMemory                 24
     _Alloc                         24
     _InitOnce                      16
     _RemoveHoles                   40
     _TestRAM                       32


   Section sizes:

     Function/Label             Bytes
     --------------             -----
     _Config                     197
     _aFreeMem
     _LockCnt
     _LockCntHandles
     _NumFreeBytes
     _NumFreeBlocks
     _AllocSize
     _NumBlocks
     _NumFixedBytes
     _pHeap
     _pBlocks
     _FirstFreeBlock
     _pFirstFixedFreeTag
     _IsInitialized
     _MaxRequestPercent            4
     _AddFreeMemory              360
     _RemoveHoles                260
     _TestRAM                    704
     _InitOnce                   292
     _Alloc                      440
     GUI_ALLOC_p2h                 8
     GUI_ALLOC_FreeFixedBlock     28
     GUI_ALLOC_GetFixedBlock     436
     GUI_ALLOC_AllocNoInit        48
     GUI_ALLOC_h2p                32
     GUI_ALLOC_LockH              44
     GUI_ALLOC_UnlockH            28
     GUI_ALLOC_GetNumFreeBytes    32
     GUI_ALLOC_GetNumFreeBlocks   28
     GUI_ALLOC_GetNumUsedBytes    36
     GUI_ALLOC_GetNumUsedBlocks   36
     GUI_ALLOC_GetMaxSize        108
     GUI_ALLOC_RequestSize        84
     GUI_ALLOC_Lock               20
     GUI_ALLOC_Unlock             20
     GUI_ALLOC_AssignMemory       24
     GUI_ALLOC_SetAvBlockSize     28
     GUI_ALLOC_GetSize            44
     GUI_ALLOC_Free              108
     GUI_ALLOC_FreePtr           124
     GUI_ALLOC_FreePtrArray      152
     ??DataTable23                 4
     ??DataTable23_1               4
     ??DataTable23_2               4
     ??DataTable23_3               4

 
   201 bytes in section .data
 3 540 bytes in section .text
 
 3 540 bytes of CODE memory
   201 bytes of DATA memory

Errors: none
Warnings: none
