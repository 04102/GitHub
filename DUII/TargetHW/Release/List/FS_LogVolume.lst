###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:14:57 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\FS\FS_LogVolume.c                       #
#    Command line =  C:\DUII\TargetHW\FS\FS_LogVolume.c -D DEBUG=1 -D         #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\FS_LogVolume.lst           #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\FS_LogVolume.o              #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\FS\FS_LogVolume.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          **** emFile file system for embedded applications ****
     13          emFile is protected by international copyright laws. Knowledge of the
     14          source code may not be used to write a similar product. This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : FS_LogVolume.c
     19          Purpose     : Logical volume driver
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          /*********************************************************************
     24          *
     25          *             #include Section
     26          *
     27          **********************************************************************
     28          */
     29          
     30          #include "FS_Int.h"
     31          
     32          #ifndef   NUM_UNITS
     33            #define NUM_UNITS  4
     34          #endif
     35          
     36          typedef struct DEV_INFO DEV_INFO;
     37          
     38          struct DEV_INFO {
     39            DEV_INFO             * pNext;
     40            const FS_DEVICE_TYPE * pDevice;
     41            U8                     Unit;
     42            U32                    StartOff;
     43            U32                    NumSectors;
     44          };
     45          
     46          typedef struct {
     47            const char * sVolName;
     48            DEV_INFO   * pDevInfo;
     49            U16          BytesPerSector;
     50          } LOG_VOL;
     51          
     52          
     53          
     54          /*********************************************************************
     55          *
     56          *       Static data
     57          *
     58          **********************************************************************
     59          */

   \                                 In section .bss, align 4
     60          static LOG_VOL      * _apLogVol[NUM_UNITS];
   \                     _apLogVol:
   \   00000000                      DS8 16
   \   00000010                      DS8 4
     61          static int            _NumUnits;
     62          
     63          /*********************************************************************
     64          *
     65          *       Macros, function replacement
     66          *
     67          **********************************************************************
     68          */
     69          
     70          /*********************************************************************
     71          *
     72          *       ASSERT_UNIT_NO_IS_IN_RANGE
     73          */
     74          #if FS_DEBUG_LEVEL >= FS_DEBUG_LEVEL_CHECK_ALL
     75            #define ASSERT_UNIT_NO_IS_IN_RANGE(Unit)                                \
     76            if (Unit >= _NumUnits) {                                \
     77              FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "NAND: Illegal unit number.\n"));     \
     78              return -1;                                            \
     79            }
     80          #else
     81            #define ASSERT_UNIT_NO_IS_IN_RANGE(Unit)
     82          #endif
     83          
     84          /*********************************************************************
     85          *
     86          *       Static code
     87          *
     88          **********************************************************************
     89          */
     90          
     91          
     92          /*********************************************************************
     93          *
     94          *       _GetNumSectors
     95          *
     96          */
     97          static U32 _GetNumSectors(LOG_VOL * pLogVol) {
     98            U32 NumSectors;
     99            DEV_INFO * pDevInfo;
    100            
    101            
    102            NumSectors = 0;
    103            for (pDevInfo = pLogVol->pDevInfo; pDevInfo; pDevInfo = pDevInfo->pNext) {
    104              NumSectors += pDevInfo->NumSectors;
    105            }
    106            return NumSectors;
    107          }
    108          
    109          
    110          /*********************************************************************
    111          *
    112          *       _UpdateNumSectors
    113          *
    114          */
    115          static void _UpdateNumSectors(LOG_VOL * pLogVol) {
    116            DEV_INFO     * pDevInfo;
    117            FS_DEV_INFO    DevInfo;
    118            
    119            for (pDevInfo = pLogVol->pDevInfo; pDevInfo; pDevInfo = pDevInfo->pNext) {
    120              if (pDevInfo->pDevice->pfIoCtl(pDevInfo->Unit, FS_CMD_GET_DEVINFO, 0, (void*)&DevInfo) == 0) {
    121                 pDevInfo->NumSectors    = DevInfo.NumSectors;
    122                 pLogVol->BytesPerSector = DevInfo.BytesPerSector;
    123              }
    124            }
    125          }
    126          
    127          /*********************************************************************
    128          *
    129          *       _LOGVOL_GetStatus
    130          *
    131          */

   \                                 In section .text, align 4, keep-with-next
    132          static int _LOGVOL_GetStatus(U8 Unit) {  
    133            FS_USE_PARA(Unit);
    134            return 1;
   \                     _LOGVOL_GetStatus:
   \   00000000   0100A0E3           MOV      R0,#+1
   \   00000004   1EFF2FE1           BX       LR               ;; return
    135          }
    136          
    137          /*********************************************************************
    138          *
    139          *       _ReadWrite
    140          */

   \                                 In section .text, align 4, keep-with-next
    141          static int _ReadWrite(U8 Unit, U32 FirstSectorReq, const void *pBuffer, U32 NumSectorsReq, U8 IsWrite, U8 RepeatSame) {
   \                     _ReadWrite:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0140A0E1           MOV      R4,R1
    142            LOG_VOL  * pLogVol;
    143            DEV_INFO * pDevInfo;
    144            int        r;
    145            U32        NumSectorsAtOnce;
    146            U32        NumSectorsInDev;           // Number of sectors in device
    147          
    148            r = -1;
    149            ASSERT_UNIT_NO_IS_IN_RANGE(Unit);
    150            pLogVol = _apLogVol[Unit];
   \   00000008   ........           LDR      R1,??DataTable8_1
   \   0000000C   00C0A0E1           MOV      R12,R0
   \   00000010   0C8191E7           LDR      R8,[R1, +R12, LSL #+2]
   \   00000014   04D04DE2           SUB      SP,SP,#+4
   \   00000018   0250A0E1           MOV      R5,R2
   \   0000001C   0360A0E1           MOV      R6,R3
   \   00000020   2C70DDE5           LDRB     R7,[SP, #+44]
   \   00000024   0000E0E3           MVN      R0,#+0
    151            //
    152            // Iterate over devices until we have reached the last device or all data has been read.
    153            //
    154            pDevInfo = pLogVol->pDevInfo;
   \   00000028   049098E5           LDR      R9,[R8, #+4]
   \   0000002C   000000EA           B        ??_ReadWrite_0
    155            while (pDevInfo) {
    156              NumSectorsInDev = pDevInfo->NumSectors;
    157              if (FirstSectorReq < NumSectorsInDev) {
    158                NumSectorsAtOnce = MIN(NumSectorsInDev - FirstSectorReq, NumSectorsReq);
    159                if (IsWrite) {
    160                  r = pDevInfo->pDevice->pfWrite(pDevInfo->Unit, FirstSectorReq + pDevInfo->StartOff, pBuffer, NumSectorsAtOnce, RepeatSame);
    161                } else {
    162                  r = pDevInfo->pDevice->pfRead (pDevInfo->Unit, FirstSectorReq + pDevInfo->StartOff, (void *)pBuffer, NumSectorsAtOnce);
    163                }
    164                if (r) {
    165                  break;    // Error;
    166                }
    167                NumSectorsReq   -= NumSectorsAtOnce;
    168                FirstSectorReq  += NumSectorsAtOnce;
    169                {
    170                  const U8 * p;
    171                  p        = (const U8 *)pBuffer;
    172                  p       += NumSectorsAtOnce * pLogVol->BytesPerSector;
    173                  pBuffer  = p;
    174                }
    175              }
    176              FirstSectorReq -= NumSectorsInDev;
    177              if (NumSectorsReq == 0) {
    178                r = 0;                    // O.K., all sectors read
    179                break;
    180              }
    181              pDevInfo = pDevInfo->pNext;
   \                     ??_ReadWrite_1:
   \   00000030   009099E5           LDR      R9,[R9, #+0]
   \                     ??_ReadWrite_0:
   \   00000034   000059E3           CMP      R9,#+0
   \   00000038   2000000A           BEQ      ??_ReadWrite_2
   \   0000003C   10A099E5           LDR      R10,[R9, #+16]
   \   00000040   0A0054E1           CMP      R4,R10
   \   00000044   1900002A           BCS      ??_ReadWrite_3
   \   00000048   04B04AE0           SUB      R11,R10,R4
   \   0000004C   0C0099E5           LDR      R0,[R9, #+12]
   \   00000050   2820DDE5           LDRB     R2,[SP, #+40]
   \   00000054   06005BE1           CMP      R11,R6
   \   00000058   06B0A081           MOVHI    R11,R6
   \   0000005C   041080E0           ADD      R1,R0,R4
   \   00000060   04C099E5           LDR      R12,[R9, #+4]
   \   00000064   0800D9E5           LDRB     R0,[R9, #+8]
   \   00000068   000052E3           CMP      R2,#+0
   \   0000006C   0500000A           BEQ      ??_ReadWrite_4
   \   00000070   00708DE5           STR      R7,[SP, #+0]
   \   00000074   0B30A0E1           MOV      R3,R11
   \   00000078   0520A0E1           MOV      R2,R5
   \   0000007C   0CC09CE5           LDR      R12,[R12, #+12]
   \   00000080   3CFF2FE1           BLX      R12
   \   00000084   030000EA           B        ??_ReadWrite_5
   \                     ??_ReadWrite_4:
   \   00000088   0B30A0E1           MOV      R3,R11
   \   0000008C   0520A0E1           MOV      R2,R5
   \   00000090   08C09CE5           LDR      R12,[R12, #+8]
   \   00000094   3CFF2FE1           BLX      R12
   \                     ??_ReadWrite_5:
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   0700001A           BNE      ??_ReadWrite_2
   \   000000A0   B810D8E1           LDRH     R1,[R8, #+8]
   \   000000A4   0B6046E0           SUB      R6,R6,R11
   \   000000A8   04408BE0           ADD      R4,R11,R4
   \   000000AC   915B25E0           MLA      R5,R1,R11,R5
   \                     ??_ReadWrite_3:
   \   000000B0   0A4044E0           SUB      R4,R4,R10
   \   000000B4   000056E3           CMP      R6,#+0
   \   000000B8   DCFFFF1A           BNE      ??_ReadWrite_1
   \   000000BC   0000A0E3           MOV      R0,#+0
    182            }
    183            return r;
   \                     ??_ReadWrite_2:
   \   000000C0   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000C4   F08FBDE8           POP      {R4-R11,PC}      ;; return
    184          }
    185          
    186          /*********************************************************************
    187          *
    188          *       _LOGVOL_Read
    189          */

   \                                 In section .text, align 4, keep-with-next
    190          static int _LOGVOL_Read(U8 Unit, U32 FirstSectorReq, void *pBuffer, U32 NumSectorsReq) {
   \                     _LOGVOL_Read:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
    191            return _ReadWrite(Unit, FirstSectorReq, pBuffer, NumSectorsReq, 0, 0);
   \   00000008   00C0A0E3           MOV      R12,#+0
   \   0000000C   04C08DE5           STR      R12,[SP, #+4]
   \   00000010   00C08DE5           STR      R12,[SP, #+0]
   \   00000014   ........           BL       _ReadWrite
   \   00000018   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   0000001C   0080BDE8           POP      {PC}             ;; return
    192          }
    193          
    194          /*********************************************************************
    195          *
    196          *       _LOGVOL_Write
    197          */

   \                                 In section .text, align 4, keep-with-next
    198          static int _LOGVOL_Write(U8 Unit, U32 FirstSector, const void *pBuffer, U32 NumSectors, U8 RepeatSame) {
   \                     _LOGVOL_Write:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   10C0DDE5           LDRB     R12,[SP, #+16]
    199            return _ReadWrite(Unit, FirstSector, (const void*)pBuffer, NumSectors, 1, RepeatSame);
   \   0000000C   04C08DE5           STR      R12,[SP, #+4]
   \   00000010   01C0A0E3           MOV      R12,#+1
   \   00000014   00C08DE5           STR      R12,[SP, #+0]
   \   00000018   ........           BL       _ReadWrite
   \   0000001C   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
    200          }
    201          
    202          /*********************************************************************
    203          *
    204          *       _LOGVOL_IoCtl
    205          *
    206          */

   \                                 In section .text, align 4, keep-with-next
    207          static int _LOGVOL_IoCtl(U8 Unit, I32 Cmd, I32 Aux, void *pBuffer) {
   \                     _LOGVOL_IoCtl:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    208            LOG_VOL     * pLogVol;
    209            FS_DEV_INFO * pInfo;
    210            DEV_INFO    * pDevInfo;
    211            int           DriverReturn;
    212            int           r;
    213            U32           NumSectors; 
    214          
    215            ASSERT_UNIT_NO_IS_IN_RANGE(Unit);
    216            pLogVol = _apLogVol[Unit];
   \   00000004   ........           LDR      R7,??DataTable8_1
   \   00000008   0180A0E1           MOV      R8,R1
   \   0000000C   005197E7           LDR      R5,[R7, +R0, LSL #+2]
   \   00000010   10D04DE2           SUB      SP,SP,#+16
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   0340A0E1           MOV      R4,R3
    217            FS_USE_PARA(Aux);
    218            r = -1;
    219            switch (Cmd) {
   \   0000001C   FB0F58E2           SUBS     R0,R8,#+1004
   \   00000020   0200000A           BEQ      ??_LOGVOL_IoCtl_0
   \   00000024   070050E2           SUBS     R0,R0,#+7
   \   00000028   2F00000A           BEQ      ??_LOGVOL_IoCtl_1
   \   0000002C   3B0000EA           B        ??_LOGVOL_IoCtl_2
    220            case FS_CMD_GET_DEVINFO:
    221              if (!pBuffer) {
   \                     ??_LOGVOL_IoCtl_0:
   \   00000030   000054E3           CMP      R4,#+0
    222                return -1;
   \   00000034   0000E003           MVNEQ    R0,#+0
   \   00000038   4900000A           BEQ      ??_LOGVOL_IoCtl_3
    223              }
    224              pInfo = (FS_DEV_INFO *)pBuffer;
    225              NumSectors             = _GetNumSectors(pLogVol);
   \   0000003C   047095E5           LDR      R7,[R5, #+4]
   \   00000040   0060A0E3           MOV      R6,#+0
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   0710B0E1           MOVS     R1,R7
   \   0000004C   0600000A           BEQ      ??_LOGVOL_IoCtl_4
   \                     ??_LOGVOL_IoCtl_5:
   \   00000050   102091E5           LDR      R2,[R1, #+16]
   \   00000054   001091E5           LDR      R1,[R1, #+0]
   \   00000058   000082E0           ADD      R0,R2,R0
   \   0000005C   000051E3           CMP      R1,#+0
   \   00000060   FAFFFF1A           BNE      ??_LOGVOL_IoCtl_5
    226              if (NumSectors == 0) {
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   1100001A           BNE      ??_LOGVOL_IoCtl_6
    227                _UpdateNumSectors(pLogVol);
   \                     ??_LOGVOL_IoCtl_4:
   \   0000006C   000057E3           CMP      R7,#+0
   \   00000070   0F00000A           BEQ      ??_LOGVOL_IoCtl_6
   \                     ??_LOGVOL_IoCtl_7:
   \   00000074   04C097E5           LDR      R12,[R7, #+4]
   \   00000078   0D30A0E1           MOV      R3,SP
   \   0000007C   0020A0E3           MOV      R2,#+0
   \   00000080   FB1FA0E3           MOV      R1,#+1004
   \   00000084   0800D7E5           LDRB     R0,[R7, #+8]
   \   00000088   10C09CE5           LDR      R12,[R12, #+16]
   \   0000008C   3CFF2FE1           BLX      R12
   \   00000090   000050E3           CMP      R0,#+0
   \   00000094   0300001A           BNE      ??_LOGVOL_IoCtl_8
   \   00000098   04009DE5           LDR      R0,[SP, #+4]
   \   0000009C   100087E5           STR      R0,[R7, #+16]
   \   000000A0   B800DDE1           LDRH     R0,[SP, #+8]
   \   000000A4   B800C5E1           STRH     R0,[R5, #+8]
   \                     ??_LOGVOL_IoCtl_8:
   \   000000A8   007097E5           LDR      R7,[R7, #+0]
   \   000000AC   000057E3           CMP      R7,#+0
   \   000000B0   EFFFFF1A           BNE      ??_LOGVOL_IoCtl_7
    228              }
    229              NumSectors             = _GetNumSectors(pLogVol);
   \                     ??_LOGVOL_IoCtl_6:
   \   000000B4   040095E5           LDR      R0,[R5, #+4]
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   0400001A           BNE      ??_LOGVOL_IoCtl_9
    230              pInfo->NumSectors      = NumSectors;
   \                     ??_LOGVOL_IoCtl_10:
   \   000000C0   046084E5           STR      R6,[R4, #+4]
    231              pInfo->BytesPerSector  = pLogVol->BytesPerSector;
   \   000000C4   B800D5E1           LDRH     R0,[R5, #+8]
    232              r                      = 0;
   \   000000C8   0070A0E3           MOV      R7,#+0
   \   000000CC   B800C4E1           STRH     R0,[R4, #+8]
    233              break;
   \   000000D0   220000EA           B        ??_LOGVOL_IoCtl_11
   \                     ??_LOGVOL_IoCtl_9:
   \   000000D4   101090E5           LDR      R1,[R0, #+16]
   \   000000D8   000090E5           LDR      R0,[R0, #+0]
   \   000000DC   066081E0           ADD      R6,R1,R6
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   FAFFFF1A           BNE      ??_LOGVOL_IoCtl_9
   \   000000E8   F4FFFFEA           B        ??_LOGVOL_IoCtl_10
    234            case FS_CMD_DEINIT:
    235              pDevInfo = pLogVol->pDevInfo;
   \                     ??_LOGVOL_IoCtl_1:
   \   000000EC   045095E5           LDR      R5,[R5, #+4]
    236              while (pDevInfo) {
   \   000000F0   000055E3           CMP      R5,#+0
   \   000000F4   0400000A           BEQ      ??_LOGVOL_IoCtl_12
    237                DEV_INFO * pDevNext;
    238          
    239                pDevNext = pDevInfo->pNext;
   \                     ??_LOGVOL_IoCtl_13:
   \   000000F8   004095E5           LDR      R4,[R5, #+0]
    240                FS_Free(pDevInfo);
   \   000000FC   0500A0E1           MOV      R0,R5
   \   00000100   ........           BL       FS_Free
    241                pDevInfo = pDevNext;
   \   00000104   0450B0E1           MOVS     R5,R4
   \   00000108   FAFFFF1A           BNE      ??_LOGVOL_IoCtl_13
    242              }
    243              FS_FREE(pLogVol);
    244              _NumUnits--;
   \                     ??_LOGVOL_IoCtl_12:
   \   0000010C   100097E5           LDR      R0,[R7, #+16]
   \   00000110   010040E2           SUB      R0,R0,#+1
   \   00000114   100087E5           STR      R0,[R7, #+16]
    245              return 0;
   \   00000118   0000A0E3           MOV      R0,#+0
   \   0000011C   100000EA           B        ??_LOGVOL_IoCtl_3
    246            default:
    247              pDevInfo = pLogVol->pDevInfo;
   \                     ??_LOGVOL_IoCtl_2:
   \   00000120   045095E5           LDR      R5,[R5, #+4]
    248              r        = 0;
   \   00000124   0070A0E3           MOV      R7,#+0
    249              while (pDevInfo) {      
   \   00000128   000055E3           CMP      R5,#+0
   \   0000012C   0B00000A           BEQ      ??_LOGVOL_IoCtl_11
    250                DriverReturn = pDevInfo->pDevice->pfIoCtl(pDevInfo->Unit, Cmd, Aux, pBuffer);
   \                     ??_LOGVOL_IoCtl_14:
   \   00000130   04C095E5           LDR      R12,[R5, #+4]
   \   00000134   0430A0E1           MOV      R3,R4
   \   00000138   0620A0E1           MOV      R2,R6
   \   0000013C   0810A0E1           MOV      R1,R8
   \   00000140   0800D5E5           LDRB     R0,[R5, #+8]
   \   00000144   10C09CE5           LDR      R12,[R12, #+16]
   \   00000148   3CFF2FE1           BLX      R12
    251                if (DriverReturn != 0) {
   \   0000014C   000050E3           CMP      R0,#+0
    252                  r = DriverReturn;
    253                }
    254                pDevInfo = pDevInfo->pNext;
   \   00000150   005095E5           LDR      R5,[R5, #+0]
   \   00000154   0070A011           MOVNE    R7,R0
   \   00000158   000055E3           CMP      R5,#+0
   \   0000015C   F3FFFF1A           BNE      ??_LOGVOL_IoCtl_14
    255              }
    256              break;
    257            }
    258            return r;
   \                     ??_LOGVOL_IoCtl_11:
   \   00000160   0700A0E1           MOV      R0,R7
   \                     ??_LOGVOL_IoCtl_3:
   \   00000164   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   00000168   F081BDE8           POP      {R4-R8,PC}       ;; return
    259          }
    260          
    261          /*********************************************************************
    262          *
    263          *       _LOGVOL_AddDevice
    264          *
    265          *  Note:
    266          *    No functionality required here.
    267          */

   \                                 In section .text, align 4, keep-with-next
    268          static int _LOGVOL_AddDevice(void) {
    269            return _NumUnits;
   \                     _LOGVOL_AddDevice:
   \   00000000   ........           LDR      R0,??DataTable8_1
   \   00000004   100090E5           LDR      R0,[R0, #+16]
   \   00000008   1EFF2FE1           BX       LR               ;; return
    270          }
    271          
    272          /*********************************************************************
    273          *
    274          *       _LOGVOL_GetNumUnits
    275          *
    276          */

   \                                 In section .text, align 4, keep-with-next
    277          static int _LOGVOL_GetNumUnits(void) {
    278            return _NumUnits;
   \                     _LOGVOL_GetNumUnits:
   \   00000000   ........           LDR      R0,??DataTable8_1
   \   00000004   100090E5           LDR      R0,[R0, #+16]
   \   00000008   1EFF2FE1           BX       LR               ;; return
    279          }
    280          
    281          
    282          /*********************************************************************
    283          *
    284          *       _GetDriverName
    285          */

   \                                 In section .text, align 4, keep-with-next
    286          static const char * _LOGVOL_GetDriverName(U8 Unit) {
   \                     _LOGVOL_GetDriverName:
   \   00000000   ........           LDR      R1,??DataTable8_1
   \   00000004   000191E7           LDR      R0,[R1, +R0, LSL #+2]
   \   00000008   000050E3           CMP      R0,#+0
   \   0000000C   0100000A           BEQ      ??_LOGVOL_GetDriverName_0
    287            const char * sVolName;
    288            if (_apLogVol[Unit]) {
    289              sVolName = _apLogVol[Unit]->sVolName;
   \   00000010   000090E5           LDR      R0,[R0, #+0]
   \   00000014   1EFF2FE1           BX       LR
    290            } else {
    291              sVolName = "";
   \                     ??_LOGVOL_GetDriverName_0:
   \   00000018   ........           ADR      R0,??DataTable8  ;; ""
    292            }
    293            return sVolName;
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    294          }
    295          
    296          /*********************************************************************
    297          *
    298          *       Public code, internal
    299          *
    300          **********************************************************************
    301          */
    302          
    303          /*********************************************************************
    304          *
    305          *       FS_LOGVOL_AddDevice
    306          *
    307          */

   \                                 In section .text, align 4, keep-with-next
    308          static const FS_DEVICE_TYPE _LOGVOL_Driver = {
   \                     _LOGVOL_Driver:
   \   00000000                      ; Initializer data, 32 bytes
   \   00000000   ............       DC32 _LOGVOL_GetDriverName, _LOGVOL_AddDevice, _LOGVOL_Read, _LOGVOL_Write, _LOGVOL_IoCtl, 0, _LOGVOL_GetStatus, _LOGVOL_GetNumUnits
   \              ............
   \              ............
   \              ....00000000
   \              ............
   \              ....        
    309            _LOGVOL_GetDriverName,
    310            _LOGVOL_AddDevice,
    311            _LOGVOL_Read,
    312            _LOGVOL_Write,
    313            _LOGVOL_IoCtl,
    314            NULL,
    315            _LOGVOL_GetStatus,
    316            _LOGVOL_GetNumUnits
    317          };
    318          
    319          /*********************************************************************
    320          *
    321          *       Public code
    322          *
    323          **********************************************************************
    324          */
    325          
    326          /*********************************************************************
    327          *
    328          *       FS_LOGVOL_Create
    329          *
    330          */

   \                                 In section .text, align 4, keep-with-next
    331          int FS_LOGVOL_Create(const char * sVolName) {
   \                     FS_LOGVOL_Create:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    332            int r;
    333            LOG_VOL * pLogVol;
    334            FS_VOLUME * pVolume;
    335          
    336            FS_LOCK();
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   ........           BL       FS_OS_Lock
    337            r = -1;
    338            if ((_NumUnits + 1) < NUM_UNITS) {
   \   00000010   ........           LDR      R6,??DataTable8_1
   \   00000014   0050E0E3           MVN      R5,#+0
   \   00000018   100096E5           LDR      R0,[R6, #+16]
   \   0000001C   010080E2           ADD      R0,R0,#+1
   \   00000020   040050E3           CMP      R0,#+4
   \   00000024   0D0000AA           BGE      ??FS_LOGVOL_Create_0
    339              pVolume = FS__AddDevice(&_LOGVOL_Driver);
    340              if (pVolume) {
   \   00000028   ........           ADR      R0,_LOGVOL_Driver
   \   0000002C   ........           BL       FS__AddDevice
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0A00000A           BEQ      ??FS_LOGVOL_Create_1
    341                pLogVol = (LOG_VOL *)FS_AllocZeroed(sizeof(LOG_VOL));
   \   00000038   0C00A0E3           MOV      R0,#+12
   \   0000003C   ........           BL       FS_AllocZeroed
    342                if (pLogVol) {
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0600000A           BEQ      ??FS_LOGVOL_Create_1
    343                  pLogVol->sVolName = sVolName;
   \   00000048   004080E5           STR      R4,[R0, #+0]
    344                  _apLogVol[_NumUnits++] = pLogVol;
   \   0000004C   101096E5           LDR      R1,[R6, #+16]
    345                  r = 0;
   \   00000050   0050A0E3           MOV      R5,#+0
   \   00000054   010186E7           STR      R0,[R6, +R1, LSL #+2]
   \   00000058   010081E2           ADD      R0,R1,#+1
   \   0000005C   100086E5           STR      R0,[R6, #+16]
    346                }
    347              }
    348            }
    349            FS_UNLOCK();
   \                     ??FS_LOGVOL_Create_0:
   \   00000060   0000A0E3           MOV      R0,#+0
   \                     ??FS_LOGVOL_Create_1:
   \   00000064   ........           BL       FS_OS_Unlock
    350            return r;
   \   00000068   0500A0E1           MOV      R0,R5
   \   0000006C   7080BDE8           POP      {R4-R6,PC}       ;; return
    351          }
    352          
    353          /*********************************************************************
    354          *
    355          *       FS_LOGVOL_AddDevice
    356          *
    357          */

   \                                 In section .text, align 4, keep-with-next
    358          int FS_LOGVOL_AddDevice(const char * sLogVolName, const FS_DEVICE_TYPE * pDevice, U8 Unit, U32 StartOff, U32 NumSectors) {
   \                     FS_LOGVOL_AddDevice:
   \   00000000   FA4F2DE9           PUSH     {R1,R3-R11,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0080A0E1           MOV      R8,R0
   \   0000000C   0240A0E1           MOV      R4,R2
   \   00000010   38509DE5           LDR      R5,[SP, #+56]
    359            int       i;
    360            LOG_VOL * pLogVol;
    361            int       r;
    362          
    363            FS_LOCK();
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   ........           BL       FS_OS_Lock
    364            r = -1;
    365            //
    366            // Find log volume
    367            //
    368            for (i = 0; i < _NumUnits; i++) {
   \   0000001C   ........           LDR      R9,??DataTable8_1
   \   00000020   0060E0E3           MVN      R6,#+0
   \   00000024   00B0A0E3           MOV      R11,#+0
   \   00000028   09A0A0E1           MOV      R10,R9
   \   0000002C   000000EA           B        ??FS_LOGVOL_AddDevice_0
   \                     ??FS_LOGVOL_AddDevice_1:
   \   00000030   01B08BE2           ADD      R11,R11,#+1
   \                     ??FS_LOGVOL_AddDevice_0:
   \   00000034   100099E5           LDR      R0,[R9, #+16]
   \   00000038   00005BE1           CMP      R11,R0
   \   0000003C   2D0000AA           BGE      ??FS_LOGVOL_AddDevice_2
    369              pLogVol = _apLogVol[i];
   \   00000040   04709AE4           LDR      R7,[R10], #+4
    370              if (strcmp(sLogVolName, pLogVol->sVolName) == 0) {
   \   00000044   0800A0E1           MOV      R0,R8
   \   00000048   001097E5           LDR      R1,[R7, #+0]
   \   0000004C   ........           BL       strcmp
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   F5FFFF1A           BNE      ??FS_LOGVOL_AddDevice_1
    371                DEV_INFO             * pDevInfo;
    372                DEV_INFO             ** ppPrevNext;
    373                FS_DEV_INFO            DevInfo;
    374          
    375                FS_MEMSET(&DevInfo, 0, sizeof(DevInfo));
   \   00000058   0D00A0E1           MOV      R0,SP
   \   0000005C   0010A0E3           MOV      R1,#+0
   \   00000060   0020A0E3           MOV      R2,#+0
   \   00000064   0030A0E3           MOV      R3,#+0
   \   00000068   0E00A0E8           STM      R0!,{R1-R3}
    376                //
    377                // Get info from device
    378                //
    379                if (pDevice->pfIoCtl(Unit, FS_CMD_GET_DEVINFO, 0, (void*)&DevInfo)) {
   \   0000006C   0CC09DE5           LDR      R12,[SP, #+12]
   \   00000070   0D30A0E1           MOV      R3,SP
   \   00000074   FB1FA0E3           MOV      R1,#+1004
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   10C09CE5           LDR      R12,[R12, #+16]
   \   00000080   3CFF2FE1           BLX      R12
    380                  FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "FS_LOGVOL_AddDevice: Could not retrieve device information from device.\n"));
    381                }
    382                if (NumSectors == 0) {
   \   00000084   04009DE5           LDR      R0,[SP, #+4]
   \   00000088   000055E3           CMP      R5,#+0
    383                  NumSectors = DevInfo.NumSectors;
   \   0000008C   0050A001           MOVEQ    R5,R0
    384                }
    385                if (DevInfo.NumSectors < NumSectors) {
   \   00000090   050050E1           CMP      R0,R5
   \   00000094   1700003A           BCC      ??FS_LOGVOL_AddDevice_2
    386                  FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "FS_LOGVOL_AddDevice: Device has less sector than requested.\n"));
    387                  break;
    388                }
    389                //
    390                // For first device added, set BytesPerSector. All add. devices added need to have the same sector size.
    391                //
    392                if ((void*)pLogVol->pDevInfo == NULL) {
   \   00000098   040097E5           LDR      R0,[R7, #+4]
   \   0000009C   000050E3           CMP      R0,#+0
    393                  pLogVol->BytesPerSector = DevInfo.BytesPerSector;
   \   000000A0   B800DD01           LDRHEQ   R0,[SP, #+8]
   \   000000A4   B800C701           STRHEQ   R0,[R7, #+8]
    394                }
    395                if (pLogVol->BytesPerSector != DevInfo.BytesPerSector) {
   \   000000A8   B800D7E1           LDRH     R0,[R7, #+8]
   \   000000AC   B810DDE1           LDRH     R1,[SP, #+8]
   \   000000B0   010050E1           CMP      R0,R1
   \   000000B4   0F00001A           BNE      ??FS_LOGVOL_AddDevice_2
    396                  FS_DEBUG_ERROROUT((FS_MTYPE_DRIVER, "FS_LOGVOL_AddDevice: Devices with different sector size can not be combined.\n"));
    397                  break;
    398                }
    399                //
    400                // Goto end of list
    401                //
    402                ppPrevNext   = &pLogVol->pDevInfo;
   \   000000B8   046087E2           ADD      R6,R7,#+4
   \   000000BC   000000EA           B        ??FS_LOGVOL_AddDevice_3
    403                for (; pDevInfo = *ppPrevNext, pDevInfo; ppPrevNext = &pDevInfo->pNext);
   \                     ??FS_LOGVOL_AddDevice_4:
   \   000000C0   0060A0E1           MOV      R6,R0
   \                     ??FS_LOGVOL_AddDevice_3:
   \   000000C4   000096E5           LDR      R0,[R6, #+0]
   \   000000C8   000050E3           CMP      R0,#+0
   \   000000CC   FBFFFF1A           BNE      ??FS_LOGVOL_AddDevice_4
    404                //
    405                // Alloc memory for new device, fill it in and add it to the linked list
    406                //
    407                pDevInfo    = (DEV_INFO *)FS_AllocZeroed(sizeof(DEV_INFO));
   \   000000D0   1400A0E3           MOV      R0,#+20
   \   000000D4   ........           BL       FS_AllocZeroed
    408                pDevInfo->NumSectors = NumSectors;
   \   000000D8   105080E5           STR      R5,[R0, #+16]
    409                pDevInfo->StartOff   = StartOff;
   \   000000DC   10109DE5           LDR      R1,[SP, #+16]
   \   000000E0   0C1080E5           STR      R1,[R0, #+12]
    410                pDevInfo->pDevice    = pDevice;
   \   000000E4   0C109DE5           LDR      R1,[SP, #+12]
   \   000000E8   041080E5           STR      R1,[R0, #+4]
    411                pDevInfo->Unit       = Unit;
   \   000000EC   0840C0E5           STRB     R4,[R0, #+8]
    412                *ppPrevNext = pDevInfo;
   \   000000F0   000086E5           STR      R0,[R6, #+0]
    413                r = 0;
   \   000000F4   0060A0E3           MOV      R6,#+0
    414                break;
    415              }
    416            }
    417            FS_UNLOCK();
   \                     ??FS_LOGVOL_AddDevice_2:
   \   000000F8   0000A0E3           MOV      R0,#+0
   \   000000FC   ........           BL       FS_OS_Unlock
    418            return r;
   \   00000100   0600A0E1           MOV      R0,R6
   \   00000104   14D08DE2           ADD      SP,SP,#+20
   \   00000108   F08FBDE8           POP      {R4-R11,PC}      ;; return
    419          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   00000000           DC8      "",0x0,0x0,0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   ........           DC32     _apLogVol

   \                                 In section .rodata, align 1, keep-with-next
   \                     `?<Constant "">`:
   \   00000000                      ; Initializer data, 1 bytes
   \   00000000   00                 DC8 0
    420          
    421          
    422          
    423          
    424          
    425          /*************************** End of file ****************************/
    426          

   Maximum stack usage in bytes:

     Function              .cstack
     --------              -------
     FS_LOGVOL_AddDevice       56
     FS_LOGVOL_Create          16
     _LOGVOL_AddDevice          0
     _LOGVOL_GetDriverName      0
     _LOGVOL_GetNumUnits        0
     _LOGVOL_GetStatus          0
     _LOGVOL_IoCtl             40
     _LOGVOL_Read              16
     _LOGVOL_Write             16
     _ReadWrite                40


   Section sizes:

     Function/Label        Bytes
     --------------        -----
     _apLogVol               20
     _NumUnits
     _LOGVOL_GetStatus        8
     _ReadWrite             200
     _LOGVOL_Read            32
     _LOGVOL_Write           36
     _LOGVOL_IoCtl          364
     _LOGVOL_AddDevice       12
     _LOGVOL_GetNumUnits     12
     _LOGVOL_GetDriverName   32
     _LOGVOL_Driver          32
     FS_LOGVOL_Create       112
     FS_LOGVOL_AddDevice    268
     ??DataTable8             4
     ??DataTable8_1           4
     ?<Constant "">           1

 
    20 bytes in section .bss
     1 byte  in section .rodata
 1 116 bytes in section .text
 
 1 116 bytes of CODE  memory
     1 byte  of CONST memory
    20 bytes of DATA  memory

Errors: none
Warnings: none
