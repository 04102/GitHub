###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     02/Feb/2016  18:29:16 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\DUII\DualGaugeScreen.cpp                         #
#    Command line =  C:\DUII\DUII\DualGaugeScreen.cpp -D DEBUG=1 -D           #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --eec++ --no_static_destruction                          #
#    List file    =  C:\DUII\TargetHW\Release\List\DualGaugeScreen.lst        #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\DualGaugeScreen.o           #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\DUII\DualGaugeScreen.cpp
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2009  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.00 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : MainTask.C
     19          Purpose     : Main program, called from after main after initialisation
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stdio.h>
     24          #include <stdlib.h>
     25          #include "DUII.h"
     26          #include "GUI.h"
     27          #include "GeneralConfig.h"
     28          #include "commondefs.h"
     29          #include "ConfigScreens.h"
     30          #include "DualGaugeScreen.h"
     31          #include "gauge.hpp"
     32          #include "RunningGauges.h"
     33          #include "DataHandler.h"
     34          #include "LEDHandler.h"
     35          
     36          #ifdef __cplusplus
     37          extern "C" {
     38          #endif
     39          
     40          /*********************************************************************
     41          *
     42          *       External data and code
     43          *
     44          **********************************************************************
     45          */
     46          extern GUI_CONST_STORAGE GUI_BITMAP bmDualGaugeBackground;
     47          extern GUI_CONST_STORAGE GUI_BITMAP bmLeftGauge;
     48          extern GUI_CONST_STORAGE GUI_BITMAP bmRightGauge;
     49          extern char lockupSemaphore;
     50          
     51          /*********************************************************************
     52          *
     53          *       Public code
     54          *
     55          **********************************************************************
     56          */
     57          Gauge *CreateAnalogInputGauge(int input, Alarm **pAlarm, WM_HWIN hParent, int hpos, GUI_CONST_STORAGE GUI_BITMAP *pImage);
     58          
     59          /*********************************************************************
     60          *
     61          *       Public variables
     62          *
     63          **********************************************************************
     64          */
     65          char inputEnabled[4];
     66          
     67          #ifdef __cplusplus
     68          }
     69          #endif
     70          
     71          
     72          /*********************************************************************
     73          *
     74          *       Local Prototypes
     75          *
     76          **********************************************************************
     77          */
     78          int GetInput(int n);
     79          GlobalDataIndexType GetInputID(int input);
     80          
     81          /*********************************************************************
     82          *
     83          *       Local Valiables
     84          *
     85          **********************************************************************
     86          */
     87          static WM_HWIN hDualGaugeScreen;
     88          static WM_HTIMER hScreenTimer;
     89          Gauge *pAnalog0Gauge = 0;
     90          Gauge *pAnalog1Gauge = 0;
     91          static bool firsttimethrough;
     92          static Alarm *pAnalog0Red = 0;
     93          static Alarm *pAnalog1Red = 0;
     94          static GUI_MEMDEV_Handle memDualGaugeScreen;
     95          

   \                                 In section .text, align 4, keep-with-next
     96          void _cbDualGaugeCallback(WM_MESSAGE * pMsg)
     97          {
   \                     _cbDualGaugeCallback:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
     98          	switch(pMsg->MsgId)
   \   00000004   001090E5           LDR      R1,[R0, #+0]
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   0B1051E2           SUBS     R1,R1,#+11
   \   00000010   8400000A           BEQ      ??_cbDualGaugeCallback_0
   \   00000014   041051E2           SUBS     R1,R1,#+4
   \   00000018   0C00000A           BEQ      ??_cbDualGaugeCallback_1
   \   0000001C   411F51E2           SUBS     R1,R1,#+260
   \   00000020   A800001A           BNE      ??_cbDualGaugeCallback_2
     99          	{
    100          	case WM_TIMER:
    101          		if (pMsg->Data.v == hScreenTimer)
   \   00000024   ........           LDR      R4,??DataTable6_4
   \   00000028   0C0090E5           LDR      R0,[R0, #+12]
   \   0000002C   042094E5           LDR      R2,[R4, #+4]
   \   00000030   020050E1           CMP      R0,R2
   \   00000034   A400001A           BNE      ??_cbDualGaugeCallback_3
    102          		{
    103          			WM_RestartTimer(hScreenTimer, GAUGE_SCREEN_REFRESH_TIME);
   \   00000038   1910A0E3           MOV      R1,#+25
   \   0000003C   0200A0E1           MOV      R0,R2
   \   00000040   ........           BL       WM_RestartTimer
    104          			WM_InvalidateWindow(hDualGaugeScreen);
   \   00000044   000094E5           LDR      R0,[R4, #+0]
   \   00000048   ........           BL       WM_InvalidateWindow
   \   0000004C   9E0000EA           B        ??_cbDualGaugeCallback_3
    105          		}
    106          		break;
    107          
    108          	case WM_PAINT:
    109          		if (CS_IsVisible(MULTI_ANALOG_GAUGES) || firsttimethrough)
   \                     ??_cbDualGaugeCallback_1:
   \   00000050   0400A0E3           MOV      R0,#+4
   \   00000054   ........           BL       CS_IsVisible
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0300001A           BNE      ??_cbDualGaugeCallback_4
   \   00000060   ........           LDR      R0,??DataTable6_4
   \   00000064   1C00D0E5           LDRB     R0,[R0, #+28]
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   6800000A           BEQ      ??_cbDualGaugeCallback_5
    110          		{
    111          			GUI_MEMDEV_Handle mControl;
    112          			int temp;
    113          
    114          			if (lockupSemaphore)			// If main has not run since our last paint - exit!
   \                     ??_cbDualGaugeCallback_4:
   \   00000070   ........           LDR      R0,??DataTable6
   \   00000074   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000078   000051E3           CMP      R1,#+0
   \   0000007C   9200001A           BNE      ??_cbDualGaugeCallback_3
    115          				break;
    116          			else lockupSemaphore = true;
   \   00000080   0110A0E3           MOV      R1,#+1
    117          			
    118          			GUI_MEMDEV_Select(memDualGaugeScreen);
   \   00000084   ........           LDR      R4,??DataTable6_4
   \   00000088   0010C0E5           STRB     R1,[R0, #+0]
   \   0000008C   180094E5           LDR      R0,[R4, #+24]
   \   00000090   ........           BL       GUI_MEMDEV_Select
    119          
    120          			firsttimethrough = false;
   \   00000094   0000A0E3           MOV      R0,#+0
   \   00000098   1C00C4E5           STRB     R0,[R4, #+28]
    121          
    122          			GUI_DrawBitmap(&bmDualGaugeBackground, 0, 0);
   \   0000009C   0020A0E3           MOV      R2,#+0
   \   000000A0   0010A0E3           MOV      R1,#+0
   \   000000A4   ........           LDR      R0,??DataTable6_1
   \   000000A8   ........           BL       GUI_DrawBitmap
    123          
    124          			if ((temp = GetInput(1)) != -1)
   \   000000AC   ........           LDR      R5,??DataTable6_2
   \   000000B0   0000A0E3           MOV      R0,#+0
   \   000000B4   0010A0E3           MOV      R1,#+0
   \   000000B8   0520A0E1           MOV      R2,R5
   \                     ??_cbDualGaugeCallback_6:
   \   000000BC   9330D2E5           LDRB     R3,[R2, #+147]
   \   000000C0   000053E3           CMP      R3,#+0
   \   000000C4   01108112           ADDNE    R1,R1,#+1
   \   000000C8   010051E3           CMP      R1,#+1
   \   000000CC   0400000A           BEQ      ??_cbDualGaugeCallback_7
   \   000000D0   010080E2           ADD      R0,R0,#+1
   \   000000D4   402082E2           ADD      R2,R2,#+64
   \   000000D8   040050E3           CMP      R0,#+4
   \   000000DC   F6FFFFBA           BLT      ??_cbDualGaugeCallback_6
   \   000000E0   140000EA           B        ??_cbDualGaugeCallback_8
   \                     ??_cbDualGaugeCallback_7:
   \   000000E4   010070E3           CMN      R0,#+1
   \   000000E8   1200000A           BEQ      ??_cbDualGaugeCallback_8
    125          				pAnalog0Gauge->SetValue(GetValue(GetInputID(temp)).fVal);
   \   000000EC   010050E3           CMP      R0,#+1
   \   000000F0   0800000A           BEQ      ??_cbDualGaugeCallback_9
   \   000000F4   0900003A           BCC      ??_cbDualGaugeCallback_10
   \   000000F8   030050E3           CMP      R0,#+3
   \   000000FC   0100000A           BEQ      ??_cbDualGaugeCallback_11
   \   00000100   0200003A           BCC      ??_cbDualGaugeCallback_12
   \   00000104   050000EA           B        ??_cbDualGaugeCallback_10
   \                     ??_cbDualGaugeCallback_11:
   \   00000108   3910A0E3           MOV      R1,#+57
   \   0000010C   040000EA           B        ??_cbDualGaugeCallback_13
   \                     ??_cbDualGaugeCallback_12:
   \   00000110   3810A0E3           MOV      R1,#+56
   \   00000114   020000EA           B        ??_cbDualGaugeCallback_13
   \                     ??_cbDualGaugeCallback_9:
   \   00000118   3710A0E3           MOV      R1,#+55
   \   0000011C   000000EA           B        ??_cbDualGaugeCallback_13
   \                     ??_cbDualGaugeCallback_10:
   \   00000120   3610A0E3           MOV      R1,#+54
   \                     ??_cbDualGaugeCallback_13:
   \   00000124   0D00A0E1           MOV      R0,SP
   \   00000128   ........           BL       GetValue
   \   0000012C   00109DE5           LDR      R1,[SP, #+0]
   \   00000130   080094E5           LDR      R0,[R4, #+8]
   \   00000134   ........           BL       _ZN5Gauge8SetValueEf
    126          			if ((temp = GetInput(2)) != -1)
   \                     ??_cbDualGaugeCallback_8:
   \   00000138   0000A0E3           MOV      R0,#+0
   \   0000013C   0010A0E3           MOV      R1,#+0
   \                     ??_cbDualGaugeCallback_14:
   \   00000140   9320D5E5           LDRB     R2,[R5, #+147]
   \   00000144   000052E3           CMP      R2,#+0
   \   00000148   01108112           ADDNE    R1,R1,#+1
   \   0000014C   020051E3           CMP      R1,#+2
   \   00000150   0400000A           BEQ      ??_cbDualGaugeCallback_15
   \   00000154   010080E2           ADD      R0,R0,#+1
   \   00000158   405085E2           ADD      R5,R5,#+64
   \   0000015C   040050E3           CMP      R0,#+4
   \   00000160   F6FFFFBA           BLT      ??_cbDualGaugeCallback_14
   \   00000164   140000EA           B        ??_cbDualGaugeCallback_16
   \                     ??_cbDualGaugeCallback_15:
   \   00000168   010070E3           CMN      R0,#+1
   \   0000016C   1200000A           BEQ      ??_cbDualGaugeCallback_16
    127          				pAnalog1Gauge->SetValue(GetValue(GetInputID(temp)).fVal);
   \   00000170   010050E3           CMP      R0,#+1
   \   00000174   0800000A           BEQ      ??_cbDualGaugeCallback_17
   \   00000178   0900003A           BCC      ??_cbDualGaugeCallback_18
   \   0000017C   030050E3           CMP      R0,#+3
   \   00000180   0100000A           BEQ      ??_cbDualGaugeCallback_19
   \   00000184   0200003A           BCC      ??_cbDualGaugeCallback_20
   \   00000188   050000EA           B        ??_cbDualGaugeCallback_18
   \                     ??_cbDualGaugeCallback_19:
   \   0000018C   3910A0E3           MOV      R1,#+57
   \   00000190   040000EA           B        ??_cbDualGaugeCallback_21
   \                     ??_cbDualGaugeCallback_20:
   \   00000194   3810A0E3           MOV      R1,#+56
   \   00000198   020000EA           B        ??_cbDualGaugeCallback_21
   \                     ??_cbDualGaugeCallback_17:
   \   0000019C   3710A0E3           MOV      R1,#+55
   \   000001A0   000000EA           B        ??_cbDualGaugeCallback_21
   \                     ??_cbDualGaugeCallback_18:
   \   000001A4   3610A0E3           MOV      R1,#+54
   \                     ??_cbDualGaugeCallback_21:
   \   000001A8   0D00A0E1           MOV      R0,SP
   \   000001AC   ........           BL       GetValue
   \   000001B0   00109DE5           LDR      R1,[SP, #+0]
   \   000001B4   0C0094E5           LDR      R0,[R4, #+12]
   \   000001B8   ........           BL       _ZN5Gauge8SetValueEf
    128          
    129          			mControl = pAnalog0Gauge->DrawToMemArea();
   \                     ??_cbDualGaugeCallback_16:
   \   000001BC   080094E5           LDR      R0,[R4, #+8]
   \   000001C0   ........           BL       _ZN5Gauge13DrawToMemAreaEv
   \   000001C4   0050A0E1           MOV      R5,R0
    130          			GUI_MEMDEV_Select(memDualGaugeScreen);
   \   000001C8   180094E5           LDR      R0,[R4, #+24]
   \   000001CC   ........           BL       GUI_MEMDEV_Select
    131          			GUI_MEMDEV_Write(mControl);
   \   000001D0   0500A0E1           MOV      R0,R5
   \   000001D4   ........           BL       GUI_MEMDEV_Write
    132          
    133          			mControl = pAnalog1Gauge->DrawToMemArea();
   \   000001D8   0C0094E5           LDR      R0,[R4, #+12]
   \   000001DC   ........           BL       _ZN5Gauge13DrawToMemAreaEv
   \   000001E0   0050A0E1           MOV      R5,R0
    134          			GUI_MEMDEV_Select(memDualGaugeScreen);
   \   000001E4   180094E5           LDR      R0,[R4, #+24]
   \   000001E8   ........           BL       GUI_MEMDEV_Select
    135          			GUI_MEMDEV_Write(mControl);
   \   000001EC   0500A0E1           MOV      R0,R5
   \   000001F0   ........           BL       GUI_MEMDEV_Write
    136          
    137          			GUI_DrawBitmap(&bmthreewayarrow, 0, 229);
   \   000001F4   E520A0E3           MOV      R2,#+229
   \   000001F8   0010A0E3           MOV      R1,#+0
   \   000001FC   ........           LDR      R0,??DataTable6_3
   \   00000200   ........           BL       GUI_DrawBitmap
    138          
    139          #ifdef	INCLUDE_RACE_HELP
    140          			// If the help screen is still being displayed then show the appropriate help screen
    141          			if (raceTimerActive)
    142          			{
    143          				CheckRaceHelpScreen(MULTI_ANALOG_GAUGES);
    144          			}
    145          #endif
    146          
    147          			CheckWarningPopups();
   \   00000204   ........           BL       CheckWarningPopups
    148          
    149          			GUI_MEMDEV_CopyToLCD(memDualGaugeScreen);
   \   00000208   180094E5           LDR      R0,[R4, #+24]
   \   0000020C   ........           BL       GUI_MEMDEV_CopyToLCD
    150          
    151          			GUI_SelectLCD();
   \   00000210   ........           BL       GUI_SelectLCD
    152          		}
    153          		if (SlideOutVisible())
   \                     ??_cbDualGaugeCallback_5:
   \   00000214   ........           BL       SlideOutVisible
   \   00000218   000050E3           CMP      R0,#+0
   \   0000021C   2A00000A           BEQ      ??_cbDualGaugeCallback_3
    154          			DrawSignalStrength();
   \   00000220   ........           BL       DrawSignalStrength
   \   00000224   280000EA           B        ??_cbDualGaugeCallback_3
    155          		break;
    156          
    157          	case WM_DELETE:
    158          		if (pAnalog0Gauge)
   \                     ??_cbDualGaugeCallback_0:
   \   00000228   ........           LDR      R4,??DataTable6_4
   \   0000022C   080094E5           LDR      R0,[R4, #+8]
   \   00000230   000050E3           CMP      R0,#+0
   \   00000234   0300000A           BEQ      ??_cbDualGaugeCallback_22
    159          		{
    160          			delete pAnalog0Gauge;
   \   00000238   ........           BL       _ZN5GaugeD1Ev
   \   0000023C   ........           BL       _ZdlPv
    161          			pAnalog0Gauge = 0;
   \   00000240   0000A0E3           MOV      R0,#+0
   \   00000244   080084E5           STR      R0,[R4, #+8]
    162          		}
    163          		if (pAnalog1Gauge)
   \                     ??_cbDualGaugeCallback_22:
   \   00000248   0C0094E5           LDR      R0,[R4, #+12]
   \   0000024C   000050E3           CMP      R0,#+0
   \   00000250   0300000A           BEQ      ??_cbDualGaugeCallback_23
    164          		{
    165          			delete pAnalog1Gauge;
   \   00000254   ........           BL       _ZN5GaugeD1Ev
   \   00000258   ........           BL       _ZdlPv
    166          			pAnalog1Gauge = 0;
   \   0000025C   0000A0E3           MOV      R0,#+0
   \   00000260   0C0084E5           STR      R0,[R4, #+12]
    167          		}
    168          		if (pAnalog0Red)
   \                     ??_cbDualGaugeCallback_23:
   \   00000264   100094E5           LDR      R0,[R4, #+16]
   \   00000268   000050E3           CMP      R0,#+0
   \   0000026C   0700000A           BEQ      ??_cbDualGaugeCallback_24
    169          		{
    170          			if (pAnalog0Red->Next)
   \   00000270   180090E5           LDR      R0,[R0, #+24]
   \   00000274   000050E3           CMP      R0,#+0
   \   00000278   0000000A           BEQ      ??_cbDualGaugeCallback_25
    171          				delete pAnalog0Red->Next;
   \   0000027C   ........           BL       _ZdlPv
    172          			delete pAnalog0Red;
   \                     ??_cbDualGaugeCallback_25:
   \   00000280   100094E5           LDR      R0,[R4, #+16]
   \   00000284   ........           BL       _ZdlPv
    173          			pAnalog0Red = 0;
   \   00000288   0000A0E3           MOV      R0,#+0
   \   0000028C   100084E5           STR      R0,[R4, #+16]
    174          		}
    175          		if (pAnalog1Red)
   \                     ??_cbDualGaugeCallback_24:
   \   00000290   140094E5           LDR      R0,[R4, #+20]
   \   00000294   000050E3           CMP      R0,#+0
   \   00000298   0700000A           BEQ      ??_cbDualGaugeCallback_26
    176          		{
    177          			if (pAnalog1Red->Next)
   \   0000029C   180090E5           LDR      R0,[R0, #+24]
   \   000002A0   000050E3           CMP      R0,#+0
   \   000002A4   0000000A           BEQ      ??_cbDualGaugeCallback_27
    178          				delete pAnalog1Red->Next;
   \   000002A8   ........           BL       _ZdlPv
    179          			delete pAnalog1Red;
   \                     ??_cbDualGaugeCallback_27:
   \   000002AC   140094E5           LDR      R0,[R4, #+20]
   \   000002B0   ........           BL       _ZdlPv
    180          			pAnalog1Red = 0;
   \   000002B4   0000A0E3           MOV      R0,#+0
   \   000002B8   140084E5           STR      R0,[R4, #+20]
    181          		}
    182          		GUI_MEMDEV_Delete(memDualGaugeScreen);
   \                     ??_cbDualGaugeCallback_26:
   \   000002BC   180094E5           LDR      R0,[R4, #+24]
   \   000002C0   ........           BL       GUI_MEMDEV_Delete
    183          		break;
   \   000002C4   000000EA           B        ??_cbDualGaugeCallback_3
    184          
    185          	default:
    186          		  WM_DefaultProc(pMsg);
   \                     ??_cbDualGaugeCallback_2:
   \   000002C8   ........           BL       WM_DefaultProc
    187          	};
    188          }
   \                     ??_cbDualGaugeCallback_3:
   \   000002CC   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   000002D0   3080BDE8           POP      {R4,R5,PC}       ;; return
    189          
    190          /*********************************************************************
    191          *
    192          *       Dual Gauge Screen
    193          */
    194          

   \                                 In section .text, align 4, keep-with-next
    195          WM_HWIN Display_DualGaugeScreen(WM_HWIN hParent)
    196          {
   \                     Display_DualGaugeScreen:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    197          	firsttimethrough = true;
   \   00000004   ........           LDR      R4,??DataTable6_4
   \   00000008   0110A0E3           MOV      R1,#+1
   \   0000000C   1C10C4E5           STRB     R1,[R4, #+28]
   \   00000010   14D04DE2           SUB      SP,SP,#+20
    198          
    199          	if ((hDualGaugeScreen = WM_CreateWindowAsChild(0, 0, XSIZE_PHYS, YSIZE_PHYS, hParent, WM_CF_SHOW, _cbDualGaugeCallback, 0)) <= 0)
   \   00000014   0010A0E3           MOV      R1,#+0
   \   00000018   0C108DE5           STR      R1,[SP, #+12]
   \   0000001C   ........           LDR      R1,??DataTable6_5
   \   00000020   00008DE5           STR      R0,[SP, #+0]
   \   00000024   08108DE5           STR      R1,[SP, #+8]
   \   00000028   0210A0E3           MOV      R1,#+2
   \   0000002C   04108DE5           STR      R1,[SP, #+4]
   \   00000030   443FA0E3           MOV      R3,#+272
   \   00000034   782FA0E3           MOV      R2,#+480
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   0000A0E3           MOV      R0,#+0
   \   00000040   ........           BL       WM_CreateWindowAsChild
   \   00000044   000084E5           STR      R0,[R4, #+0]
   \   00000048   010050E3           CMP      R0,#+1
   \   0000004C   000000AA           BGE      ??Display_DualGaugeScreen_0
    200          		SystemError();
   \   00000050   ........           BL       SystemError
    201          
    202          	// Display the FIRST TWO enabled analog inputs.  Note that there SHOULD only be
    203          	// one or two inputs enabled.
    204          	pAnalog0Gauge = CreateAnalogInputGauge(GetInput(1), &pAnalog0Red, hDualGaugeScreen,   0, &bmLeftGauge);
   \                     ??Display_DualGaugeScreen_0:
   \   00000054   ........           LDR      R5,??DataTable6_2
   \   00000058   0000A0E3           MOV      R0,#+0
   \   0000005C   0010A0E3           MOV      R1,#+0
   \   00000060   0520A0E1           MOV      R2,R5
   \                     ??Display_DualGaugeScreen_1:
   \   00000064   9330D2E5           LDRB     R3,[R2, #+147]
   \   00000068   000053E3           CMP      R3,#+0
   \   0000006C   01108112           ADDNE    R1,R1,#+1
   \   00000070   010051E3           CMP      R1,#+1
   \   00000074   0400000A           BEQ      ??Display_DualGaugeScreen_2
   \   00000078   010080E2           ADD      R0,R0,#+1
   \   0000007C   402082E2           ADD      R2,R2,#+64
   \   00000080   040050E3           CMP      R0,#+4
   \   00000084   F6FFFFBA           BLT      ??Display_DualGaugeScreen_1
   \   00000088   0000E0E3           MVN      R0,#+0
   \                     ??Display_DualGaugeScreen_2:
   \   0000008C   ........           LDR      R1,??DataTable6_6
   \   00000090   0030A0E3           MOV      R3,#+0
   \   00000094   00108DE5           STR      R1,[SP, #+0]
   \   00000098   002094E5           LDR      R2,[R4, #+0]
   \   0000009C   101084E2           ADD      R1,R4,#+16
   \   000000A0   ........           BL       CreateAnalogInputGauge
   \   000000A4   080084E5           STR      R0,[R4, #+8]
    205          	pAnalog1Gauge = CreateAnalogInputGauge(GetInput(2), &pAnalog1Red, hDualGaugeScreen, 250, &bmRightGauge);
   \   000000A8   0000A0E3           MOV      R0,#+0
   \   000000AC   0010A0E3           MOV      R1,#+0
   \                     ??Display_DualGaugeScreen_3:
   \   000000B0   9320D5E5           LDRB     R2,[R5, #+147]
   \   000000B4   000052E3           CMP      R2,#+0
   \   000000B8   01108112           ADDNE    R1,R1,#+1
   \   000000BC   020051E3           CMP      R1,#+2
   \   000000C0   0400000A           BEQ      ??Display_DualGaugeScreen_4
   \   000000C4   010080E2           ADD      R0,R0,#+1
   \   000000C8   405085E2           ADD      R5,R5,#+64
   \   000000CC   040050E3           CMP      R0,#+4
   \   000000D0   F6FFFFBA           BLT      ??Display_DualGaugeScreen_3
   \   000000D4   0000E0E3           MVN      R0,#+0
   \                     ??Display_DualGaugeScreen_4:
   \   000000D8   ........           LDR      R1,??DataTable6_10
   \   000000DC   FA30A0E3           MOV      R3,#+250
   \   000000E0   00108DE5           STR      R1,[SP, #+0]
   \   000000E4   002094E5           LDR      R2,[R4, #+0]
   \   000000E8   141084E2           ADD      R1,R4,#+20
   \   000000EC   ........           BL       CreateAnalogInputGauge
   \   000000F0   0C0084E5           STR      R0,[R4, #+12]
    206          
    207          	WM_InvalidateWindow(hDualGaugeScreen);
   \   000000F4   000094E5           LDR      R0,[R4, #+0]
   \   000000F8   ........           BL       WM_InvalidateWindow
    208          
    209          	// create the memory area to prevent flicker
    210          	memDualGaugeScreen = GUI_MEMDEV_Create(0, 0, XSIZE_PHYS, YSIZE_PHYS);
   \   000000FC   443FA0E3           MOV      R3,#+272
   \   00000100   782FA0E3           MOV      R2,#+480
   \   00000104   0010A0E3           MOV      R1,#+0
   \   00000108   0000A0E3           MOV      R0,#+0
   \   0000010C   ........           BL       GUI_MEMDEV_Create
   \   00000110   180084E5           STR      R0,[R4, #+24]
    211          
    212          	hScreenTimer = WM_CreateTimer(hDualGaugeScreen, 0, GAUGE_SCREEN_REFRESH_TIME, 0);
   \   00000114   0030A0E3           MOV      R3,#+0
   \   00000118   1920A0E3           MOV      R2,#+25
   \   0000011C   0010A0E3           MOV      R1,#+0
   \   00000120   000094E5           LDR      R0,[R4, #+0]
   \   00000124   ........           BL       WM_CreateTimer
   \   00000128   040084E5           STR      R0,[R4, #+4]
    213          
    214          	return hDualGaugeScreen;
   \   0000012C   000094E5           LDR      R0,[R4, #+0]
   \   00000130   14D08DE2           ADD      SP,SP,#+20
   \   00000134   3080BDE8           POP      {R4,R5,PC}       ;; return
    215          }
    216          
    217          

   \                                 In section .text, align 4, keep-with-next
    218          Gauge *CreateAnalogInputGauge(int input, Alarm **pAlarm, WM_HWIN hParent, int hpos, GUI_CONST_STORAGE GUI_BITMAP *pImage)
    219          {
   \                     CreateAnalogInputGauge:
   \   00000000   FF4F2DE9           PUSH     {R0-R11,LR}
   \   00000004   34D04DE2           SUB      SP,SP,#+52
    220          	float upperLimit, lowerLimit, temp;
    221          	char *pName, *pUnits;
    222          	Gauge *pGauge;
    223          	Alarm *pAlarmL, *pAlarmH;
    224          	static char inputNum[5];
    225          
    226          	if ((input != -1 ) && (inputEnabled[input] = vehicleData.analogInput[input].enabled))
   \   00000008   ........           LDR      R4,??DataTable6_7
   \   0000000C   010070E3           CMN      R0,#+1
   \   00000010   5C00000A           BEQ      ??CreateAnalogInputGauge_0
   \   00000014   ........           LDR      R1,??DataTable6_2
   \   00000018   005381E0           ADD      R5,R1,R0, LSL #+6
   \   0000001C   9300D5E5           LDRB     R0,[R5, #+147]
   \   00000020   34109DE5           LDR      R1,[SP, #+52]
   \   00000024   0400C1E7           STRB     R0,[R1, +R4]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   5500000A           BEQ      ??CreateAnalogInputGauge_0
    227          	{
    228          		upperLimit = vehicleData.analogInput[input].highValuePoint;
   \   00000030   B07095E5           LDR      R7,[R5, #+176]
    229          		lowerLimit = vehicleData.analogInput[input].lowValuePoint;
   \   00000034   AC6095E5           LDR      R6,[R5, #+172]
    230          		
    231          		// handle inverse user values
    232          		if (upperLimit < lowerLimit) {
   \   00000038   0700A0E1           MOV      R0,R7
   \   0000003C   0610A0E1           MOV      R1,R6
   \   00000040   ........           BL       __aeabi_cfcmple
    233          			temp = upperLimit;
    234          			upperLimit = lowerLimit;
   \   00000044   0670A031           MOVCC    R7,R6
    235          			lowerLimit = temp;
   \   00000048   0060A031           MOVCC    R6,R0
    236          		}
    237          		
    238          		if ((upperLimit == 0.0) && (lowerLimit == 0.0))
   \   0000004C   0700A0E1           MOV      R0,R7
   \   00000050   0010A0E3           MOV      R1,#+0
   \   00000054   ........           BL       __aeabi_cfcmpeq
   \   00000058   0600A001           MOVEQ    R0,R6
   \   0000005C   ........           BLEQ     __aeabi_cfcmpeq
    239          		{
    240          			upperLimit = 100.0;
   \   00000060   4074A003           MOVEQ    R7,#+1073741824
   \   00000064   B2778703           ORREQ    R7,R7,#0x2C80000
    241          			lowerLimit = 0.0;
    242          		}
    243          		temp = (upperLimit - lowerLimit) * 0.1;
   \   00000068   0700A0E1           MOV      R0,R7
   \   0000006C   0610A0E1           MOV      R1,R6
   \   00000070   ........           BL       __aeabi_fsub
   \   00000074   ........           BL       __aeabi_f2d
   \   00000078   0020A0E1           MOV      R2,R0
   \   0000007C   0130A0E1           MOV      R3,R1
   \   00000080   ........           ADR      R0,??DataTable6_8
   \   00000084   030090E8           LDM      R0,{R0,R1}
   \   00000088   ........           BL       __aeabi_dmul
   \   0000008C   ........           BL       __aeabi_d2f
   \   00000090   0080A0E1           MOV      R8,R0
    244          
    245          		pAlarmL = pAlarmH = 0;
    246          		if (vehicleData.analogInput[input].lowerAlarmTriggerComparison != OFF)
   \   00000094   9400D5E5           LDRB     R0,[R5, #+148]
   \   00000098   0090A0E3           MOV      R9,#+0
   \   0000009C   00A0A0E3           MOV      R10,#+0
   \   000000A0   00B0A0E3           MOV      R11,#+0
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   1000000A           BEQ      ??CreateAnalogInputGauge_1
    247          			pAlarmL = new Alarm(true, (float)vehicleData.analogInput[input].lowerAlarmTriggerLevel, lowerLimit, GUI_RED, GUI_DARKRED, LOW, NULL, NULL);
   \   000000AC   2000A0E3           MOV      R0,#+32
   \   000000B0   ........           BL       _Znwj
   \   000000B4   000050E3           CMP      R0,#+0
   \   000000B8   0C00000A           BEQ      ??CreateAnalogInputGauge_1
   \   000000BC   0210A0E3           MOV      R1,#+2
   \   000000C0   08108DE5           STR      R1,[SP, #+8]
   \   000000C4   8010A0E3           MOV      R1,#+128
   \   000000C8   04108DE5           STR      R1,[SP, #+4]
   \   000000CC   FF10A0E3           MOV      R1,#+255
   \   000000D0   10908DE5           STR      R9,[SP, #+16]
   \   000000D4   0C908DE5           STR      R9,[SP, #+12]
   \   000000D8   00108DE5           STR      R1,[SP, #+0]
   \   000000DC   0630A0E1           MOV      R3,R6
   \   000000E0   982095E5           LDR      R2,[R5, #+152]
   \   000000E4   0110A0E3           MOV      R1,#+1
   \   000000E8   ........           BL       _ZN5AlarmC1Ebffmm9AlarmTypePS_S1_
   \   000000EC   00B0A0E1           MOV      R11,R0
    248          		if (vehicleData.analogInput[input].upperAlarmTriggerComparison != OFF)
   \                     ??CreateAnalogInputGauge_1:
   \   000000F0   9500D5E5           LDRB     R0,[R5, #+149]
   \   000000F4   000050E3           CMP      R0,#+0
   \   000000F8   1000000A           BEQ      ??CreateAnalogInputGauge_2
    249          			pAlarmH = new Alarm(true, (float)vehicleData.analogInput[input].upperAlarmTriggerLevel, upperLimit, GUI_RED, GUI_DARKRED, HIGH, NULL, NULL);
   \   000000FC   2000A0E3           MOV      R0,#+32
   \   00000100   ........           BL       _Znwj
   \   00000104   000050E3           CMP      R0,#+0
   \   00000108   0C00000A           BEQ      ??CreateAnalogInputGauge_2
   \   0000010C   0310A0E3           MOV      R1,#+3
   \   00000110   08108DE5           STR      R1,[SP, #+8]
   \   00000114   8010A0E3           MOV      R1,#+128
   \   00000118   04108DE5           STR      R1,[SP, #+4]
   \   0000011C   FF10A0E3           MOV      R1,#+255
   \   00000120   10908DE5           STR      R9,[SP, #+16]
   \   00000124   0C908DE5           STR      R9,[SP, #+12]
   \   00000128   00108DE5           STR      R1,[SP, #+0]
   \   0000012C   0730A0E1           MOV      R3,R7
   \   00000130   9C2095E5           LDR      R2,[R5, #+156]
   \   00000134   0110A0E3           MOV      R1,#+1
   \   00000138   ........           BL       _ZN5AlarmC1Ebffmm9AlarmTypePS_S1_
   \   0000013C   00A0A0E1           MOV      R10,R0
    250          
    251          		if ((pAlarmL == 0) && (pAlarmH == 0))
   \                     ??CreateAnalogInputGauge_2:
   \   00000140   00005BE3           CMP      R11,#+0
   \   00000144   0400001A           BNE      ??CreateAnalogInputGauge_3
   \   00000148   38009DE5           LDR      R0,[SP, #+56]
   \   0000014C   00005AE3           CMP      R10,#+0
    252          			*pAlarm = 0;
   \   00000150   00908005           STREQ    R9,[R0, #+0]
   \   00000154   00A08015           STRNE    R10,[R0, #+0]
   \   00000158   030000EA           B        ??CreateAnalogInputGauge_4
    253          		else if (pAlarmL)
    254          		{
    255          			*pAlarm = pAlarmL;
   \                     ??CreateAnalogInputGauge_3:
   \   0000015C   38009DE5           LDR      R0,[SP, #+56]
    256          			if (pAlarmH)
   \   00000160   00005AE3           CMP      R10,#+0
   \   00000164   00B080E5           STR      R11,[R0, #+0]
    257          				pAlarmL->Next = pAlarmH;
   \   00000168   18A08B15           STRNE    R10,[R11, #+24]
    258          		}
    259          		else *pAlarm = pAlarmH;
    260          
    261          		pName = vehicleData.analogInput[input].Name;
   \                     ??CreateAnalogInputGauge_4:
   \   0000016C   78A085E2           ADD      R10,R5,#+120
    262          		pUnits = vehicleData.analogInput[input].Units;
   \   00000170   895085E2           ADD      R5,R5,#+137
    263          		sprintf(inputNum, "A%d", input);
   \   00000174   34209DE5           LDR      R2,[SP, #+52]
   \   00000178   ........           ADR      R1,??DataTable6_9  ;; "A%d"
   \   0000017C   040084E2           ADD      R0,R4,#+4
   \   00000180   ........           BL       sprintf
   \   00000184   080000EA           B        ??CreateAnalogInputGauge_5
    264          	}
    265          	else
    266          	{
    267          		upperLimit = 100.0;
    268          		lowerLimit = 0.0;
    269          		temp = 10.0;
    270          		*pAlarm = 0;
   \                     ??CreateAnalogInputGauge_0:
   \   00000188   38009DE5           LDR      R0,[SP, #+56]
   \   0000018C   4074A0E3           MOV      R7,#+1073741824
   \   00000190   0060A0E3           MOV      R6,#+0
   \   00000194   B27787E3           ORR      R7,R7,#0x2C80000
   \   00000198   006080E5           STR      R6,[R0, #+0]
   \   0000019C   6A8747E2           SUB      R8,R7,#+27787264
    271          		pName = "Disabled";
   \   000001A0   ........           ADR      R10,`?<Constant "Disabled">`
    272          		pUnits = "";
   \   000001A4   ........           ADR      R5,??DataTable6_11  ;; ""
    273          		inputNum[0] = 0;
   \   000001A8   0460C4E5           STRB     R6,[R4, #+4]
    274          	}
    275          
    276          	if ((pGauge = new Gauge(hpos, 42, 115, lowerLimit, upperLimit,
    277          			pName, pUnits, inputNum, *pAlarm, (temp * 2), temp, 0, 0, true, hParent, pImage)) <= 0)
   \                     ??CreateAnalogInputGauge_5:
   \   000001AC   FC00A0E3           MOV      R0,#+252
   \   000001B0   ........           BL       _Znwj
   \   000001B4   0090B0E1           MOVS     R9,R0
   \   000001B8   1E00000A           BEQ      ??CreateAnalogInputGauge_6
   \   000001BC   68009DE5           LDR      R0,[SP, #+104]
   \   000001C0   1C808DE5           STR      R8,[SP, #+28]
   \   000001C4   30008DE5           STR      R0,[SP, #+48]
   \   000001C8   3C009DE5           LDR      R0,[SP, #+60]
   \   000001CC   0810A0E1           MOV      R1,R8
   \   000001D0   2C008DE5           STR      R0,[SP, #+44]
   \   000001D4   0100A0E3           MOV      R0,#+1
   \   000001D8   28008DE5           STR      R0,[SP, #+40]
   \   000001DC   0000A0E3           MOV      R0,#+0
   \   000001E0   24008DE5           STR      R0,[SP, #+36]
   \   000001E4   20008DE5           STR      R0,[SP, #+32]
   \   000001E8   4004A0E3           MOV      R0,#+1073741824
   \   000001EC   ........           BL       __aeabi_fmul
   \   000001F0   18008DE5           STR      R0,[SP, #+24]
   \   000001F4   38009DE5           LDR      R0,[SP, #+56]
   \   000001F8   7330A0E3           MOV      R3,#+115
   \   000001FC   000090E5           LDR      R0,[R0, #+0]
   \   00000200   0C508DE5           STR      R5,[SP, #+12]
   \   00000204   14008DE5           STR      R0,[SP, #+20]
   \   00000208   040084E2           ADD      R0,R4,#+4
   \   0000020C   10008DE5           STR      R0,[SP, #+16]
   \   00000210   08A08DE5           STR      R10,[SP, #+8]
   \   00000214   04708DE5           STR      R7,[SP, #+4]
   \   00000218   00608DE5           STR      R6,[SP, #+0]
   \   0000021C   2A20A0E3           MOV      R2,#+42
   \   00000220   40109DE5           LDR      R1,[SP, #+64]
   \   00000224   0900A0E1           MOV      R0,R9
   \   00000228   ........           BL       _ZN5GaugeC1EiiiffPcS0_S0_P5AlarmffiiclPK10GUI_BITMAP
   \   0000022C   0050B0E1           MOVS     R5,R0
   \   00000230   0200001A           BNE      ??CreateAnalogInputGauge_7
   \   00000234   000000EA           B        ??CreateAnalogInputGauge_8
   \                     ??CreateAnalogInputGauge_6:
   \   00000238   0050A0E3           MOV      R5,#+0
    278          		SystemError();
   \                     ??CreateAnalogInputGauge_8:
   \   0000023C   ........           BL       SystemError
    279          
    280          	if (!inputEnabled[input])
   \                     ??CreateAnalogInputGauge_7:
   \   00000240   34009DE5           LDR      R0,[SP, #+52]
   \   00000244   0400D0E7           LDRB     R0,[R0, +R4]
   \   00000248   000050E3           CMP      R0,#+0
   \   0000024C   0200001A           BNE      ??CreateAnalogInputGauge_9
    281          		pGauge->SetValue(0.0);
   \   00000250   0010A0E3           MOV      R1,#+0
   \   00000254   0500A0E1           MOV      R0,R5
   \   00000258   ........           BL       _ZN5Gauge8SetValueEf
    282          
    283          	return pGauge;
   \                     ??CreateAnalogInputGauge_9:
   \   0000025C   0500A0E1           MOV      R0,R5
   \   00000260   44D08DE2           ADD      SP,SP,#+68
   \   00000264   F08FBDE8           POP      {R4-R11,PC}      ;; return
    284          }

   \                                 In section .bss, align 4
   \                     inputEnabled:
   \   00000000                      DS8 4
   \   00000004                      DS8 8

   \                                 In section .bss, align 4
   \                     hDualGaugeScreen:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \                     pAnalog0Gauge:
   \   00000008                      DS8 4
   \                     pAnalog1Gauge:
   \   0000000C                      DS8 4
   \   00000010                      DS8 4
   \   00000014                      DS8 4
   \   00000018                      DS8 4
   \   0000001C                      DS8 1
    285          
    286          //
    287          // Returns index to the nth enabled input.
    288          // If n inputs not enabled return -1
    289          //

   \                                 In section .text, align 4, keep-with-next
    290          int GetInput(int n)
    291          {
    292          	int count, index;
    293          
    294          	for (count = index = 0; index < 4; index++)
   \                     _Z8GetInputi:
   \   00000000   0010A0E3           MOV      R1,#+0
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   ........           LDR      R3,??DataTable6_2
    295          	{
    296          		if (vehicleData.analogInput[index].enabled)
   \                     ??GetInput_0:
   \   0000000C   93C0D3E5           LDRB     R12,[R3, #+147]
   \   00000010   00005CE3           CMP      R12,#+0
    297          			count++;
   \   00000014   01208212           ADDNE    R2,R2,#+1
    298          		if (count == n)
   \   00000018   000052E1           CMP      R2,R0
   \   0000001C   0100001A           BNE      ??GetInput_1
    299          			return index;
   \   00000020   0100A0E1           MOV      R0,R1
   \   00000024   1EFF2FE1           BX       LR
    300          	}
   \                     ??GetInput_1:
   \   00000028   011081E2           ADD      R1,R1,#+1
   \   0000002C   403083E2           ADD      R3,R3,#+64
   \   00000030   040051E3           CMP      R1,#+4
   \   00000034   F4FFFFBA           BLT      ??GetInput_0
    301          	return -1;
   \   00000038   0000E0E3           MVN      R0,#+0
   \   0000003C   1EFF2FE1           BX       LR               ;; return
    302          }
    303          

   \                                 In section .text, align 4, keep-with-next
    304          GlobalDataIndexType GetInputID(int input)
    305          {
    306          	switch (input)
   \                     _Z10GetInputIDi:
   \   00000000   010050E3           CMP      R0,#+1
   \   00000004   0500000A           BEQ      ??GetInputID_0
   \   00000008   0200003A           BCC      ??GetInputID_1
   \   0000000C   030050E3           CMP      R0,#+3
   \   00000010   0600000A           BEQ      ??GetInputID_2
   \   00000014   0300003A           BCC      ??GetInputID_3
    307          	{
    308          	default:
    309          	case 0:	return ANALOG_INPUT_0;
   \                     ??GetInputID_1:
   \   00000018   3600A0E3           MOV      R0,#+54
   \   0000001C   1EFF2FE1           BX       LR
    310          	case 1:	return ANALOG_INPUT_1;
   \                     ??GetInputID_0:
   \   00000020   3700A0E3           MOV      R0,#+55
   \   00000024   1EFF2FE1           BX       LR
    311          	case 2:	return ANALOG_INPUT_2;
   \                     ??GetInputID_3:
   \   00000028   3800A0E3           MOV      R0,#+56
   \   0000002C   1EFF2FE1           BX       LR
    312          	case 3:	return ANALOG_INPUT_3;
   \                     ??GetInputID_2:
   \   00000030   3900A0E3           MOV      R0,#+57
   \   00000034   1EFF2FE1           BX       LR               ;; return
    313          	}
    314          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     lockupSemaphore

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   ........           DC32     bmDualGaugeBackground

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   ........           DC32     vehicleData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   ........           DC32     bmthreewayarrow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   ........           DC32     hDualGaugeScreen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   ........           DC32     _cbDualGaugeCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   ........           DC32     bmLeftGauge

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   ........           DC32     inputEnabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   9A9999999999       DC32     0x9999999A,0x3FB99999
   \              B93F        

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   41256400           DC8      "A%d"

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   ........           DC32     bmRightGauge

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   00000000           DC8      "",0x0,0x0,0x0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "A%d">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   41256400           DC8 65, 37, 100, 0

   \                                 In section .rodata, align 1, keep-with-next
   \                     `?<Constant "">`:
   \   00000000                      ; Initializer data, 1 bytes
   \   00000000   00                 DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Disabled">`:
   \   00000000                      ; Initializer data, 12 bytes
   \   00000000   44697361626C       DC8 68, 105, 115, 97, 98, 108, 101, 100, 0, 0
   \              65640000    
   \   0000000A   0000               DC8 0, 0
    315          
    316          /*************************** End of file ****************************/
    317          

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     CreateAnalogInputGauge     104
     Display_DualGaugeScreen     32
     GetInput(int)                0
     GetInputID(int)              0
     _cbDualGaugeCallback        24


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     _cbDualGaugeCallback     724
     Display_DualGaugeScreen  312
     CreateAnalogInputGauge   616
     inputEnabled              12
     inputNum
     hDualGaugeScreen          29
     hScreenTimer
     pAnalog0Gauge
     pAnalog1Gauge
     pAnalog0Red
     pAnalog1Red
     memDualGaugeScreen
     firsttimethrough
     GetInput(int)             64
     GetInputID(int)           56
     ??DataTable6               4
     ??DataTable6_1             4
     ??DataTable6_2             4
     ??DataTable6_3             4
     ??DataTable6_4             4
     ??DataTable6_5             4
     ??DataTable6_6             4
     ??DataTable6_7             4
     ??DataTable6_8             8
     ??DataTable6_9             4
     ??DataTable6_10            4
     ??DataTable6_11            4
     ?<Constant "A%d">          4
     ?<Constant "">             1
     ?<Constant "Disabled">    12

 
    41 bytes in section .bss
     5 bytes in section .rodata
 1 836 bytes in section .text
 
 1 836 bytes of CODE  memory
     5 bytes of CONST memory
    41 bytes of DATA  memory

Errors: none
Warnings: none
