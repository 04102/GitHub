###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:11:22 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\Util\JLINKDCC_Process.c                 #
#    Command line =  C:\DUII\TargetHW\Util\JLINKDCC_Process.c -D DEBUG=1 -D   #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\JLINKDCC_Process.lst       #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\JLINKDCC_Process.o          #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\Util\JLINKDCC_Process.c
      1          /*********************************************************************
      2          *              SEGGER MICROCONTROLLER SYSTEME GmbH                   *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *           (c) 2006 -2008   SEGGER Microcontroller Systeme GmbH     *
      7          *                                                                    *
      8          *      Internet: www.segger.com   Support: support@segger.com        *
      9          *                                                                    *
     10          **********************************************************************
     11          ----------------------------------------------------------------------
     12          File    : DCC_Process.c
     13          Purpose : Data handler for ARM J-Link type communication via DCC (IAR version, using intrinsics)
     14          Changes : 08-10-08
     15                    Support for "channels"added, where
     16                    channel 0 is reserved for terminal
     17                    channel 1 is reserved for OS communication such as embOSView
     18          
     19          Notes   : (1) How to use
     20                        In order to use the DCC communication to read / write memory, the
     21                          following needs to be done:
     22                        * Add this file to the project / make-file
     23                        * Make sure this data handler is called regularly
     24                        * Add the JLINKDCC data abort handler (optional)
     25                          For details, refer to the documentation or see file JLINKDCC_HandleDataAbort.s79.
     26                    (2) Compatibility
     27                        The J-Link ARM DCC handler is compatible to the DCC communication
     28                        protocol used by IAR in the embedded workbench for ARM and allows
     29                        using the live data window in C-Spy
     30          
     31          Protocol
     32            Following response packets from target will be possible:
     33            00 00 00 XX - reading a byte XX
     34            00 00 XX XX - reading a half word XXXX
     35            XX XX XX XX - reading a word, except words starting with 93zX XXXX (10010011-1xxxxxxx-xxxxxxx-xxxxxxx)
     36          
     37            93 8z 00 XX - terminal I/O one byte XX to channel z=0-15
     38            93 9z 00 XX - terminal I/O one byte XX to channel z=16-31
     39            93 Az XX XX - terminal I/O two bytes XX XX to channel z=0-15
     40            93 Bz XX XX - terminal I/O two bytes XX XX to channel z=16-31
     41          
     42            93 C0 XX XX - escape sequence for words starting with 93XX, the lower 16-bit part is in XX XX
     43            93 C1 XX XX - escape sequence for words starting with 93XX, the upper 16-bit part is in XX XX
     44            93 C2 XX XX - data abort for reading
     45            91 CA XX XX - signature (same as before)
     46          
     47            There is a new capability flag. C-SPY will use the new protocol when this is set.
     48            #define DCC_CAP_TERM_OUT   0x80
     49          
     50          Sequence for U8 write:
     51            H->T    Addr & 0xFFFFFFFE
     52            H->T    ((Addr & 1) << 31) | (Data << 2) | 0x40000001
     53          
     54          Sequence for U16 write:
     55            H->T    Addr & 0xFFFFFFFE
     56            H->T    ((Addr & 1) << 31) | (Data << 2) | 0x20000001
     57          
     58          Sequence for U32 write:
     59            H->T    Addr & 0xFFFFFFFE
     60            H->T    (Data & 0xFFFF) << 2
     61            H->T    ((Addr & 1) << 31) | ((Data >> 14) & 0xFFFF) | 0x10000001
     62          
     63          Sequence for U8 Read:
     64            H->T    Addr & 0xFFFFFFFE
     65            H->T    ((Addr & 1) << 31) | (NumItems << 2) | 0x04000001
     66            if (Aborted) {
     67              T->H    0x93c20000
     68            } else {
     69              T->H    Data
     70            }
     71          
     72          Sequence for U16 Read:
     73            H->T    Addr & 0xFFFFFFFE
     74            H->T    ((Addr & 1) << 31) | (NumItems << 2) | 0x02000001
     75            if (Aborted) {
     76              T->H    0x93c20000
     77            } else {
     78              T->H    Data
     79            }
     80          
     81          Sequence for U32 Read:
     82            H->T    Addr & 0xFFFFFFFE
     83            H->T    ((Addr & 1) << 31) | (NumItems << 2) | 0x01000001
     84            if (Aborted) {
     85              T->H    0x93c20000
     86            } else if ((Data >> 24) != 0x93) {
     87              T->H    Data
     88            } else {
     89              T->H    0x93c0.0000 | (Data & 0xFFFF)
     90              T->H    0x93c1.0000 | (Data >> 16)
     91            }
     92          
     93          Terminal IN:  (target receives data)
     94          H->T   0x93000000 + (Channel << 19) + (Data8 << 1) + DCC_OP_COMMAND
     95          
     96          Terminal OUT: (target sends data)
     97          T->H   0x93800000 + (Channel << 16) + (Data8)
     98          
     99          ---------------------------END-OF-HEADER------------------------------
    100          */
    101          
    102          #include "JLINKDCC.h"
    103          
    104          #ifdef __ICCARM__
    105            /* With IAR workbench we use intrinsics for CP14 communication */
    106            #include <intrinsics.h>
    107          #else
    108            /* We use external functions from assembly module JLINKDCC_Process_ASM.s */
    109            extern unsigned long CP14_ReadDCCStat(void);
    110            extern unsigned long CP14_ReadDCC(void);
    111            extern void CP14_WriteDCC(unsigned long Data);
    112          #endif
    113          
    114          /*********************************************************************
    115          *
    116          *       Defines, configurable
    117          *
    118          **********************************************************************
    119          */
    120          
    121          #define BUFFER_SIZE         1024          // Used for channel 0 (terminal out buffer)
    122          #define NUM_CHANNELS           2
    123          
    124          /*********************************************************************
    125          *
    126          *       Defines, non- configurable
    127          *
    128          **********************************************************************
    129          */
    130          
    131          #define U8  unsigned char
    132          #define U16 unsigned short
    133          #define U32 unsigned int
    134          
    135          #define DCC_OP_READ_U32   0x01000000
    136          #define DCC_OP_READ_U16   0x02000000
    137          #define DCC_OP_READ_U8    0x04000000
    138          #define DCC_OP_GET_CAPS   0x08000000
    139          #define DCC_OP_WRITE_U32  0x10000000
    140          #define DCC_OP_WRITE_U16  0x20000000
    141          #define DCC_OP_WRITE_U8   0x40000000
    142          #define DCC_OP_ODD_ADDR   0x80000000
    143          #define DCC_OP_COMMAND    0x00000001
    144          
    145          #define DCC_SIGNATURE     0x91CA0000
    146          #define DCC_CONFIG        0xFF       // All features are supported
    147          
    148          #define DCC_CHANNEL_TERMINAL  0
    149          #define DCC_CHANNEL_OS        1
    150          
    151          /*********************************************************************
    152          *
    153          *       Global data
    154          *
    155          **********************************************************************
    156          */
    157          

   \                                 In section .bss, align 1
    158          U8 JLINKDCC_IsInHandler;
   \                     JLINKDCC_IsInHandler:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    159          U8 JLINKDCC_AbortOccurred;
    160          
    161          /*********************************************************************
    162          *
    163          *       Static data
    164          *
    165          **********************************************************************
    166          */
    167          
    168          void (* _pfOnRx[2]) (unsigned Channel, U8 Data);
    169          void (* _pfOnTx[2]) (unsigned Channel);
    170          
    171          
    172          static U16 _NumReadItems;
   \                     _NumReadItems:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \                     _pfOnRx:
   \   00000004                      DS8 8
   \                     _pfOnTx:
   \   0000000C                      DS8 8
   \   00000014                      DS8 4
   \   00000018                      DS8 4
   \   0000001C                      DS8 4
   \   00000020                      DS8 4
   \   00000024                      DS8 4
   \   00000028                      DS8 4
   \   0000002C                      DS8 4
   \                     JLINKDCC_AbortOccurred:
   \   00000030                      DS8 1
   \   00000031                      DS8 1
   \   00000032                      DS8 1
   \   00000033                      DS8 1
   \   00000034                      DS8 1024
    173          static U32 _Command;
    174          static U32 _Addr;
    175          
    176          static char _acBuffer[BUFFER_SIZE];
    177          static int  _RdPos;
    178          static int  _WrPos;
    179          
    180          static int _ActiveChannel    = 0;
    181          
    182          static char _WritePendingNB  = 0;
    183          static U32  _PendingPacketNB = 0;
    184          
    185          static char _WritePending;
    186          static U32  _Data;
    187          
    188          /*********************************************************************
    189          *
    190          *       Static code
    191          *
    192          **********************************************************************
    193          */
    194          
    195          #ifdef __ICCARM__
    196          
    197          /****** Use intrinsics for CP14 communication ***********************/
    198          
    199          /*********************************************************************
    200          *
    201          *       _ReadDCCStat
    202          */
    203          static __interwork __arm int _ReadDCCStat(void) {
    204            return __MRC( 14, 0, 0, 0, 0 );       // __asm("mrc P14,0,R0,C0,C0,0");
    205          }
    206          
    207          /*********************************************************************
    208          *
    209          *       _ReadDCC
    210          */
    211          static __interwork __arm U32 _ReadDCC(void) {
    212            return __MRC( 14, 0, 1, 0, 0 );       // __asm("mrc P14,0,R0,C1,C0,0");
    213          }
    214          
    215          /*********************************************************************
    216          *
    217          *       _WriteDCC
    218          */
    219          static __interwork __arm void _WriteDCC(U32 Data) {
    220            __MCR( 14, 0, Data, 1, 0, 0 );        // __asm("mcr P14,0,R0,C1,C0,0");
    221          }
    222          
    223          #else
    224          
    225          /****** Map externel CP14 communication routines ********************/
    226          #define _ReadDCCStat     CP14_ReadDCCStat
    227          #define _ReadDCC         CP14_ReadDCC
    228          #define _WriteDCC(Data)  CP14_WriteDCC(Data)
    229          
    230          #endif /* __ICCARM__ */
    231          
    232          /*********************************************************************
    233          *
    234          *       _HandleRead
    235          *
    236          *  Function description
    237          *    Performs Command / data read from host
    238          */

   \                                 In section .text, align 4, keep-with-next
    239          static void _HandleRead(void) {
    240            U32 Data;
    241          
    242            if ((_ReadDCCStat() & 1) == 0) {       // Data or command received ?
   \                     _HandleRead:
   \   00000000   100E10EE           MRC      p14,0,R0,c0,c0,0
   \   00000004   010010E3           TST      R0,#0x1
   \   00000008   0000001A           BNE      ??_HandleRead_0
    243              return;      // Nothing received
    244            }
    245          
    246            Data = _ReadDCC();
   \   0000000C   1EFF2FE1           BX       LR
   \                     ??_HandleRead_0:
   \   00000010   00402DE9           PUSH     {LR}
   \   00000014   100E11EE           MRC      p14,0,R0,c1,c0,0
   \   00000018   0020A0E1           MOV      R2,R0
    247            //
    248            // If item received does not have the command-flag set, it is the new addr.
    249            //
    250            if ((Data & DCC_OP_COMMAND) == 0) {
   \   0000001C   ........           LDR      R1,??DataTable8
   \   00000020   010012E3           TST      R2,#0x1
   \   00000024   04D04DE2           SUB      SP,SP,#+4
    251              _Addr = Data;
   \   00000028   18208105           STREQ    R2,[R1, #+24]
    252              return;
   \   0000002C   2F00000A           BEQ      ??_HandleRead_1
    253            }
    254            //
    255            // If item received is a terminal out command,
    256            //
    257            if ((Data & 0xFF000000) == 0x93000000) {
   \   00000030   FF3402E2           AND      R3,R2,#0xFF000000
   \   00000034   930453E3           CMP      R3,#-1828716544
   \   00000038   0900001A           BNE      ??_HandleRead_2
    258              unsigned Channel;
    259              Channel = (Data >> 19) & 0x1F;
   \   0000003C   1F00A0E3           MOV      R0,#+31
   \   00000040   A20900E0           AND      R0,R0,R2, LSR #+19
   \   00000044   001181E0           ADD      R1,R1,R0, LSL #+2
   \   00000048   043091E5           LDR      R3,[R1, #+4]
   \   0000004C   000053E3           CMP      R3,#+0
   \   00000050   2600000A           BEQ      ??_HandleRead_1
    260              if (_pfOnRx[Channel]) {
    261                _pfOnRx[Channel](Channel, (Data >> 1) & 0xFF);
   \   00000054   A210A0E1           LSR      R1,R2,#+1
   \   00000058   FF1001E2           AND      R1,R1,#0xFF
   \   0000005C   33FF2FE1           BLX      R3
   \   00000060   220000EA           B        ??_HandleRead_1
    262              }
    263              return;
    264            }
    265            //
    266            // We received a new command.
    267            //
    268            _Command = Data;
   \                     ??_HandleRead_2:
   \   00000064   142081E5           STR      R2,[R1, #+20]
    269            if (_Command & DCC_OP_ODD_ADDR) {
   \   00000068   800410E3           TST      R0,#0x80000000
    270              _Addr |= 1;
   \   0000006C   18209115           LDRNE    R2,[R1, #+24]
   \   00000070   01208213           ORRNE    R2,R2,#0x1
   \   00000074   18208115           STRNE    R2,[R1, #+24]
    271            }
    272            if (_Command & (DCC_OP_READ_U32 | DCC_OP_READ_U16 | DCC_OP_READ_U8 | DCC_OP_GET_CAPS)) {
   \   00000078   F00610E3           TST      R0,#0xF000000
    273              _NumReadItems = (_Command >> 2) & 0xffff;
   \   0000007C   2001A011           LSRNE    R0,R0,#+2
   \   00000080   B000C111           STRHNE   R0,[R1, #+0]
   \   00000084   1900001A           BNE      ??_HandleRead_1
    274            } else {
    275              // Clear before write
    276              JLINKDCC_AbortOccurred = 0;
   \   00000088   0020A0E3           MOV      R2,#+0
   \   0000008C   3020C1E5           STRB     R2,[R1, #+48]
    277          
    278              if (_Command & DCC_OP_WRITE_U32) {
   \   00000090   400510E3           TST      R0,#0x10000000
   \   00000094   0400000A           BEQ      ??_HandleRead_3
    279                _Data |= (_Command << 14) & 0xffff0000;
   \   00000098   2C2091E5           LDR      R2,[R1, #+44]
   \   0000009C   0037A0E1           LSL      R3,R0,#+14
   \   000000A0   2338A0E1           LSR      R3,R3,#+16
   \   000000A4   032882E1           ORR      R2,R2,R3, LSL #+16
   \   000000A8   010000EA           B        ??_HandleRead_4
    280              } else {
    281                _Data = (_Command >> 2) & 0xffff;
   \                     ??_HandleRead_3:
   \   000000AC   0027A0E1           LSL      R2,R0,#+14
   \   000000B0   2228A0E1           LSR      R2,R2,#+16
   \                     ??_HandleRead_4:
   \   000000B4   2C2081E5           STR      R2,[R1, #+44]
    282              }
    283              if (_Command & DCC_OP_WRITE_U8) {
   \   000000B8   400410E3           TST      R0,#0x40000000
   \   000000BC   182091E5           LDR      R2,[R1, #+24]
    284                *(U8*)_Addr = _Data;
   \   000000C0   2C309115           LDRNE    R3,[R1, #+44]
   \   000000C4   0130C214           STRBNE   R3,[R2], #+1
    285                _Addr += 1;
    286              }
    287              if (_Command & DCC_OP_WRITE_U16) {
   \   000000C8   800510E3           TST      R0,#0x20000000
    288                *(U16*)_Addr = _Data;
   \   000000CC   2C309115           LDRNE    R3,[R1, #+44]
   \   000000D0   B230C210           STRHNE   R3,[R2], #+2
    289                _Addr += 2;
   \   000000D4   182081E5           STR      R2,[R1, #+24]
    290              }
    291              if (_Command & DCC_OP_WRITE_U32) {
   \   000000D8   400510E3           TST      R0,#0x10000000
   \   000000DC   0300000A           BEQ      ??_HandleRead_1
    292                *(U32*)_Addr =_Data;
   \   000000E0   0200A0E1           MOV      R0,R2
   \   000000E4   2C2091E5           LDR      R2,[R1, #+44]
   \   000000E8   042080E4           STR      R2,[R0], #+4
    293                _Addr += 4;
   \   000000EC   180081E5           STR      R0,[R1, #+24]
   \                     ??_HandleRead_1:
   \   000000F0   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000F4   0080BDE8           POP      {PC}             ;; return
    294              }
    295            }
    296          }
    297          
    298          /*********************************************************************
    299          *
    300          *       _HandleWrite
    301          *
    302          *  Function description
    303          *    Sends data back to host if there is space in DCC buffer and data to be send.
    304          */

   \                                 In section .text, align 4, keep-with-next
    305          static void _HandleWrite(void) {
    306            U32 Data;
    307            int DCCBusy;
    308            int NumBytes;
    309          
    310            Data = 0;
    311            DCCBusy = _ReadDCCStat() & 2;
    312            if (DCCBusy) {                  // Can we send data ?
   \                     _HandleWrite:
   \   00000000   100E10EE           MRC      p14,0,R0,c0,c0,0
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   0030A0E3           MOV      R3,#+0
   \   0000000C   020010E3           TST      R0,#0x2
   \   00000010   0000000A           BEQ      ??_HandleWrite_0
    313              return;                       // If not, we are done.
    314            }
    315          
    316            if (_ActiveChannel) {
   \   00000014   1EFF2FE1           BX       LR
   \                     ??_HandleWrite_0:
   \   00000018   30402DE9           PUSH     {R4,R5,LR}
   \   0000001C   ........           LDR      R2,??DataTable8
   \   00000020   04D04DE2           SUB      SP,SP,#+4
   \   00000024   240092E5           LDR      R0,[R2, #+36]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0B00000A           BEQ      ??_HandleWrite_1
    317              U32 Channel;
    318          
    319              Channel = _ActiveChannel;
    320              _ActiveChannel = 0;
    321              if (_WritePendingNB) {
   \   00000030   3130D2E5           LDRB     R3,[R2, #+49]
   \   00000034   241082E5           STR      R1,[R2, #+36]
   \   00000038   000053E3           CMP      R3,#+0
    322                _WriteDCC(_PendingPacketNB);
   \   0000003C   28309215           LDRNE    R3,[R2, #+40]
   \   00000040   103E011E           MCRNE    p14,0,R3,c1,c0,0
    323                _WritePendingNB = 0;
   \   00000044   3110C215           STRBNE   R1,[R2, #+49]
   \   00000048   001182E0           ADD      R1,R2,R0, LSL #+2
   \   0000004C   0C1091E5           LDR      R1,[R1, #+12]
   \   00000050   000051E3           CMP      R1,#+0
   \   00000054   5600000A           BEQ      ??_HandleWrite_2
    324              }
    325              if (_pfOnTx[Channel]) {
    326                _pfOnTx[Channel](Channel);
   \   00000058   31FF2FE1           BLX      R1
   \   0000005C   540000EA           B        ??_HandleWrite_2
    327              }
    328              return;
    329            }
    330          
    331            //
    332            // Check if a data item is pending
    333            //
    334            if (_WritePending) {
   \                     ??_HandleWrite_1:
   \   00000060   3200D2E5           LDRB     R0,[R2, #+50]
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   0300000A           BEQ      ??_HandleWrite_3
    335              _WriteDCC(_Data);
   \   0000006C   2C0092E5           LDR      R0,[R2, #+44]
   \   00000070   100E01EE           MCR      p14,0,R0,c1,c0,0
    336              _WritePending = 0;
   \   00000074   3210C2E5           STRB     R1,[R2, #+50]
    337              return;
   \   00000078   4D0000EA           B        ??_HandleWrite_2
    338            }
    339            //
    340            // Check if a read command is pending
    341            //
    342            if (_NumReadItems) {
   \                     ??_HandleWrite_3:
   \   0000007C   B000D2E1           LDRH     R0,[R2, #+0]
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   2900000A           BEQ      ??_HandleWrite_4
    343              if (_Command & DCC_OP_GET_CAPS) {
   \   00000088   140092E5           LDR      R0,[R2, #+20]
   \   0000008C   800610E3           TST      R0,#0x8000000
   \   00000090   0400000A           BEQ      ??_HandleWrite_5
    344                Data = (DCC_CONFIG | DCC_SIGNATURE);
    345                Data |= (JLINKDCC_AbortOccurred << 8);  // write abort status
   \   00000094   3000D2E5           LDRB     R0,[R2, #+48]
   \   00000098   ........           LDR      R3,??DataTable8_1  ;; 0x91ca00ff
    346                JLINKDCC_AbortOccurred = 0;
   \   0000009C   3010C2E5           STRB     R1,[R2, #+48]
   \   000000A0   003483E1           ORR      R3,R3,R0, LSL #+8
   \   000000A4   1C0000EA           B        ??_HandleWrite_6
    347              } else {
    348          
    349                // Clear before next read
    350                JLINKDCC_AbortOccurred = 0;
   \                     ??_HandleWrite_5:
   \   000000A8   3010C2E5           STRB     R1,[R2, #+48]
    351          
    352                if (_Command & DCC_OP_READ_U8) {
   \   000000AC   400610E3           TST      R0,#0x4000000
   \   000000B0   0300000A           BEQ      ??_HandleWrite_7
    353                  Data = *(U8*)_Addr;
   \   000000B4   180092E5           LDR      R0,[R2, #+24]
   \   000000B8   0130D0E4           LDRB     R3,[R0], #+1
    354                  _Addr += 1;
   \                     ??_HandleWrite_8:
   \   000000BC   180082E5           STR      R0,[R2, #+24]
   \   000000C0   150000EA           B        ??_HandleWrite_6
    355                } else if (_Command & DCC_OP_READ_U16) {
   \                     ??_HandleWrite_7:
   \   000000C4   800710E3           TST      R0,#0x2000000
    356                  Data = *(U16*)_Addr;
   \   000000C8   18009215           LDRNE    R0,[R2, #+24]
   \   000000CC   B230D010           LDRHNE   R3,[R0], #+2
    357                  _Addr += 2;
   \   000000D0   F9FFFF1A           BNE      ??_HandleWrite_8
    358                } else if (_Command & DCC_OP_READ_U32) {
   \   000000D4   400710E3           TST      R0,#0x1000000
   \   000000D8   0F00000A           BEQ      ??_HandleWrite_6
    359                  Data = *(U32*)_Addr;
   \   000000DC   180092E5           LDR      R0,[R2, #+24]
    360                  _Addr += 4;
    361                  if ((Data & 0xFF800000) == 0x93800000) {    // Do we need to use the escape sequence and split it up into 2 transfers ?
   \   000000E0   8014A0E3           MOV      R1,#-2147483648
   \   000000E4   043090E4           LDR      R3,[R0], #+4
   \   000000E8   180082E5           STR      R0,[R2, #+24]
   \   000000EC   A30BA0E1           LSR      R0,R3,#+23
   \   000000F0   4E1581E3           ORR      R1,R1,#0x13800000
   \   000000F4   800B51E1           CMP      R1,R0, LSL #+23
   \   000000F8   0700001A           BNE      ??_HandleWrite_6
    362                    _Data = 0x93c10000 | (Data >> 16);
   \   000000FC   410881E3           ORR      R0,R1,#0x410000
   \   00000100   230880E1           ORR      R0,R0,R3, LSR #+16
   \   00000104   2C0082E5           STR      R0,[R2, #+44]
    363                    Data  = 0x93c00000 | (Data & 0xFFFF);
   \   00000108   0308A0E1           LSL      R0,R3,#+16
   \   0000010C   401881E3           ORR      R1,R1,#0x400000
   \   00000110   203881E1           ORR      R3,R1,R0, LSR #+16
    364                    _WritePending = 1;
   \   00000114   0100A0E3           MOV      R0,#+1
   \   00000118   3200C2E5           STRB     R0,[R2, #+50]
    365                  }
    366                }
    367                if (JLINKDCC_AbortOccurred) {
    368                  Data = 0x93c20000;          // read abort status
    369                  _WritePending = 0;
    370                  JLINKDCC_AbortOccurred = 0; // clear it
    371                }
    372              }
    373          
    374              _WriteDCC(Data);
   \                     ??_HandleWrite_6:
   \   0000011C   103E01EE           MCR      p14,0,R3,c1,c0,0
    375              _NumReadItems--;
   \   00000120   B000D2E1           LDRH     R0,[R2, #+0]
   \   00000124   010040E2           SUB      R0,R0,#+1
   \   00000128   B000C2E1           STRH     R0,[R2, #+0]
    376              return;
   \   0000012C   200000EA           B        ??_HandleWrite_2
    377            }
    378            //
    379            // Handle terminal out. Up to 2 bytes in one 32-bit unit
    380            //
    381            NumBytes = _WrPos - _RdPos;
   \                     ??_HandleWrite_4:
   \   00000130   200092E5           LDR      R0,[R2, #+32]
   \   00000134   1C3092E5           LDR      R3,[R2, #+28]
   \   00000138   030050E0           SUBS     R0,R0,R3
    382            if (NumBytes < 0) {
    383              NumBytes += sizeof(_acBuffer);
   \   0000013C   400E8042           ADDMI    R0,R0,#+1024
    384            }
    385            if (NumBytes) {
   \   00000140   000050E3           CMP      R0,#+0
   \   00000144   1A00000A           BEQ      ??_HandleWrite_2
    386              int i;
    387              if (NumBytes > 2) {
   \   00000148   030050E3           CMP      R0,#+3
    388                NumBytes = 2;
   \   0000014C   0200A0A3           MOVGE    R0,#+2
   \   00000150   010000AA           BGE      ??_HandleWrite_9
    389              }
    390              if (NumBytes == 2) {
   \   00000154   020050E3           CMP      R0,#+2
   \   00000158   0300001A           BNE      ??_HandleWrite_10
    391                Data = 0x93A00000;
   \                     ??_HandleWrite_9:
   \   0000015C   9034A0E3           MOV      R3,#-1879048192
   \   00000160   E83783E3           ORR      R3,R3,#0x3A00000
   \   00000164   00C0A0E3           MOV      R12,#+0
   \   00000168   040000EA           B        ??_HandleWrite_11
    392              } else {
    393                Data = 0x93800000;
   \                     ??_HandleWrite_10:
   \   0000016C   8034A0E3           MOV      R3,#-2147483648
   \   00000170   4E3583E3           ORR      R3,R3,#0x13800000
    394              }
    395              for (i = 0; i < NumBytes; i++) {
   \   00000174   00C0A0E3           MOV      R12,#+0
   \   00000178   010050E3           CMP      R0,#+1
   \   0000017C   0B0000BA           BLT      ??_HandleWrite_12
    396                Data |= _acBuffer[_RdPos] << (8*i);
   \                     ??_HandleWrite_11:
   \   00000180   1CE092E5           LDR      LR,[R2, #+28]
   \   00000184   8C51A0E1           LSL      R5,R12,#+3
   \   00000188   02408EE0           ADD      R4,LR,R2
   \   0000018C   3440D4E5           LDRB     R4,[R4, #+52]
    397                _RdPos++;
   \   00000190   01E08EE2           ADD      LR,LR,#+1
   \   00000194   1CE082E5           STR      LR,[R2, #+28]
    398                if (_RdPos == sizeof(_acBuffer)) {
   \   00000198   400E5EE3           CMP      LR,#+1024
   \   0000019C   143583E1           ORR      R3,R3,R4, LSL R5
    399                  _RdPos = 0;
   \   000001A0   1C108205           STREQ    R1,[R2, #+28]
    400                }
    401              }
   \   000001A4   01C08CE2           ADD      R12,R12,#+1
   \   000001A8   00005CE1           CMP      R12,R0
   \   000001AC   F3FFFFBA           BLT      ??_HandleWrite_11
    402              _WriteDCC(Data);
   \                     ??_HandleWrite_12:
   \   000001B0   103E01EE           MCR      p14,0,R3,c1,c0,0
    403            }
   \                     ??_HandleWrite_2:
   \   000001B4   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000001B8   3080BDE8           POP      {R4,R5,PC}       ;; return
    404          }
    405          
    406          
    407          /*********************************************************************
    408          *
    409          *       Public code
    410          *
    411          **********************************************************************
    412          */
    413          
    414          /*********************************************************************
    415          *
    416          *       JLINKDCC_Process
    417          *
    418          *  Function description
    419          *    This function should be called more or less regularily to allow
    420          *    memory reads while the application progam is running.
    421          *    The more often it is called, the higher the transfer speed.
    422          */

   \                                 In section .text, align 4, keep-with-next
    423          void JLINKDCC_Process(void) {
   \                     JLINKDCC_Process:
   \   00000000   10402DE9           PUSH     {R4,LR}
    424            //
    425            // Avoid problems if this code is called from multiple threads or interrupts
    426            //
    427            if (JLINKDCC_IsInHandler) {
   \   00000004   ........           LDR      R4,??DataTable8_2
   \   00000008   0000D4E5           LDRB     R0,[R4, #+0]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0500001A           BNE      ??JLINKDCC_Process_0
    428              return;
    429            }
    430            JLINKDCC_IsInHandler = 1;
   \   00000014   0100A0E3           MOV      R0,#+1
   \   00000018   0000C4E5           STRB     R0,[R4, #+0]
    431            _HandleRead();
   \   0000001C   ........           BL       _HandleRead
    432            _HandleWrite();
   \   00000020   ........           BL       _HandleWrite
    433             JLINKDCC_IsInHandler = 0;
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   0000C4E5           STRB     R0,[R4, #+0]
    434          }
   \                     ??JLINKDCC_Process_0:
   \   0000002C   1080BDE8           POP      {R4,PC}          ;; return
    435          
    436          /*********************************************************************
    437          *
    438          *       JLINKDCC_SendChar
    439          *
    440          *  Function description
    441          *   Sends a single char to terminal out.
    442          */

   \                                 In section .text, align 4, keep-with-next
    443          void JLINKDCC_SendChar(char c) {
    444            int Pos;
    445          
    446            Pos = _WrPos + 1;
   \                     JLINKDCC_SendChar:
   \   00000000   ........           LDR      R1,??DataTable8
   \   00000004   202091E5           LDR      R2,[R1, #+32]
    447            if (Pos == sizeof(_acBuffer)) {
    448              Pos = 0;
    449            }
    450            if (Pos == _RdPos) {
   \   00000008   1CC091E5           LDR      R12,[R1, #+28]
   \   0000000C   013082E2           ADD      R3,R2,#+1
   \   00000010   400E53E3           CMP      R3,#+1024
   \   00000014   0030A003           MOVEQ    R3,#+0
   \   00000018   0C0053E1           CMP      R3,R12
    451              return;
    452            }
    453            _acBuffer[_WrPos] = c;
   \   0000001C   01208210           ADDNE    R2,R2,R1
   \   00000020   3400C215           STRBNE   R0,[R2, #+52]
    454            _WrPos = Pos;
   \   00000024   20308115           STRNE    R3,[R1, #+32]
    455          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
    456          
    457          /*********************************************************************
    458          *
    459          *       JLINKDCC_SendString
    460          *
    461          *  Function description
    462          *   Sends a NUL- terminated string to terminal out.
    463          */

   \                                 In section .text, align 4, keep-with-next
    464          void JLINKDCC_SendString(const char * s) {
   \                     JLINKDCC_SendString:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   ........           LDR      R1,??DataTable8
   \   00000008   1C2091E5           LDR      R2,[R1, #+28]
   \   0000000C   070000EA           B        ??JLINKDCC_SendString_0
    465            char c;
    466            while (1) {
    467              c = *s++;
    468              if (c == 0) {
    469                break;
    470              }
    471              JLINKDCC_SendChar(c);
   \                     ??JLINKDCC_SendString_1:
   \   00000010   203091E5           LDR      R3,[R1, #+32]
   \   00000014   01C083E2           ADD      R12,R3,#+1
   \   00000018   400E5CE3           CMP      R12,#+1024
   \   0000001C   00C0A003           MOVEQ    R12,#+0
   \   00000020   02005CE1           CMP      R12,R2
   \   00000024   01308310           ADDNE    R3,R3,R1
   \   00000028   34E0C315           STRBNE   LR,[R3, #+52]
   \   0000002C   20C08115           STRNE    R12,[R1, #+32]
   \                     ??JLINKDCC_SendString_0:
   \   00000030   01E0D0E4           LDRB     LR,[R0], #+1
   \   00000034   00005EE3           CMP      LR,#+0
   \   00000038   F4FFFF1A           BNE      ??JLINKDCC_SendString_1
    472            }
    473          }
   \   0000003C   0080BDE8           POP      {PC}             ;; return
    474          
    475          /*********************************************************************
    476          *
    477          *       JLINKDCC_SendCharOnChannelNB
    478          *
    479          *  Function description
    480          *    Send data to the host on selected channel.
    481          *    This function is non-blocking.
    482          *    If data can not be send it is stored in a buffer
    483          *    and sent later, when the DCC Handler is called.
    484          */

   \                                 In section .text, align 4, keep-with-next
    485          void JLINKDCC_SendCharOnChannelNB(unsigned Channel, U8 Data) {
    486            U32 DCCPacket;
    487            int DCCBusy;
    488          
    489            DCCPacket = 0x93800000 | (Channel << 16);
    490            DCCPacket |= Data;
   \                     JLINKDCC_SendCharOnChannelNB:
   \   00000000   8024A0E3           MOV      R2,#-2147483648
   \   00000004   001881E1           ORR      R1,R1,R0, LSL #+16
   \   00000008   4E2582E3           ORR      R2,R2,#0x13800000
   \   0000000C   011082E1           ORR      R1,R2,R1
    491            DCCBusy = _ReadDCCStat() & 2;
    492            if (DCCBusy == 0) {
   \   00000010   103E10EE           MRC      p14,0,R3,c0,c0,0
   \   00000014   ........           LDR      R2,??DataTable8
   \   00000018   020013E3           TST      R3,#0x2
    493              _WriteDCC(DCCPacket);
   \   0000001C   101E010E           MCREQ    p14,0,R1,c1,c0,0
    494            } else {
    495              _WritePendingNB = 1;
   \   00000020   0130A013           MOVNE    R3,#+1
   \   00000024   3130C215           STRBNE   R3,[R2, #+49]
    496              _PendingPacketNB = DCCPacket;
   \   00000028   28108215           STRNE    R1,[R2, #+40]
    497            }
    498            _ActiveChannel = Channel;
   \   0000002C   240082E5           STR      R0,[R2, #+36]
    499          }
   \   00000030   1EFF2FE1           BX       LR               ;; return
    500          
    501          /*********************************************************************
    502          *
    503          *       JLINKDCC_SendOnChannel
    504          *
    505          *  Function description
    506          *    Send data to the host.
    507          *    32 channels are available, channel 0 is used for terminal output and is buffered,
    508          *    all other channels are unbuffered.
    509          */

   \                                 In section .text, align 4, keep-with-next
    510          void JLINKDCC_SendOnChannel(unsigned Channel, U8 * pData, int NumItems) {
   \                     JLINKDCC_SendOnChannel:
   \   00000000   10402DE9           PUSH     {R4,LR}
    511            U32 Data;
    512          
    513            if (Channel == DCC_CHANNEL_TERMINAL)  {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0F00001A           BNE      ??JLINKDCC_SendOnChannel_0
    514              while (NumItems-- > 0) {
   \                     ??JLINKDCC_SendOnChannel_1:
   \   0000000C   010052E3           CMP      R2,#+1
   \   00000010   210000BA           BLT      ??JLINKDCC_SendOnChannel_2
    515                Data = *pData++;
    516                JLINKDCC_SendChar(Data);
   \   00000014   ........           LDR      R0,??DataTable8
   \   00000018   012042E2           SUB      R2,R2,#+1
   \   0000001C   20C090E5           LDR      R12,[R0, #+32]
   \   00000020   1C4090E5           LDR      R4,[R0, #+28]
   \   00000024   01E08CE2           ADD      LR,R12,#+1
   \   00000028   400E5EE3           CMP      LR,#+1024
   \   0000002C   00E0A003           MOVEQ    LR,#+0
   \   00000030   0130D1E4           LDRB     R3,[R1], #+1
   \   00000034   04005EE1           CMP      LR,R4
   \   00000038   F3FFFF0A           BEQ      ??JLINKDCC_SendOnChannel_1
   \   0000003C   00C08CE0           ADD      R12,R12,R0
   \   00000040   3430CCE5           STRB     R3,[R12, #+52]
   \   00000044   20E080E5           STR      LR,[R0, #+32]
   \   00000048   EFFFFFEA           B        ??JLINKDCC_SendOnChannel_1
    517              }
    518            } else {
    519              while (NumItems-- > 0) {
   \                     ??JLINKDCC_SendOnChannel_0:
   \   0000004C   010052E3           CMP      R2,#+1
   \   00000050   110000BA           BLT      ??JLINKDCC_SendOnChannel_2
   \                     ??JLINKDCC_SendOnChannel_3:
   \   00000054   012042E2           SUB      R2,R2,#+1
    520                Data = *pData++;
   \   00000058   0130D1E4           LDRB     R3,[R1], #+1
    521                if  (NumItems > 0) {
   \   0000005C   010052E3           CMP      R2,#+1
   \   00000060   030000BA           BLT      ??JLINKDCC_SendOnChannel_4
    522                  Data |= *pData++ << 8;
   \   00000064   01C0D1E4           LDRB     R12,[R1], #+1
    523                  NumItems--;
   \   00000068   012042E2           SUB      R2,R2,#+1
   \   0000006C   0C3483E1           ORR      R3,R3,R12, LSL #+8
    524                  Data |= 0x200000;
   \   00000070   803983E3           ORR      R3,R3,#0x200000
    525                }
    526                Data |= 0x93800000;
    527                Data |= Channel << 16;
   \                     ??JLINKDCC_SendOnChannel_4:
   \   00000074   80C4A0E3           MOV      R12,#-2147483648
   \   00000078   4EC58CE3           ORR      R12,R12,#0x13800000
   \   0000007C   00C88CE1           ORR      R12,R12,R0, LSL #+16
   \   00000080   03308CE1           ORR      R3,R12,R3
    528                while (_ReadDCCStat() & 2);       // Wait until we can send data
   \                     ??JLINKDCC_SendOnChannel_5:
   \   00000084   10CE10EE           MRC      p14,0,R12,c0,c0,0
   \   00000088   02001CE3           TST      R12,#0x2
   \   0000008C   FCFFFF1A           BNE      ??JLINKDCC_SendOnChannel_5
    529                _WriteDCC(Data);
   \   00000090   103E01EE           MCR      p14,0,R3,c1,c0,0
    530              }
    531            }
   \   00000094   010052E3           CMP      R2,#+1
   \   00000098   EDFFFFAA           BGE      ??JLINKDCC_SendOnChannel_3
    532          }
   \                     ??JLINKDCC_SendOnChannel_2:
   \   0000009C   1080BDE8           POP      {R4,PC}          ;; return
    533          
    534          /*********************************************************************
    535          *
    536          *       JLINKDCC_SetpfOnRx
    537          *
    538          */

   \                                 In section .text, align 4, keep-with-next
    539          void JLINKDCC_SetpfOnRx(unsigned Channel, void (* pf)(unsigned Channel, U8 Data)) {
    540            _pfOnRx[Channel] = pf;
   \                     JLINKDCC_SetpfOnRx:
   \   00000000   ........           LDR      R2,??DataTable8
   \   00000004   000182E0           ADD      R0,R2,R0, LSL #+2
   \   00000008   041080E5           STR      R1,[R0, #+4]
    541          }
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    542          
    543          /*********************************************************************
    544          *
    545          *       JLINKDCC_SetpfOnTx
    546          *
    547          */

   \                                 In section .text, align 4, keep-with-next
    548          void JLINKDCC_SetpfOnTx(unsigned Channel, void (* pf)(unsigned Channel)) {
    549            _pfOnTx[Channel] = pf;
   \                     JLINKDCC_SetpfOnTx:
   \   00000000   ........           LDR      R2,??DataTable8
   \   00000004   000182E0           ADD      R0,R2,R0, LSL #+2
   \   00000008   0C1080E5           STR      R1,[R0, #+12]
    550          }
   \   0000000C   1EFF2FE1           BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     _NumReadItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   FF00CA91           DC32     0x91ca00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   ........           DC32     JLINKDCC_IsInHandler
    551          
    552          
    553          /*************************** end of file ****************************/

   Maximum stack usage in bytes:

     Function                     .cstack
     --------                     -------
     JLINKDCC_Process                  8
     JLINKDCC_SendChar                 0
     JLINKDCC_SendCharOnChannelNB      0
     JLINKDCC_SendOnChannel            8
     JLINKDCC_SendString               4
     JLINKDCC_SetpfOnRx                0
     JLINKDCC_SetpfOnTx                0
     _HandleRead                       8
     _HandleWrite                     16


   Section sizes:

     Function/Label               Bytes
     --------------               -----
     JLINKDCC_IsInHandler            1
     _NumReadItems                1076
     _pfOnRx
     _pfOnTx
     _Command
     _Addr
     _RdPos
     _WrPos
     _ActiveChannel
     _PendingPacketNB
     _Data
     JLINKDCC_AbortOccurred
     _WritePendingNB
     _WritePending
     _acBuffer
     _HandleRead                   248
     _HandleWrite                  444
     JLINKDCC_Process               48
     JLINKDCC_SendChar              44
     JLINKDCC_SendString            64
     JLINKDCC_SendCharOnChannelNB   52
     JLINKDCC_SendOnChannel        160
     JLINKDCC_SetpfOnRx             16
     JLINKDCC_SetpfOnTx             16
     ??DataTable8                    4
     ??DataTable8_1                  4
     ??DataTable8_2                  4

 
 1 077 bytes in section .bss
 1 104 bytes in section .text
 
 1 104 bytes of CODE memory
 1 077 bytes of DATA memory

Errors: none
Warnings: none
