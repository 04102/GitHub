###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:09:50 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\LCD_RotateCW.c                      #
#    Command line =  C:\DUII\TargetHW\GUI\LCD_RotateCW.c -D DEBUG=1 -D        #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\LCD_RotateCW.lst           #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\LCD_RotateCW.o              #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\LCD_RotateCW.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : LCD_RotateCW.c
     19          Purpose     : Implementation of GUI_SetRotation
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include "GUI_Private.h"
     24          
     25          #if GUI_WINSUPPORT
     26            #include "WM.h"
     27          #endif
     28          
     29          #if GUI_SUPPORT_ROTATION
     30          
     31          /*********************************************************************
     32          *
     33          *       Static code
     34          *
     35          **********************************************************************
     36          */
     37          /*********************************************************************
     38          *
     39          *       _GetpfSetPixel
     40          */
     41          static tLCD_SetPixelAA * _GetpfSetPixel(void) {
     42            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
     43            case 0:
     44              return &LCD_SetPixelAA_NoTrans;
     45            case LCD_DRAWMODE_TRANS:
     46              return &LCD_SetPixelAA;
     47            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
     48            case LCD_DRAWMODE_XOR:
     49              return &LCD_SetPixelAA_Xor;
     50            }
     51            return NULL; // Never reach...
     52          }
     53          
     54          /*********************************************************************
     55          *
     56          *       _DrawBitLine1BPP
     57          */

   \                                 In section .text, align 4, keep-with-next
     58          static void  _DrawBitLine1BPP(int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine1BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   2C009DE5           LDR      R0,[SP, #+44]
     59            LCD_PIXELINDEX Index0, Index1;
     60            unsigned IndexMask, Pixel;
     61          
     62            Index0 = *(pTrans + 0);
     63            Index1 = *(pTrans + 1);
     64            y += Diff;
     65            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000010   ........           LDR      R5,??DataTable4
   \   00000014   00A090E5           LDR      R10,[R0, #+0]
   \   00000018   04B090E5           LDR      R11,[R0, #+4]
   \   0000001C   1000D5E5           LDRB     R0,[R5, #+16]
   \   00000020   0370A0E1           MOV      R7,R3
   \   00000024   0280A0E1           MOV      R8,R2
   \   00000028   28909DE5           LDR      R9,[SP, #+40]
   \   0000002C   016087E0           ADD      R6,R7,R1
   \   00000030   030010E2           ANDS     R0,R0,#0x3
   \   00000034   0300000A           BEQ      ??_DrawBitLine1BPP_0
   \   00000038   020050E3           CMP      R0,#+2
   \   0000003C   1600000A           BEQ      ??_DrawBitLine1BPP_1
   \   00000040   2A00003A           BCC      ??_DrawBitLine1BPP_2
   \   00000044   4D0000EA           B        ??_DrawBitLine1BPP_3
     66            case 0:
     67              do {
     68                LCDDEV_L0_SetPixelIndex(GUI_Context.apDevice[GUI_Context.SelLayer], x, y, (*p & (0x80 >> Diff)) ? Index1 : Index0);
   \                     ??_DrawBitLine1BPP_0:
   \   00000048   0000D8E5           LDRB     R0,[R8, #+0]
   \   0000004C   8010A0E3           MOV      R1,#+128
   \   00000050   0620A0E1           MOV      R2,R6
   \   00000054   510710E1           TST      R0,R1, ASR R7
   \   00000058   1100D5E5           LDRB     R0,[R5, #+17]
   \   0000005C   0B30A011           MOVNE    R3,R11
   \   00000060   0A30A001           MOVEQ    R3,R10
   \   00000064   000185E0           ADD      R0,R5,R0, LSL #+2
   \   00000068   480090E5           LDR      R0,[R0, #+72]
   \   0000006C   0410A0E1           MOV      R1,R4
   \   00000070   0CC090E5           LDR      R12,[R0, #+12]
   \   00000074   18C09CE5           LDR      R12,[R12, #+24]
   \   00000078   3CFF2FE1           BLX      R12
     69                y++;
     70                if (++Diff == 8) {
   \   0000007C   017087E2           ADD      R7,R7,#+1
   \   00000080   080057E3           CMP      R7,#+8
     71                  Diff = 0;
   \   00000084   0070A003           MOVEQ    R7,#+0
     72                  p++;
   \   00000088   01808802           ADDEQ    R8,R8,#+1
   \   0000008C   016086E2           ADD      R6,R6,#+1
     73                }
     74              } while (--xsize);
   \   00000090   019059E2           SUBS     R9,R9,#+1
   \   00000094   EBFFFF1A           BNE      ??_DrawBitLine1BPP_0
   \   00000098   380000EA           B        ??_DrawBitLine1BPP_3
     75              break;
     76            case LCD_DRAWMODE_TRANS:
     77              do {
     78                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_1:
   \   0000009C   0000D8E5           LDRB     R0,[R8, #+0]
   \   000000A0   8010A0E3           MOV      R1,#+128
   \   000000A4   510710E1           TST      R0,R1, ASR R7
   \   000000A8   0800000A           BEQ      ??_DrawBitLine1BPP_4
   \   000000AC   1100D5E5           LDRB     R0,[R5, #+17]
   \   000000B0   0B30A0E1           MOV      R3,R11
   \   000000B4   0620A0E1           MOV      R2,R6
   \   000000B8   000185E0           ADD      R0,R5,R0, LSL #+2
   \   000000BC   480090E5           LDR      R0,[R0, #+72]
   \   000000C0   0410A0E1           MOV      R1,R4
   \   000000C4   0CC090E5           LDR      R12,[R0, #+12]
   \   000000C8   18C09CE5           LDR      R12,[R12, #+24]
     79                  LCDDEV_L0_SetPixelIndex(GUI_Context.apDevice[GUI_Context.SelLayer], x, y, Index1);
   \   000000CC   3CFF2FE1           BLX      R12
     80                }
     81                y++;
     82                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_4:
   \   000000D0   017087E2           ADD      R7,R7,#+1
   \   000000D4   080057E3           CMP      R7,#+8
     83                  Diff = 0;
   \   000000D8   0070A003           MOVEQ    R7,#+0
     84                  p++;
   \   000000DC   01808802           ADDEQ    R8,R8,#+1
   \   000000E0   016086E2           ADD      R6,R6,#+1
     85                }
     86              } while (--xsize);
   \   000000E4   019059E2           SUBS     R9,R9,#+1
   \   000000E8   EBFFFF1A           BNE      ??_DrawBitLine1BPP_1
   \   000000EC   230000EA           B        ??_DrawBitLine1BPP_3
     87              break;
     88            case LCD_DRAWMODE_XOR:;
     89              IndexMask = GUI_Context.apDevice[GUI_Context.SelLayer]->pColorConvAPI->pfGetIndexMask();
   \                     ??_DrawBitLine1BPP_2:
   \   000000F0   1100D5E5           LDRB     R0,[R5, #+17]
   \   000000F4   000185E0           ADD      R0,R5,R0, LSL #+2
   \   000000F8   480090E5           LDR      R0,[R0, #+72]
   \   000000FC   100090E5           LDR      R0,[R0, #+16]
   \   00000100   080090E5           LDR      R0,[R0, #+8]
   \   00000104   30FF2FE1           BLX      R0
   \   00000108   00A0A0E1           MOV      R10,R0
   \   0000010C   80B0A0E3           MOV      R11,#+128
     90              do {
     91                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_5:
   \   00000110   0000D8E5           LDRB     R0,[R8, #+0]
   \   00000114   5B0710E1           TST      R0,R11, ASR R7
   \   00000118   1100000A           BEQ      ??_DrawBitLine1BPP_6
   \   0000011C   1100D5E5           LDRB     R0,[R5, #+17]
   \   00000120   0620A0E1           MOV      R2,R6
   \   00000124   0410A0E1           MOV      R1,R4
   \   00000128   000185E0           ADD      R0,R5,R0, LSL #+2
   \   0000012C   480090E5           LDR      R0,[R0, #+72]
   \   00000130   0C3090E5           LDR      R3,[R0, #+12]
   \   00000134   143093E5           LDR      R3,[R3, #+20]
     92                  Pixel = LCDDEV_L0_GetPixelIndex(GUI_Context.apDevice[GUI_Context.SelLayer], x, y);
   \   00000138   33FF2FE1           BLX      R3
   \   0000013C   0010A0E1           MOV      R1,R0
   \   00000140   1100D5E5           LDRB     R0,[R5, #+17]
   \   00000144   01302AE0           EOR      R3,R10,R1
   \   00000148   0620A0E1           MOV      R2,R6
   \   0000014C   000185E0           ADD      R0,R5,R0, LSL #+2
   \   00000150   480090E5           LDR      R0,[R0, #+72]
   \   00000154   0410A0E1           MOV      R1,R4
   \   00000158   0CC090E5           LDR      R12,[R0, #+12]
   \   0000015C   18C09CE5           LDR      R12,[R12, #+24]
     93                  LCDDEV_L0_SetPixelIndex(GUI_Context.apDevice[GUI_Context.SelLayer], x, y, Pixel ^ IndexMask);
   \   00000160   3CFF2FE1           BLX      R12
     94                }
     95                y++;
     96                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_6:
   \   00000164   017087E2           ADD      R7,R7,#+1
   \   00000168   080057E3           CMP      R7,#+8
     97                  Diff = 0;
   \   0000016C   0070A003           MOVEQ    R7,#+0
     98                  p++;
   \   00000170   01808802           ADDEQ    R8,R8,#+1
   \   00000174   016086E2           ADD      R6,R6,#+1
     99                }
    100              } while (--xsize);
   \   00000178   019059E2           SUBS     R9,R9,#+1
   \   0000017C   E3FFFF1A           BNE      ??_DrawBitLine1BPP_5
    101              break;
    102            }
    103          }
   \                     ??_DrawBitLine1BPP_3:
   \   00000180   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000184   F08FBDE8           POP      {R4-R11,PC}      ;; return
    104          
    105          /*********************************************************************
    106          *
    107          *       _DrawBitLine2BPP
    108          */
    109          static void  _DrawBitLine2BPP(int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize) {
    110            LCD_PIXELINDEX Pixels, PixelIndex;
    111            int CurrentPixel, Shift, Index;
    112            tLCD_SetPixelAA * pfSetPixelAA;
    113            const int aConvTable[4] = {0, 5, 10, 15};
    114          
    115            Pixels = *p;
    116            CurrentPixel = Diff;
    117            y += Diff;
    118            pfSetPixelAA = _GetpfSetPixel();
    119            do {
    120              Shift = (3 - CurrentPixel) << 1;
    121              Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    122              PixelIndex = *(aConvTable + Index);
    123              pfSetPixelAA(x, y, PixelIndex);
    124              y++;
    125              if (++CurrentPixel == 4) {
    126                CurrentPixel = 0;
    127                Pixels = *(++p);
    128              }
    129            } while (--xsize);
    130          }
    131          
    132          /*********************************************************************
    133          *
    134          *       _DrawBitLine4BPP
    135          */
    136          static void  _DrawBitLine4BPP(int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize) {
    137            LCD_PIXELINDEX Pixels;
    138            int CurrentPixel, Shift, Index;
    139            tLCD_SetPixelAA * pfSetPixelAA;
    140          
    141            Pixels = *p;
    142            CurrentPixel = Diff;
    143            y += Diff;
    144            pfSetPixelAA = _GetpfSetPixel();
    145            do {
    146              Shift = (1 - CurrentPixel) << 2;
    147              Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    148              pfSetPixelAA(x, y, Index);
    149              y++;
    150              if (++CurrentPixel == 2) {
    151                CurrentPixel = 0;
    152                Pixels = *(++p);
    153              }
    154            } while (--xsize);
    155          }
    156          
    157          /*********************************************************************
    158          *
    159          *       _DrawBitmap
    160          *
    161          * Purpose:
    162          *   Draws a bitmap (1bpp) clockwise.
    163          */

   \                                 In section .text, align 4, keep-with-next
    164          static void _DrawBitmap(int x0, int y0,
    165                                  int xsize, int ysize,
    166                                  int BitsPerPixel, 
    167                                  int BytesPerLine,
    168                                  const U8 GUI_UNI_PTR * pData, int Diff,
    169                                  const LCD_PIXELINDEX * pTrans)
    170          {
   \                     _DrawBitmap:
   \   00000000   FE4F2DE9           PUSH     {R1-R11,LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
    171            int i;
    172            /* Use _DrawBitLineXBPP */
    173            for (i = 0; i < ysize; i++) {
   \   00000008   28109DE5           LDR      R1,[SP, #+40]
   \   0000000C   0020A0E3           MOV      R2,#+0
   \   00000010   58409DE5           LDR      R4,[SP, #+88]
   \   00000014   0C208DE5           STR      R2,[SP, #+12]
   \   00000018   010051E3           CMP      R1,#+1
   \   0000001C   7A0000BA           BLT      ??_DrawBitmap_2
   \   00000020   08008DE5           STR      R0,[SP, #+8]
    174              switch (BitsPerPixel) {
   \                     ??_DrawBitmap_3:
   \   00000024   50009DE5           LDR      R0,[SP, #+80]
   \   00000028   010050E2           SUBS     R0,R0,#+1
   \   0000002C   0400000A           BEQ      ??_DrawBitmap_4
   \   00000030   010050E2           SUBS     R0,R0,#+1
   \   00000034   0C00000A           BEQ      ??_DrawBitmap_5
   \   00000038   020050E2           SUBS     R0,R0,#+2
   \   0000003C   3C00000A           BEQ      ??_DrawBitmap_6
   \   00000040   650000EA           B        ??_DrawBitmap_7
    175              case 1:
    176                _DrawBitLine1BPP(x0 - i, y0, pData, Diff, xsize, pTrans);
   \                     ??_DrawBitmap_4:
   \   00000044   60009DE5           LDR      R0,[SP, #+96]
   \   00000048   5C309DE5           LDR      R3,[SP, #+92]
   \   0000004C   04008DE5           STR      R0,[SP, #+4]
   \   00000050   24009DE5           LDR      R0,[SP, #+36]
   \   00000054   0420A0E1           MOV      R2,R4
   \   00000058   00008DE5           STR      R0,[SP, #+0]
   \   0000005C   20109DE5           LDR      R1,[SP, #+32]
   \   00000060   08009DE5           LDR      R0,[SP, #+8]
   \   00000064   ........           BL       _DrawBitLine1BPP
    177                break;
   \   00000068   5B0000EA           B        ??_DrawBitmap_7
    178              case 2:
    179                _DrawBitLine2BPP(x0 - i, y0, pData, Diff, xsize);
   \                     ??_DrawBitmap_5:
   \   0000006C   ............       ADRL     R1,`?<Constant {0, 5, 10, 15}>`
   \              ....        
   \   00000074   24509DE5           LDR      R5,[SP, #+36]
   \   00000078   0C50B1E8           LDM      R1!,{R2,R3,R12,LR}
   \   0000007C   08709DE5           LDR      R7,[SP, #+8]
   \   00000080   10008DE2           ADD      R0,SP,#+16
   \   00000084   0C50A0E8           STM      R0!,{R2,R3,R12,LR}
   \   00000088   5C909DE5           LDR      R9,[SP, #+92]
   \   0000008C   20009DE5           LDR      R0,[SP, #+32]
   \   00000090   0460A0E1           MOV      R6,R4
   \   00000094   00A089E0           ADD      R10,R9,R0
   \   00000098   ........           LDR      R0,??DataTable4
   \   0000009C   0080D6E5           LDRB     R8,[R6, #+0]
   \   000000A0   1000D0E5           LDRB     R0,[R0, #+16]
   \   000000A4   030000E2           AND      R0,R0,#0x3
   \   000000A8   030050E3           CMP      R0,#+3
   \   000000AC   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_DrawBitmap_0:
   \   000000B0   0900008A           BHI      ??_DrawBitmap_8
   \   000000B4   060000EA           B        ??_DrawBitmap_9
   \   000000B8   010000EA           B        ??_DrawBitmap_10
   \   000000BC   020000EA           B        ??_DrawBitmap_11
   \   000000C0   FFFFFFEA           B        ??_DrawBitmap_10
   \                     ??_DrawBitmap_10:
   \   000000C4   ........           LDR      R11,??DataTable4_1
   \   000000C8   040000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_11:
   \   000000CC   ........           LDR      R11,??DataTable4_2
   \   000000D0   020000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_9:
   \   000000D4   ........           LDR      R11,??DataTable4_3
   \   000000D8   000000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_8:
   \   000000DC   00B0A0E3           MOV      R11,#+0
   \                     ??_DrawBitmap_12:
   \   000000E0   030069E2           RSB      R0,R9,#+3
   \   000000E4   8000A0E1           LSL      R0,R0,#+1
   \   000000E8   0020A0E1           MOV      R2,R0
   \   000000EC   C010A0E3           MOV      R1,#+192
   \   000000F0   062062E2           RSB      R2,R2,#+6
   \   000000F4   511208E0           AND      R1,R8,R1, ASR R2
   \   000000F8   3100A0E1           LSR      R0,R1,R0
   \   000000FC   10108DE2           ADD      R1,SP,#+16
   \   00000100   002191E7           LDR      R2,[R1, +R0, LSL #+2]
   \   00000104   0A10A0E1           MOV      R1,R10
   \   00000108   FF2002E2           AND      R2,R2,#0xFF
   \   0000010C   0700A0E1           MOV      R0,R7
   \   00000110   3BFF2FE1           BLX      R11
   \   00000114   019089E2           ADD      R9,R9,#+1
   \   00000118   040059E3           CMP      R9,#+4
   \   0000011C   0090A003           MOVEQ    R9,#+0
   \   00000120   0180F605           LDRBEQ   R8,[R6, #+1]!
   \   00000124   01A08AE2           ADD      R10,R10,#+1
   \   00000128   015055E2           SUBS     R5,R5,#+1
   \   0000012C   EBFFFF1A           BNE      ??_DrawBitmap_12
   \   00000130   290000EA           B        ??_DrawBitmap_7
    180                break;
    181              case 4:
    182                _DrawBitLine4BPP(x0 - i, y0, pData, Diff, xsize);
   \                     ??_DrawBitmap_6:
   \   00000134   5C909DE5           LDR      R9,[SP, #+92]
   \   00000138   20009DE5           LDR      R0,[SP, #+32]
   \   0000013C   0460A0E1           MOV      R6,R4
   \   00000140   00A089E0           ADD      R10,R9,R0
   \   00000144   ........           LDR      R0,??DataTable4
   \   00000148   24509DE5           LDR      R5,[SP, #+36]
   \   0000014C   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000150   08709DE5           LDR      R7,[SP, #+8]
   \   00000154   0080D6E5           LDRB     R8,[R6, #+0]
   \   00000158   030000E2           AND      R0,R0,#0x3
   \   0000015C   030050E3           CMP      R0,#+3
   \   00000160   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_DrawBitmap_1:
   \   00000164   0900008A           BHI      ??_DrawBitmap_13
   \   00000168   060000EA           B        ??_DrawBitmap_14
   \   0000016C   010000EA           B        ??_DrawBitmap_15
   \   00000170   020000EA           B        ??_DrawBitmap_16
   \   00000174   FFFFFFEA           B        ??_DrawBitmap_15
   \                     ??_DrawBitmap_15:
   \   00000178   ........           LDR      R11,??DataTable4_1
   \   0000017C   040000EA           B        ??_DrawBitmap_17
   \                     ??_DrawBitmap_16:
   \   00000180   ........           LDR      R11,??DataTable4_2
   \   00000184   020000EA           B        ??_DrawBitmap_17
   \                     ??_DrawBitmap_14:
   \   00000188   ........           LDR      R11,??DataTable4_3
   \   0000018C   000000EA           B        ??_DrawBitmap_17
   \                     ??_DrawBitmap_13:
   \   00000190   00B0A0E3           MOV      R11,#+0
   \                     ??_DrawBitmap_17:
   \   00000194   010069E2           RSB      R0,R9,#+1
   \   00000198   0001A0E1           LSL      R0,R0,#+2
   \   0000019C   0020A0E1           MOV      R2,R0
   \   000001A0   F010A0E3           MOV      R1,#+240
   \   000001A4   042062E2           RSB      R2,R2,#+4
   \   000001A8   511208E0           AND      R1,R8,R1, ASR R2
   \   000001AC   3120A0E1           LSR      R2,R1,R0
   \   000001B0   FF2002E2           AND      R2,R2,#0xFF
   \   000001B4   0A10A0E1           MOV      R1,R10
   \   000001B8   0700A0E1           MOV      R0,R7
   \   000001BC   3BFF2FE1           BLX      R11
   \   000001C0   019089E2           ADD      R9,R9,#+1
   \   000001C4   020059E3           CMP      R9,#+2
   \   000001C8   0090A003           MOVEQ    R9,#+0
   \   000001CC   0180F605           LDRBEQ   R8,[R6, #+1]!
   \   000001D0   01A08AE2           ADD      R10,R10,#+1
   \   000001D4   015055E2           SUBS     R5,R5,#+1
   \   000001D8   EDFFFF1A           BNE      ??_DrawBitmap_17
    183                break;
    184              }
    185              pData += BytesPerLine;
   \                     ??_DrawBitmap_7:
   \   000001DC   54009DE5           LDR      R0,[SP, #+84]
    186            }
   \   000001E0   28109DE5           LDR      R1,[SP, #+40]
   \   000001E4   044080E0           ADD      R4,R0,R4
   \   000001E8   0C009DE5           LDR      R0,[SP, #+12]
   \   000001EC   010080E2           ADD      R0,R0,#+1
   \   000001F0   0C008DE5           STR      R0,[SP, #+12]
   \   000001F4   08009DE5           LDR      R0,[SP, #+8]
   \   000001F8   010040E2           SUB      R0,R0,#+1
   \   000001FC   08008DE5           STR      R0,[SP, #+8]
   \   00000200   0C009DE5           LDR      R0,[SP, #+12]
   \   00000204   010050E1           CMP      R0,R1
   \   00000208   85FFFFBA           BLT      ??_DrawBitmap_3
    187          }
   \                     ??_DrawBitmap_2:
   \   0000020C   2CD08DE2           ADD      SP,SP,#+44       ;; stack cleaning
   \   00000210   F08FBDE8           POP      {R4-R11,PC}      ;; return
    188          
    189          /*********************************************************************
    190          *
    191          *       _Rect2TextRect
    192          *
    193          * Purpose:
    194          *   This function transforms a given rectangle (window coordinates)
    195          *   to the rectangle used to clip the text.
    196          */

   \                                 In section .text, align 4, keep-with-next
    197          static void _Rect2TextRect(GUI_RECT * pRect) {
    198            int x1, y1;
    199            x1 = pRect->x1;
    200            y1 = pRect->y1;
    201            pRect->x1 = pRect->x0 + (y1 - pRect->y0);
   \                     _Rect2TextRect:
   \   00000000   F030D0E1           LDRSH    R3,[R0, #+0]
   \   00000004   F6C0D0E1           LDRSH    R12,[R0, #+6]
   \   00000008   F410D0E1           LDRSH    R1,[R0, #+4]
   \   0000000C   F220D0E1           LDRSH    R2,[R0, #+2]
   \   00000010   03C08CE0           ADD      R12,R12,R3
   \   00000014   02C04CE0           SUB      R12,R12,R2
    202            pRect->y1 = pRect->y0 + (x1 - pRect->x0);
   \   00000018   021081E0           ADD      R1,R1,R2
   \   0000001C   B4C0C0E1           STRH     R12,[R0, #+4]
   \   00000020   031041E0           SUB      R1,R1,R3
   \   00000024   B610C0E1           STRH     R1,[R0, #+6]
    203          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
    204          
    205          /*********************************************************************
    206          *
    207          *       _TransformPointCW
    208          *
    209          * Purpose:
    210          *   This function transforms an unrotated point (window
    211          *   coordinates) into a rotated point in desktop coordinates
    212          *   and handles the rotation of the current text rectangle.
    213          */
    214          static void _TransformPointCW(int * pXPos, int * pYPos) {
    215            GUI_RECT ClientRect = {0};
    216            int xPos, yPos, xNumPixel, yNumPixel;
    217            /* Get the client rectangle */
    218            #if GUI_WINSUPPORT
    219              WM_GetWindowRect(&ClientRect);
    220            #else
    221              GUI_GetClientRect(&ClientRect);
    222            #endif
    223            xNumPixel = LCD_GetXSize() - 1;
    224            yNumPixel = LCD_GetYSize() - 1;
    225            if (ClientRect.x1 > xNumPixel) {
    226              ClientRect.x1 = xNumPixel;
    227            }
    228            if (ClientRect.y1 > yNumPixel) {
    229              ClientRect.y1 = yNumPixel;
    230            }
    231            /* Save old positions */
    232            xPos = *pXPos;
    233            yPos = *pYPos;
    234            /* Rotate and add window origin */
    235            *pXPos = ClientRect.x0 - yPos;
    236            *pYPos = ClientRect.y0 + xPos;
    237            /* Handle rotation of text rectangle */
    238            *pXPos = *pXPos + GUI_RectDispString.x1 + GUI_RectDispString.y0;
    239            *pYPos = *pYPos + GUI_RectDispString.y0 - GUI_RectDispString.x0;
    240          }
    241          
    242          /*********************************************************************
    243          *
    244          *       _DrawBitmapCW
    245          */

   \                                 In section .text, align 4, keep-with-next
    246          static void _DrawBitmapCW(int x0, int y0, int xsize, int ysize, int xMul, int yMul,
    247                                     int BitsPerPixel, int BytesPerLine,
    248                                     const U8 GUI_UNI_PTR * pPixel, const LCD_PIXELINDEX * pTrans)
    249          {
   \                     _DrawBitmapCW:
   \   00000000   F44F2DE9           PUSH     {R2,R4-R11,LR}
   \   00000004   0090A0E1           MOV      R9,R0
   \   00000008   0180A0E1           MOV      R8,R1
   \   0000000C   0340A0E1           MOV      R4,R3
    250            U8  Data = 0;
    251            int x1, y1, Diff;
    252            /* Handle the optional Y-magnification */
    253            y1 = y0 + ysize - 1;
   \   00000010   080084E0           ADD      R0,R4,R8
   \   00000014   01A040E2           SUB      R10,R0,#+1
    254            x1 = x0 + xsize - 1;
   \   00000018   090082E0           ADD      R0,R2,R9
    255            /* Rotate positions */
    256            _TransformPointCW(&x0, &y0);
   \   0000001C   ........           ADR      R7,`?<Constant {0}>`
   \   00000020   016040E2           SUB      R6,R0,#+1
   \   00000024   18D04DE2           SUB      SP,SP,#+24
   \   00000028   000097E5           LDR      R0,[R7, #+0]
   \   0000002C   041097E5           LDR      R1,[R7, #+4]
   \   00000030   48509DE5           LDR      R5,[SP, #+72]
   \   00000034   0D20A0E1           MOV      R2,SP
   \   00000038   030082E8           STM      R2,{R0,R1}
   \   0000003C   0D00A0E1           MOV      R0,SP
   \   00000040   ........           BL       WM_GetWindowRect
   \   00000044   ........           BL       LCD_GetXSize
   \   00000048   01B040E2           SUB      R11,R0,#+1
   \   0000004C   ........           BL       LCD_GetYSize
   \   00000050   F410DDE1           LDRSH    R1,[SP, #+4]
   \   00000054   010040E2           SUB      R0,R0,#+1
   \   00000058   F020DDE1           LDRSH    R2,[SP, #+0]
   \   0000005C   01005BE1           CMP      R11,R1
   \   00000060   F610DDE1           LDRSH    R1,[SP, #+6]
   \   00000064   B4B0CDB1           STRHLT   R11,[SP, #+4]
   \   00000068   082042E0           SUB      R2,R2,R8
   \   0000006C   010050E1           CMP      R0,R1
   \   00000070   B600CDB1           STRHLT   R0,[SP, #+6]
   \   00000074   0900A0E1           MOV      R0,R9
   \   00000078   ........           LDR      R9,??DataTable4_4
   \   0000007C   F430D9E1           LDRSH    R3,[R9, #+4]
   \   00000080   F210D9E1           LDRSH    R1,[R9, #+2]
   \   00000084   022083E0           ADD      R2,R3,R2
   \   00000088   028081E0           ADD      R8,R1,R2
   \   0000008C   F220DDE1           LDRSH    R2,[SP, #+2]
   \   00000090   020080E0           ADD      R0,R0,R2
   \   00000094   000081E0           ADD      R0,R1,R0
   \   00000098   F010D9E1           LDRSH    R1,[R9, #+0]
    257            _TransformPointCW(&x1, &y1);
   \   0000009C   0D20A0E1           MOV      R2,SP
   \   000000A0   010040E0           SUB      R0,R0,R1
   \   000000A4   14008DE5           STR      R0,[SP, #+20]
   \   000000A8   000097E5           LDR      R0,[R7, #+0]
   \   000000AC   041097E5           LDR      R1,[R7, #+4]
   \   000000B0   030082E8           STM      R2,{R0,R1}
   \   000000B4   0D00A0E1           MOV      R0,SP
   \   000000B8   ........           BL       WM_GetWindowRect
   \   000000BC   ........           BL       LCD_GetXSize
   \   000000C0   017040E2           SUB      R7,R0,#+1
   \   000000C4   ........           BL       LCD_GetYSize
   \   000000C8   F410DDE1           LDRSH    R1,[SP, #+4]
   \   000000CC   010040E2           SUB      R0,R0,#+1
   \   000000D0   F420D9E1           LDRSH    R2,[R9, #+4]
   \   000000D4   010057E1           CMP      R7,R1
   \   000000D8   F610DDE1           LDRSH    R1,[SP, #+6]
   \   000000DC   B470CDB1           STRHLT   R7,[SP, #+4]
   \   000000E0   010050E1           CMP      R0,R1
   \   000000E4   F010DDE1           LDRSH    R1,[SP, #+0]
   \   000000E8   B600CDB1           STRHLT   R0,[SP, #+6]
   \   000000EC   F200D9E1           LDRSH    R0,[R9, #+2]
   \   000000F0   0A1041E0           SUB      R1,R1,R10
   \   000000F4   011082E0           ADD      R1,R2,R1
   \   000000F8   F220DDE1           LDRSH    R2,[SP, #+2]
   \   000000FC   011080E0           ADD      R1,R0,R1
   \   00000100   022086E0           ADD      R2,R6,R2
   \   00000104   020080E0           ADD      R0,R0,R2
   \   00000108   F020D9E1           LDRSH    R2,[R9, #+0]
   \   0000010C   020040E0           SUB      R0,R0,R2
    258            /*  Handle BITMAP without magnification */
    259            if ((xMul == 1) && (yMul == 1)) {
   \   00000110   40209DE5           LDR      R2,[SP, #+64]
   \   00000114   010052E3           CMP      R2,#+1
   \   00000118   44209D05           LDREQ    R2,[SP, #+68]
   \   0000011C   01005203           CMPEQ    R2,#+1
   \   00000120   3D00001A           BNE      ??_DrawBitmapCW_0
   \   00000124   ........           LDR      R2,??DataTable4
   \   00000128   FC20D2E1           LDRSH    R2,[R2, #+12]
   \   0000012C   080052E1           CMP      R2,R8
   \   00000130   060000AA           BGE      ??_DrawBitmapCW_1
    260              /* Clip right side */
    261              if (x0 > GUI_Context.ClipRect.x1) {
    262                Diff = x0 - GUI_Context.ClipRect.x1;
   \   00000134   022048E0           SUB      R2,R8,R2
    263                ysize -= Diff;
    264                x0 -= Diff;
    265                pPixel += Diff * BytesPerLine;
   \   00000138   4C309DE5           LDR      R3,[SP, #+76]
   \   0000013C   024044E0           SUB      R4,R4,R2
   \   00000140   028048E0           SUB      R8,R8,R2
   \   00000144   50C09DE5           LDR      R12,[SP, #+80]
   \   00000148   93C222E0           MLA      R2,R3,R2,R12
   \   0000014C   50208DE5           STR      R2,[SP, #+80]
   \                     ??_DrawBitmapCW_1:
   \   00000150   ........           LDR      R2,??DataTable4
   \   00000154   F820D2E1           LDRSH    R2,[R2, #+8]
   \   00000158   020051E1           CMP      R1,R2
    266              }
    267              /* Clip left side */
    268              if (x1 < GUI_Context.ClipRect.x0) {
    269                Diff = GUI_Context.ClipRect.x0 - x1;
    270                x1 += Diff;
    271                ysize -= Diff;
   \   0000015C   022044B0           SUBLT    R2,R4,R2
   \   00000160   024081B0           ADDLT    R4,R1,R2
    272              }
    273              Diff = 0;
   \   00000164   ........           LDR      R2,??DataTable4
   \   00000168   0010A0E3           MOV      R1,#+0
   \   0000016C   FE20D2E1           LDRSH    R2,[R2, #+14]
   \   00000170   000052E1           CMP      R2,R0
   \   00000174   030000AA           BGE      ??_DrawBitmapCW_2
    274              /* Clip top */
    275              if (y1 > GUI_Context.ClipRect.y1) {
    276                Diff = y1 - GUI_Context.ClipRect.y1; 
   \   00000178   021040E0           SUB      R1,R0,R2
    277                xsize -= Diff;
   \   0000017C   18009DE5           LDR      R0,[SP, #+24]
   \   00000180   010040E0           SUB      R0,R0,R1
   \   00000184   18008DE5           STR      R0,[SP, #+24]
   \                     ??_DrawBitmapCW_2:
   \   00000188   ........           LDR      R0,??DataTable4
   \   0000018C   14209DE5           LDR      R2,[SP, #+20]
   \   00000190   FA00D0E1           LDRSH    R0,[R0, #+10]
   \   00000194   000052E1           CMP      R2,R0
   \   00000198   0D0000AA           BGE      ??_DrawBitmapCW_3
    278              }
    279              /* Clip bottom */
    280              if (y0 < GUI_Context.ClipRect.y0) {
    281                Diff = GUI_Context.ClipRect.y0 - y0;
   \   0000019C   021040E0           SUB      R1,R0,R2
    282                xsize -= Diff;
   \   000001A0   18009DE5           LDR      R0,[SP, #+24]
    283                switch (BitsPerPixel) {
   \   000001A4   010055E3           CMP      R5,#+1
   \   000001A8   010040E0           SUB      R0,R0,R1
   \   000001AC   18008DE5           STR      R0,[SP, #+24]
   \   000001B0   0700001A           BNE      ??_DrawBitmapCW_3
    284                case 1:
    285                  pPixel += (Diff >> 3); y0 -= (Diff >> 3) << 3; Diff &= 7;
   \   000001B4   50209DE5           LDR      R2,[SP, #+80]
   \   000001B8   C101A0E1           ASR      R0,R1,#+3
   \   000001BC   022080E0           ADD      R2,R0,R2
   \   000001C0   50208DE5           STR      R2,[SP, #+80]
   \   000001C4   14209DE5           LDR      R2,[SP, #+20]
   \   000001C8   071001E2           AND      R1,R1,#0x7
   \   000001CC   800142E0           SUB      R0,R2,R0, LSL #+3
   \   000001D0   14008DE5           STR      R0,[SP, #+20]
    286                  break;
    287                }
    288              }
    289              if (xsize <=0) {
   \                     ??_DrawBitmapCW_3:
   \   000001D4   18009DE5           LDR      R0,[SP, #+24]
   \   000001D8   010050E3           CMP      R0,#+1
    290                return;
    291              }
    292              if (ysize <= 0) {
   \   000001DC   010054A3           CMPGE    R4,#+1
   \   000001E0   570000BA           BLT      ??_DrawBitmapCW_4
    293                return;
    294              }
    295              _DrawBitmap(x0, y0, xsize, ysize, BitsPerPixel, BytesPerLine, pPixel, Diff, pTrans);
   \   000001E4   54009DE5           LDR      R0,[SP, #+84]
   \   000001E8   0C108DE5           STR      R1,[SP, #+12]
   \   000001EC   10008DE5           STR      R0,[SP, #+16]
   \   000001F0   50009DE5           LDR      R0,[SP, #+80]
   \   000001F4   00508DE5           STR      R5,[SP, #+0]
   \   000001F8   08008DE5           STR      R0,[SP, #+8]
   \   000001FC   4C009DE5           LDR      R0,[SP, #+76]
   \   00000200   0430A0E1           MOV      R3,R4
   \   00000204   04008DE5           STR      R0,[SP, #+4]
   \   00000208   18209DE5           LDR      R2,[SP, #+24]
   \   0000020C   14109DE5           LDR      R1,[SP, #+20]
   \   00000210   0800A0E1           MOV      R0,R8
   \   00000214   ........           BL       _DrawBitmap
   \   00000218   490000EA           B        ??_DrawBitmapCW_4
    296            } else {
    297              /* Handle BITMAP with magnification */
    298              int x, y, xi, yi;
    299              int Shift = 8 - BitsPerPixel;
   \                     ??_DrawBitmapCW_0:
   \   0000021C   080065E2           RSB      R0,R5,#+8
   \   00000220   0C008DE5           STR      R0,[SP, #+12]
    300              for (x = x0, xi = 0; xi < ysize; xi++, x -= yMul, pPixel += BytesPerLine) {
   \   00000224   010054E3           CMP      R4,#+1
   \   00000228   450000BA           BLT      ??_DrawBitmapCW_4
   \   0000022C   00408DE5           STR      R4,[SP, #+0]
    301                int xMax = x - yMul + 1;
   \                     ??_DrawBitmapCW_5:
   \   00000230   44009DE5           LDR      R0,[SP, #+68]
   \   00000234   000048E0           SUB      R0,R8,R0
   \   00000238   04008DE5           STR      R0,[SP, #+4]
   \   0000023C   014080E2           ADD      R4,R0,#+1
    302                if ((xMax >= GUI_Context.ClipRect.x0) && (x <= GUI_Context.ClipRect.x1)) {
   \   00000240   ........           LDR      R0,??DataTable4
   \   00000244   F800D0E1           LDRSH    R0,[R0, #+8]
   \   00000248   000054E1           CMP      R4,R0
   \   0000024C   320000BA           BLT      ??_DrawBitmapCW_6
   \   00000250   ........           LDR      R0,??DataTable4
   \   00000254   FC00D0E1           LDRSH    R0,[R0, #+12]
   \   00000258   080050E1           CMP      R0,R8
   \   0000025C   2E0000BA           BLT      ??_DrawBitmapCW_6
    303                  int BitsLeft = 0;
    304                  const U8 GUI_UNI_PTR * pDataLine = pPixel;
   \   00000260   50109DE5           LDR      R1,[SP, #+80]
    305                  for (y = y0, yi = 0; yi < xsize; yi++, y += xMul) {
   \   00000264   18009DE5           LDR      R0,[SP, #+24]
   \   00000268   08108DE5           STR      R1,[SP, #+8]
   \   0000026C   14609DE5           LDR      R6,[SP, #+20]
   \   00000270   010050E3           CMP      R0,#+1
   \   00000274   280000BA           BLT      ??_DrawBitmapCW_6
   \   00000278   18709DE5           LDR      R7,[SP, #+24]
   \   0000027C   010000EA           B        ??_DrawBitmapCW_7
    306                    U8  Index;
    307                    if (!BitsLeft) {
   \                     ??_DrawBitmapCW_8:
   \   00000280   00005AE3           CMP      R10,#+0
   \   00000284   0300001A           BNE      ??_DrawBitmapCW_9
    308                      Data = *pDataLine++;
   \                     ??_DrawBitmapCW_7:
   \   00000288   08109DE5           LDR      R1,[SP, #+8]
    309                      BitsLeft =8;
   \   0000028C   08A0A0E3           MOV      R10,#+8
   \   00000290   0190D1E4           LDRB     R9,[R1], #+1
   \   00000294   08108DE5           STR      R1,[SP, #+8]
    310                    }
    311                    Index = Data >> Shift;
   \                     ??_DrawBitmapCW_9:
   \   00000298   0C109DE5           LDR      R1,[SP, #+12]
   \   0000029C   FF0009E2           AND      R0,R9,#0xFF
   \   000002A0   5001A0E1           ASR      R0,R0,R1
   \   000002A4   FF0000E2           AND      R0,R0,#0xFF
    312                    Data    <<= BitsPerPixel;
   \   000002A8   1995A0E1           LSL      R9,R9,R5
    313                    BitsLeft -= BitsPerPixel;
   \   000002AC   05A04AE0           SUB      R10,R10,R5
    314                    if (Index || ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) == 0)) {
   \   000002B0   000050E3           CMP      R0,#+0
   \   000002B4   0300001A           BNE      ??_DrawBitmapCW_10
   \   000002B8   ........           LDR      R1,??DataTable4
   \   000002BC   1010D1E5           LDRB     R1,[R1, #+16]
   \   000002C0   020011E3           TST      R1,#0x2
   \   000002C4   1000001A           BNE      ??_DrawBitmapCW_11
    315                      LCD_PIXELINDEX OldColor = LCD__GetColorIndex();
   \                     ??_DrawBitmapCW_10:
   \   000002C8   ........           LDR      R1,??DataTable4_5
    316                      if (pTrans) {
   \   000002CC   54209DE5           LDR      R2,[SP, #+84]
   \   000002D0   001091E5           LDR      R1,[R1, #+0]
   \   000002D4   000052E3           CMP      R2,#+0
    317                        LCD__SetColorIndex(*(pTrans + Index));
   \   000002D8   00019217           LDRNE    R0,[R2, +R0, LSL #+2]
   \   000002DC   00B091E5           LDR      R11,[R1, #+0]
    318                      } else {
    319                        LCD__SetColorIndex(Index);
   \   000002E0   000081E5           STR      R0,[R1, #+0]
    320                      }
    321                      LCD_FillRect(xMax, y, x, y + xMul - 1);
   \   000002E4   40009DE5           LDR      R0,[SP, #+64]
   \   000002E8   0820A0E1           MOV      R2,R8
   \   000002EC   000086E0           ADD      R0,R6,R0
   \   000002F0   013040E2           SUB      R3,R0,#+1
   \   000002F4   0610A0E1           MOV      R1,R6
   \   000002F8   0400A0E1           MOV      R0,R4
   \   000002FC   ........           BL       LCD_FillRect
    322                      LCD__SetColorIndex(OldColor);
   \   00000300   ........           LDR      R0,??DataTable4_5
   \   00000304   000090E5           LDR      R0,[R0, #+0]
   \   00000308   00B080E5           STR      R11,[R0, #+0]
    323                    }
    324                  }
   \                     ??_DrawBitmapCW_11:
   \   0000030C   40009DE5           LDR      R0,[SP, #+64]
   \   00000310   017057E2           SUBS     R7,R7,#+1
   \   00000314   066080E0           ADD      R6,R0,R6
   \   00000318   D8FFFF1A           BNE      ??_DrawBitmapCW_8
    325                }
    326              }
   \                     ??_DrawBitmapCW_6:
   \   0000031C   4C009DE5           LDR      R0,[SP, #+76]
   \   00000320   50109DE5           LDR      R1,[SP, #+80]
   \   00000324   04809DE5           LDR      R8,[SP, #+4]
   \   00000328   010080E0           ADD      R0,R0,R1
   \   0000032C   50008DE5           STR      R0,[SP, #+80]
   \   00000330   00009DE5           LDR      R0,[SP, #+0]
   \   00000334   010040E2           SUB      R0,R0,#+1
   \   00000338   00008DE5           STR      R0,[SP, #+0]
   \   0000033C   000050E3           CMP      R0,#+0
   \   00000340   BAFFFF1A           BNE      ??_DrawBitmapCW_5
   \                     ??_DrawBitmapCW_4:
   \   00000344   1CD08DE2           ADD      SP,SP,#+28       ;; stack cleaning
   \   00000348   F08FBDE8           POP      {R4-R11,PC}      ;; return
    327            }
    328          }
    329          
    330          /*********************************************************************
    331          *
    332          *       Global data
    333          *
    334          **********************************************************************
    335          */
    336          /*********************************************************************
    337          *
    338          *       LCD_APIListCW
    339          *
    340          * Purpose:
    341          *   Function pointer table for rotating text CW
    342          */

   \                                 In section .data, align 4
    343          tLCD_APIList LCD_APIListCW = {
   \                     LCD_APIListCW:
   \   00000000   ............       DC32 _DrawBitmapCW, _Rect2TextRect
   \              ....        

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   ........           DC32     LCD_SetPixelAA_Xor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   ........           DC32     LCD_SetPixelAA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   ........           DC32     LCD_SetPixelAA_NoTrans

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   ........           DC32     GUI_RectDispString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 5, 10, 15}>`:
   \   00000000                      ; Initializer data, 16 bytes
   \   00000000   000000000500       DC32 0, 5, 10, 15
   \              00000A000000
   \              0F000000    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   0000               DC16 0
   \   00000002   000000000000       DC8 0, 0, 0, 0, 0, 0
    344            (tLCD_DrawBitmap*)&_DrawBitmapCW,
    345            &_Rect2TextRect
    346          };
    347          
    348          #else
    349          void LCD_RotateCW_C(void);
    350          void LCD_RotateCW_C(void){}
    351          #endif
    352          

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     _DrawBitLine1BPP     40
     _DrawBitmap          80
     _DrawBitmapCW        64
     _Rect2TextRect        0


   Section sizes:

     Function/Label             Bytes
     --------------             -----
     _DrawBitLine1BPP            392
     _DrawBitmap                 532
     _Rect2TextRect               44
     _DrawBitmapCW               844
     LCD_APIListCW                 8
     ??DataTable4                  4
     ??DataTable4_1                4
     ??DataTable4_2                4
     ??DataTable4_3                4
     ??DataTable4_4                4
     ??DataTable4_5                4
     ?<Constant {0, 5, 10, 15}>   16
     ?<Constant {0}>               8

 
     8 bytes in section .data
 1 860 bytes in section .text
 
 1 860 bytes of CODE memory
     8 bytes of DATA memory

Errors: none
Warnings: none
