###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     19/Nov/2015  13:11:09 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\FS\FS_Misc.c                            #
#    Command line =  C:\DUII\TargetHW\FS\FS_Misc.c -D DEBUG=1 -D              #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D NOPROFILER -D     #
#                    OS_TRACE=0 -D OS_VIEW_ENABLE=0 -lCN                      #
#                    C:\DUII\TargetHW\Release\List\ -o                        #
#                    C:\DUII\TargetHW\Release\Obj\ --endian=little            #
#                    --cpu=ARM926EJ-S -e --fpu=None --dlib_config             #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\ -I              #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ --cpu_mode arm -Ohs  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  C:\DUII\TargetHW\Release\List\FS_Misc.lst                #
#    Object file  =  C:\DUII\TargetHW\Release\Obj\FS_Misc.o                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\FS\FS_Misc.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          **** emFile file system for embedded applications ****
     13          emFile is protected by international copyright laws. Knowledge of the
     14          source code may not be used to write a similar product. This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : FS_Misc.c
     19          Purpose     : Misc. API functions
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          /*********************************************************************
     24          *
     25          *        #include Section
     26          *
     27          **********************************************************************
     28          */
     29          
     30          #include "FS_Int.h"
     31          
     32          /*********************************************************************
     33          *
     34          *        Local data types
     35          *
     36          **********************************************************************
     37          */
     38          
     39          typedef struct {
     40            const char * Mode;
     41            U8 AccessFlags;
     42            U8 DoDel;
     43            U8 DoOpen;
     44            U8 DoCreate;
     45          } _FS_MODE_TYPE;
     46          
     47          /*********************************************************************
     48          *
     49          *       Static data
     50          *
     51          **********************************************************************
     52          */
     53          
     54          /*********************************************************************
     55          *
     56          *       Static const
     57          *
     58          **********************************************************************
     59          */
     60          

   \                                 In section .text, align 4, keep-with-next
     61          static const _FS_MODE_TYPE _aAccessMode[] = {
   \                     _aAccessMode:
   \   00000000                      ; Initializer data, 120 bytes
   \   00000000   ........           DC32 `?<Constant "r">`
   \   00000004   08000100           DC8 8, 0, 1, 0
   \   00000008   ........           DC32 `?<Constant "rb">`
   \   0000000C   0A000100           DC8 10, 0, 1, 0
   \   00000010   ........           DC32 `?<Constant "w">`
   \   00000014   14010001           DC8 20, 1, 0, 1
   \   00000018   ........           DC32 `?<Constant "wb">`
   \   0000001C   16010001           DC8 22, 1, 0, 1
   \   00000020   ........           DC32 `?<Constant "a">`
   \   00000024   15000101           DC8 21, 0, 1, 1
   \   00000028   ........           DC32 `?<Constant "ab">`
   \   0000002C   17000101           DC8 23, 0, 1, 1
   \   00000030   ........           DC32 `?<Constant "r+">`
   \   00000034   18000100           DC8 24, 0, 1, 0
   \   00000038   ........           DC32 `?<Constant "r+b">`
   \   0000003C   1A000100           DC8 26, 0, 1, 0
   \   00000040   ........           DC32 `?<Constant "rb+">`
   \   00000044   1A000100           DC8 26, 0, 1, 0
   \   00000048   ........           DC32 `?<Constant "w+">`
   \   0000004C   1C010001           DC8 28, 1, 0, 1
   \   00000050   ........           DC32 `?<Constant "w+b">`
   \   00000054   1E010001           DC8 30, 1, 0, 1
   \   00000058   ........           DC32 `?<Constant "wb+">`
   \   0000005C   1E010001           DC8 30, 1, 0, 1
   \   00000060   ........           DC32 `?<Constant "a+">`
   \   00000064   1D000101           DC8 29, 0, 1, 1
   \   00000068   ........           DC32 `?<Constant "a+b">`
   \   0000006C   1F000101           DC8 31, 0, 1, 1
   \   00000070   ........           DC32 `?<Constant "ab+">`
   \   00000074   1F000101           DC8 31, 0, 1, 1
     62                                                   /* DEL  OPEN  CREATE  READ  WRITE  APPEND  CREATE  BINARY */
     63            { "r"   ,  FS_FILE_ACCESS_FLAG_R,         0,   1,    0},
     64            { "rb"  ,  FS_FILE_ACCESS_FLAGS_BR,       0,   1,    0}, /* 1,    0,     0,       0,     1 */
     65            { "w"   ,  FS_FILE_ACCESS_FLAGS_CW,       1,   0,    1}, /* 0,    1,     0,       1,     0 */
     66            { "wb"  ,  FS_FILE_ACCESS_FLAGS_BCW,      1,   0,    1}, /* 0,    1,     0,       1,     1 */
     67            { "a"   ,  FS_FILE_ACCESS_FLAGS_ACW,      0,   1,    1}, /* 0,    1,     1,       1,     0 */
     68            { "ab"  ,  FS_FILE_ACCESS_FLAGS_ABCW,     0,   1,    1}, /* 0,    1,     1,       1,     1 */
     69            { "r+"  ,  FS_FILE_ACCESS_FLAGS_RW,       0,   1,    0}, /* 1,    1,     0,       0,     0 */
     70            { "r+b" ,  FS_FILE_ACCESS_FLAGS_BRW,      0,   1,    0}, /* 1,    1,     0,       0,     1 */
     71            { "rb+" ,  FS_FILE_ACCESS_FLAGS_BRW,      0,   1,    0}, /* 1,    1,     0,       0,     1 */
     72            { "w+"  ,  FS_FILE_ACCESS_FLAGS_CRW,      1,   0,    1}, /* 1,    1,     0,       1,     0 */
     73            { "w+b" ,  FS_FILE_ACCESS_FLAGS_BCRW,     1,   0,    1}, /* 1,    1,     0,       1,     1 */
     74            { "wb+" ,  FS_FILE_ACCESS_FLAGS_BCRW,     1,   0,    1}, /* 1,    1,     0,       1,     1 */
     75            { "a+"  ,  FS_FILE_ACCESS_FLAGS_ACRW,     0,   1,    1}, /* 1,    1,     1,       1,     0 */
     76            { "a+b" ,  FS_FILE_ACCESS_FLAGS_ABCRW,    0,   1,    1}, /* 1,    1,     1,       1,     1 */
     77            { "ab+" ,  FS_FILE_ACCESS_FLAGS_ABCRW,    0,   1,    1}  /* 1,    1,     1,       1,     1 */
     78          };
     79          
     80          /*********************************************************************
     81          *
     82          *       Static code
     83          *
     84          **********************************************************************
     85          */
     86          
     87          /*********************************************************************
     88          *
     89          *       _CalcSizeInKB
     90          *
     91          *  Function description
     92          *     Given the numbers of clusters, sectors per cluster and bytes per sector,
     93          *     calculate the equivalent number of kilo bytes.
     94          *
     95          *  Parameters:
     96          *     NumClusters         - The Number of sectors
     97          *     SectorsPerCluster   - The number of sectors in a cluster
     98          *     BytesPerSector      - The number of bytes in a sector
     99          *
    100          *  Return value:
    101          *     The number of kilo bytes (KB).
    102          */
    103          static U32 _CalcSizeInKB(U32 NumClusters, U32 SectorsPerCluster, U32 BytesPerSector) {
    104            U32 BytesPerCluster;
    105            int NumShifts;
    106          
    107            BytesPerCluster = SectorsPerCluster * BytesPerSector;
    108            NumShifts = 10;
    109            do {
    110              if (BytesPerCluster == 1) {
    111                break;
    112              }
    113              BytesPerCluster >>= 1;
    114            } while (--NumShifts);
    115            return BytesPerCluster * (NumClusters >> NumShifts);
    116          }
    117          
    118          
    119          /*********************************************************************
    120          *
    121          *       _Text2Mode
    122          *
    123          *  Function description
    124          *    Converts the "open-mode-string" into flags using a table.
    125          */
    126          static int _Text2Mode(const char * sMode) {
    127            unsigned j;
    128            for (j = 0; j < COUNTOF(_aAccessMode); j++) { /* Go through whole list */
    129              if (FS_STRCMP(sMode, _aAccessMode[j].Mode) == 0) {
    130                return j;
    131              }
    132            }
    133            return -1;       /* Not a valid access mode */
    134          }
    135          
    136          /*********************************************************************
    137          *
    138          *       _SB_Clean
    139          */
    140          static void _SB_Clean(FS_SB * pSB) {
    141            if (pSB->HasError) {
    142              return;       /* Previous error, do not continue */
    143            }
    144            if (pSB->IsDirty) {
    145              if (FS_LB_WritePart(pSB->pPart, pSB->SectorNo, pSB->pBuffer, pSB->Type)) {
    146                pSB->HasError = 1;
    147              }
    148              /* Handle the optional sector copy (Typically used for the second FAT) */
    149          #if FS_MAINTAIN_FAT_COPY
    150              if (pSB->WriteCopyOff) {
    151                FS_LB_WritePart(pSB->pPart, pSB->SectorNo + pSB->WriteCopyOff, pSB->pBuffer, pSB->Type);
    152              }
    153          #endif
    154              pSB->IsDirty = 0;
    155            }
    156          }
    157          
    158          /*********************************************************************
    159          *
    160          *       Public data
    161          *
    162          **********************************************************************
    163          */
    164          
    165          /*********************************************************************
    166          *
    167          *       Public code
    168          *
    169          **********************************************************************
    170          */
    171          
    172          /*********************************************************************
    173          *
    174          *       Public code, internal functions
    175          *
    176          **********************************************************************
    177          */
    178          
    179          /*********************************************************************
    180          *
    181          *       FS__AllocSectorBuffer
    182          *
    183          *  Description:
    184          *    Allocate a sector buffer.
    185          *
    186          *  Return value:
    187          *    ==0         - Cannot allocate a buffer.
    188          *    !=0         - Address of a buffer.
    189          */

   \                                 In section .text, align 4, keep-with-next
    190          U8 * FS__AllocSectorBuffer(void) {
   \                     FS__AllocSectorBuffer:
   \   00000000   00402DE9           PUSH     {LR}
    191            unsigned i;
    192            U8 * r;
    193          
    194            r = (U8*)NULL;
    195            FS_LOCK_SYS();
    196            for (i = 0; i < FS_Global.NumSectorBuffers; i++) {
   \   00000004   ........           LDR      R2,??DataTable27
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   083092E5           LDR      R3,[R2, #+8]
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   03C0A0E1           MOV      R12,R3
   \   00000018   0C2092E5           LDR      R2,[R2, #+12]
   \   0000001C   000000EA           B        ??FS__AllocSectorBuffer_0
   \                     ??FS__AllocSectorBuffer_1:
   \   00000020   011081E2           ADD      R1,R1,#+1
   \                     ??FS__AllocSectorBuffer_0:
   \   00000024   020051E1           CMP      R1,R2
   \   00000028   0600002A           BCS      ??FS__AllocSectorBuffer_2
    197              if (FS_Global.paSectorBuffer[i].InUse == 0) {
   \   0000002C   08E09CE4           LDR      LR,[R12], #+8
   \   00000030   00005EE3           CMP      LR,#+0
   \   00000034   F9FFFF1A           BNE      ??FS__AllocSectorBuffer_1
    198                FS_Global.paSectorBuffer[i].InUse  = 1;
   \   00000038   0100A0E3           MOV      R0,#+1
   \   0000003C   810183E7           STR      R0,[R3, +R1, LSL #+3]
    199                r = (U8 *)FS_Global.paSectorBuffer[i].pBuffer;
   \   00000040   810183E0           ADD      R0,R3,R1, LSL #+3
   \   00000044   040090E5           LDR      R0,[R0, #+4]
    200                break;
    201              }
    202            }
    203            if (r == (U8 *)NULL) {
    204              FS_DEBUG_ERROROUT((FS_MTYPE_API, "FS__AllocSectorBuffer: No sector buffer available.\n"));
    205            }
    206            FS_UNLOCK_SYS();
    207            return r;
   \                     ??FS__AllocSectorBuffer_2:
   \   00000048   0080BDE8           POP      {PC}             ;; return
    208          }
    209          
    210          /*********************************************************************
    211          *
    212          *       FS__FreeSectorBuffer
    213          *
    214          *  Description:
    215          *    Free sector buffer.
    216          *
    217          *  Parameters:
    218          *    pBuffer     - Pointer to a buffer, which has to be set free.
    219          */

   \                                 In section .text, align 4, keep-with-next
    220          void FS__FreeSectorBuffer(void *pBuffer) {
   \                     FS__FreeSectorBuffer:
   \   00000000   10402DE9           PUSH     {R4,LR}
    221            unsigned i;
    222            FS_LOCK_SYS();
    223            for (i = 0; i < FS_Global.NumSectorBuffers; i++) {
   \   00000004   ........           LDR      R3,??DataTable27
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   08C093E5           LDR      R12,[R3, #+8]
   \   00000010   0020A0E3           MOV      R2,#+0
   \   00000014   04E08CE2           ADD      LR,R12,#+4
   \   00000018   0C3093E5           LDR      R3,[R3, #+12]
   \   0000001C   000000EA           B        ??FS__FreeSectorBuffer_0
   \                     ??FS__FreeSectorBuffer_1:
   \   00000020   012082E2           ADD      R2,R2,#+1
   \                     ??FS__FreeSectorBuffer_0:
   \   00000024   030052E1           CMP      R2,R3
   \   00000028   0300002A           BCS      ??FS__FreeSectorBuffer_2
    224              if (((void*)FS_Global.paSectorBuffer[i].pBuffer) == pBuffer) {
   \   0000002C   08409EE4           LDR      R4,[LR], #+8
   \   00000030   000054E1           CMP      R4,R0
   \   00000034   F9FFFF1A           BNE      ??FS__FreeSectorBuffer_1
    225                FS_Global.paSectorBuffer[i].InUse = 0;
   \   00000038   82118CE7           STR      R1,[R12, +R2, LSL #+3]
    226                break;
    227              }
    228            }
    229            FS_UNLOCK_SYS();
    230          }
   \                     ??FS__FreeSectorBuffer_2:
   \   0000003C   1080BDE8           POP      {R4,PC}          ;; return
    231          
    232          /*********************************************************************
    233          *
    234          *       FS__SB_Flush
    235          */

   \                                 In section .text, align 4, keep-with-next
    236          void FS__SB_Flush(FS_SB * pSB) {
   \                     FS__SB_Flush:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    237            pSB->IsDirty = 1;
   \   00000008   0150A0E3           MOV      R5,#+1
   \   0000000C   0C50C4E5           STRB     R5,[R4, #+12]
    238            _SB_Clean(pSB);
   \   00000010   0D00D4E5           LDRB     R0,[R4, #+13]
   \   00000014   04D04DE2           SUB      SP,SP,#+4
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0800001A           BNE      ??FS__SB_Flush_0
   \   00000020   0E30D4E5           LDRB     R3,[R4, #+14]
   \   00000024   082094E5           LDR      R2,[R4, #+8]
   \   00000028   001094E5           LDR      R1,[R4, #+0]
   \   0000002C   040094E5           LDR      R0,[R4, #+4]
   \   00000030   ........           BL       FS_LB_WritePart
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0D50C415           STRBNE   R5,[R4, #+13]
   \   0000003C   0000A013           MOVNE    R0,#+0
   \   00000040   0C00C4E5           STRB     R0,[R4, #+12]
    239          }
   \                     ??FS__SB_Flush_0:
   \   00000044   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000048   3080BDE8           POP      {R4,R5,PC}       ;; return
    240          
    241          /*********************************************************************
    242          *
    243          *       FS__SB_Create
    244          *
    245          *  Function description
    246          *    Creates a Smart buffer
    247          */

   \                                 In section .text, align 4, keep-with-next
    248          char FS__SB_Create(FS_SB * pSB, FS_PARTITION * pPart) {
   \                     FS__SB_Create:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    249            U8   * pBuffer;
    250          
    251            FS_MEMSET(pSB, 0, sizeof(FS_SB));
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   0030A0E3           MOV      R3,#+0
   \   0000000C   00C0A0E3           MOV      R12,#+0
   \   00000010   00E0A0E3           MOV      LR,#+0
   \   00000014   0C50A0E8           STM      R0!,{R2,R3,R12,LR}
    252            pBuffer = FS__AllocSectorBuffer();
   \   00000018   ........           LDR      R12,??DataTable27
   \   0000001C   100040E2           SUB      R0,R0,#+16
   \   00000020   08E09CE5           LDR      LR,[R12, #+8]
   \   00000024   0CC09CE5           LDR      R12,[R12, #+12]
   \   00000028   0E40A0E1           MOV      R4,LR
   \   0000002C   000000EA           B        ??FS__SB_Create_0
   \                     ??FS__SB_Create_1:
   \   00000030   013083E2           ADD      R3,R3,#+1
   \                     ??FS__SB_Create_0:
   \   00000034   0C0053E1           CMP      R3,R12
   \   00000038   0800002A           BCS      ??FS__SB_Create_2
   \   0000003C   085094E4           LDR      R5,[R4], #+8
   \   00000040   000055E3           CMP      R5,#+0
   \   00000044   F9FFFF1A           BNE      ??FS__SB_Create_1
   \   00000048   01C0A0E3           MOV      R12,#+1
   \   0000004C   83C18EE7           STR      R12,[LR, +R3, LSL #+3]
   \   00000050   83318EE0           ADD      R3,LR,R3, LSL #+3
   \   00000054   043093E5           LDR      R3,[R3, #+4]
    253            if (pBuffer == NULL) {
   \   00000058   000053E3           CMP      R3,#+0
   \   0000005C   0100001A           BNE      ??FS__SB_Create_3
    254              FS_DEBUG_ERROROUT((FS_MTYPE_API, "FS_SB_Create: No sector buffer available.\n"));
    255              return 1;               /* Error, no buffer */
   \                     ??FS__SB_Create_2:
   \   00000060   0100A0E3           MOV      R0,#+1
   \   00000064   3080BDE8           POP      {R4,R5,PC}
    256            }
    257            pSB->pBuffer  = pBuffer;
   \                     ??FS__SB_Create_3:
   \   00000068   083080E5           STR      R3,[R0, #+8]
    258            pSB->pPart    = pPart;
   \   0000006C   041080E5           STR      R1,[R0, #+4]
    259            pSB->SectorNo = 0xFFFFFFFFUL;
   \   00000070   0210E0E1           MVN      R1,R2
   \   00000074   001080E5           STR      R1,[R0, #+0]
    260            pSB->Type     = FS_SB_TYPE_DATA;
   \   00000078   0E20C0E5           STRB     R2,[R0, #+14]
    261            return 0;               /* O.K. */
   \   0000007C   0000A0E3           MOV      R0,#+0
   \   00000080   3080BDE8           POP      {R4,R5,PC}       ;; return
    262          }
    263          
    264          /*********************************************************************
    265          *
    266          *       FS__SB_Delete
    267          */

   \                                 In section .text, align 4, keep-with-next
    268          void FS__SB_Delete(FS_SB * pSB) {
   \                     FS__SB_Delete:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    269            _SB_Clean(pSB);
   \   00000008   0D00D4E5           LDRB     R0,[R4, #+13]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0C00001A           BNE      ??FS__SB_Delete_0
   \   00000014   0C00D4E5           LDRB     R0,[R4, #+12]
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0900000A           BEQ      ??FS__SB_Delete_0
   \   00000020   0E30D4E5           LDRB     R3,[R4, #+14]
   \   00000024   082094E5           LDR      R2,[R4, #+8]
   \   00000028   001094E5           LDR      R1,[R4, #+0]
   \   0000002C   040094E5           LDR      R0,[R4, #+4]
   \   00000030   ........           BL       FS_LB_WritePart
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0100A013           MOVNE    R0,#+1
   \   0000003C   0D00C415           STRBNE   R0,[R4, #+13]
   \   00000040   0000A013           MOVNE    R0,#+0
   \   00000044   0C00C4E5           STRB     R0,[R4, #+12]
    270            FS__FreeSectorBuffer(pSB->pBuffer);
   \                     ??FS__SB_Delete_0:
   \   00000048   ........           LDR      R3,??DataTable27
   \   0000004C   080094E5           LDR      R0,[R4, #+8]
   \   00000050   08C093E5           LDR      R12,[R3, #+8]
   \   00000054   0010A0E3           MOV      R1,#+0
   \   00000058   0020A0E3           MOV      R2,#+0
   \   0000005C   04E08CE2           ADD      LR,R12,#+4
   \   00000060   0C3093E5           LDR      R3,[R3, #+12]
   \   00000064   000000EA           B        ??FS__SB_Delete_1
   \                     ??FS__SB_Delete_2:
   \   00000068   012082E2           ADD      R2,R2,#+1
   \                     ??FS__SB_Delete_1:
   \   0000006C   030052E1           CMP      R2,R3
   \   00000070   0300002A           BCS      ??FS__SB_Delete_3
   \   00000074   08409EE4           LDR      R4,[LR], #+8
   \   00000078   000054E1           CMP      R4,R0
   \   0000007C   F9FFFF1A           BNE      ??FS__SB_Delete_2
   \   00000080   82118CE7           STR      R1,[R12, +R2, LSL #+3]
    271          }
   \                     ??FS__SB_Delete_3:
   \   00000084   1080BDE8           POP      {R4,PC}          ;; return
    272          
    273          /*********************************************************************
    274          *
    275          *       FS__SB_Clean
    276          *
    277          *  Function description
    278          *    Cleans the smart buffer: If the buffer is marked as being dirty,
    279          *    it is written.
    280          */

   \                                 In section .text, align 4, keep-with-next
    281          void FS__SB_Clean(FS_SB * pSB) {
   \                     FS__SB_Clean:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    282            _SB_Clean(pSB);
   \   00000008   0D00D4E5           LDRB     R0,[R4, #+13]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0C00001A           BNE      ??FS__SB_Clean_0
   \   00000014   0C00D4E5           LDRB     R0,[R4, #+12]
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0900000A           BEQ      ??FS__SB_Clean_0
   \   00000020   0E30D4E5           LDRB     R3,[R4, #+14]
   \   00000024   082094E5           LDR      R2,[R4, #+8]
   \   00000028   001094E5           LDR      R1,[R4, #+0]
   \   0000002C   040094E5           LDR      R0,[R4, #+4]
   \   00000030   ........           BL       FS_LB_WritePart
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0100A013           MOVNE    R0,#+1
   \   0000003C   0D00C415           STRBNE   R0,[R4, #+13]
   \   00000040   0000A013           MOVNE    R0,#+0
   \   00000044   0C00C4E5           STRB     R0,[R4, #+12]
    283          }
   \                     ??FS__SB_Clean_0:
   \   00000048   1080BDE8           POP      {R4,PC}          ;; return
    284          /*********************************************************************
    285          *
    286          *       FS__SB_MarkDirty
    287          */

   \                                 In section .text, align 4, keep-with-next
    288          void FS__SB_MarkDirty(FS_SB * pSB) {
    289            pSB->IsDirty = 1;
   \                     FS__SB_MarkDirty:
   \   00000000   0110A0E3           MOV      R1,#+1
   \   00000004   0C10C0E5           STRB     R1,[R0, #+12]
    290          }
   \   00000008   1EFF2FE1           BX       LR               ;; return
    291          
    292          /*********************************************************************
    293          *
    294          *       FS__SB_SetWriteCopyOff
    295          *
    296          *  Function description
    297          *    Sets the "WriteCopyOffset", which is the offset of the sector to write a copy to.
    298          *    Typically used for FAT  sectors only.
    299          */
    300          #if FS_MAINTAIN_FAT_COPY
    301          void FS__SB_SetWriteCopyOff(FS_SB * pSB, U32 Off) {
    302            pSB->WriteCopyOff = Off;
    303          }
    304          #endif
    305          
    306          /*********************************************************************
    307          *
    308          *       FS__SB_SetSector
    309          *
    310          *  Function description
    311          *    Assigns a sector to a smart buffer.
    312          *
    313          */

   \                                 In section .text, align 4, keep-with-next
    314          void FS__SB_SetSector(FS_SB * pSB, U32 SectorNo, U8 Type) {
   \                     FS__SB_SetSector:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    315            if (SectorNo != pSB->SectorNo) {
   \   0000000C   001094E5           LDR      R1,[R4, #+0]
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   010055E1           CMP      R5,R1
   \   00000018   1200000A           BEQ      ??FS__SB_SetSector_0
    316              if (pSB->IsDirty) {
   \   0000001C   0C00D4E5           LDRB     R0,[R4, #+12]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0B00000A           BEQ      ??FS__SB_SetSector_1
    317                _SB_Clean(pSB);
   \   00000028   0D00D4E5           LDRB     R0,[R4, #+13]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0800001A           BNE      ??FS__SB_SetSector_1
   \   00000034   0E30D4E5           LDRB     R3,[R4, #+14]
   \   00000038   082094E5           LDR      R2,[R4, #+8]
   \   0000003C   040094E5           LDR      R0,[R4, #+4]
   \   00000040   ........           BL       FS_LB_WritePart
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0100A013           MOVNE    R0,#+1
   \   0000004C   0D00C415           STRBNE   R0,[R4, #+13]
   \   00000050   0000A013           MOVNE    R0,#+0
   \   00000054   0C00C4E5           STRB     R0,[R4, #+12]
    318              }
    319              pSB->SectorNo = SectorNo;
   \                     ??FS__SB_SetSector_1:
   \   00000058   005084E5           STR      R5,[R4, #+0]
    320              pSB->Type     = Type;
   \   0000005C   0E60C4E5           STRB     R6,[R4, #+14]
    321              pSB->Read     = 0;
   \   00000060   0000A0E3           MOV      R0,#+0
   \   00000064   0F00C4E5           STRB     R0,[R4, #+15]
    322          #if FS_MAINTAIN_FAT_COPY
    323              pSB->WriteCopyOff = 0;
    324          #endif
    325            }
    326          }
   \                     ??FS__SB_SetSector_0:
   \   00000068   7080BDE8           POP      {R4-R6,PC}       ;; return
    327          
    328          /*********************************************************************
    329          *
    330          *       FS__SB_MarkValid
    331          *
    332          *  Function description
    333          *    Marks a buffer as containing valid sector data.
    334          *    Useful if a buffer is filled and needs to be written later on.
    335          */

   \                                 In section .text, align 4, keep-with-next
    336          void FS__SB_MarkValid(FS_SB * pSB, U32 SectorNo, U8 Type) {
   \                     FS__SB_MarkValid:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    337            FS__SB_SetSector(pSB, SectorNo, Type);
   \   0000000C   001094E5           LDR      R1,[R4, #+0]
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   010055E1           CMP      R5,R1
   \   00000018   1200000A           BEQ      ??FS__SB_MarkValid_0
   \   0000001C   0C00D4E5           LDRB     R0,[R4, #+12]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0B00000A           BEQ      ??FS__SB_MarkValid_1
   \   00000028   0D00D4E5           LDRB     R0,[R4, #+13]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0800001A           BNE      ??FS__SB_MarkValid_1
   \   00000034   0E30D4E5           LDRB     R3,[R4, #+14]
   \   00000038   082094E5           LDR      R2,[R4, #+8]
   \   0000003C   040094E5           LDR      R0,[R4, #+4]
   \   00000040   ........           BL       FS_LB_WritePart
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0100A013           MOVNE    R0,#+1
   \   0000004C   0D00C415           STRBNE   R0,[R4, #+13]
   \   00000050   0000A013           MOVNE    R0,#+0
   \   00000054   0C00C4E5           STRB     R0,[R4, #+12]
   \                     ??FS__SB_MarkValid_1:
   \   00000058   005084E5           STR      R5,[R4, #+0]
   \   0000005C   0E60C4E5           STRB     R6,[R4, #+14]
   \   00000060   0000A0E3           MOV      R0,#+0
   \   00000064   0F00C4E5           STRB     R0,[R4, #+15]
    338            pSB->Read     = 1;
   \                     ??FS__SB_MarkValid_0:
   \   00000068   0100A0E3           MOV      R0,#+1
   \   0000006C   0F00C4E5           STRB     R0,[R4, #+15]
    339            pSB->IsDirty  = 1;
   \   00000070   0C00C4E5           STRB     R0,[R4, #+12]
    340          }
   \   00000074   7080BDE8           POP      {R4-R6,PC}       ;; return
    341          
    342          
    343          /*********************************************************************
    344          *
    345          *       FS__SB_MarkNotDirty
    346          *
    347          *  Function description
    348          *    Marks a buffer as containing valid sector data.
    349          *    Useful if a buffer is filled and needs to be written later on.
    350          */

   \                                 In section .text, align 4, keep-with-next
    351          void FS__SB_MarkNotDirty(FS_SB * pSB) {
    352            pSB->IsDirty  = 0;
   \                     FS__SB_MarkNotDirty:
   \   00000000   0010A0E3           MOV      R1,#+0
   \   00000004   0C10C0E5           STRB     R1,[R0, #+12]
    353          }
   \   00000008   1EFF2FE1           BX       LR               ;; return
    354          
    355          
    356          /*********************************************************************
    357          *
    358          *       FS__SB_Read
    359          *
    360          *  Return value
    361          *    0    O.K.
    362          *    !=0  Error
    363          */

   \                                 In section .text, align 4, keep-with-next
    364          char FS__SB_Read(FS_SB * pSB) {
   \                     FS__SB_Read:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    365            if (pSB->HasError) {
   \   00000008   0D00D4E5           LDRB     R0,[R4, #+13]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   000050E3           CMP      R0,#+0
    366              return 1;       /* Previous error, do not continue */
   \   00000014   0100A013           MOVNE    R0,#+1
   \   00000018   0E00001A           BNE      ??FS__SB_Read_0
    367            }
    368            if ((pSB->Read) == 0) {
   \   0000001C   0F00D4E5           LDRB     R0,[R4, #+15]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0A00001A           BNE      ??FS__SB_Read_1
    369              if (FS_LB_ReadPart(pSB->pPart, pSB->SectorNo, pSB->pBuffer, pSB->Type)) {
   \   00000028   0150A0E3           MOV      R5,#+1
   \   0000002C   0E30D4E5           LDRB     R3,[R4, #+14]
   \   00000030   082094E5           LDR      R2,[R4, #+8]
   \   00000034   001094E5           LDR      R1,[R4, #+0]
   \   00000038   040094E5           LDR      R0,[R4, #+4]
   \   0000003C   ........           BL       FS_LB_ReadPart
   \   00000040   000050E3           CMP      R0,#+0
    370                pSB->HasError = 1;
   \   00000044   0D50C415           STRBNE   R5,[R4, #+13]
    371                return 1;     /* Read failed */
   \   00000048   0100A013           MOVNE    R0,#+1
   \   0000004C   0100001A           BNE      ??FS__SB_Read_0
    372              } else {
    373                pSB->Read = 1;
   \   00000050   0F50C4E5           STRB     R5,[R4, #+15]
    374              }
    375            }
    376            return 0;       /* Sector read successfully */
   \                     ??FS__SB_Read_1:
   \   00000054   0000A0E3           MOV      R0,#+0
   \                     ??FS__SB_Read_0:
   \   00000058   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000005C   3080BDE8           POP      {R4,R5,PC}       ;; return
    377          }
    378          
    379          /*********************************************************************
    380          *
    381          *       FS__SB_Write
    382          *
    383          *  Return value
    384          *    0    O.K.
    385          *    !=0  Error
    386          */

   \                                 In section .text, align 4, keep-with-next
    387          char FS__SB_Write(FS_SB * pSB) {
   \                     FS__SB_Write:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    388            FS_DEBUG_ASSERT(FS_MTYPE_FS, pSB->SectorNo != 0xFFFFFFFF);
    389            if (pSB->HasError) {
   \   00000008   0D00D4E5           LDRB     R0,[R4, #+13]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0100000A           BEQ      ??FS__SB_Write_0
    390              return 1;       /* Previous error, do not continue */
   \   00000014   0100A0E3           MOV      R0,#+1
   \   00000018   1080BDE8           POP      {R4,PC}
    391            }
    392            if (FS_LB_WritePart(pSB->pPart, pSB->SectorNo, pSB->pBuffer, pSB->Type)) {
   \                     ??FS__SB_Write_0:
   \   0000001C   0E30D4E5           LDRB     R3,[R4, #+14]
   \   00000020   082094E5           LDR      R2,[R4, #+8]
   \   00000024   001094E5           LDR      R1,[R4, #+0]
   \   00000028   040094E5           LDR      R0,[R4, #+4]
   \   0000002C   ........           BL       FS_LB_WritePart
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0200000A           BEQ      ??FS__SB_Write_1
    393              pSB->HasError = 1;
   \   00000038   0100A0E3           MOV      R0,#+1
   \   0000003C   0D00C4E5           STRB     R0,[R4, #+13]
    394              return 1;     /* Write failed */
   \   00000040   1080BDE8           POP      {R4,PC}
    395            }
    396            pSB->IsDirty = 0;
   \                     ??FS__SB_Write_1:
   \   00000044   0C00C4E5           STRB     R0,[R4, #+12]
    397            return 0;       /* Sector written successfully */
   \   00000048   1080BDE8           POP      {R4,PC}          ;; return
    398          }
    399          
    400          
    401          /*********************************************************************
    402          *
    403          *       FS__AllocFileHandle
    404          *
    405          *  Function description:
    406          *    Returns a free file handle.
    407          *
    408          *  Return value:
    409          *    pFile      - A valid free file handle
    410          *
    411          */

   \                                 In section .text, align 4, keep-with-next
    412          FS_FILE * FS__AllocFileHandle(void) {
   \                     FS__AllocFileHandle:
   \   00000000   10402DE9           PUSH     {R4,LR}
    413            FS_FILE * pFile;
    414          
    415            FS_LOCK_SYS();
    416            pFile = FS_Global.pFirstFilehandle;
   \   00000004   ........           LDR      R0,??DataTable27
   \   00000008   144090E5           LDR      R4,[R0, #+20]
    417            while (1) { /* While no free entry found. */
    418              if (pFile->InUse == 0) {
   \                     ??FS__AllocFileHandle_0:
   \   0000000C   0A00D4E5           LDRB     R0,[R4, #+10]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0C0094E5           LDR      R0,[R4, #+12]
   \   00000018   0900001A           BNE      ??FS__AllocFileHandle_1
    419                FS_FILE * pNext;
    420                //
    421                // Save the pNext pointer to restore it back.
    422                //
    423                pNext = pFile->pNext;
    424                FS_MEMSET(pFile, 0, sizeof(FS_FILE));
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   0020A0E3           MOV      R2,#+0
   \   00000024   0030A0E3           MOV      R3,#+0
   \   00000028   00C0A0E3           MOV      R12,#+0
   \   0000002C   0E10A4E8           STM      R4!,{R1-R3,R12}
   \   00000030   104044E2           SUB      R4,R4,#+16
    425                pFile->InUse = 1;
   \   00000034   0110A0E3           MOV      R1,#+1
   \   00000038   0A10C4E5           STRB     R1,[R4, #+10]
    426                pFile->pNext = pNext;
   \   0000003C   0C0084E5           STR      R0,[R4, #+12]
    427                break;
   \   00000040   0E0000EA           B        ??FS__AllocFileHandle_2
    428              }
    429          #ifndef FS_TRIAL
    430              if (pFile->pNext == NULL) {
   \                     ??FS__AllocFileHandle_1:
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0900001A           BNE      ??FS__AllocFileHandle_3
    431                pFile->pNext = (FS_FILE *)FS_TryAlloc(sizeof(FS_FILE));
   \   0000004C   1000A0E3           MOV      R0,#+16
   \   00000050   ........           BL       FS_TryAlloc
   \   00000054   0C0084E5           STR      R0,[R4, #+12]
    432                //
    433                // Check if we got a valid pointer.
    434                //
    435                if (pFile->pNext) {
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0400000A           BEQ      ??FS__AllocFileHandle_3
    436                  FS_MEMSET(pFile->pNext, 0, sizeof(FS_FILE));
   \   00000060   0010A0E3           MOV      R1,#+0
   \   00000064   0020A0E3           MOV      R2,#+0
   \   00000068   0030A0E3           MOV      R3,#+0
   \   0000006C   00C0A0E3           MOV      R12,#+0
   \   00000070   0E10A0E8           STM      R0!,{R1-R3,R12}
    437                }
    438              }
    439          #endif
    440              pFile = pFile->pNext;
   \                     ??FS__AllocFileHandle_3:
   \   00000074   0C4094E5           LDR      R4,[R4, #+12]
    441              //
    442              // Neither a free file handle found
    443              // nor enough space to allocate a new one.
    444              //
    445              if (pFile == NULL) {
   \   00000078   000054E3           CMP      R4,#+0
   \   0000007C   E2FFFF1A           BNE      ??FS__AllocFileHandle_0
    446                break;
    447              }
    448            }
    449            FS_UNLOCK_SYS();
    450            return pFile;
   \                     ??FS__AllocFileHandle_2:
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   1080BDE8           POP      {R4,PC}          ;; return
    451          }
    452          
    453          /*********************************************************************
    454          *
    455          *       FS__FreeFileHandle
    456          *
    457          *  Function description:
    458          *    Closes the file handle and mark it as free.
    459          *
    460          *  Parameters:
    461          *    pFile       - Pointer to an opened file handle.
    462          *
    463          */

   \                                 In section .text, align 4, keep-with-next
    464          void FS__FreeFileHandle(FS_FILE * pFile) {
    465            if (pFile) {
   \                     FS__FreeFileHandle:
   \   00000000   000050E3           CMP      R0,#+0
    466              FS_LOCK_SYS();
    467              pFile->InUse = 0;
   \   00000004   0010A013           MOVNE    R1,#+0
   \   00000008   0A10C015           STRBNE   R1,[R0, #+10]
    468              pFile->pFileObj = (FS_FILE_OBJ*)NULL;
   \   0000000C   00108015           STRNE    R1,[R0, #+0]
    469              FS_UNLOCK_SYS();
    470            }
    471          }
   \   00000010   1EFF2FE1           BX       LR               ;; return
    472          
    473          
    474          /*********************************************************************
    475          *
    476          *       FS__AllocFileObj
    477          *
    478          *  Function description:
    479          *    Returns a free file handle.
    480          *
    481          *  Parameter(s)
    482          *    sFullFileName    Points to a full file name. May NOT be NULL.
    483          *
    484          *  Return value:
    485          *    pFileObj   - A valid free file Obj
    486          *
    487          */

   \                                 In section .text, align 4, keep-with-next
    488          FS_FILE_OBJ * FS__AllocFileObj(const char * sFullFileName) {
   \                     FS__AllocFileObj:
   \   00000000   10402DE9           PUSH     {R4,LR}
    489            FS_FILE_OBJ * pFileObj;
    490          
    491            /*  Find next free entry */
    492            FS_LOCK_SYS();
    493            pFileObj = FS_Global.pFirstFileObj;
   \   00000004   ........           LDR      R0,??DataTable27
   \   00000008   184090E5           LDR      R4,[R0, #+24]
    494            while (1) {
    495              if (pFileObj->UseCnt == 0) {
   \                     ??FS__AllocFileObj_0:
   \   0000000C   0C00D4E5           LDRB     R0,[R4, #+12]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0C00001A           BNE      ??FS__AllocFileObj_1
    496                //
    497                // Init File object
    498                //
    499                pFileObj->FirstCluster = 0;
   \   00000018   000084E5           STR      R0,[R4, #+0]
    500                pFileObj->Size         = 0;
   \   0000001C   040084E5           STR      R0,[R4, #+4]
    501                pFileObj->pVolume      = NULL;
   \   00000020   080084E5           STR      R0,[R4, #+8]
    502                FS_MEMSET(&pFileObj->Data, 0, sizeof(pFileObj->Data));
   \   00000024   100084E2           ADD      R0,R4,#+16
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   0020A0E3           MOV      R2,#+0
   \   00000030   0030A0E3           MOV      R3,#+0
   \   00000034   0E00A0E8           STM      R0!,{R1-R3}
   \   00000038   0600A0E8           STM      R0!,{R1,R2}
    503                pFileObj->UseCnt++;
   \   0000003C   0C00D4E5           LDRB     R0,[R4, #+12]
   \   00000040   010080E2           ADD      R0,R0,#+1
   \   00000044   0C00C4E5           STRB     R0,[R4, #+12]
    504          #if FS_MULTI_HANDLE_SAFE
    505                FS_STRCPY(pFileObj->acFullFileName, sFullFileName);
    506          #else
    507                FS_USE_PARA(sFullFileName);
    508          #endif
    509                break;
   \   00000048   0C0000EA           B        ??FS__AllocFileObj_2
    510              }
    511          #ifndef FS_TRIAL
    512              if (pFileObj->pNext == NULL) {
   \                     ??FS__AllocFileObj_1:
   \   0000004C   280094E5           LDR      R0,[R4, #+40]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   0600001A           BNE      ??FS__AllocFileObj_3
    513                pFileObj->pNext = (FS_FILE_OBJ *)FS_TryAlloc(sizeof(FS_FILE_OBJ));
   \   00000058   2C00A0E3           MOV      R0,#+44
   \   0000005C   ........           BL       FS_TryAlloc
   \   00000060   280084E5           STR      R0,[R4, #+40]
    514                //
    515                // Check if we got a valid pointer.
    516                //
    517                if (pFileObj->pNext) {
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   0100000A           BEQ      ??FS__AllocFileObj_3
    518                  FS_MEMSET(pFileObj->pNext, 0, sizeof(FS_FILE_OBJ));
   \   0000006C   2C10A0E3           MOV      R1,#+44
   \   00000070   ........           BL       __aeabi_memclr4
    519                }
    520              }
    521          #endif
    522              pFileObj = pFileObj->pNext;
   \                     ??FS__AllocFileObj_3:
   \   00000074   284094E5           LDR      R4,[R4, #+40]
    523              //
    524              // Neither a free file handle found
    525              // nor enough space to allocate a new one.
    526              //
    527              if (pFileObj == NULL) {
   \   00000078   000054E3           CMP      R4,#+0
   \   0000007C   E2FFFF1A           BNE      ??FS__AllocFileObj_0
    528                break;
    529              }
    530            }
    531            FS_UNLOCK_SYS();
    532            return pFileObj;
   \                     ??FS__AllocFileObj_2:
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   1080BDE8           POP      {R4,PC}          ;; return
    533          }
    534          
    535          /*********************************************************************
    536          *
    537          *       FS__GetFileObj
    538          *
    539          *  Function description:
    540          *    Returns a free file handle.
    541          *
    542          *  Return value:
    543          *    pFileObj     - A valid file obj
    544          *
    545          */

   \                                 In section .text, align 4, keep-with-next
    546          FS_FILE_OBJ * FS__GetFileObj(const char * sFullFileName) {
    547            FS_FILE_OBJ * pFileObj;
    548          #if FS_MULTI_HANDLE_SAFE
    549            pFileObj = FS_Global.pFirstFileObj;
    550            /*  Find next free entry */
    551            FS_LOCK_SYS();
    552            while (pFileObj) {
    553              if (FS_STRCMP(sFullFileName, pFileObj->acFullFileName) == 0) {
    554                pFileObj->UseCnt++;
    555                break;
    556              }
    557              pFileObj = pFileObj->pNext;
    558            }
    559            FS_UNLOCK_SYS();
    560          #else
    561            FS_USE_PARA(sFullFileName);
    562            pFileObj = (FS_FILE_OBJ *)NULL;
    563          #endif
    564            return pFileObj;
   \                     FS__GetFileObj:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return
    565          }
    566          
    567          /*********************************************************************
    568          *
    569          *       FS__FreeFileObj
    570          *
    571          *  Function description:
    572          *    Closes the file object.
    573          *
    574          *  Parameters:
    575          *    pFile       - Pointer to an open file obj.
    576          *
    577          */

   \                                 In section .text, align 4, keep-with-next
    578          void FS__FreeFileObj(FS_FILE_OBJ * pFileObj) {
    579            if (pFileObj) {
   \                     FS__FreeFileObj:
   \   00000000   000050E3           CMP      R0,#+0
    580              FS_LOCK_SYS();
    581              if (pFileObj->UseCnt) {
   \   00000004   0C10D015           LDRBNE   R1,[R0, #+12]
   \   00000008   00005113           CMPNE    R1,#+0
    582                pFileObj->UseCnt--;
   \   0000000C   01104112           SUBNE    R1,R1,#+1
   \   00000010   0C10C015           STRBNE   R1,[R0, #+12]
    583              }
    584          #if FS_MULTI_HANDLE_SAFE
    585              if (pFileObj->UseCnt == 0) {
    586                //
    587                // Empty string when this file object is not used anymore.
    588                //
    589                pFileObj->acFullFileName[0] = '\0';
    590              }
    591          #endif
    592              FS_UNLOCK_SYS();
    593            }
    594          }
   \   00000014   1EFF2FE1           BX       LR               ;; return
    595          
    596          /*********************************************************************
    597          *
    598          *       _BuildFullFileName
    599          *
    600          *  Function description
    601          *    Stores the full filename (including volume and path) into the destination
    602          *    Buffer
    603          *
    604          *  Return value:
    605          *    0      O.K.
    606          *    1
    607          */
    608          #if FS_MULTI_HANDLE_SAFE
    609          static int _BuildFullFileName(FS_VOLUME * pVolume, const char * sFileName, char * sDest) {
    610            int Len;
    611            int Len1;
    612            const char * sDriverName;
    613            FS_DEVICE  * pDevice;
    614          
    615            if (pVolume == (FS_VOLUME *)NULL) {
    616              return 1;
    617            }
    618          
    619            pDevice = &pVolume->Partition.Device;
    620            sDriverName = pDevice->pType->pfGetName(pDevice->Data.Unit);
    621            Len = FS_STRLEN(sDriverName);
    622            FS_STRCPY(sDest, sDriverName);
    623            *(sDest + Len++) = ':';
    624            *(sDest + Len++) = '0' + pDevice->Data.Unit;
    625            *(sDest + Len++) = ':';
    626            Len1 = FS_STRLEN(sFileName);
    627            if ((Len1 + Len) >= FS_MAX_LEN_FULL_FILE_NAME) {
    628              FS_DEBUG_ERROROUT((FS_MTYPE_API,"_BuildFullFileName: sFileName is too long to store in sDest."));
    629              return 1;   /* Error: file name is too long to store in sDest */
    630            }
    631            if (*sFileName != FS_DIRECTORY_DELIMITER) {
    632              *(sDest + Len++) = FS_DIRECTORY_DELIMITER;
    633            }
    634            FS_STRCPY((sDest + Len), sFileName);
    635            return 0;
    636          }
    637          #endif
    638          
    639          /*********************************************************************
    640          *
    641          *       FS__FTell
    642          *
    643          *  Function description:
    644          *    Internal version if FS_FTell
    645          *    Return position of a file pointer.
    646          *
    647          *  Parameters:
    648          *    pFile         - Pointer to a FS_FILE data structure.
    649          *
    650          *  Return value:
    651          *    >=0           - Current position of the file pointer.
    652          *    ==-1          - An error has occurred.
    653          */

   \                                 In section .text, align 4, keep-with-next
    654          I32 FS__FTell(FS_FILE *pFile) {
    655            I32 r;
    656            r = -1;
   \                     FS__FTell:
   \   00000000   0010E0E3           MVN      R1,#+0
    657            if (pFile) {
   \   00000004   000050E3           CMP      R0,#+0
    658              FS_LOCK_SYS();
    659              r =  pFile->FilePos;
   \   00000008   04109015           LDRNE    R1,[R0, #+4]
    660              FS_UNLOCK_SYS();
    661            }
    662            return r;
   \   0000000C   0100A0E1           MOV      R0,R1
   \   00000010   1EFF2FE1           BX       LR               ;; return
    663          }
    664          
    665          /*********************************************************************
    666          *
    667          *       FS__FCloseNL
    668          *
    669          *  Function description:
    670          *    Internal version of FS_FClose.
    671          *    Close a file referred by pFile.
    672          *
    673          *  Parameters:
    674          *    pFile       - Pointer to a FS_FILE data structure.
    675          *
    676          *  Return value:
    677          *    1           - Error, File handle can not be closed.
    678          *    0           - File handle has been closed.
    679          */

   \                                 In section .text, align 4, keep-with-next
    680          int FS__FCloseNL(FS_FILE *pFile) {
   \                     FS__FCloseNL:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    681            if (pFile->InUse) {
   \   00000008   0A00D4E5           LDRB     R0,[R4, #+10]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0C00000A           BEQ      ??FS__FCloseNL_0
    682              FS_FILE_OBJ * pFileObj;
    683          
    684              pFileObj = pFile->pFileObj;
   \   00000018   005094E5           LDR      R5,[R4, #+0]
    685              FS_CLOSE_FILE(pFile);  /* Execute the FSL function */
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       FS_FAT_Close
    686              FS__FreeFileObj(pFileObj);
   \   00000024   000055E3           CMP      R5,#+0
   \   00000028   0C00D515           LDRBNE   R0,[R5, #+12]
   \   0000002C   00005013           CMPNE    R0,#+0
   \   00000030   01004012           SUBNE    R0,R0,#+1
   \   00000034   0C00C515           STRBNE   R0,[R5, #+12]
    687              FS__FreeFileHandle(pFile);
   \   00000038   000054E3           CMP      R4,#+0
   \   0000003C   0000A013           MOVNE    R0,#+0
   \   00000040   0A00C415           STRBNE   R0,[R4, #+10]
   \   00000044   00008415           STRNE    R0,[R4, #+0]
    688            }
    689            return 0;
   \   00000048   0000A0E3           MOV      R0,#+0
   \                     ??FS__FCloseNL_0:
   \   0000004C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000050   3080BDE8           POP      {R4,R5,PC}       ;; return
    690          }
    691          
    692          /*********************************************************************
    693          *
    694          *       FS__FClose
    695          *
    696          *  Function description:
    697          *    Internal version of FS_FClose.
    698          *    Close a file referred by pFile.
    699          *
    700          *  Parameters:
    701          *    pFile       - Pointer to a FS_FILE data structure.
    702          *
    703          *  Return value:
    704          *    1           - Error, File handle can not be closed.
    705          *    0           - File handle has been closed.
    706          */

   \                                 In section .text, align 4, keep-with-next
    707          int FS__FClose(FS_FILE *pFile) {
   \                     FS__FClose:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    708            FS_FILE_OBJ * pFileObj;
    709            FS_DEVICE   * pDevice;
    710            FS_VOLUME   * pVolume;
    711            char          InUse;
    712          
    713            pVolume = (FS_VOLUME *)NULL;
    714            pDevice = (FS_DEVICE *)NULL;
    715            FS_LOCK_SYS();
    716            InUse = pFile->InUse;
    717            pFileObj = pFile->pFileObj;
   \   00000008   006094E5           LDR      R6,[R4, #+0]
   \   0000000C   0A10D4E5           LDRB     R1,[R4, #+10]
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   0620B0E1           MOVS     R2,R6
    718            if (pFileObj) {
    719              pVolume  = pFileObj->pVolume;
   \   00000018   08009615           LDRNE    R0,[R6, #+8]
    720            }
    721            if (pVolume) {
    722              pDevice  = &pVolume->Partition.Device;
    723            }
    724            FS_UNLOCK_SYS();
    725            if ((InUse == 0) || (pVolume == NULL)) {
   \   0000001C   000051E3           CMP      R1,#+0
   \   00000020   0050A0E3           MOV      R5,#+0
   \   00000024   00005013           CMPNE    R0,#+0
   \   00000028   0100001A           BNE      ??FS__FClose_0
    726              return 1;
   \   0000002C   0100A0E3           MOV      R0,#+1
   \   00000030   7080BDE8           POP      {R4-R6,PC}
    727            }
   \                     ??FS__FClose_0:
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       FS_FAT_Close
   \   0000003C   000056E3           CMP      R6,#+0
   \   00000040   0C00D615           LDRBNE   R0,[R6, #+12]
   \   00000044   00005013           CMPNE    R0,#+0
   \   00000048   01004012           SUBNE    R0,R0,#+1
   \   0000004C   0C00C615           STRBNE   R0,[R6, #+12]
   \   00000050   000054E3           CMP      R4,#+0
   \   00000054   0A50C415           STRBNE   R5,[R4, #+10]
   \   00000058   00508415           STRNE    R5,[R4, #+0]
    728            FS_USE_PARA(pDevice);
    729            FS_USE_PARA(pVolume);
    730            FS_LOCK_DRIVER(pDevice);
    731          #if FS_OS_LOCK_PER_DRIVER
    732            FS_LOCK_SYS();
    733            if (pFileObj != pFile->pFileObj) {
    734              InUse = 0;
    735            }
    736            if (pFile->InUse == 0) {
    737              InUse = 0;
    738            }
    739            FS_UNLOCK_SYS();
    740            if (InUse == 0) {      // Let's make sure the file is still valid
    741              FS_DEBUG_ERROROUT((FS_MTYPE_API,"Application error: File handle has been invalidated by other thread during wait"));
    742              FS_UNLOCK_DRIVER(pDevice);
    743              return 1;
    744          
    745            } else
    746          #endif
    747            {
    748              FS_JOURNAL_BEGIN (pVolume);
    749              FS__FCloseNL(pFile);
    750              FS_JOURNAL_END (pVolume);
    751            }
    752            FS_UNLOCK_DRIVER(pDevice);
    753            return 0;
   \   0000005C   0000A0E3           MOV      R0,#+0
   \   00000060   7080BDE8           POP      {R4-R6,PC}       ;; return
    754          }
    755          
    756          
    757          /*********************************************************************
    758          *
    759          *       _FSeekNL
    760          *
    761          *  Function description:
    762          *    Internal version of FS_FSeek
    763          *    Set current position of a file pointer.
    764          *
    765          *  Parameters:
    766          *    pFile       - Pointer to a FS_FILE data structure.
    767          *    Offset      - Offset for setting the file pointer position.
    768          *    Origin      - Mode for positioning the file pointer.
    769          *
    770          *  Return value:
    771          *    ==0         - File pointer has been positioned according to the
    772          *                  parameters.
    773          *    ==-1        - An error has occurred.
    774          */
    775          static int _FSeekNL(FS_FILE *pFile, I32 Offset, int Origin) {
    776            U32  uOffset;
    777          
    778            uOffset = (U32)Offset;
    779            if (pFile == NULL) {
    780              return -1;
    781            }
    782            switch (Origin) {
    783            case FS_SEEK_SET:
    784              break;
    785            case FS_SEEK_CUR:
    786              uOffset += pFile->FilePos;
    787              break;
    788            case FS_SEEK_END:
    789              uOffset += pFile->pFileObj->Size;
    790              break;
    791            default:
    792              pFile->Error = FS_ERR_INVALIDPAR;
    793              FS_DEBUG_WARN((FS_MTYPE_API, "FS__FSeek: Illegal parameter"));
    794              return -1;
    795            }
    796            if (pFile->FilePos != uOffset) {
    797              pFile->FilePos  = uOffset;
    798              pFile->Error    = FS_ERR_OK;    /* Clear any previous error */
    799            }
    800            return 0;
    801          }
    802          
    803          /*********************************************************************
    804          *
    805          *       FS__FSeek
    806          *
    807          *  Function description:
    808          *    Internal version of FS_FSeek
    809          *    Set current position of a file pointer.
    810          *
    811          *  Parameters:
    812          *    pFile       - Pointer to a FS_FILE data structure.
    813          *    Offset      - Offset for setting the file pointer position.
    814          *    Origin      - Mode for positioning the file pointer.
    815          *
    816          *  Return value:
    817          *    ==0         - File pointer has been positioned according to the
    818          *                  parameters.
    819          *    ==-1        - An error has occurred.
    820          */

   \                                 In section .text, align 4, keep-with-next
    821          int FS__FSeek(FS_FILE *pFile, I32 Offset, int Origin) {
    822            int r;
    823          
    824            FS_LOCK_SYS();
    825            r = _FSeekNL(pFile, Offset, Origin);
   \                     FS__FSeek:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1500000A           BEQ      ??FS__FSeek_0
   \   00000008   000052E3           CMP      R2,#+0
   \   0000000C   0800000A           BEQ      ??FS__FSeek_1
   \   00000010   020052E3           CMP      R2,#+2
   \   00000014   0100000A           BEQ      ??FS__FSeek_2
   \   00000018   0300003A           BCC      ??FS__FSeek_3
   \   0000001C   0B0000EA           B        ??FS__FSeek_4
   \                     ??FS__FSeek_2:
   \   00000020   002090E5           LDR      R2,[R0, #+0]
   \   00000024   042092E5           LDR      R2,[R2, #+4]
   \   00000028   000000EA           B        ??FS__FSeek_5
   \                     ??FS__FSeek_3:
   \   0000002C   042090E5           LDR      R2,[R0, #+4]
   \                     ??FS__FSeek_5:
   \   00000030   011082E0           ADD      R1,R2,R1
   \                     ??FS__FSeek_1:
   \   00000034   042090E5           LDR      R2,[R0, #+4]
   \   00000038   010052E1           CMP      R2,R1
   \   0000003C   04108015           STRNE    R1,[R0, #+4]
   \   00000040   0010A013           MOVNE    R1,#+0
   \   00000044   B810C011           STRHNE   R1,[R0, #+8]
   \   00000048   0000A0E3           MOV      R0,#+0
   \   0000004C   1EFF2FE1           BX       LR
   \                     ??FS__FSeek_4:
   \   00000050   0210E0E3           MVN      R1,#+2
   \   00000054   B810C0E1           STRH     R1,[R0, #+8]
   \   00000058   020081E3           ORR      R0,R1,#0x2
   \   0000005C   1EFF2FE1           BX       LR
   \                     ??FS__FSeek_0:
   \   00000060   0000E0E3           MVN      R0,#+0
    826            FS_UNLOCK_SYS();
    827            return r;
   \   00000064   1EFF2FE1           BX       LR               ;; return
    828          }
    829          
    830          /*********************************************************************
    831          *
    832          *       FS__CalcSizeInBytes
    833          *
    834          *  Function description
    835          *     Given the numbers of clusters, sectors per cluster and bytes per sector,
    836          *     calculate the equivalent number of bytes.
    837          *
    838          *  Parameters:
    839          *     NumClusters         - The Number of sectors
    840          *     SectorsPerCluster   - The number of sectors in a cluster
    841          *     BytesPerSector      - The number of bytes in a sector
    842          *
    843          *  Return value:
    844          *     The number of bytes, or if the number would exceed the range U32
    845          *     can represent, return 0xFFFFFFFF
    846          */

   \                                 In section .text, align 4, keep-with-next
    847          U32 FS__CalcSizeInBytes(U32 NumClusters, U32 SectorsPerCluster, U32 BytesPerSector) {
    848            if (_CalcSizeInKB(NumClusters, SectorsPerCluster, BytesPerSector) < 0x400000UL) {
   \                     FS__CalcSizeInBytes:
   \   00000000   920103E0           MUL      R3,R2,R1
   \   00000004   0AC0A0E3           MOV      R12,#+10
   \                     ??FS__CalcSizeInBytes_0:
   \   00000008   010053E3           CMP      R3,#+1
   \   0000000C   A330A011           LSRNE    R3,R3,#+1
   \   00000010   01C05C12           SUBSNE   R12,R12,#+1
   \   00000014   FBFFFF1A           BNE      ??FS__CalcSizeInBytes_0
   \   00000018   30CCA0E1           LSR      R12,R0,R12
   \   0000001C   9C0303E0           MUL      R3,R12,R3
   \   00000020   400853E3           CMP      R3,#+4194304
   \   00000024   0200002A           BCS      ??FS__CalcSizeInBytes_1
    849              return NumClusters * SectorsPerCluster * BytesPerSector;
   \   00000028   910000E0           MUL      R0,R1,R0
   \   0000002C   920000E0           MUL      R0,R2,R0
   \   00000030   1EFF2FE1           BX       LR
    850            } else {
    851              return 0xFFFFFFFFUL;    // Max. value of U32. The size in bytes does not fit into a U32.
   \                     ??FS__CalcSizeInBytes_1:
   \   00000034   0000E0E3           MVN      R0,#+0
   \   00000038   1EFF2FE1           BX       LR               ;; return
    852            }
    853          }
    854          
    855          /*********************************************************************
    856          *
    857          *       FS__CalcSizeInKB
    858          *
    859          *  Function description
    860          *     Given the numbers of clusters, sectors per cluster and bytes per sector,
    861          *     calculate the equivalent number of KBytes.
    862          *
    863          *  Parameters:
    864          *     NumClusters         - The Number of sectors
    865          *     SectorsPerCluster   - The number of sectors in a cluster
    866          *     BytesPerSector      - The number of bytes in a sector
    867          *
    868          *  Return value:
    869          *     The value in KBytes.
    870          */

   \                                 In section .text, align 4, keep-with-next
    871          U32 FS__CalcSizeInKB(U32 NumClusters, U32 SectorsPerCluster, U32 BytesPerSector) {
    872            U32 v;
    873          
    874            v = _CalcSizeInKB(NumClusters, SectorsPerCluster, BytesPerSector);
   \                     FS__CalcSizeInKB:
   \   00000000   920101E0           MUL      R1,R2,R1
   \   00000004   0A20A0E3           MOV      R2,#+10
   \                     ??FS__CalcSizeInKB_0:
   \   00000008   010051E3           CMP      R1,#+1
   \   0000000C   A110A011           LSRNE    R1,R1,#+1
   \   00000010   01205212           SUBSNE   R2,R2,#+1
   \   00000014   FBFFFF1A           BNE      ??FS__CalcSizeInKB_0
    875            return v;
   \   00000018   3022A0E1           LSR      R2,R0,R2
   \   0000001C   920100E0           MUL      R0,R2,R1
   \   00000020   1EFF2FE1           BX       LR               ;; return
    876          }
    877          
    878          /*********************************************************************
    879          *
    880          *       FS__Remove
    881          *
    882          *  Function description:
    883          *    Internal version of FS_Remove
    884          *    Removes a file.
    885          *    There is no real 'delete' function in the FSL, but the FSL's 'open'
    886          *    function can delete a file.
    887          *
    888          *  Parameters:
    889          *    pFileName   - Fully qualified file name.
    890          *
    891          *  Return value:
    892          *    ==0         - File has been removed.
    893          *    ==-1        - An error has occurred.
    894          */

   \                                 In section .text, align 4, keep-with-next
    895          int FS__Remove(const char *pFileName) {
   \                     FS__Remove:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
    896            int r;
    897            FS_FILE * pFile;
    898            r = -1;
    899          
    900            pFile = FS__FOpenEx(pFileName, FS_FILE_ACCESS_FLAG_W, 0, 1, 0);
   \   00000008   0040A0E3           MOV      R4,#+0
   \   0000000C   0050E0E3           MVN      R5,#+0
   \   00000010   08408DE5           STR      R4,[SP, #+8]
   \   00000014   08108DE2           ADD      R1,SP,#+8
   \   00000018   ........           BL       FS__FindVolume
   \   0000001C   0060B0E1           MOVS     R6,R0
   \   00000020   2200000A           BEQ      ??FS__Remove_0
   \   00000024   08009DE5           LDR      R0,[SP, #+8]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0200000A           BEQ      ??FS__Remove_1
   \   00000030   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   1C00000A           BEQ      ??FS__Remove_0
   \                     ??FS__Remove_1:
   \   0000003C   0600A0E1           MOV      R0,R6
   \   00000040   ........           BL       FS__AutoMount
   \   00000044   010050E3           CMP      R0,#+1
   \   00000048   180000BA           BLT      ??FS__Remove_0
   \   0000004C   030050E3           CMP      R0,#+3
   \   00000050   1600001A           BNE      ??FS__Remove_0
   \   00000054   08109DE5           LDR      R1,[SP, #+8]
   \   00000058   0000A0E3           MOV      R0,#+0
   \   0000005C   000051E3           CMP      R1,#+0
   \   00000060   0700000A           BEQ      ??FS__Remove_2
   \   00000064   04008DE5           STR      R0,[SP, #+4]
   \   00000068   0100A0E3           MOV      R0,#+1
   \   0000006C   00008DE5           STR      R0,[SP, #+0]
   \   00000070   0030A0E3           MOV      R3,#+0
   \   00000074   1020A0E3           MOV      R2,#+16
   \   00000078   08109DE5           LDR      R1,[SP, #+8]
   \   0000007C   0600A0E1           MOV      R0,R6
   \   00000080   ........           BL       FS__OpenEx
    901            if (pFile) {
   \                     ??FS__Remove_2:
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0800000A           BEQ      ??FS__Remove_0
    902              FS__FreeFileObj(pFile->pFileObj);
   \   0000008C   001090E5           LDR      R1,[R0, #+0]
    903              FS__FreeFileHandle(pFile);
    904              r = 0;
   \   00000090   0050A0E3           MOV      R5,#+0
   \   00000094   000051E3           CMP      R1,#+0
   \   00000098   0C20D115           LDRBNE   R2,[R1, #+12]
   \   0000009C   00005213           CMPNE    R2,#+0
   \   000000A0   01204212           SUBNE    R2,R2,#+1
   \   000000A4   0C20C115           STRBNE   R2,[R1, #+12]
   \   000000A8   0A40C0E5           STRB     R4,[R0, #+10]
   \   000000AC   004080E5           STR      R4,[R0, #+0]
    905            }
    906            return r;
   \                     ??FS__Remove_0:
   \   000000B0   0500A0E1           MOV      R0,R5
   \   000000B4   10D08DE2           ADD      SP,SP,#+16
   \   000000B8   7080BDE8           POP      {R4-R6,PC}       ;; return
    907          }
    908          
    909          
    910          /*********************************************************************
    911          *
    912          *       FS__OpenEx
    913          *
    914          *  Function description:
    915          *    Either opens an existing file or create a new one or delete
    916          *    a file existing file.
    917          *
    918          *  Parameters:
    919          *    pVolume     - Pointer to a volume structure.
    920          *    sFilePath   - String to the relative path of the file.
    921          *    AccessFlags - Type of Access.
    922          *    DoCreate    - Shall the file be created.
    923          *    DoDel       - Shall the existing file be deleted.
    924          *    DoOpen      - Shall the file be opened.
    925          *
    926          *  Return value:
    927          *    ==0         - Unable to open the file.
    928          *    !=0         - Address of an FS_FILE data structure.
    929          */

   \                                 In section .text, align 4, keep-with-next
    930          FS_FILE * FS__OpenEx(FS_VOLUME * pVolume, const char * sFilePath, U8 AccessFlags, char DoCreate, char DoDel, char DoOpen) {
   \                     FS__OpenEx:
   \   00000000   F54F2DE9           PUSH     {R0,R2,R4-R11,LR}
    931            FS_FILE      * pFile;
    932            FS_FILE_OBJ  * pFileObj;
    933            int            r;
    934          
    935            pFile    = NULL;
    936            pFileObj = NULL;
    937            /* Find correct FSL  (device:unit:name) */
    938            //
    939            // Allocate file object.
    940            // The procedure depends. If multiple handles per file are allowed, we first need to check if
    941            // the file is already open.
    942            //
    943          #if FS_MULTI_HANDLE_SAFE
    944            {
    945              char ac[FS_MAX_LEN_FULL_FILE_NAME];
    946              if (_BuildFullFileName(pVolume, sFilePath, ac)) {
    947                goto Error;
    948              }
    949              /* Find file obj (if the file is already open), else alloc one */
    950              pFileObj = FS__GetFileObj(ac);
    951              if ((void*)pFileObj == NULL) {
    952                pFileObj = FS__AllocFileObj(ac);
    953              }
    954            }
    955          #else
    956            pFileObj = FS__AllocFileObj(NULL);
   \   00000004   ........           LDR      R11,??DataTable27
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0350A0E1           MOV      R5,R3
   \   00000014   3060DDE5           LDRB     R6,[SP, #+48]
   \   00000018   3470DDE5           LDRB     R7,[SP, #+52]
   \   0000001C   0080A0E3           MOV      R8,#+0
   \   00000020   18909BE5           LDR      R9,[R11, #+24]
   \                     ??FS__OpenEx_0:
   \   00000024   0C00D9E5           LDRB     R0,[R9, #+12]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0D00000A           BEQ      ??FS__OpenEx_1
   \   00000030   280099E5           LDR      R0,[R9, #+40]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0600001A           BNE      ??FS__OpenEx_2
   \   0000003C   2C00A0E3           MOV      R0,#+44
   \   00000040   ........           BL       FS_TryAlloc
   \   00000044   280089E5           STR      R0,[R9, #+40]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0100000A           BEQ      ??FS__OpenEx_2
   \   00000050   2C10A0E3           MOV      R1,#+44
   \   00000054   ........           BL       __aeabi_memclr4
   \                     ??FS__OpenEx_2:
   \   00000058   289099E5           LDR      R9,[R9, #+40]
   \   0000005C   000059E3           CMP      R9,#+0
   \   00000060   EFFFFF1A           BNE      ??FS__OpenEx_0
   \   00000064   0B0000EA           B        ??FS__OpenEx_3
   \                     ??FS__OpenEx_1:
   \   00000068   008089E5           STR      R8,[R9, #+0]
   \   0000006C   048089E5           STR      R8,[R9, #+4]
   \   00000070   088089E5           STR      R8,[R9, #+8]
   \   00000074   100089E2           ADD      R0,R9,#+16
   \   00000078   0010A0E3           MOV      R1,#+0
   \   0000007C   0020A0E3           MOV      R2,#+0
   \   00000080   0030A0E3           MOV      R3,#+0
   \   00000084   0E00A0E8           STM      R0!,{R1-R3}
   \   00000088   0600A0E8           STM      R0!,{R1,R2}
   \   0000008C   0C00D9E5           LDRB     R0,[R9, #+12]
   \   00000090   010080E2           ADD      R0,R0,#+1
   \   00000094   0C00C9E5           STRB     R0,[R9, #+12]
    957          #endif
    958            if ((void *)pFileObj == NULL) {
   \                     ??FS__OpenEx_3:
   \   00000098   000059E3           CMP      R9,#+0
   \   0000009C   2A00000A           BEQ      ??FS__OpenEx_4
    959          #ifdef FS_TRIAL
    960              FS_DEBUG_ERROROUT((FS_MTYPE_API, "FS_FOpen: Trial limitation: Only one file can be opened at once.\n"));
    961          #else
    962              FS_DEBUG_ERROROUT((FS_MTYPE_API, "FS_FOpen: No file object available.\n"));
    963          #endif
    964              goto Error;
    965            }
    966            //
    967            // Allocate file handle.
    968            //
    969            pFile    = FS__AllocFileHandle();
   \   000000A0   ........           BL       FS__AllocFileHandle
   \   000000A4   00A0B0E1           MOVS     R10,R0
    970            if ((void*)pFile == NULL) {
   \   000000A8   2400000A           BEQ      ??FS__OpenEx_5
    971          #ifdef FS_TRIAL
    972              FS_DEBUG_ERROROUT((FS_MTYPE_API, "FS_FOpen: Trial limitation: Only one file can be opened at once.\n"));
    973          #else
    974              FS_DEBUG_ERROROUT((FS_MTYPE_API, "FS_FOpen: No file handle available.\n"));
    975          #endif
    976              goto Error;
    977            }
    978            //
    979            // Allocate or invalidate file buffer
    980            //
    981          #if FS_USE_FILE_BUFFER
    982            if (pFileObj->pBuffer) {
   \   000000AC   240099E5           LDR      R0,[R9, #+36]
   \   000000B0   000050E3           CMP      R0,#+0
    983              pFileObj->pBuffer->NumBytesInBuffer = 0;
   \   000000B4   10808015           STRNE    R8,[R0, #+16]
   \   000000B8   1300001A           BNE      ??FS__OpenEx_6
    984            } else {
    985              if (FS_Global.FileBufferSize) {
   \   000000BC   00009BE5           LDR      R0,[R11, #+0]
   \   000000C0   000050E3           CMP      R0,#+0
   \   000000C4   1000000A           BEQ      ??FS__OpenEx_6
    986                pFileObj->pBuffer = (FS_FILE_BUFFER *)FS_TryAlloc(sizeof(FS_FILE_BUFFER));
   \   000000C8   1800A0E3           MOV      R0,#+24
   \   000000CC   ........           BL       FS_TryAlloc
   \   000000D0   240089E5           STR      R0,[R9, #+36]
    987                if (pFileObj->pBuffer) {
   \   000000D4   000050E3           CMP      R0,#+0
   \   000000D8   0B00000A           BEQ      ??FS__OpenEx_6
    988                  void * p;
    989          
    990                  p = FS_TryAlloc(FS_Global.FileBufferSize);
   \   000000DC   00009BE5           LDR      R0,[R11, #+0]
   \   000000E0   ........           BL       FS_TryAlloc
    991                  if (p) {
   \   000000E4   000050E3           CMP      R0,#+0
   \   000000E8   0600000A           BEQ      ??FS__OpenEx_7
    992                    pFileObj->pBuffer->pData = (U8 *)p;
   \   000000EC   241099E5           LDR      R1,[R9, #+36]
   \   000000F0   000081E5           STR      R0,[R1, #+0]
    993                    pFileObj->pBuffer->BufferSize = FS_Global.FileBufferSize;
   \   000000F4   00009BE5           LDR      R0,[R11, #+0]
   \   000000F8   0C0081E5           STR      R0,[R1, #+12]
    994                    pFileObj->pBuffer->Flags      = FS_Global.FileBufferFlags;
   \   000000FC   0400DBE5           LDRB     R0,[R11, #+4]
   \   00000100   1500C1E5           STRB     R0,[R1, #+21]
   \   00000104   000000EA           B        ??FS__OpenEx_6
    995                  } else {
    996                    FS_DEBUG_WARN((FS_MTYPE_API, "File buffer could not be allocated to file object"));
    997                    FS_FREE(pFileObj->pBuffer);
    998                    pFileObj->pBuffer = NULL;
   \                     ??FS__OpenEx_7:
   \   00000108   248089E5           STR      R8,[R9, #+36]
    999                  }
   1000                }
   1001              }
   1002            }
   1003          #endif
   1004            //
   1005            // Write information to the file handle.
   1006            //
   1007            FS_LOCK_SYS();
   1008            pFile->AccessFlags = AccessFlags;
   \                     ??FS__OpenEx_6:
   \   0000010C   0800DDE5           LDRB     R0,[SP, #+8]
   1009            pFile->pFileObj    = pFileObj;
   1010            pFileObj->pVolume  = pVolume;
   1011            FS_UNLOCK_SYS();
   1012            FS_JOURNAL_BEGIN (pVolume);
   1013            r = FS_OPEN_FILE(sFilePath, pFile, DoDel, DoOpen, DoCreate);
   1014            FS_JOURNAL_END (pVolume);
   1015            if (r) {
   \   00000110   0730A0E1           MOV      R3,R7
   \   00000114   0620A0E1           MOV      R2,R6
   \   00000118   0B00CAE5           STRB     R0,[R10, #+11]
   \   0000011C   00908AE5           STR      R9,[R10, #+0]
   \   00000120   04009DE5           LDR      R0,[SP, #+4]
   \   00000124   0A10A0E1           MOV      R1,R10
   \   00000128   080089E5           STR      R0,[R9, #+8]
   \   0000012C   00508DE5           STR      R5,[SP, #+0]
   \   00000130   0400A0E1           MOV      R0,R4
   \   00000134   ........           BL       FS_FAT_Open
   \   00000138   000050E3           CMP      R0,#+0
   \   0000013C   0800000A           BEQ      ??FS__OpenEx_8
   1016              goto Error;        /* Illegal access flags */
   1017            }
   1018            goto Done;
   1019          Error:
   1020            FS__FreeFileHandle(pFile);
   \                     ??FS__OpenEx_5:
   \   00000140   00005AE3           CMP      R10,#+0
   \   00000144   0A80CA15           STRBNE   R8,[R10, #+10]
   \   00000148   00808A15           STRNE    R8,[R10, #+0]
   1021            pFile = (FS_FILE*)NULL;
   1022            FS__FreeFileObj(pFileObj);
   \                     ??FS__OpenEx_4:
   \   0000014C   000059E3           CMP      R9,#+0
   \   00000150   0C00D915           LDRBNE   R0,[R9, #+12]
   \   00000154   00A0A0E3           MOV      R10,#+0
   \   00000158   00005013           CMPNE    R0,#+0
   \   0000015C   01004012           SUBNE    R0,R0,#+1
   \   00000160   0C00C915           STRBNE   R0,[R9, #+12]
   1023          Done:
   1024            return pFile;
   \                     ??FS__OpenEx_8:
   \   00000164   0A00A0E1           MOV      R0,R10
   \   00000168   0CD08DE2           ADD      SP,SP,#+12
   \   0000016C   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1025          }
   1026          
   1027          /*********************************************************************
   1028          *
   1029          *       FS__FOpenEx
   1030          *
   1031          *  Function description:
   1032          *    Either opens an existing file or create a new one or delete
   1033          *    a file existing file.
   1034          *
   1035          *  Parameters:
   1036          *    sFullFileName - Fully qualified file name.
   1037          *    AccessFlags   - Type of Access.
   1038          *    DoCreate      - Shall the file be created.
   1039          *    DoDel         - Shall the existing file be deleted.
   1040          *    DoOpen        - Shall the file be opened.
   1041          *
   1042          *  Return value:
   1043          *    ==0         - Unable to open the file.
   1044          *    !=0         - Address of an FS_FILE data structure.
   1045          */

   \                                 In section .text, align 4, keep-with-next
   1046          FS_FILE * FS__FOpenEx(const char * sFullFileName, U8 AccessFlags, char DoCreate, char DoDel, char DoOpen) {
   \                     FS__FOpenEx:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0250A0E1           MOV      R5,R2
   \   00000008   10D04DE2           SUB      SP,SP,#+16
   \   0000000C   0140A0E1           MOV      R4,R1
   1047            FS_FILE      * pFile;
   1048            const char   * sFileName = NULL;
   \   00000010   0020A0E3           MOV      R2,#+0
   \   00000014   0360A0E1           MOV      R6,R3
   \   00000018   2870DDE5           LDRB     R7,[SP, #+40]
   \   0000001C   08208DE5           STR      R2,[SP, #+8]
   1049            FS_VOLUME    * pVolume;
   1050            int            r;
   1051          
   1052            pVolume = FS__FindVolume(sFullFileName, &sFileName);
   \   00000020   08108DE2           ADD      R1,SP,#+8
   \   00000024   ........           BL       FS__FindVolume
   \   00000028   0080B0E1           MOVS     R8,R0
   1053            if ((void*)pVolume == NULL) {
   \   0000002C   0100001A           BNE      ??FS__FOpenEx_0
   1054              return NULL;
   \                     ??FS__FOpenEx_1:
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   170000EA           B        ??FS__FOpenEx_2
   1055            }
   1056            //
   1057            //  Pre-check if we have a valid file name, the correct handling is done in the FS layer
   1058            //
   1059            if (sFileName) {
   \                     ??FS__FOpenEx_0:
   \   00000038   08009DE5           LDR      R0,[SP, #+8]
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0200000A           BEQ      ??FS__FOpenEx_3
   1060              if (*sFileName == '\0') {
   \   00000044   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   1100000A           BEQ      ??FS__FOpenEx_2
   1061                FS_DEBUG_ERROROUT((FS_MTYPE_API, "FS__OpenEx: No file name was specified.\n"));
   1062                return NULL;
   1063              }
   1064            }
   1065            r = FS__AutoMount(pVolume);
   \                     ??FS__FOpenEx_3:
   \   00000050   0800A0E1           MOV      R0,R8
   \   00000054   ........           BL       FS__AutoMount
   1066            if (r <= 0) {
   \   00000058   010050E3           CMP      R0,#+1
   \   0000005C   F3FFFFBA           BLT      ??FS__FOpenEx_1
   1067              FS_DEBUG_ERROROUT((FS_MTYPE_API, "FS__OpenEx: Volume can not be mounted.\n"));
   1068              return (FS_FILE *)NULL;
   1069            }
   1070            //
   1071            //  Check if we want to write data to the volume and the device is mounted read-only.
   1072            //
   1073            if ((AccessFlags & FS_FILE_ACCESS_FLAGS_ACW) && (r != FS_MOUNT_RW)) {
   \   00000060   150014E3           TST      R4,#0x15
   \   00000064   03005013           CMPNE    R0,#+3
   \   00000068   F0FFFF1A           BNE      ??FS__FOpenEx_1
   1074              FS_DEBUG_ERROROUT((FS_MTYPE_API, "FS__OpenEx: Volume is mounted read-only, cannot either create file nor write/append to file.\n."));
   1075              return NULL;
   1076            }
   1077            pFile = NULL;
   1078            FS_LOCK_DRIVER(&pVolume->Partition.Device);
   1079          #if FS_OS_LOCK_PER_DRIVER
   1080            if (pVolume->IsMounted == 0) {
   1081              FS_DEBUG_ERROROUT((FS_MTYPE_API, "Application error: Volume has been unmounted by other thread during wait"));
   1082            } else
   1083          #endif
   1084            {
   1085              if (sFileName) {
   \   0000006C   08109DE5           LDR      R1,[SP, #+8]
   \   00000070   0000A0E3           MOV      R0,#+0
   \   00000074   000051E3           CMP      R1,#+0
   \   00000078   0600000A           BEQ      ??FS__FOpenEx_2
   1086                pFile = FS__OpenEx(pVolume, sFileName, AccessFlags, DoCreate, DoDel, DoOpen);
   \   0000007C   04708DE5           STR      R7,[SP, #+4]
   \   00000080   00608DE5           STR      R6,[SP, #+0]
   \   00000084   0530A0E1           MOV      R3,R5
   \   00000088   0420A0E1           MOV      R2,R4
   \   0000008C   08109DE5           LDR      R1,[SP, #+8]
   \   00000090   0800A0E1           MOV      R0,R8
   \   00000094   ........           BL       FS__OpenEx
   1087              }
   1088            }
   1089            FS_UNLOCK_DRIVER(&pVolume->Partition.Device);
   1090            return pFile;
   \                     ??FS__FOpenEx_2:
   \   00000098   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   0000009C   F081BDE8           POP      {R4-R8,PC}       ;; return
   1091          }
   1092          
   1093          /*********************************************************************
   1094          *
   1095          *       FS__FOpen
   1096          *
   1097          *  Function description:
   1098          *    Internal version of FS_FOpen.
   1099          *    Open an existing file or create a new one.
   1100          *
   1101          *  Parameters:
   1102          *    pFileName   - Fully qualified file name.
   1103          *    pMode       - Mode for opening the file.
   1104          *
   1105          *  Return value:
   1106          *    ==0         - Unable to open the file.
   1107          *    !=0         - Address of an FS_FILE data structure.
   1108          */

   \                                 In section .text, align 4, keep-with-next
   1109          FS_FILE * FS__FOpen(const char * pFileName, const char * pMode) {
   \                     FS__FOpen:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   1110            FS_FILE      * pFile;
   1111            int            ModeIndex;
   1112            U8          AccessFlags;
   1113            char           DoCreate;
   1114            char           DoDel;
   1115            char           DoOpen;
   1116          
   1117            pFile = NULL;
   1118            /* Check mode */
   1119            ModeIndex = _Text2Mode(pMode);
   \   00000004   ............       ADRL     R9,_aAccessMode
   \              ....        
   \   0000000C   10D04DE2           SUB      SP,SP,#+16
   \   00000010   0060A0E1           MOV      R6,R0
   \   00000014   0170A0E1           MOV      R7,R1
   \   00000018   0050A0E3           MOV      R5,#+0
   \   0000001C   0040A0E3           MOV      R4,#+0
   \   00000020   0080A0E3           MOV      R8,#+0
   \   00000024   09A0A0E1           MOV      R10,R9
   \                     ??FS__FOpen_0:
   \   00000028   08109AE4           LDR      R1,[R10], #+8
   \   0000002C   0700A0E1           MOV      R0,R7
   \   00000030   ........           BL       strcmp
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0300000A           BEQ      ??FS__FOpen_1
   \   0000003C   018088E2           ADD      R8,R8,#+1
   \   00000040   0F0058E3           CMP      R8,#+15
   \   00000044   F7FFFF3A           BCC      ??FS__FOpen_0
   \   00000048   250000EA           B        ??FS__FOpen_2
   1120            if (ModeIndex < 0) {
   \                     ??FS__FOpen_1:
   \   0000004C   000058E3           CMP      R8,#+0
   \   00000050   2300004A           BMI      ??FS__FOpen_2
   1121              FS_DEBUG_ERROROUT((FS_MTYPE_API, "FS__FOpen: Illegal access flags.\n"));
   1122            } else {
   1123              /* All checks have been performed, lets do the work  */
   1124              AccessFlags        = _aAccessMode[ModeIndex].AccessFlags;
   1125              DoDel              = _aAccessMode[ModeIndex].DoDel;
   1126              DoOpen             = _aAccessMode[ModeIndex].DoOpen;
   1127              DoCreate           = _aAccessMode[ModeIndex].DoCreate;
   1128              pFile = FS__FOpenEx(pFileName, AccessFlags, DoCreate, DoDel, DoOpen);
   \   00000054   880189E0           ADD      R0,R9,R8, LSL #+3
   \   00000058   0670D0E5           LDRB     R7,[R0, #+6]
   \   0000005C   0580D0E5           LDRB     R8,[R0, #+5]
   \   00000060   0790D0E5           LDRB     R9,[R0, #+7]
   \   00000064   04A0D0E5           LDRB     R10,[R0, #+4]
   \   00000068   08508DE5           STR      R5,[SP, #+8]
   \   0000006C   08108DE2           ADD      R1,SP,#+8
   \   00000070   0600A0E1           MOV      R0,R6
   \   00000074   ........           BL       FS__FindVolume
   \   00000078   0060B0E1           MOVS     R6,R0
   \   0000007C   1800000A           BEQ      ??FS__FOpen_2
   \   00000080   08009DE5           LDR      R0,[SP, #+8]
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0200000A           BEQ      ??FS__FOpen_3
   \   0000008C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000090   000050E3           CMP      R0,#+0
   \   00000094   1200000A           BEQ      ??FS__FOpen_2
   \                     ??FS__FOpen_3:
   \   00000098   0600A0E1           MOV      R0,R6
   \   0000009C   ........           BL       FS__AutoMount
   \   000000A0   010050E3           CMP      R0,#+1
   \   000000A4   0E0000BA           BLT      ??FS__FOpen_2
   \   000000A8   15001AE3           TST      R10,#0x15
   \   000000AC   03005013           CMPNE    R0,#+3
   \   000000B0   0B00001A           BNE      ??FS__FOpen_2
   \   000000B4   08009DE5           LDR      R0,[SP, #+8]
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   0700000A           BEQ      ??FS__FOpen_4
   \   000000C0   04708DE5           STR      R7,[SP, #+4]
   \   000000C4   00808DE5           STR      R8,[SP, #+0]
   \   000000C8   0930A0E1           MOV      R3,R9
   \   000000CC   0A20A0E1           MOV      R2,R10
   \   000000D0   08109DE5           LDR      R1,[SP, #+8]
   \   000000D4   0600A0E1           MOV      R0,R6
   \   000000D8   ........           BL       FS__OpenEx
   \   000000DC   0050A0E1           MOV      R5,R0
   \                     ??FS__FOpen_4:
   \   000000E0   0540A0E1           MOV      R4,R5
   1129            }
   1130            return pFile;
   \                     ??FS__FOpen_2:
   \   000000E4   0400A0E1           MOV      R0,R4
   \   000000E8   10D08DE2           ADD      SP,SP,#+16
   \   000000EC   F087BDE8           POP      {R4-R10,PC}      ;; return
   1131          }
   1132          
   1133          /*********************************************************************
   1134          *
   1135          *       Public code, API functions
   1136          *
   1137          **********************************************************************
   1138          */
   1139          
   1140          /*********************************************************************
   1141          *
   1142          *       FS_FOpen
   1143          *
   1144          *  Function description:
   1145          *    Open an existing file or create a new one.
   1146          *
   1147          *  Parameters:
   1148          *    pFileName   - Fully qualified file name.
   1149          *    pMode       - Mode for opening the file.
   1150          *
   1151          *  Return value:
   1152          *    ==0         - Unable to open the file.
   1153          *    !=0         - Address of an FS_FILE data structure.
   1154          */

   \                                 In section .text, align 4, keep-with-next
   1155          FS_FILE * FS_FOpen(const char * pFileName, const char * pMode) {
   \                     FS_FOpen:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
   1156            FS_FILE      * pFile;
   1157          
   1158            FS_LOCK();
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   ........           BL       FS_OS_Lock
   1159            pFile = FS__FOpen(pFileName, pMode);
   \   00000018   0510A0E1           MOV      R1,R5
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       FS__FOpen
   \   00000024   0040A0E1           MOV      R4,R0
   1160            FS_UNLOCK();
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   ........           BL       FS_OS_Unlock
   1161            return pFile;
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   04D08DE2           ADD      SP,SP,#+4
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
   1162          }
   1163          
   1164          
   1165          
   1166          /*********************************************************************
   1167          *
   1168          *       FS_Remove
   1169          *
   1170          *  Function description:
   1171          *    Remove a file.
   1172          *    There is no real 'delete' function in the FSL, but the FSL's 'open'
   1173          *    function can delete a file.
   1174          *
   1175          *  Parameters:
   1176          *    pFileName   - Fully qualified file name.
   1177          *
   1178          *  Return value:
   1179          *    ==0         - File has been removed.
   1180          *    ==-1        - An error has occurred.
   1181          */

   \                                 In section .text, align 4, keep-with-next
   1182          int FS_Remove(const char *sFileName) {
   \                     FS_Remove:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1183            int r;
   1184          
   1185            FS_LOCK();
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   ........           BL       FS_OS_Lock
   1186            r = FS__Remove(sFileName);
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   ........           BL       FS__Remove
   \   00000018   0040A0E1           MOV      R4,R0
   1187            FS_UNLOCK();
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   ........           BL       FS_OS_Unlock
   1188            return r;
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   1080BDE8           POP      {R4,PC}          ;; return
   1189          }
   1190          
   1191          
   1192          /*********************************************************************
   1193          *
   1194          *       FS_FClose
   1195          *
   1196          *  Function description:
   1197          *    Close a file referred by pFile.
   1198          *
   1199          *  Parameters:
   1200          *    pFile       - Pointer to a FS_FILE data structure.
   1201          *
   1202          *  Return value:
   1203          *    1           - Error, File handle can not be closed.
   1204          *    0           - File handle has been closed.
   1205          */

   \                                 In section .text, align 4, keep-with-next
   1206          int FS_FClose(FS_FILE *pFile) {
   \                     FS_FClose:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   1207            int r;
   1208          
   1209            FS_LOCK();
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   ........           BL       FS_OS_Lock
   1210            r  = 1;
   \   00000014   0170A0E3           MOV      R7,#+1
   1211            if (pFile) {
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   1300000A           BEQ      ??FS_FClose_0
   1212              r = FS__FClose(pFile);
   \   00000020   006094E5           LDR      R6,[R4, #+0]
   \   00000024   0A10D4E5           LDRB     R1,[R4, #+10]
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   0620B0E1           MOVS     R2,R6
   \   00000030   08009615           LDRNE    R0,[R6, #+8]
   \   00000034   0050A0E3           MOV      R5,#+0
   \   00000038   000051E3           CMP      R1,#+0
   \   0000003C   0B00000A           BEQ      ??FS_FClose_0
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0A00000A           BEQ      ??FS_FClose_1
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   ........           BL       FS_FAT_Close
   \   00000050   000056E3           CMP      R6,#+0
   \   00000054   0C00D615           LDRBNE   R0,[R6, #+12]
   \   00000058   0070A0E3           MOV      R7,#+0
   \   0000005C   00005013           CMPNE    R0,#+0
   \   00000060   01004012           SUBNE    R0,R0,#+1
   \   00000064   0C00C615           STRBNE   R0,[R6, #+12]
   \   00000068   0A50C4E5           STRB     R5,[R4, #+10]
   \   0000006C   005084E5           STR      R5,[R4, #+0]
   1213            }
   1214            FS_UNLOCK();
   \                     ??FS_FClose_0:
   \   00000070   0000A0E3           MOV      R0,#+0
   \                     ??FS_FClose_1:
   \   00000074   ........           BL       FS_OS_Unlock
   1215            return r;
   \   00000078   0700A0E1           MOV      R0,R7
   \   0000007C   04D08DE2           ADD      SP,SP,#+4
   \   00000080   F080BDE8           POP      {R4-R7,PC}       ;; return
   1216          }
   1217          
   1218          /*********************************************************************
   1219          *
   1220          *       FS_FSeek
   1221          *
   1222          *  Function description:
   1223          *    Set current position of a file pointer.
   1224          *
   1225          *  Parameters:
   1226          *    pFile       - Pointer to a FS_FILE data structure.
   1227          *    Offset      - Offset for setting the file pointer position.
   1228          *    Origin      - Mode for positioning the file pointer.b
   1229          *
   1230          *  Return value:
   1231          *    ==0         - File pointer has been positioned according to the
   1232          *                  parameters.
   1233          *    ==-1        - An error has occurred.
   1234          */

   \                                 In section .text, align 4, keep-with-next
   1235          int FS_FSeek(FS_FILE * pFile, I32 Offset, int Origin) {
   \                     FS_FSeek:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   1236            int r;
   1237            FS_LOCK();
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   ........           BL       FS_OS_Lock
   1238            r = FS__FSeek(pFile, Offset, Origin);
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   1500000A           BEQ      ??FS_FSeek_0
   \   00000020   000056E3           CMP      R6,#+0
   \   00000024   0800000A           BEQ      ??FS_FSeek_1
   \   00000028   020056E3           CMP      R6,#+2
   \   0000002C   0100000A           BEQ      ??FS_FSeek_2
   \   00000030   0300003A           BCC      ??FS_FSeek_3
   \   00000034   0B0000EA           B        ??FS_FSeek_4
   \                     ??FS_FSeek_2:
   \   00000038   000094E5           LDR      R0,[R4, #+0]
   \   0000003C   040090E5           LDR      R0,[R0, #+4]
   \   00000040   000000EA           B        ??FS_FSeek_5
   \                     ??FS_FSeek_3:
   \   00000044   040094E5           LDR      R0,[R4, #+4]
   \                     ??FS_FSeek_5:
   \   00000048   055080E0           ADD      R5,R0,R5
   \                     ??FS_FSeek_1:
   \   0000004C   040094E5           LDR      R0,[R4, #+4]
   \   00000050   050050E1           CMP      R0,R5
   \   00000054   04508415           STRNE    R5,[R4, #+4]
   \   00000058   0000A013           MOVNE    R0,#+0
   \   0000005C   B800C411           STRHNE   R0,[R4, #+8]
   \   00000060   0040A0E3           MOV      R4,#+0
   \   00000064   040000EA           B        ??FS_FSeek_6
   \                     ??FS_FSeek_4:
   \   00000068   0200E0E3           MVN      R0,#+2
   \   0000006C   B800C4E1           STRH     R0,[R4, #+8]
   \   00000070   024080E3           ORR      R4,R0,#0x2
   \   00000074   000000EA           B        ??FS_FSeek_6
   \                     ??FS_FSeek_0:
   \   00000078   0040E0E3           MVN      R4,#+0
   1239            FS_UNLOCK();
   \                     ??FS_FSeek_6:
   \   0000007C   0000A0E3           MOV      R0,#+0
   \   00000080   ........           BL       FS_OS_Unlock
   1240            return r;
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   7080BDE8           POP      {R4-R6,PC}       ;; return
   1241          }
   1242          
   1243          /*********************************************************************
   1244          *
   1245          *       FS_FTell
   1246          *
   1247          *  Function description:
   1248          *    Return position of a file pointer.
   1249          *
   1250          *  Parameters:
   1251          *    pFile         - Pointer to a FS_FILE data structure.
   1252          *
   1253          *  Return value:
   1254          *    >=0           - Current position of the file pointer.
   1255          *    ==-1          - An error has occurred.
   1256          */

   \                                 In section .text, align 4, keep-with-next
   1257          I32 FS_FTell(FS_FILE *pFile) {
   \                     FS_FTell:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   1258            I32 r;
   1259            FS_LOCK();
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   ........           BL       FS_OS_Lock
   1260            r = FS__FTell(pFile);
   \   00000014   0050E0E3           MVN      R5,#+0
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   04509415           LDRNE    R5,[R4, #+4]
   1261            FS_UNLOCK();
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   ........           BL       FS_OS_Unlock
   1262            return r;
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   04D08DE2           ADD      SP,SP,#+4
   \   00000030   3080BDE8           POP      {R4,R5,PC}       ;; return
   1263          }
   1264          
   1265          /*********************************************************************
   1266          *
   1267          *       FS_FEof
   1268          *
   1269          *  Function description:
   1270          *    Returns if end of file has been reached.
   1271          *
   1272          *  Parameters:
   1273          *    pFile         - Pointer to a FS_FILE data structure.
   1274          *
   1275          *  Return value:
   1276          *    == 1          - End of File has been reached.
   1277          *    == 0          - End of File has not been reached.
   1278          */

   \                                 In section .text, align 4, keep-with-next
   1279          int FS_FEof(FS_FILE * pFile) {
   \                     FS_FEof:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   1280            int r;
   1281            char InUse;
   1282            FS_LOCK();
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   ........           BL       FS_OS_Lock
   1283            r = 1;
   \   00000014   0150A0E3           MOV      R5,#+1
   1284            if (pFile) {
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   0A00000A           BEQ      ??FS_FEof_0
   1285          
   1286              FS_LOCK_SYS();
   1287              InUse = pFile->InUse;
   1288              FS_UNLOCK_SYS();
   1289              if (InUse) {
   \   00000020   0A00D4E5           LDRB     R0,[R4, #+10]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0600000A           BEQ      ??FS_FEof_1
   1290                r = (pFile->FilePos >= pFile->pFileObj->Size);
   \   0000002C   001094E5           LDR      R1,[R4, #+0]
   \   00000030   040094E5           LDR      R0,[R4, #+4]
   \   00000034   041091E5           LDR      R1,[R1, #+4]
   \   00000038   010050E1           CMP      R0,R1
   \   0000003C   0200002A           BCS      ??FS_FEof_0
   \   00000040   0050A0E3           MOV      R5,#+0
   \   00000044   000000EA           B        ??FS_FEof_0
   1291              } else {
   1292                r = -1;
   \                     ??FS_FEof_1:
   \   00000048   005065E2           RSB      R5,R5,#+0
   1293              }
   1294            }
   1295            FS_UNLOCK();
   \                     ??FS_FEof_0:
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   ........           BL       FS_OS_Unlock
   1296            return r;
   \   00000054   0500A0E1           MOV      R0,R5
   \   00000058   04D08DE2           ADD      SP,SP,#+4
   \   0000005C   3080BDE8           POP      {R4,R5,PC}       ;; return
   1297          }
   1298          
   1299          /*********************************************************************
   1300          *
   1301          *       FS_FError
   1302          *
   1303          *  Function description:
   1304          *    Return error status of a file.
   1305          *
   1306          *  Parameters:
   1307          *    pFile         - Pointer to a FS_FILE data structure.
   1308          *
   1309          *  Return value:
   1310          *    == FS_ERR_OK  - No error.
   1311          *    != FS_ERR_OK  - An error has occurred.
   1312          */

   \                                 In section .text, align 4, keep-with-next
   1313          I16 FS_FError(FS_FILE * pFile) {
   \                     FS_FError:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   1314            I16 r;
   1315          
   1316            FS_LOCK();
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   ........           BL       FS_OS_Lock
   1317            r = FS_ERR_INVALIDPAR;
   \   00000014   0250E0E3           MVN      R5,#+2
   1318            if (pFile) {
   \   00000018   000054E3           CMP      R4,#+0
   1319              r = pFile->Error;
   \   0000001C   F850D411           LDRSHNE  R5,[R4, #+8]
   1320            }
   1321            FS_UNLOCK();
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   ........           BL       FS_OS_Unlock
   1322            return r;
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   04D08DE2           ADD      SP,SP,#+4
   \   00000030   3080BDE8           POP      {R4,R5,PC}       ;; return
   1323          }
   1324          
   1325          /*********************************************************************
   1326          *
   1327          *       FS_ClearErr
   1328          *
   1329          *  Function description:
   1330          *    API function. Clear error status of a file.
   1331          *
   1332          *  Parameters:
   1333          *    pFile       - Pointer to a FS_FILE data structure.
   1334          *
   1335          *  Return value:
   1336          *    None.
   1337          */

   \                                 In section .text, align 4, keep-with-next
   1338          void FS_ClearErr(FS_FILE * pFile) {
   \                     FS_ClearErr:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1339            FS_LOCK();
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   ........           BL       FS_OS_Lock
   1340            if (pFile) {
   \   00000010   000054E3           CMP      R4,#+0
   1341              pFile->Error = FS_ERR_OK;
   \   00000014   0000A013           MOVNE    R0,#+0
   \   00000018   B800C411           STRHNE   R0,[R4, #+8]
   1342            }
   1343            FS_UNLOCK();
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   ........           BL       FS_OS_Unlock
   1344          }
   \   00000024   1080BDE8           POP      {R4,PC}          ;; return
   1345          
   1346          /*********************************************************************
   1347          *
   1348          *       FS__RemoveDevice
   1349          *
   1350          *  Description:
   1351          *    Removes a volume from the file system.
   1352          *
   1353          *  Parameters:
   1354          *    pVolume    - Pointer to a volume that should be removed.
   1355          *  Return value:
   1356          */

   \                                 In section .text, align 4, keep-with-next
   1357          void FS__RemoveDevice(FS_VOLUME * pVolume) {
   \                     FS__RemoveDevice:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   1358            int          i;
   1359            int          NumVolumes;
   1360            FS_VOLUME  * pVolume2Check;
   1361          
   1362            pVolume2Check = &FS_Global.FirstVolume;
   \   00000004   ........           LDR      R4,??DataTable27
   \   00000008   0050A0E1           MOV      R5,R0
   1363            NumVolumes = FS_Global.NumVolumes;
   \   0000000C   801094E5           LDR      R1,[R4, #+128]
   \   00000010   1C0084E2           ADD      R0,R4,#+28
   1364            //
   1365            //  Get through the whole volume list.
   1366            //
   1367            for (i = 0; i < NumVolumes; i++) {
   \   00000014   010051E3           CMP      R1,#+1
   \   00000018   2D0000BA           BLT      ??FS__RemoveDevice_0
   1368              FS_VOLUME * pVolumeNext;
   1369          
   1370              //
   1371              //  Did we found the correct volume
   1372              //
   1373              if (pVolume2Check == pVolume) {
   \                     ??FS__RemoveDevice_1:
   \   0000001C   050050E1           CMP      R0,R5
   \   00000020   2800001A           BNE      ??FS__RemoveDevice_2
   1374                FS_DEVICE * pDevice;
   1375          
   1376                //
   1377                // Send to the underlying layer that the device
   1378                // will be unmounted and removed.
   1379                //
   1380                pDevice = &pVolume->Partition.Device;
   1381                if (FS_LB_GetStatus(pDevice) == FS_MEDIA_NOT_PRESENT) {
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           BL       FS_LB_GetStatus
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0500A0E1           MOV      R0,R5
   \   00000034   0100001A           BNE      ??FS__RemoveDevice_3
   1382                  FS__UnmountForcedNL(pVolume);
   \   00000038   ........           BL       FS__UnmountForcedNL
   \   0000003C   000000EA           B        ??FS__RemoveDevice_4
   1383                } else {
   1384                  FS__UnmountNL(pVolume);
   \                     ??FS__RemoveDevice_3:
   \   00000040   ........           BL       FS__UnmountNL
   1385                }
   1386                FS__IoCtlNL(pVolume, FS_CMD_DEINIT, 0, NULL);
   \                     ??FS__RemoveDevice_4:
   \   00000044   F310A0E3           MOV      R1,#+243
   \   00000048   0030A0E3           MOV      R3,#+0
   \   0000004C   0020A0E3           MOV      R2,#+0
   \   00000050   C01F81E3           ORR      R1,R1,#0x300
   \   00000054   0500A0E1           MOV      R0,R5
   \   00000058   ........           BL       FS__IoCtlNL
   1387                //
   1388                //  Remove all relevant journaling information if necessary
   1389                //  (FS_SUPPORT_JOURNAL == 1)
   1390                //
   1391                FS_JOURNAL_DEINIT(pVolume);
   1392                //
   1393                //  Remove the volume instance from the OS device lock instance,
   1394                //  if necessary. (FS_OS_LOCKIN == 2)
   1395                FS_OS_REMOVE_DRIVER(pVolume->Partition.Device.pType);
   1396                pVolumeNext = pVolume->pNext;
   \   0000005C   606095E5           LDR      R6,[R5, #+96]
   1397                FS_MEMSET(pVolume, 0, sizeof(FS_VOLUME));
   \   00000060   6410A0E3           MOV      R1,#+100
   \   00000064   0500A0E1           MOV      R0,R5
   \   00000068   ........           BL       __aeabi_memclr4
   1398                if (pVolume != &FS_Global.FirstVolume) {
   1399                  FS_FREE(pVolume);
   1400                }
   1401                if ((pVolume == &FS_Global.FirstVolume) && (pVolumeNext != NULL)) {
   \   0000006C   1C0084E2           ADD      R0,R4,#+28
   \   00000070   000055E1           CMP      R5,R0
   \   00000074   0500001A           BNE      ??FS__RemoveDevice_5
   \   00000078   000056E3           CMP      R6,#+0
   \   0000007C   0300000A           BEQ      ??FS__RemoveDevice_5
   1402                  //
   1403                  // In case we remove the first volume, we need to move the volume
   1404                  // next after the first volume to the first volume.
   1405                  // The moved entry will then be removed if freeing memory is available.
   1406                  //
   1407                  FS_MEMCPY(&FS_Global.FirstVolume, pVolumeNext, sizeof(FS_VOLUME));
   \   00000080   6420A0E3           MOV      R2,#+100
   \   00000084   0610A0E1           MOV      R1,R6
   \   00000088   ........           BL       FS_memcpy
   \   0000008C   090000EA           B        ??FS__RemoveDevice_6
   1408                  FS_FREE(pVolumeNext);
   1409                } else {
   1410                  FS_VOLUME ** ppNextVolume;
   1411                  FS_VOLUME  * pNextVolume;
   1412                  ppNextVolume = &FS_Global.FirstVolume.pNext;
   \                     ??FS__RemoveDevice_5:
   \   00000090   7C0084E2           ADD      R0,R4,#+124
   1413                  pNextVolume  = FS_Global.FirstVolume.pNext;
   \   00000094   7C1094E5           LDR      R1,[R4, #+124]
   \   00000098   020000EA           B        ??FS__RemoveDevice_7
   1414                  do {
   1415                    if (pNextVolume == pVolume) {
   1416                      *ppNextVolume = pVolumeNext;
   1417                      break;
   1418                    }
   1419                    if (pNextVolume == NULL) {
   1420                      break;
   1421                    }
   1422                    pNextVolume = pNextVolume->pNext;
   1423                    ppNextVolume = &(*ppNextVolume)->pNext;
   \                     ??FS__RemoveDevice_8:
   \   0000009C   000090E5           LDR      R0,[R0, #+0]
   \   000000A0   601091E5           LDR      R1,[R1, #+96]
   \   000000A4   600080E2           ADD      R0,R0,#+96
   1424          
   1425                  } while(1);
   \                     ??FS__RemoveDevice_7:
   \   000000A8   050051E1           CMP      R1,R5
   \   000000AC   00608005           STREQ    R6,[R0, #+0]
   \   000000B0   00005113           CMPNE    R1,#+0
   \   000000B4   F8FFFF1A           BNE      ??FS__RemoveDevice_8
   1426                }
   1427                FS_Global.NumVolumes--;
   \                     ??FS__RemoveDevice_6:
   \   000000B8   800094E5           LDR      R0,[R4, #+128]
   \   000000BC   010040E2           SUB      R0,R0,#+1
   \   000000C0   800084E5           STR      R0,[R4, #+128]
   1428                break;
   \   000000C4   7080BDE8           POP      {R4-R6,PC}
   1429              } else {
   1430                pVolume2Check = pVolume2Check->pNext;
   \                     ??FS__RemoveDevice_2:
   \   000000C8   600090E5           LDR      R0,[R0, #+96]
   1431              }
   1432          
   1433            }
   \   000000CC   011051E2           SUBS     R1,R1,#+1
   \   000000D0   D1FFFF1A           BNE      ??FS__RemoveDevice_1
   1434          }
   \                     ??FS__RemoveDevice_0:
   \   000000D4   7080BDE8           POP      {R4-R6,PC}       ;; return
   1435          
   1436          /*********************************************************************
   1437          *
   1438          *       FS__RemoveDevices
   1439          *
   1440          *  Description:
   1441          *    Removes a volume from the file system.
   1442          *
   1443          *  Parameters:
   1444          *    pVolume    - Pointer to a volume that should be removed.
   1445          *  Return value:
   1446          */

   \                                 In section .text, align 4, keep-with-next
   1447          void FS__RemoveDevices(void) {
   \                     FS__RemoveDevices:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   1448            int         i;
   1449            int         NumVolumes;
   1450            FS_VOLUME * pVolume;
   1451          
   1452            pVolume    = &FS_Global.FirstVolume;
   \   00000004   ........           LDR      R4,??DataTable27
   1453            NumVolumes = FS_Global.NumVolumes;
   \   00000008   806094E5           LDR      R6,[R4, #+128]
   \   0000000C   1C5084E2           ADD      R5,R4,#+28
   1454            //
   1455            //  Get through the whole volume list.
   1456            //
   1457            for (i = 0; i < NumVolumes; i++) {
   \   00000010   010056E3           CMP      R6,#+1
   \   00000014   150000BA           BLT      ??FS__RemoveDevices_0
   \   00000018   F370A0E3           MOV      R7,#+243
   \   0000001C   C07F87E3           ORR      R7,R7,#0x300
   1458              FS_VOLUME * pVolumeNext;
   1459              FS_DEVICE * pDevice;
   1460          
   1461              pDevice = &pVolume->Partition.Device;
   1462              if (FS_LB_GetStatus(pDevice) == FS_MEDIA_NOT_PRESENT) {
   \                     ??FS__RemoveDevices_1:
   \   00000020   0500A0E1           MOV      R0,R5
   \   00000024   ........           BL       FS_LB_GetStatus
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   0100001A           BNE      ??FS__RemoveDevices_2
   1463                FS__UnmountForcedNL(pVolume);
   \   00000034   ........           BL       FS__UnmountForcedNL
   \   00000038   000000EA           B        ??FS__RemoveDevices_3
   1464              } else {
   1465                FS__UnmountNL(pVolume);
   \                     ??FS__RemoveDevices_2:
   \   0000003C   ........           BL       FS__UnmountNL
   1466              }
   1467              FS__IoCtlNL(pVolume, FS_CMD_DEINIT, 0, NULL);
   \                     ??FS__RemoveDevices_3:
   \   00000040   0030A0E3           MOV      R3,#+0
   \   00000044   0020A0E3           MOV      R2,#+0
   \   00000048   0710A0E1           MOV      R1,R7
   \   0000004C   0500A0E1           MOV      R0,R5
   \   00000050   ........           BL       FS__IoCtlNL
   1468              FS_JOURNAL_DEINIT(pVolume);
   1469              FS_OS_REMOVE_DRIVER(pVolume->Partition.Device.pType);
   1470              pVolumeNext = pVolume->pNext;
   \   00000054   608095E5           LDR      R8,[R5, #+96]
   1471              FS_MEMSET(pVolume, 0, sizeof(FS_VOLUME));
   \   00000058   6410A0E3           MOV      R1,#+100
   \   0000005C   0500A0E1           MOV      R0,R5
   \   00000060   ........           BL       __aeabi_memclr4
   1472              if (pVolume != &FS_Global.FirstVolume) {
   1473                FS_FREE(pVolume);
   1474              }
   1475              pVolume = pVolumeNext;
   \   00000064   0850A0E1           MOV      R5,R8
   1476            }
   \   00000068   016056E2           SUBS     R6,R6,#+1
   \   0000006C   EBFFFF1A           BNE      ??FS__RemoveDevices_1
   1477            FS_Global.NumVolumes = 0;
   \                     ??FS__RemoveDevices_0:
   \   00000070   0000A0E3           MOV      R0,#+0
   \   00000074   800084E5           STR      R0,[R4, #+128]
   1478          }
   \   00000078   F081BDE8           POP      {R4-R8,PC}       ;; return
   1479          
   1480          /*********************************************************************
   1481          *
   1482          *       FS_Init
   1483          *
   1484          *  Function description:
   1485          *    Start the file system.
   1486          *
   1487          */

   \                                 In section .text, align 4, keep-with-next
   1488          void FS_Init(void) {
   \                     FS_Init:
   \   00000000   10402DE9           PUSH     {R4,LR}
   1489            unsigned NumDriverLocks;
   1490            //
   1491            // Allocate memory for sector buffers
   1492            //
   1493            NumDriverLocks = FS_STORAGE_Init();
   \   00000004   ........           BL       FS_STORAGE_Init
   1494            if (NumDriverLocks) {
   \   00000008   000050E3           CMP      R0,#+0
   \   0000000C   1F00000A           BEQ      ??FS_Init_0
   1495              U8            * pBuffer;
   1496              SECTOR_BUFFER * pSectorBuffer;
   1497              unsigned        i;
   1498          
   1499              FS_Global.NumSectorBuffers = FS_NUM_MEMBLOCKS_PER_OPERATION * NumDriverLocks;
   \   00000010   ........           LDR      R4,??DataTable27
   \   00000014   8000A0E1           LSL      R0,R0,#+1
   \   00000018   0C0084E5           STR      R0,[R4, #+12]
   1500              //
   1501              // Alloc memory for the SECTOR_BUFFER structure.
   1502              //
   1503              FS_Global.paSectorBuffer   = (SECTOR_BUFFER *)FS_AllocZeroed(FS_Global.NumSectorBuffers * sizeof(SECTOR_BUFFER));
   \   0000001C   8001A0E1           LSL      R0,R0,#+3
   \   00000020   ........           BL       FS_AllocZeroed
   \   00000024   080084E5           STR      R0,[R4, #+8]
   1504              pBuffer           = (U8 *)FS_AllocZeroed(FS_Global.MaxSectorSize * FS_Global.NumSectorBuffers);
   \   00000028   B001D4E1           LDRH     R0,[R4, #+16]
   \   0000002C   0C1094E5           LDR      R1,[R4, #+12]
   \   00000030   910000E0           MUL      R0,R1,R0
   \   00000034   ........           BL       FS_AllocZeroed
   1505              pSectorBuffer     = FS_Global.paSectorBuffer;
   1506              for (i = 0; i < FS_Global.NumSectorBuffers; i++) {
   \   00000038   0C3094E5           LDR      R3,[R4, #+12]
   \   0000003C   081094E5           LDR      R1,[R4, #+8]
   \   00000040   0020A0E3           MOV      R2,#+0
   \   00000044   000053E3           CMP      R3,#+0
   \   00000048   0700000A           BEQ      ??FS_Init_1
   1507                pSectorBuffer->pBuffer = (U32 *)pBuffer;
   \                     ??FS_Init_2:
   \   0000004C   040081E5           STR      R0,[R1, #+4]
   1508                pBuffer               += FS_Global.MaxSectorSize;
   \   00000050   B031D4E1           LDRH     R3,[R4, #+16]
   1509                pSectorBuffer++;
   1510              }
   \   00000054   012082E2           ADD      R2,R2,#+1
   \   00000058   081081E2           ADD      R1,R1,#+8
   \   0000005C   000083E0           ADD      R0,R3,R0
   \   00000060   0C3094E5           LDR      R3,[R4, #+12]
   \   00000064   030052E1           CMP      R2,R3
   \   00000068   F7FFFF3A           BCC      ??FS_Init_2
   1511              FS_Global.pFirstFilehandle = (FS_FILE     *)FS_AllocZeroed(sizeof(FS_FILE));
   \                     ??FS_Init_1:
   \   0000006C   1000A0E3           MOV      R0,#+16
   \   00000070   ........           BL       FS_AllocZeroed
   \   00000074   140084E5           STR      R0,[R4, #+20]
   1512              FS_Global.pFirstFileObj    = (FS_FILE_OBJ *)FS_AllocZeroed(sizeof(FS_FILE_OBJ));
   \   00000078   2C00A0E3           MOV      R0,#+44
   \   0000007C   ........           BL       FS_AllocZeroed
   \   00000080   180084E5           STR      R0,[R4, #+24]
   1513              FS_Global.IsInited |= (1 << 1);  // Set InitStatus to FS-Complete init state.
   \   00000084   1200D4E5           LDRB     R0,[R4, #+18]
   \   00000088   020080E3           ORR      R0,R0,#0x2
   \   0000008C   1200C4E5           STRB     R0,[R4, #+18]
   1514            }
   1515          }
   \                     ??FS_Init_0:
   \   00000090   1080BDE8           POP      {R4,PC}          ;; return
   1516          
   1517          /*********************************************************************
   1518          *
   1519          *       FS_ConfigUpdateDirOnWrite
   1520          *
   1521          *  Description:
   1522          *    This sets whether the directory entry after writing the data to file
   1523          *    shall be updated or not.
   1524          *
   1525          *  Parameters:
   1526          *    OnOff       - 1 means enable  update directory after write
   1527          *                  0 means do not  update directory. FS_FClose will
   1528          *                    update the directory entry
   1529          */

   \                                 In section .text, align 4, keep-with-next
   1530          void FS_ConfigUpdateDirOnWrite(char OnOff) {
   \                     FS_ConfigUpdateDirOnWrite:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1531            FS_LOCK();
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   ........           BL       FS_OS_Lock
   1532            FS_LOCK_SYS();
   1533            if (OnOff) {
   \   00000010   000054E3           CMP      R4,#+0
   1534              FS_Global.WriteMode = FS_WRITEMODE_SAFE;
   1535            } else {
   1536              FS_Global.WriteMode = FS_WRITEMODE_MEDIUM;
   \   00000014   ........           LDR      R1,??DataTable27
   \   00000018   0000A013           MOVNE    R0,#+0
   \   0000001C   0100A003           MOVEQ    R0,#+1
   \   00000020   8400C1E5           STRB     R0,[R1, #+132]
   1537            }
   1538            FS_UNLOCK_SYS();
   1539            FS_UNLOCK();
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   ........           BL       FS_OS_Unlock
   1540          }
   \   0000002C   1080BDE8           POP      {R4,PC}          ;; return
   1541          
   1542          #if FS_USE_FILE_BUFFER
   1543          
   1544          /*********************************************************************
   1545          *
   1546          *       FS_ConfigFileBufferDefault
   1547          *
   1548          *  Function description
   1549          *    Configures default file buffer size and flags for all files.
   1550          *    Should only be called once, in FS_X_AddDevices()
   1551          */

   \                                 In section .text, align 4, keep-with-next
   1552          void FS_ConfigFileBufferDefault(int BufferSize, int Flags) {
   \                     FS_ConfigFileBufferDefault:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
   1553            FS_LOCK();
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   ........           BL       FS_OS_Lock
   1554            FS_LOCK_SYS();
   1555            FS_Global.FileBufferSize  = BufferSize;
   \   00000018   ........           LDR      R0,??DataTable27
   1556            FS_Global.FileBufferFlags = Flags;
   1557            FS_UNLOCK_SYS();
   1558            FS_UNLOCK();
   \   0000001C   04D08DE2           ADD      SP,SP,#+4
   \   00000020   004080E5           STR      R4,[R0, #+0]
   \   00000024   0450C0E5           STRB     R5,[R0, #+4]
   \   00000028   3040BDE8           POP      {R4,R5,LR}
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   ........           B        FS_OS_Unlock     ;; tailcall
   1559          }
   1560          
   1561          /*********************************************************************
   1562          *
   1563          *       FS_ConfigFileBufferFlags
   1564          *
   1565          *  Description:
   1566          *    Is only allowed to be called immediately after a FS_FOpen(),
   1567          *    in order to change the buffer flags of a specific file
   1568          */

   \                                 In section .text, align 4, keep-with-next
   1569          void FS_ConfigFileBufferFlags(FS_FILE * pFile, int Flags) {
   1570            FS_FILE_BUFFER * pFileBuffer;
   1571          
   1572            pFileBuffer = pFile->pFileObj->pBuffer;
   \                     FS_ConfigFileBufferFlags:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
   \   00000004   240090E5           LDR      R0,[R0, #+36]
   1573            if (pFileBuffer) {
   \   00000008   000050E3           CMP      R0,#+0
   1574              pFileBuffer->Flags = Flags;
   \   0000000C   1510C015           STRBNE   R1,[R0, #+21]
   1575            } else {
   1576              FS_DEBUG_WARN((FS_MTYPE_API, "File buffer not set"));
   1577            }
   1578          }
   \   00000010   1EFF2FE1           BX       LR               ;; return
   1579          
   1580          #endif
   1581          
   1582          /*********************************************************************
   1583          *
   1584          *       FS_RemoveDevice
   1585          *
   1586          *  Function description:
   1587          *    Removes an instance of a device driver.
   1588          *
   1589          */

   \                                 In section .text, align 4, keep-with-next
   1590          void FS_RemoveDevice(const char * sVolume) {
   \                     FS_RemoveDevice:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1591            FS_VOLUME * pVolume;
   1592          
   1593            FS_LOCK();
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   ........           BL       FS_OS_Lock
   1594            pVolume = FS__FindVolume(sVolume, NULL);
   \   00000010   0010A0E3           MOV      R1,#+0
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   ........           BL       FS__FindVolume
   1595            if (pVolume) {
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0100000A           BEQ      ??FS_RemoveDevice_0
   1596              FS__RemoveDevice(pVolume);
   \   00000024   ........           BL       FS__RemoveDevice
   1597            }
   1598            FS_UNLOCK();
   \   00000028   0000A0E3           MOV      R0,#+0
   \                     ??FS_RemoveDevice_0:
   \   0000002C   1040BDE8           POP      {R4,LR}
   \   00000030   ........           B        FS_OS_Unlock     ;; tailcall
   1599          }
   1600          
   1601          /*********************************************************************
   1602          *
   1603          *       FS_SetFileWriteMode
   1604          *
   1605          *  Description:
   1606          *    Configures the file write mode.
   1607          *
   1608          *
   1609          *  Parameters:
   1610          *    WriteMode:   FS_WRITEMODE_SAFE   - Updates FAT and directory entry after each write operation
   1611          *                 FS_WRITEMODE_MEDIUM - Updates FAT after each write operation
   1612          *                 FS_WRITEMODE_FAST   - FAT and directory entry are updated when the file is closed.
   1613          */

   \                                 In section .text, align 4, keep-with-next
   1614          void FS_SetFileWriteMode(FS_WRITEMODE WriteMode) {
   \                     FS_SetFileWriteMode:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1615            FS_LOCK();
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   ........           BL       FS_OS_Lock
   1616            FS_LOCK_SYS();
   1617            FS_Global.WriteMode = WriteMode;
   \   00000010   ........           LDR      R0,??DataTable28
   \   00000014   8440C0E5           STRB     R4,[R0, #+132]
   1618            FS_UNLOCK_SYS();
   1619            FS_UNLOCK();
   \   00000018   1040BDE8           POP      {R4,LR}
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   ........           B        FS_OS_Unlock     ;; tailcall
   1620          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   ........           DC32     FS_Global

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   ........           DC32     FS_Global

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "r">`:
   \   00000000                      ; Initializer data, 2 bytes
   \   00000000   7200               DC8 114, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "rb">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   72620000           DC8 114, 98, 0, 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "w">`:
   \   00000000                      ; Initializer data, 2 bytes
   \   00000000   7700               DC8 119, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "wb">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   77620000           DC8 119, 98, 0, 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "a">`:
   \   00000000                      ; Initializer data, 2 bytes
   \   00000000   6100               DC8 97, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "ab">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   61620000           DC8 97, 98, 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "r+">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   722B0000           DC8 114, 43, 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "r+b">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   722B6200           DC8 114, 43, 98, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "rb+">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   72622B00           DC8 114, 98, 43, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "w+">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   772B0000           DC8 119, 43, 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "w+b">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   772B6200           DC8 119, 43, 98, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "wb+">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   77622B00           DC8 119, 98, 43, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "a+">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   612B0000           DC8 97, 43, 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "a+b">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   612B6200           DC8 97, 43, 98, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "ab+">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   61622B00           DC8 97, 98, 43, 0
   1621          
   1622          
   1623          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function                   .cstack
     --------                   -------
     FS_ClearErr                     8
     FS_ConfigFileBufferDefault     16
     FS_ConfigFileBufferFlags        0
     FS_ConfigUpdateDirOnWrite       8
     FS_FClose                      24
     FS_FEof                        16
     FS_FError                      16
     FS_FOpen                       16
     FS_FSeek                       16
     FS_FTell                       16
     FS_Init                         8
     FS_Remove                       8
     FS_RemoveDevice                 8
     FS_SetFileWriteMode             8
     FS__AllocFileHandle             8
     FS__AllocFileObj                8
     FS__AllocSectorBuffer           4
     FS__CalcSizeInBytes             0
     FS__CalcSizeInKB                0
     FS__FClose                     16
     FS__FCloseNL                   16
     FS__FOpen                      48
     FS__FOpenEx                    40
     FS__FSeek                       0
     FS__FTell                       0
     FS__FreeFileHandle              0
     FS__FreeFileObj                 0
     FS__FreeSectorBuffer            8
     FS__GetFileObj                  0
     FS__OpenEx                     48
     FS__Remove                     32
     FS__RemoveDevice               16
     FS__RemoveDevices              24
     FS__SB_Clean                    8
     FS__SB_Create                  12
     FS__SB_Delete                   8
     FS__SB_Flush                   16
     FS__SB_MarkDirty                0
     FS__SB_MarkNotDirty             0
     FS__SB_MarkValid               16
     FS__SB_Read                    16
     FS__SB_SetSector               16
     FS__SB_Write                    8


   Section sizes:

     Function/Label             Bytes
     --------------             -----
     _aAccessMode                120
     FS__AllocSectorBuffer        76
     FS__FreeSectorBuffer         64
     FS__SB_Flush                 76
     FS__SB_Create               132
     FS__SB_Delete               136
     FS__SB_Clean                 76
     FS__SB_MarkDirty             12
     FS__SB_SetSector            108
     FS__SB_MarkValid            120
     FS__SB_MarkNotDirty          12
     FS__SB_Read                  96
     FS__SB_Write                 76
     FS__AllocFileHandle         136
     FS__FreeFileHandle           20
     FS__AllocFileObj            136
     FS__GetFileObj                8
     FS__FreeFileObj              24
     FS__FTell                    20
     FS__FCloseNL                 84
     FS__FClose                  100
     FS__FSeek                   104
     FS__CalcSizeInBytes          60
     FS__CalcSizeInKB             36
     FS__Remove                  188
     FS__OpenEx                  368
     FS__FOpenEx                 160
     FS__FOpen                   240
     FS_FOpen                     60
     FS_Remove                    44
     FS_FClose                   132
     FS_FSeek                    140
     FS_FTell                     52
     FS_FEof                      96
     FS_FError                    52
     FS_ClearErr                  40
     FS__RemoveDevice            216
     FS__RemoveDevices           124
     FS_Init                     148
     FS_ConfigUpdateDirOnWrite    48
     FS_ConfigFileBufferDefault   52
     FS_ConfigFileBufferFlags     20
     FS_RemoveDevice              52
     FS_SetFileWriteMode          36
     ??DataTable27                 4
     ??DataTable28                 4
     ?<Constant "r">               2
     ?<Constant "rb">              4
     ?<Constant "w">               2
     ?<Constant "wb">              4
     ?<Constant "a">               2
     ?<Constant "ab">              4
     ?<Constant "r+">              4
     ?<Constant "r+b">             4
     ?<Constant "rb+">             4
     ?<Constant "w+">              4
     ?<Constant "w+b">             4
     ?<Constant "wb+">             4
     ?<Constant "a+">              4
     ?<Constant "a+b">             4
     ?<Constant "ab+">             4

 
    54 bytes in section .rodata
 4 108 bytes in section .text
 
 4 108 bytes of CODE  memory
    54 bytes of CONST memory

Errors: none
Warnings: none
