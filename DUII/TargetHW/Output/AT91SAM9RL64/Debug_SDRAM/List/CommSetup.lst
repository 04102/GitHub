###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     02/Feb/2016  18:31:50 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\Setup\CommSetup.c                       #
#    Command line =  C:\DUII\TargetHW\Setup\CommSetup.c -D DEBUG=1 -D         #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D                   #
#                    XIGNORE_TEMPERATURE -D BUILD_DEBUG_PORT -D PROFILER      #
#                    -lCN C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Li #
#                    st\ -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\ #
#                    Obj\ --debug --endian=little --cpu=ARM926EJ-S -e         #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\Co #
#                    mmSetup.lst                                              #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\Com #
#                    mSetup.o                                                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\Setup\CommSetup.c
      1          /*
      2          ----------------------------------------------------------------------
      3          File    : CommSetup.c adapted from RTOSINIT_AT91SAM9RL64.c
      4                    for ATMEL AT91SAM9Rx64 CPU
      5          
      6          Purpose : Initializes and handles the hardware for the App as far
      7                    as required by the OS.
      8                    Feel free to modify this file acc. to your
      9                    target system.
     10          
     11          Limitations: App can only have single UART enabled.
     12          
     13          No hardware flow control. N-8-1. baudrate definable.
     14          
     15          EmbOsView can be independently operated on UART 1
     16          Debug statements can be independently operated on DBGU
     17          
     18          --------  END-OF-HEADER  ---------------------------------------------
     19          */
     20          
     21          #include "RTOS.H"
     22          #include "commondefs.h"
     23          #include "DUII.h"
     24          #include "CommTask.h"
     25          
     26          /*
     27          external functions
     28          */
     29          extern OS_ISR_HANDLER* OS_ARM_InstallISRHandler (int , OS_ISR_HANDLER* );
     30          extern void OS_ARM_EnableISR(int );
     31          extern void OS_ARM_DisableISR(int );
     32          extern int OS_ARM_ISRSetPrio(int , int );
     33          extern void App_Comm_Setup(void);
     34          
     35          #define APP_UART (0)				// use USART 0 for application
     36          #define APP_UART_PRIO    (0x03)		// (0-7) priority for application UART interrupts
     37          #define APP_BAUDRATE (230400)		// SU communicatio = 230kbaud
     38          
     39          /*********************************************************************
     40          *
     41          *       Configuration
     42          *
     43          **********************************************************************
     44          */
     45          
     46          #define OS_FSYS 200000000uL
     47          
     48          #ifndef   OS_PCLK_TIMER
     49            #define OS_PCLK_TIMER (OS_FSYS / 2)
     50          #endif
     51          
     52          /*********************************************************************
     53          *
     54          *       UART settings for Application
     55          *       If you do not want (or can not due to hardware limitations)
     56          *       to dedicate a UART to Application, please define it to be -1
     57          */
     58          #ifndef   APP_PCLK_UART
     59            #define APP_PCLK_UART (OS_FSYS / 2)
     60          #endif
     61          
     62          #define APP_UART_USED ((APP_UART == 0) || (APP_UART == 1) || (APP_UART == 2))
     63          
     64          /*********************************************************************
     65          *
     66          *       Local defines (sfrs used in RTOSInit.c)
     67          *
     68          **********************************************************************
     69          */
     70          
     71          /*      USART, used for Application communication */
     72          #define _USART0_BASE_ADDR  (0xFFFB0000)
     73          #define _USART1_BASE_ADDR  (0xFFFB4000)
     74          #define _USART2_BASE_ADDR  (0xFFFB8000)
     75          
     76          /*      PIO control register */
     77          #define _PIOA_BASE_ADDR    (0xfffff400)
     78          #define _PIOB_BASE_ADDR    (0xfffff600)
     79          #define _PIOC_BASE_ADDR    (0xfffff800)
     80          
     81          /*      Power management controller */
     82          #define _PMC_BASE_ADDR     (0xFFFFFC00)
     83          
     84          #define _PMC_CKGR_PLLAR (*(volatile OS_U32*) (_PMC_BASE_ADDR + 0x28))  /* PLLA register */
     85          #define _PMC_CKGR_PLLBR (*(volatile OS_U32*) (_PMC_BASE_ADDR + 0x2c))  /* PLLB register */
     86          
     87          #define _PMC_PCER     (*(volatile OS_U32*) (_PMC_BASE_ADDR + 0x10))  /* Peripheral clock enable register */
     88          #define _PMC_MOR      (*(volatile OS_U32*) (_PMC_BASE_ADDR + 0x20))  /* main oscillator register */
     89          #define _PMC_PLLR     (*(volatile OS_U32*) (_PMC_BASE_ADDR + 0x2c))  /* PLL register */
     90          #define _PMC_MCKR     (*(volatile OS_U32*) (_PMC_BASE_ADDR + 0x30))  /* Master clock register */
     91          #define _PMC_SR       (*(volatile OS_U32*) (_PMC_BASE_ADDR + 0x68))  /* status register */
     92          #define _PMC_IMR      (*(volatile OS_U32*) (_PMC_BASE_ADDR + 0x6C))  /* interrupt mask register */
     93          
     94          #define _PMC_MOSCS    (1 <<  0)
     95          #define _CKGR_MAINRDY (1 << 16)
     96          #define _PMC_LOCKA    (1 <<  1)
     97          #define _PMC_LOCKB    (1 <<  2)
     98          #define _PMC_MCKRDY   (1 <<  3)
     99          #define _PMC_PCKRDY2  (1 << 10)
    100          #define _PMC_PCKRDY1  (1 <<  9)
    101          #define _PMC_PCKRDY0  (1 <<  8)
    102          #define _PMC_MASK_ALL (_PMC_PCKRDY2 | _PMC_PCKRDY1 | _PMC_PCKRDY0 | \
    103                                 _PMC_MCKRDY  | _PMC_LOCKB    | _PMC_MOSCS)
    104          
    105          /*      Advanced interrupt controller (AIC) */
    106          #define _AIC_BASE_ADDR      (0xfffff000)
    107          #define _AIC_SMR_BASE_ADDR  (_AIC_BASE_ADDR + 0x00)
    108          #define _AIC_SVR_BASE_ADDR  (_AIC_BASE_ADDR + 0x80)
    109          #define _AIC_SVR0      (*(volatile OS_U32*) (_AIC_SVR_BASE_ADDR + 0x00))
    110          #define _AIC_SVR1      (*(volatile OS_U32*) (_AIC_SVR_BASE_ADDR + 0x04))
    111          #define _AIC_IVR       (*(volatile OS_U32*) (_AIC_BASE_ADDR + 0x100))
    112          #define _AIC_ISR       (*(volatile OS_U32*) (_AIC_BASE_ADDR + 0x108))
    113          #define _AIC_IPR       (*(volatile OS_U32*) (_AIC_BASE_ADDR + 0x10c))
    114          #define _AIC_IDCR      (*(volatile OS_U32*) (_AIC_BASE_ADDR + 0x124))
    115          #define _AIC_ICCR      (*(volatile OS_U32*) (_AIC_BASE_ADDR + 0x128))
    116          #define _AIC_IECR      (*(volatile OS_U32*) (_AIC_BASE_ADDR + 0x120))
    117          #define _AIC_EOICR     (*(volatile OS_U32*) (_AIC_BASE_ADDR + 0x130))
    118          #define _AIC_SPU       (*(volatile OS_U32*) (_AIC_BASE_ADDR + 0x134))
    119          #define _AIC_DCR       (*(volatile OS_U32*) (_AIC_BASE_ADDR + 0x138))
    120          #define _AIC_FFDR      (*(volatile OS_U32*) (_AIC_BASE_ADDR + 0x144))
    121          
    122          /*      AIC interrupt sources and peripheral IDs        */
    123          #define _SYSTEM_IRQ_ID  (1)   /* System IRQ ID             */
    124          #define _US0IRQ_ID      (6)   /* USART Channel 0 interrupt */
    125          #define _US1IRQ_ID      (7)   /* USART Channel 1 interrupt */
    126          #define _US2IRQ_ID      (8)   /* USART Channel 2 interrupt */
    127          
    128          #ifndef   _NUM_INT_SOURCES
    129            #define _NUM_INT_SOURCES   (32)
    130          #endif
    131          
    132          #define _INT_PRIORITY_MASK (0x07)
    133          #define _NUM_INT_PRIORITIES   (8)
    134          
    135          /*      MATRIX + EBI interface */
    136          #define _MATRIX_BASE_ADDR   (0xFFFFEE00)                                // MATRIX Base Address
    137          
    138          //#define _MATRIX_MCFG   (*(volatile OS_U32*) (_MATRIX_BASE_ADDR + 0x00)) // MATRIX Master configuration register
    139          #define _MATRIX_EBICSA (*(volatile OS_U32*) (_MATRIX_BASE_ADDR + 0x120)) // MATRIX EBI Chip Select Assignment register
    140          
    141          /*      PIOC, used as data BUS */
    142          #define _PIOB_PDR      (*(volatile OS_U32*) (_PIOB_BASE_ADDR + 0x04))    // PIOB disable register
    143          #define _PIOB_MDDR     (*(volatile OS_U32*) (_PIOB_BASE_ADDR + 0x54))    // PIOB multi driver disable register
    144          #define _PIOB_ASR      (*(volatile OS_U32*) (_PIOB_BASE_ADDR + 0x70))    // PIOB peripheral A select register
    145          
    146          /*********************************************************************
    147          *
    148          *       local data
    149          *
    150          **********************************************************************
    151          */
    152          
    153          /*********************************************************************
    154          *
    155          *       Static data
    156          *
    157          **********************************************************************
    158          */
    159          
    160          /*********************************************************************
    161          *
    162          *       Local functions
    163          *
    164          **********************************************************************
    165          */
    166          
    167          /*********************************************************************
    168          *
    169          *       Communication for Application via UART
    170          *
    171          **********************************************************************
    172          */
    173          
    174          #if (APP_UART == 0)
    175          	#define _PIO_US_BASE_ADDR     (_PIOA_BASE_ADDR)
    176          	#define _APP_UART_BASE_ADDR    (_USART0_BASE_ADDR)
    177          	#define APP_UART_ID           (_US0IRQ_ID)
    178          	#define APP_UART_RX_PIN       (7)
    179          	#define APP_UART_TX_PIN       (6)
    180          #elif (APP_UART == 1)
    181          	#define _PIO_US_BASE_ADDR     (_PIOA_BASE_ADDR)
    182          	#define _APP_UART_BASE_ADDR    (_USART1_BASE_ADDR)
    183          	#define APP_UART_ID            (_US1IRQ_ID)
    184          	#define APP_UART_RX_PIN        (12)
    185          	#define APP_UART_TX_PIN        (11)
    186          #elif (APP_UART == 2)
    187          	#define _PIO_US_BASE_ADDR     (_PIOA_BASE_ADDR)
    188          	#define _APP_UART_BASE_ADDR    (_USART2_BASE_ADDR)
    189          	#define APP_UART_ID            (_US2IRQ_ID)
    190          	#define APP_UART_RX_PIN        (14)
    191          	#define APP_UART_TX_PIN        (13)
    192          #endif
    193          
    194            #define _PIO_US_PDR  (*(volatile OS_U32*)(_PIO_US_BASE_ADDR + 0x04)) // PIO disable register
    195            #define _PIO_US_ASR  (*(volatile OS_U32*)(_PIO_US_BASE_ADDR + 0x70)) // PIO peripheral "A" select register
    196            #define _PIO_US_BSR  (*(volatile OS_U32*)(_PIO_US_BASE_ADDR + 0x74)) // PIO peripheral "B" select register
    197          
    198            #define PIO_PDR_USART ((1 << APP_UART_RX_PIN) | (1 << APP_UART_TX_PIN))
    199          
    200            #define _US_CR   (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x00))
    201            #define _US_MR   (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x04))
    202            #define _US_IER  (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x08))
    203            #define _US_IDR  (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x0c))
    204            #define _US_IMR  (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x10))
    205            #define _US_CSR  (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x14))
    206            #define _US_RHR  (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x18))
    207            #define _US_THR  (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x1c))
    208            #define _US_BRGR (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x20))
    209            #define _US_RTOR (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x24))
    210            #define _US_TTGR (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x28))
    211          
    212            #define _US_TPR  (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x108))
    213            #define _US_TCR  (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x10c))
    214            #define _US_PTCR (*(volatile OS_U32*)(_APP_UART_BASE_ADDR + 0x120))
    215          
    216            #define US_RXRDY		(1 << 0)		// Rx status flag
    217            #define US_TXRDY		(1 << 1)		// Tx RDY Status flag
    218            #define US_ENDTX		(1 << 4)		// Tx end flag
    219            #define US_TXEMPTY	(1 << 9)		// Tx EMPTY Status flag
    220            #define US_TXBUFE		(1 << 11)		// Tx Buffer Empty Status flag
    221            #define US_RXBUFF		(1 << 12)		// Rx Buffer Full Status flag
    222          
    223            #define USART_RX_ERROR_FLAGS (0xE0) /* Parity, framing, overrun error  */
    224          
    225          // -------- PDC_PTCR : (PDC Offset: 0x20) PDC Transfer Control Register --------
    226          #define AT91C_PDC_RXTEN       (0x1 <<  0) // (PDC) Receiver Transfer Enable
    227          #define AT91C_PDC_RXTDIS      (0x1 <<  1) // (PDC) Receiver Transfer Disable
    228          #define AT91C_PDC_TXTEN       (0x1 <<  8) // (PDC) Transmitter Transfer Enable
    229          #define AT91C_PDC_TXTDIS      (0x1 <<  9) // (PDC) Transmitter Transfer Disable
    230          
    231          #ifdef UARTDMA
    232          /*********************************************************************
    233          *
    234          *       App_putstring()
    235          */
    236          
    237          void App_putstring(void *buffer, unsigned int size) {
    238          
    239          
    240          	while((_US_CSR & US_ENDTX) == 0) ;	// Wait until buffer becomes available
    241          
    242          	_US_TPR = (unsigned int) buffer;	// the non-volatile buffer
    243          	_US_TCR = size;						// number of chars
    244          	_US_PTCR = AT91C_PDC_TXTEN;			// enable transfer
    245          }
    246          #else			// single character transmit
    247          
    248          #if 0		// in case of datatrace
    249          typedef struct {
    250          	int rcvdid;
    251          	int rcvdlen;
    252          	int sentid;
    253          	int sentlen;
    254          	float maxxg;
    255          } messagehistorytype;
    256          
    257          messagehistorytype messagehistory[100];
    258          int messagecounter = 0;
    259          #endif
    260          
    261          
    262          // This function starts an interrupt-driven transmit of the trasmit buffer
    263          // on designated UART. Blocks only if previous transmission is in progress.

   \                                 In section .text, align 4, keep-with-next
    264          void XmitUART(comporthandle *handle, u16 numbytes) {
   \                     XmitUART:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    265          
    266          	while (0 != handle->txbytes)
   \   00000008   B200D4E1           LDRH     R0,[R4, #+2]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0400000A           BEQ      ??XmitUART_0
    267          		OS_Delay(5) ;		// wait for previous transmission to finish
   \                     ??XmitUART_1:
   \   0000001C   0500A0E3           MOV      R0,#+5
   \   00000020   ........           BL       OS_Delay
   \   00000024   B200D4E1           LDRH     R0,[R4, #+2]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   FAFFFF1A           BNE      ??XmitUART_1
    268          //	while (0 != CTS[handle->port]);
    269          	
    270          	handle->txptr = handle->txbuff;
   \                     ??XmitUART_0:
   \   00000030   100094E5           LDR      R0,[R4, #+16]
    271          	handle->txbytes = numbytes;
    272          
    273          	// put the first character in the buffer to get things started
    274          //	_US_THR = *(handle->txptr);
    275          
    276          	// adjust counters
    277          //	(com[0].txptr)++;
    278          //	(com[0].txbytes)--;
    279          		
    280          	// enable interrupts
    281          	_US_IER = US_TXRDY;	
   \   00000034   0210A0E3           MOV      R1,#+2
   \   00000038   080084E5           STR      R0,[R4, #+8]
   \   0000003C   ........           LDR      R0,??DataTable2  ;; 0xfffb0008
   \   00000040   B250C4E1           STRH     R5,[R4, #+2]
   \   00000044   001080E5           STR      R1,[R0, #+0]
    282          } // XmitUART
   \   00000048   04D08DE2           ADD      SP,SP,#+4
   \   0000004C   3080BDE8           POP      {R4,R5,PC}       ;; return
    283          	
    284          #endif
    285          
    286          
    287          /*********************************************************************
    288          *
    289          *       App_ISR_Usart() Application USART interrupt handler
    290          *       handles both Rx and Tx interrupt
    291          *		processes single character receive
    292          *		sends messages via DMA buffer
    293          *
    294          *		parses TCAT Traqmate Communications Protocol character by character
    295          */
    296          

   \                                 In section .text, align 4, keep-with-next
    297          static void App_ISR_Usart(void) {
   \                     App_ISR_Usart:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    298          	int UsartStatus;
    299          	volatile int Dummy;
    300          	u08 tempch;
    301          	static int msg_state = LOOKING_FOR_SYNC;	// init state machine variable
    302          	static int msg_length ; 					// variables to build message
    303          	static u08 chk = 0;							// init the checksum variable
    304          	static int index = 0;						// init the receive character storage index
    305          	static u08 *msgbuff;						// for quicker access to buffer
    306          
    307          	UsartStatus = _US_CSR;							// get uart status
   \   00000004   FF44A0E3           MOV      R4,#-16777216
   \   00000008   FB4884E3           ORR      R4,R4,#0xFB0000
   \   0000000C   145094E5           LDR      R5,[R4, #+20]
   \   00000010   04D04DE2           SUB      SP,SP,#+4
    308          	if (UsartStatus & US_RXRDY) {				// check for data received
   \   00000014   010015E3           TST      R5,#0x1
   \   00000018   6900000A           BEQ      ??App_ISR_Usart_1
    309          		if (UsartStatus & USART_RX_ERROR_FLAGS) {	// check for errors
   \   0000001C   E00015E3           TST      R5,#0xE0
   \   00000020   0400000A           BEQ      ??App_ISR_Usart_2
    310          			Dummy = _US_RHR;						// discard data with errors
   \   00000024   180094E5           LDR      R0,[R4, #+24]
   \   00000028   00008DE5           STR      R0,[SP, #+0]
    311          			_US_CR = (1 << 8);						// reset error status bits PARE, FRAME, OVRE and RXBRK */
   \   0000002C   400FA0E3           MOV      R0,#+256
   \   00000030   000084E5           STR      R0,[R4, #+0]
   \   00000034   620000EA           B        ??App_ISR_Usart_1
    312          		} // if
   \                     ??App_ISR_Usart_2:
   \   00000038   ........           LDR      R0,??DataTable2_1
    313          		else {		// process character
    314          			tempch = _US_RHR;
   \   0000003C   182094E5           LDR      R2,[R4, #+24]
    315          
    316          			switch(msg_state) { 					// based on the state of reception we are in
   \   00000040   003090E5           LDR      R3,[R0, #+0]
   \   00000044   1010D0E5           LDRB     R1,[R0, #+16]
   \   00000048   01C043E2           SUB      R12,R3,#+1
   \   0000004C   03005CE3           CMP      R12,#+3
   \   00000050   0CF18F90           ADDLS    PC,PC,R12, LSL #+2
   \                     ??App_ISR_Usart_0:
   \   00000054   4300008A           BHI      ??App_ISR_Usart_3
   \   00000058   020000EA           B        ??App_ISR_Usart_4
   \   0000005C   160000EA           B        ??App_ISR_Usart_5
   \   00000060   200000EA           B        ??App_ISR_Usart_6
   \   00000064   360000EA           B        ??App_ISR_Usart_7
    317          			case LOOKING_FOR_SYNC:				// state = 1
    318          				index = 0;       				// init the storage index
   \                     ??App_ISR_Usart_4:
   \   00000068   00C0A0E3           MOV      R12,#+0
    319          				if (tempch==SOH) {				// if start of header byte received
   \   0000006C   FF2002E2           AND      R2,R2,#0xFF
   \   00000070   08C080E5           STR      R12,[R0, #+8]
   \   00000074   160052E3           CMP      R2,#+22
   \   00000078   3A00001A           BNE      ??App_ISR_Usart_3
    320          					msgbuff = msgrxbuff[com[0].rxnextidx];	// for quicker access to buffer
   \   0000007C   ........           LDR      R2,??DataTable2_2
   \   00000080   1D30A0E3           MOV      R3,#+29
   \   00000084   0D20D2E5           LDRB     R2,[R2, #+13]
   \   00000088   ........           LDR      R12,??DataTable2_3
   \   0000008C   803F83E3           ORR      R3,R3,#0x200
   \   00000090   83C202E1           SMLABB   R2,R3,R2,R12
    321          					msgbuff[index++]=tempch ;	// store SOH
   \   00000094   1630A0E3           MOV      R3,#+22
   \   00000098   0C2080E5           STR      R2,[R0, #+12]
   \   0000009C   0030C2E5           STRB     R3,[R2, #+0]
   \   000000A0   0120A0E3           MOV      R2,#+1
   \   000000A4   082080E5           STR      R2,[R0, #+8]
    322          					chk ^= tempch ;				// start checksum calc
    323          					msg_state = POSSIBLE_SYNC;      // update state
   \   000000A8   0220A0E3           MOV      R2,#+2
   \   000000AC   002080E5           STR      R2,[R0, #+0]
   \   000000B0   161021E2           EOR      R1,R1,#0x16
   \                     ??App_ISR_Usart_8:
   \   000000B4   1010C0E5           STRB     R1,[R0, #+16]
   \   000000B8   410000EA           B        ??App_ISR_Usart_1
    324          				}
    325          				break ;
    326          			
    327          			case POSSIBLE_SYNC:					// state = 2
    328          				msgbuff[index++] = tempch ;	// get the next byte
   \                     ??App_ISR_Usart_5:
   \   000000BC   08C090E5           LDR      R12,[R0, #+8]
   \   000000C0   0CE090E5           LDR      LR,[R0, #+12]
    329          				chk ^= tempch ;				// continue checksum calc
   \   000000C4   011022E0           EOR      R1,R2,R1
   \   000000C8   0E20CCE7           STRB     R2,[R12, +LR]
   \   000000CC   01C08CE2           ADD      R12,R12,#+1
   \   000000D0   08C080E5           STR      R12,[R0, #+8]
    330          				if (index == CHECKSUM)			// see if we should have
   \   000000D4   06005CE3           CMP      R12,#+6
   \   000000D8   2200001A           BNE      ??App_ISR_Usart_3
    331          					msg_state = DO_CHECKSUM;		// received the checksum
   \   000000DC   0320A0E3           MOV      R2,#+3
   \   000000E0   002080E5           STR      R2,[R0, #+0]
   \   000000E4   F2FFFFEA           B        ??App_ISR_Usart_8
    332          				break ;
    333          	
    334          			case DO_CHECKSUM:					// state = 3
    335          				msgbuff[index++]=tempch ;		// store rcv checksum
   \                     ??App_ISR_Usart_6:
   \   000000E8   08C090E5           LDR      R12,[R0, #+8]
   \   000000EC   0C3090E5           LDR      R3,[R0, #+12]
    336          				chk ^= 0xff ;					// final calculation exor
   \   000000F0   FF1021E2           EOR      R1,R1,#0xFF
   \   000000F4   0320CCE7           STRB     R2,[R12, +R3]
   \   000000F8   01C08CE2           ADD      R12,R12,#+1
    337          				if (chk == tempch) {			// check against rcv'd checksum
   \   000000FC   022CA0E1           MOV      R2,R2, LSL #+24
   \   00000100   08C080E5           STR      R12,[R0, #+8]
   \   00000104   220C51E1           CMP      R1,R2, LSR #+24
   \   00000108   0700001A           BNE      ??App_ISR_Usart_9
    338          												// if they match, get the message length
    339          					msg_length = msgbuff[UPPER_BYTE_COUNT];
    340          					msg_length = msg_length << 8 ;
    341          					msg_length += msgbuff[LOWER_BYTE_COUNT];
   \   0000010C   0320D3E5           LDRB     R2,[R3, #+3]
   \   00000110   0430D3E5           LDRB     R3,[R3, #+4]
   \   00000114   022493E0           ADDS     R2,R3,R2, LSL #+8
   \   00000118   042080E5           STR      R2,[R0, #+4]
    342          	
    343          					if(msg_length) msg_state=FOUND_SYNC ;	// remainder of message
   \   0000011C   1400000A           BEQ      ??App_ISR_Usart_10
   \   00000120   0420A0E3           MOV      R2,#+4
   \   00000124   002080E5           STR      R2,[R0, #+0]
   \   00000128   E1FFFFEA           B        ??App_ISR_Usart_8
    344          					else msg_state=MESSAGE_COMPLETE;		// no message remaining
    345          				}
    346          				else {							// if checksum failed, start looking again
    347          					index=0;					// discard all received data
   \                     ??App_ISR_Usart_9:
   \   0000012C   0020A0E3           MOV      R2,#+0
    348          					msg_state=LOOKING_FOR_SYNC;		// set new state
   \   00000130   0110A0E3           MOV      R1,#+1
   \   00000134   082080E5           STR      R2,[R0, #+8]
   \   00000138   001080E5           STR      R1,[R0, #+0]
    349          					chk = 0;					// re-init checksum byte
   \   0000013C   1020C0E5           STRB     R2,[R0, #+16]
   \   00000140   1F0000EA           B        ??App_ISR_Usart_1
    350          				}
    351          				break ;
    352          			
    353          			case FOUND_SYNC:					// get remainder of message // state = 4
    354          				msgbuff[index++]=tempch ;		// store the data
   \                     ??App_ISR_Usart_7:
   \   00000144   08C090E5           LDR      R12,[R0, #+8]
   \   00000148   0CE090E5           LDR      LR,[R0, #+12]
   \   0000014C   0E20CCE7           STRB     R2,[R12, +LR]
    355          				if (index == DATA_START+msg_length)		// see if finished
   \   00000150   042090E5           LDR      R2,[R0, #+4]
   \   00000154   01C08CE2           ADD      R12,R12,#+1
   \   00000158   072082E2           ADD      R2,R2,#+7
   \   0000015C   08C080E5           STR      R12,[R0, #+8]
   \   00000160   02005CE1           CMP      R12,R2
   \   00000164   0200000A           BEQ      ??App_ISR_Usart_10
   \                     ??App_ISR_Usart_3:
   \   00000168   1010C0E5           STRB     R1,[R0, #+16]
    356          					msg_state=MESSAGE_COMPLETE ;			// set message complete
    357          				break;
    358          	
    359          			default:            // should never get here if state machine works
    360          				break ;
    361          			} // switch
    362          												// state = 5
    363          			if(msg_state==MESSAGE_COMPLETE) {	// check to see if complete msg received
   \   0000016C   050053E3           CMP      R3,#+5
   \   00000170   1300001A           BNE      ??App_ISR_Usart_1
    364          
    365          #if 0				
    366          				messagehistory[messagecounter].rcvdid = msgbuff[OPCODE];
    367          				messagehistory[messagecounter].rcvdlen = msg_length;
    368          				messagehistory[messagecounter].maxxg = DataValues[MAX_X_G].fVal;
    369          
    370          				if (messagecounter < 100)
    371          					messagecounter++;
    372          				else
    373          					messagecounter--;
    374          #endif
    375          				
    376          				msg_state=LOOKING_FOR_SYNC ; // if so, set up for new msg
   \                     ??App_ISR_Usart_10:
   \   00000174   0110A0E3           MOV      R1,#+1
   \   00000178   001080E5           STR      R1,[R0, #+0]
    377          				index = 0 ;              // reset index
    378          				chk = 0;                 // reset checksum variable
    379          				if (NULL == com[0].rxptr)	{	// if last buffer processed
   \   0000017C   ........           LDR      R1,??DataTable2_2
   \   00000180   0020A0E3           MOV      R2,#+0
   \   00000184   043091E5           LDR      R3,[R1, #+4]
   \   00000188   082080E5           STR      R2,[R0, #+8]
   \   0000018C   1020C0E5           STRB     R2,[R0, #+16]
   \   00000190   000053E3           CMP      R3,#+0
   \   00000194   0A00001A           BNE      ??App_ISR_Usart_1
    380          					com[0].rxptr = msgbuff; 		// set semaphore
   \   00000198   0C0090E5           LDR      R0,[R0, #+12]
   \   0000019C   040081E5           STR      R0,[R1, #+4]
    381          //					com[0].rxnextidx = 1 - com[0].rxnextidx;	// swap buffers
    382          					if (++(com[0].rxnextidx) >= NUM_RX_BUFF) com[0].rxnextidx = 0;	// go to next buffer
   \   000001A0   0D00D1E5           LDRB     R0,[R1, #+13]
   \   000001A4   010080E2           ADD      R0,R0,#+1
   \   000001A8   0D00C1E5           STRB     R0,[R1, #+13]
   \   000001AC   FF0000E2           AND      R0,R0,#0xFF
   \   000001B0   030050E3           CMP      R0,#+3
   \   000001B4   0D20C125           STRBCS   R2,[R1, #+13]
    383          					OS_SignalEvent((1 << TCAT_MSG_RECEIVED), &commTCB);
   \   000001B8   ........           LDR      R1,??DataTable2_4
   \   000001BC   8000A0E3           MOV      R0,#+128
   \   000001C0   ........           BL       OS_SignalEvent
    384          				} // if
    385          			} // if
    386          		} // else
    387          	} // if
    388          
    389          //	UsartStatus = _US_CSR;					// get uart status
    390          	
    391          #ifdef UARTDMA
    392          	if (UsartStatus & US_ENDTX) {			// check if transmission finished
    393          		_US_IDR = US_ENDTX;					// disable interrupt
    394          //		_US_PTCR = AT91C_PDC_TXTDIS;		// disable DMA transfer
    395          		com[0].txptr = NULL;				// mark transmit buffer as empty
    396          	} // if
    397          #else // single character transmit
    398          	
    399          	if (UsartStatus & US_TXRDY ) {		// byte transmitted
   \                     ??App_ISR_Usart_1:
   \   000001C4   020015E3           TST      R5,#0x2
   \   000001C8   1100000A           BEQ      ??App_ISR_Usart_11
    400          		if (0 != com[0].txbytes) {
   \   000001CC   ........           LDR      R1,??DataTable2_2
   \   000001D0   B200D1E1           LDRH     R0,[R1, #+2]
   \   000001D4   000050E3           CMP      R0,#+0
   \   000001D8   0900000A           BEQ      ??App_ISR_Usart_12
    401          			_US_THR = *(com[0].txptr);
   \   000001DC   080091E5           LDR      R0,[R1, #+8]
   \   000001E0   0000D0E5           LDRB     R0,[R0, #+0]
   \   000001E4   1C0084E5           STR      R0,[R4, #+28]
    402          			(com[0].txptr)++;
   \   000001E8   080091E5           LDR      R0,[R1, #+8]
   \   000001EC   010080E2           ADD      R0,R0,#+1
   \   000001F0   080081E5           STR      R0,[R1, #+8]
    403          			(com[0].txbytes)--;
   \   000001F4   B200D1E1           LDRH     R0,[R1, #+2]
   \   000001F8   010040E2           SUB      R0,R0,#+1
   \   000001FC   B200C1E1           STRH     R0,[R1, #+2]
   \   00000200   030000EA           B        ??App_ISR_Usart_11
    404          		}
    405          		else {
    406          			_US_IDR = US_TXRDY;			// disable transmit interrupt
   \                     ??App_ISR_Usart_12:
   \   00000204   0200A0E3           MOV      R0,#+2
   \   00000208   0C0084E5           STR      R0,[R4, #+12]
    407          			com[0].txptr = NULL;		// clear pointer
   \   0000020C   0000A0E3           MOV      R0,#+0
   \   00000210   080081E5           STR      R0,[R1, #+8]
    408          		}
    409          	} // if
    410          #endif
    411          
    412          } // App_ISR_Usart
   \                     ??App_ISR_Usart_11:
   \   00000214   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000218   3080BDE8           POP      {R4,R5,PC}       ;; return

   \                                 In section .data, align 4
   \                     ??msg_state:
   \   00000000   01000000           DC32 1
   \   00000004   00000000           DC8 0, 0, 0, 0
   \   00000008   00000000           DC32 0
   \   0000000C   00000000           DC8 0, 0, 0, 0
   \   00000010   00                 DC8 0
    413          
    414          
    415          /*********************************************************************
    416          *
    417          *       App_COM_Init()
    418          *       Initialize UART for Application
    419          */
    420          void App_COM_Init(void);

   \                                 In section .text, align 4, keep-with-next
    421          void App_COM_Init(void) {             /* Initialize UART, enable UART interrupts */
   \                     App_COM_Init:
   \   00000000   10402DE9           PUSH     {R4,LR}
    422            _PMC_PCER  = (1 << APP_UART_ID);    /* Enable peripheral clock for selected USART */
   \   00000004   E800A0E3           MOV      R0,#+232
   \   00000008   4040A0E3           MOV      R4,#+64
   \   0000000C   A00E80E3           ORR      R0,R0,#0xA00
   \   00000010   D84E00E5           STR      R4,[R0, #-3800]
    423            _PIO_US_PDR  = PIO_PDR_USART;      /* Enable peripheral output signals on PIO for USART (disable PIO Port) */
   \   00000014   C000A0E3           MOV      R0,#+192
   \   00000018   B71FA0E3           MOV      R1,#+732
   \   0000001C   D80E01E5           STR      R0,[R1, #-3800]
    424            _PIO_US_ASR  = PIO_PDR_USART;      /* Select "A" peripherals on PIO for USART (USART Rx, TX) */
   \   00000020   D21FA0E3           MOV      R1,#+840
   \   00000024   D80E01E5           STR      R0,[R1, #-3800]
    425            _PIO_US_BSR  = 0;                  /* Deselct "B" peripherals on PIO for USART */
   \   00000028   D30FA0E3           MOV      R0,#+844
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   D81E00E5           STR      R1,[R0, #-3800]
    426            _US_CR   = (1 <<  2) |             /* RSTRX: Reset Receiver: 1 = The receiver logic is reset. */
    427                       (1 <<  3)               /* RSTTX: Reset Transmitter: 1 = The transmitter logic is reset. */
    428                     ;
   \   00000034   FF04A0E3           MOV      R0,#-16777216
   \   00000038   FB0880E3           ORR      R0,R0,#0xFB0000
   \   0000003C   0C10A0E3           MOV      R1,#+12
   \   00000040   001080E5           STR      R1,[R0, #+0]
    429            _US_CR   = (0 <<  2) |             /* RSTRX: Reset Receiver: 1 = The receiver logic is reset. */
    430                       (0 <<  3) |             /* RSTTX: Reset Transmitter: 1 = The transmitter logic is reset. */
    431                       (1 <<  4) |             /* RXEN: Receiver Enable: 1 = The receiver is enabled if RXDIS is 0. */
    432                       (0 <<  5) |             /* RXDIS: Receiver Disable: 0 = Noeffect. */
    433                       (1 <<  6) |             /* TXEN: Transmitter Enable: 1 = The transmitter is enabled if TXDIS is 0. */
    434                       (0 <<  7) |             /* TXDIS: Transmitter Disable: 0 = Noeffect. */
    435                       (1 <<  8) |             /* RSTSTA: Reset Status Bits: 1 = Resets the status bits PARE, FRAME, OVRE and RXBRK in the US_CSR. */
    436                       (0 <<  9) |             /* STTBRK: Start Break: 0 = Noeffect. */
    437                       (0 << 10) |             /* STPBRK: Stop Break: 0 = Noeffect. */
    438                       (0 << 11) |             /* STTTO: Start Time-out: 0 = Noeffect. */
    439                       (0 << 12)               /* SENDA: Send Address: 0 = Noeffect. */
    440                     ;
   \   00000044   541FA0E3           MOV      R1,#+336
   \   00000048   001080E5           STR      R1,[R0, #+0]
    441            _US_MR   = (0 <<  4) |             /* USCLKS: Clock Selection: 0 = MCK */
    442                       (3 <<  6) |             /* CHRL: Character Length: 3 = Eight bits */
    443                       (0 <<  8) |             /* SYNC: Synchronous Mode Select: 0 = USART operates in Asynchronous Mode. */
    444                     (0x4 <<  9) |             /* PAR: Parity Type: 0x4 = No parity */
    445                       (0 << 12) |             /* NBSTOP: Number of Stop Bits: 0 = 1 stop bit */
    446                       (0 << 14) |             /* CHMODE: Channel Mode: 0 = Normal mode */
    447                       (0 << 17) |             /* MODE9: 9-bit Character Length: 0 = CHRL defines character length. */
    448                       (0 << 18)               /* CKLO: Clock Output Select: 0 = The USART does not drive the SCK pin. */
    449                     ;
   \   0000004C   8C1EA0E3           MOV      R1,#+2240
   \   00000050   041080E5           STR      R1,[R0, #+4]
    450            _US_BRGR = (APP_PCLK_UART / (APP_BAUDRATE * 16));
   \   00000054   1B10A0E3           MOV      R1,#+27
   \   00000058   201080E5           STR      R1,[R0, #+32]
    451            _US_IDR  = 0xFFFFFFFF;             /* Disable all interrupts     */
   \   0000005C   0010E0E3           MVN      R1,#+0
   \   00000060   0C1080E5           STR      R1,[R0, #+12]
    452            _US_IER  = US_RXRDY;               /* Enable Rx Interrupt , Do not Enable Tx Interrupt */
   \   00000064   0110A0E3           MOV      R1,#+1
   \   00000068   081080E5           STR      R1,[R0, #+8]
    453          
    454            /* create memory buffers for isr */
    455            App_Comm_Setup();
   \   0000006C   ........           BL       App_Comm_Setup
    456          
    457            /* Setup interrupt controller for App USART */
    458            OS_ARM_InstallISRHandler(APP_UART_ID, &App_ISR_Usart);  /* App UART interrupt handler vector */
   \   00000070   ........           LDR      R1,??DataTable2_5
   \   00000074   0600A0E3           MOV      R0,#+6
   \   00000078   ........           BL       OS_ARM_InstallISRHandler
    459            OS_ARM_ISRSetPrio(APP_UART_ID, APP_UART_PRIO);              /* Level sensitive, selected priority. */
   \   0000007C   0310A0E3           MOV      R1,#+3
   \   00000080   0600A0E3           MOV      R0,#+6
   \   00000084   ........           BL       OS_ARM_ISRSetPrio
    460            _AIC_ICCR = (1 << APP_UART_ID);                            /* Clear App usart interrupt.        */
   \   00000088   D700E0E3           MVN      R0,#+215
   \   0000008C   E00EC0E3           BIC      R0,R0,#0xE00
   \   00000090   004080E5           STR      R4,[R0, #+0]
    461            OS_ARM_EnableISR(APP_UART_ID);                             /* Enable App usart interrupts       */
   \   00000094   1040BDE8           POP      {R4,LR}
   \   00000098   0600A0E3           MOV      R0,#+6
   \   0000009C   ........           B        OS_ARM_EnableISR  ;; tailcall
    462          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0800FBFF           DC32     0xfffb0008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   ........           DC32     ??msg_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   ........           DC32     com

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   ........           DC32     msgrxbuff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   ........           DC32     commTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   ........           DC32     App_ISR_Usart
    463          /*****  EOF  ********************************************************/
    464          

   Maximum stack usage in bytes:

     Function      .cstack
     --------      -------
     App_COM_Init       8
     App_ISR_Usart     16
     XmitUART          16


   Section sizes:

     Function/Label Bytes
     -------------- -----
     XmitUART         80
     App_ISR_Usart   540
     msg_state        17
     msg_length
     index
     msgbuff
     chk
     App_COM_Init    160
     ??DataTable2      4
     ??DataTable2_1    4
     ??DataTable2_2    4
     ??DataTable2_3    4
     ??DataTable2_4    4
     ??DataTable2_5    4

 
  17 bytes in section .data
 804 bytes in section .text
 
 804 bytes of CODE memory
  17 bytes of DATA memory

Errors: none
Warnings: none
