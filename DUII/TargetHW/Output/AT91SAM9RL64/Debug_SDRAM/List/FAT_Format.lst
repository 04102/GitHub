###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     14/Jul/2015  18:59:14 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\FS\FAT_Format.c                         #
#    Command line =  C:\DUII\TargetHW\FS\FAT_Format.c -D DEBUG=1 -D           #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D                   #
#                    XIGNORE_TEMPERATURE -D BUILD_DEBUG_PORT -D PROFILER      #
#                    -lCN C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Li #
#                    st\ -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\ #
#                    Obj\ --debug --endian=little --cpu=ARM926EJ-S -e         #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\FA #
#                    T_Format.lst                                             #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\FAT #
#                    _Format.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\FS\FAT_Format.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          **** emFile file system for embedded applications ****
     13          emFile is protected by international copyright laws. Knowledge of the
     14          source code may not be used to write a similar product. This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : FAT_Format.c
     19          Purpose     : Implementation format routines
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          /*********************************************************************
     24          *
     25          *             #include Section
     26          *
     27          **********************************************************************
     28          */
     29          
     30          #include "FAT.h"
     31          #include "FAT_Intern.h"
     32          
     33          /*********************************************************************
     34          *
     35          *       #define constants
     36          *
     37          **********************************************************************
     38          */
     39          #define FAT_SIGNATURE   0xAA55
     40          
     41          #define PART_OFF_PARTITION0         0x01BE     /* Offset of start of partition table   */
     42          #define PARTENTRY_OFF_TYPE          0x04
     43          
     44          #define PART_TYPE_FAT12             0x01
     45          #define PART_TYPE_FAT16             0x04
     46          #define PART_TYPE_FAT16_HUGE        0x06
     47          #define PART_TYPE_FAT32             0x0B
     48          
     49          #define NUM_DEFAULT_DIR_ENTRIES     0x100
     50          
     51          /*********************************************************************
     52          *
     53          *       Local data types
     54          *
     55          **********************************************************************
     56          */
     57          typedef struct {
     58            I32  MediaID;
     59            U32  NumSectors;
     60            U16  SectorsPerTrack;
     61            U16  NumHeads;
     62            U8   Media; 
     63          } FORMAT_MEDIA_TYPE;
     64          
     65          
     66          typedef struct {
     67            U32 SecNum;
     68            U8  SectorsPerCluster;
     69            U16 NumRootDirEntries;
     70          } FORMAT_INFO;
     71          
     72          typedef struct {
     73            U8  FATType;
     74            U32 MinClusters;
     75          } FAT_TYPE_INFO;
     76          
     77          /*********************************************************************
     78          *
     79          *       Static const
     80          *
     81          **********************************************************************
     82          */
     83          

   \                                 In section .text, align 4, keep-with-next
     84          static const FAT_TYPE_INFO _aFATTypeInfo[] = {
   \                     _aFATTypeInfo:
   \   00000000                      ; Initializer data, 24 bytes
   \   00000000   0C000000           DC8 12, 0, 0, 0
   \   00000004   00000000           DC32 0
   \   00000008   10000000           DC8 16, 0, 0, 0
   \   0000000C   F50F0000           DC32 4085
   \   00000010   20000000           DC8 32, 0, 0, 0
   \   00000014   F5FF0000           DC32 65525
     85              {  FS_FAT_TYPE_FAT12, 0x00000000},
     86              {  FS_FAT_TYPE_FAT16, 0x00000FF5}
     87          #if (FS_FAT_SUPPORT_FAT32)
     88              ,{ FS_FAT_TYPE_FAT32, 0x0000FFF5 }
     89          #endif
     90            };
     91          
     92          /*********************************************************************
     93          *
     94          *       Static data
     95          *
     96          **********************************************************************
     97          */
     98          
     99          /* Default volume label. Format will use this string as default label */

   \                                 In section .text, align 4, keep-with-next
    100          const char _acVolumeLabel[] = "NO NAME    "; /* 11 characters */
   \                     _acVolumeLabel:
   \   00000000                      ; Initializer data, 12 bytes
   \   00000000   4E4F204E414D       DC8 78, 79, 32, 78, 65, 77, 69, 32, 32, 32
   \              45202020    
   \   0000000A   2000               DC8 32, 0
    101          
    102          /*********************************************************************
    103          *
    104          *       _aFormatInfo
    105          *
    106          * Purpose
    107          *   Table with format info
    108          *
    109          * Notes
    110          *   (1) Why this table ?
    111          *       It is not necessary to put information on how to format media of
    112          *       a certain size into a table, but it sure is a lot easier and
    113          *       also a lot more compact in terms of code size than to put this
    114          *       into the source code and also proves to be the most flexible
    115          *       method
    116          *   (2) How is the table searched ?
    117          *       Simple ... The first entry, number of sectors is compared.
    118          *       The first entry with less more or equal sectors as available
    119          *       on the medium (partition) is used
    120          *   (3) Does this table work the same way on any medium ?
    121          *       Yes. It is used by all format code for any medium.
    122          */

   \                                 In section .text, align 4, keep-with-next
    123          static const FORMAT_INFO _aFormatInfo[] = {
   \                     _aFormatInfo:
   \   00000000                      ; Initializer data, 104 bytes
   \   00000000   00010000           DC32 256
   \   00000004   0100               DC8 1, 0
   \   00000006   2000               DC16 32
   \   00000008   00020000           DC32 512
   \   0000000C   0100               DC8 1, 0
   \   0000000E   4000               DC16 64
   \   00000010   00080000           DC32 2048
   \   00000014   0100               DC8 1, 0
   \   00000016   8000               DC16 128
   \   00000018   00100000           DC32 4096
   \   0000001C   0100               DC8 1, 0
   \   0000001E   0001               DC16 256
   \   00000020   00400000           DC32 16384
   \   00000024   0200               DC8 2, 0
   \   00000026   0001               DC16 256
   \   00000028   00800000           DC32 32768
   \   0000002C   0200               DC8 2, 0
   \   0000002E   0001               DC16 256
   \   00000030   00000400           DC32 262144
   \   00000034   0400               DC8 4, 0
   \   00000036   0002               DC16 512
   \   00000038   00000800           DC32 524288
   \   0000003C   0800               DC8 8, 0
   \   0000003E   0002               DC16 512
   \   00000040   00001000           DC32 1048576
   \   00000044   1000               DC8 16, 0
   \   00000046   0002               DC16 512
   \   00000048   00000001           DC32 16777216
   \   0000004C   0800               DC8 8, 0
   \   0000004E   0000               DC16 0
   \   00000050   00000002           DC32 33554432
   \   00000054   1000               DC8 16, 0
   \   00000056   0000               DC16 0
   \   00000058   00000004           DC32 67108864
   \   0000005C   2000               DC8 32, 0
   \   0000005E   0000               DC16 0
   \   00000060   FFFFFFFF           DC32 4294967295
   \   00000064   4000               DC8 64, 0
   \   00000066   0000               DC16 0
    124          /*    NumSectors, SectorsPerCluster, NumRootDirEntries */
    125            {        256UL, 0x0001,            0x0020},    /* <= 128kB */
    126            {        512UL, 0x0001,            0x0040},    /* <= 256kB */
    127            {   0x000800UL, 0x0001,            0x0080},    /* <= 1  MB */
    128            {   0x001000UL, 0x0001,            0x0100},    /* <= 2  MB */
    129            {   0x004000UL, 0x0002,            0x0100},    /* <=  16 MB */
    130            {   0x008000UL, 0x0002,            0x0100},    /* <=  32 MB */
    131            {   0x040000UL, 0x0004,            0x0200},    /* <= 128 MB */
    132            {   0x080000UL, 0x0008,            0x0200},    /* <= 256 MB */
    133            {   0x100000UL, 0x0010,            0x0200},    /* <= 512 MB */
    134          #if (FS_FAT_SUPPORT_FAT32)
    135            /* media bigger than 512MB are formatted with FAT32 */
    136            {  0x1000000UL, 0x0008,            0 },   /* <=  8GB */
    137            {   33554432UL, 0x0010,            0 },   /* <= 16GB */
    138            {   67108864UL, 0x0020,            0 },   /* <= 32GB */
    139            { 0xFFFFFFFFUL, 0x0040,            0 }
    140          #else
    141            {   0x1FFEA0UL, 0x0020,            0x0200},   /* <= 1GB */
    142            {   0x3FFD40UL, 0x0040,            0x0200},   /* <= 2GB */
    143          /*  {   0x7FFA80, 0x0080,            0x0200},   <= 4GB */
    144            {   0xFFF500UL, 0x0080,            0x0200},   /* <= 8GB */
    145          #endif
    146          };
    147          
    148          /*********************************************************************
    149          *
    150          *       Static code
    151          *
    152          **********************************************************************
    153          */
    154          
    155          /*********************************************************************
    156          *
    157          *       _UpdatePartTable
    158          *
    159          *  Function description
    160          *    Updates the partition table. This is necessary because different FAT types
    161          *    have different Ids in the partition table.
    162          *    In other words: If a medium was FAT32 and is now formatted as FAT16 (or the other way round),
    163          *    the partion type in the partition table needs to be changed.
    164          */
    165          static void _UpdatePartTable(FS_VOLUME * pVolume, U32 NumSectors, U8 FATType, U8 * pBuffer) {
    166            int   Off;
    167            U8 CurrentPartType;
    168            U8 PartType;
    169          
    170            PartType = PART_TYPE_FAT32;
    171            if (FS_LB_ReadDevice(&pVolume->Partition.Device, 0, pBuffer, FS_SECTOR_TYPE_DATA)) {
    172              FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_UpdatePartTable: Could not read sector 0 to update partition 0.\n"));
    173              return;
    174            }
    175            Off  = PART_OFF_PARTITION0 + PARTENTRY_OFF_TYPE;
    176            CurrentPartType = *(pBuffer + Off);
    177            /* */
    178            switch (FATType) {
    179            case FS_FAT_TYPE_FAT12:
    180              PartType = PART_TYPE_FAT12;
    181              break;
    182            case FS_FAT_TYPE_FAT16:
    183              if (NumSectors < 65536UL) {
    184                PartType = PART_TYPE_FAT16;
    185              } else {
    186                PartType = PART_TYPE_FAT16_HUGE;
    187              }
    188              break;
    189          #if FS_DEBUG_LEVEL >= FS_DEBUG_LEVEL_CHECK_ALL
    190            case FS_FAT_TYPE_FAT32:
    191              break;
    192            default:
    193              FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_UpdatePartTable: Unknown FAT Type.\n"));
    194              return;
    195          #endif
    196            }
    197            if (CurrentPartType != PartType) {
    198              *(pBuffer + Off) = PartType;
    199              if (FS_LB_WriteDevice(&pVolume->Partition.Device, 0, pBuffer, FS_SECTOR_TYPE_DATA)) {
    200                FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_UpdatePartTable: Could not write sector 0 to update partition 0.\n"));
    201              }
    202            }
    203          }
    204          
    205          
    206          
    207          /*********************************************************************
    208          *
    209          *       _FatFormatEx
    210          *
    211          *  Description:
    212          *    Format a media using specified parameters.
    213          *
    214          *  Return value:
    215          *    >=0         - Media has been formatted.
    216          *    <0          - An error has occurred.
    217          */

   \                                 In section .text, align 4, keep-with-next
    218          static int _FatFormatEx(FS_VOLUME * pVolume,
    219                                  U32 NumSectors,
    220                                  U8  Media,
    221                                  U16 SecPerTrk,
    222                                  U16 NumHeads,
    223                                  U8  SectorsPerCluster,
    224                                  U16 NumRootDirEntriesProp,   /* Proposed, actual value depends on FATType */
    225                                  U16 BytesPerSector,
    226                                  U16 NumReservedSectors,
    227                                  U8  UpdatePartition)
    228          {
   \                     _FatFormatEx:
   \   00000000   FE4F2DE9           PUSH     {R1-R11,LR}
   \   00000004   18D04DE2           SUB      SP,SP,#+24
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   B005DDE1           LDRH     R0,[SP, #+80]
    229            int                  i;
    230            int                  j;
    231            int                  n;
    232            I32               NumClusters;
    233            U32               FATSize;
    234            U8                FATType;
    235            U32               RootDirSectors;
    236            I32               NumDataSectors;
    237            U16               NumRootDirEntries;
    238            U16               NumReservedSectorsTemp;
    239            FS_PARTITION       * pPart;
    240            FS_DEVICE          * pDevice;  
    241            U8              * pBuffer;
    242          
    243            pPart              = &pVolume->Partition;
    244            pDevice            = &pPart->Device;
    245            FATType            = 0;
    246            NumRootDirEntries  = 0;
    247            FATSize            = 0;
    248          #if FS_DEBUG_LEVEL >= FS_DEBUG_LEVEL_CHECK_PARA
    249            NumRootDirEntriesProp &= 0xFFF0;   /* Make sure it is a multiple of 16 */
   \   00000010   F010A0E3           MOV      R1,#+240
   \   00000014   FF1C81E3           ORR      R1,R1,#0xFF00
   \   00000018   000001E0           AND      R0,R1,R0
   \   0000001C   B600CDE1           STRH     R0,[SP, #+6]
   \   00000020   B445DDE1           LDRH     R4,[SP, #+84]
    250          #endif
    251            /*
    252             * Is device ready ?
    253             */
    254            i = FS_LB_GetStatus(pDevice);
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           BL       FS_LB_GetStatus
   \   0000002C   0070B0E1           MOVS     R7,R0
    255            if (i < 0) {
   \   00000030   6401004A           BMI      ??_FatFormatEx_0
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   5D00C5E5           STRB     R0,[R5, #+93]
    256              return i;
    257            }
    258            /*
    259             * Unmount the volume. Note that all handles should have been closed !
    260             */
    261            pVolume->IsMounted = 0;
    262            pBuffer = FS__AllocSectorBuffer();
   \   0000003C   ........           BL       FS__AllocSectorBuffer
   \   00000040   0060B0E1           MOVS     R6,R0
    263            if (pBuffer == 0) {
   \   00000044   0100001A           BNE      ??_FatFormatEx_1
    264              return -1;
   \                     ??_FatFormatEx_2:
   \   00000048   0000E0E3           MVN      R0,#+0
   \   0000004C   5D0100EA           B        ??_FatFormatEx_0
    265            }
    266            /*
    267             * Check if the a sector fits into the sector buffer
    268             */
    269            if ((BytesPerSector > FS_Global.MaxSectorSize) || (BytesPerSector == 0)) {
   \                     ??_FatFormatEx_1:
   \   00000050   ........           LDR      R0,??DataTable7
   \   00000054   B001D0E1           LDRH     R0,[R0, #+16]
   \   00000058   040050E1           CMP      R0,R4
   \   0000005C   F9FFFF3A           BCC      ??_FatFormatEx_2
   \   00000060   000054E3           CMP      R4,#+0
   \   00000064   F7FFFF0A           BEQ      ??_FatFormatEx_2
    270              FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_FatFormatEx: Invalid BytesPerSector value: %d\n.", BytesPerSector));
    271              return -1;
    272            }
    273            NumReservedSectorsTemp = NumReservedSectors;
    274            //
    275            // Set NumHeads and SectorPerTrack to default value, if necessary
    276            //
    277            if (NumHeads == 0) {
   \   00000068   B804DDE1           LDRH     R0,[SP, #+72]
   \   0000006C   B885DDE1           LDRH     R8,[SP, #+88]
    278              NumHeads = 0xFF;
    279            }
    280            if (SecPerTrk == 0) {
    281              SecPerTrk = 0x3F;
    282            }
    283            /*
    284             * Calculate the number of data sectors, number of clusters.
    285             * We calculate preliminary values first (Values may be slightly too big),
    286             * Use these to calc FATSize and then compute the correct values in a second step.
    287             */
    288          
    289            for (i = COUNTOF(_aFATTypeInfo) - 1; i >= 0; i--) {
   \   00000070   0270A0E3           MOV      R7,#+2
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   B002DDE1           LDRH     R0,[SP, #+32]
   \   0000007C   FF10A003           MOVEQ    R1,#+255
   \   00000080   B814CD01           STRHEQ   R1,[SP, #+72]
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   3F10A003           MOVEQ    R1,#+63
   \   0000008C   B012CD01           STRHEQ   R1,[SP, #+32]
   \   00000090   ............       ADRL     R1,_aFATTypeInfo+0x10
   \              ....        
   \   00000098   8401A0E1           LSL      R0,R4,#+3
   \   0000009C   00108DE5           STR      R1,[SP, #+0]
   \   000000A0   4C10DDE5           LDRB     R1,[SP, #+76]
   \   000000A4   0C008DE5           STR      R0,[SP, #+12]
   \   000000A8   08108DE5           STR      R1,[SP, #+8]
    290              I32 MinClusters;
    291          
    292              MinClusters        = _aFATTypeInfo[i].MinClusters;
   \                     ??_FatFormatEx_3:
   \   000000AC   00009DE5           LDR      R0,[SP, #+0]
   \   000000B0   040090E5           LDR      R0,[R0, #+4]
   \   000000B4   10008DE5           STR      R0,[SP, #+16]
    293              FATType            = _aFATTypeInfo[i].FATType;
   \   000000B8   00009DE5           LDR      R0,[SP, #+0]
   \   000000BC   0090D0E5           LDRB     R9,[R0, #+0]
    294              if ((NumReservedSectorsTemp != NumReservedSectors) || (NumReservedSectorsTemp == 0)) {
   \   000000C0   B805DDE1           LDRH     R0,[SP, #+88]
   \   000000C4   000058E1           CMP      R8,R0
   \   000000C8   0100001A           BNE      ??_FatFormatEx_4
   \   000000CC   000058E3           CMP      R8,#+0
   \   000000D0   2300001A           BNE      ??_FatFormatEx_5
    295                NumReservedSectorsTemp = (FATType == FS_FAT_TYPE_FAT32) ? 32 : 1;
   \                     ??_FatFormatEx_4:
   \   000000D4   200059E3           CMP      R9,#+32
   \   000000D8   2080A003           MOVEQ    R8,#+32
   \   000000DC   2200000A           BEQ      ??_FatFormatEx_6
   \   000000E0   0180A0E3           MOV      R8,#+1
   \                     ??_FatFormatEx_7:
   \   000000E4   B610DDE1           LDRH     R1,[SP, #+6]
    296              }
    297              NumRootDirEntries  = (FATType == FS_FAT_TYPE_FAT32) ?  0 : NumRootDirEntriesProp;
    298              RootDirSectors  = FS__DivideU32Up(NumRootDirEntries * 32, BytesPerSector);
    299              NumDataSectors  = (NumSectors - NumReservedSectorsTemp - RootDirSectors);
   \                     ??_FatFormatEx_8:
   \   000000E8   18009DE5           LDR      R0,[SP, #+24]
   \   000000EC   B410CDE1           STRH     R1,[SP, #+4]
   \   000000F0   08A040E0           SUB      R10,R0,R8
   \   000000F4   B400DDE1           LDRH     R0,[SP, #+4]
   \   000000F8   0410A0E1           MOV      R1,R4
   \   000000FC   8002A0E1           LSL      R0,R0,#+5
   \   00000100   ........           BL       FS__DivideU32Up
   \   00000104   00A04AE0           SUB      R10,R10,R0
    300              NumClusters     = NumDataSectors / SectorsPerCluster;
    301              FATSize         = FS__DivideU32Up(NumClusters * FATType, 8 * BytesPerSector /* Bits per sector */);
    302              NumDataSectors -= 2 * FATSize;                                           /* Compute precise number of avail. sectors */
    303              NumClusters     = NumDataSectors / SectorsPerCluster;                    /* Compute precise number of avail. clusters */    
   \   00000108   0A00A0E1           MOV      R0,R10
   \   0000010C   08109DE5           LDR      R1,[SP, #+8]
   \   00000110   ........           BL       __aeabi_idiv
   \   00000114   0CB09DE5           LDR      R11,[SP, #+12]
   \   00000118   990000E0           MUL      R0,R9,R0
   \   0000011C   0B10A0E1           MOV      R1,R11
   \   00000120   ........           BL       FS__DivideU32Up
   \   00000124   80004AE0           SUB      R0,R10,R0, LSL #+1
   \   00000128   08109DE5           LDR      R1,[SP, #+8]
   \   0000012C   ........           BL       __aeabi_idiv
   \   00000130   00A0A0E1           MOV      R10,R0
    304              FATSize         = FS__DivideU32Up(NumClusters * FATType, 8 * BytesPerSector /* Bits per sector */);
   \   00000134   990A00E0           MUL      R0,R9,R10
   \   00000138   0C109DE5           LDR      R1,[SP, #+12]
   \   0000013C   ........           BL       FS__DivideU32Up
   \   00000140   00B0A0E1           MOV      R11,R0
    305              /* Now check if the max. number of clusters is exceeded ... */
    306              if (i == 0) {
   \   00000144   000057E3           CMP      R7,#+0
   \   00000148   0900001A           BNE      ??_FatFormatEx_9
    307                if (NumClusters <= 4084) {
   \   0000014C   F500A0E3           MOV      R0,#+245
   \   00000150   F00E80E3           ORR      R0,R0,#0xF00
   \   00000154   00005AE1           CMP      R10,R0
    308                  break;
    309                }
    310                NumClusters = 4084;
   \   00000158   01A0C0A3           BICGE    R10,R0,#0x1
   \   0000015C   070000AA           BGE      ??_FatFormatEx_10
   \   00000160   0C0000EA           B        ??_FatFormatEx_11
    311              } else {
   \                     ??_FatFormatEx_5:
   \   00000164   200059E3           CMP      R9,#+32
   \   00000168   DDFFFF1A           BNE      ??_FatFormatEx_7
   \                     ??_FatFormatEx_6:
   \   0000016C   0010A0E3           MOV      R1,#+0
   \   00000170   DCFFFFEA           B        ??_FatFormatEx_8
    312                if (NumClusters >= MinClusters) {
   \                     ??_FatFormatEx_9:
   \   00000174   10009DE5           LDR      R0,[SP, #+16]
   \   00000178   00005AE1           CMP      R10,R0
   \   0000017C   050000AA           BGE      ??_FatFormatEx_11
    313                  break;                                                     /* O.K., this FATType can be used */
    314                }
    315              }
    316            }
   \                     ??_FatFormatEx_10:
   \   00000180   00009DE5           LDR      R0,[SP, #+0]
   \   00000184   017047E2           SUB      R7,R7,#+1
   \   00000188   080040E2           SUB      R0,R0,#+8
   \   0000018C   00008DE5           STR      R0,[SP, #+0]
   \   00000190   000057E3           CMP      R7,#+0
   \   00000194   C4FFFF5A           BPL      ??_FatFormatEx_3
    317            NumReservedSectors = NumReservedSectorsTemp;
   \                     ??_FatFormatEx_11:
   \   00000198   B885CDE1           STRH     R8,[SP, #+88]
    318            /*
    319             * Now that the type of FAT has been determined, we can perform add. checks.
    320             */
    321            if (NumRootDirEntriesProp == 0) {
    322              if (FATType != FS_FAT_TYPE_FAT32) {
    323                FS_DEBUG_WARN((FS_MTYPE_FS, "_FatFormatEx: NumRootDirEntries (%d) is illegal. Defaulting to %d.\n", NumRootDirEntriesProp, NUM_DEFAULT_DIR_ENTRIES));
    324                NumRootDirEntriesProp = NUM_DEFAULT_DIR_ENTRIES;
    325              }
    326            }
    327            /* 
    328             *  Prepare buffer. Offset 0 - 35 is same for FAT12/FAT16 and FAT32 
    329             */
    330            /* MS specified most frequently used format: 0xEB 0x3C 0x90 */
    331            FS_MEMSET(pBuffer, 0x00, BytesPerSector);
   \   0000019C   0410A0E1           MOV      R1,R4
   \   000001A0   0600A0E1           MOV      R0,R6
   \   000001A4   ........           BL       __aeabi_memclr
    332            pBuffer[0]   = 0xE9; /* jmpBoot */
   \   000001A8   E900A0E3           MOV      R0,#+233
   \   000001AC   0000C6E5           STRB     R0,[R6, #+0]
    333            FS_STRNCPY((char*)&pBuffer[3], "MSWIN4.1", 8);                /* OEMName = 'MSWIN4.1' */
   \   000001B0   0820A0E3           MOV      R2,#+8
   \   000001B4   ............       ADRL     R1,`?<Constant "MSWIN4.1">`
   \              ....        
   \   000001BC   030086E2           ADD      R0,R6,#+3
   \   000001C0   ........           BL       strncpy
    334            FS_StoreU16LE(&pBuffer[11], BytesPerSector);                   /* Sector size     */
   \   000001C4   0410A0E1           MOV      R1,R4
   \   000001C8   0B0086E2           ADD      R0,R6,#+11
   \   000001CC   ........           BL       FS_StoreU16LE
    335            pBuffer[13]  = SectorsPerCluster;                             /* Sectors in each allocation unit */
   \   000001D0   4C00DDE5           LDRB     R0,[SP, #+76]
   \   000001D4   0D00C6E5           STRB     R0,[R6, #+13]
    336            FS_StoreU16LE(&pBuffer[14], NumReservedSectors);
   \   000001D8   B875DDE1           LDRH     R7,[SP, #+88]
   \   000001DC   0E0086E2           ADD      R0,R6,#+14
   \   000001E0   0710A0E1           MOV      R1,R7
   \   000001E4   ........           BL       FS_StoreU16LE
    337            pBuffer[16]  = 2;                                             /* NumFATs */
   \   000001E8   0200A0E3           MOV      R0,#+2
   \   000001EC   1000C6E5           STRB     R0,[R6, #+16]
   \   000001F0   B410DDE1           LDRH     R1,[SP, #+4]
   \   000001F4   110086E2           ADD      R0,R6,#+17
    338            FS_StoreU16LE(&pBuffer[17], NumRootDirEntries);
   \   000001F8   ........           BL       FS_StoreU16LE
    339          
    340            /* Number of total sectors (512 byte units) of the media
    341             * This is independent of FAT type (FAT12/FAT16/FAT32)
    342             */
    343            if (NumSectors < 0x10000UL) {
   \   000001FC   18009DE5           LDR      R0,[SP, #+24]
   \   00000200   400B50E3           CMP      R0,#+65536
   \   00000204   0010A0E1           MOV      R1,R0
   \   00000208   0400002A           BCS      ??_FatFormatEx_12
    344              FS_StoreU16LE(&pBuffer[19], (U16)NumSectors);              /* Total Sectors16 */
   \   0000020C   0118A0E1           LSL      R1,R1,#+16
   \   00000210   2118A0E1           LSR      R1,R1,#+16
   \   00000214   130086E2           ADD      R0,R6,#+19
   \   00000218   ........           BL       FS_StoreU16LE
   \   0000021C   010000EA           B        ??_FatFormatEx_13
    345            } else {
    346              FS_StoreU32LE(&pBuffer[32], NumSectors);                      /* Total Sectors32 */
   \                     ??_FatFormatEx_12:
   \   00000220   200086E2           ADD      R0,R6,#+32
   \   00000224   ........           BL       FS_StoreU32LE
    347            }
    348            pBuffer[21]  = Media;                                          /* Media */
   \                     ??_FatFormatEx_13:
   \   00000228   1C00DDE5           LDRB     R0,[SP, #+28]
   \   0000022C   1500C6E5           STRB     R0,[R6, #+21]
    349            FS_StoreU16LE(&pBuffer[24], SecPerTrk);                         /* Sectors per Track */
   \   00000230   B012DDE1           LDRH     R1,[SP, #+32]
   \   00000234   180086E2           ADD      R0,R6,#+24
   \   00000238   ........           BL       FS_StoreU16LE
    350            FS_StoreU16LE(&pBuffer[26], NumHeads);                          /* Number of Heads */
   \   0000023C   B814DDE1           LDRH     R1,[SP, #+72]
   \   00000240   1A0086E2           ADD      R0,R6,#+26
   \   00000244   ........           BL       FS_StoreU16LE
    351            FS_StoreU32LE(&pBuffer[28], pVolume->Partition.StartSector);    /* Hidden Sectors */
   \   00000248   141095E5           LDR      R1,[R5, #+20]
   \   0000024C   1C0086E2           ADD      R0,R6,#+28
   \   00000250   ........           BL       FS_StoreU32LE
   \   00000254   ........           LDR      R8,??DataTable7_1  ;; 0x1234567
   \   00000258   2900A0E3           MOV      R0,#+41
   \   0000025C   8010A0E3           MOV      R1,#+128
   \   00000260   200059E3           CMP      R9,#+32
   \   00000264   1500000A           BEQ      ??_FatFormatEx_14
    352            /* Offset 36 and above have different meanings for FAT12/FAT16 and FAT32 */
    353            if (FATType != FS_FAT_TYPE_FAT32) {
    354              pBuffer[36]  = 0x80;                                         /* Physical drive number */
   \   00000268   2410C6E5           STRB     R1,[R6, #+36]
    355              pBuffer[38]  = 0x29;                                         /* Extended Boot Signature */
   \   0000026C   2600C6E5           STRB     R0,[R6, #+38]
    356              FS_StoreU32LE(&pBuffer[39], 0x01234567UL);                      /* 32 Bit Volume ID */
   \   00000270   0810A0E1           MOV      R1,R8
   \   00000274   270086E2           ADD      R0,R6,#+39
   \   00000278   ........           BL       FS_StoreU32LE
    357              FS_StoreU16LE(&pBuffer[22], (U16)FATSize);                 /* FATSz16 */
   \   0000027C   0B18A0E1           LSL      R1,R11,#+16
   \   00000280   2118A0E1           LSR      R1,R1,#+16
   \   00000284   160086E2           ADD      R0,R6,#+22
   \   00000288   ........           BL       FS_StoreU16LE
    358              FS_STRNCPY((char*)&pBuffer[43], _acVolumeLabel, 11);         /* VolLab = ' ' */
   \   0000028C   0B20A0E3           MOV      R2,#+11
   \   00000290   ............       ADRL     R1,_acVolumeLabel
   \              ....        
   \   00000298   2B0086E2           ADD      R0,R6,#+43
   \   0000029C   ........           BL       strncpy
    359              FS_STRNCPY((char*)&pBuffer[54], (FATType == FS_FAT_TYPE_FAT12) ? "FAT12   " : "FAT16   ", 8);
   \   000002A0   0C0059E3           CMP      R9,#+12
   \   000002A4   ............       ADRLEQ   R1,`?<Constant "FAT12   ">`
   \              ....        
   \   000002AC   ............       ADRLNE   R1,`?<Constant "FAT16   ">`
   \              ....        
   \   000002B4   0820A0E3           MOV      R2,#+8
   \   000002B8   360086E2           ADD      R0,R6,#+54
   \   000002BC   180000EA           B        ??_FatFormatEx_15
    360            }
    361          #if (FS_FAT_SUPPORT_FAT32)
    362            else {
    363              /* FAT32 */
    364              pBuffer[64]  = 0x80;                                         /* Physical drive number */
   \                     ??_FatFormatEx_14:
   \   000002C0   4010C6E5           STRB     R1,[R6, #+64]
    365              pBuffer[66]  = 0x29;                                         /* Extended Boot Signature */
   \   000002C4   4200C6E5           STRB     R0,[R6, #+66]
    366              FS_StoreU32LE(&pBuffer[36], FATSize);                         /* FATSize32 */
   \   000002C8   0B10A0E1           MOV      R1,R11
   \   000002CC   240086E2           ADD      R0,R6,#+36
   \   000002D0   ........           BL       FS_StoreU32LE
    367              FS_StoreU32LE(&pBuffer[44], 2);                               /* RootClus */
   \   000002D4   0210A0E3           MOV      R1,#+2
   \   000002D8   2C0086E2           ADD      R0,R6,#+44
   \   000002DC   ........           BL       FS_StoreU32LE
    368              FS_StoreU16LE(&pBuffer[48], 1);                               /* FSInfo */
   \   000002E0   0110A0E3           MOV      R1,#+1
   \   000002E4   300086E2           ADD      R0,R6,#+48
   \   000002E8   ........           BL       FS_StoreU16LE
    369              pBuffer[50]  = 0x06;                                         /* BkBootSec = 0x0006; */
   \   000002EC   0600A0E3           MOV      R0,#+6
   \   000002F0   3200C6E5           STRB     R0,[R6, #+50]
    370              FS_StoreU32LE(&pBuffer[67], 0x01234567UL);                      /* 32 Bit Volume ID */
   \   000002F4   0810A0E1           MOV      R1,R8
   \   000002F8   430086E2           ADD      R0,R6,#+67
   \   000002FC   ........           BL       FS_StoreU32LE
    371              FS_STRNCPY((char*)&pBuffer[71], _acVolumeLabel, 11);         /* VolLab = ' ' */
   \   00000300   0B20A0E3           MOV      R2,#+11
   \   00000304   ............       ADRL     R1,_acVolumeLabel
   \              ....        
   \   0000030C   470086E2           ADD      R0,R6,#+71
   \   00000310   ........           BL       strncpy
    372              FS_STRNCPY((char*)&pBuffer[82], "FAT32   ", 8);              /* FilSysType = 'FAT32' */
   \   00000314   0820A0E3           MOV      R2,#+8
   \   00000318   ............       ADRL     R1,`?<Constant "FAT32   ">`
   \              ....        
   \   00000320   520086E2           ADD      R0,R6,#+82
   \                     ??_FatFormatEx_15:
   \   00000324   ........           BL       strncpy
    373            }
    374          #endif /* FS_FAT_SUPPORT_FAT32 */
    375            FS_StoreU16LE(&pBuffer[510], FAT_SIGNATURE);                    /* Signature = 0xAA55 */
   \   00000328   5580A0E3           MOV      R8,#+85
   \   0000032C   FE00A0E3           MOV      R0,#+254
   \   00000330   AA8C88E3           ORR      R8,R8,#0xAA00
   \   00000334   400F80E3           ORR      R0,R0,#0x100
   \   00000338   0810A0E1           MOV      R1,R8
   \   0000033C   060080E0           ADD      R0,R0,R6
   \   00000340   ........           BL       FS_StoreU16LE
    376            /* Write BPB to media */
    377            i = FS_LB_WritePart(pPart, 0, (void*)pBuffer, FS_SECTOR_TYPE_DATA);
    378            if (i < 0) {
   \   00000344   0030A0E3           MOV      R3,#+0
   \   00000348   0620A0E1           MOV      R2,R6
   \   0000034C   0010A0E3           MOV      R1,#+0
   \   00000350   0500A0E1           MOV      R0,R5
   \   00000354   ........           BL       FS_LB_WritePart
   \   00000358   000050E3           CMP      R0,#+0
   \   0000035C   0200005A           BPL      ??_FatFormatEx_16
    379              FS__FreeSectorBuffer(pBuffer);
   \                     ??_FatFormatEx_17:
   \   00000360   0600A0E1           MOV      R0,R6
   \   00000364   ........           BL       FS__FreeSectorBuffer
    380              return -1;
   \   00000368   36FFFFEA           B        ??_FatFormatEx_2
    381            }
    382            if (FATType == FS_FAT_TYPE_FAT32) {
   \                     ??_FatFormatEx_16:
   \   0000036C   200059E3           CMP      R9,#+32
   \   00000370   0600001A           BNE      ??_FatFormatEx_18
    383              /* Write backup BPB */
    384              i = FS_LB_WritePart(pPart, 6, (void*)pBuffer, FS_SECTOR_TYPE_DATA);
    385              if (i < 0) {
   \   00000374   0030A0E3           MOV      R3,#+0
   \   00000378   0620A0E1           MOV      R2,R6
   \   0000037C   0610A0E3           MOV      R1,#+6
   \   00000380   0500A0E1           MOV      R0,R5
   \   00000384   ........           BL       FS_LB_WritePart
   \   00000388   000050E3           CMP      R0,#+0
   \   0000038C   F3FFFF4A           BMI      ??_FatFormatEx_17
    386                FS__FreeSectorBuffer(pBuffer);
    387                return -1;
    388              }
    389            }
    390            /*
    391             *  Init FAT 1 & 2. Start by filling all FAT sectors except the first one with 0
    392             */
    393            FS_MEMSET(pBuffer, 0x00, BytesPerSector);
   \                     ??_FatFormatEx_18:
   \   00000390   0410A0E1           MOV      R1,R4
   \   00000394   0600A0E1           MOV      R0,R6
   \   00000398   ........           BL       __aeabi_memclr
   \   0000039C   0200A0E3           MOV      R0,#+2
   \   000003A0   00008DE5           STR      R0,[SP, #+0]
   \   000003A4   0630A0E1           MOV      R3,R6
   \   000003A8   8B20A0E1           LSL      R2,R11,#+1
   \   000003AC   0710A0E1           MOV      R1,R7
   \   000003B0   0500A0E1           MOV      R0,R5
    394          
    395            i = FS_LB_WriteMultiplePart(pPart, NumReservedSectors, 2 * FATSize, pBuffer, FS_SECTOR_TYPE_MAN);
    396            if (i < 0) {
   \   000003B4   ........           BL       FS_LB_WriteMultiplePart
   \   000003B8   000050E3           CMP      R0,#+0
   \   000003BC   E7FFFF4A           BMI      ??_FatFormatEx_17
    397              FS__FreeSectorBuffer(pBuffer);
    398              return -1;
    399            }
    400            /*
    401             * Init the first FAT sector
    402             */
    403            pBuffer[0] = (U8)Media;
   \   000003C0   1C00DDE5           LDRB     R0,[SP, #+28]
    404            pBuffer[1] = (U8)0xFF;
    405            pBuffer[2] = (U8)0xFF;
    406            if (FATType != FS_FAT_TYPE_FAT12) {
   \   000003C4   0C0059E3           CMP      R9,#+12
   \   000003C8   0000C6E5           STRB     R0,[R6, #+0]
   \   000003CC   FF00A0E3           MOV      R0,#+255
   \   000003D0   0100C6E5           STRB     R0,[R6, #+1]
   \   000003D4   0200C6E5           STRB     R0,[R6, #+2]
   \   000003D8   0800000A           BEQ      ??_FatFormatEx_19
    407              pBuffer[3] = (U8)0xFF;
   \   000003DC   0300C6E5           STRB     R0,[R6, #+3]
    408            }
    409          #if (FS_FAT_SUPPORT_FAT32)
    410            if (FATType == FS_FAT_TYPE_FAT32) {
   \   000003E0   200059E3           CMP      R9,#+32
   \   000003E4   0500001A           BNE      ??_FatFormatEx_19
    411              FS_StoreU32LE(&pBuffer[4],   0x0FFFFFFFUL);
   \   000003E8   F014E0E3           MVN      R1,#-268435456
   \   000003EC   040086E2           ADD      R0,R6,#+4
   \   000003F0   ........           BL       FS_StoreU32LE
    412              FS_StoreU32LE(&pBuffer[8],   0x0FFFFFFFUL);
   \   000003F4   F014E0E3           MVN      R1,#-268435456
   \   000003F8   080086E2           ADD      R0,R6,#+8
   \   000003FC   ........           BL       FS_StoreU32LE
    413            }
    414          #endif /* FS_FAT_SUPPORT_FAT32 */
    415            for (i = 0; i < 2; i++) {
    416              j = FS_LB_WritePart(pPart, (U32)NumReservedSectors + i * FATSize, (void*)pBuffer, FS_SECTOR_TYPE_MAN);
    417              if (j < 0) {
   \                     ??_FatFormatEx_19:
   \   00000400   0230A0E3           MOV      R3,#+2
   \   00000404   0620A0E1           MOV      R2,R6
   \   00000408   0710A0E1           MOV      R1,R7
   \   0000040C   0500A0E1           MOV      R0,R5
   \   00000410   ........           BL       FS_LB_WritePart
   \   00000414   000050E3           CMP      R0,#+0
   \   00000418   D0FFFF4A           BMI      ??_FatFormatEx_17
   \   0000041C   0230A0E3           MOV      R3,#+2
   \   00000420   0620A0E1           MOV      R2,R6
   \   00000424   07108BE0           ADD      R1,R11,R7
   \   00000428   0500A0E1           MOV      R0,R5
   \   0000042C   ........           BL       FS_LB_WritePart
   \   00000430   000050E3           CMP      R0,#+0
   \   00000434   C9FFFF4A           BMI      ??_FatFormatEx_17
    418                FS__FreeSectorBuffer(pBuffer);
    419                return -1;
    420              }
    421            }
    422            /* Init root directory area */
    423            FS_MEMSET(pBuffer, 0x00, BytesPerSector);
   \   00000438   0410A0E1           MOV      R1,R4
   \   0000043C   0600A0E1           MOV      R0,R6
   \   00000440   ........           BL       __aeabi_memclr
    424            if (NumRootDirEntries != 0) {
   \   00000444   B400DDE1           LDRH     R0,[SP, #+4]
   \   00000448   8B7087E0           ADD      R7,R7,R11, LSL #+1
   \   0000044C   000050E3           CMP      R0,#+0
   \   00000450   0100A0E3           MOV      R0,#+1
   \   00000454   00008DE5           STR      R0,[SP, #+0]
   \   00000458   0B00000A           BEQ      ??_FatFormatEx_20
    425              /* FAT12/FAT16 */
    426              n = (((U32)NumRootDirEntries * 32) / (U32)BytesPerSector);
    427              j = FS_LB_WriteMultiplePart(pPart, NumReservedSectors + 2 * FATSize, n, pBuffer, FS_SECTOR_TYPE_DIR);
    428              if (j < 0) {
   \   0000045C   B400DDE1           LDRH     R0,[SP, #+4]
   \   00000460   0410A0E1           MOV      R1,R4
   \   00000464   8002A0E1           LSL      R0,R0,#+5
   \   00000468   ........           BL       __aeabi_uidiv
   \   0000046C   0020A0E1           MOV      R2,R0
   \   00000470   0630A0E1           MOV      R3,R6
   \   00000474   0710A0E1           MOV      R1,R7
   \   00000478   0500A0E1           MOV      R0,R5
   \   0000047C   ........           BL       FS_LB_WriteMultiplePart
   \   00000480   000050E3           CMP      R0,#+0
   \   00000484   0700005A           BPL      ??_FatFormatEx_21
   \   00000488   B4FFFFEA           B        ??_FatFormatEx_17
    429                FS__FreeSectorBuffer(pBuffer);
    430                return -1;
    431              }
    432            }
    433          #if (FS_FAT_SUPPORT_FAT32)
    434            else {
    435              /* FAT32 */
    436              n = SectorsPerCluster;
    437              j = FS_LB_WriteMultiplePart(pPart, NumReservedSectors + 2 * FATSize, n, pBuffer, FS_SECTOR_TYPE_DIR);
    438              if (j < 0) {
   \                     ??_FatFormatEx_20:
   \   0000048C   0630A0E1           MOV      R3,R6
   \   00000490   4C20DDE5           LDRB     R2,[SP, #+76]
   \   00000494   0710A0E1           MOV      R1,R7
   \   00000498   0500A0E1           MOV      R0,R5
   \   0000049C   ........           BL       FS_LB_WriteMultiplePart
   \   000004A0   000050E3           CMP      R0,#+0
   \   000004A4   ADFFFF4A           BMI      ??_FatFormatEx_17
    439                FS__FreeSectorBuffer(pBuffer);
    440                return -1;
    441              }
    442            }
    443          #endif /* FS_FAT_SUPPORT_FAT32 */
    444          #if (FS_FAT_SUPPORT_FAT32)
    445            if (FATType == FS_FAT_TYPE_FAT32) {
   \                     ??_FatFormatEx_21:
   \   000004A8   200059E3           CMP      R9,#+32
   \   000004AC   2200001A           BNE      ??_FatFormatEx_22
    446              /* Init FSInfo */
    447              FS_MEMSET(pBuffer, 0x00, BytesPerSector);
   \   000004B0   0410A0E1           MOV      R1,R4
   \   000004B4   0600A0E1           MOV      R0,R6
   \   000004B8   ........           BL       __aeabi_memclr
    448              FS_StoreU32LE(&pBuffer[FSINFO_OFF_SIGNATURE_1],       0x41615252UL);       /* LeadSig = 0x41615252 */
   \   000004BC   ........           LDR      R1,??DataTable7_2  ;; 0x41615252
   \   000004C0   0600A0E1           MOV      R0,R6
   \   000004C4   ........           BL       FS_StoreU32LE
    449              FS_StoreU32LE(&pBuffer[FSINFO_OFF_SIGNATURE_2],       0x61417272UL);       /* StructSig = 0x61417272 */
   \   000004C8   ........           LDR      R1,??DataTable7_3  ;; 0x61417272
   \   000004CC   790F86E2           ADD      R0,R6,#+484
   \   000004D0   ........           BL       FS_StoreU32LE
    450              FS_StoreU32LE(&pBuffer[FSINFO_OFF_FREE_CLUSTERS],     NumClusters - 1);  /* Invalidate last known free cluster count */
   \   000004D4   01104AE2           SUB      R1,R10,#+1
   \   000004D8   7A0F86E2           ADD      R0,R6,#+488
   \   000004DC   ........           BL       FS_StoreU32LE
    451              FS_StoreU32LE(&pBuffer[FSINFO_OFF_NEXT_FREE_CLUSTER], 0x00000003UL);       /* Give hint for free cluster search */
   \   000004E0   0310A0E3           MOV      R1,#+3
   \   000004E4   7B0F86E2           ADD      R0,R6,#+492
   \   000004E8   ........           BL       FS_StoreU32LE
    452              FS_StoreU16LE(&pBuffer[510], FAT_SIGNATURE);                             /* Signature = 0xAA55 */
   \   000004EC   FE00A0E3           MOV      R0,#+254
   \   000004F0   400F80E3           ORR      R0,R0,#0x100
   \   000004F4   0810A0E1           MOV      R1,R8
   \   000004F8   060080E0           ADD      R0,R0,R6
   \   000004FC   ........           BL       FS_StoreU16LE
    453              i = FS_LB_WritePart(pPart, 1, (void*)pBuffer, FS_SECTOR_TYPE_DATA);
   \   00000500   0030A0E3           MOV      R3,#+0
   \   00000504   0620A0E1           MOV      R2,R6
   \   00000508   0110A0E3           MOV      R1,#+1
   \   0000050C   0500A0E1           MOV      R0,R5
   \   00000510   ........           BL       FS_LB_WritePart
   \   00000514   0070B0E1           MOVS     R7,R0
    454              if (i >= 0) {
   \   00000518   0500004A           BMI      ??_FatFormatEx_23
    455                /* Write Backup of FSInfo sector */
    456                i  = FS_LB_WritePart(pPart, 7, (void*)pBuffer, FS_SECTOR_TYPE_DATA);
   \   0000051C   0030A0E3           MOV      R3,#+0
   \   00000520   0620A0E1           MOV      R2,R6
   \   00000524   0710A0E3           MOV      R1,#+7
   \   00000528   0500A0E1           MOV      R0,R5
   \   0000052C   ........           BL       FS_LB_WritePart
   \   00000530   0070A0E1           MOV      R7,R0
    457              }
    458              if (i < 0) {
   \                     ??_FatFormatEx_23:
   \   00000534   000057E3           CMP      R7,#+0
   \   00000538   88FFFF4A           BMI      ??_FatFormatEx_17
    459                FS__FreeSectorBuffer(pBuffer);
    460                return -1;
    461              }
    462            }
    463          #endif /* FS_FAT_SUPPORT_FAT32 */
    464            // 
    465            // Update partition table if necessary 
    466            //
    467            if (pVolume->Partition.StartSector) {
   \                     ??_FatFormatEx_22:
   \   0000053C   140095E5           LDR      R0,[R5, #+20]
   \   00000540   000050E3           CMP      R0,#+0
    468              if (UpdatePartition) {
   \   00000544   5C00DD15           LDRBNE   R0,[SP, #+92]
   \   00000548   00005013           CMPNE    R0,#+0
   \   0000054C   1A00000A           BEQ      ??_FatFormatEx_24
    469                _UpdatePartTable(pVolume, NumSectors, FATType, pBuffer);
   \   00000550   0B40A0E3           MOV      R4,#+11
   \   00000554   0030A0E3           MOV      R3,#+0
   \   00000558   0620A0E1           MOV      R2,R6
   \   0000055C   0010A0E3           MOV      R1,#+0
   \   00000560   0500A0E1           MOV      R0,R5
   \   00000564   ........           BL       FS_LB_ReadDevice
   \   00000568   000050E3           CMP      R0,#+0
   \   0000056C   1200001A           BNE      ??_FatFormatEx_24
   \   00000570   C201D6E5           LDRB     R0,[R6, #+450]
   \   00000574   0C9059E2           SUBS     R9,R9,#+12
   \   00000578   0600000A           BEQ      ??_FatFormatEx_25
   \   0000057C   049059E2           SUBS     R9,R9,#+4
   \   00000580   0500001A           BNE      ??_FatFormatEx_26
   \   00000584   18109DE5           LDR      R1,[SP, #+24]
   \   00000588   400B51E3           CMP      R1,#+65536
   \   0000058C   0640A023           MOVCS    R4,#+6
   \   00000590   0440A033           MOVCC    R4,#+4
   \   00000594   000000EA           B        ??_FatFormatEx_26
   \                     ??_FatFormatEx_25:
   \   00000598   0140A0E3           MOV      R4,#+1
   \                     ??_FatFormatEx_26:
   \   0000059C   040050E1           CMP      R0,R4
   \   000005A0   0500000A           BEQ      ??_FatFormatEx_24
   \   000005A4   C241C6E5           STRB     R4,[R6, #+450]
   \   000005A8   0030A0E3           MOV      R3,#+0
   \   000005AC   0620A0E1           MOV      R2,R6
   \   000005B0   0010A0E3           MOV      R1,#+0
   \   000005B4   0500A0E1           MOV      R0,R5
   \   000005B8   ........           BL       FS_LB_WriteDevice
    470              }
    471            }
    472            FS__FreeSectorBuffer(pBuffer);
   \                     ??_FatFormatEx_24:
   \   000005BC   0600A0E1           MOV      R0,R6
   \   000005C0   ........           BL       FS__FreeSectorBuffer
    473            return 0;
   \   000005C4   0000A0E3           MOV      R0,#+0
   \                     ??_FatFormatEx_0:
   \   000005C8   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   000005CC   F08FBDE8           POP      {R4-R11,PC}      ;; return
    474          }
    475          
    476          /*********************************************************************
    477          *
    478          *       _FatFormat
    479          *
    480          *  Description:
    481          *    Format a media using specified parameters.
    482          *
    483          *  Return value:
    484          *    >=0         - Media has been formatted.
    485          *    <0          - An error has occurred.
    486          */
    487          static int _FatFormat(FS_VOLUME * pVolume, I32 NumSectors, U8 Media, U16 SecPerTrk, U16 NumHeads, U16 BytesPerSector) {
    488            int i;
    489            U8  SectorsPerCluster;
    490            U16 NumRootDirEntries;
    491            /*
    492             * Find properties to use in table
    493             */
    494            for (i = 0; (U32)NumSectors > _aFormatInfo[i].SecNum; i++);
    495            SectorsPerCluster  = _aFormatInfo[i].SectorsPerCluster;
    496            NumRootDirEntries  = _aFormatInfo[i].NumRootDirEntries;
    497            return _FatFormatEx(pVolume, NumSectors, Media, SecPerTrk, NumHeads, SectorsPerCluster, NumRootDirEntries, BytesPerSector, 0, 1);
    498          }
    499          
    500          /*********************************************************************
    501          *
    502          *       _AutoFormat
    503          *
    504          *  Description:
    505          *    FS internal function. Get information about the media from the 
    506          *    device driver. Based on that informaton, calculate parameters for
    507          *    formatting that media and call the format routine.
    508          *
    509          *  Parameters:
    510          *    Idx         - Index of device in the device information table referred by FS__pDevInfo.
    511          *    Unit        - Unit number.
    512          *  
    513          *  Return value:
    514          *    >=0         - Media has been formatted.
    515          *    <0          - An error has occurred.
    516          */
    517          static int _AutoFormat(FS_VOLUME * pVolume) {
    518            FS_DEV_INFO DevInfo;
    519            FS_MEMSET(&DevInfo, 0, sizeof(FS_DEV_INFO));
    520            /*
    521             * Check if there is a partition table
    522             */
    523            FS__LocatePartition(pVolume);
    524            FS_LB_GetDeviceInfo(&pVolume->Partition.Device, &DevInfo);   /* Get info from device */
    525            if (pVolume->Partition.StartSector) {
    526              DevInfo.NumSectors = pVolume->Partition.NumSectors;
    527            }
    528            /* Check if we have gotten the information */
    529            if (DevInfo.NumSectors == 0) {
    530              return -1;     /* Error, we could not get the required info or device is not ready */
    531            }
    532            
    533            /* Format media using calculated values */
    534            return _FatFormat(pVolume, DevInfo.NumSectors, 0xF8, DevInfo.SectorsPerTrack, DevInfo.NumHeads, DevInfo.BytesPerSector);
    535          }
    536          
    537          
    538          /*********************************************************************
    539          *
    540          *       _Format
    541          *
    542          */
    543          static int _Format(FS_VOLUME * pVolume, FS_FORMAT_INFO * pFormatInfo) {
    544            int Status;
    545            FS_DEV_INFO DevInfo;
    546            FS_DEVICE * pDevice;
    547            
    548            pDevice = &pVolume->Partition.Device;
    549            Status = FS_LB_GetStatus(pDevice);
    550            if (Status >= 0) {
    551              FS__LocatePartition(pVolume);            /* Check if there is a partition table */
    552              if ((void*)pFormatInfo->pDevInfo == NULL) {
    553                FS_LB_GetDeviceInfo(pDevice, &DevInfo);   /* Get info from device */
    554              } else {
    555                DevInfo = *pFormatInfo->pDevInfo;
    556              }
    557              /* If there is a partition table, then use this information to clip the size (NumSectors) */
    558              if (pVolume->Partition.StartSector) {
    559                if (DevInfo.NumSectors > pVolume->Partition.NumSectors) {
    560                  DevInfo.NumSectors = pVolume->Partition.NumSectors;
    561                }
    562              }
    563              Status = _FatFormatEx(pVolume, DevInfo.NumSectors, (U8)0xF8, DevInfo.SectorsPerTrack, DevInfo.NumHeads,
    564                                   (U8)pFormatInfo->SectorsPerCluster, pFormatInfo->NumRootDirEntries, DevInfo.BytesPerSector, 0, 1);
    565            } else {
    566              Status = -1;
    567            }
    568            return Status;
    569          }
    570          
    571          /*********************************************************************
    572          *
    573          *       _FormatEx
    574          *
    575          */
    576          static int _FormatEx(FS_VOLUME * pVolume, FS_FORMAT_INFO_EX * pFormatInfoEx) {
    577            int Status;
    578            FS_DEV_INFO DevInfo;
    579            FS_DEVICE * pDevice;
    580            
    581            pDevice = &pVolume->Partition.Device;
    582            Status = FS_LB_GetStatus(pDevice);
    583            if (Status >= 0) {
    584              FS__LocatePartition(pVolume);            /* Check if there is a partition table */
    585              if ((void*)pFormatInfoEx->pDevInfo == NULL) {
    586                FS_LB_GetDeviceInfo(pDevice, &DevInfo);   /* Get info from device */
    587              } else {
    588                DevInfo = *pFormatInfoEx->pDevInfo;
    589              }
    590              /* If there is a partition table, then use this information to clip the size (NumSectors) */
    591              if (pVolume->Partition.StartSector) {
    592                if (DevInfo.NumSectors > pVolume->Partition.NumSectors) {
    593                  DevInfo.NumSectors = pVolume->Partition.NumSectors;
    594                }
    595              }
    596              Status = _FatFormatEx(pVolume, DevInfo.NumSectors, (U8)0xF8, DevInfo.SectorsPerTrack, DevInfo.NumHeads,
    597                                   (U8)pFormatInfoEx->SectorsPerCluster, pFormatInfoEx->NumRootDirEntries, DevInfo.BytesPerSector,
    598                                    pFormatInfoEx->NumReservedSectors, pFormatInfoEx->UpdatePartition);
    599            } else {
    600              Status = -1;
    601            }
    602            return Status;
    603          }
    604          
    605          
    606          /*********************************************************************
    607          *
    608          *       Public code
    609          *
    610          **********************************************************************
    611          */
    612          
    613          /*********************************************************************
    614          *
    615          *       FS_FAT_Format
    616          *
    617          *  Description:
    618          *    This functions formats the volume
    619          *
    620          *  Return value:
    621          *    -1     Error, formatting the volume was not successful.
    622          *     0     Success.
    623          */

   \                                 In section .text, align 4, keep-with-next
    624          int FS_FAT_Format(FS_VOLUME  * pVolume, FS_FORMAT_INFO * pFormatInfo) {
   \                     FS_FAT_Format:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   28D04DE2           SUB      SP,SP,#+40
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150B0E1           MOVS     R5,R1
    625            int r;
    626            if (pFormatInfo) {
   \   00000010   2600000A           BEQ      ??FS_FAT_Format_0
    627              r = _Format(pVolume, pFormatInfo);
   \   00000014   ........           BL       FS_LB_GetStatus
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   4F00004A           BMI      ??FS_FAT_Format_1
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       FS__LocatePartition
   \   00000028   040095E5           LDR      R0,[R5, #+4]
   \   0000002C   18108DE2           ADD      R1,SP,#+24
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0C10B018           LDMNE    R0!,{R2,R3,R12}
   \   00000038   0400A001           MOVEQ    R0,R4
   \   0000003C   0C10A118           STMNE    R1!,{R2,R3,R12}
   \   00000040   ........           BLEQ     FS_LB_GetDeviceInfo
   \   00000044   140094E5           LDR      R0,[R4, #+20]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0400000A           BEQ      ??FS_FAT_Format_2
   \   00000050   180094E5           LDR      R0,[R4, #+24]
   \   00000054   1C109DE5           LDR      R1,[SP, #+28]
   \   00000058   010050E1           CMP      R0,R1
   \   0000005C   0100A081           MOVHI    R0,R1
   \   00000060   1C008DE5           STR      R0,[SP, #+28]
   \                     ??FS_FAT_Format_2:
   \   00000064   0100A0E3           MOV      R0,#+1
   \   00000068   14008DE5           STR      R0,[SP, #+20]
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   10008DE5           STR      R0,[SP, #+16]
   \   00000074   B002DDE1           LDRH     R0,[SP, #+32]
   \   00000078   BA31DDE1           LDRH     R3,[SP, #+26]
   \   0000007C   F820A0E3           MOV      R2,#+248
   \   00000080   0C008DE5           STR      R0,[SP, #+12]
   \   00000084   B200D5E1           LDRH     R0,[R5, #+2]
   \   00000088   1C109DE5           LDR      R1,[SP, #+28]
   \   0000008C   08008DE5           STR      R0,[SP, #+8]
   \   00000090   B000D5E1           LDRH     R0,[R5, #+0]
   \   00000094   FF0000E2           AND      R0,R0,#0xFF
   \   00000098   04008DE5           STR      R0,[SP, #+4]
   \   0000009C   B801DDE1           LDRH     R0,[SP, #+24]
   \   000000A0   00008DE5           STR      R0,[SP, #+0]
   \                     ??FS_FAT_Format_3:
   \   000000A4   0400A0E1           MOV      R0,R4
   \   000000A8   ........           BL       _FatFormatEx
    628            } else {
   \   000000AC   2C0000EA           B        ??FS_FAT_Format_4
    629              r = _AutoFormat(pVolume);
   \                     ??FS_FAT_Format_0:
   \   000000B0   18008DE2           ADD      R0,SP,#+24
   \   000000B4   0010A0E3           MOV      R1,#+0
   \   000000B8   0020A0E3           MOV      R2,#+0
   \   000000BC   0030A0E3           MOV      R3,#+0
   \   000000C0   0E00A0E8           STM      R0!,{R1-R3}
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   ........           BL       FS__LocatePartition
   \   000000CC   18108DE2           ADD      R1,SP,#+24
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   ........           BL       FS_LB_GetDeviceInfo
   \   000000D8   140094E5           LDR      R0,[R4, #+20]
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   18109415           LDRNE    R1,[R4, #+24]
   \   000000E4   1C108D15           STRNE    R1,[SP, #+28]
   \   000000E8   1C109DE5           LDR      R1,[SP, #+28]
   \   000000EC   000051E3           CMP      R1,#+0
   \   000000F0   1A00000A           BEQ      ??FS_FAT_Format_1
   \   000000F4   ........           ADR      LR,_aFormatInfo
   \   000000F8   B022DDE1           LDRH     R2,[SP, #+32]
   \   000000FC   0E50A0E1           MOV      R5,LR
   \   00000100   006095E5           LDR      R6,[R5, #+0]
   \   00000104   B801DDE1           LDRH     R0,[SP, #+24]
   \   00000108   BA31DDE1           LDRH     R3,[SP, #+26]
   \   0000010C   00C0A0E3           MOV      R12,#+0
   \   00000110   010056E1           CMP      R6,R1
   \   00000114   0C00003A           BCC      ??FS_FAT_Format_5
   \                     ??FS_FAT_Format_6:
   \   00000118   8CC18EE0           ADD      R12,LR,R12, LSL #+3
   \   0000011C   01E0A0E3           MOV      LR,#+1
   \   00000120   14E08DE5           STR      LR,[SP, #+20]
   \   00000124   00E0A0E3           MOV      LR,#+0
   \   00000128   10E08DE5           STR      LR,[SP, #+16]
   \   0000012C   0C208DE5           STR      R2,[SP, #+12]
   \   00000130   B620DCE1           LDRH     R2,[R12, #+6]
   \   00000134   08208DE5           STR      R2,[SP, #+8]
   \   00000138   0420DCE5           LDRB     R2,[R12, #+4]
   \   0000013C   00008DE5           STR      R0,[SP, #+0]
   \   00000140   04208DE5           STR      R2,[SP, #+4]
   \   00000144   F820A0E3           MOV      R2,#+248
   \   00000148   D5FFFFEA           B        ??FS_FAT_Format_3
   \                     ??FS_FAT_Format_5:
   \   0000014C   0860B5E5           LDR      R6,[R5, #+8]!
   \   00000150   01C08CE2           ADD      R12,R12,#+1
   \   00000154   010056E1           CMP      R6,R1
   \   00000158   FBFFFF3A           BCC      ??FS_FAT_Format_5
   \   0000015C   EDFFFFEA           B        ??FS_FAT_Format_6
   \                     ??FS_FAT_Format_1:
   \   00000160   0000E0E3           MVN      R0,#+0
    630            }
    631            return r;
   \                     ??FS_FAT_Format_4:
   \   00000164   28D08DE2           ADD      SP,SP,#+40       ;; stack cleaning
   \   00000168   7080BDE8           POP      {R4-R6,PC}       ;; return
    632          }
    633          
    634          /*********************************************************************
    635          *
    636          *       FS_FAT_FormatEx
    637          *
    638          *  Description:
    639          *    This functions formats the volume
    640          *
    641          *  Return value:
    642          *    -1     Error, formatting the volume was not successful.
    643          *     0     Success.
    644          */

   \                                 In section .text, align 4, keep-with-next
    645          int FS_FAT_FormatEx(FS_VOLUME  * pVolume, FS_FORMAT_INFO_EX * pFormatInfoEx) {
   \                     FS_FAT_FormatEx:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   28D04DE2           SUB      SP,SP,#+40
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150B0E1           MOVS     R5,R1
    646            int r;
    647            if (pFormatInfoEx) {
   \   00000010   2600000A           BEQ      ??FS_FAT_FormatEx_0
    648              r = _FormatEx(pVolume, pFormatInfoEx);
   \   00000014   ........           BL       FS_LB_GetStatus
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   4F00004A           BMI      ??FS_FAT_FormatEx_1
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       FS__LocatePartition
   \   00000028   080095E5           LDR      R0,[R5, #+8]
   \   0000002C   18108DE2           ADD      R1,SP,#+24
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0C10B018           LDMNE    R0!,{R2,R3,R12}
   \   00000038   0400A001           MOVEQ    R0,R4
   \   0000003C   0C10A118           STMNE    R1!,{R2,R3,R12}
   \   00000040   ........           BLEQ     FS_LB_GetDeviceInfo
   \   00000044   140094E5           LDR      R0,[R4, #+20]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0400000A           BEQ      ??FS_FAT_FormatEx_2
   \   00000050   180094E5           LDR      R0,[R4, #+24]
   \   00000054   1C109DE5           LDR      R1,[SP, #+28]
   \   00000058   010050E1           CMP      R0,R1
   \   0000005C   0100A081           MOVHI    R0,R1
   \   00000060   1C008DE5           STR      R0,[SP, #+28]
   \                     ??FS_FAT_FormatEx_2:
   \   00000064   0600D5E5           LDRB     R0,[R5, #+6]
   \   00000068   BA31DDE1           LDRH     R3,[SP, #+26]
   \   0000006C   F820A0E3           MOV      R2,#+248
   \   00000070   14008DE5           STR      R0,[SP, #+20]
   \   00000074   B400D5E1           LDRH     R0,[R5, #+4]
   \   00000078   1C109DE5           LDR      R1,[SP, #+28]
   \   0000007C   10008DE5           STR      R0,[SP, #+16]
   \   00000080   B002DDE1           LDRH     R0,[SP, #+32]
   \   00000084   0C008DE5           STR      R0,[SP, #+12]
   \   00000088   B200D5E1           LDRH     R0,[R5, #+2]
   \   0000008C   08008DE5           STR      R0,[SP, #+8]
   \   00000090   B000D5E1           LDRH     R0,[R5, #+0]
   \   00000094   FF0000E2           AND      R0,R0,#0xFF
   \   00000098   04008DE5           STR      R0,[SP, #+4]
   \   0000009C   B801DDE1           LDRH     R0,[SP, #+24]
   \   000000A0   00008DE5           STR      R0,[SP, #+0]
   \                     ??FS_FAT_FormatEx_3:
   \   000000A4   0400A0E1           MOV      R0,R4
   \   000000A8   ........           BL       _FatFormatEx
    649            } else {
   \   000000AC   2C0000EA           B        ??FS_FAT_FormatEx_4
    650              r = _AutoFormat(pVolume);
   \                     ??FS_FAT_FormatEx_0:
   \   000000B0   18008DE2           ADD      R0,SP,#+24
   \   000000B4   0010A0E3           MOV      R1,#+0
   \   000000B8   0020A0E3           MOV      R2,#+0
   \   000000BC   0030A0E3           MOV      R3,#+0
   \   000000C0   0E00A0E8           STM      R0!,{R1-R3}
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   ........           BL       FS__LocatePartition
   \   000000CC   18108DE2           ADD      R1,SP,#+24
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   ........           BL       FS_LB_GetDeviceInfo
   \   000000D8   140094E5           LDR      R0,[R4, #+20]
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   18109415           LDRNE    R1,[R4, #+24]
   \   000000E4   1C108D15           STRNE    R1,[SP, #+28]
   \   000000E8   1C109DE5           LDR      R1,[SP, #+28]
   \   000000EC   000051E3           CMP      R1,#+0
   \   000000F0   1A00000A           BEQ      ??FS_FAT_FormatEx_1
   \   000000F4   ........           ADR      LR,_aFormatInfo
   \   000000F8   B022DDE1           LDRH     R2,[SP, #+32]
   \   000000FC   0E50A0E1           MOV      R5,LR
   \   00000100   006095E5           LDR      R6,[R5, #+0]
   \   00000104   B801DDE1           LDRH     R0,[SP, #+24]
   \   00000108   BA31DDE1           LDRH     R3,[SP, #+26]
   \   0000010C   00C0A0E3           MOV      R12,#+0
   \   00000110   010056E1           CMP      R6,R1
   \   00000114   0C00003A           BCC      ??FS_FAT_FormatEx_5
   \                     ??FS_FAT_FormatEx_6:
   \   00000118   8CC18EE0           ADD      R12,LR,R12, LSL #+3
   \   0000011C   01E0A0E3           MOV      LR,#+1
   \   00000120   14E08DE5           STR      LR,[SP, #+20]
   \   00000124   00E0A0E3           MOV      LR,#+0
   \   00000128   10E08DE5           STR      LR,[SP, #+16]
   \   0000012C   0C208DE5           STR      R2,[SP, #+12]
   \   00000130   B620DCE1           LDRH     R2,[R12, #+6]
   \   00000134   08208DE5           STR      R2,[SP, #+8]
   \   00000138   0420DCE5           LDRB     R2,[R12, #+4]
   \   0000013C   00008DE5           STR      R0,[SP, #+0]
   \   00000140   04208DE5           STR      R2,[SP, #+4]
   \   00000144   F820A0E3           MOV      R2,#+248
   \   00000148   D5FFFFEA           B        ??FS_FAT_FormatEx_3
   \                     ??FS_FAT_FormatEx_5:
   \   0000014C   0860B5E5           LDR      R6,[R5, #+8]!
   \   00000150   01C08CE2           ADD      R12,R12,#+1
   \   00000154   010056E1           CMP      R6,R1
   \   00000158   FBFFFF3A           BCC      ??FS_FAT_FormatEx_5
   \   0000015C   EDFFFFEA           B        ??FS_FAT_FormatEx_6
   \                     ??FS_FAT_FormatEx_1:
   \   00000160   0000E0E3           MVN      R0,#+0
    651            }
    652            return r;
   \                     ??FS_FAT_FormatEx_4:
   \   00000164   28D08DE2           ADD      SP,SP,#+40       ;; stack cleaning
   \   00000168   7080BDE8           POP      {R4-R6,PC}       ;; return
    653            
    654          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     FS_Global

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   67452301           DC32     0x1234567

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   52526141           DC32     0x41615252

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   72724161           DC32     0x61417272

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MSWIN4.1">`:
   \   00000000                      ; Initializer data, 12 bytes
   \   00000000   4D5357494E34       DC8 77, 83, 87, 73, 78, 52, 46, 49, 0, 0
   \              2E310000    
   \   0000000A   0000               DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "FAT12   ">`:
   \   00000000                      ; Initializer data, 12 bytes
   \   00000000   464154313220       DC8 70, 65, 84, 49, 50, 32, 32, 32, 0, 0
   \              20200000    
   \   0000000A   0000               DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "FAT16   ">`:
   \   00000000                      ; Initializer data, 12 bytes
   \   00000000   464154313620       DC8 70, 65, 84, 49, 54, 32, 32, 32, 0, 0
   \              20200000    
   \   0000000A   0000               DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "FAT32   ">`:
   \   00000000                      ; Initializer data, 12 bytes
   \   00000000   464154333220       DC8 70, 65, 84, 51, 50, 32, 32, 32, 0, 0
   \              20200000    
   \   0000000A   0000               DC8 0, 0
    655          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function        .cstack
     --------        -------
     FS_FAT_Format       56
     FS_FAT_FormatEx     56
     _FatFormatEx        72


   Section sizes:

     Function/Label         Bytes
     --------------         -----
     _aFATTypeInfo            24
     _acVolumeLabel           12
     _aFormatInfo            104
     _FatFormatEx           1488
     FS_FAT_Format           364
     FS_FAT_FormatEx         364
     ??DataTable7              4
     ??DataTable7_1            4
     ??DataTable7_2            4
     ??DataTable7_3            4
     ?<Constant "MSWIN4.1">   12
     ?<Constant "FAT12   ">   12
     ?<Constant "FAT16   ">   12
     ?<Constant "FAT32   ">   12

 
 2 420 bytes in section .text
 
 2 420 bytes of CODE memory

Errors: none
Warnings: none
