###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     14/Jul/2015  19:01:21 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\LCD_RotateCCW.c                     #
#    Command line =  C:\DUII\TargetHW\GUI\LCD_RotateCCW.c -D DEBUG=1 -D       #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D                   #
#                    XIGNORE_TEMPERATURE -D BUILD_DEBUG_PORT -D PROFILER      #
#                    -lCN C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Li #
#                    st\ -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\ #
#                    Obj\ --debug --endian=little --cpu=ARM926EJ-S -e         #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\LC #
#                    D_RotateCCW.lst                                          #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\LCD #
#                    _RotateCCW.o                                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\LCD_RotateCCW.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : LCD_RotateCCW.c
     19          Purpose     : Implementation of GUI_SetRotation
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include "GUI_Private.h"
     24          
     25          #if GUI_WINSUPPORT
     26            #include "WM.h"
     27          #endif
     28          
     29          #if GUI_SUPPORT_ROTATION
     30          
     31          /*********************************************************************
     32          *
     33          *       Static code
     34          *
     35          **********************************************************************
     36          */
     37          /*********************************************************************
     38          *
     39          *       _GetpfSetPixel
     40          */
     41          static tLCD_SetPixelAA * _GetpfSetPixel(void) {
     42            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
     43            case 0:
     44              return &LCD_SetPixelAA_NoTrans;
     45            case LCD_DRAWMODE_TRANS:
     46              return &LCD_SetPixelAA;
     47            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
     48            case LCD_DRAWMODE_XOR:
     49              return &LCD_SetPixelAA_Xor;
     50            }
     51            return NULL; // Never reach...
     52          }
     53          
     54          /*********************************************************************
     55          *
     56          *       _DrawBitLine1BPP
     57          */

   \                                 In section .text, align 4, keep-with-next
     58          static void  _DrawBitLine1BPP(int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine1BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   2C009DE5           LDR      R0,[SP, #+44]
     59            LCD_PIXELINDEX Index0, Index1;
     60            unsigned IndexMask, Pixel;
     61          
     62            Index0 = *(pTrans + 0);
     63            Index1 = *(pTrans + 1);
     64            y -= Diff;
     65            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000010   ........           LDR      R5,??DataTable4
   \   00000014   00A090E5           LDR      R10,[R0, #+0]
   \   00000018   04B090E5           LDR      R11,[R0, #+4]
   \   0000001C   1000D5E5           LDRB     R0,[R5, #+16]
   \   00000020   0370A0E1           MOV      R7,R3
   \   00000024   0280A0E1           MOV      R8,R2
   \   00000028   28909DE5           LDR      R9,[SP, #+40]
   \   0000002C   076041E0           SUB      R6,R1,R7
   \   00000030   030010E2           ANDS     R0,R0,#0x3
   \   00000034   0300000A           BEQ      ??_DrawBitLine1BPP_0
   \   00000038   020050E3           CMP      R0,#+2
   \   0000003C   1600000A           BEQ      ??_DrawBitLine1BPP_1
   \   00000040   2A00003A           BCC      ??_DrawBitLine1BPP_2
   \   00000044   4D0000EA           B        ??_DrawBitLine1BPP_3
     66            case 0:
     67              do {
     68                LCDDEV_L0_SetPixelIndex(GUI_Context.apDevice[GUI_Context.SelLayer], x, y, (*p & (0x80 >> Diff)) ? Index1 : Index0);
   \                     ??_DrawBitLine1BPP_0:
   \   00000048   0000D8E5           LDRB     R0,[R8, #+0]
   \   0000004C   8010A0E3           MOV      R1,#+128
   \   00000050   0620A0E1           MOV      R2,R6
   \   00000054   510710E1           TST      R0,R1, ASR R7
   \   00000058   1100D5E5           LDRB     R0,[R5, #+17]
   \   0000005C   0B30A011           MOVNE    R3,R11
   \   00000060   0A30A001           MOVEQ    R3,R10
   \   00000064   000185E0           ADD      R0,R5,R0, LSL #+2
   \   00000068   480090E5           LDR      R0,[R0, #+72]
   \   0000006C   0410A0E1           MOV      R1,R4
   \   00000070   0CC090E5           LDR      R12,[R0, #+12]
   \   00000074   18C09CE5           LDR      R12,[R12, #+24]
   \   00000078   3CFF2FE1           BLX      R12
     69                y--;
     70                if (++Diff == 8) {
   \   0000007C   017087E2           ADD      R7,R7,#+1
   \   00000080   080057E3           CMP      R7,#+8
     71                  Diff = 0;
   \   00000084   0070A003           MOVEQ    R7,#+0
     72                  p++;
   \   00000088   01808802           ADDEQ    R8,R8,#+1
   \   0000008C   016046E2           SUB      R6,R6,#+1
     73                }
     74              } while (--xsize);
   \   00000090   019059E2           SUBS     R9,R9,#+1
   \   00000094   EBFFFF1A           BNE      ??_DrawBitLine1BPP_0
   \   00000098   380000EA           B        ??_DrawBitLine1BPP_3
     75              break;
     76            case LCD_DRAWMODE_TRANS:
     77              do {
     78                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_1:
   \   0000009C   0000D8E5           LDRB     R0,[R8, #+0]
   \   000000A0   8010A0E3           MOV      R1,#+128
   \   000000A4   510710E1           TST      R0,R1, ASR R7
   \   000000A8   0800000A           BEQ      ??_DrawBitLine1BPP_4
   \   000000AC   1100D5E5           LDRB     R0,[R5, #+17]
   \   000000B0   0B30A0E1           MOV      R3,R11
   \   000000B4   0620A0E1           MOV      R2,R6
   \   000000B8   000185E0           ADD      R0,R5,R0, LSL #+2
   \   000000BC   480090E5           LDR      R0,[R0, #+72]
   \   000000C0   0410A0E1           MOV      R1,R4
   \   000000C4   0CC090E5           LDR      R12,[R0, #+12]
   \   000000C8   18C09CE5           LDR      R12,[R12, #+24]
     79                  LCDDEV_L0_SetPixelIndex(GUI_Context.apDevice[GUI_Context.SelLayer], x, y, Index1);
   \   000000CC   3CFF2FE1           BLX      R12
     80                }
     81                y--;
     82                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_4:
   \   000000D0   017087E2           ADD      R7,R7,#+1
   \   000000D4   080057E3           CMP      R7,#+8
     83                  Diff = 0;
   \   000000D8   0070A003           MOVEQ    R7,#+0
     84                  p++;
   \   000000DC   01808802           ADDEQ    R8,R8,#+1
   \   000000E0   016046E2           SUB      R6,R6,#+1
     85                }
     86              } while (--xsize);
   \   000000E4   019059E2           SUBS     R9,R9,#+1
   \   000000E8   EBFFFF1A           BNE      ??_DrawBitLine1BPP_1
   \   000000EC   230000EA           B        ??_DrawBitLine1BPP_3
     87              break;
     88            case LCD_DRAWMODE_XOR:;
     89              IndexMask = GUI_Context.apDevice[GUI_Context.SelLayer]->pColorConvAPI->pfGetIndexMask();
   \                     ??_DrawBitLine1BPP_2:
   \   000000F0   1100D5E5           LDRB     R0,[R5, #+17]
   \   000000F4   000185E0           ADD      R0,R5,R0, LSL #+2
   \   000000F8   480090E5           LDR      R0,[R0, #+72]
   \   000000FC   100090E5           LDR      R0,[R0, #+16]
   \   00000100   080090E5           LDR      R0,[R0, #+8]
   \   00000104   30FF2FE1           BLX      R0
   \   00000108   00A0A0E1           MOV      R10,R0
   \   0000010C   80B0A0E3           MOV      R11,#+128
     90              do {
     91                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_5:
   \   00000110   0000D8E5           LDRB     R0,[R8, #+0]
   \   00000114   5B0710E1           TST      R0,R11, ASR R7
   \   00000118   1100000A           BEQ      ??_DrawBitLine1BPP_6
   \   0000011C   1100D5E5           LDRB     R0,[R5, #+17]
   \   00000120   0620A0E1           MOV      R2,R6
   \   00000124   0410A0E1           MOV      R1,R4
   \   00000128   000185E0           ADD      R0,R5,R0, LSL #+2
   \   0000012C   480090E5           LDR      R0,[R0, #+72]
   \   00000130   0C3090E5           LDR      R3,[R0, #+12]
   \   00000134   143093E5           LDR      R3,[R3, #+20]
     92                  Pixel = LCDDEV_L0_GetPixelIndex(GUI_Context.apDevice[GUI_Context.SelLayer], x, y);
   \   00000138   33FF2FE1           BLX      R3
   \   0000013C   0010A0E1           MOV      R1,R0
   \   00000140   1100D5E5           LDRB     R0,[R5, #+17]
   \   00000144   01302AE0           EOR      R3,R10,R1
   \   00000148   0620A0E1           MOV      R2,R6
   \   0000014C   000185E0           ADD      R0,R5,R0, LSL #+2
   \   00000150   480090E5           LDR      R0,[R0, #+72]
   \   00000154   0410A0E1           MOV      R1,R4
   \   00000158   0CC090E5           LDR      R12,[R0, #+12]
   \   0000015C   18C09CE5           LDR      R12,[R12, #+24]
     93                  LCDDEV_L0_SetPixelIndex(GUI_Context.apDevice[GUI_Context.SelLayer], x, y, Pixel ^ IndexMask);
   \   00000160   3CFF2FE1           BLX      R12
     94                }
     95                y--;
     96                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_6:
   \   00000164   017087E2           ADD      R7,R7,#+1
   \   00000168   080057E3           CMP      R7,#+8
     97                  Diff = 0;
   \   0000016C   0070A003           MOVEQ    R7,#+0
     98                  p++;
   \   00000170   01808802           ADDEQ    R8,R8,#+1
   \   00000174   016046E2           SUB      R6,R6,#+1
     99                }
    100              } while (--xsize);
   \   00000178   019059E2           SUBS     R9,R9,#+1
   \   0000017C   E3FFFF1A           BNE      ??_DrawBitLine1BPP_5
    101              break;
    102            }
    103          }
   \                     ??_DrawBitLine1BPP_3:
   \   00000180   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000184   F08FBDE8           POP      {R4-R11,PC}      ;; return
    104          
    105          /*********************************************************************
    106          *
    107          *       _DrawBitLine2BPP
    108          */
    109          static void  _DrawBitLine2BPP(int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize) {
    110            LCD_PIXELINDEX Pixels, PixelIndex;
    111            int CurrentPixel, Shift, Index;
    112            tLCD_SetPixelAA * pfSetPixelAA;
    113            const int aConvTable[4] = {0, 5, 10, 15};
    114          
    115            Pixels = *p;
    116            CurrentPixel = Diff;
    117            y -= Diff;
    118            pfSetPixelAA = _GetpfSetPixel();
    119            do {
    120              Shift = (3 - CurrentPixel) << 1;
    121              Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    122              PixelIndex = *(aConvTable + Index);
    123              pfSetPixelAA(x, y, PixelIndex);
    124              y--;
    125              if (++CurrentPixel == 4) {
    126                CurrentPixel = 0;
    127                Pixels = *(++p);
    128              }
    129            } while (--xsize);
    130          }
    131          
    132          /*********************************************************************
    133          *
    134          *       _DrawBitLine4BPP
    135          */
    136          static void  _DrawBitLine4BPP(int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize) {
    137            LCD_PIXELINDEX Pixels;
    138            int CurrentPixel, Shift, Index;
    139            tLCD_SetPixelAA * pfSetPixelAA;
    140          
    141            Pixels = *p;
    142            CurrentPixel = Diff;
    143            y -= Diff;
    144            pfSetPixelAA = _GetpfSetPixel();
    145            do {
    146              Shift = (1 - CurrentPixel) << 2;
    147              Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    148              pfSetPixelAA(x, y, Index);
    149              y--;
    150              if (++CurrentPixel == 2) {
    151                CurrentPixel = 0;
    152                Pixels = *(++p);
    153              }
    154            } while (--xsize);
    155          }
    156          
    157          /*********************************************************************
    158          *
    159          *       _DrawBitmap
    160          *
    161          * Purpose:
    162          *   Draws a bitmap (1bpp) counter clockwise.
    163          */

   \                                 In section .text, align 4, keep-with-next
    164          static void _DrawBitmap(int x0, int y0,
    165                                  int xsize, int ysize,
    166                                  int BitsPerPixel, 
    167                                  int BytesPerLine,
    168                                  const U8 GUI_UNI_PTR * pData, int Diff,
    169                                  const LCD_PIXELINDEX * pTrans)
    170          {
   \                     _DrawBitmap:
   \   00000000   FE4F2DE9           PUSH     {R1-R11,LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
    171            int i;
    172            /* Use _DrawBitLineXBPP */
    173            for (i = 0; i < ysize; i++) {
   \   00000008   28109DE5           LDR      R1,[SP, #+40]
   \   0000000C   0020A0E3           MOV      R2,#+0
   \   00000010   58409DE5           LDR      R4,[SP, #+88]
   \   00000014   0C208DE5           STR      R2,[SP, #+12]
   \   00000018   010051E3           CMP      R1,#+1
   \   0000001C   7A0000BA           BLT      ??_DrawBitmap_2
   \   00000020   08008DE5           STR      R0,[SP, #+8]
    174              switch (BitsPerPixel) {
   \                     ??_DrawBitmap_3:
   \   00000024   50009DE5           LDR      R0,[SP, #+80]
   \   00000028   010050E2           SUBS     R0,R0,#+1
   \   0000002C   0400000A           BEQ      ??_DrawBitmap_4
   \   00000030   010050E2           SUBS     R0,R0,#+1
   \   00000034   0C00000A           BEQ      ??_DrawBitmap_5
   \   00000038   020050E2           SUBS     R0,R0,#+2
   \   0000003C   3C00000A           BEQ      ??_DrawBitmap_6
   \   00000040   650000EA           B        ??_DrawBitmap_7
    175              case 1:
    176                _DrawBitLine1BPP(x0 + i, y0, pData, Diff, xsize, pTrans);
   \                     ??_DrawBitmap_4:
   \   00000044   60009DE5           LDR      R0,[SP, #+96]
   \   00000048   5C309DE5           LDR      R3,[SP, #+92]
   \   0000004C   04008DE5           STR      R0,[SP, #+4]
   \   00000050   24009DE5           LDR      R0,[SP, #+36]
   \   00000054   0420A0E1           MOV      R2,R4
   \   00000058   00008DE5           STR      R0,[SP, #+0]
   \   0000005C   20109DE5           LDR      R1,[SP, #+32]
   \   00000060   08009DE5           LDR      R0,[SP, #+8]
   \   00000064   ........           BL       _DrawBitLine1BPP
    177                break;
   \   00000068   5B0000EA           B        ??_DrawBitmap_7
    178              case 2:
    179                _DrawBitLine2BPP(x0 + i, y0, pData, Diff, xsize);
   \                     ??_DrawBitmap_5:
   \   0000006C   ............       ADRL     R1,`?<Constant {0, 5, 10, 15}>`
   \              ....        
   \   00000074   24509DE5           LDR      R5,[SP, #+36]
   \   00000078   0C50B1E8           LDM      R1!,{R2,R3,R12,LR}
   \   0000007C   08709DE5           LDR      R7,[SP, #+8]
   \   00000080   10008DE2           ADD      R0,SP,#+16
   \   00000084   0C50A0E8           STM      R0!,{R2,R3,R12,LR}
   \   00000088   5C909DE5           LDR      R9,[SP, #+92]
   \   0000008C   20009DE5           LDR      R0,[SP, #+32]
   \   00000090   0460A0E1           MOV      R6,R4
   \   00000094   09A040E0           SUB      R10,R0,R9
   \   00000098   ........           LDR      R0,??DataTable4
   \   0000009C   0080D6E5           LDRB     R8,[R6, #+0]
   \   000000A0   1000D0E5           LDRB     R0,[R0, #+16]
   \   000000A4   030000E2           AND      R0,R0,#0x3
   \   000000A8   030050E3           CMP      R0,#+3
   \   000000AC   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_DrawBitmap_0:
   \   000000B0   0900008A           BHI      ??_DrawBitmap_8
   \   000000B4   060000EA           B        ??_DrawBitmap_9
   \   000000B8   010000EA           B        ??_DrawBitmap_10
   \   000000BC   020000EA           B        ??_DrawBitmap_11
   \   000000C0   FFFFFFEA           B        ??_DrawBitmap_10
   \                     ??_DrawBitmap_10:
   \   000000C4   ........           LDR      R11,??DataTable4_1
   \   000000C8   040000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_11:
   \   000000CC   ........           LDR      R11,??DataTable4_2
   \   000000D0   020000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_9:
   \   000000D4   ........           LDR      R11,??DataTable4_3
   \   000000D8   000000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_8:
   \   000000DC   00B0A0E3           MOV      R11,#+0
   \                     ??_DrawBitmap_12:
   \   000000E0   030069E2           RSB      R0,R9,#+3
   \   000000E4   8000A0E1           LSL      R0,R0,#+1
   \   000000E8   0020A0E1           MOV      R2,R0
   \   000000EC   C010A0E3           MOV      R1,#+192
   \   000000F0   062062E2           RSB      R2,R2,#+6
   \   000000F4   511208E0           AND      R1,R8,R1, ASR R2
   \   000000F8   3100A0E1           LSR      R0,R1,R0
   \   000000FC   10108DE2           ADD      R1,SP,#+16
   \   00000100   002191E7           LDR      R2,[R1, +R0, LSL #+2]
   \   00000104   0A10A0E1           MOV      R1,R10
   \   00000108   FF2002E2           AND      R2,R2,#0xFF
   \   0000010C   0700A0E1           MOV      R0,R7
   \   00000110   3BFF2FE1           BLX      R11
   \   00000114   019089E2           ADD      R9,R9,#+1
   \   00000118   040059E3           CMP      R9,#+4
   \   0000011C   0090A003           MOVEQ    R9,#+0
   \   00000120   0180F605           LDRBEQ   R8,[R6, #+1]!
   \   00000124   01A04AE2           SUB      R10,R10,#+1
   \   00000128   015055E2           SUBS     R5,R5,#+1
   \   0000012C   EBFFFF1A           BNE      ??_DrawBitmap_12
   \   00000130   290000EA           B        ??_DrawBitmap_7
    180                break;
    181              case 4:
    182                _DrawBitLine4BPP(x0 + i, y0, pData, Diff, xsize);
   \                     ??_DrawBitmap_6:
   \   00000134   5C909DE5           LDR      R9,[SP, #+92]
   \   00000138   20009DE5           LDR      R0,[SP, #+32]
   \   0000013C   0460A0E1           MOV      R6,R4
   \   00000140   09A040E0           SUB      R10,R0,R9
   \   00000144   ........           LDR      R0,??DataTable4
   \   00000148   24509DE5           LDR      R5,[SP, #+36]
   \   0000014C   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000150   08709DE5           LDR      R7,[SP, #+8]
   \   00000154   0080D6E5           LDRB     R8,[R6, #+0]
   \   00000158   030000E2           AND      R0,R0,#0x3
   \   0000015C   030050E3           CMP      R0,#+3
   \   00000160   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_DrawBitmap_1:
   \   00000164   0900008A           BHI      ??_DrawBitmap_13
   \   00000168   060000EA           B        ??_DrawBitmap_14
   \   0000016C   010000EA           B        ??_DrawBitmap_15
   \   00000170   020000EA           B        ??_DrawBitmap_16
   \   00000174   FFFFFFEA           B        ??_DrawBitmap_15
   \                     ??_DrawBitmap_15:
   \   00000178   ........           LDR      R11,??DataTable4_1
   \   0000017C   040000EA           B        ??_DrawBitmap_17
   \                     ??_DrawBitmap_16:
   \   00000180   ........           LDR      R11,??DataTable4_2
   \   00000184   020000EA           B        ??_DrawBitmap_17
   \                     ??_DrawBitmap_14:
   \   00000188   ........           LDR      R11,??DataTable4_3
   \   0000018C   000000EA           B        ??_DrawBitmap_17
   \                     ??_DrawBitmap_13:
   \   00000190   00B0A0E3           MOV      R11,#+0
   \                     ??_DrawBitmap_17:
   \   00000194   010069E2           RSB      R0,R9,#+1
   \   00000198   0001A0E1           LSL      R0,R0,#+2
   \   0000019C   0020A0E1           MOV      R2,R0
   \   000001A0   F010A0E3           MOV      R1,#+240
   \   000001A4   042062E2           RSB      R2,R2,#+4
   \   000001A8   511208E0           AND      R1,R8,R1, ASR R2
   \   000001AC   3120A0E1           LSR      R2,R1,R0
   \   000001B0   FF2002E2           AND      R2,R2,#0xFF
   \   000001B4   0A10A0E1           MOV      R1,R10
   \   000001B8   0700A0E1           MOV      R0,R7
   \   000001BC   3BFF2FE1           BLX      R11
   \   000001C0   019089E2           ADD      R9,R9,#+1
   \   000001C4   020059E3           CMP      R9,#+2
   \   000001C8   0090A003           MOVEQ    R9,#+0
   \   000001CC   0180F605           LDRBEQ   R8,[R6, #+1]!
   \   000001D0   01A04AE2           SUB      R10,R10,#+1
   \   000001D4   015055E2           SUBS     R5,R5,#+1
   \   000001D8   EDFFFF1A           BNE      ??_DrawBitmap_17
    183                break;
    184              }
    185              pData += BytesPerLine;
   \                     ??_DrawBitmap_7:
   \   000001DC   54009DE5           LDR      R0,[SP, #+84]
    186            }
   \   000001E0   28109DE5           LDR      R1,[SP, #+40]
   \   000001E4   044080E0           ADD      R4,R0,R4
   \   000001E8   0C009DE5           LDR      R0,[SP, #+12]
   \   000001EC   010080E2           ADD      R0,R0,#+1
   \   000001F0   0C008DE5           STR      R0,[SP, #+12]
   \   000001F4   08009DE5           LDR      R0,[SP, #+8]
   \   000001F8   010080E2           ADD      R0,R0,#+1
   \   000001FC   08008DE5           STR      R0,[SP, #+8]
   \   00000200   0C009DE5           LDR      R0,[SP, #+12]
   \   00000204   010050E1           CMP      R0,R1
   \   00000208   85FFFFBA           BLT      ??_DrawBitmap_3
    187          }
   \                     ??_DrawBitmap_2:
   \   0000020C   2CD08DE2           ADD      SP,SP,#+44       ;; stack cleaning
   \   00000210   F08FBDE8           POP      {R4-R11,PC}      ;; return
    188          
    189          /*********************************************************************
    190          *
    191          *       _Rect2TextRect
    192          *
    193          * Purpose:
    194          *   This function transforms a given rectangle (window coordinates)
    195          *   to the rectangle used to clip the text.
    196          */

   \                                 In section .text, align 4, keep-with-next
    197          static void _Rect2TextRect(GUI_RECT * pRect) {
    198            int x1, y1;
    199            x1 = pRect->x1;
    200            y1 = pRect->y1;
    201            pRect->x1 = pRect->x0 + (y1 - pRect->y0);
   \                     _Rect2TextRect:
   \   00000000   F030D0E1           LDRSH    R3,[R0, #+0]
   \   00000004   F6C0D0E1           LDRSH    R12,[R0, #+6]
   \   00000008   F410D0E1           LDRSH    R1,[R0, #+4]
   \   0000000C   F220D0E1           LDRSH    R2,[R0, #+2]
   \   00000010   03C08CE0           ADD      R12,R12,R3
   \   00000014   02C04CE0           SUB      R12,R12,R2
    202            pRect->y1 = pRect->y0 + (x1 - pRect->x0);
   \   00000018   021081E0           ADD      R1,R1,R2
   \   0000001C   B4C0C0E1           STRH     R12,[R0, #+4]
   \   00000020   031041E0           SUB      R1,R1,R3
   \   00000024   B610C0E1           STRH     R1,[R0, #+6]
    203          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
    204          
    205          /*********************************************************************
    206          *
    207          *       _TransformPointCCW
    208          *
    209          * Purpose:
    210          *   This function transforms an unrotated point (window
    211          *   coordinates) into a rotated point in desktop coordinates
    212          *   and handles the rotation of the current text rectangle.
    213          */
    214          static void _TransformPointCCW(int * pXPos, int * pYPos) {
    215            GUI_RECT ClientRect = {0};
    216            int xPos, yPos, xNumPixel, yNumPixel;
    217            /* Get the client rectangle */
    218            #if GUI_WINSUPPORT
    219              WM_GetWindowRect(&ClientRect);
    220            #else
    221              GUI_GetClientRect(&ClientRect);
    222            #endif
    223            xNumPixel = LCD_GetXSize() - 1;
    224            yNumPixel = LCD_GetYSize() - 1;
    225            if (ClientRect.x1 > xNumPixel) {
    226              ClientRect.x1 = xNumPixel;
    227            }
    228            if (ClientRect.y1 > yNumPixel) {
    229              ClientRect.y1 = yNumPixel;
    230            }
    231            /* Save old positions */
    232            xPos = *pXPos;
    233            yPos = *pYPos;
    234            /* Rotate and add window origin */
    235            *pXPos = ClientRect.x0 + yPos;
    236            *pYPos = ClientRect.y1 - xPos;
    237            /* Handle rotation of text rectangle */
    238            *pXPos = *pXPos + GUI_RectDispString.x0 - GUI_RectDispString.y0;
    239            *pYPos = *pYPos + GUI_RectDispString.y1 - (ClientRect.y1 - ClientRect.y0) + GUI_RectDispString.x0;
    240          }
    241          
    242          /*********************************************************************
    243          *
    244          *       _DrawBitmapCCW
    245          */

   \                                 In section .text, align 4, keep-with-next
    246          static void _DrawBitmapCCW(int x0, int y0, int xsize, int ysize, int xMul, int yMul,
    247                                     int BitsPerPixel, int BytesPerLine,
    248                                     const U8 GUI_UNI_PTR * pPixel, const LCD_PIXELINDEX* pTrans)
    249          {
   \                     _DrawBitmapCCW:
   \   00000000   F44F2DE9           PUSH     {R2,R4-R11,LR}
   \   00000004   0090A0E1           MOV      R9,R0
   \   00000008   0180A0E1           MOV      R8,R1
   \   0000000C   0340A0E1           MOV      R4,R3
    250            U8  Data = 0;
    251            int x1, y1, Diff;
    252            /* Handle the optional Y-magnification */
    253            y1 = y0 + ysize - 1;
   \   00000010   080084E0           ADD      R0,R4,R8
   \   00000014   01A040E2           SUB      R10,R0,#+1
    254            x1 = x0 + xsize - 1;
   \   00000018   090082E0           ADD      R0,R2,R9
    255            /* Rotate positions */
    256            _TransformPointCCW(&x0, &y0);
   \   0000001C   ........           ADR      R7,`?<Constant {0}>`
   \   00000020   016040E2           SUB      R6,R0,#+1
   \   00000024   18D04DE2           SUB      SP,SP,#+24
   \   00000028   000097E5           LDR      R0,[R7, #+0]
   \   0000002C   041097E5           LDR      R1,[R7, #+4]
   \   00000030   48509DE5           LDR      R5,[SP, #+72]
   \   00000034   0D20A0E1           MOV      R2,SP
   \   00000038   030082E8           STM      R2,{R0,R1}
   \   0000003C   0D00A0E1           MOV      R0,SP
   \   00000040   ........           BL       WM_GetWindowRect
   \   00000044   ........           BL       LCD_GetXSize
   \   00000048   01B040E2           SUB      R11,R0,#+1
   \   0000004C   ........           BL       LCD_GetYSize
   \   00000050   F410DDE1           LDRSH    R1,[SP, #+4]
   \   00000054   010040E2           SUB      R0,R0,#+1
   \   00000058   F020DDE1           LDRSH    R2,[SP, #+0]
   \   0000005C   01005BE1           CMP      R11,R1
   \   00000060   F610DDE1           LDRSH    R1,[SP, #+6]
   \   00000064   B4B0CDB1           STRHLT   R11,[SP, #+4]
   \   00000068   022088E0           ADD      R2,R8,R2
   \   0000006C   010050E1           CMP      R0,R1
   \   00000070   B600CDB1           STRHLT   R0,[SP, #+6]
   \   00000074   0900A0E1           MOV      R0,R9
   \   00000078   ........           LDR      R9,??DataTable4_4
   \   0000007C   000060E2           RSB      R0,R0,#+0
   \   00000080   F010D9E1           LDRSH    R1,[R9, #+0]
   \   00000084   F230D9E1           LDRSH    R3,[R9, #+2]
   \   00000088   022081E0           ADD      R2,R1,R2
   \   0000008C   038042E0           SUB      R8,R2,R3
   \   00000090   F620D9E1           LDRSH    R2,[R9, #+6]
   \   00000094   000082E0           ADD      R0,R2,R0
   \   00000098   F220DDE1           LDRSH    R2,[SP, #+2]
   \   0000009C   000082E0           ADD      R0,R2,R0
   \   000000A0   000081E0           ADD      R0,R1,R0
   \   000000A4   14008DE5           STR      R0,[SP, #+20]
    257            _TransformPointCCW(&x1, &y1);
   \   000000A8   000097E5           LDR      R0,[R7, #+0]
   \   000000AC   041097E5           LDR      R1,[R7, #+4]
   \   000000B0   0D20A0E1           MOV      R2,SP
   \   000000B4   030082E8           STM      R2,{R0,R1}
   \   000000B8   0D00A0E1           MOV      R0,SP
   \   000000BC   ........           BL       WM_GetWindowRect
   \   000000C0   ........           BL       LCD_GetXSize
   \   000000C4   017040E2           SUB      R7,R0,#+1
   \   000000C8   ........           BL       LCD_GetYSize
   \   000000CC   F410DDE1           LDRSH    R1,[SP, #+4]
   \   000000D0   010040E2           SUB      R0,R0,#+1
   \   000000D4   F220D9E1           LDRSH    R2,[R9, #+2]
   \   000000D8   010057E1           CMP      R7,R1
   \   000000DC   F610DDE1           LDRSH    R1,[SP, #+6]
   \   000000E0   B470CDB1           STRHLT   R7,[SP, #+4]
   \   000000E4   F630D9E1           LDRSH    R3,[R9, #+6]
   \   000000E8   010050E1           CMP      R0,R1
   \   000000EC   B600CDB1           STRHLT   R0,[SP, #+6]
   \   000000F0   F010DDE1           LDRSH    R1,[SP, #+0]
   \   000000F4   F000D9E1           LDRSH    R0,[R9, #+0]
   \   000000F8   01108AE0           ADD      R1,R10,R1
   \   000000FC   011080E0           ADD      R1,R0,R1
   \   00000100   021041E0           SUB      R1,R1,R2
   \   00000104   002066E2           RSB      R2,R6,#+0
   \   00000108   022083E0           ADD      R2,R3,R2
   \   0000010C   F230DDE1           LDRSH    R3,[SP, #+2]
   \   00000110   022083E0           ADD      R2,R3,R2
   \   00000114   020080E0           ADD      R0,R0,R2
    258            /*  Handle BITMAP without magnification */
    259            if ((xMul == 1) && (yMul == 1)) {
   \   00000118   40209DE5           LDR      R2,[SP, #+64]
   \   0000011C   010052E3           CMP      R2,#+1
   \   00000120   44209D05           LDREQ    R2,[SP, #+68]
   \   00000124   01005203           CMPEQ    R2,#+1
   \   00000128   3D00001A           BNE      ??_DrawBitmapCCW_0
   \   0000012C   ........           LDR      R2,??DataTable4
   \   00000130   FC20D2E1           LDRSH    R2,[R2, #+12]
   \   00000134   010052E1           CMP      R2,R1
    260              /* Clip right side */
    261              if (x1 > GUI_Context.ClipRect.x1) {
    262                Diff = x1 - GUI_Context.ClipRect.x1;
    263                ysize -= Diff;
   \   00000138   011044B0           SUBLT    R1,R4,R1
   \   0000013C   014082B0           ADDLT    R4,R2,R1
   \   00000140   ........           LDR      R1,??DataTable4
   \   00000144   F810D1E1           LDRSH    R1,[R1, #+8]
   \   00000148   010058E1           CMP      R8,R1
   \   0000014C   060000AA           BGE      ??_DrawBitmapCCW_1
    264              }
    265              /* Clip left side */
    266              if (x0 < GUI_Context.ClipRect.x0) {
    267                Diff = GUI_Context.ClipRect.x0 - x0;
    268                pPixel += Diff * BytesPerLine;
   \   00000150   4C209DE5           LDR      R2,[SP, #+76]
   \   00000154   081041E0           SUB      R1,R1,R8
   \   00000158   50309DE5           LDR      R3,[SP, #+80]
   \   0000015C   923123E0           MLA      R3,R2,R1,R3
    269                x0 += Diff;
   \   00000160   088081E0           ADD      R8,R1,R8
   \   00000164   50308DE5           STR      R3,[SP, #+80]
    270                ysize -= Diff;
   \   00000168   014044E0           SUB      R4,R4,R1
    271              }
    272              Diff = 0;
   \                     ??_DrawBitmapCCW_1:
   \   0000016C   ........           LDR      R2,??DataTable4
   \   00000170   0010A0E3           MOV      R1,#+0
   \   00000174   FA20D2E1           LDRSH    R2,[R2, #+10]
   \   00000178   020050E1           CMP      R0,R2
   \   0000017C   030000AA           BGE      ??_DrawBitmapCCW_2
    273              /* Clip top */
    274              if (y1 < GUI_Context.ClipRect.y0) {
    275                Diff = GUI_Context.ClipRect.y0 - y1;
   \   00000180   001042E0           SUB      R1,R2,R0
    276                xsize -= Diff;
   \   00000184   18009DE5           LDR      R0,[SP, #+24]
   \   00000188   010040E0           SUB      R0,R0,R1
   \   0000018C   18008DE5           STR      R0,[SP, #+24]
   \                     ??_DrawBitmapCCW_2:
   \   00000190   ........           LDR      R0,??DataTable4
   \   00000194   14209DE5           LDR      R2,[SP, #+20]
   \   00000198   FE00D0E1           LDRSH    R0,[R0, #+14]
   \   0000019C   020050E1           CMP      R0,R2
   \   000001A0   0D0000AA           BGE      ??_DrawBitmapCCW_3
    277              }
    278              /* Clip bottom */
    279              if (y0 > GUI_Context.ClipRect.y1) {
    280                Diff = y0 - GUI_Context.ClipRect.y1;
   \   000001A4   001042E0           SUB      R1,R2,R0
    281                xsize -= Diff;
   \   000001A8   18009DE5           LDR      R0,[SP, #+24]
    282                switch (BitsPerPixel) {
   \   000001AC   010055E3           CMP      R5,#+1
   \   000001B0   010040E0           SUB      R0,R0,R1
   \   000001B4   18008DE5           STR      R0,[SP, #+24]
   \   000001B8   0700001A           BNE      ??_DrawBitmapCCW_3
    283                case 1:
    284                  pPixel += (Diff >> 3); y0 -= (Diff >> 3) << 3; Diff &= 7;
   \   000001BC   50209DE5           LDR      R2,[SP, #+80]
   \   000001C0   C101A0E1           ASR      R0,R1,#+3
   \   000001C4   022080E0           ADD      R2,R0,R2
   \   000001C8   50208DE5           STR      R2,[SP, #+80]
   \   000001CC   14209DE5           LDR      R2,[SP, #+20]
   \   000001D0   071001E2           AND      R1,R1,#0x7
   \   000001D4   800142E0           SUB      R0,R2,R0, LSL #+3
   \   000001D8   14008DE5           STR      R0,[SP, #+20]
    285                  break;
    286                }
    287              }
    288              if (xsize <= 0) {
   \                     ??_DrawBitmapCCW_3:
   \   000001DC   18009DE5           LDR      R0,[SP, #+24]
   \   000001E0   010050E3           CMP      R0,#+1
    289                return;
    290              }
    291              if (ysize <= 0) {
   \   000001E4   010054A3           CMPGE    R4,#+1
   \   000001E8   570000BA           BLT      ??_DrawBitmapCCW_4
    292                return;
    293              }
    294              _DrawBitmap(x0, y0, xsize, ysize, BitsPerPixel, BytesPerLine, pPixel, Diff, pTrans);
   \   000001EC   54009DE5           LDR      R0,[SP, #+84]
   \   000001F0   0C108DE5           STR      R1,[SP, #+12]
   \   000001F4   10008DE5           STR      R0,[SP, #+16]
   \   000001F8   50009DE5           LDR      R0,[SP, #+80]
   \   000001FC   00508DE5           STR      R5,[SP, #+0]
   \   00000200   08008DE5           STR      R0,[SP, #+8]
   \   00000204   4C009DE5           LDR      R0,[SP, #+76]
   \   00000208   0430A0E1           MOV      R3,R4
   \   0000020C   04008DE5           STR      R0,[SP, #+4]
   \   00000210   18209DE5           LDR      R2,[SP, #+24]
   \   00000214   14109DE5           LDR      R1,[SP, #+20]
   \   00000218   0800A0E1           MOV      R0,R8
   \   0000021C   ........           BL       _DrawBitmap
   \   00000220   490000EA           B        ??_DrawBitmapCCW_4
    295            } else {
    296              /* Handle BITMAP with magnification */
    297              int x, y, xi, yi;
    298              int Shift = 8 - BitsPerPixel;
   \                     ??_DrawBitmapCCW_0:
   \   00000224   080065E2           RSB      R0,R5,#+8
   \   00000228   08008DE5           STR      R0,[SP, #+8]
    299              for (x = x0, xi = 0; xi < ysize; xi++, x += yMul, pPixel += BytesPerLine) {
   \   0000022C   010054E3           CMP      R4,#+1
   \   00000230   450000BA           BLT      ??_DrawBitmapCCW_4
   \   00000234   00408DE5           STR      R4,[SP, #+0]
    300                int xMax = x + yMul - 1;
   \                     ??_DrawBitmapCCW_5:
   \   00000238   44009DE5           LDR      R0,[SP, #+68]
   \   0000023C   000088E0           ADD      R0,R8,R0
   \   00000240   014040E2           SUB      R4,R0,#+1
    301                if ((xMax >= GUI_Context.ClipRect.x0) && (x <= GUI_Context.ClipRect.x1)) {
   \   00000244   ........           LDR      R0,??DataTable4
   \   00000248   F800D0E1           LDRSH    R0,[R0, #+8]
   \   0000024C   000054E1           CMP      R4,R0
   \   00000250   320000BA           BLT      ??_DrawBitmapCCW_6
   \   00000254   ........           LDR      R0,??DataTable4
   \   00000258   FC00D0E1           LDRSH    R0,[R0, #+12]
   \   0000025C   080050E1           CMP      R0,R8
   \   00000260   2E0000BA           BLT      ??_DrawBitmapCCW_6
    302                  int BitsLeft = 0;
    303                  const U8 GUI_UNI_PTR * pDataLine = pPixel;
   \   00000264   50109DE5           LDR      R1,[SP, #+80]
    304                  for (y = y0, yi = 0; yi < xsize; yi++, y -= xMul) {
   \   00000268   18009DE5           LDR      R0,[SP, #+24]
   \   0000026C   04108DE5           STR      R1,[SP, #+4]
   \   00000270   14609DE5           LDR      R6,[SP, #+20]
   \   00000274   010050E3           CMP      R0,#+1
   \   00000278   280000BA           BLT      ??_DrawBitmapCCW_6
   \   0000027C   18709DE5           LDR      R7,[SP, #+24]
   \   00000280   010000EA           B        ??_DrawBitmapCCW_7
    305                    U8  Index;
    306                    if (!BitsLeft) {
   \                     ??_DrawBitmapCCW_8:
   \   00000284   00005AE3           CMP      R10,#+0
   \   00000288   0300001A           BNE      ??_DrawBitmapCCW_9
    307                      Data = *pDataLine++;
   \                     ??_DrawBitmapCCW_7:
   \   0000028C   04109DE5           LDR      R1,[SP, #+4]
    308                      BitsLeft =8;
   \   00000290   08A0A0E3           MOV      R10,#+8
   \   00000294   0190D1E4           LDRB     R9,[R1], #+1
   \   00000298   04108DE5           STR      R1,[SP, #+4]
    309                    }
    310                    Index = Data >> Shift;
   \                     ??_DrawBitmapCCW_9:
   \   0000029C   08109DE5           LDR      R1,[SP, #+8]
   \   000002A0   FF0009E2           AND      R0,R9,#0xFF
   \   000002A4   5001A0E1           ASR      R0,R0,R1
   \   000002A8   FF0000E2           AND      R0,R0,#0xFF
    311                    Data    <<= BitsPerPixel;
   \   000002AC   1995A0E1           LSL      R9,R9,R5
    312                    BitsLeft -= BitsPerPixel;
   \   000002B0   05A04AE0           SUB      R10,R10,R5
    313                    if (Index || ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) == 0)) {
   \   000002B4   000050E3           CMP      R0,#+0
   \   000002B8   0300001A           BNE      ??_DrawBitmapCCW_10
   \   000002BC   ........           LDR      R1,??DataTable4
   \   000002C0   1010D1E5           LDRB     R1,[R1, #+16]
   \   000002C4   020011E3           TST      R1,#0x2
   \   000002C8   1000001A           BNE      ??_DrawBitmapCCW_11
    314                      LCD_PIXELINDEX OldColor = LCD__GetColorIndex();
   \                     ??_DrawBitmapCCW_10:
   \   000002CC   ........           LDR      R1,??DataTable4_5
    315                      if (pTrans) {
   \   000002D0   54209DE5           LDR      R2,[SP, #+84]
   \   000002D4   001091E5           LDR      R1,[R1, #+0]
   \   000002D8   000052E3           CMP      R2,#+0
    316                        LCD__SetColorIndex(*(pTrans + Index));
   \   000002DC   00019217           LDRNE    R0,[R2, +R0, LSL #+2]
   \   000002E0   00B091E5           LDR      R11,[R1, #+0]
    317                      } else {
    318                        LCD__SetColorIndex(Index);
   \   000002E4   000081E5           STR      R0,[R1, #+0]
    319                      }
    320                      LCD_FillRect(x, y - xMul + 1, xMax, y);
   \   000002E8   40009DE5           LDR      R0,[SP, #+64]
   \   000002EC   0630A0E1           MOV      R3,R6
   \   000002F0   000046E0           SUB      R0,R6,R0
   \   000002F4   011080E2           ADD      R1,R0,#+1
   \   000002F8   0420A0E1           MOV      R2,R4
   \   000002FC   0800A0E1           MOV      R0,R8
   \   00000300   ........           BL       LCD_FillRect
    321                      LCD__SetColorIndex(OldColor);
   \   00000304   ........           LDR      R0,??DataTable4_5
   \   00000308   000090E5           LDR      R0,[R0, #+0]
   \   0000030C   00B080E5           STR      R11,[R0, #+0]
    322                    }
    323                  }
   \                     ??_DrawBitmapCCW_11:
   \   00000310   40009DE5           LDR      R0,[SP, #+64]
   \   00000314   017057E2           SUBS     R7,R7,#+1
   \   00000318   006046E0           SUB      R6,R6,R0
   \   0000031C   D8FFFF1A           BNE      ??_DrawBitmapCCW_8
    324                }
    325              }
   \                     ??_DrawBitmapCCW_6:
   \   00000320   44009DE5           LDR      R0,[SP, #+68]
   \   00000324   50109DE5           LDR      R1,[SP, #+80]
   \   00000328   088080E0           ADD      R8,R0,R8
   \   0000032C   4C009DE5           LDR      R0,[SP, #+76]
   \   00000330   010080E0           ADD      R0,R0,R1
   \   00000334   50008DE5           STR      R0,[SP, #+80]
   \   00000338   00009DE5           LDR      R0,[SP, #+0]
   \   0000033C   010040E2           SUB      R0,R0,#+1
   \   00000340   00008DE5           STR      R0,[SP, #+0]
   \   00000344   000050E3           CMP      R0,#+0
   \   00000348   BAFFFF1A           BNE      ??_DrawBitmapCCW_5
   \                     ??_DrawBitmapCCW_4:
   \   0000034C   1CD08DE2           ADD      SP,SP,#+28       ;; stack cleaning
   \   00000350   F08FBDE8           POP      {R4-R11,PC}      ;; return
    326            }
    327          }
    328          
    329          /*********************************************************************
    330          *
    331          *       Global data
    332          *
    333          **********************************************************************
    334          */
    335          /*********************************************************************
    336          *
    337          *       LCD_APIListCCW
    338          *
    339          * Purpose:
    340          *   Function pointer table for rotating text CCW
    341          */

   \                                 In section .data, align 4
    342          tLCD_APIList LCD_APIListCCW = {
   \                     LCD_APIListCCW:
   \   00000000   ............       DC32 _DrawBitmapCCW, _Rect2TextRect
   \              ....        

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   ........           DC32     LCD_SetPixelAA_Xor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   ........           DC32     LCD_SetPixelAA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   ........           DC32     LCD_SetPixelAA_NoTrans

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   ........           DC32     GUI_RectDispString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 5, 10, 15}>`:
   \   00000000                      ; Initializer data, 16 bytes
   \   00000000   000000000500       DC32 0, 5, 10, 15
   \              00000A000000
   \              0F000000    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   0000               DC16 0
   \   00000002   000000000000       DC8 0, 0, 0, 0, 0, 0
    343            (tLCD_DrawBitmap*)&_DrawBitmapCCW,
    344            &_Rect2TextRect
    345          };
    346          
    347          #else
    348          void LCD_RotateCCW_C(void);
    349          void LCD_RotateCCW_C(void){}
    350          #endif
    351          

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     _DrawBitLine1BPP     40
     _DrawBitmap          80
     _DrawBitmapCCW       64
     _Rect2TextRect        0


   Section sizes:

     Function/Label             Bytes
     --------------             -----
     _DrawBitLine1BPP            392
     _DrawBitmap                 532
     _Rect2TextRect               44
     _DrawBitmapCCW              852
     LCD_APIListCCW                8
     ??DataTable4                  4
     ??DataTable4_1                4
     ??DataTable4_2                4
     ??DataTable4_3                4
     ??DataTable4_4                4
     ??DataTable4_5                4
     ?<Constant {0, 5, 10, 15}>   16
     ?<Constant {0}>               8

 
     8 bytes in section .data
 1 868 bytes in section .text
 
 1 868 bytes of CODE memory
     8 bytes of DATA memory

Errors: none
Warnings: none
