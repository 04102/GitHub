###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     14/Jul/2015  19:00:41 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_OX_24.c                  #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_OX_24.c -D DEBUG=1 -D    #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D                   #
#                    XIGNORE_TEMPERATURE -D BUILD_DEBUG_PORT -D PROFILER      #
#                    -lCN C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Li #
#                    st\ -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\ #
#                    Obj\ --debug --endian=little --cpu=ARM926EJ-S -e         #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\GU #
#                    IDRV_Lin_OX_24.lst                                       #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\GUI #
#                    DRV_Lin_OX_24.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDRV_Lin_OX_24.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDRV_Lin_OX_24.c
     19          Purpose     : Driver for accessing linear video memory
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stddef.h>
     24          
     25          #include "LCD_Private.h"
     26          #include "GUI_Private.h"
     27          #include "LCD_SIM.h"
     28          #include "LCD_ConfDefaults.h"
     29          
     30          #include "GUIDRV_Lin.h"
     31          
     32          #if (!defined(WIN32) | defined(LCD_SIMCONTROLLER))
     33          
     34          /*********************************************************************
     35          *
     36          *       Defines
     37          *
     38          **********************************************************************
     39          */
     40          #ifdef WIN32
     41            //
     42            // Simulation prototypes
     43            //
     44            U16  SIM_Lin_ReadMem16  (unsigned int Off);
     45            U32  SIM_Lin_ReadMem32  (unsigned int Off);
     46            U32  SIM_Lin_ReadMem32p (U32 * p);
     47            void SIM_Lin_WriteMem16 (unsigned int Off, U16 Data);
     48            void SIM_Lin_WriteMem32 (unsigned int Off, U32 Data);
     49            void SIM_Lin_WriteMem16p(U16 * p, U16 Data);
     50            void SIM_Lin_WriteMem32p(U32 * p, U32 Data);
     51            void SIM_Lin_memcpy     (void * pDst, const void * pSrc, int Len);
     52            void SIM_Lin_SetVRAMAddr(int LayerIndex, void * pVRAM);
     53            void SIM_Lin_SetVRAMSize(int LayerIndex, int xSize, int ySize);
     54            //
     55            // Access macro definition for internal simulation
     56            //
     57            #define LCD_READ_MEM16(VRAMAddr, Off)        SIM_Lin_ReadMem16(Off)
     58            #define LCD_READ_MEM32(VRAMAddr, Off)        SIM_Lin_ReadMem32(Off)
     59            #define LCD_READ_MEM32P(p)                   SIM_Lin_ReadMem32p(p)
     60            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) SIM_Lin_WriteMem16(Off, Data)
     61            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) SIM_Lin_WriteMem32(Off, Data)
     62            #define LCD_WRITE_MEM16P(p, Data)            SIM_Lin_WriteMem16p(p, Data)
     63            #define LCD_WRITE_MEM32P(p, Data)            SIM_Lin_WriteMem32p(p, Data)
     64            #undef  GUI_MEMCPY
     65            #define GUI_MEMCPY(pDst, pSrc, Len) SIM_Lin_memcpy(pDst, pSrc, Len)
     66          #else
     67            //
     68            // Access macro definition for hardware
     69            //
     70            #define LCD_READ_MEM16(VRAMAddr, Off)        (*((U16 *)VRAMAddr + (U32)Off))
     71            #define LCD_READ_MEM32(VRAMAddr, Off)        (*((U32 *)VRAMAddr + (U32)Off))
     72            #define LCD_READ_MEM32P(p)                   (*((U32 *)p))
     73            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) *((U16 *)VRAMAddr + (U32)Off) = Data
     74            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) *((U32 *)VRAMAddr + (U32)Off) = Data
     75            #define LCD_WRITE_MEM16P(p, Data)            *((U16 *)p) = Data
     76            #define LCD_WRITE_MEM32P(p, Data)            *((U32 *)p) = Data
     77          #endif
     78          
     79          #define WRITE_MEM16(VRAMAddr, Off, Data) LCD_WRITE_MEM16(VRAMAddr, Off, Data)
     80          #define WRITE_MEM32(VRAMAddr, Off, Data) LCD_WRITE_MEM32(VRAMAddr, Off, Data)
     81          #define READ_MEM16(VRAMAddr, Off)        LCD_READ_MEM16(VRAMAddr, Off)
     82          #define READ_MEM32(VRAMAddr, Off)        LCD_READ_MEM32(VRAMAddr, Off)
     83          #define READ_MEM32P(p)                   LCD_READ_MEM32P(p)
     84          #define WRITE_MEM16P(p, Data)            LCD_WRITE_MEM16P(p, Data)
     85          #define WRITE_MEM32P(p, Data)            LCD_WRITE_MEM32P(p, Data)
     86          
     87          #define OFF2PTR16(VRAMAddr, Off)     (U16 *)((U8 *)VRAMAddr + (Off << 1))
     88          #define OFF2PTR32(VRAMAddr, Off)     (U32 *)((U8 *)VRAMAddr + (Off << 2))
     89          
     90          #define XY2OFF32(vxSizePhys, x, y)      (((U32)(y * (vxSizePhys + vxSizePhys + vxSizePhys)) + ((unsigned)(x + x + x))) >> 2)
     91          
     92          /*********************************************************************
     93          *
     94          *       Types
     95          *
     96          **********************************************************************
     97          */
     98          typedef struct {
     99            U32 VRAMAddr;
    100            int xSize, ySize;
    101            int vxSize, vySize;
    102            int vxSizePhys;
    103            int xPos, yPos;
    104            int Alpha;
    105            int IsVisible;
    106            void (* pfFillRect)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex);
    107          } DRIVER_CONTEXT;
    108          
    109          /*********************************************************************
    110          *
    111          *       Static functions
    112          *
    113          **********************************************************************
    114          */
    115          /*********************************************************************
    116          *
    117          *       _SetPixelIndex
    118          *
    119          * Purpose:
    120          *   Sets the index of the given pixel. The upper layers
    121          *   calling this routine make sure that the coordinates are in range, so
    122          *   that no check on the parameters needs to be performed.
    123          */

   \                                 In section .text, align 4, keep-with-next
    124          static void _SetPixelIndex(GUI_DEVICE * pDevice, int x, int y, int PixelIndex) {
   \                     _SetPixelIndex:
   \   00000000   10402DE9           PUSH     {R4,LR}
    125            DRIVER_CONTEXT * pContext;
    126            U32 Off, Data;
    127          
    128            //
    129            // Get context
    130            //
    131            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000004   080090E5           LDR      R0,[R0, #+8]
    132            //
    133            // Mirror x
    134            //
    135            x = (pContext->vxSize - 1 - (x));
   \   00000008   0CC090E5           LDR      R12,[R0, #+12]
   \   0000000C   01C04CE2           SUB      R12,R12,#+1
   \   00000010   01E04CE0           SUB      LR,R12,R1
    136            //
    137            // Write into hardware
    138            //
    139            Off      = XY2OFF32(pContext->vxSizePhys, x, y);
   \   00000014   141090E5           LDR      R1,[R0, #+20]
    140            Data     = READ_MEM32(pContext->VRAMAddr, Off);
   \   00000018   00C090E5           LDR      R12,[R0, #+0]
   \   0000001C   910202E0           MUL      R2,R1,R2
   \   00000020   821082E0           ADD      R1,R2,R2, LSL #+1
   \   00000024   8E208EE0           ADD      R2,LR,LR, LSL #+1
   \   00000028   011082E0           ADD      R1,R2,R1
    141            PixelIndex &= 0xFFFFFF;
   \   0000002C   0324A0E1           LSL      R2,R3,#+8
   \   00000030   2111A0E1           LSR      R1,R1,#+2
    142            switch (x & 3) {
   \   00000034   03300EE2           AND      R3,LR,#0x3
   \   00000038   01419CE7           LDR      R4,[R12, +R1, LSL #+2]
   \   0000003C   2224A0E1           LSR      R2,R2,#+8
   \   00000040   030053E3           CMP      R3,#+3
   \   00000044   03F18F90           ADDLS    PC,PC,R3, LSL #+2
   \                     ??_SetPixelIndex_0:
   \   00000048   1D00008A           BHI      ??_SetPixelIndex_1
   \   0000004C   020000EA           B        ??_SetPixelIndex_2
   \   00000050   040000EA           B        ??_SetPixelIndex_3
   \   00000054   0E0000EA           B        ??_SetPixelIndex_4
   \   00000058   170000EA           B        ??_SetPixelIndex_5
    143            case 0:
    144              Data &= 0xFF000000;
    145              Data |= PixelIndex;
   \                     ??_SetPixelIndex_2:
   \   0000005C   FF3404E2           AND      R3,R4,#0xFF000000
   \   00000060   034082E1           ORR      R4,R2,R3
    146              break;
   \   00000064   160000EA           B        ??_SetPixelIndex_1
    147            case 1:
    148              Data &= 0x00FFFFFF;
    149              Data |= (PixelIndex << 24);
    150              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_SetPixelIndex_3:
   \   00000068   0434A0E1           LSL      R3,R4,#+8
   \   0000006C   02ECA0E1           LSL      LR,R2,#+24
   \   00000070   23348EE1           ORR      R3,LR,R3, LSR #+8
   \   00000074   01318CE7           STR      R3,[R12, +R1, LSL #+2]
    151              Off++;
    152              Data = READ_MEM32(pContext->VRAMAddr, Off);
    153              Data &= 0xFFFF0000;
    154              Data |= (PixelIndex >> 8);
   \   00000078   003090E5           LDR      R3,[R0, #+0]
   \   0000007C   011081E2           ADD      R1,R1,#+1
   \   00000080   013193E7           LDR      R3,[R3, +R1, LSL #+2]
   \   00000084   4224A0E1           ASR      R2,R2,#+8
   \   00000088   2338A0E1           LSR      R3,R3,#+16
   \   0000008C   034882E1           ORR      R4,R2,R3, LSL #+16
    155              break;
   \   00000090   0B0000EA           B        ??_SetPixelIndex_1
    156            case 2:
    157              Data &= 0x0000FFFF;
    158              Data |= (PixelIndex << 16);
    159              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_SetPixelIndex_4:
   \   00000094   0438A0E1           LSL      R3,R4,#+16
   \   00000098   02E8A0E1           LSL      LR,R2,#+16
   \   0000009C   23388EE1           ORR      R3,LR,R3, LSR #+16
   \   000000A0   01318CE7           STR      R3,[R12, +R1, LSL #+2]
    160              Off++;
    161              Data = READ_MEM32(pContext->VRAMAddr, Off);
    162              Data &= 0xFFFFFF00;
    163              Data |= (PixelIndex >> 16);
   \   000000A4   003090E5           LDR      R3,[R0, #+0]
   \   000000A8   011081E2           ADD      R1,R1,#+1
   \   000000AC   013193E7           LDR      R3,[R3, +R1, LSL #+2]
   \   000000B0   FF30C3E3           BIC      R3,R3,#0xFF
   \   000000B4   424883E1           ORR      R4,R3,R2, ASR #+16
    164              break;
   \   000000B8   010000EA           B        ??_SetPixelIndex_1
    165            case 3:
    166              Data &= 0x000000FF;
    167              Data |= (PixelIndex << 8);
   \                     ??_SetPixelIndex_5:
   \   000000BC   FF3004E2           AND      R3,R4,#0xFF
   \   000000C0   024483E1           ORR      R4,R3,R2, LSL #+8
    168              break;
    169            }
    170            WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_SetPixelIndex_1:
   \   000000C4   000090E5           LDR      R0,[R0, #+0]
   \   000000C8   014180E7           STR      R4,[R0, +R1, LSL #+2]
    171          }
   \   000000CC   1080BDE8           POP      {R4,PC}          ;; return
    172          
    173          /*********************************************************************
    174          *
    175          *       _GetPixelIndex
    176          *
    177          * Purpose:
    178          *   Returns the index of the given pixel. The upper layers
    179          *   calling this routine make sure that the coordinates are in range, so
    180          *   that no check on the parameters needs to be performed.
    181          */

   \                                 In section .text, align 4, keep-with-next
    182          static unsigned int _GetPixelIndex(GUI_DEVICE * pDevice, int x, int y) {
    183            DRIVER_CONTEXT * pContext;
    184            U32 Off, Data, PixelIndex;
    185          
    186            //
    187            // Get context
    188            //
    189            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetPixelIndex:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
   \   00000004   0230A0E1           MOV      R3,R2
    190            //
    191            // Mirror x
    192            //
    193            x = (pContext->vxSize - 1 - (x));
   \   00000008   0CC090E5           LDR      R12,[R0, #+12]
   \   0000000C   01C04CE2           SUB      R12,R12,#+1
   \   00000010   01104CE0           SUB      R1,R12,R1
    194            //
    195            // Read from hardware
    196            //
    197            Off      = XY2OFF32(pContext->vxSizePhys, x, y);
   \   00000014   14C090E5           LDR      R12,[R0, #+20]
   \   00000018   9C0303E0           MUL      R3,R12,R3
   \   0000001C   81C081E0           ADD      R12,R1,R1, LSL #+1
   \   00000020   833083E0           ADD      R3,R3,R3, LSL #+1
   \   00000024   03308CE0           ADD      R3,R12,R3
    198            Data     = READ_MEM32(pContext->VRAMAddr, Off);
   \   00000028   00C090E5           LDR      R12,[R0, #+0]
   \   0000002C   2331A0E1           LSR      R3,R3,#+2
    199            switch (x & 3) {
   \   00000030   031001E2           AND      R1,R1,#0x3
   \   00000034   03019CE7           LDR      R0,[R12, +R3, LSL #+2]
   \   00000038   030051E3           CMP      R1,#+3
   \   0000003C   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetPixelIndex_0:
   \   00000040   1200008A           BHI      ??_GetPixelIndex_1
   \   00000044   020000EA           B        ??_GetPixelIndex_2
   \   00000048   030000EA           B        ??_GetPixelIndex_3
   \   0000004C   090000EA           B        ??_GetPixelIndex_4
   \   00000050   0D0000EA           B        ??_GetPixelIndex_5
    200            case 0:
    201              PixelIndex  = (Data & 0x00FFFFFF);
   \                     ??_GetPixelIndex_2:
   \   00000054   0004A0E1           LSL      R0,R0,#+8
   \   00000058   0B0000EA           B        ??_GetPixelIndex_5
    202              break;
    203            case 1:
    204              PixelIndex  = (Data & 0xFF000000) >> 24;
    205              Off++;
    206              Data        = READ_MEM32(pContext->VRAMAddr, Off);
    207              PixelIndex |= (Data & 0x0000FFFF) << 8;
   \                     ??_GetPixelIndex_3:
   \   0000005C   03118CE0           ADD      R1,R12,R3, LSL #+2
   \   00000060   B410D1E1           LDRH     R1,[R1, #+4]
   \   00000064   0118A0E1           LSL      R1,R1,#+16
   \   00000068   2118A0E1           LSR      R1,R1,#+16
   \   0000006C   0114A0E1           LSL      R1,R1,#+8
   \   00000070   202C81E1           ORR      R2,R1,R0, LSR #+24
    208              break;
   \   00000074   050000EA           B        ??_GetPixelIndex_1
    209            case 2:
    210              PixelIndex  = (Data & 0xFFFF0000) >> 16;
    211              Off++;
    212              Data        = READ_MEM32(pContext->VRAMAddr, Off);
    213              PixelIndex |= (Data & 0x000000FF) << 16;
   \                     ??_GetPixelIndex_4:
   \   00000078   03118CE0           ADD      R1,R12,R3, LSL #+2
   \   0000007C   0410D1E5           LDRB     R1,[R1, #+4]
   \   00000080   0118A0E1           LSL      R1,R1,#+16
   \   00000084   202881E1           ORR      R2,R1,R0, LSR #+16
    214              break;
   \   00000088   000000EA           B        ??_GetPixelIndex_1
    215            case 3:
    216              PixelIndex  = (Data & 0xFFFFFF00) >> 8;
   \                     ??_GetPixelIndex_5:
   \   0000008C   2024A0E1           LSR      R2,R0,#+8
    217              break;
    218            }
    219            return PixelIndex;
   \                     ??_GetPixelIndex_1:
   \   00000090   0200A0E1           MOV      R0,R2
   \   00000094   1EFF2FE1           BX       LR               ;; return
    220          }
    221          
    222          /*********************************************************************
    223          *
    224          *       _XorPixel
    225          */

   \                                 In section .text, align 4, keep-with-next
    226          static void _XorPixel(GUI_DEVICE * pDevice, int x, int y) {
   \                     _XorPixel:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    227            LCD_PIXELINDEX PixelIndex;
    228            LCD_PIXELINDEX IndexMask;
    229          
    230            PixelIndex = _GetPixelIndex(pDevice, x, y);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   142090E5           LDR      R2,[R0, #+20]
   \   00000014   0150A0E1           MOV      R5,R1
   \   00000018   0C1090E5           LDR      R1,[R0, #+12]
   \   0000001C   920603E0           MUL      R3,R2,R6
   \   00000020   011041E2           SUB      R1,R1,#+1
   \   00000024   051041E0           SUB      R1,R1,R5
   \   00000028   832083E0           ADD      R2,R3,R3, LSL #+1
   \   0000002C   813081E0           ADD      R3,R1,R1, LSL #+1
   \   00000030   022083E0           ADD      R2,R3,R2
   \   00000034   003090E5           LDR      R3,[R0, #+0]
   \   00000038   2221A0E1           LSR      R2,R2,#+2
   \   0000003C   031001E2           AND      R1,R1,#0x3
   \   00000040   04D04DE2           SUB      SP,SP,#+4
   \   00000044   020193E7           LDR      R0,[R3, +R2, LSL #+2]
   \   00000048   030051E3           CMP      R1,#+3
   \   0000004C   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_XorPixel_0:
   \   00000050   1100008A           BHI      ??_XorPixel_1
   \   00000054   0E0000EA           B        ??_XorPixel_2
   \   00000058   060000EA           B        ??_XorPixel_3
   \   0000005C   000000EA           B        ??_XorPixel_4
   \   00000060   0C0000EA           B        ??_XorPixel_5
   \                     ??_XorPixel_4:
   \   00000064   021183E0           ADD      R1,R3,R2, LSL #+2
   \   00000068   0410D1E5           LDRB     R1,[R1, #+4]
   \   0000006C   0118A0E1           LSL      R1,R1,#+16
   \   00000070   207881E1           ORR      R7,R1,R0, LSR #+16
   \   00000074   080000EA           B        ??_XorPixel_1
   \                     ??_XorPixel_3:
   \   00000078   021183E0           ADD      R1,R3,R2, LSL #+2
   \   0000007C   B410D1E1           LDRH     R1,[R1, #+4]
   \   00000080   0118A0E1           LSL      R1,R1,#+16
   \   00000084   2118A0E1           LSR      R1,R1,#+16
   \   00000088   0114A0E1           LSL      R1,R1,#+8
   \   0000008C   207C81E1           ORR      R7,R1,R0, LSR #+24
   \   00000090   010000EA           B        ??_XorPixel_1
   \                     ??_XorPixel_2:
   \   00000094   0004A0E1           LSL      R0,R0,#+8
   \                     ??_XorPixel_5:
   \   00000098   2074A0E1           LSR      R7,R0,#+8
    231            IndexMask  = pDevice->pColorConvAPI->pfGetIndexMask();
   \                     ??_XorPixel_1:
   \   0000009C   100094E5           LDR      R0,[R4, #+16]
   \   000000A0   080090E5           LDR      R0,[R0, #+8]
   \   000000A4   30FF2FE1           BLX      R0
    232            _SetPixelIndex(pDevice, x, y, PixelIndex ^ IndexMask);
   \   000000A8   073020E0           EOR      R3,R0,R7
   \   000000AC   0620A0E1           MOV      R2,R6
   \   000000B0   0510A0E1           MOV      R1,R5
   \   000000B4   0400A0E1           MOV      R0,R4
   \   000000B8   04D08DE2           ADD      SP,SP,#+4
   \   000000BC   F040BDE8           POP      {R4-R7,LR}
   \   000000C0   ........           B        _SetPixelIndex   ;; tailcall
    233          }
    234          
    235          /*********************************************************************
    236          *
    237          *       _DrawHLine
    238          */

   \                                 In section .text, align 4, keep-with-next
    239          static void _DrawHLine  (GUI_DEVICE * pDevice, int x0, int y,  int x1) {
   \                     _DrawHLine:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0070A0E1           MOV      R7,R0
    240            DRIVER_CONTEXT * pContext;
    241            int Off, RemPixels, Odd, temp;
    242            U32 Data;
    243            LCD_PIXELINDEX ColorIndex;
    244          
    245            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable13
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0140A0E1           MOV      R4,R1
   \   00000018   0250A0E1           MOV      R5,R2
   \   0000001C   0360A0E1           MOV      R6,R3
   \   00000020   010010E3           TST      R0,#0x1
   \   00000024   0900000A           BEQ      ??_DrawHLine_0
   \   00000028   040056E1           CMP      R6,R4
   \   0000002C   780000BA           BLT      ??_DrawHLine_1
    246              for (; x0 <= x1; x0++) {
    247                _XorPixel(pDevice, x0, y);
   \                     ??_DrawHLine_2:
   \   00000030   0520A0E1           MOV      R2,R5
   \   00000034   0410A0E1           MOV      R1,R4
   \   00000038   0700A0E1           MOV      R0,R7
   \   0000003C   ........           BL       _XorPixel
    248              }
   \   00000040   014084E2           ADD      R4,R4,#+1
   \   00000044   040056E1           CMP      R6,R4
   \   00000048   F8FFFFAA           BGE      ??_DrawHLine_2
   \   0000004C   700000EA           B        ??_DrawHLine_1
    249            } else {
    250              ColorIndex = LCD__GetColorIndex();
    251              //
    252              // Get context
    253              //
    254              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     ??_DrawHLine_0:
   \   00000050   081097E5           LDR      R1,[R7, #+8]
   \   00000054   ........           LDR      R0,??DataTable13_1
    255              //
    256              // Mirror x
    257              //
    258              temp = x0;
   \   00000058   0C2091E5           LDR      R2,[R1, #+12]
   \   0000005C   0430A0E1           MOV      R3,R4
   \   00000060   01C042E2           SUB      R12,R2,#+1
    259              x0 = (pContext->vxSize - 1 - x1);
    260              x1 = (pContext->vxSize - 1 - temp);
    261              Off = XY2OFF32(pContext->vxSizePhys, x0, y);
   \   00000064   142091E5           LDR      R2,[R1, #+20]
   \   00000068   06404CE0           SUB      R4,R12,R6
   \   0000006C   92050EE0           MUL      LR,R2,R5
   \   00000070   000090E5           LDR      R0,[R0, #+0]
   \   00000074   8E208EE0           ADD      R2,LR,LR, LSL #+1
   \   00000078   84E084E0           ADD      LR,R4,R4, LSL #+1
    262              RemPixels = x1 - x0 + 1;
   \   0000007C   03304CE0           SUB      R3,R12,R3
   \   00000080   02208EE0           ADD      R2,LR,R2
   \   00000084   043043E0           SUB      R3,R3,R4
   \   00000088   000090E5           LDR      R0,[R0, #+0]
   \   0000008C   2221A0E1           LSR      R2,R2,#+2
   \   00000090   013083E2           ADD      R3,R3,#+1
    263              //
    264              // First triple DWORD
    265              //
    266              Odd = x0 & 3;
   \   00000094   03C014E2           ANDS     R12,R4,#0x3
    267              if (Odd) {
   \   00000098   2900000A           BEQ      ??_DrawHLine_3
    268                Data  = READ_MEM32(pContext->VRAMAddr, Off);
   \   0000009C   00E091E5           LDR      LR,[R1, #+0]
    269                switch (Odd) {
   \   000000A0   01005CE3           CMP      R12,#+1
   \   000000A4   02419EE7           LDR      R4,[LR, +R2, LSL #+2]
   \   000000A8   0400000A           BEQ      ??_DrawHLine_4
   \   000000AC   2400003A           BCC      ??_DrawHLine_3
   \   000000B0   03005CE3           CMP      R12,#+3
   \   000000B4   1C00000A           BEQ      ??_DrawHLine_5
   \   000000B8   0F00003A           BCC      ??_DrawHLine_6
   \   000000BC   200000EA           B        ??_DrawHLine_3
    270                case 1:
    271                  Data &= 0x00FFFFFF;
    272                  Data |= ColorIndex << 24;
    273                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_4:
   \   000000C0   04C4A0E1           LSL      R12,R4,#+8
   \   000000C4   004CA0E1           LSL      R4,R0,#+24
   \   000000C8   2CC484E1           ORR      R12,R4,R12, LSR #+8
   \   000000CC   02C18EE7           STR      R12,[LR, +R2, LSL #+2]
    274                  Off++;
    275                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    276                  Data &= 0xFFFF0000;
    277                  Data |= ColorIndex >> 8;
   \   000000D0   00C091E5           LDR      R12,[R1, #+0]
   \   000000D4   012082E2           ADD      R2,R2,#+1
   \   000000D8   02C19CE7           LDR      R12,[R12, +R2, LSL #+2]
   \   000000DC   20E4A0E1           LSR      LR,R0,#+8
   \   000000E0   2CC8A0E1           LSR      R12,R12,#+16
   \   000000E4   0C488EE1           ORR      R4,LR,R12, LSL #+16
    278                  RemPixels--;
   \   000000E8   013053E2           SUBS     R3,R3,#+1
    279                  if (!RemPixels) {
   \   000000EC   0200001A           BNE      ??_DrawHLine_6
    280                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_7:
   \   000000F0   00C091E5           LDR      R12,[R1, #+0]
   \   000000F4   02418CE7           STR      R4,[R12, +R2, LSL #+2]
    281                    break;
   \   000000F8   110000EA           B        ??_DrawHLine_3
    282                  }
    283                  //
    284                  // no break at this position required...
    285                  //
    286                case 2:
    287                  Data &= 0x0000FFFF;
    288                  Data |= ColorIndex << 16;
    289                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_6:
   \   000000FC   04C8A0E1           LSL      R12,R4,#+16
   \   00000100   00E8A0E1           LSL      LR,R0,#+16
   \   00000104   2CC88EE1           ORR      R12,LR,R12, LSR #+16
   \   00000108   00E091E5           LDR      LR,[R1, #+0]
    290                  Off++;
    291                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    292                  Data &= 0xFFFFFF00;
    293                  Data |= ColorIndex >> 16;
    294                  RemPixels--;
   \   0000010C   013053E2           SUBS     R3,R3,#+1
   \   00000110   02C18EE7           STR      R12,[LR, +R2, LSL #+2]
   \   00000114   00C091E5           LDR      R12,[R1, #+0]
   \   00000118   012082E2           ADD      R2,R2,#+1
   \   0000011C   02C19CE7           LDR      R12,[R12, +R2, LSL #+2]
   \   00000120   FFC0CCE3           BIC      R12,R12,#0xFF
   \   00000124   20488CE1           ORR      R4,R12,R0, LSR #+16
    295                  if (!RemPixels) {
   \   00000128   F0FFFF0A           BEQ      ??_DrawHLine_7
    296                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    297                    break;
    298                  }
    299                  //
    300                  // no break at this position required...
    301                  //
    302                case 3:
    303                  Data &= 0x000000FF;
    304                  Data |= ColorIndex << 8;
    305                  RemPixels--;
    306                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_5:
   \   0000012C   FFC004E2           AND      R12,R4,#0xFF
   \   00000130   00E091E5           LDR      LR,[R1, #+0]
   \   00000134   00C48CE1           ORR      R12,R12,R0, LSL #+8
   \   00000138   02C18EE7           STR      R12,[LR, +R2, LSL #+2]
   \   0000013C   013043E2           SUB      R3,R3,#+1
    307                  Off++;
   \   00000140   012082E2           ADD      R2,R2,#+1
    308                }
    309              }
    310              //
    311              // Complete triple DWORDS
    312              //
    313              if (RemPixels >= 4) {
   \                     ??_DrawHLine_3:
   \   00000144   040053E3           CMP      R3,#+4
   \   00000148   100000BA           BLT      ??_DrawHLine_8
    314                U32 Data0, Data1, Data2;
    315                Data0 = (ColorIndex      ) | (ColorIndex << 24);
    316                Data1 = (ColorIndex >>  8) | (ColorIndex << 16);
   \   0000014C   00E8A0E1           LSL      LR,R0,#+16
    317                Data2 = (ColorIndex >> 16) | (ColorIndex <<  8);
   \   00000150   0044A0E1           LSL      R4,R0,#+8
   \   00000154   00CC80E1           ORR      R12,R0,R0, LSL #+24
   \   00000158   20E48EE1           ORR      LR,LR,R0, LSR #+8
   \   0000015C   204884E1           ORR      R4,R4,R0, LSR #+16
    318                do {
    319                  WRITE_MEM32(pContext->VRAMAddr, Off + 0, Data0);
   \                     ??_DrawHLine_9:
   \   00000160   005091E5           LDR      R5,[R1, #+0]
    320                  WRITE_MEM32(pContext->VRAMAddr, Off + 1, Data1);
    321                  WRITE_MEM32(pContext->VRAMAddr, Off + 2, Data2);
    322                  Off += 3;
    323                } while ((RemPixels -= 4) >= 4);
   \   00000164   043043E2           SUB      R3,R3,#+4
   \   00000168   02C185E7           STR      R12,[R5, +R2, LSL #+2]
   \   0000016C   005091E5           LDR      R5,[R1, #+0]
   \   00000170   040053E3           CMP      R3,#+4
   \   00000174   025185E0           ADD      R5,R5,R2, LSL #+2
   \   00000178   04E085E5           STR      LR,[R5, #+4]
   \   0000017C   005091E5           LDR      R5,[R1, #+0]
   \   00000180   025185E0           ADD      R5,R5,R2, LSL #+2
   \   00000184   084085E5           STR      R4,[R5, #+8]
   \   00000188   032082E2           ADD      R2,R2,#+3
   \   0000018C   F3FFFFAA           BGE      ??_DrawHLine_9
    324              }
    325              //
    326              // Last triple DWORD
    327              //
    328              if (RemPixels) {
   \                     ??_DrawHLine_8:
   \   00000190   000053E3           CMP      R3,#+0
   \   00000194   1E00000A           BEQ      ??_DrawHLine_1
    329                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    330                Data &= 0xFF000000;
    331                Data |= ColorIndex;
   \   00000198   00C091E5           LDR      R12,[R1, #+0]
    332                RemPixels--;
   \   0000019C   013053E2           SUBS     R3,R3,#+1
   \   000001A0   02E19CE7           LDR      LR,[R12, +R2, LSL #+2]
   \   000001A4   FFE40EE2           AND      LR,LR,#0xFF000000
   \   000001A8   0E4080E1           ORR      R4,R0,LR
    333                if (!RemPixels) {
   \   000001AC   0200001A           BNE      ??_DrawHLine_10
    334                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_11:
   \   000001B0   000091E5           LDR      R0,[R1, #+0]
   \   000001B4   024180E7           STR      R4,[R0, +R2, LSL #+2]
    335                  return;
   \   000001B8   150000EA           B        ??_DrawHLine_1
    336                }
    337                Data &= 0x00FFFFFF;
    338                Data |= ColorIndex << 24;
    339                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_10:
   \   000001BC   04E4A0E1           LSL      LR,R4,#+8
   \   000001C0   004CA0E1           LSL      R4,R0,#+24
   \   000001C4   2EE484E1           ORR      LR,R4,LR, LSR #+8
   \   000001C8   02E18CE7           STR      LR,[R12, +R2, LSL #+2]
    340                Off++;
    341                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    342                Data &= 0xFFFF0000;
    343                Data |= ColorIndex >> 8;
   \   000001CC   00C091E5           LDR      R12,[R1, #+0]
   \   000001D0   012082E2           ADD      R2,R2,#+1
   \   000001D4   02E19CE7           LDR      LR,[R12, +R2, LSL #+2]
   \   000001D8   2044A0E1           LSR      R4,R0,#+8
   \   000001DC   2EE8A0E1           LSR      LR,LR,#+16
   \   000001E0   0E4884E1           ORR      R4,R4,LR, LSL #+16
    344                RemPixels--;
    345                if (!RemPixels) {
   \   000001E4   013053E2           SUBS     R3,R3,#+1
   \   000001E8   F0FFFF0A           BEQ      ??_DrawHLine_11
    346                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    347                  return;
    348                }
    349                Data &= 0x0000FFFF;
    350                Data |= ColorIndex << 16;
    351                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000001EC   0438A0E1           LSL      R3,R4,#+16
   \   000001F0   00E8A0E1           LSL      LR,R0,#+16
   \   000001F4   23388EE1           ORR      R3,LR,R3, LSR #+16
   \   000001F8   02318CE7           STR      R3,[R12, +R2, LSL #+2]
    352                Off++;
    353                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    354                Data &= 0xFFFFFF00;
    355                Data |= ColorIndex >> 16;
    356                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000001FC   001091E5           LDR      R1,[R1, #+0]
   \   00000200   012082E2           ADD      R2,R2,#+1
   \   00000204   023191E7           LDR      R3,[R1, +R2, LSL #+2]
   \   00000208   FF30C3E3           BIC      R3,R3,#0xFF
   \   0000020C   200883E1           ORR      R0,R3,R0, LSR #+16
   \   00000210   020181E7           STR      R0,[R1, +R2, LSL #+2]
   \                     ??_DrawHLine_1:
   \   00000214   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000218   F080BDE8           POP      {R4-R7,PC}       ;; return
    357              }
    358            }
    359          }
    360          
    361          /*********************************************************************
    362          *
    363          *       _DrawVLine, not optimized
    364          */

   \                                 In section .text, align 4, keep-with-next
    365          static void _DrawVLine  (GUI_DEVICE * pDevice, int x, int y0,  int y1) {
   \                     _DrawVLine:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    366            LCD_PIXELINDEX ColorIndex;
    367          
    368            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable13
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0270A0E1           MOV      R7,R2
   \   00000018   0360A0E1           MOV      R6,R3
   \   0000001C   010010E3           TST      R0,#0x1
   \   00000020   0900000A           BEQ      ??_DrawVLine_0
   \   00000024   070056E1           CMP      R6,R7
   \   00000028   140000BA           BLT      ??_DrawVLine_1
    369              for (; y0 <= y1; y0++) {
    370                _XorPixel(pDevice, x, y0);
   \                     ??_DrawVLine_2:
   \   0000002C   0720A0E1           MOV      R2,R7
   \   00000030   0510A0E1           MOV      R1,R5
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       _XorPixel
    371              }
   \   0000003C   017087E2           ADD      R7,R7,#+1
   \   00000040   070056E1           CMP      R6,R7
   \   00000044   F8FFFFAA           BGE      ??_DrawVLine_2
   \   00000048   F081BDE8           POP      {R4-R8,PC}
    372            } else {
    373              ColorIndex = LCD__GetColorIndex();
   \                     ??_DrawVLine_0:
   \   0000004C   ........           LDR      R0,??DataTable13_1
   \   00000050   070056E1           CMP      R6,R7
   \   00000054   000090E5           LDR      R0,[R0, #+0]
   \   00000058   008090E5           LDR      R8,[R0, #+0]
   \   0000005C   070000BA           BLT      ??_DrawVLine_1
    374              for (; y0 <= y1; y0++) {
    375                _SetPixelIndex(pDevice, x, y0, ColorIndex);
   \                     ??_DrawVLine_3:
   \   00000060   0830A0E1           MOV      R3,R8
   \   00000064   0720A0E1           MOV      R2,R7
   \   00000068   0510A0E1           MOV      R1,R5
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   ........           BL       _SetPixelIndex
    376              }
   \   00000074   017087E2           ADD      R7,R7,#+1
   \   00000078   070056E1           CMP      R6,R7
   \   0000007C   F7FFFFAA           BGE      ??_DrawVLine_3
    377            }
    378          }
   \                     ??_DrawVLine_1:
   \   00000080   F081BDE8           POP      {R4-R8,PC}       ;; return
    379          
    380          /*********************************************************************
    381          *
    382          *       _FillRect
    383          */

   \                                 In section .text, align 4, keep-with-next
    384          static void _FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   18809DE5           LDR      R8,[SP, #+24]
   \   00000008   0260A0E1           MOV      R6,R2
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0370A0E1           MOV      R7,R3
   \   00000018   060058E1           CMP      R8,R6
   \   0000001C   070000BA           BLT      ??_FillRect_0
    385            #ifdef LCD_FILL_RECT
    386               LCD_FILL_RECT(x0, y0, x1, y1, LCD__GetColorIndex());
    387            #else
    388              for (; y0 <= y1; y0++) {
    389                _DrawHLine(pDevice, x0, y0, x1);
   \                     ??_FillRect_1:
   \   00000020   0730A0E1           MOV      R3,R7
   \   00000024   0620A0E1           MOV      R2,R6
   \   00000028   0510A0E1           MOV      R1,R5
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       _DrawHLine
    390              }
   \   00000034   016086E2           ADD      R6,R6,#+1
   \   00000038   060058E1           CMP      R8,R6
   \   0000003C   F7FFFFAA           BGE      ??_FillRect_1
    391            #endif
    392          }
   \                     ??_FillRect_0:
   \   00000040   F081BDE8           POP      {R4-R8,PC}       ;; return
    393          
    394          /*********************************************************************
    395          *
    396          *       Draw Bitmap 1 BPP
    397          */

   \                                 In section .text, align 4, keep-with-next
    398          static void _DrawBitLine1BPP(GUI_DEVICE * pDevice, unsigned x, unsigned y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine1BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0360A0E1           MOV      R6,R3
    399            #define GET_PIXEL_INDEX(Index) {               \
    400              Index = ((Pixels & 1) ? Index1 : Index0);    \
    401              PixelCnt--;                                  \
    402              Pixels >>= 1;                                \
    403              if (PixelCnt == 0) {                         \
    404                Pixels |= LCD_aMirror[*(++p)] << PixelCnt; \
    405                PixelCnt += 8;                             \
    406              }                                            \
    407            }
    408            #define GET_PIXEL_INDEX_TRANS(Index, Bit) {    \
    409              Bit = Pixels & 1;                            \
    410              GET_PIXEL_INDEX(Index);                      \
    411            }
    412            DRIVER_CONTEXT * pContext;
    413            LCD_PIXELINDEX Index0, Index1;
    414            LCD_PIXELINDEX IndexMask;
    415            U32 Off, Data, Data0, Data1, Data2, Index;
    416            unsigned Pixels, PixelCnt, Odd, Bit;
    417          
    418            Index0 = *(pTrans + 0);
    419            Index1 = *(pTrans + 1);
    420            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    421            x += Diff;
    422            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000008   ........           LDR      R3,??DataTable13
   \   0000000C   0CD04DE2           SUB      SP,SP,#+12
   \   00000010   01C0A0E1           MOV      R12,R1
   \   00000014   1030D3E5           LDRB     R3,[R3, #+16]
   \   00000018   38109DE5           LDR      R1,[SP, #+56]
   \   0000001C   0040A0E1           MOV      R4,R0
   \   00000020   30709DE5           LDR      R7,[SP, #+48]
   \   00000024   0250A0E1           MOV      R5,R2
   \   00000028   000091E5           LDR      R0,[R1, #+0]
   \   0000002C   033003E2           AND      R3,R3,#0x3
   \   00000030   34809DE5           LDR      R8,[SP, #+52]
   \   00000034   041091E5           LDR      R1,[R1, #+4]
   \   00000038   082094E5           LDR      R2,[R4, #+8]
   \   0000003C   0C9087E0           ADD      R9,R7,R12
   \   00000040   030053E3           CMP      R3,#+3
   \   00000044   03F18F90           ADDLS    PC,PC,R3, LSL #+2
   \                     ??_DrawBitLine1BPP_0:
   \   00000048   1C02008A           BHI      ??_DrawBitLine1BPP_2
   \   0000004C   020000EA           B        ??_DrawBitLine1BPP_3
   \   00000050   E20100EA           B        ??_DrawBitLine1BPP_4
   \   00000054   D30000EA           B        ??_DrawBitLine1BPP_5
   \   00000058   E00100EA           B        ??_DrawBitLine1BPP_4
    423            case 0:
    424              //
    425              // Mirror x
    426              //
    427              x = (pContext->vxSize - 1 - x);
   \                     ??_DrawBitLine1BPP_3:
   \   0000005C   0C3092E5           LDR      R3,[R2, #+12]
    428              PixelCnt = 8 - Diff;
    429              Pixels   = LCD_aMirror[*p] >> Diff;
   \   00000060   00E0D6E5           LDRB     LR,[R6, #+0]
   \   00000064   013043E2           SUB      R3,R3,#+1
   \   00000068   099043E0           SUB      R9,R3,R9
   \   0000006C   ........           LDR      R3,??DataTable14
    430              Off      = XY2OFF32(pContext->vxSizePhys, x, y);
   \   00000070   144092E5           LDR      R4,[R2, #+20]
   \   00000074   03E0DEE7           LDRB     LR,[LR, +R3]
   \   00000078   08C067E2           RSB      R12,R7,#+8
   \   0000007C   844084E0           ADD      R4,R4,R4, LSL #+1
   \   00000080   5EE7A0E1           ASR      LR,LR,R7
   \   00000084   897089E0           ADD      R7,R9,R9, LSL #+1
   \   00000088   947525E0           MLA      R5,R4,R5,R7
    431              //
    432              // First triple DWORD
    433              //
    434              Odd = x & 3;
   \   0000008C   039009E2           AND      R9,R9,#0x3
   \   00000090   2541A0E1           LSR      R4,R5,#+2
    435              if (Odd != 3) {
   \   00000094   030059E3           CMP      R9,#+3
   \   00000098   4B00000A           BEQ      ??_DrawBitLine1BPP_6
    436                if (Odd != 0) {
   \   0000009C   000059E3           CMP      R9,#+0
    437                  Off++;
    438                }
    439                Data = READ_MEM32(pContext->VRAMAddr, Off);
   \   000000A0   007092E5           LDR      R7,[R2, #+0]
   \   000000A4   01408412           ADDNE    R4,R4,#+1
   \   000000A8   045197E7           LDR      R5,[R7, +R4, LSL #+2]
    440                switch (Odd) {
   \   000000AC   3500000A           BEQ      ??_DrawBitLine1BPP_7
   \   000000B0   020059E3           CMP      R9,#+2
   \   000000B4   0100000A           BEQ      ??_DrawBitLine1BPP_8
   \   000000B8   1A00003A           BCC      ??_DrawBitLine1BPP_9
   \   000000BC   420000EA           B        ??_DrawBitLine1BPP_6
    441                case 2:
    442                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_8:
   \   000000C0   01001EE3           TST      LR,#0x1
   \   000000C4   01B0A011           MOVNE    R11,R1
   \   000000C8   00B0A001           MOVEQ    R11,R0
   \   000000CC   01C04CE2           SUB      R12,R12,#+1
   \   000000D0   AEE0A0E1           LSR      LR,LR,#+1
   \   000000D4   00005CE3           CMP      R12,#+0
   \   000000D8   0300001A           BNE      ??_DrawBitLine1BPP_10
   \   000000DC   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   000000E0   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000000E4   0EE08CE1           ORR      LR,R12,LR
   \   000000E8   08C0A0E3           MOV      R12,#+8
    443                  Data &= 0xFFFFFF00;
    444                  Data |= Index >> 16;
    445                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_10:
   \   000000EC   FF50C5E3           BIC      R5,R5,#0xFF
   \   000000F0   2B5885E1           ORR      R5,R5,R11, LSR #+16
   \   000000F4   045187E7           STR      R5,[R7, +R4, LSL #+2]
    446                  Off--;
    447                  Data = READ_MEM32(pContext->VRAMAddr, Off);
    448                  Data &= 0x0000FFFF;
    449                  Data |= Index << 16;
   \   000000F8   005092E5           LDR      R5,[R2, #+0]
   \   000000FC   014044E2           SUB      R4,R4,#+1
   \   00000100   045185E0           ADD      R5,R5,R4, LSL #+2
   \   00000104   B050D5E1           LDRH     R5,[R5, #+0]
   \   00000108   0B78A0E1           LSL      R7,R11,#+16
    450                  xsize--;                  
   \   0000010C   018058E2           SUBS     R8,R8,#+1
   \   00000110   0558A0E1           LSL      R5,R5,#+16
   \   00000114   255887E1           ORR      R5,R7,R5, LSR #+16
    451                  if (!xsize) {
   \   00000118   0200001A           BNE      ??_DrawBitLine1BPP_9
    452                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);   
   \                     ??_DrawBitLine1BPP_11:
   \   0000011C   007092E5           LDR      R7,[R2, #+0]
   \   00000120   045187E7           STR      R5,[R7, +R4, LSL #+2]
    453                    break;
   \   00000124   280000EA           B        ??_DrawBitLine1BPP_6
    454                  }
    455                case 1:
    456                  GET_PIXEL_INDEX(Index);   
   \                     ??_DrawBitLine1BPP_9:
   \   00000128   01001EE3           TST      LR,#0x1
   \   0000012C   01B0A011           MOVNE    R11,R1
   \   00000130   00B0A001           MOVEQ    R11,R0
   \   00000134   01C04CE2           SUB      R12,R12,#+1
   \   00000138   AEE0A0E1           LSR      LR,LR,#+1
   \   0000013C   00005CE3           CMP      R12,#+0
   \   00000140   0300001A           BNE      ??_DrawBitLine1BPP_12
   \   00000144   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000148   03C0DCE7           LDRB     R12,[R12, +R3]
   \   0000014C   0EE08CE1           ORR      LR,R12,LR
   \   00000150   08C0A0E3           MOV      R12,#+8
    457                  Data &= 0xFFFF0000;
    458                  Data |= Index >> 8;
    459                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_12:
   \   00000154   2558A0E1           LSR      R5,R5,#+16
   \   00000158   2B74A0E1           LSR      R7,R11,#+8
   \   0000015C   055887E1           ORR      R5,R7,R5, LSL #+16
   \   00000160   007092E5           LDR      R7,[R2, #+0]
    460                  Off--;
    461                  Data = READ_MEM32(pContext->VRAMAddr, Off);
    462                  Data &= 0x00FFFFFF;
    463                  Data |= Index << 24;
    464                  xsize--;                  
   \   00000164   018058E2           SUBS     R8,R8,#+1
   \   00000168   045187E7           STR      R5,[R7, +R4, LSL #+2]
   \   0000016C   005092E5           LDR      R5,[R2, #+0]
   \   00000170   014044E2           SUB      R4,R4,#+1
   \   00000174   045195E7           LDR      R5,[R5, +R4, LSL #+2]
   \   00000178   0B7CA0E1           LSL      R7,R11,#+24
   \   0000017C   0554A0E1           LSL      R5,R5,#+8
   \   00000180   255487E1           ORR      R5,R7,R5, LSR #+8
    465                  if (!xsize) {
   \   00000184   E4FFFF0A           BEQ      ??_DrawBitLine1BPP_11
    466                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);   
    467                    break;
    468                  }
    469                case 0:
    470                  GET_PIXEL_INDEX(Index);   
   \                     ??_DrawBitLine1BPP_7:
   \   00000188   01001EE3           TST      LR,#0x1
   \   0000018C   01B0A011           MOVNE    R11,R1
   \   00000190   00B0A001           MOVEQ    R11,R0
   \   00000194   01C04CE2           SUB      R12,R12,#+1
   \   00000198   AEE0A0E1           LSR      LR,LR,#+1
   \   0000019C   00005CE3           CMP      R12,#+0
   \   000001A0   0300001A           BNE      ??_DrawBitLine1BPP_13
   \   000001A4   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   000001A8   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000001AC   0EE08CE1           ORR      LR,R12,LR
   \   000001B0   08C0A0E3           MOV      R12,#+8
    471                  Data &= 0xFF000000;
    472                  Data |= Index;
    473                  xsize--;                  
    474                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);     
   \                     ??_DrawBitLine1BPP_13:
   \   000001B4   007092E5           LDR      R7,[R2, #+0]
   \   000001B8   FF5405E2           AND      R5,R5,#0xFF000000
   \   000001BC   05508BE1           ORR      R5,R11,R5
   \   000001C0   045187E7           STR      R5,[R7, +R4, LSL #+2]
   \   000001C4   018048E2           SUB      R8,R8,#+1
    475                  Off--;
   \   000001C8   014044E2           SUB      R4,R4,#+1
    476                }
    477              }
    478              //
    479              // Complete triple DWORDS
    480              //
    481              if (xsize >= 4) {
   \                     ??_DrawBitLine1BPP_6:
   \   000001CC   040058E3           CMP      R8,#+4
   \   000001D0   3C0000BA           BLT      ??_DrawBitLine1BPP_14
    482                do {
    483                  /* OK */
    484                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_15:
   \   000001D4   01001EE3           TST      LR,#0x1
   \   000001D8   0150A011           MOVNE    R5,R1
   \   000001DC   0050A001           MOVEQ    R5,R0
   \   000001E0   01C04CE2           SUB      R12,R12,#+1
   \   000001E4   AEE0A0E1           LSR      LR,LR,#+1
   \   000001E8   00005CE3           CMP      R12,#+0
   \   000001EC   0300001A           BNE      ??_DrawBitLine1BPP_16
   \   000001F0   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   000001F4   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000001F8   0EE08CE1           ORR      LR,R12,LR
   \   000001FC   08C0A0E3           MOV      R12,#+8
    485                  Data0  = (Index <<  8);
   \                     ??_DrawBitLine1BPP_16:
   \   00000200   0574A0E1           LSL      R7,R5,#+8
    486                  GET_PIXEL_INDEX(Index);
   \   00000204   01001EE3           TST      LR,#0x1
   \   00000208   0150A011           MOVNE    R5,R1
   \   0000020C   0050A001           MOVEQ    R5,R0
   \   00000210   01C04CE2           SUB      R12,R12,#+1
   \   00000214   AEE0A0E1           LSR      LR,LR,#+1
   \   00000218   00005CE3           CMP      R12,#+0
   \   0000021C   0300001A           BNE      ??_DrawBitLine1BPP_17
   \   00000220   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000224   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000228   0EE08CE1           ORR      LR,R12,LR
   \   0000022C   08C0A0E3           MOV      R12,#+8
    487                  Data0 |= (Index >> 16);
   \                     ??_DrawBitLine1BPP_17:
   \   00000230   257887E1           ORR      R7,R7,R5, LSR #+16
    488                  Data1  = (Index << 16);
   \   00000234   0598A0E1           LSL      R9,R5,#+16
    489                  GET_PIXEL_INDEX(Index);
   \   00000238   01001EE3           TST      LR,#0x1
   \   0000023C   0150A011           MOVNE    R5,R1
   \   00000240   0050A001           MOVEQ    R5,R0
   \   00000244   01C04CE2           SUB      R12,R12,#+1
   \   00000248   AEE0A0E1           LSR      LR,LR,#+1
   \   0000024C   00005CE3           CMP      R12,#+0
   \   00000250   0300001A           BNE      ??_DrawBitLine1BPP_18
   \   00000254   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000258   03C0DCE7           LDRB     R12,[R12, +R3]
   \   0000025C   0EE08CE1           ORR      LR,R12,LR
   \   00000260   08C0A0E3           MOV      R12,#+8
    490                  Data1 |= (Index >>  8);
    491                  Data2  = (Index << 24);
    492                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_18:
   \   00000264   01001EE3           TST      LR,#0x1
   \   00000268   01B0A011           MOVNE    R11,R1
   \   0000026C   00B0A001           MOVEQ    R11,R0
   \   00000270   01C04CE2           SUB      R12,R12,#+1
   \   00000274   259489E1           ORR      R9,R9,R5, LSR #+8
   \   00000278   AEE0A0E1           LSR      LR,LR,#+1
   \   0000027C   00005CE3           CMP      R12,#+0
   \   00000280   0300001A           BNE      ??_DrawBitLine1BPP_19
   \   00000284   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000288   03C0DCE7           LDRB     R12,[R12, +R3]
   \   0000028C   0EE08CE1           ORR      LR,R12,LR
   \   00000290   08C0A0E3           MOV      R12,#+8
    493                  Data2 |= (Index      );
    494                  WRITE_MEM32(pContext->VRAMAddr, Off - 0, Data0);
   \                     ??_DrawBitLine1BPP_19:
   \   00000294   00A092E5           LDR      R10,[R2, #+0]
    495                  WRITE_MEM32(pContext->VRAMAddr, Off - 1, Data1);
    496                  WRITE_MEM32(pContext->VRAMAddr, Off - 2, Data2);
   \   00000298   055C8BE1           ORR      R5,R11,R5, LSL #+24
   \   0000029C   04718AE7           STR      R7,[R10, +R4, LSL #+2]
   \   000002A0   007092E5           LDR      R7,[R2, #+0]
    497                  Off -= 3;
    498                } while ((xsize -= 4) >= 4);
   \   000002A4   048048E2           SUB      R8,R8,#+4
   \   000002A8   047187E0           ADD      R7,R7,R4, LSL #+2
   \   000002AC   049007E5           STR      R9,[R7, #-4]
   \   000002B0   007092E5           LDR      R7,[R2, #+0]
   \   000002B4   040058E3           CMP      R8,#+4
   \   000002B8   047187E0           ADD      R7,R7,R4, LSL #+2
   \   000002BC   085007E5           STR      R5,[R7, #-8]
   \   000002C0   034044E2           SUB      R4,R4,#+3
   \   000002C4   C2FFFFAA           BGE      ??_DrawBitLine1BPP_15
    499              }
    500              //
    501              // Last triple DWORD
    502              //
    503              if (xsize) {
   \                     ??_DrawBitLine1BPP_14:
   \   000002C8   000058E3           CMP      R8,#+0
   \   000002CC   7B01000A           BEQ      ??_DrawBitLine1BPP_2
    504                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    505                Data &= 0x000000FF;
   \   000002D0   007092E5           LDR      R7,[R2, #+0]
    506                GET_PIXEL_INDEX(Index);
   \   000002D4   01001EE3           TST      LR,#0x1
   \   000002D8   01B0A011           MOVNE    R11,R1
   \   000002DC   00B0A001           MOVEQ    R11,R0
   \   000002E0   01C04CE2           SUB      R12,R12,#+1
   \   000002E4   0451D7E7           LDRB     R5,[R7, +R4, LSL #+2]
   \   000002E8   AEE0A0E1           LSR      LR,LR,#+1
   \   000002EC   00005CE3           CMP      R12,#+0
   \   000002F0   0300001A           BNE      ??_DrawBitLine1BPP_20
   \   000002F4   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   000002F8   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000002FC   0EE08CE1           ORR      LR,R12,LR
   \   00000300   08C0A0E3           MOV      R12,#+8
    507                Data |= (Index << 8);
   \                     ??_DrawBitLine1BPP_20:
   \   00000304   0B5485E1           ORR      R5,R5,R11, LSL #+8
    508                xsize--;
   \   00000308   018058E2           SUBS     R8,R8,#+1
    509                if (!xsize) {
   \   0000030C   0200001A           BNE      ??_DrawBitLine1BPP_21
    510                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_22:
   \   00000310   000092E5           LDR      R0,[R2, #+0]
   \   00000314   045180E7           STR      R5,[R0, +R4, LSL #+2]
    511                  return;
   \   00000318   680100EA           B        ??_DrawBitLine1BPP_2
    512                }
    513                Data &= 0xFFFFFF00;
    514                GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_21:
   \   0000031C   01001EE3           TST      LR,#0x1
   \   00000320   01B0A011           MOVNE    R11,R1
   \   00000324   00B0A001           MOVEQ    R11,R0
   \   00000328   01C05CE2           SUBS     R12,R12,#+1
   \   0000032C   01C0D605           LDRBEQ   R12,[R6, #+1]
   \   00000330   AEE0A0E1           LSR      LR,LR,#+1
   \   00000334   FF50C5E3           BIC      R5,R5,#0xFF
   \   00000338   0330DC07           LDRBEQ   R3,[R12, +R3]
   \   0000033C   0EE08301           ORREQ    LR,R3,LR
    515                Data |= Index >> 16;
    516                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000340   2B3885E1           ORR      R3,R5,R11, LSR #+16
   \   00000344   043187E7           STR      R3,[R7, +R4, LSL #+2]
    517                Off--;
    518                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    519                Data &= 0x0000FFFF;
    520                Data |= Index << 16;
   \   00000348   003092E5           LDR      R3,[R2, #+0]
   \   0000034C   014044E2           SUB      R4,R4,#+1
   \   00000350   04C183E0           ADD      R12,R3,R4, LSL #+2
   \   00000354   B0C0DCE1           LDRH     R12,[R12, #+0]
   \   00000358   0B58A0E1           LSL      R5,R11,#+16
   \   0000035C   0CC8A0E1           LSL      R12,R12,#+16
   \   00000360   2C5885E1           ORR      R5,R5,R12, LSR #+16
    521                xsize--;
    522                if (!xsize) {
   \   00000364   01C058E2           SUBS     R12,R8,#+1
   \   00000368   E8FFFF0A           BEQ      ??_DrawBitLine1BPP_22
    523                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    524                  return;
    525                }
    526                Data &= 0xFFFF0000;
   \   0000036C   25C8A0E1           LSR      R12,R5,#+16
    527                GET_PIXEL_INDEX(Index);
   \   00000370   01001EE3           TST      LR,#0x1
   \   00000374   0C58A0E1           LSL      R5,R12,#+16
   \   00000378   01B0A011           MOVNE    R11,R1
   \   0000037C   00B0A001           MOVEQ    R11,R0
    528                Data |= Index >> 8;
    529                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000380   2B0485E1           ORR      R0,R5,R11, LSR #+8
   \   00000384   040183E7           STR      R0,[R3, +R4, LSL #+2]
    530                Off--;
    531                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    532                Data &= 0x00FFFFFF;
    533                Data |= Index << 24;
    534                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_23:
   \   00000388   000092E5           LDR      R0,[R2, #+0]
   \   0000038C   014044E2           SUB      R4,R4,#+1
   \   00000390   041190E7           LDR      R1,[R0, +R4, LSL #+2]
   \   00000394   0B2CA0E1           LSL      R2,R11,#+24
   \   00000398   0114A0E1           LSL      R1,R1,#+8
   \   0000039C   211482E1           ORR      R1,R2,R1, LSR #+8
   \   000003A0   041180E7           STR      R1,[R0, +R4, LSL #+2]
   \   000003A4   450100EA           B        ??_DrawBitLine1BPP_2
    535              }
    536              break;
    537            case LCD_DRAWMODE_TRANS:
    538              //
    539              // Mirror x
    540              //
    541              x = (pContext->vxSize - 1 - x);
   \                     ??_DrawBitLine1BPP_5:
   \   000003A8   0C3092E5           LDR      R3,[R2, #+12]
    542              PixelCnt = 8 - Diff;
    543              Pixels   = LCD_aMirror[*p] >> Diff;
   \   000003AC   00E0D6E5           LDRB     LR,[R6, #+0]
   \   000003B0   013043E2           SUB      R3,R3,#+1
   \   000003B4   099043E0           SUB      R9,R3,R9
   \   000003B8   ........           LDR      R3,??DataTable14
    544              Off      = XY2OFF32(pContext->vxSizePhys, x, y);
   \   000003BC   144092E5           LDR      R4,[R2, #+20]
   \   000003C0   03E0DEE7           LDRB     LR,[LR, +R3]
   \   000003C4   08C067E2           RSB      R12,R7,#+8
   \   000003C8   844084E0           ADD      R4,R4,R4, LSL #+1
   \   000003CC   5EE7A0E1           ASR      LR,LR,R7
   \   000003D0   897089E0           ADD      R7,R9,R9, LSL #+1
   \   000003D4   947525E0           MLA      R5,R4,R5,R7
    545              //
    546              // First triple DWORD
    547              //
    548              Odd = x & 3;
   \   000003D8   039009E2           AND      R9,R9,#0x3
   \   000003DC   2541A0E1           LSR      R4,R5,#+2
    549              if (Odd != 3) {
   \   000003E0   030059E3           CMP      R9,#+3
   \   000003E4   5F00000A           BEQ      ??_DrawBitLine1BPP_24
    550                if (Odd != 0) {
   \   000003E8   000059E3           CMP      R9,#+0
    551                  Off++;
    552                }
    553                Data = READ_MEM32(pContext->VRAMAddr, Off);
   \   000003EC   007092E5           LDR      R7,[R2, #+0]
   \   000003F0   01408412           ADDNE    R4,R4,#+1
   \   000003F4   045197E7           LDR      R5,[R7, +R4, LSL #+2]
    554                switch (Odd) {
   \   000003F8   4800000A           BEQ      ??_DrawBitLine1BPP_25
   \   000003FC   020059E3           CMP      R9,#+2
   \   00000400   0100000A           BEQ      ??_DrawBitLine1BPP_26
   \   00000404   2200003A           BCC      ??_DrawBitLine1BPP_27
   \   00000408   560000EA           B        ??_DrawBitLine1BPP_24
    555                case 2:
    556                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_26:
   \   0000040C   01A01EE2           ANDS     R10,LR,#0x1
   \   00000410   01B0A011           MOVNE    R11,R1
   \   00000414   00B0A001           MOVEQ    R11,R0
   \   00000418   01C04CE2           SUB      R12,R12,#+1
   \   0000041C   AEE0A0E1           LSR      LR,LR,#+1
   \   00000420   00005CE3           CMP      R12,#+0
   \   00000424   0300001A           BNE      ??_DrawBitLine1BPP_28
   \   00000428   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   0000042C   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000430   0EE08CE1           ORR      LR,R12,LR
   \   00000434   08C0A0E3           MOV      R12,#+8
    557                  if (Bit) {
   \                     ??_DrawBitLine1BPP_28:
   \   00000438   018048E2           SUB      R8,R8,#+1
   \   0000043C   019044E2           SUB      R9,R4,#+1
   \   00000440   00005AE3           CMP      R10,#+0
   \   00000444   0E00000A           BEQ      ??_DrawBitLine1BPP_29
    558                    Data &= 0xFFFFFF00;
    559                    Data |= Index >> 16;
    560                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000448   FF50C5E3           BIC      R5,R5,#0xFF
   \   0000044C   2B5885E1           ORR      R5,R5,R11, LSR #+16
   \   00000450   045187E7           STR      R5,[R7, +R4, LSL #+2]
    561                    Off--;
    562                    Data = READ_MEM32(pContext->VRAMAddr, Off);
    563                    Data &= 0x0000FFFF;
    564                    Data |= Index << 16;
   \   00000454   005092E5           LDR      R5,[R2, #+0]
   \   00000458   0940A0E1           MOV      R4,R9
   \   0000045C   045185E0           ADD      R5,R5,R4, LSL #+2
   \   00000460   B050D5E1           LDRH     R5,[R5, #+0]
   \   00000464   0B78A0E1           LSL      R7,R11,#+16
    565                    xsize--;                  
    566                    if (!xsize) {
   \   00000468   000058E3           CMP      R8,#+0
   \   0000046C   0558A0E1           LSL      R5,R5,#+16
   \   00000470   255887E1           ORR      R5,R7,R5, LSR #+16
   \   00000474   0600001A           BNE      ??_DrawBitLine1BPP_27
    567                      WRITE_MEM32(pContext->VRAMAddr, Off, Data);   
   \                     ??_DrawBitLine1BPP_30:
   \   00000478   007092E5           LDR      R7,[R2, #+0]
   \   0000047C   045187E7           STR      R5,[R7, +R4, LSL #+2]
    568                      break;
   \   00000480   380000EA           B        ??_DrawBitLine1BPP_24
    569                    }
    570                  } else {
    571                    Off--;
   \                     ??_DrawBitLine1BPP_29:
   \   00000484   0940A0E1           MOV      R4,R9
    572                    xsize--;
    573                    if (!xsize) {
   \   00000488   000058E3           CMP      R8,#+0
   \   0000048C   0B01000A           BEQ      ??_DrawBitLine1BPP_2
    574                      break;
    575                    }
    576                    Data = READ_MEM32(pContext->VRAMAddr, Off);
   \   00000490   045197E7           LDR      R5,[R7, +R4, LSL #+2]
    577                  }
    578                case 1:
    579                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_27:
   \   00000494   01A01EE2           ANDS     R10,LR,#0x1
   \   00000498   01B0A011           MOVNE    R11,R1
   \   0000049C   00B0A001           MOVEQ    R11,R0
   \   000004A0   01C04CE2           SUB      R12,R12,#+1
   \   000004A4   AEE0A0E1           LSR      LR,LR,#+1
   \   000004A8   00005CE3           CMP      R12,#+0
   \   000004AC   0300001A           BNE      ??_DrawBitLine1BPP_31
   \   000004B0   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   000004B4   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000004B8   0EE08CE1           ORR      LR,R12,LR
   \   000004BC   08C0A0E3           MOV      R12,#+8
    580                  if (Bit) {
   \                     ??_DrawBitLine1BPP_31:
   \   000004C0   007092E5           LDR      R7,[R2, #+0]
   \   000004C4   018048E2           SUB      R8,R8,#+1
   \   000004C8   019044E2           SUB      R9,R4,#+1
   \   000004CC   00005AE3           CMP      R10,#+0
   \   000004D0   0C00000A           BEQ      ??_DrawBitLine1BPP_32
    581                    Data &= 0xFFFF0000;
    582                    Data |= Index >> 8;
    583                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000004D4   2558A0E1           LSR      R5,R5,#+16
   \   000004D8   2BA4A0E1           LSR      R10,R11,#+8
   \   000004DC   05588AE1           ORR      R5,R10,R5, LSL #+16
   \   000004E0   045187E7           STR      R5,[R7, +R4, LSL #+2]
    584                    Off--;
    585                    Data = READ_MEM32(pContext->VRAMAddr, Off);
    586                    Data &= 0x00FFFFFF;
    587                    Data |= Index << 24;
   \   000004E4   005092E5           LDR      R5,[R2, #+0]
   \   000004E8   0940A0E1           MOV      R4,R9
   \   000004EC   045195E7           LDR      R5,[R5, +R4, LSL #+2]
   \   000004F0   0B7CA0E1           LSL      R7,R11,#+24
   \   000004F4   0554A0E1           LSL      R5,R5,#+8
   \   000004F8   255487E1           ORR      R5,R7,R5, LSR #+8
    588                    xsize--;                  
    589                    if (!xsize) {
   \   000004FC   000058E3           CMP      R8,#+0
   \   00000500   0600001A           BNE      ??_DrawBitLine1BPP_25
   \   00000504   DBFFFFEA           B        ??_DrawBitLine1BPP_30
    590                      WRITE_MEM32(pContext->VRAMAddr, Off, Data);   
    591                      break;
    592                    }
    593                  } else {
    594                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_32:
   \   00000508   045187E7           STR      R5,[R7, +R4, LSL #+2]
    595                    Off--;
   \   0000050C   0940A0E1           MOV      R4,R9
    596                    xsize--;
    597                    if (!xsize) {
   \   00000510   000058E3           CMP      R8,#+0
   \   00000514   E900000A           BEQ      ??_DrawBitLine1BPP_2
    598                      break;
    599                    }
    600                    Data = READ_MEM32(pContext->VRAMAddr, Off);
   \   00000518   005092E5           LDR      R5,[R2, #+0]
   \   0000051C   045195E7           LDR      R5,[R5, +R4, LSL #+2]
    601                  }
    602                case 0:
    603                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_25:
   \   00000520   01A01EE2           ANDS     R10,LR,#0x1
   \   00000524   01B0A011           MOVNE    R11,R1
   \   00000528   00B0A001           MOVEQ    R11,R0
   \   0000052C   01C04CE2           SUB      R12,R12,#+1
   \   00000530   AEE0A0E1           LSR      LR,LR,#+1
   \   00000534   00005CE3           CMP      R12,#+0
   \   00000538   0300001A           BNE      ??_DrawBitLine1BPP_33
   \   0000053C   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000540   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000544   0EE08CE1           ORR      LR,R12,LR
   \   00000548   08C0A0E3           MOV      R12,#+8
    604                  if (Bit) {
   \                     ??_DrawBitLine1BPP_33:
   \   0000054C   00005AE3           CMP      R10,#+0
    605                    Data &= 0xFF000000;
    606                    Data |= Index;
   \   00000550   FF540512           ANDNE    R5,R5,#0xFF000000
    607                  }
    608                  xsize--;                  
    609                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);     
   \   00000554   007092E5           LDR      R7,[R2, #+0]
   \   00000558   05508B11           ORRNE    R5,R11,R5
   \   0000055C   045187E7           STR      R5,[R7, +R4, LSL #+2]
   \   00000560   018048E2           SUB      R8,R8,#+1
    610                  Off--;
   \   00000564   014044E2           SUB      R4,R4,#+1
    611                }
    612              }
    613              //
    614              // Complete triple DWORDS
    615              //
    616              if (xsize >= 4) {
   \                     ??_DrawBitLine1BPP_24:
   \   00000568   040058E3           CMP      R8,#+4
   \   0000056C   590000BA           BLT      ??_DrawBitLine1BPP_34
    617                do {
    618                  Data0  = READ_MEM32(pContext->VRAMAddr, Off - 0);
   \                     ??_DrawBitLine1BPP_35:
   \   00000570   007092E5           LDR      R7,[R2, #+0]
   \   00000574   04708DE5           STR      R7,[SP, #+4]
   \   00000578   0750A0E1           MOV      R5,R7
   \   0000057C   047195E7           LDR      R7,[R5, +R4, LSL #+2]
    619                  Data1  = READ_MEM32(pContext->VRAMAddr, Off - 1);
   \   00000580   045185E0           ADD      R5,R5,R4, LSL #+2
   \   00000584   049015E5           LDR      R9,[R5, #-4]
    620                  Data2  = READ_MEM32(pContext->VRAMAddr, Off - 2);
   \   00000588   085015E5           LDR      R5,[R5, #-8]
    621                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \   0000058C   01A01EE2           ANDS     R10,LR,#0x1
   \   00000590   00A08DE5           STR      R10,[SP, #+0]
   \   00000594   01B0A011           MOVNE    R11,R1
   \   00000598   00B0A001           MOVEQ    R11,R0
   \   0000059C   01A04CE2           SUB      R10,R12,#+1
   \   000005A0   AEE0A0E1           LSR      LR,LR,#+1
   \   000005A4   00005AE3           CMP      R10,#+0
   \   000005A8   0300001A           BNE      ??_DrawBitLine1BPP_36
   \   000005AC   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   000005B0   08A0A0E3           MOV      R10,#+8
   \   000005B4   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000005B8   0EE08CE1           ORR      LR,R12,LR
    622                  if (Bit) {
   \                     ??_DrawBitLine1BPP_36:
   \   000005BC   00C09DE5           LDR      R12,[SP, #+0]
   \   000005C0   00005CE3           CMP      R12,#+0
    623                    Data0 &= 0x000000FF;
    624                    Data0 |= (Index <<  8);
   \   000005C4   FFC00712           ANDNE    R12,R7,#0xFF
   \   000005C8   0B748C11           ORRNE    R7,R12,R11, LSL #+8
    625                  }
    626                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \   000005CC   01C01EE2           ANDS     R12,LR,#0x1
   \   000005D0   00C08DE5           STR      R12,[SP, #+0]
   \   000005D4   01C0A011           MOVNE    R12,R1
   \   000005D8   00C0A001           MOVEQ    R12,R0
   \   000005DC   01B04AE2           SUB      R11,R10,#+1
   \   000005E0   AEE0A0E1           LSR      LR,LR,#+1
   \   000005E4   00005BE3           CMP      R11,#+0
   \   000005E8   0300001A           BNE      ??_DrawBitLine1BPP_37
   \   000005EC   01A0F6E5           LDRB     R10,[R6, #+1]!
   \   000005F0   08B0A0E3           MOV      R11,#+8
   \   000005F4   03A0DAE7           LDRB     R10,[R10, +R3]
   \   000005F8   0EE08AE1           ORR      LR,R10,LR
    627                  if (Bit) {
   \                     ??_DrawBitLine1BPP_37:
   \   000005FC   00A09DE5           LDR      R10,[SP, #+0]
   \   00000600   00005AE3           CMP      R10,#+0
   \   00000604   0400000A           BEQ      ??_DrawBitLine1BPP_38
    628                    Data0 &= 0xFFFFFF00;
    629                    Data0 |= (Index >> 16);
   \   00000608   FF70C7E3           BIC      R7,R7,#0xFF
   \   0000060C   2C7887E1           ORR      R7,R7,R12, LSR #+16
    630                    Data1 &= 0x0000FFFF;
    631                    Data1 |= (Index << 16);
   \   00000610   0998A0E1           LSL      R9,R9,#+16
   \   00000614   0CC8A0E1           LSL      R12,R12,#+16
   \   00000618   29988CE1           ORR      R9,R12,R9, LSR #+16
    632                  }
    633                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_38:
   \   0000061C   01C01EE2           ANDS     R12,LR,#0x1
   \   00000620   00C08DE5           STR      R12,[SP, #+0]
   \   00000624   01A0A011           MOVNE    R10,R1
   \   00000628   00A0A001           MOVEQ    R10,R0
   \   0000062C   01C04BE2           SUB      R12,R11,#+1
   \   00000630   AEE0A0E1           LSR      LR,LR,#+1
   \   00000634   00005CE3           CMP      R12,#+0
   \   00000638   0300001A           BNE      ??_DrawBitLine1BPP_39
   \   0000063C   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000640   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000644   0EE08CE1           ORR      LR,R12,LR
   \   00000648   08C0A0E3           MOV      R12,#+8
    634                  if (Bit) {
   \                     ??_DrawBitLine1BPP_39:
   \   0000064C   00B09DE5           LDR      R11,[SP, #+0]
   \   00000650   00005BE3           CMP      R11,#+0
   \   00000654   0500000A           BEQ      ??_DrawBitLine1BPP_40
    635                    Data1 &= 0xFFFF0000;
    636                    Data1 |= (Index >>  8);
   \   00000658   2AB4A0E1           LSR      R11,R10,#+8
   \   0000065C   2998A0E1           LSR      R9,R9,#+16
    637                    Data2 &= 0x00FFFFFF;
    638                    Data2 |= (Index << 24);
   \   00000660   0554A0E1           LSL      R5,R5,#+8
   \   00000664   0AACA0E1           LSL      R10,R10,#+24
   \   00000668   09988BE1           ORR      R9,R11,R9, LSL #+16
   \   0000066C   25548AE1           ORR      R5,R10,R5, LSR #+8
    639                  }
    640                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_40:
   \   00000670   01A01EE2           ANDS     R10,LR,#0x1
   \   00000674   01B0A011           MOVNE    R11,R1
   \   00000678   00B0A001           MOVEQ    R11,R0
   \   0000067C   01C04CE2           SUB      R12,R12,#+1
   \   00000680   AEE0A0E1           LSR      LR,LR,#+1
   \   00000684   00005CE3           CMP      R12,#+0
   \   00000688   0300001A           BNE      ??_DrawBitLine1BPP_41
   \   0000068C   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000690   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000694   0EE08CE1           ORR      LR,R12,LR
   \   00000698   08C0A0E3           MOV      R12,#+8
    641                  if (Bit) {
   \                     ??_DrawBitLine1BPP_41:
   \   0000069C   00005AE3           CMP      R10,#+0
    642                    Data2 &= 0xFF000000;
    643                    Data2 |= (Index      );
    644                  }
    645                  WRITE_MEM32(pContext->VRAMAddr, Off - 0, Data0);
   \   000006A0   04A09DE5           LDR      R10,[SP, #+4]
   \   000006A4   FF540512           ANDNE    R5,R5,#0xFF000000
   \   000006A8   04718AE7           STR      R7,[R10, +R4, LSL #+2]
    646                  WRITE_MEM32(pContext->VRAMAddr, Off - 1, Data1);
   \   000006AC   007092E5           LDR      R7,[R2, #+0]
   \   000006B0   05508B11           ORRNE    R5,R11,R5
   \   000006B4   047187E0           ADD      R7,R7,R4, LSL #+2
   \   000006B8   049007E5           STR      R9,[R7, #-4]
    647                  WRITE_MEM32(pContext->VRAMAddr, Off - 2, Data2);
   \   000006BC   007092E5           LDR      R7,[R2, #+0]
    648                  Off -= 3;
    649                } while ((xsize -= 4) >= 4);
   \   000006C0   048048E2           SUB      R8,R8,#+4
   \   000006C4   047187E0           ADD      R7,R7,R4, LSL #+2
   \   000006C8   085007E5           STR      R5,[R7, #-8]
   \   000006CC   034044E2           SUB      R4,R4,#+3
   \   000006D0   040058E3           CMP      R8,#+4
   \   000006D4   A5FFFFAA           BGE      ??_DrawBitLine1BPP_35
    650              }
    651              //
    652              // Last triple DWORD
    653              //
    654              if (xsize) {
   \                     ??_DrawBitLine1BPP_34:
   \   000006D8   000058E3           CMP      R8,#+0
   \   000006DC   7700000A           BEQ      ??_DrawBitLine1BPP_2
    655                Data  = READ_MEM32(pContext->VRAMAddr, Off);
   \   000006E0   007092E5           LDR      R7,[R2, #+0]
    656                GET_PIXEL_INDEX_TRANS(Index, Bit);
   \   000006E4   01A01EE2           ANDS     R10,LR,#0x1
   \   000006E8   01B0A011           MOVNE    R11,R1
   \   000006EC   00B0A001           MOVEQ    R11,R0
   \   000006F0   01C04CE2           SUB      R12,R12,#+1
   \   000006F4   045197E7           LDR      R5,[R7, +R4, LSL #+2]
   \   000006F8   AEE0A0E1           LSR      LR,LR,#+1
   \   000006FC   00005CE3           CMP      R12,#+0
   \   00000700   0300001A           BNE      ??_DrawBitLine1BPP_42
   \   00000704   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000708   03C0DCE7           LDRB     R12,[R12, +R3]
   \   0000070C   0EE08CE1           ORR      LR,R12,LR
   \   00000710   08C0A0E3           MOV      R12,#+8
    657                if (Bit) {
   \                     ??_DrawBitLine1BPP_42:
   \   00000714   018048E2           SUB      R8,R8,#+1
   \   00000718   00005AE3           CMP      R10,#+0
   \   0000071C   0400000A           BEQ      ??_DrawBitLine1BPP_43
    658                  Data &= 0x000000FF;
    659                  Data |= (Index << 8);
   \   00000720   FF5005E2           AND      R5,R5,#0xFF
   \   00000724   0B5485E1           ORR      R5,R5,R11, LSL #+8
    660                  xsize--;
    661                  if (!xsize) {
   \   00000728   000058E3           CMP      R8,#+0
   \   0000072C   0200001A           BNE      ??_DrawBitLine1BPP_44
   \   00000730   F6FEFFEA           B        ??_DrawBitLine1BPP_22
    662                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    663                    return;
    664                  }
    665                } else {
    666                  xsize--;
    667                  if (!xsize) {
   \                     ??_DrawBitLine1BPP_43:
   \   00000734   000058E3           CMP      R8,#+0
   \   00000738   6000000A           BEQ      ??_DrawBitLine1BPP_2
    668                    return;
    669                  }
    670                }
    671                GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_44:
   \   0000073C   01A01EE2           ANDS     R10,LR,#0x1
   \   00000740   01B0A011           MOVNE    R11,R1
   \   00000744   00B0A001           MOVEQ    R11,R0
   \   00000748   01C05CE2           SUBS     R12,R12,#+1
   \   0000074C   01C0D605           LDRBEQ   R12,[R6, #+1]
   \   00000750   AEE0A0E1           LSR      LR,LR,#+1
   \   00000754   0330DC07           LDRBEQ   R3,[R12, +R3]
    672                if (Bit) {
   \   00000758   01C044E2           SUB      R12,R4,#+1
   \   0000075C   0EE08301           ORREQ    LR,R3,LR
   \   00000760   013048E2           SUB      R3,R8,#+1
   \   00000764   00005AE3           CMP      R10,#+0
   \   00000768   0C00000A           BEQ      ??_DrawBitLine1BPP_45
    673                  Data &= 0xFFFFFF00;
    674                  Data |= Index >> 16;
    675                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   0000076C   FF50C5E3           BIC      R5,R5,#0xFF
   \   00000770   2B5885E1           ORR      R5,R5,R11, LSR #+16
   \   00000774   045187E7           STR      R5,[R7, +R4, LSL #+2]
    676                  Off--;
   \   00000778   0C40A0E1           MOV      R4,R12
    677                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    678                  Data &= 0x0000FFFF;
    679                  Data |= Index << 16;
   \   0000077C   00C092E5           LDR      R12,[R2, #+0]
   \   00000780   0B58A0E1           LSL      R5,R11,#+16
   \   00000784   04C18CE0           ADD      R12,R12,R4, LSL #+2
   \   00000788   B0C0DCE1           LDRH     R12,[R12, #+0]
    680                  xsize--;
    681                  if (!xsize) {
   \   0000078C   000053E3           CMP      R3,#+0
   \   00000790   0CC8A0E1           LSL      R12,R12,#+16
   \   00000794   2C5885E1           ORR      R5,R5,R12, LSR #+16
   \   00000798   0600001A           BNE      ??_DrawBitLine1BPP_46
   \   0000079C   DBFEFFEA           B        ??_DrawBitLine1BPP_22
    682                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    683                    return;
    684                  }
    685                } else {
    686                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_45:
   \   000007A0   045187E7           STR      R5,[R7, +R4, LSL #+2]
    687                  Off--;
   \   000007A4   0C40A0E1           MOV      R4,R12
    688                  xsize--;
    689                  if (!xsize) {
   \   000007A8   000053E3           CMP      R3,#+0
   \   000007AC   4300000A           BEQ      ??_DrawBitLine1BPP_2
    690                    return;
    691                  }
    692                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
   \   000007B0   003092E5           LDR      R3,[R2, #+0]
   \   000007B4   045193E7           LDR      R5,[R3, +R4, LSL #+2]
    693                }
    694                GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_46:
   \   000007B8   01A01EE2           ANDS     R10,LR,#0x1
   \   000007BC   01B0A011           MOVNE    R11,R1
   \   000007C0   00B0A001           MOVEQ    R11,R0
    695                if (Bit) {
   \   000007C4   D1FEFF0A           BEQ      ??_DrawBitLine1BPP_22
    696                  Data &= 0xFFFF0000;
    697                  Data |= Index >> 8;
    698                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000007C8   2508A0E1           LSR      R0,R5,#+16
   \   000007CC   2B14A0E1           LSR      R1,R11,#+8
   \   000007D0   000881E1           ORR      R0,R1,R0, LSL #+16
   \   000007D4   001092E5           LDR      R1,[R2, #+0]
   \   000007D8   040181E7           STR      R0,[R1, +R4, LSL #+2]
    699                  Off--;
   \   000007DC   E9FEFFEA           B        ??_DrawBitLine1BPP_23
    700                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    701                  Data &= 0x00FFFFFF;
    702                  Data |= Index << 24;
    703                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    704                } else {
    705                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    706                }
    707              }
    708              break;
    709            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    710            case LCD_DRAWMODE_XOR:
    711              IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \                     ??_DrawBitLine1BPP_4:
   \   000007E0   100094E5           LDR      R0,[R4, #+16]
   \   000007E4   080090E5           LDR      R0,[R0, #+8]
   \   000007E8   30FF2FE1           BLX      R0
   \   000007EC   00A0A0E1           MOV      R10,R0
   \   000007F0   80B0A0E3           MOV      R11,#+128
    712              do {
    713                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_47:
   \   000007F4   0000D6E5           LDRB     R0,[R6, #+0]
   \   000007F8   5B0710E1           TST      R0,R11, ASR R7
   \   000007FC   2800000A           BEQ      ??_DrawBitLine1BPP_48
    714                  int Pixel = _GetPixelIndex(pDevice, x, y);
   \   00000800   081094E5           LDR      R1,[R4, #+8]
   \   00000804   143091E5           LDR      R3,[R1, #+20]
   \   00000808   0C2091E5           LDR      R2,[R1, #+12]
   \   0000080C   93050CE0           MUL      R12,R3,R5
   \   00000810   012042E2           SUB      R2,R2,#+1
   \   00000814   092042E0           SUB      R2,R2,R9
   \   00000818   8C308CE0           ADD      R3,R12,R12, LSL #+1
   \   0000081C   82C082E0           ADD      R12,R2,R2, LSL #+1
   \   00000820   03308CE0           ADD      R3,R12,R3
   \   00000824   001091E5           LDR      R1,[R1, #+0]
   \   00000828   2331A0E1           LSR      R3,R3,#+2
   \   0000082C   032002E2           AND      R2,R2,#0x3
   \   00000830   03C191E7           LDR      R12,[R1, +R3, LSL #+2]
   \   00000834   030052E3           CMP      R2,#+3
   \   00000838   02F18F90           ADDLS    PC,PC,R2, LSL #+2
   \                     ??_DrawBitLine1BPP_1:
   \   0000083C   1300008A           BHI      ??_DrawBitLine1BPP_49
   \   00000840   100000EA           B        ??_DrawBitLine1BPP_50
   \   00000844   080000EA           B        ??_DrawBitLine1BPP_51
   \   00000848   020000EA           B        ??_DrawBitLine1BPP_52
   \   0000084C   FFFFFFEA           B        ??_DrawBitLine1BPP_53
   \                     ??_DrawBitLine1BPP_53:
   \   00000850   2C04A0E1           LSR      R0,R12,#+8
   \   00000854   0D0000EA           B        ??_DrawBitLine1BPP_49
   \                     ??_DrawBitLine1BPP_52:
   \   00000858   030181E0           ADD      R0,R1,R3, LSL #+2
   \   0000085C   0400D0E5           LDRB     R0,[R0, #+4]
   \   00000860   0008A0E1           LSL      R0,R0,#+16
   \   00000864   2C0880E1           ORR      R0,R0,R12, LSR #+16
   \   00000868   080000EA           B        ??_DrawBitLine1BPP_49
   \                     ??_DrawBitLine1BPP_51:
   \   0000086C   030181E0           ADD      R0,R1,R3, LSL #+2
   \   00000870   B400D0E1           LDRH     R0,[R0, #+4]
   \   00000874   0008A0E1           LSL      R0,R0,#+16
   \   00000878   2008A0E1           LSR      R0,R0,#+16
   \   0000087C   0004A0E1           LSL      R0,R0,#+8
   \   00000880   2C0C80E1           ORR      R0,R0,R12, LSR #+24
   \   00000884   010000EA           B        ??_DrawBitLine1BPP_49
   \                     ??_DrawBitLine1BPP_50:
   \   00000888   0C04A0E1           LSL      R0,R12,#+8
   \   0000088C   2004A0E1           LSR      R0,R0,#+8
    715                  _SetPixelIndex(pDevice, x, y, Pixel ^ IndexMask);
   \                     ??_DrawBitLine1BPP_49:
   \   00000890   00302AE0           EOR      R3,R10,R0
   \   00000894   0520A0E1           MOV      R2,R5
   \   00000898   0910A0E1           MOV      R1,R9
   \   0000089C   0400A0E1           MOV      R0,R4
   \   000008A0   ........           BL       _SetPixelIndex
    716                }
    717                x++;
    718                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_48:
   \   000008A4   017087E2           ADD      R7,R7,#+1
   \   000008A8   080057E3           CMP      R7,#+8
    719                  Diff = 0;
   \   000008AC   0070A003           MOVEQ    R7,#+0
    720                  p++;
   \   000008B0   01608602           ADDEQ    R6,R6,#+1
   \   000008B4   019089E2           ADD      R9,R9,#+1
    721                }
    722              } while (--xsize);
   \   000008B8   018058E2           SUBS     R8,R8,#+1
   \   000008BC   CCFFFF1A           BNE      ??_DrawBitLine1BPP_47
   \                     ??_DrawBitLine1BPP_2:
   \   000008C0   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   000008C4   F08FBDE8           POP      {R4-R11,PC}      ;; return
    723              break;
    724            }
    725            #undef GET_PIXEL_INDEX
    726            #undef GET_PIXEL_INDEX_TRANS
    727          }
    728          
    729          /*********************************************************************
    730          *
    731          *       Draw Bitmap 2 BPP
    732          */

   \                                 In section .text, align 4, keep-with-next
    733          static void  _DrawBitLine2BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine2BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    734            LCD_PIXELINDEX Pixels, PixelIndex;
    735            int CurrentPixel, Shift, Index;
    736          
    737            Pixels = *p;
    738            CurrentPixel = Diff;
    739            x += Diff;
    740            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000008   ........           LDR      R0,??DataTable13
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   28409DE5           LDR      R4,[SP, #+40]
   \   00000018   0370A0E1           MOV      R7,R3
   \   0000001C   0260A0E1           MOV      R6,R2
   \   00000020   2C809DE5           LDR      R8,[SP, #+44]
   \   00000024   0090D7E5           LDRB     R9,[R7, #+0]
   \   00000028   01A084E0           ADD      R10,R4,R1
   \   0000002C   030010E2           ANDS     R0,R0,#0x3
   \   00000030   0200000A           BEQ      ??_DrawBitLine2BPP_0
   \   00000034   020050E2           SUBS     R0,R0,#+2
   \   00000038   2A00000A           BEQ      ??_DrawBitLine2BPP_1
   \   0000003C   540000EA           B        ??_DrawBitLine2BPP_2
    741            case 0:
    742              if (pTrans) {
   \                     ??_DrawBitLine2BPP_0:
   \   00000040   30009DE5           LDR      R0,[SP, #+48]
   \   00000044   C0B0A0E3           MOV      R11,#+192
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   1300000A           BEQ      ??_DrawBitLine2BPP_3
    743                do {
    744                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_4:
   \   00000050   030064E2           RSB      R0,R4,#+3
   \   00000054   8000A0E1           LSL      R0,R0,#+1
    745                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    746                  PixelIndex = *(pTrans + Index);
    747                  _SetPixelIndex(pDevice, x++, y, PixelIndex);
   \   00000058   0010A0E1           MOV      R1,R0
   \   0000005C   061061E2           RSB      R1,R1,#+6
   \   00000060   5B1109E0           AND      R1,R9,R11, ASR R1
   \   00000064   3100A0E1           LSR      R0,R1,R0
   \   00000068   30109DE5           LDR      R1,[SP, #+48]
   \   0000006C   0620A0E1           MOV      R2,R6
   \   00000070   003191E7           LDR      R3,[R1, +R0, LSL #+2]
   \   00000074   0A10A0E1           MOV      R1,R10
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           BL       _SetPixelIndex
    748                  if (++CurrentPixel == 4) {
   \   00000080   014084E2           ADD      R4,R4,#+1
   \   00000084   040054E3           CMP      R4,#+4
    749                    CurrentPixel = 0;
   \   00000088   0040A003           MOVEQ    R4,#+0
    750                    Pixels = *(++p);
   \   0000008C   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   00000090   01A08AE2           ADD      R10,R10,#+1
    751                  }
    752                } while (--xsize);
   \   00000094   018058E2           SUBS     R8,R8,#+1
   \   00000098   ECFFFF1A           BNE      ??_DrawBitLine2BPP_4
   \   0000009C   3C0000EA           B        ??_DrawBitLine2BPP_2
    753              } else {
    754                do {
    755                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_3:
   \   000000A0   030064E2           RSB      R0,R4,#+3
   \   000000A4   8000A0E1           LSL      R0,R0,#+1
    756                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    757                  _SetPixelIndex(pDevice, x++, y, Index);
   \   000000A8   0010A0E1           MOV      R1,R0
   \   000000AC   061061E2           RSB      R1,R1,#+6
   \   000000B0   5B1109E0           AND      R1,R9,R11, ASR R1
   \   000000B4   3130A0E1           LSR      R3,R1,R0
   \   000000B8   0620A0E1           MOV      R2,R6
   \   000000BC   0A10A0E1           MOV      R1,R10
   \   000000C0   0500A0E1           MOV      R0,R5
   \   000000C4   ........           BL       _SetPixelIndex
    758                  if (++CurrentPixel == 4) {
   \   000000C8   014084E2           ADD      R4,R4,#+1
   \   000000CC   040054E3           CMP      R4,#+4
    759                    CurrentPixel = 0;
   \   000000D0   0040A003           MOVEQ    R4,#+0
    760                    Pixels = *(++p);
   \   000000D4   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   000000D8   01A08AE2           ADD      R10,R10,#+1
    761                  }
    762                } while (--xsize);
   \   000000DC   018058E2           SUBS     R8,R8,#+1
   \   000000E0   EEFFFF1A           BNE      ??_DrawBitLine2BPP_3
   \   000000E4   2A0000EA           B        ??_DrawBitLine2BPP_2
    763              }
    764              break;
    765            case LCD_DRAWMODE_TRANS:
    766              if (pTrans) {
   \                     ??_DrawBitLine2BPP_1:
   \   000000E8   30009DE5           LDR      R0,[SP, #+48]
   \   000000EC   C0B0A0E3           MOV      R11,#+192
   \   000000F0   000050E3           CMP      R0,#+0
   \   000000F4   1400000A           BEQ      ??_DrawBitLine2BPP_5
    767                do {
    768                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_6:
   \   000000F8   030064E2           RSB      R0,R4,#+3
   \   000000FC   8000A0E1           LSL      R0,R0,#+1
    769                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000100   0010A0E1           MOV      R1,R0
   \   00000104   061061E2           RSB      R1,R1,#+6
   \   00000108   5B1109E0           AND      R1,R9,R11, ASR R1
   \   0000010C   3130B0E1           LSRS     R3,R1,R0
    770                  if (Index) {
   \   00000110   0500000A           BEQ      ??_DrawBitLine2BPP_7
    771                    PixelIndex = *(pTrans + Index);
    772                    _SetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000114   30009DE5           LDR      R0,[SP, #+48]
   \   00000118   0620A0E1           MOV      R2,R6
   \   0000011C   033190E7           LDR      R3,[R0, +R3, LSL #+2]
   \   00000120   0A10A0E1           MOV      R1,R10
   \   00000124   0500A0E1           MOV      R0,R5
   \   00000128   ........           BL       _SetPixelIndex
    773                  }
    774                  x++;
    775                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_7:
   \   0000012C   014084E2           ADD      R4,R4,#+1
   \   00000130   040054E3           CMP      R4,#+4
    776                    CurrentPixel = 0;
   \   00000134   0040A003           MOVEQ    R4,#+0
    777                    Pixels = *(++p);
   \   00000138   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   0000013C   01A08AE2           ADD      R10,R10,#+1
    778                  }
    779                } while (--xsize);
   \   00000140   018058E2           SUBS     R8,R8,#+1
   \   00000144   EBFFFF1A           BNE      ??_DrawBitLine2BPP_6
   \   00000148   110000EA           B        ??_DrawBitLine2BPP_2
    780              } else {
    781                do {
    782                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_5:
   \   0000014C   030064E2           RSB      R0,R4,#+3
   \   00000150   8000A0E1           LSL      R0,R0,#+1
    783                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000154   0010A0E1           MOV      R1,R0
   \   00000158   061061E2           RSB      R1,R1,#+6
   \   0000015C   5B1109E0           AND      R1,R9,R11, ASR R1
   \   00000160   3130B0E1           LSRS     R3,R1,R0
    784                  if (Index) {
   \   00000164   0300000A           BEQ      ??_DrawBitLine2BPP_8
    785                    _SetPixelIndex(pDevice, x, y, Index);
   \   00000168   0620A0E1           MOV      R2,R6
   \   0000016C   0A10A0E1           MOV      R1,R10
   \   00000170   0500A0E1           MOV      R0,R5
   \   00000174   ........           BL       _SetPixelIndex
    786                  }
    787                  x++;
    788                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_8:
   \   00000178   014084E2           ADD      R4,R4,#+1
   \   0000017C   040054E3           CMP      R4,#+4
    789                    CurrentPixel = 0;
   \   00000180   0040A003           MOVEQ    R4,#+0
    790                    Pixels = *(++p);
   \   00000184   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   00000188   01A08AE2           ADD      R10,R10,#+1
    791                  }
    792                } while (--xsize);
   \   0000018C   018058E2           SUBS     R8,R8,#+1
   \   00000190   EDFFFF1A           BNE      ??_DrawBitLine2BPP_5
    793              }
    794              break;
    795            }
    796          }
   \                     ??_DrawBitLine2BPP_2:
   \   00000194   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000198   F08FBDE8           POP      {R4-R11,PC}      ;; return
    797          
    798          /*********************************************************************
    799          *
    800          *       Draw Bitmap 4 BPP
    801          */

   \                                 In section .text, align 4, keep-with-next
    802          static void  _DrawBitLine4BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine4BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    803            LCD_PIXELINDEX Pixels, PixelIndex;
    804            int CurrentPixel, Shift, Index;
    805          
    806            Pixels = *p;
    807            CurrentPixel = Diff;
    808            x += Diff;
    809            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000008   ........           LDR      R0,??DataTable13
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   28409DE5           LDR      R4,[SP, #+40]
   \   00000018   0370A0E1           MOV      R7,R3
   \   0000001C   0260A0E1           MOV      R6,R2
   \   00000020   2C809DE5           LDR      R8,[SP, #+44]
   \   00000024   0090D7E5           LDRB     R9,[R7, #+0]
   \   00000028   01A084E0           ADD      R10,R4,R1
   \   0000002C   030010E2           ANDS     R0,R0,#0x3
   \   00000030   0200000A           BEQ      ??_DrawBitLine4BPP_0
   \   00000034   020050E2           SUBS     R0,R0,#+2
   \   00000038   2A00000A           BEQ      ??_DrawBitLine4BPP_1
   \   0000003C   540000EA           B        ??_DrawBitLine4BPP_2
    810            case 0:
    811              if (pTrans) {
   \                     ??_DrawBitLine4BPP_0:
   \   00000040   30009DE5           LDR      R0,[SP, #+48]
   \   00000044   F0B0A0E3           MOV      R11,#+240
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   1300000A           BEQ      ??_DrawBitLine4BPP_3
    812                do {
    813                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_4:
   \   00000050   010064E2           RSB      R0,R4,#+1
   \   00000054   0001A0E1           LSL      R0,R0,#+2
    814                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    815                  PixelIndex = *(pTrans + Index);
    816                  _SetPixelIndex(pDevice, x++, y, PixelIndex);
   \   00000058   0010A0E1           MOV      R1,R0
   \   0000005C   041061E2           RSB      R1,R1,#+4
   \   00000060   5B1109E0           AND      R1,R9,R11, ASR R1
   \   00000064   3100A0E1           LSR      R0,R1,R0
   \   00000068   30109DE5           LDR      R1,[SP, #+48]
   \   0000006C   0620A0E1           MOV      R2,R6
   \   00000070   003191E7           LDR      R3,[R1, +R0, LSL #+2]
   \   00000074   0A10A0E1           MOV      R1,R10
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           BL       _SetPixelIndex
    817                  if (++CurrentPixel == 2) {
   \   00000080   014084E2           ADD      R4,R4,#+1
   \   00000084   020054E3           CMP      R4,#+2
    818                    CurrentPixel = 0;
   \   00000088   0040A003           MOVEQ    R4,#+0
    819                    Pixels = *(++p);
   \   0000008C   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   00000090   01A08AE2           ADD      R10,R10,#+1
    820                  }
    821                } while (--xsize);
   \   00000094   018058E2           SUBS     R8,R8,#+1
   \   00000098   ECFFFF1A           BNE      ??_DrawBitLine4BPP_4
   \   0000009C   3C0000EA           B        ??_DrawBitLine4BPP_2
    822              } else {
    823                do {
    824                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_3:
   \   000000A0   010064E2           RSB      R0,R4,#+1
   \   000000A4   0001A0E1           LSL      R0,R0,#+2
    825                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    826                  _SetPixelIndex(pDevice, x++, y, Index);
   \   000000A8   0010A0E1           MOV      R1,R0
   \   000000AC   041061E2           RSB      R1,R1,#+4
   \   000000B0   5B1109E0           AND      R1,R9,R11, ASR R1
   \   000000B4   3130A0E1           LSR      R3,R1,R0
   \   000000B8   0620A0E1           MOV      R2,R6
   \   000000BC   0A10A0E1           MOV      R1,R10
   \   000000C0   0500A0E1           MOV      R0,R5
   \   000000C4   ........           BL       _SetPixelIndex
    827                  if (++CurrentPixel == 2) {
   \   000000C8   014084E2           ADD      R4,R4,#+1
   \   000000CC   020054E3           CMP      R4,#+2
    828                    CurrentPixel = 0;
   \   000000D0   0040A003           MOVEQ    R4,#+0
    829                    Pixels = *(++p);
   \   000000D4   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   000000D8   01A08AE2           ADD      R10,R10,#+1
    830                  }
    831                } while (--xsize);
   \   000000DC   018058E2           SUBS     R8,R8,#+1
   \   000000E0   EEFFFF1A           BNE      ??_DrawBitLine4BPP_3
   \   000000E4   2A0000EA           B        ??_DrawBitLine4BPP_2
    832              }
    833              break;
    834            case LCD_DRAWMODE_TRANS:
    835              if (pTrans) {
   \                     ??_DrawBitLine4BPP_1:
   \   000000E8   30009DE5           LDR      R0,[SP, #+48]
   \   000000EC   F0B0A0E3           MOV      R11,#+240
   \   000000F0   000050E3           CMP      R0,#+0
   \   000000F4   1400000A           BEQ      ??_DrawBitLine4BPP_5
    836                do {
    837                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_6:
   \   000000F8   010064E2           RSB      R0,R4,#+1
   \   000000FC   0001A0E1           LSL      R0,R0,#+2
    838                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000100   0010A0E1           MOV      R1,R0
   \   00000104   041061E2           RSB      R1,R1,#+4
   \   00000108   5B1109E0           AND      R1,R9,R11, ASR R1
   \   0000010C   3130B0E1           LSRS     R3,R1,R0
    839                  if (Index) {
   \   00000110   0500000A           BEQ      ??_DrawBitLine4BPP_7
    840                    PixelIndex = *(pTrans + Index);
    841                    _SetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000114   30009DE5           LDR      R0,[SP, #+48]
   \   00000118   0620A0E1           MOV      R2,R6
   \   0000011C   033190E7           LDR      R3,[R0, +R3, LSL #+2]
   \   00000120   0A10A0E1           MOV      R1,R10
   \   00000124   0500A0E1           MOV      R0,R5
   \   00000128   ........           BL       _SetPixelIndex
    842                  }
    843                  x++;
    844                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_7:
   \   0000012C   014084E2           ADD      R4,R4,#+1
   \   00000130   020054E3           CMP      R4,#+2
    845                    CurrentPixel = 0;
   \   00000134   0040A003           MOVEQ    R4,#+0
    846                    Pixels = *(++p);
   \   00000138   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   0000013C   01A08AE2           ADD      R10,R10,#+1
    847                  }
    848                } while (--xsize);
   \   00000140   018058E2           SUBS     R8,R8,#+1
   \   00000144   EBFFFF1A           BNE      ??_DrawBitLine4BPP_6
   \   00000148   110000EA           B        ??_DrawBitLine4BPP_2
    849              } else {
    850                do {
    851                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_5:
   \   0000014C   010064E2           RSB      R0,R4,#+1
   \   00000150   0001A0E1           LSL      R0,R0,#+2
    852                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000154   0010A0E1           MOV      R1,R0
   \   00000158   041061E2           RSB      R1,R1,#+4
   \   0000015C   5B1109E0           AND      R1,R9,R11, ASR R1
   \   00000160   3130B0E1           LSRS     R3,R1,R0
    853                  if (Index) {
   \   00000164   0300000A           BEQ      ??_DrawBitLine4BPP_8
    854                    _SetPixelIndex(pDevice, x, y, Index);
   \   00000168   0620A0E1           MOV      R2,R6
   \   0000016C   0A10A0E1           MOV      R1,R10
   \   00000170   0500A0E1           MOV      R0,R5
   \   00000174   ........           BL       _SetPixelIndex
    855                  }
    856                  x++;
    857                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_8:
   \   00000178   014084E2           ADD      R4,R4,#+1
   \   0000017C   020054E3           CMP      R4,#+2
    858                    CurrentPixel = 0;
   \   00000180   0040A003           MOVEQ    R4,#+0
    859                    Pixels = *(++p);
   \   00000184   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   00000188   01A08AE2           ADD      R10,R10,#+1
    860                  }
    861                } while (--xsize);
   \   0000018C   018058E2           SUBS     R8,R8,#+1
   \   00000190   EDFFFF1A           BNE      ??_DrawBitLine4BPP_5
    862              }
    863              break;
    864            }
    865          }
   \                     ??_DrawBitLine4BPP_2:
   \   00000194   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000198   F08FBDE8           POP      {R4-R11,PC}      ;; return
    866          
    867          /*********************************************************************
    868          *
    869          *       Draw Bitmap 8 BPP
    870          */

   \                                 In section .text, align 4, keep-with-next
    871          static void  _DrawBitLine8BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine8BPP:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    872            LCD_PIXELINDEX Pixel;
    873          
    874            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000008   ........           LDR      R0,??DataTable16
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0170A0E1           MOV      R7,R1
   \   00000018   0250A0E1           MOV      R5,R2
   \   0000001C   0360A0E1           MOV      R6,R3
   \   00000020   20909DE5           LDR      R9,[SP, #+32]
   \   00000024   24809DE5           LDR      R8,[SP, #+36]
   \   00000028   030010E2           ANDS     R0,R0,#0x3
   \   0000002C   0200000A           BEQ      ??_DrawBitLine8BPP_0
   \   00000030   020050E2           SUBS     R0,R0,#+2
   \   00000034   3700000A           BEQ      ??_DrawBitLine8BPP_1
   \   00000038   850000EA           B        ??_DrawBitLine8BPP_2
    875            case 0:
    876              if (pTrans) {
   \                     ??_DrawBitLine8BPP_0:
   \   0000003C   000058E3           CMP      R8,#+0
   \   00000040   1B00000A           BEQ      ??_DrawBitLine8BPP_3
   \   00000044   010059E3           CMP      R9,#+1
   \   00000048   810000BA           BLT      ??_DrawBitLine8BPP_2
   \   0000004C   010019E3           TST      R9,#0x1
   \   00000050   0400000A           BEQ      ??_DrawBitLine8BPP_4
    877                for (; xsize > 0; xsize--, x++, p++) {
    878                  Pixel = *p;
    879                  _SetPixelIndex(pDevice, x, y, *(pTrans + Pixel));
   \   00000054   0100D6E4           LDRB     R0,[R6], #+1
   \   00000058   003198E7           LDR      R3,[R8, +R0, LSL #+2]
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           BL       _SetPixelIndex
   \   00000064   017087E2           ADD      R7,R7,#+1
   \                     ??_DrawBitLine8BPP_4:
   \   00000068   A990B0E1           LSRS     R9,R9,#+1
   \   0000006C   7800000A           BEQ      ??_DrawBitLine8BPP_2
   \                     ??_DrawBitLine8BPP_5:
   \   00000070   0100D6E4           LDRB     R0,[R6], #+1
   \   00000074   0520A0E1           MOV      R2,R5
   \   00000078   0710A0E1           MOV      R1,R7
   \   0000007C   003198E7           LDR      R3,[R8, +R0, LSL #+2]
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   ........           BL       _SetPixelIndex
   \   00000088   0100D6E4           LDRB     R0,[R6], #+1
   \   0000008C   017087E2           ADD      R7,R7,#+1
   \   00000090   0520A0E1           MOV      R2,R5
   \   00000094   003198E7           LDR      R3,[R8, +R0, LSL #+2]
   \   00000098   0710A0E1           MOV      R1,R7
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   ........           BL       _SetPixelIndex
    880                }
   \   000000A4   017087E2           ADD      R7,R7,#+1
   \   000000A8   019059E2           SUBS     R9,R9,#+1
   \   000000AC   EFFFFF1A           BNE      ??_DrawBitLine8BPP_5
   \   000000B0   670000EA           B        ??_DrawBitLine8BPP_2
    881              } else {
   \                     ??_DrawBitLine8BPP_3:
   \   000000B4   010059E3           CMP      R9,#+1
   \   000000B8   650000BA           BLT      ??_DrawBitLine8BPP_2
   \   000000BC   010019E3           TST      R9,#0x1
   \   000000C0   0300000A           BEQ      ??_DrawBitLine8BPP_6
    882                for (; xsize > 0; xsize--, x++, p++) {
    883                  _SetPixelIndex(pDevice, x, y, *p);
   \   000000C4   0130D6E4           LDRB     R3,[R6], #+1
   \   000000C8   0400A0E1           MOV      R0,R4
   \   000000CC   ........           BL       _SetPixelIndex
   \   000000D0   017087E2           ADD      R7,R7,#+1
   \                     ??_DrawBitLine8BPP_6:
   \   000000D4   A980B0E1           LSRS     R8,R9,#+1
   \   000000D8   5D00000A           BEQ      ??_DrawBitLine8BPP_2
   \                     ??_DrawBitLine8BPP_7:
   \   000000DC   0130D6E4           LDRB     R3,[R6], #+1
   \   000000E0   0520A0E1           MOV      R2,R5
   \   000000E4   0710A0E1           MOV      R1,R7
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       _SetPixelIndex
   \   000000F0   017087E2           ADD      R7,R7,#+1
   \   000000F4   0130D6E4           LDRB     R3,[R6], #+1
   \   000000F8   0520A0E1           MOV      R2,R5
   \   000000FC   0710A0E1           MOV      R1,R7
   \   00000100   0400A0E1           MOV      R0,R4
   \   00000104   ........           BL       _SetPixelIndex
    884                }
   \   00000108   017087E2           ADD      R7,R7,#+1
   \   0000010C   018058E2           SUBS     R8,R8,#+1
   \   00000110   F1FFFF1A           BNE      ??_DrawBitLine8BPP_7
   \   00000114   4E0000EA           B        ??_DrawBitLine8BPP_2
    885              }
    886              break;
    887            case LCD_DRAWMODE_TRANS:
    888              if (pTrans) {
   \                     ??_DrawBitLine8BPP_1:
   \   00000118   000058E3           CMP      R8,#+0
   \   0000011C   2600000A           BEQ      ??_DrawBitLine8BPP_8
   \   00000120   010059E3           CMP      R9,#+1
   \   00000124   4A0000BA           BLT      ??_DrawBitLine8BPP_2
   \   00000128   019049E2           SUB      R9,R9,#+1
   \   0000012C   0030D6E5           LDRB     R3,[R6, #+0]
   \   00000130   010019E3           TST      R9,#0x1
   \   00000134   0600000A           BEQ      ??_DrawBitLine8BPP_9
    889                for (; xsize > 0; xsize--, x++, p++) {
    890                  Pixel = *p;
    891                  if (Pixel) {
   \   00000138   000053E3           CMP      R3,#+0
   \   0000013C   0200000A           BEQ      ??_DrawBitLine8BPP_10
    892                    _SetPixelIndex(pDevice, x, y, *(pTrans + Pixel));
   \   00000140   033198E7           LDR      R3,[R8, +R3, LSL #+2]
   \   00000144   0400A0E1           MOV      R0,R4
   \   00000148   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_10:
   \   0000014C   017087E2           ADD      R7,R7,#+1
   \   00000150   0130F6E5           LDRB     R3,[R6, #+1]!
   \                     ??_DrawBitLine8BPP_9:
   \   00000154   A990B0E1           LSRS     R9,R9,#+1
   \   00000158   1300000A           BEQ      ??_DrawBitLine8BPP_11
   \                     ??_DrawBitLine8BPP_12:
   \   0000015C   000053E3           CMP      R3,#+0
   \   00000160   0400000A           BEQ      ??_DrawBitLine8BPP_13
   \   00000164   033198E7           LDR      R3,[R8, +R3, LSL #+2]
   \   00000168   0520A0E1           MOV      R2,R5
   \   0000016C   0710A0E1           MOV      R1,R7
   \   00000170   0400A0E1           MOV      R0,R4
   \   00000174   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_13:
   \   00000178   0130F6E5           LDRB     R3,[R6, #+1]!
   \   0000017C   017087E2           ADD      R7,R7,#+1
   \   00000180   000053E3           CMP      R3,#+0
   \   00000184   0400000A           BEQ      ??_DrawBitLine8BPP_14
   \   00000188   033198E7           LDR      R3,[R8, +R3, LSL #+2]
   \   0000018C   0520A0E1           MOV      R2,R5
   \   00000190   0710A0E1           MOV      R1,R7
   \   00000194   0400A0E1           MOV      R0,R4
   \   00000198   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_14:
   \   0000019C   017087E2           ADD      R7,R7,#+1
   \   000001A0   0130F6E5           LDRB     R3,[R6, #+1]!
   \   000001A4   019059E2           SUBS     R9,R9,#+1
   \   000001A8   EBFFFF1A           BNE      ??_DrawBitLine8BPP_12
   \                     ??_DrawBitLine8BPP_11:
   \   000001AC   000053E3           CMP      R3,#+0
   \   000001B0   2700000A           BEQ      ??_DrawBitLine8BPP_2
   \   000001B4   033198E7           LDR      R3,[R8, +R3, LSL #+2]
   \   000001B8   210000EA           B        ??_DrawBitLine8BPP_15
    893                  }
    894                }
    895              } else {
   \                     ??_DrawBitLine8BPP_8:
   \   000001BC   010059E3           CMP      R9,#+1
   \   000001C0   230000BA           BLT      ??_DrawBitLine8BPP_2
   \   000001C4   018049E2           SUB      R8,R9,#+1
   \   000001C8   0030D6E5           LDRB     R3,[R6, #+0]
   \   000001CC   010018E3           TST      R8,#0x1
   \   000001D0   0500000A           BEQ      ??_DrawBitLine8BPP_16
    896                for (; xsize > 0; xsize--, x++, p++) {
    897                  Pixel = *p;
    898                  if (Pixel) {
   \   000001D4   000053E3           CMP      R3,#+0
   \   000001D8   0100000A           BEQ      ??_DrawBitLine8BPP_17
    899                    _SetPixelIndex(pDevice, x, y, Pixel);
   \   000001DC   0400A0E1           MOV      R0,R4
   \   000001E0   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_17:
   \   000001E4   017087E2           ADD      R7,R7,#+1
   \   000001E8   0130F6E5           LDRB     R3,[R6, #+1]!
   \                     ??_DrawBitLine8BPP_16:
   \   000001EC   A880B0E1           LSRS     R8,R8,#+1
   \   000001F0   1100000A           BEQ      ??_DrawBitLine8BPP_18
   \                     ??_DrawBitLine8BPP_19:
   \   000001F4   000053E3           CMP      R3,#+0
   \   000001F8   0300000A           BEQ      ??_DrawBitLine8BPP_20
   \   000001FC   0520A0E1           MOV      R2,R5
   \   00000200   0710A0E1           MOV      R1,R7
   \   00000204   0400A0E1           MOV      R0,R4
   \   00000208   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_20:
   \   0000020C   0130F6E5           LDRB     R3,[R6, #+1]!
   \   00000210   017087E2           ADD      R7,R7,#+1
   \   00000214   000053E3           CMP      R3,#+0
   \   00000218   0300000A           BEQ      ??_DrawBitLine8BPP_21
   \   0000021C   0520A0E1           MOV      R2,R5
   \   00000220   0710A0E1           MOV      R1,R7
   \   00000224   0400A0E1           MOV      R0,R4
   \   00000228   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_21:
   \   0000022C   017087E2           ADD      R7,R7,#+1
   \   00000230   0130F6E5           LDRB     R3,[R6, #+1]!
   \   00000234   018058E2           SUBS     R8,R8,#+1
   \   00000238   EDFFFF1A           BNE      ??_DrawBitLine8BPP_19
   \                     ??_DrawBitLine8BPP_18:
   \   0000023C   000053E3           CMP      R3,#+0
   \   00000240   0300000A           BEQ      ??_DrawBitLine8BPP_2
   \                     ??_DrawBitLine8BPP_15:
   \   00000244   0520A0E1           MOV      R2,R5
   \   00000248   0710A0E1           MOV      R1,R7
   \   0000024C   0400A0E1           MOV      R0,R4
   \   00000250   ........           BL       _SetPixelIndex
    900                  }
    901                }
    902              }
    903              break;
    904            }
    905          }
   \                     ??_DrawBitLine8BPP_2:
   \   00000254   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000258   F083BDE8           POP      {R4-R9,PC}       ;; return
    906          
    907          /*********************************************************************
    908          *
    909          *       Draw Bitmap 32 BPP
    910          */

   \                                 In section .text, align 4, keep-with-next
    911          static void _DrawBitLine32BPP(GUI_DEVICE * pDevice, int x, int y, U32 const GUI_UNI_PTR * p, int xsize) {
   \                     _DrawBitLine32BPP:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    912            #define GET_PIXEL_INDEX(Index) Index = *p++
    913            DRIVER_CONTEXT * pContext;
    914            U32 Data, Data0, Data1, Data2, Index;
    915            unsigned Off, Odd;
    916          
    917            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   10C09DE5           LDR      R12,[SP, #+16]
    918            //
    919            // Mirror x
    920            //
    921            x = (pContext->vxSizePhys - 1 - x);
   \   0000000C   14E090E5           LDR      LR,[R0, #+20]
   \   00000010   01404EE2           SUB      R4,LR,#+1
   \   00000014   014044E0           SUB      R4,R4,R1
    922            //
    923            // First triple DWORD
    924            //
    925            Off = XY2OFF32(pContext->vxSizePhys, x, y);
   \   00000018   9E0201E0           MUL      R1,LR,R2
   \   0000001C   842084E0           ADD      R2,R4,R4, LSL #+1
   \   00000020   811081E0           ADD      R1,R1,R1, LSL #+1
   \   00000024   011082E0           ADD      R1,R2,R1
    926            Odd = x & 3;
   \   00000028   032004E2           AND      R2,R4,#0x3
   \   0000002C   2111A0E1           LSR      R1,R1,#+2
    927            if (Odd != 3) {
   \   00000030   030052E3           CMP      R2,#+3
   \   00000034   2D00000A           BEQ      ??_DrawBitLine32BPP_0
    928              if (Odd != 0) {
   \   00000038   000052E3           CMP      R2,#+0
    929                Off++;
    930              }
    931              Data    = READ_MEM32(pContext->VRAMAddr, Off);
   \   0000003C   00E090E5           LDR      LR,[R0, #+0]
   \   00000040   01108112           ADDNE    R1,R1,#+1
   \   00000044   01419EE7           LDR      R4,[LR, +R1, LSL #+2]
    932              switch (Odd) {
   \   00000048   2100000A           BEQ      ??_DrawBitLine32BPP_1
   \   0000004C   020052E3           CMP      R2,#+2
   \   00000050   0100000A           BEQ      ??_DrawBitLine32BPP_2
   \   00000054   1000003A           BCC      ??_DrawBitLine32BPP_3
   \   00000058   240000EA           B        ??_DrawBitLine32BPP_0
    933              case 2:
    934                GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine32BPP_2:
   \   0000005C   042093E4           LDR      R2,[R3], #+4
    935                Data &= 0xFFFFFF00;
    936                Data |= Index >> 16;
    937                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000060   FF40C4E3           BIC      R4,R4,#0xFF
   \   00000064   224884E1           ORR      R4,R4,R2, LSR #+16
   \   00000068   01418EE7           STR      R4,[LR, +R1, LSL #+2]
    938                Off--;
    939                Data = READ_MEM32(pContext->VRAMAddr, Off);
    940                Data &= 0x0000FFFF;
    941                Data |= Index << 16;
   \   0000006C   00E090E5           LDR      LR,[R0, #+0]
   \   00000070   011041E2           SUB      R1,R1,#+1
   \   00000074   01E18EE0           ADD      LR,LR,R1, LSL #+2
   \   00000078   B0E0DEE1           LDRH     LR,[LR, #+0]
   \   0000007C   0228A0E1           LSL      R2,R2,#+16
    942                xsize--;                  
   \   00000080   01C05CE2           SUBS     R12,R12,#+1
   \   00000084   0EE8A0E1           LSL      LR,LR,#+16
   \   00000088   2E4882E1           ORR      R4,R2,LR, LSR #+16
    943                if (!xsize) {
   \   0000008C   0200001A           BNE      ??_DrawBitLine32BPP_3
    944                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);   
   \                     ??_DrawBitLine32BPP_4:
   \   00000090   002090E5           LDR      R2,[R0, #+0]
   \   00000094   014182E7           STR      R4,[R2, +R1, LSL #+2]
    945                  break;
   \   00000098   140000EA           B        ??_DrawBitLine32BPP_0
    946                }
    947              case 1:
    948                GET_PIXEL_INDEX(Index);   
   \                     ??_DrawBitLine32BPP_3:
   \   0000009C   042093E4           LDR      R2,[R3], #+4
    949                Data &= 0xFFFF0000;
    950                Data |= Index >> 8;
    951                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000000A0   24E8A0E1           LSR      LR,R4,#+16
   \   000000A4   2244A0E1           LSR      R4,R2,#+8
   \   000000A8   0EE884E1           ORR      LR,R4,LR, LSL #+16
   \   000000AC   004090E5           LDR      R4,[R0, #+0]
    952                Off--;
    953                Data = READ_MEM32(pContext->VRAMAddr, Off);
    954                Data &= 0x00FFFFFF;
    955                Data |= Index << 24;
   \   000000B0   022CA0E1           LSL      R2,R2,#+24
   \   000000B4   01E184E7           STR      LR,[R4, +R1, LSL #+2]
   \   000000B8   00E090E5           LDR      LR,[R0, #+0]
   \   000000BC   011041E2           SUB      R1,R1,#+1
   \   000000C0   01E19EE7           LDR      LR,[LR, +R1, LSL #+2]
    956                xsize--;                  
   \   000000C4   01C05CE2           SUBS     R12,R12,#+1
   \   000000C8   0EE4A0E1           LSL      LR,LR,#+8
   \   000000CC   2E4482E1           ORR      R4,R2,LR, LSR #+8
    957                if (!xsize) {
   \   000000D0   EEFFFF0A           BEQ      ??_DrawBitLine32BPP_4
    958                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);   
    959                  break;
    960                }
    961              case 0:
    962                GET_PIXEL_INDEX(Index);   
   \                     ??_DrawBitLine32BPP_1:
   \   000000D4   042093E4           LDR      R2,[R3], #+4
    963                Data &= 0xFF000000;
    964                Data |= Index;
    965                xsize--;                  
    966                WRITE_MEM32(pContext->VRAMAddr, Off, Data);     
   \   000000D8   00E090E5           LDR      LR,[R0, #+0]
   \   000000DC   FF4404E2           AND      R4,R4,#0xFF000000
   \   000000E0   042082E1           ORR      R2,R2,R4
   \   000000E4   01218EE7           STR      R2,[LR, +R1, LSL #+2]
   \   000000E8   01C04CE2           SUB      R12,R12,#+1
    967                Off--;
   \   000000EC   011041E2           SUB      R1,R1,#+1
    968              }
    969            }
    970            //
    971            // Complete triple DWORDS
    972            //
    973            if (xsize >= 4) {
   \                     ??_DrawBitLine32BPP_0:
   \   000000F0   04005CE3           CMP      R12,#+4
   \   000000F4   150000BA           BLT      ??_DrawBitLine32BPP_5
    974              do {
    975                GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine32BPP_6:
   \   000000F8   042093E4           LDR      R2,[R3], #+4
    976                Data0  = (Index <<  8);
    977                GET_PIXEL_INDEX(Index);
   \   000000FC   04E093E4           LDR      LR,[R3], #+4
   \   00000100   0224A0E1           LSL      R2,R2,#+8
    978                Data0 |= (Index >> 16);
   \   00000104   2E4882E1           ORR      R4,R2,LR, LSR #+16
    979                Data1  = (Index << 16);
   \   00000108   0E28A0E1           LSL      R2,LR,#+16
    980                GET_PIXEL_INDEX(Index);
   \   0000010C   04E093E4           LDR      LR,[R3], #+4
    981                Data1 |= (Index >>  8);
    982                Data2  = (Index << 24);
    983                GET_PIXEL_INDEX(Index);
    984                Data2 |= (Index      );
    985                WRITE_MEM32(pContext->VRAMAddr, Off - 0, Data0);
   \   00000110   006090E5           LDR      R6,[R0, #+0]
   \   00000114   2E5482E1           ORR      R5,R2,LR, LSR #+8
   \   00000118   042093E4           LDR      R2,[R3], #+4
   \   0000011C   014186E7           STR      R4,[R6, +R1, LSL #+2]
    986                WRITE_MEM32(pContext->VRAMAddr, Off - 1, Data1);
   \   00000120   004090E5           LDR      R4,[R0, #+0]
   \   00000124   0EECA0E1           LSL      LR,LR,#+24
   \   00000128   014184E0           ADD      R4,R4,R1, LSL #+2
   \   0000012C   045004E5           STR      R5,[R4, #-4]
    987                WRITE_MEM32(pContext->VRAMAddr, Off - 2, Data2);
   \   00000130   004090E5           LDR      R4,[R0, #+0]
   \   00000134   0E2082E1           ORR      R2,R2,LR
   \   00000138   014184E0           ADD      R4,R4,R1, LSL #+2
    988                Off -= 3;
    989              } while ((xsize -= 4) >= 4);
   \   0000013C   04C04CE2           SUB      R12,R12,#+4
   \   00000140   082004E5           STR      R2,[R4, #-8]
   \   00000144   031041E2           SUB      R1,R1,#+3
   \   00000148   04005CE3           CMP      R12,#+4
   \   0000014C   E9FFFFAA           BGE      ??_DrawBitLine32BPP_6
    990            }
    991            //
    992            // Last triple DWORD
    993            //
    994            if (xsize) {
   \                     ??_DrawBitLine32BPP_5:
   \   00000150   00005CE3           CMP      R12,#+0
   \   00000154   2100000A           BEQ      ??_DrawBitLine32BPP_7
    995              Data  = READ_MEM32(pContext->VRAMAddr, Off);
    996              Data &= 0x000000FF;
    997              GET_PIXEL_INDEX(Index);
    998              Data |= (Index << 8);
   \   00000158   00E090E5           LDR      LR,[R0, #+0]
   \   0000015C   042093E4           LDR      R2,[R3], #+4
   \   00000160   0141DEE7           LDRB     R4,[LR, +R1, LSL #+2]
    999              xsize--;
   \   00000164   01C05CE2           SUBS     R12,R12,#+1
   \   00000168   024484E1           ORR      R4,R4,R2, LSL #+8
   1000              if (!xsize) {
   \   0000016C   0200001A           BNE      ??_DrawBitLine32BPP_8
   1001                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine32BPP_9:
   \   00000170   000090E5           LDR      R0,[R0, #+0]
   \   00000174   014180E7           STR      R4,[R0, +R1, LSL #+2]
   1002                return;
   \   00000178   7080BDE8           POP      {R4-R6,PC}
   1003              }
   1004              Data &= 0xFFFFFF00;
   1005              GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine32BPP_8:
   \   0000017C   042093E4           LDR      R2,[R3], #+4
   1006              Data |= Index >> 16;
   1007              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000180   FF40C4E3           BIC      R4,R4,#0xFF
   \   00000184   224884E1           ORR      R4,R4,R2, LSR #+16
   \   00000188   01418EE7           STR      R4,[LR, +R1, LSL #+2]
   1008              Off--;
   1009              Data  = READ_MEM32(pContext->VRAMAddr, Off);
   1010              Data &= 0x0000FFFF;
   1011              Data |= Index << 16;
   \   0000018C   00E090E5           LDR      LR,[R0, #+0]
   \   00000190   011041E2           SUB      R1,R1,#+1
   \   00000194   01418EE0           ADD      R4,LR,R1, LSL #+2
   \   00000198   B040D4E1           LDRH     R4,[R4, #+0]
   \   0000019C   0228A0E1           LSL      R2,R2,#+16
   \   000001A0   0448A0E1           LSL      R4,R4,#+16
   \   000001A4   244882E1           ORR      R4,R2,R4, LSR #+16
   1012              xsize--;
   1013              if (!xsize) {
   \   000001A8   01205CE2           SUBS     R2,R12,#+1
   \   000001AC   EFFFFF0A           BEQ      ??_DrawBitLine32BPP_9
   1014                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   1015                return;
   1016              }
   1017              Data &= 0xFFFF0000;
   1018              GET_PIXEL_INDEX(Index);
   \   000001B0   002093E5           LDR      R2,[R3, #+0]
   1019              Data |= Index >> 8;
   1020              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000001B4   2438A0E1           LSR      R3,R4,#+16
   \   000001B8   22C4A0E1           LSR      R12,R2,#+8
   \   000001BC   03388CE1           ORR      R3,R12,R3, LSL #+16
   \   000001C0   01318EE7           STR      R3,[LR, +R1, LSL #+2]
   1021              Off--;
   1022              Data  = READ_MEM32(pContext->VRAMAddr, Off);
   1023              Data &= 0x00FFFFFF;
   1024              Data |= Index << 24;
   1025              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000001C4   000090E5           LDR      R0,[R0, #+0]
   \   000001C8   011041E2           SUB      R1,R1,#+1
   \   000001CC   013190E7           LDR      R3,[R0, +R1, LSL #+2]
   \   000001D0   022CA0E1           LSL      R2,R2,#+24
   \   000001D4   0334A0E1           LSL      R3,R3,#+8
   \   000001D8   232482E1           ORR      R2,R2,R3, LSR #+8
   \   000001DC   012180E7           STR      R2,[R0, +R1, LSL #+2]
   \                     ??_DrawBitLine32BPP_7:
   \   000001E0   7080BDE8           POP      {R4-R6,PC}       ;; return
   1026            }
   1027            #undef GET_PIXEL_INDEX
   1028          }
   1029          
   1030          /*********************************************************************
   1031          *
   1032          *       _DrawBitmap
   1033          */

   \                                 In section .text, align 4, keep-with-next
   1034          static void _DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0,
   1035                                 int xSize, int ySize,
   1036                                 int BitsPerPixel, 
   1037                                 int BytesPerLine,
   1038                                 const U8 GUI_UNI_PTR * pData, int Diff,
   1039                                 const LCD_PIXELINDEX* pTrans) {
   \                     _DrawBitmap:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   3C109DE5           LDR      R1,[SP, #+60]
   \   00000010   0040A0E1           MOV      R4,R0
   1040            int i;
   1041          
   1042            //
   1043            // Use _DrawBitLineXBPP and _DrawBitLineXBPP_Swap
   1044            //
   1045            switch (BitsPerPixel) {
   \   00000014   011041E2           SUB      R1,R1,#+1
   \   00000018   0360A0E1           MOV      R6,R3
   \   0000001C   38009DE5           LDR      R0,[SP, #+56]
   \   00000020   40709DE5           LDR      R7,[SP, #+64]
   \   00000024   44809DE5           LDR      R8,[SP, #+68]
   \   00000028   48909DE5           LDR      R9,[SP, #+72]
   \   0000002C   4CA09DE5           LDR      R10,[SP, #+76]
   \   00000030   1F0051E3           CMP      R1,#+31
   \   00000034   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitmap_0:
   \   00000038   EC00008A           BHI      ??_DrawBitmap_1
   \   0000003C   1E0000EA           B        ??_DrawBitmap_2
   \   00000040   4A0000EA           B        ??_DrawBitmap_3
   \   00000044   E90000EA           B        ??_DrawBitmap_1
   \   00000048   750000EA           B        ??_DrawBitmap_4
   \   0000004C   E70000EA           B        ??_DrawBitmap_1
   \   00000050   E60000EA           B        ??_DrawBitmap_1
   \   00000054   E50000EA           B        ??_DrawBitmap_1
   \   00000058   9E0000EA           B        ??_DrawBitmap_5
   \   0000005C   E30000EA           B        ??_DrawBitmap_1
   \   00000060   E20000EA           B        ??_DrawBitmap_1
   \   00000064   E10000EA           B        ??_DrawBitmap_1
   \   00000068   E00000EA           B        ??_DrawBitmap_1
   \   0000006C   DF0000EA           B        ??_DrawBitmap_1
   \   00000070   DE0000EA           B        ??_DrawBitmap_1
   \   00000074   DD0000EA           B        ??_DrawBitmap_1
   \   00000078   DC0000EA           B        ??_DrawBitmap_1
   \   0000007C   DB0000EA           B        ??_DrawBitmap_1
   \   00000080   DA0000EA           B        ??_DrawBitmap_1
   \   00000084   D90000EA           B        ??_DrawBitmap_1
   \   00000088   D80000EA           B        ??_DrawBitmap_1
   \   0000008C   D70000EA           B        ??_DrawBitmap_1
   \   00000090   D60000EA           B        ??_DrawBitmap_1
   \   00000094   D50000EA           B        ??_DrawBitmap_1
   \   00000098   D40000EA           B        ??_DrawBitmap_1
   \   0000009C   D30000EA           B        ??_DrawBitmap_1
   \   000000A0   D20000EA           B        ??_DrawBitmap_1
   \   000000A4   D10000EA           B        ??_DrawBitmap_1
   \   000000A8   D00000EA           B        ??_DrawBitmap_1
   \   000000AC   CF0000EA           B        ??_DrawBitmap_1
   \   000000B0   CE0000EA           B        ??_DrawBitmap_1
   \   000000B4   CD0000EA           B        ??_DrawBitmap_1
   \   000000B8   AB0000EA           B        ??_DrawBitmap_6
   1046            case 1:
   1047              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_2:
   \   000000BC   010050E3           CMP      R0,#+1
   \   000000C0   CA0000BA           BLT      ??_DrawBitmap_1
   \   000000C4   02B0A0E1           MOV      R11,R2
   \   000000C8   10008DE5           STR      R0,[SP, #+16]
   \   000000CC   010010E3           TST      R0,#0x1
   \   000000D0   0800000A           BEQ      ??_DrawBitmap_7
   1048                _DrawBitLine1BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   000000D4   08A08DE5           STR      R10,[SP, #+8]
   \   000000D8   04608DE5           STR      R6,[SP, #+4]
   \   000000DC   00908DE5           STR      R9,[SP, #+0]
   \   000000E0   0830A0E1           MOV      R3,R8
   \   000000E4   0510A0E1           MOV      R1,R5
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       _DrawBitLine1BPP
   1049                pData += BytesPerLine;
   \   000000F0   088087E0           ADD      R8,R7,R8
   \   000000F4   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_7:
   \   000000F8   10109DE5           LDR      R1,[SP, #+16]
   \   000000FC   A110A0E1           LSR      R1,R1,#+1
   \   00000100   0C108DE5           STR      R1,[SP, #+12]
   \   00000104   000051E3           CMP      R1,#+0
   \   00000108   B800000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_8:
   \   0000010C   08A08DE5           STR      R10,[SP, #+8]
   \   00000110   04608DE5           STR      R6,[SP, #+4]
   \   00000114   00908DE5           STR      R9,[SP, #+0]
   \   00000118   0830A0E1           MOV      R3,R8
   \   0000011C   0B20A0E1           MOV      R2,R11
   \   00000120   0510A0E1           MOV      R1,R5
   \   00000124   0400A0E1           MOV      R0,R4
   \   00000128   ........           BL       _DrawBitLine1BPP
   \   0000012C   088087E0           ADD      R8,R7,R8
   \   00000130   08A08DE5           STR      R10,[SP, #+8]
   \   00000134   04608DE5           STR      R6,[SP, #+4]
   \   00000138   00908DE5           STR      R9,[SP, #+0]
   \   0000013C   0830A0E1           MOV      R3,R8
   \   00000140   01208BE2           ADD      R2,R11,#+1
   \   00000144   0510A0E1           MOV      R1,R5
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   ........           BL       _DrawBitLine1BPP
   1050              }
   \   00000150   0C109DE5           LDR      R1,[SP, #+12]
   \   00000154   088087E0           ADD      R8,R7,R8
   \   00000158   011041E2           SUB      R1,R1,#+1
   \   0000015C   0C108DE5           STR      R1,[SP, #+12]
   \   00000160   02B08BE2           ADD      R11,R11,#+2
   \   00000164   000051E3           CMP      R1,#+0
   \   00000168   E7FFFF1A           BNE      ??_DrawBitmap_8
   \   0000016C   9F0000EA           B        ??_DrawBitmap_1
   1051              break;
   1052            case 2:
   1053              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_3:
   \   00000170   010050E3           CMP      R0,#+1
   \   00000174   9D0000BA           BLT      ??_DrawBitmap_1
   \   00000178   02B0A0E1           MOV      R11,R2
   \   0000017C   10008DE5           STR      R0,[SP, #+16]
   \   00000180   010010E3           TST      R0,#0x1
   \   00000184   0800000A           BEQ      ??_DrawBitmap_9
   1054                _DrawBitLine2BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   00000188   08A08DE5           STR      R10,[SP, #+8]
   \   0000018C   04608DE5           STR      R6,[SP, #+4]
   \   00000190   00908DE5           STR      R9,[SP, #+0]
   \   00000194   0830A0E1           MOV      R3,R8
   \   00000198   0510A0E1           MOV      R1,R5
   \   0000019C   0400A0E1           MOV      R0,R4
   \   000001A0   ........           BL       _DrawBitLine2BPP
   1055                pData += BytesPerLine;
   \   000001A4   088087E0           ADD      R8,R7,R8
   \   000001A8   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_9:
   \   000001AC   10109DE5           LDR      R1,[SP, #+16]
   \   000001B0   A110A0E1           LSR      R1,R1,#+1
   \   000001B4   0C108DE5           STR      R1,[SP, #+12]
   \   000001B8   000051E3           CMP      R1,#+0
   \   000001BC   8B00000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_10:
   \   000001C0   08A08DE5           STR      R10,[SP, #+8]
   \   000001C4   04608DE5           STR      R6,[SP, #+4]
   \   000001C8   00908DE5           STR      R9,[SP, #+0]
   \   000001CC   0830A0E1           MOV      R3,R8
   \   000001D0   0B20A0E1           MOV      R2,R11
   \   000001D4   0510A0E1           MOV      R1,R5
   \   000001D8   0400A0E1           MOV      R0,R4
   \   000001DC   ........           BL       _DrawBitLine2BPP
   \   000001E0   088087E0           ADD      R8,R7,R8
   \   000001E4   08A08DE5           STR      R10,[SP, #+8]
   \   000001E8   04608DE5           STR      R6,[SP, #+4]
   \   000001EC   00908DE5           STR      R9,[SP, #+0]
   \   000001F0   0830A0E1           MOV      R3,R8
   \   000001F4   01208BE2           ADD      R2,R11,#+1
   \   000001F8   0510A0E1           MOV      R1,R5
   \   000001FC   0400A0E1           MOV      R0,R4
   \   00000200   ........           BL       _DrawBitLine2BPP
   1056              }
   \   00000204   0C109DE5           LDR      R1,[SP, #+12]
   \   00000208   088087E0           ADD      R8,R7,R8
   \   0000020C   011041E2           SUB      R1,R1,#+1
   \   00000210   0C108DE5           STR      R1,[SP, #+12]
   \   00000214   02B08BE2           ADD      R11,R11,#+2
   \   00000218   000051E3           CMP      R1,#+0
   \   0000021C   E7FFFF1A           BNE      ??_DrawBitmap_10
   \   00000220   720000EA           B        ??_DrawBitmap_1
   1057              break;
   1058            case 4:
   1059              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_4:
   \   00000224   010050E3           CMP      R0,#+1
   \   00000228   700000BA           BLT      ??_DrawBitmap_1
   \   0000022C   02B0A0E1           MOV      R11,R2
   \   00000230   10008DE5           STR      R0,[SP, #+16]
   \   00000234   010010E3           TST      R0,#0x1
   \   00000238   0800000A           BEQ      ??_DrawBitmap_11
   1060                _DrawBitLine4BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   0000023C   08A08DE5           STR      R10,[SP, #+8]
   \   00000240   04608DE5           STR      R6,[SP, #+4]
   \   00000244   00908DE5           STR      R9,[SP, #+0]
   \   00000248   0830A0E1           MOV      R3,R8
   \   0000024C   0510A0E1           MOV      R1,R5
   \   00000250   0400A0E1           MOV      R0,R4
   \   00000254   ........           BL       _DrawBitLine4BPP
   1061                pData += BytesPerLine;
   \   00000258   088087E0           ADD      R8,R7,R8
   \   0000025C   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_11:
   \   00000260   10109DE5           LDR      R1,[SP, #+16]
   \   00000264   A110A0E1           LSR      R1,R1,#+1
   \   00000268   0C108DE5           STR      R1,[SP, #+12]
   \   0000026C   000051E3           CMP      R1,#+0
   \   00000270   5E00000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_12:
   \   00000274   08A08DE5           STR      R10,[SP, #+8]
   \   00000278   04608DE5           STR      R6,[SP, #+4]
   \   0000027C   00908DE5           STR      R9,[SP, #+0]
   \   00000280   0830A0E1           MOV      R3,R8
   \   00000284   0B20A0E1           MOV      R2,R11
   \   00000288   0510A0E1           MOV      R1,R5
   \   0000028C   0400A0E1           MOV      R0,R4
   \   00000290   ........           BL       _DrawBitLine4BPP
   \   00000294   088087E0           ADD      R8,R7,R8
   \   00000298   08A08DE5           STR      R10,[SP, #+8]
   \   0000029C   04608DE5           STR      R6,[SP, #+4]
   \   000002A0   00908DE5           STR      R9,[SP, #+0]
   \   000002A4   0830A0E1           MOV      R3,R8
   \   000002A8   01208BE2           ADD      R2,R11,#+1
   \   000002AC   0510A0E1           MOV      R1,R5
   \   000002B0   0400A0E1           MOV      R0,R4
   \   000002B4   ........           BL       _DrawBitLine4BPP
   1062              }
   \   000002B8   0C109DE5           LDR      R1,[SP, #+12]
   \   000002BC   088087E0           ADD      R8,R7,R8
   \   000002C0   011041E2           SUB      R1,R1,#+1
   \   000002C4   0C108DE5           STR      R1,[SP, #+12]
   \   000002C8   02B08BE2           ADD      R11,R11,#+2
   \   000002CC   000051E3           CMP      R1,#+0
   \   000002D0   E7FFFF1A           BNE      ??_DrawBitmap_12
   \   000002D4   450000EA           B        ??_DrawBitmap_1
   1063              break;
   1064            case 8:
   1065              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_5:
   \   000002D8   010050E3           CMP      R0,#+1
   \   000002DC   430000BA           BLT      ??_DrawBitmap_1
   \   000002E0   00B0A0E1           MOV      R11,R0
   \   000002E4   0290A0E1           MOV      R9,R2
   \   000002E8   01001BE3           TST      R11,#0x1
   \   000002EC   0700000A           BEQ      ??_DrawBitmap_13
   1066                _DrawBitLine8BPP(pDevice, x0, i + y0, pData, xSize, pTrans);
   \   000002F0   04A08DE5           STR      R10,[SP, #+4]
   \   000002F4   00608DE5           STR      R6,[SP, #+0]
   \   000002F8   0830A0E1           MOV      R3,R8
   \   000002FC   0510A0E1           MOV      R1,R5
   \   00000300   0400A0E1           MOV      R0,R4
   \   00000304   ........           BL       _DrawBitLine8BPP
   1067                pData += BytesPerLine;
   \   00000308   088087E0           ADD      R8,R7,R8
   \   0000030C   019089E2           ADD      R9,R9,#+1
   \                     ??_DrawBitmap_13:
   \   00000310   ABB0B0E1           LSRS     R11,R11,#+1
   \   00000314   3500000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_14:
   \   00000318   04A08DE5           STR      R10,[SP, #+4]
   \   0000031C   00608DE5           STR      R6,[SP, #+0]
   \   00000320   0830A0E1           MOV      R3,R8
   \   00000324   0920A0E1           MOV      R2,R9
   \   00000328   0510A0E1           MOV      R1,R5
   \   0000032C   0400A0E1           MOV      R0,R4
   \   00000330   ........           BL       _DrawBitLine8BPP
   \   00000334   088087E0           ADD      R8,R7,R8
   \   00000338   04A08DE5           STR      R10,[SP, #+4]
   \   0000033C   00608DE5           STR      R6,[SP, #+0]
   \   00000340   0830A0E1           MOV      R3,R8
   \   00000344   012089E2           ADD      R2,R9,#+1
   \   00000348   0510A0E1           MOV      R1,R5
   \   0000034C   0400A0E1           MOV      R0,R4
   \   00000350   ........           BL       _DrawBitLine8BPP
   1068              }
   \   00000354   01B04BE2           SUB      R11,R11,#+1
   \   00000358   088087E0           ADD      R8,R7,R8
   \   0000035C   029089E2           ADD      R9,R9,#+2
   \   00000360   00005BE3           CMP      R11,#+0
   \   00000364   EBFFFF1A           BNE      ??_DrawBitmap_14
   \   00000368   200000EA           B        ??_DrawBitmap_1
   1069              break;
   1070            case 32:
   1071              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_6:
   \   0000036C   010050E3           CMP      R0,#+1
   \   00000370   1E0000BA           BLT      ??_DrawBitmap_1
   \   00000374   00A0A0E1           MOV      R10,R0
   \   00000378   0290A0E1           MOV      R9,R2
   \   0000037C   01001AE3           TST      R10,#0x1
   \   00000380   0600000A           BEQ      ??_DrawBitmap_15
   1072                _DrawBitLine32BPP(pDevice, x0, i + y0, (const U32 *)pData, xSize);
   \   00000384   00608DE5           STR      R6,[SP, #+0]
   \   00000388   0830A0E1           MOV      R3,R8
   \   0000038C   0510A0E1           MOV      R1,R5
   \   00000390   0400A0E1           MOV      R0,R4
   \   00000394   ........           BL       _DrawBitLine32BPP
   1073                pData += BytesPerLine;
   \   00000398   088087E0           ADD      R8,R7,R8
   \   0000039C   019089E2           ADD      R9,R9,#+1
   \                     ??_DrawBitmap_15:
   \   000003A0   AAA0B0E1           LSRS     R10,R10,#+1
   \   000003A4   1100000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_16:
   \   000003A8   00608DE5           STR      R6,[SP, #+0]
   \   000003AC   0830A0E1           MOV      R3,R8
   \   000003B0   0920A0E1           MOV      R2,R9
   \   000003B4   0510A0E1           MOV      R1,R5
   \   000003B8   0400A0E1           MOV      R0,R4
   \   000003BC   ........           BL       _DrawBitLine32BPP
   \   000003C0   088087E0           ADD      R8,R7,R8
   \   000003C4   00608DE5           STR      R6,[SP, #+0]
   \   000003C8   0830A0E1           MOV      R3,R8
   \   000003CC   012089E2           ADD      R2,R9,#+1
   \   000003D0   0510A0E1           MOV      R1,R5
   \   000003D4   0400A0E1           MOV      R0,R4
   \   000003D8   ........           BL       _DrawBitLine32BPP
   1074              }
   \   000003DC   01A04AE2           SUB      R10,R10,#+1
   \   000003E0   088087E0           ADD      R8,R7,R8
   \   000003E4   029089E2           ADD      R9,R9,#+2
   \   000003E8   00005AE3           CMP      R10,#+0
   \   000003EC   EDFFFF1A           BNE      ??_DrawBitmap_16
   1075              break;
   1076            }
   1077          }
   \                     ??_DrawBitmap_1:
   \   000003F0   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000003F4   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1078          
   1079          /*********************************************************************
   1080          *
   1081          *       _SetOrg
   1082          */

   \                                 In section .text, align 4, keep-with-next
   1083          static void _SetOrg(GUI_DEVICE * pDevice, int x, int y) {
   \                     _SetOrg:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1084            #ifndef WIN32
   1085              DRIVER_CONTEXT * pContext;
   1086            #endif
   1087            LCD_X_SETORG_INFO Data = {0};
   \   00000004   ............       ADRL     R12,`?<Constant {0}>`
   \              ....        
   \   0000000C   0CD04DE2           SUB      SP,SP,#+12
   \   00000010   00409CE5           LDR      R4,[R12, #+0]
   \   00000014   04509CE5           LDR      R5,[R12, #+4]
   \   00000018   0D30A0E1           MOV      R3,SP
   \   0000001C   300083E8           STM      R3,{R4,R5}
   1088          
   1089            #ifdef WIN32
   1090              LCDSIM_SetOrg(x, y, pDevice->LayerIndex);
   1091            #else
   1092              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000020   083090E5           LDR      R3,[R0, #+8]
   1093              Data.xPos = pContext->vxSize - pContext->xSize - x;
   \   00000024   0CC093E5           LDR      R12,[R3, #+12]
   \   00000028   043093E5           LDR      R3,[R3, #+4]
   1094              Data.yPos = y;
   \   0000002C   04208DE5           STR      R2,[SP, #+4]
   \   00000030   03304CE0           SUB      R3,R12,R3
   \   00000034   011043E0           SUB      R1,R3,R1
   \   00000038   00108DE5           STR      R1,[SP, #+0]
   1095              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETORG, (void *)&Data);
   \   0000003C   0D20A0E1           MOV      R2,SP
   \   00000040   0310A0E3           MOV      R1,#+3
   \   00000044   180090E5           LDR      R0,[R0, #+24]
   \   00000048   ........           BL       LCD_X_DisplayDriver
   1096            #endif
   1097          }
   \   0000004C   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000050   3080BDE8           POP      {R4,R5,PC}       ;; return
   1098          
   1099          /*********************************************************************
   1100          *
   1101          *       _InitOnce
   1102          *
   1103          * Purpose:
   1104          *   Allocates a fixed block for the context of the driver
   1105          *
   1106          * Return value:
   1107          *   0 on success, 1 on error
   1108          */
   1109          static int _InitOnce(GUI_DEVICE * pDevice) {
   1110            if (pDevice->u.pContext == NULL) {
   1111              pDevice->u.pContext = GUI_ALLOC_GetFixedBlock(sizeof(DRIVER_CONTEXT));
   1112              GUI__memset((U8 *)pDevice->u.pContext, 0, sizeof(DRIVER_CONTEXT));
   1113            }
   1114            return pDevice->u.pContext ? 0 : 1;
   1115          }
   1116          
   1117          /*********************************************************************
   1118          *
   1119          *       _GetRect
   1120          */

   \                                 In section .text, align 4, keep-with-next
   1121          static void _GetRect(GUI_DEVICE * pDevice, LCD_RECT * pRect) {
   1122            DRIVER_CONTEXT * pContext;
   1123          
   1124            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetRect:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
   1125            pRect->x0 = 0;
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   B020C1E1           STRH     R2,[R1, #+0]
   1126            pRect->y0 = 0;
   \   0000000C   B220C1E1           STRH     R2,[R1, #+2]
   1127            pRect->x1 = pContext->vxSize - 1;
   \   00000010   0C2090E5           LDR      R2,[R0, #+12]
   \   00000014   012042E2           SUB      R2,R2,#+1
   \   00000018   B420C1E1           STRH     R2,[R1, #+4]
   1128            pRect->y1 = pContext->vySize - 1;
   \   0000001C   100090E5           LDR      R0,[R0, #+16]
   \   00000020   010040E2           SUB      R0,R0,#+1
   \   00000024   B600C1E1           STRH     R0,[R1, #+6]
   1129          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
   1130          
   1131          /*********************************************************************
   1132          *
   1133          *       _GetDevProp
   1134          */

   \                                 In section .text, align 4, keep-with-next
   1135          static I32 _GetDevProp(GUI_DEVICE * pDevice, int Index) {
   1136            DRIVER_CONTEXT * pContext;
   1137          
   1138            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1139            switch (Index) {
   \                     _GetDevProp:
   \   00000000   011041E2           SUB      R1,R1,#+1
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   0D0051E3           CMP      R1,#+13
   \   0000000C   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevProp_0:
   \   00000010   1B00008A           BHI      ??_GetDevProp_1
   \   00000014   0C0000EA           B        ??_GetDevProp_2
   \   00000018   0D0000EA           B        ??_GetDevProp_3
   \   0000001C   0E0000EA           B        ??_GetDevProp_4
   \   00000020   0F0000EA           B        ??_GetDevProp_5
   \   00000024   160000EA           B        ??_GetDevProp_1
   \   00000028   150000EA           B        ??_GetDevProp_1
   \   0000002C   140000EA           B        ??_GetDevProp_1
   \   00000030   0D0000EA           B        ??_GetDevProp_6
   \   00000034   0E0000EA           B        ??_GetDevProp_7
   \   00000038   0F0000EA           B        ??_GetDevProp_8
   \   0000003C   0E0000EA           B        ??_GetDevProp_8
   \   00000040   0D0000EA           B        ??_GetDevProp_8
   \   00000044   0A0000EA           B        ??_GetDevProp_7
   \   00000048   090000EA           B        ??_GetDevProp_7
   1140            case LCD_DEVCAP_XSIZE:
   1141              return pContext->xSize;
   \                     ??_GetDevProp_2:
   \   0000004C   040090E5           LDR      R0,[R0, #+4]
   \   00000050   1EFF2FE1           BX       LR
   1142            case LCD_DEVCAP_YSIZE:
   1143              return pContext->ySize;
   \                     ??_GetDevProp_3:
   \   00000054   080090E5           LDR      R0,[R0, #+8]
   \   00000058   1EFF2FE1           BX       LR
   1144            case LCD_DEVCAP_VXSIZE:
   1145              return pContext->vxSize;
   \                     ??_GetDevProp_4:
   \   0000005C   0C0090E5           LDR      R0,[R0, #+12]
   \   00000060   1EFF2FE1           BX       LR
   1146            case LCD_DEVCAP_VYSIZE:
   1147              return pContext->vySize;
   \                     ??_GetDevProp_5:
   \   00000064   100090E5           LDR      R0,[R0, #+16]
   \   00000068   1EFF2FE1           BX       LR
   1148            case LCD_DEVCAP_BITSPERPIXEL:
   1149              return 24;
   \                     ??_GetDevProp_6:
   \   0000006C   1800A0E3           MOV      R0,#+24
   \   00000070   1EFF2FE1           BX       LR
   1150            case LCD_DEVCAP_NUMCOLORS:
   1151              return 0;
   \                     ??_GetDevProp_7:
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   1EFF2FE1           BX       LR
   1152            case LCD_DEVCAP_XMAG:
   1153              return 1;
   \                     ??_GetDevProp_8:
   \   0000007C   0100A0E3           MOV      R0,#+1
   \   00000080   1EFF2FE1           BX       LR
   1154            case LCD_DEVCAP_YMAG:
   1155              return 1;
   1156            case LCD_DEVCAP_MIRROR_X:
   1157              return 1;
   1158            case LCD_DEVCAP_MIRROR_Y:
   1159              return 0;
   1160            case LCD_DEVCAP_SWAP_XY:
   1161              return 0;
   1162            }
   1163            return -1;
   \                     ??_GetDevProp_1:
   \   00000084   0000E0E3           MVN      R0,#+0
   \   00000088   1EFF2FE1           BX       LR               ;; return
   1164          }
   1165          
   1166          /*********************************************************************
   1167          *
   1168          *       _GetDevData
   1169          */

   \                                 In section .text, align 4, keep-with-next
   1170          static void * _GetDevData(GUI_DEVICE * pDevice, int Index) {
   1171            GUI_USE_PARA(pDevice);
   1172            switch (Index) {
   \                     _GetDevData:
   \   00000000   010051E3           CMP      R1,#+1
   \   00000004   0100001A           BNE      ??_GetDevData_0
   1173            #if GUI_SUPPORT_MEMDEV
   1174              case LCD_DEVDATA_MEMDEV:
   1175                return (void *)&GUI_MEMDEV_DEVICE_32;
   \   00000008   ........           LDR      R0,??DataTable16_1
   \   0000000C   1EFF2FE1           BX       LR
   1176            #endif
   1177            }
   1178            return NULL;
   \                     ??_GetDevData_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
   1179          }
   1180          
   1181          /*********************************************************************
   1182          *
   1183          *       Static code: Functions available by _GetDevFunc()
   1184          *
   1185          **********************************************************************
   1186          */
   1187          /*********************************************************************
   1188          *
   1189          *       _SetVRAMAddr
   1190          */

   \                                 In section .text, align 4, keep-with-next
   1191          static void _SetVRAMAddr(GUI_DEVICE * pDevice, void * pVRAM) {
   \                     _SetVRAMAddr:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1192            DRIVER_CONTEXT * pContext;
   1193            LCD_X_SETVRAMADDR_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {(void *)0}>`
   \              ....        
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   001091E5           LDR      R1,[R1, #+0]
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
   1194          
   1195            _InitOnce(pDevice);
   \   00000020   080094E5           LDR      R0,[R4, #+8]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0500001A           BNE      ??_SetVRAMAddr_0
   \   0000002C   2C00A0E3           MOV      R0,#+44
   \   00000030   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000034   080084E5           STR      R0,[R4, #+8]
   \   00000038   2C20A0E3           MOV      R2,#+44
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   ........           BL       GUI__memset
   1196            if (pDevice->u.pContext) {
   \                     ??_SetVRAMAddr_0:
   \   00000044   080094E5           LDR      R0,[R4, #+8]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0500000A           BEQ      ??_SetVRAMAddr_1
   1197              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1198              pContext->VRAMAddr = (U32)pVRAM;
   \   00000050   005080E5           STR      R5,[R0, #+0]
   1199              Data.pVRAM = pVRAM;
   \   00000054   00508DE5           STR      R5,[SP, #+0]
   1200              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVRAMADDR, (void *)&Data);
   \   00000058   0D20A0E1           MOV      R2,SP
   \   0000005C   0210A0E3           MOV      R1,#+2
   \   00000060   180094E5           LDR      R0,[R4, #+24]
   \   00000064   ........           BL       LCD_X_DisplayDriver
   1201            }
   1202            #ifdef WIN32
   1203              SIM_Lin_SetVRAMAddr(pDevice->LayerIndex, pVRAM);
   1204            #endif
   1205          }
   \                     ??_SetVRAMAddr_1:
   \   00000068   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000006C   3080BDE8           POP      {R4,R5,PC}       ;; return
   1206          
   1207          /*********************************************************************
   1208          *
   1209          *       _SetVSize
   1210          */

   \                                 In section .text, align 4, keep-with-next
   1211          static void _SetVSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetVSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1212            DRIVER_CONTEXT * pContext;
   1213          
   1214            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetVSize_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
   1215            if (pDevice->u.pContext) {
   \                     ??_SetVSize_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   1216              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1217              pContext->vxSize = xSize;
   \   0000003C   0C508015           STRNE    R5,[R0, #+12]
   1218              pContext->vySize = ySize;
   \   00000040   10608015           STRNE    R6,[R0, #+16]
   1219              pContext->vxSizePhys = xSize;
   \   00000044   14508015           STRNE    R5,[R0, #+20]
   1220            }
   1221            #ifdef WIN32
   1222              SIM_Lin_SetVRAMSize(pDevice->LayerIndex, xSize, ySize);
   1223            #endif
   1224          }
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1225          
   1226          /*********************************************************************
   1227          *
   1228          *       _SetSize
   1229          */

   \                                 In section .text, align 4, keep-with-next
   1230          static void _SetSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1231            DRIVER_CONTEXT * pContext;
   1232            LCD_X_SETSIZE_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_1`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
   1233          
   1234            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetSize_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
   1235            if (pDevice->u.pContext) {
   \                     ??_SetSize_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0A00000A           BEQ      ??_SetSize_1
   1236              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1237              if (pContext->vxSizePhys == 0) {
   \   0000005C   141090E5           LDR      R1,[R0, #+20]
   1238                pContext->vxSizePhys = xSize;
   1239              }
   1240              pContext->xSize = xSize;
   1241              pContext->ySize = ySize;
   1242              Data.xSize = xSize;
   1243              Data.ySize = ySize;
   1244              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETSIZE, (void *)&Data);
   \   00000060   0D20A0E1           MOV      R2,SP
   \   00000064   000051E3           CMP      R1,#+0
   \   00000068   14508005           STREQ    R5,[R0, #+20]
   \   0000006C   045080E5           STR      R5,[R0, #+4]
   \   00000070   086080E5           STR      R6,[R0, #+8]
   \   00000074   00508DE5           STR      R5,[SP, #+0]
   \   00000078   04608DE5           STR      R6,[SP, #+4]
   \   0000007C   0710A0E3           MOV      R1,#+7
   \   00000080   180094E5           LDR      R0,[R4, #+24]
   \   00000084   ........           BL       LCD_X_DisplayDriver
   1245            }
   1246          }
   \                     ??_SetSize_1:
   \   00000088   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   0000008C   7080BDE8           POP      {R4-R6,PC}       ;; return
   1247          
   1248          /*********************************************************************
   1249          *
   1250          *       _SetPos
   1251          */

   \                                 In section .text, align 4, keep-with-next
   1252          static void _SetPos(GUI_DEVICE * pDevice, int xPos, int yPos) {
   \                     _SetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1253            DRIVER_CONTEXT * pContext;
   1254            LCD_X_SETPOS_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_2`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
   1255          
   1256            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetPos_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
   1257            if (pDevice->u.pContext) {
   \                     ??_SetPos_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0700000A           BEQ      ??_SetPos_1
   1258              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1259              pContext->xPos = xPos;
   \   0000005C   185080E5           STR      R5,[R0, #+24]
   1260              pContext->yPos = yPos;
   \   00000060   1C6080E5           STR      R6,[R0, #+28]
   1261              Data.xPos = xPos;
   \   00000064   00508DE5           STR      R5,[SP, #+0]
   1262              Data.yPos = yPos;
   \   00000068   04608DE5           STR      R6,[SP, #+4]
   1263              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETPOS, (void *)&Data);
   \   0000006C   0D20A0E1           MOV      R2,SP
   \   00000070   0810A0E3           MOV      R1,#+8
   \   00000074   180094E5           LDR      R0,[R4, #+24]
   \   00000078   ........           BL       LCD_X_DisplayDriver
   1264            }
   1265          }
   \                     ??_SetPos_1:
   \   0000007C   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000080   7080BDE8           POP      {R4-R6,PC}       ;; return
   1266          
   1267          /*********************************************************************
   1268          *
   1269          *       _GetPos
   1270          */

   \                                 In section .text, align 4, keep-with-next
   1271          static void _GetPos(GUI_DEVICE * pDevice, int * pxPos, int * pyPos) {
   \                     _GetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1272            DRIVER_CONTEXT * pContext;
   1273          
   1274            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_GetPos_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
   1275            if (pDevice->u.pContext) {
   \                     ??_GetPos_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0300000A           BEQ      ??_GetPos_1
   1276              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1277              *pxPos = pContext->xPos;
   \   00000040   181090E5           LDR      R1,[R0, #+24]
   \   00000044   001085E5           STR      R1,[R5, #+0]
   1278              *pyPos = pContext->yPos;
   \   00000048   1C0090E5           LDR      R0,[R0, #+28]
   \   0000004C   000086E5           STR      R0,[R6, #+0]
   1279            }
   1280          }
   \                     ??_GetPos_1:
   \   00000050   7080BDE8           POP      {R4-R6,PC}       ;; return
   1281          
   1282          /*********************************************************************
   1283          *
   1284          *       _SetAlpha
   1285          */

   \                                 In section .text, align 4, keep-with-next
   1286          static void _SetAlpha(GUI_DEVICE * pDevice, int Alpha) {
   \                     _SetAlpha:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1287            DRIVER_CONTEXT * pContext;
   1288            LCD_X_SETALPHA_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_3`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
   1289          
   1290            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetAlpha_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
   1291            if (pDevice->u.pContext) {
   \                     ??_SetAlpha_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetAlpha_1
   1292              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1293              pContext->Alpha = Alpha;
   \   0000004C   205080E5           STR      R5,[R0, #+32]
   1294              Data.Alpha = Alpha;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
   1295              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHA, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0A10A0E3           MOV      R1,#+10
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
   1296            }
   1297          }
   \                     ??_SetAlpha_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
   1298          
   1299          /*********************************************************************
   1300          *
   1301          *       _SetVis
   1302          */

   \                                 In section .text, align 4, keep-with-next
   1303          static void _SetVis(GUI_DEVICE * pDevice, int OnOff) {
   \                     _SetVis:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1304            DRIVER_CONTEXT * pContext;
   1305            LCD_X_SETVIS_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_4`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
   1306          
   1307            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetVis_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
   1308            if (pDevice->u.pContext) {
   \                     ??_SetVis_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetVis_1
   1309              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1310              pContext->IsVisible = OnOff;
   \   0000004C   245080E5           STR      R5,[R0, #+36]
   1311              Data.OnOff = OnOff;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
   1312              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVIS, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0910A0E3           MOV      R1,#+9
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
   1313            }
   1314          }
   \                     ??_SetVis_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
   1315          
   1316          /*********************************************************************
   1317          *
   1318          *       _Init
   1319          */

   \                                 In section .text, align 4, keep-with-next
   1320          static int  _Init(GUI_DEVICE * pDevice) {
   \                     _Init:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1321            int r;
   1322          
   1323            r = _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0500001A           BNE      ??_Init_0
   \   00000018   2C00A0E3           MOV      R0,#+44
   \   0000001C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000020   080084E5           STR      R0,[R4, #+8]
   \   00000024   2C20A0E3           MOV      R2,#+44
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   ........           BL       GUI__memset
   \                     ??_Init_0:
   \   00000030   080094E5           LDR      R0,[R4, #+8]
   1324            r |= LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_INITCONTROLLER, NULL);
   1325            return r;
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0150A003           MOVEQ    R5,#+1
   \   00000040   0050A013           MOVNE    R5,#+0
   \   00000044   0110A0E3           MOV      R1,#+1
   \   00000048   180094E5           LDR      R0,[R4, #+24]
   \   0000004C   ........           BL       LCD_X_DisplayDriver
   \   00000050   050080E1           ORR      R0,R0,R5
   \   00000054   04D08DE2           ADD      SP,SP,#+4
   \   00000058   3080BDE8           POP      {R4,R5,PC}       ;; return
   1326          }
   1327          
   1328          /*********************************************************************
   1329          *
   1330          *       _On
   1331          */

   \                                 In section .text, align 4, keep-with-next
   1332          static void _On (GUI_DEVICE * pDevice) {
   1333            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_ON, NULL);
   \                     _On:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0510A0E3           MOV      R1,#+5
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
   1334          }
   1335          
   1336          /*********************************************************************
   1337          *
   1338          *       _Off
   1339          */

   \                                 In section .text, align 4, keep-with-next
   1340          static void _Off (GUI_DEVICE * pDevice) {
   1341            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_OFF, NULL);
   \                     _Off:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0610A0E3           MOV      R1,#+6
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
   1342          }
   1343          
   1344          /*********************************************************************
   1345          *
   1346          *       _SetLUTEntry
   1347          */

   \                                 In section .text, align 4, keep-with-next
   1348          static void _SetLUTEntry(GUI_DEVICE * pDevice, U8 Pos, LCD_COLOR Color) {
   \                     _SetLUTEntry:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1349            LCD_X_SETLUTENTRY_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
   1350          
   1351            Data.Pos   = Pos;
   \   0000001C   0410CDE5           STRB     R1,[SP, #+4]
   1352            Data.Color = Color;
   \   00000020   00208DE5           STR      R2,[SP, #+0]
   1353            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETLUTENTRY, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0410A0E3           MOV      R1,#+4
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
   1354          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
   1355          
   1356          /*********************************************************************
   1357          *
   1358          *       _SetAlphaMode
   1359          */

   \                                 In section .text, align 4, keep-with-next
   1360          static void _SetAlphaMode(GUI_DEVICE * pDevice, int AlphaMode) {
   \                     _SetAlphaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1361            LCD_X_SETALPHAMODE_INFO Data = {0};
   1362          
   1363            Data.AlphaMode = AlphaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
   1364            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0B10A0E3           MOV      R1,#+11
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
   1365          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1366          
   1367          /*********************************************************************
   1368          *
   1369          *       _SetChromaMode
   1370          */

   \                                 In section .text, align 4, keep-with-next
   1371          static void _SetChromaMode(GUI_DEVICE * pDevice, int ChromaMode) {
   \                     _SetChromaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1372            LCD_X_SETCHROMAMODE_INFO Data = {0};
   1373          
   1374            Data.ChromaMode = ChromaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
   1375            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0C10A0E3           MOV      R1,#+12
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
   1376          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1377          
   1378          /*********************************************************************
   1379          *
   1380          *       _SetChroma
   1381          */

   \                                 In section .text, align 4, keep-with-next
   1382          static void _SetChroma(GUI_DEVICE * pDevice, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax) {
   \                     _SetChroma:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1383            LCD_X_SETCHROMA_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>_1`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
   1384          
   1385            Data.ChromaMin = ChromaMin;
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
   1386            Data.ChromaMax = ChromaMax;
   \   00000020   04208DE5           STR      R2,[SP, #+4]
   1387            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMA, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0D10A0E3           MOV      R1,#+13
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
   1388          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
   1389          
   1390          /*********************************************************************
   1391          *
   1392          *       _SetFunc
   1393          */

   \                                 In section .text, align 4, keep-with-next
   1394          static void _SetFunc(GUI_DEVICE * pDevice, int Index, void (* pFunc)(void)) {
   \                     _SetFunc:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1395            DRIVER_CONTEXT * pContext;
   1396          
   1397            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetFunc_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
   1398            if (pDevice->u.pContext) {
   \                     ??_SetFunc_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0100000A           BEQ      ??_SetFunc_1
   1399              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1400              switch (Index) {
   \   00000040   170055E3           CMP      R5,#+23
   1401              case LCD_DEVFUNC_FILLRECT:
   1402                pContext->pfFillRect = (void (*)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex))pFunc;
   \   00000044   28608005           STREQ    R6,[R0, #+40]
   1403                break;
   1404              }
   1405            }
   1406          }
   \                     ??_SetFunc_1:
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1407          
   1408          /*********************************************************************
   1409          *
   1410          *       _GetDevFunc
   1411          */

   \                                 In section .text, align 4, keep-with-next
   1412          static void (* _GetDevFunc(GUI_DEVICE ** ppDevice, int Index))(void) {
   1413            GUI_USE_PARA(ppDevice);
   1414            switch (Index) {
   \                     _GetDevFunc:
   \   00000000   021041E2           SUB      R1,R1,#+2
   \   00000004   140051E3           CMP      R1,#+20
   \   00000008   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevFunc_0:
   \   0000000C   3200008A           BHI      ??_GetDevFunc_1
   \   00000010   1D0000EA           B        ??_GetDevFunc_2
   \   00000014   180000EA           B        ??_GetDevFunc_3
   \   00000018   190000EA           B        ??_GetDevFunc_4
   \   0000001C   2E0000EA           B        ??_GetDevFunc_1
   \   00000020   1B0000EA           B        ??_GetDevFunc_5
   \   00000024   2C0000EA           B        ??_GetDevFunc_1
   \   00000028   2B0000EA           B        ??_GetDevFunc_1
   \   0000002C   0C0000EA           B        ??_GetDevFunc_6
   \   00000030   0D0000EA           B        ??_GetDevFunc_7
   \   00000034   0E0000EA           B        ??_GetDevFunc_8
   \   00000038   170000EA           B        ??_GetDevFunc_9
   \   0000003C   260000EA           B        ??_GetDevFunc_1
   \   00000040   170000EA           B        ??_GetDevFunc_10
   \   00000044   180000EA           B        ??_GetDevFunc_11
   \   00000048   190000EA           B        ??_GetDevFunc_12
   \   0000004C   220000EA           B        ??_GetDevFunc_1
   \   00000050   210000EA           B        ??_GetDevFunc_1
   \   00000054   180000EA           B        ??_GetDevFunc_13
   \   00000058   190000EA           B        ??_GetDevFunc_14
   \   0000005C   1A0000EA           B        ??_GetDevFunc_15
   \   00000060   1B0000EA           B        ??_GetDevFunc_16
   1415            case LCD_DEVFUNC_SET_VRAM_ADDR:
   1416              return (void (*)(void))_SetVRAMAddr;
   \                     ??_GetDevFunc_6:
   \   00000064   ........           LDR      R0,??DataTable16_2
   \   00000068   1EFF2FE1           BX       LR
   1417            case LCD_DEVFUNC_SET_VSIZE:
   1418              return (void (*)(void))_SetVSize;
   \                     ??_GetDevFunc_7:
   \   0000006C   ........           LDR      R0,??DataTable16_3
   \   00000070   1EFF2FE1           BX       LR
   1419            case LCD_DEVFUNC_SET_SIZE:
   1420              return (void (*)(void))_SetSize;
   \                     ??_GetDevFunc_8:
   \   00000074   ........           LDR      R0,??DataTable16_4
   \   00000078   1EFF2FE1           BX       LR
   1421            case LCD_DEVFUNC_SETPOS:
   1422              return (void (*)(void))_SetPos;
   \                     ??_GetDevFunc_3:
   \   0000007C   ........           LDR      R0,??DataTable16_5
   \   00000080   1EFF2FE1           BX       LR
   1423            case LCD_DEVFUNC_GETPOS:
   1424              return (void (*)(void))_GetPos;
   \                     ??_GetDevFunc_4:
   \   00000084   ........           LDR      R0,??DataTable16_6
   \   00000088   1EFF2FE1           BX       LR
   1425            case LCD_DEVFUNC_SETALPHA:
   1426              return (void (*)(void))_SetAlpha;
   \                     ??_GetDevFunc_2:
   \   0000008C   ........           LDR      R0,??DataTable16_7
   \   00000090   1EFF2FE1           BX       LR
   1427            case LCD_DEVFUNC_SETVIS:
   1428              return (void (*)(void))_SetVis;
   \                     ??_GetDevFunc_5:
   \   00000094   ........           LDR      R0,??DataTable16_8
   \   00000098   1EFF2FE1           BX       LR
   1429            case LCD_DEVFUNC_INIT:
   1430              return (void (*)(void))_Init;
   \                     ??_GetDevFunc_9:
   \   0000009C   ........           LDR      R0,??DataTable16_9
   \   000000A0   1EFF2FE1           BX       LR
   1431            case LCD_DEVFUNC_ON:
   1432              return (void (*)(void))_On;
   \                     ??_GetDevFunc_10:
   \   000000A4   ........           LDR      R0,??DataTable16_10
   \   000000A8   1EFF2FE1           BX       LR
   1433            case LCD_DEVFUNC_OFF:
   1434              return (void (*)(void))_Off;
   \                     ??_GetDevFunc_11:
   \   000000AC   ........           LDR      R0,??DataTable16_11
   \   000000B0   1EFF2FE1           BX       LR
   1435            case LCD_DEVFUNC_SETLUTENTRY:
   1436              return (void (*)(void))_SetLUTEntry;
   \                     ??_GetDevFunc_12:
   \   000000B4   ........           LDR      R0,??DataTable16_12
   \   000000B8   1EFF2FE1           BX       LR
   1437          
   1438            case LCD_DEVFUNC_ALPHAMODE:
   1439              return (void (*)(void))_SetAlphaMode;
   \                     ??_GetDevFunc_13:
   \   000000BC   ........           LDR      R0,??DataTable16_13
   \   000000C0   1EFF2FE1           BX       LR
   1440            case LCD_DEVFUNC_CHROMAMODE:
   1441              return (void (*)(void))_SetChromaMode;
   \                     ??_GetDevFunc_14:
   \   000000C4   ........           LDR      R0,??DataTable16_14
   \   000000C8   1EFF2FE1           BX       LR
   1442            case LCD_DEVFUNC_CHROMA:
   1443              return (void (*)(void))_SetChroma;
   \                     ??_GetDevFunc_15:
   \   000000CC   ........           LDR      R0,??DataTable16_15
   \   000000D0   1EFF2FE1           BX       LR
   1444            
   1445            case LCD_DEVFUNC_SETFUNC:
   1446              return (void (*)(void))_SetFunc;
   \                     ??_GetDevFunc_16:
   \   000000D4   ........           LDR      R0,??DataTable16_16
   \   000000D8   1EFF2FE1           BX       LR
   1447            }
   1448            return NULL;
   \                     ??_GetDevFunc_1:
   \   000000DC   0000A0E3           MOV      R0,#+0
   \   000000E0   1EFF2FE1           BX       LR               ;; return
   1449          }
   1450          
   1451          /*********************************************************************
   1452          *
   1453          *       Public data
   1454          *
   1455          **********************************************************************
   1456          */
   1457          /*********************************************************************
   1458          *
   1459          *       GUI_DEVICE_API structure
   1460          */

   \                                 In section .rodata, align 4, keep-with-next
   1461          const GUI_DEVICE_API GUIDRV_Lin_OX_24_API = {
   \                     GUIDRV_Lin_OX_24_API:
   \   00000000                      ; Initializer data, 52 bytes
   \   00000000   00000000....       DC32 0, _DrawBitmap, _DrawHLine, _DrawVLine, _FillRect, _GetPixelIndex, _SetPixelIndex, _XorPixel, _SetOrg, _GetDevFunc
   \              ............
   \              ............
   \              ............
   \              ............
   \              ............
   \              ........    
   \   00000028   ............       DC32 _GetDevProp, _GetDevData, _GetRect
   \              ............

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   ........           DC32     LCD_aMirror

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   ........           DC32     GUI_MEMDEV_DEVICE_32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   ........           DC32     _SetVRAMAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   ........           DC32     _SetVSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   ........           DC32     _SetSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   ........           DC32     _SetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   ........           DC32     _GetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   ........           DC32     _SetAlpha

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   ........           DC32     _SetVis

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   ........           DC32     _Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   ........           DC32     _On

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   ........           DC32     _Off

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   ........           DC32     _SetLUTEntry

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   ........           DC32     _SetAlphaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   ........           DC32     _SetChromaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   ........           DC32     _SetChroma

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \   00000000   ........           DC32     _SetFunc

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {(void *)0}>`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_2`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_3`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_4`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0
   1462            //
   1463            // Data
   1464            //
   1465            DEVICE_CLASS_DRIVER,
   1466            //
   1467            // Drawing functions
   1468            //
   1469            _DrawBitmap,
   1470            _DrawHLine,
   1471            _DrawVLine,
   1472            _FillRect,
   1473            _GetPixelIndex,
   1474            _SetPixelIndex,
   1475            _XorPixel,
   1476            //
   1477            // Set origin
   1478            //
   1479            _SetOrg,
   1480            //
   1481            // Request information
   1482            //
   1483            _GetDevFunc,
   1484            _GetDevProp,
   1485            _GetDevData,
   1486            _GetRect,
   1487          };
   1488          
   1489          #else
   1490          
   1491          void GUIDRV_Lin_OX_24_C(void);   // Avoid empty object files
   1492          void GUIDRV_Lin_OX_24_C(void) {}
   1493          
   1494          #endif
   1495          
   1496          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function          .cstack
     --------          -------
     _DrawBitLine1BPP      48
     _DrawBitLine2BPP      40
     _DrawBitLine32BPP     16
     _DrawBitLine4BPP      40
     _DrawBitLine8BPP      32
     _DrawBitmap           56
     _DrawHLine            24
     _DrawVLine            24
     _FillRect             24
     _GetDevData            0
     _GetDevFunc            0
     _GetDevProp            0
     _GetPixelIndex         4
     _GetPos               16
     _GetRect               0
     _Init                 16
     _Off                   8
     _On                    8
     _SetAlpha             16
     _SetAlphaMode          8
     _SetChroma            24
     _SetChromaMode         8
     _SetFunc              16
     _SetLUTEntry          24
     _SetOrg               24
     _SetPixelIndex         8
     _SetPos               24
     _SetSize              24
     _SetVRAMAddr          16
     _SetVSize             16
     _SetVis               16
     _XorPixel             24


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     _SetPixelIndex           208
     _GetPixelIndex           152
     _XorPixel                196
     _DrawHLine               540
     _DrawVLine               132
     _FillRect                 68
     _DrawBitLine1BPP        2248
     _DrawBitLine2BPP         412
     _DrawBitLine4BPP         412
     _DrawBitLine8BPP         604
     _DrawBitLine32BPP        484
     _DrawBitmap             1016
     _SetOrg                   84
     _GetRect                  44
     _GetDevProp              140
     _GetDevData               24
     _SetVRAMAddr             112
     _SetVSize                 76
     _SetSize                 144
     _SetPos                  132
     _GetPos                   84
     _SetAlpha                108
     _SetVis                  108
     _Init                     92
     _On                       16
     _Off                      16
     _SetLUTEntry              60
     _SetAlphaMode             36
     _SetChromaMode            36
     _SetChroma                60
     _SetFunc                  76
     _GetDevFunc              228
     GUIDRV_Lin_OX_24_API      52
     ??DataTable13              4
     ??DataTable13_1            4
     ??DataTable14              4
     ??DataTable16              4
     ??DataTable16_1            4
     ??DataTable16_2            4
     ??DataTable16_3            4
     ??DataTable16_4            4
     ??DataTable16_5            4
     ??DataTable16_6            4
     ??DataTable16_7            4
     ??DataTable16_8            4
     ??DataTable16_9            4
     ??DataTable16_10           4
     ??DataTable16_11           4
     ??DataTable16_12           4
     ??DataTable16_13           4
     ??DataTable16_14           4
     ??DataTable16_15           4
     ??DataTable16_16           4
     ?<Constant {0}>            8
     ?<Constant {(void *)0}>    4
     ?<Constant {0}>_1          8
     ?<Constant {0}>_2          8
     ?<Constant {0}>_3          4
     ?<Constant {0}>_4          4
     ?<Constant {0L}>           8
     ?<Constant {0L}>_1         8

 
    52 bytes in section .rodata
 8 280 bytes in section .text
 
 8 280 bytes of CODE  memory
    52 bytes of CONST memory

Errors: none
Warnings: none
