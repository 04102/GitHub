###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     14/Jul/2015  19:00:18 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\FS\FS_Volume.c                          #
#    Command line =  C:\DUII\TargetHW\FS\FS_Volume.c -D DEBUG=1 -D            #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D                   #
#                    XIGNORE_TEMPERATURE -D BUILD_DEBUG_PORT -D PROFILER      #
#                    -lCN C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Li #
#                    st\ -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\ #
#                    Obj\ --debug --endian=little --cpu=ARM926EJ-S -e         #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\FS #
#                    _Volume.lst                                              #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\FS_ #
#                    Volume.o                                                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\FS\FS_Volume.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          **** emFile file system for embedded applications ****
     13          emFile is protected by international copyright laws. Knowledge of the
     14          source code may not be used to write a similar product. This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : FS_Volume.c
     19          Purpose     : API functions for handling Volumes
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          /*********************************************************************
     24          *
     25          *             #include Section
     26          *
     27          **********************************************************************
     28          */
     29          
     30          #include "FS_Int.h"
     31          
     32          /*********************************************************************
     33          *
     34          *       Static code
     35          *
     36          **********************************************************************
     37          */
     38          
     39          
     40          /*********************************************************************
     41          *
     42          *       _GetVolumeInfoEx
     43          *
     44          *  Description:
     45          *    Internal function. Get volume information
     46          *
     47          *  Parameters:
     48          *    sVolume            - The volume name
     49          *    pInfo              - A pointer to FS_DISK_INFO. Volume information
     50          *                         will be filled in
     51          *
     52          *  Return value:
     53          *    0                  - OK
     54          *   -1                  - Error. Failed to get volume information
     55          */
     56          static int _GetVolumeInfoEx(FS_VOLUME  * pVolume, FS_DISK_INFO * pInfo, int Flags) {
     57            int r;
     58          
     59            r = -1;
     60            if ((FS__AutoMount(pVolume) & FS_MOUNT_R) == FS_MOUNT_R) {
     61              FS_LOCK_DRIVER(&pVolume->Partition.Device);
     62              r = FS_GET_DISKINFO(pVolume, pInfo, Flags);
     63              FS_UNLOCK_DRIVER(&pVolume->Partition.Device);
     64              if (r != -1) {
     65                r = 0;      /* OK - volume info retrieved successfully */
     66              }
     67            }
     68            return r;
     69          }
     70          
     71          /*********************************************************************
     72          *
     73          *       Public code, internal
     74          *
     75          **********************************************************************
     76          */
     77          
     78          
     79          
     80          /*********************************************************************
     81          *
     82          *       FS__GetVolumeInfoEx
     83          *
     84          *  Description:
     85          *    Internal function. Get volume information
     86          *
     87          *  Parameters:
     88          *    sVolume            - The volume name
     89          *    pInfo              - A pointer to FS_DISK_INFO. Volume information
     90          *                         will be filled in
     91          *
     92          *  Return value:
     93          *    0                  - OK
     94          *   -1                  - Error. Failed to get volume information
     95          */

   \                                 In section .text, align 4, keep-with-next
     96          int FS__GetVolumeInfoEx(const char  * sVolume, FS_DISK_INFO * pInfo, int Flags) {
   \                     FS__GetVolumeInfoEx:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0140A0E1           MOV      R4,R1
     97            FS_VOLUME*  pVolume;
     98            int r;
     99            r = -1;
    100          
    101            if (sVolume == NULL || pInfo == NULL) {
   \   00000008   000050E3           CMP      R0,#+0
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   0060E0E3           MVN      R6,#+0
   \   00000014   00005413           CMPNE    R4,#+0
   \   00000018   2100000A           BEQ      ??FS__GetVolumeInfoEx_0
    102              return -1;   /* Error */
    103            }
    104            pVolume = FS__FindVolume(sVolume, NULL);
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   ........           BL       FS__FindVolume
   \   00000024   0070B0E1           MOVS     R7,R0
    105            if (pVolume) {
   \   00000028   1D00000A           BEQ      ??FS__GetVolumeInfoEx_0
    106              r = _GetVolumeInfoEx(pVolume, pInfo, Flags);
   \   0000002C   5D00D7E5           LDRB     R0,[R7, #+93]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   1100001A           BNE      ??FS__GetVolumeInfoEx_1
   \   00000038   5E80D7E5           LDRB     R8,[R7, #+94]
   \   0000003C   000058E3           CMP      R8,#+0
   \   00000040   1700000A           BEQ      ??FS__GetVolumeInfoEx_0
   \   00000044   0700A0E1           MOV      R0,R7
   \   00000048   ........           BL       FS_LB_GetStatus
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0900000A           BEQ      ??FS__GetVolumeInfoEx_2
   \   00000054   0700A0E1           MOV      R0,R7
   \   00000058   ........           BL       FS_LB_InitMediumIfRequired
   \   0000005C   0700A0E1           MOV      R0,R7
   \   00000060   ........           BL       FS__LocatePartition
   \   00000064   0700A0E1           MOV      R0,R7
   \   00000068   ........           BL       FS_FAT_CheckBPB
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   5D80C715           STRBNE   R8,[R7, #+93]
   \   00000074   5D00D7E5           LDRB     R0,[R7, #+93]
   \   00000078   000000EA           B        ??FS__GetVolumeInfoEx_1
   \                     ??FS__GetVolumeInfoEx_2:
   \   0000007C   0600A0E1           MOV      R0,R6
   \                     ??FS__GetVolumeInfoEx_1:
   \   00000080   010010E3           TST      R0,#0x1
   \   00000084   0600000A           BEQ      ??FS__GetVolumeInfoEx_0
   \   00000088   0520A0E1           MOV      R2,R5
   \   0000008C   0410A0E1           MOV      R1,R4
   \   00000090   0700A0E1           MOV      R0,R7
   \   00000094   ........           BL       FS_FAT_GetDiskInfo
   \   00000098   0060A0E1           MOV      R6,R0
   \   0000009C   010076E3           CMN      R6,#+1
   \   000000A0   0060A013           MOVNE    R6,#+0
    107            }
    108            return r;
   \                     ??FS__GetVolumeInfoEx_0:
   \   000000A4   0600A0E1           MOV      R0,R6
   \   000000A8   F081BDE8           POP      {R4-R8,PC}       ;; return
    109          }
    110          
    111          /*********************************************************************
    112          *
    113          *       FS__GetVolumeInfo
    114          *
    115          *  Description:
    116          *    Internal function. Get volume information
    117          *
    118          *  Parameters:
    119          *    sVolume            - The volume name
    120          *    pInfo              - A pointer to FS_DISK_INFO. Volume information
    121          *                         will be filled in
    122          *
    123          *  Return value:
    124          *    0                  - OK
    125          *   -1                  - Error. Failed to get volume information
    126          */

   \                                 In section .text, align 4, keep-with-next
    127          int FS__GetVolumeInfo(const char * sVolume, FS_DISK_INFO * pInfo) {
    128            int r;
    129          
    130            r = FS__GetVolumeInfoEx(sVolume, pInfo, FS_DISKINFO_FLAG_USE_FREE_SPACE);
    131            return r;
   \                     FS__GetVolumeInfo:
   \   00000000   0120A0E3           MOV      R2,#+1
   \   00000004   ........           B        FS__GetVolumeInfoEx  ;; tailcall
    132          }
    133          
    134          
    135          /*********************************************************************
    136          *
    137          *       _Mount
    138          *
    139          *  Description:
    140          *    If volume is not yet mounted, try to mount it.
    141          *
    142          *  Parameters:
    143          *    MountType
    144          *    pVolume       Volume to mount. Must be valid, may not be NULL.
    145          *
    146          *  Return value:
    147          *    == 0               - Volume is not mounted.
    148          *    == 1 (FS_MOUNT_R)  - Volume is mounted read only.
    149          *    == 3 (FS_MOUNT_RW) - Volume is mounted read/write.
    150          *    == -1              - Error, Volume can not be mounted.
    151          */
    152          static int _Mount(FS_VOLUME * pVolume, U8 MountType) {
    153            int Status;
    154            FS_DEVICE * pDevice;
    155          
    156            pDevice = &pVolume->Partition.Device;
    157            //
    158            //  Check if the media is accessible.
    159            //
    160            Status = FS_LB_GetStatus(pDevice);
    161            if (Status != FS_MEDIA_NOT_PRESENT) {
    162              FS_LB_InitMediumIfRequired(pDevice);
    163              //
    164              // Check first if there is a partition on the volume.
    165              //
    166              FS__LocatePartition(pVolume);
    167              //
    168              //  Mount the file system
    169              //
    170              if (FS_CHECK_INFOSECTOR(pVolume)) {
    171                pVolume->IsMounted = MountType;
    172              }
    173            } else {
    174              FS_DEBUG_ERROROUT((FS_MTYPE_API, "Error: _Mount could not mount volume.\n"));
    175              return -1;
    176            }
    177            //
    178            // Mount the journal if necessary.
    179            //
    180            FS_JOURNAL_MOUNT(pVolume);
    181            return pVolume->IsMounted;
    182          }
    183          
    184          /*********************************************************************
    185          *
    186          *       FS__MountNL
    187          *
    188          *  Description:
    189          *    FS internal function.
    190          *    If volume is not yet mounted, try to mount it.
    191          *
    192          *  Parameters:
    193          *    pVolume       Volume to mount. Must be valid, may not be NULL.
    194          *
    195          *  Return value:
    196          *    == 0               - Volume is not mounted.
    197          *    == 1 (FS_MOUNT_R)  - Volume is mounted read only.
    198          *    == 3 (FS_MOUNT_RW) - Volume is mounted read/write.
    199          *    == -1              - Error, Volume can not be mounted.
    200          */

   \                                 In section .text, align 4, keep-with-next
    201          int FS__MountNL(FS_VOLUME * pVolume, U8 MountType) {
   \                     FS__MountNL:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    202            if (pVolume->IsMounted == 0) {
   \   00000008   5D00D4E5           LDRB     R0,[R4, #+93]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0E00001A           BNE      ??FS__MountNL_0
    203              //
    204              //  Shall we auto mount?
    205              //
    206              if (MountType != 0) {
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   0C00000A           BEQ      ??FS__MountNL_0
    207                if (_Mount(pVolume, MountType) <= 0) {
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       FS_LB_GetStatus
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0E00000A           BEQ      ??FS__MountNL_1
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       FS_LB_InitMediumIfRequired
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       FS__LocatePartition
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       FS_FAT_CheckBPB
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0300000A           BEQ      ??FS__MountNL_2
   \   00000054   5D50C4E5           STRB     R5,[R4, #+93]
    208                  return -1;
    209                }
    210              }
    211            }
    212            return pVolume->IsMounted;
   \                     ??FS__MountNL_0:
   \   00000058   5D00D4E5           LDRB     R0,[R4, #+93]
   \                     ??FS__MountNL_3:
   \   0000005C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000060   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??FS__MountNL_2:
   \   00000064   5D00D4E5           LDRB     R0,[R4, #+93]
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   F9FFFF1A           BNE      ??FS__MountNL_0
   \                     ??FS__MountNL_1:
   \   00000070   0000E0E3           MVN      R0,#+0
   \   00000074   F8FFFFEA           B        ??FS__MountNL_3
    213          }
    214          
    215          /*********************************************************************
    216          *
    217          *       FS__Mount
    218          *
    219          *  Description:
    220          *    FS internal function.
    221          *    If volume is not yet mounted, try to mount it.
    222          *
    223          *  Parameters:
    224          *    pVolume       Volume to mount. Must be valid, may not be NULL.
    225          *    MountType     FS_MOUNT_R (1) or FS_MOUNT_RW (3)
    226          *
    227          *  Return value:
    228          *    == 0               - Volume is not mounted.
    229          *    == 1 (FS_MOUNT_R)  - Volume is mounted read only.
    230          *    == 3 (FS_MOUNT_RW) - Volume is mounted read/write.
    231          *    == -1              - Error, Volume can not be mounted.
    232          */

   \                                 In section .text, align 4, keep-with-next
    233          int FS__Mount(FS_VOLUME * pVolume, U8 MountType) {
   \                     FS__Mount:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    234            int r;
    235            FS_DEVICE * pDevice;
    236          
    237            FS_LOCK_SYS();
    238            pDevice = &pVolume->Partition.Device;
    239            FS_UNLOCK_SYS();
    240            FS_USE_PARA(pDevice);
    241            FS_LOCK_DRIVER(pDevice);
    242            r = FS__MountNL(pVolume, MountType);
   \   00000008   5D00D4E5           LDRB     R0,[R4, #+93]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0E00001A           BNE      ??FS__Mount_0
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   0C00000A           BEQ      ??FS__Mount_0
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       FS_LB_GetStatus
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0E00000A           BEQ      ??FS__Mount_1
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       FS_LB_InitMediumIfRequired
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       FS__LocatePartition
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       FS_FAT_CheckBPB
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0300000A           BEQ      ??FS__Mount_2
   \   00000054   5D50C4E5           STRB     R5,[R4, #+93]
   \                     ??FS__Mount_0:
   \   00000058   5D00D4E5           LDRB     R0,[R4, #+93]
    243            FS_UNLOCK_DRIVER(pDevice);
    244            return r;
   \                     ??FS__Mount_3:
   \   0000005C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000060   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??FS__Mount_2:
   \   00000064   5D00D4E5           LDRB     R0,[R4, #+93]
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   F9FFFF1A           BNE      ??FS__Mount_0
   \                     ??FS__Mount_1:
   \   00000070   0000E0E3           MVN      R0,#+0
   \   00000074   F8FFFFEA           B        ??FS__Mount_3
    245          }
    246          
    247          
    248          /*********************************************************************
    249          *
    250          *       FS__AutoMount
    251          *
    252          *  Description:
    253          *    If volume is not yet mounted, try to mount it if allowed.
    254          *
    255          *  Parameters:
    256          *    pVolume       Volume to mount. Must be valid, may not be NULL.
    257          *
    258          *  Return value:
    259          *    == 0               - Volume is not mounted.
    260          *    == 1 (FS_MOUNT_R)  - Volume is mounted read only.
    261          *    == 3 (FS_MOUNT_RW) - Volume is mounted read/write.
    262          *    == -1              - Error, Volume can not be mounted.
    263          */

   \                                 In section .text, align 4, keep-with-next
    264          int FS__AutoMount(FS_VOLUME * pVolume) {
   \                     FS__AutoMount:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    265            int r;
    266            FS_DEVICE * pDevice;
    267          
    268            r = pVolume->IsMounted;
   \   00000008   5D00D4E5           LDRB     R0,[R4, #+93]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
    269            if (r) {
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   1100001A           BNE      ??FS__AutoMount_0
    270              return r;
    271            }
    272            if (pVolume->AllowAutoMount == 0) {
   \   00000018   5E50D4E5           LDRB     R5,[R4, #+94]
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   0E00000A           BEQ      ??FS__AutoMount_0
    273              return 0;
    274            }
    275            //
    276            // Not yet mounted, automount allowed. Let's try to mount.
    277            //
    278            pDevice = &pVolume->Partition.Device;
    279            FS_USE_PARA(pDevice);
    280            FS_LOCK_DRIVER(pDevice);
    281            r = _Mount(pVolume, pVolume->AllowAutoMount);
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       FS_LB_GetStatus
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0900000A           BEQ      ??FS__AutoMount_1
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       FS_LB_InitMediumIfRequired
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       FS__LocatePartition
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       FS_FAT_CheckBPB
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   5D50C415           STRBNE   R5,[R4, #+93]
   \   00000054   5D00D4E5           LDRB     R0,[R4, #+93]
   \   00000058   000000EA           B        ??FS__AutoMount_0
   \                     ??FS__AutoMount_1:
   \   0000005C   0000E0E3           MVN      R0,#+0
    282            FS_UNLOCK_DRIVER(pDevice);
    283            return r;
   \                     ??FS__AutoMount_0:
   \   00000060   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000064   3080BDE8           POP      {R4,R5,PC}       ;; return
    284          }
    285          
    286          /*********************************************************************
    287          *
    288          *       FS__AutoMountNL
    289          *
    290          *  Description:
    291          *    If volume is not yet mounted, try to mount it if allowed.
    292          *    This function does not lock.
    293          *
    294          *  Parameters:
    295          *    pVolume       Volume to mount. Must be valid, may not be NULL.
    296          *
    297          *  Return value:
    298          *    == 0               - Volume is not mounted.
    299          *    == 1 (FS_MOUNT_R)  - Volume is mounted read only.
    300          *    == 3 (FS_MOUNT_RW) - Volume is mounted read/write.
    301          *    == -1              - Error, Volume can not be mounted.
    302          */

   \                                 In section .text, align 4, keep-with-next
    303          int FS__AutoMountNL(FS_VOLUME * pVolume) {
   \                     FS__AutoMountNL:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    304            int r;
    305          
    306            r = pVolume->IsMounted;
   \   00000008   5D00D4E5           LDRB     R0,[R4, #+93]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
    307            if (r) {
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   1100001A           BNE      ??FS__AutoMountNL_0
    308              return r;
    309            }
    310            if (pVolume->AllowAutoMount == 0) {
   \   00000018   5E50D4E5           LDRB     R5,[R4, #+94]
   \   0000001C   000055E3           CMP      R5,#+0
   \   00000020   0E00000A           BEQ      ??FS__AutoMountNL_0
    311              return 0;
    312            }
    313            //
    314            // Not yet mounted, automount allowed. Let's try to mount.
    315            //
    316            r = _Mount(pVolume, pVolume->AllowAutoMount);
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       FS_LB_GetStatus
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0900000A           BEQ      ??FS__AutoMountNL_1
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       FS_LB_InitMediumIfRequired
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       FS__LocatePartition
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       FS_FAT_CheckBPB
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   5D50C415           STRBNE   R5,[R4, #+93]
   \   00000054   5D00D4E5           LDRB     R0,[R4, #+93]
   \   00000058   000000EA           B        ??FS__AutoMountNL_0
   \                     ??FS__AutoMountNL_1:
   \   0000005C   0000E0E3           MVN      R0,#+0
    317            return r;
   \                     ??FS__AutoMountNL_0:
   \   00000060   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000064   3080BDE8           POP      {R4,R5,PC}       ;; return
    318          }
    319          
    320          
    321          /*********************************************************************
    322          *
    323          *       FS__Sync
    324          *
    325          *  Function Description
    326          *    Internal version of FS_Sync
    327          */

   \                                 In section .text, align 4, keep-with-next
    328          void FS__Sync(FS_VOLUME * pVolume) {
   \                     FS__Sync:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    329            FS_DEVICE * pDevice;
    330          
    331            FS_LOCK_SYS();
    332            pDevice = &pVolume->Partition.Device;
    333            FS_UNLOCK_SYS();
    334            FS_LOCK_DRIVER(pDevice);
    335            FS_USE_PARA(pDevice);
    336            if (pVolume->IsMounted) {
   \   00000008   5D00D4E5           LDRB     R0,[R4, #+93]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   1300000A           BEQ      ??FS__Sync_0
    337              FS_FILE   * pFile;
    338              
    339              //
    340              // Clean the journal
    341              //
    342              FS_JOURNAL_CLEAN(pVolume);
    343              //
    344              // All information of each file handle is updated on the volume FS.
    345              //
    346              FS_LOCK_SYS();
    347              pFile    = FS_Global.pFirstFilehandle;
   \   00000018   ........           LDR      R0,??DataTable1
   \   0000001C   145090E5           LDR      R5,[R0, #+20]
    348              while (pFile) {
   \   00000020   000055E3           CMP      R5,#+0
   \   00000024   0B00000A           BEQ      ??FS__Sync_1
    349                //
    350                // Check if file is on this volume. SYS-Lock is required when going thru the data structures.
    351                //
    352                if (pFile->InUse && pFile->pFileObj->pVolume == pVolume) {
   \                     ??FS__Sync_2:
   \   00000028   0A00D5E5           LDRB     R0,[R5, #+10]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0500000A           BEQ      ??FS__Sync_3
   \   00000034   000095E5           LDR      R0,[R5, #+0]
   \   00000038   080090E5           LDR      R0,[R0, #+8]
   \   0000003C   040050E1           CMP      R0,R4
   \   00000040   0100001A           BNE      ??FS__Sync_3
    353                  FS_UPDATE_FILE(pFile);
   \   00000044   0500A0E1           MOV      R0,R5
   \   00000048   ........           BL       FS_FAT_Close
    354                }
    355                pFile = pFile->pNext;
   \                     ??FS__Sync_3:
   \   0000004C   0C5095E5           LDR      R5,[R5, #+12]
   \   00000050   000055E3           CMP      R5,#+0
   \   00000054   F3FFFF1A           BNE      ??FS__Sync_2
    356              }
    357              FS_UNLOCK_SYS();
    358              //
    359              // Updates all relevant FS information
    360              //
    361              FS_CLEAN_FS(pVolume);
   \                     ??FS__Sync_1:
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           BL       FS_FAT_Clean
    362              //
    363              // As last operation, tell storage layer to sync.
    364              // This should flush the cache (if active) and clean any buffers the driver may have.
    365              //
    366              FS__STORAGE_Sync(pVolume);
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       FS__STORAGE_Sync
    367            }
    368            FS_UNLOCK_DRIVER(pDevice);
    369          }
   \                     ??FS__Sync_0:
   \   00000068   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000006C   3080BDE8           POP      {R4,R5,PC}       ;; return
    370          
    371          /*********************************************************************
    372          *
    373          *       Public code
    374          *
    375          **********************************************************************
    376          */
    377          
    378          
    379          /*********************************************************************
    380          *
    381          *       FS_IsVolumeMounted
    382          *
    383          *  Description:
    384          *    Returns if a volume is mounted and correctly formatted.
    385          *
    386          *  Return value:
    387          *       1         - Volume is mounted
    388          *       0         - Volume is not mounted or does not exist
    389          */

   \                                 In section .text, align 4, keep-with-next
    390          int FS_IsVolumeMounted(const char * sVolumeName) {
   \                     FS_IsVolumeMounted:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
    391            int r;
    392            FS_VOLUME * pVolume;
    393            FS_LOCK();
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   ........           BL       FS_OS_Lock
    394            r = 0;
   \   00000014   0050A0E3           MOV      R5,#+0
    395            pVolume = FS__FindVolume(sVolumeName, NULL);
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       FS__FindVolume
    396            if (pVolume) {
   \   00000024   000050E3           CMP      R0,#+0
    397              r = (pVolume->IsMounted == 0) ? 0 : 1;
   \   00000028   5D00D015           LDRBNE   R0,[R0, #+93]
   \   0000002C   00005013           CMPNE    R0,#+0
   \   00000030   0150A013           MOVNE    R5,#+1
    398            }
    399            FS_UNLOCK();
   \   00000034   0000A013           MOVNE    R0,#+0
   \   00000038   ........           BL       FS_OS_Unlock
    400            return r;
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   04D08DE2           ADD      SP,SP,#+4
   \   00000044   3080BDE8           POP      {R4,R5,PC}       ;; return
    401          }
    402          
    403          /*********************************************************************
    404          *
    405          *       FS_GetVolumeInfo
    406          *
    407          *  Description:
    408          *    Get volume information
    409          *
    410          *  Parameters:
    411          *    sVolume            - The volume name
    412          *    pInfo              - A pointer to FS_DISK_INFO. Volume information
    413          *                         will be filled in
    414          *
    415          *  Return value:
    416          *    0                  - OK
    417          *   -1                  - Error. Failed to get volume information
    418          */

   \                                 In section .text, align 4, keep-with-next
    419          int FS_GetVolumeInfo(const char * sVolume, FS_DISK_INFO * pInfo) {
   \                     FS_GetVolumeInfo:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
    420            int r;
    421          
    422            FS_LOCK();
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   ........           BL       FS_OS_Lock
    423            r = FS__GetVolumeInfo(sVolume, pInfo);
   \   00000018   0120A0E3           MOV      R2,#+1
   \   0000001C   0510A0E1           MOV      R1,R5
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       FS__GetVolumeInfoEx
   \   00000028   0040A0E1           MOV      R4,R0
    424            FS_UNLOCK();
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   ........           BL       FS_OS_Unlock
    425            return r;
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   04D08DE2           ADD      SP,SP,#+4
   \   0000003C   3080BDE8           POP      {R4,R5,PC}       ;; return
    426          }
    427          
    428          /*********************************************************************
    429          *
    430          *       FS_GetVolumeFreeSpace
    431          *
    432          *  Description:
    433          *    Returns a volume's free space in bytes
    434          *
    435          *  Parameters:
    436          *    sVolume            - The volume name
    437          *
    438          *  Return value:
    439          *    Number of bytes available on the volume.
    440          *    If the volume can not be found, 0 is returned.
    441          *
    442          *  Notes
    443          *    (1) Max. value:
    444          *        Since the return value is a 32 bit value, the maximum that can
    445          *        be return is 0xFFFFFFFF = 2^32 - 1.
    446          *        If there is more space available than 0xFFFFFFFF, the return value is 0xFFFFFFFF.
    447          */

   \                                 In section .text, align 4, keep-with-next
    448          U32 FS_GetVolumeFreeSpace(const char * sVolume) {
   \                     FS_GetVolumeFreeSpace:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
    449            FS_DISK_INFO Info;
    450            U32       r;
    451          
    452            FS_LOCK();
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   ........           BL       FS_OS_Lock
    453            r = 0;
   \   00000014   0050A0E3           MOV      R5,#+0
    454            if (sVolume) {
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   0A00000A           BEQ      ??FS_GetVolumeFreeSpace_0
    455              if (FS__GetVolumeInfo(sVolume, &Info) != -1) {
   \   00000020   0120A0E3           MOV      R2,#+1
   \   00000024   0D10A0E1           MOV      R1,SP
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       FS__GetVolumeInfoEx
   \   00000030   010070E3           CMN      R0,#+1
   \   00000034   0400000A           BEQ      ??FS_GetVolumeFreeSpace_0
    456                r = FS__CalcSizeInBytes(Info.NumFreeClusters, Info.SectorsPerCluster, Info.BytesPerSector);
   \   00000038   BA20DDE1           LDRH     R2,[SP, #+10]
   \   0000003C   B810DDE1           LDRH     R1,[SP, #+8]
   \   00000040   04009DE5           LDR      R0,[SP, #+4]
   \   00000044   ........           BL       FS__CalcSizeInBytes
   \   00000048   0050A0E1           MOV      R5,R0
    457              }
    458            }
    459            FS_UNLOCK();
   \                     ??FS_GetVolumeFreeSpace_0:
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   ........           BL       FS_OS_Unlock
    460            return r;
   \   00000054   0500A0E1           MOV      R0,R5
   \   00000058   0CD08DE2           ADD      SP,SP,#+12
   \   0000005C   3080BDE8           POP      {R4,R5,PC}       ;; return
    461          }
    462          
    463          /*********************************************************************
    464          *
    465          *       FS_GetVolumeFreeSpaceKB
    466          *
    467          *  Description:
    468          *    Returns a volume's free space in KBytes
    469          *
    470          *  Parameters:
    471          *    sVolume            - The volume name
    472          *
    473          *  Return value:
    474          *    Number of bytes available on the volume.
    475          *    If the volume can not be found, 0 is returned.
    476          *
    477          *  Notes
    478          *    (1) Max. value:
    479          *        Since the return value is a 32 bit value, the maximum that can
    480          *        be return is 0xFFFFFFFF = 2^32 - 1.
    481          *        If there is more space available than 0xFFFFFFFF, the return value is 0xFFFFFFFF.
    482          */

   \                                 In section .text, align 4, keep-with-next
    483          U32 FS_GetVolumeFreeSpaceKB(const char * sVolume) {
   \                     FS_GetVolumeFreeSpaceKB:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
    484            FS_DISK_INFO Info;
    485            U32       r;
    486          
    487            FS_LOCK();
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   ........           BL       FS_OS_Lock
    488            r = 0;
   \   00000014   0050A0E3           MOV      R5,#+0
    489            if (sVolume) {
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   0A00000A           BEQ      ??FS_GetVolumeFreeSpaceKB_0
    490              if (FS__GetVolumeInfo(sVolume, &Info) != -1) {
   \   00000020   0120A0E3           MOV      R2,#+1
   \   00000024   0D10A0E1           MOV      R1,SP
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       FS__GetVolumeInfoEx
   \   00000030   010070E3           CMN      R0,#+1
   \   00000034   0400000A           BEQ      ??FS_GetVolumeFreeSpaceKB_0
    491                r = FS__CalcSizeInKB(Info.NumFreeClusters, Info.SectorsPerCluster, Info.BytesPerSector);
   \   00000038   BA20DDE1           LDRH     R2,[SP, #+10]
   \   0000003C   B810DDE1           LDRH     R1,[SP, #+8]
   \   00000040   04009DE5           LDR      R0,[SP, #+4]
   \   00000044   ........           BL       FS__CalcSizeInKB
   \   00000048   0050A0E1           MOV      R5,R0
    492              }
    493            }
    494            FS_UNLOCK();
   \                     ??FS_GetVolumeFreeSpaceKB_0:
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   ........           BL       FS_OS_Unlock
    495            return r;
   \   00000054   0500A0E1           MOV      R0,R5
   \   00000058   0CD08DE2           ADD      SP,SP,#+12
   \   0000005C   3080BDE8           POP      {R4,R5,PC}       ;; return
    496          }
    497          
    498          /*********************************************************************
    499          *
    500          *       FS_GetVolumeSize
    501          *
    502          *  Description:
    503          *    Returns a volume's total size in bytes
    504          *
    505          *  Parameters:
    506          *    sVolume            - The volume name
    507          *
    508          *  Return value:
    509          *    The number of total bytes available on this volume, or
    510          *    0 if the volume could not be found.
    511          *
    512          *  Notes
    513          *    (1) Max. value:
    514          *        Since the return value is a 32 bit value, the maximum that can
    515          *        be return is 0xFFFFFFFF = 2^32 - 1.
    516          *        If there is more space available than 0xFFFFFFFF, the return value is 0xFFFFFFFF.
    517          */

   \                                 In section .text, align 4, keep-with-next
    518          U32 FS_GetVolumeSize(const char * sVolume) {
   \                     FS_GetVolumeSize:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
    519            FS_DISK_INFO Info;
    520            U32       r;
    521          
    522            r = 0;          /* Error - Failed to get volume information */
   \   0000000C   0050A0E3           MOV      R5,#+0
    523            FS_LOCK();
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   ........           BL       FS_OS_Lock
    524            if (sVolume) {
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   0A00000A           BEQ      ??FS_GetVolumeSize_0
    525              if (FS__GetVolumeInfoEx(sVolume, &Info, 0) != -1) {
   \   00000020   0020A0E3           MOV      R2,#+0
   \   00000024   0D10A0E1           MOV      R1,SP
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       FS__GetVolumeInfoEx
   \   00000030   010070E3           CMN      R0,#+1
   \   00000034   0400000A           BEQ      ??FS_GetVolumeSize_0
    526                r = FS__CalcSizeInBytes(Info.NumTotalClusters, Info.SectorsPerCluster, Info.BytesPerSector);
   \   00000038   BA20DDE1           LDRH     R2,[SP, #+10]
   \   0000003C   B810DDE1           LDRH     R1,[SP, #+8]
   \   00000040   00009DE5           LDR      R0,[SP, #+0]
   \   00000044   ........           BL       FS__CalcSizeInBytes
   \   00000048   0050A0E1           MOV      R5,R0
    527              }
    528            }
    529            FS_UNLOCK();
   \                     ??FS_GetVolumeSize_0:
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   ........           BL       FS_OS_Unlock
    530            return r;
   \   00000054   0500A0E1           MOV      R0,R5
   \   00000058   0CD08DE2           ADD      SP,SP,#+12
   \   0000005C   3080BDE8           POP      {R4,R5,PC}       ;; return
    531          }
    532          
    533          /*********************************************************************
    534          *
    535          *       FS_GetVolumeSizeKB
    536          *
    537          *  Description:
    538          *    Returns a volume's total size in bytes
    539          *
    540          *  Parameters:
    541          *    sVolume            - The volume name
    542          *
    543          *  Return value:
    544          *    The number of total bytes available on this volume, or
    545          *    0 if the volume could not be found.
    546          *
    547          *  Notes
    548          *    (1) Max. value:
    549          *        Since the return value is a 32 bit value, the maximum that can
    550          *        be return is 0xFFFFFFFF = 2^32 - 1.
    551          *        If there is more space available than 0xFFFFFFFF, the return value is 0xFFFFFFFF.
    552          */

   \                                 In section .text, align 4, keep-with-next
    553          U32 FS_GetVolumeSizeKB(const char * sVolume) {
   \                     FS_GetVolumeSizeKB:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
    554            FS_DISK_INFO Info;
    555            U32       r;
    556          
    557            r = 0;          /* Error - Failed to get volume information */
   \   0000000C   0050A0E3           MOV      R5,#+0
    558            FS_LOCK();
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   ........           BL       FS_OS_Lock
    559            if (sVolume) {
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   0A00000A           BEQ      ??FS_GetVolumeSizeKB_0
    560              if (FS__GetVolumeInfoEx(sVolume, &Info, 0) != -1) {
   \   00000020   0020A0E3           MOV      R2,#+0
   \   00000024   0D10A0E1           MOV      R1,SP
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       FS__GetVolumeInfoEx
   \   00000030   010070E3           CMN      R0,#+1
   \   00000034   0400000A           BEQ      ??FS_GetVolumeSizeKB_0
    561                r = FS__CalcSizeInKB(Info.NumTotalClusters, Info.SectorsPerCluster, Info.BytesPerSector);
   \   00000038   BA20DDE1           LDRH     R2,[SP, #+10]
   \   0000003C   B810DDE1           LDRH     R1,[SP, #+8]
   \   00000040   00009DE5           LDR      R0,[SP, #+0]
   \   00000044   ........           BL       FS__CalcSizeInKB
   \   00000048   0050A0E1           MOV      R5,R0
    562              }
    563            }
    564            FS_UNLOCK();
   \                     ??FS_GetVolumeSizeKB_0:
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   ........           BL       FS_OS_Unlock
    565            return r;
   \   00000054   0500A0E1           MOV      R0,R5
   \   00000058   0CD08DE2           ADD      SP,SP,#+12
   \   0000005C   3080BDE8           POP      {R4,R5,PC}       ;; return
    566          }
    567          
    568          /*********************************************************************
    569          *
    570          *       FS_GetVolumeLabel
    571          *
    572          *  Description:
    573          *    Returns a volume label name if one exists.
    574          *
    575          *  Parameters:
    576          *    sVolume            - The volume name
    577          *    pVolumeLabel       - Pointer to a buffer to receive the volume label.
    578          *    VolumeLabelSize    - length of pVolumeName
    579          *
    580          *  Return value:
    581          *    0     - Success.
    582          *   -1     - Error.
    583          */

   \                                 In section .text, align 4, keep-with-next
    584          int FS_GetVolumeLabel(const char * sVolume, char * pVolumeLabel, unsigned VolumeLabelSize) {
   \                     FS_GetVolumeLabel:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
    585            int  r;
    586            FS_VOLUME * pVolume;
    587            r = -1;          /* Error - Failed to get volume information */
   \   00000010   0070E0E3           MVN      R7,#+0
    588            FS_LOCK();
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   ........           BL       FS_OS_Lock
    589            if (sVolume) {
   \   0000001C   000054E3           CMP      R4,#+0
    590              if (pVolumeLabel) {
   \   00000020   00005513           CMPNE    R5,#+0
   \   00000024   2000000A           BEQ      ??FS_GetVolumeLabel_0
    591                pVolume = FS__FindVolume(sVolume, NULL);
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       FS__FindVolume
   \   00000034   0040B0E1           MOVS     R4,R0
    592                if (pVolume) {
   \   00000038   1B00000A           BEQ      ??FS_GetVolumeLabel_0
    593                  if ((FS__AutoMount(pVolume) & FS_MOUNT_R) == FS_MOUNT_R)  {
   \   0000003C   5D00D4E5           LDRB     R0,[R4, #+93]
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   1100001A           BNE      ??FS_GetVolumeLabel_1
   \   00000048   5E80D4E5           LDRB     R8,[R4, #+94]
   \   0000004C   000058E3           CMP      R8,#+0
   \   00000050   1500000A           BEQ      ??FS_GetVolumeLabel_0
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       FS_LB_GetStatus
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   0900000A           BEQ      ??FS_GetVolumeLabel_2
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           BL       FS_LB_InitMediumIfRequired
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   ........           BL       FS__LocatePartition
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   ........           BL       FS_FAT_CheckBPB
   \   0000007C   000050E3           CMP      R0,#+0
   \   00000080   5D80C415           STRBNE   R8,[R4, #+93]
   \   00000084   5D00D4E5           LDRB     R0,[R4, #+93]
   \   00000088   000000EA           B        ??FS_GetVolumeLabel_1
   \                     ??FS_GetVolumeLabel_2:
   \   0000008C   0700A0E1           MOV      R0,R7
   \                     ??FS_GetVolumeLabel_1:
   \   00000090   010010E3           TST      R0,#0x1
   \   00000094   0400000A           BEQ      ??FS_GetVolumeLabel_0
    594                    FS_LOCK_DRIVER(&pVolume->Partition.Device);
    595                    r = FS_GET_VOLUME_LABEL(pVolume, pVolumeLabel, VolumeLabelSize);
   \   00000098   0620A0E1           MOV      R2,R6
   \   0000009C   0510A0E1           MOV      R1,R5
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   ........           BL       FS_FAT_GetVolumeLabel
   \   000000A8   0070A0E1           MOV      R7,R0
    596                    FS_UNLOCK_DRIVER(&pVolume->Partition.Device);
    597                  }
    598                }
    599              }
    600            }
    601            FS_UNLOCK();
   \                     ??FS_GetVolumeLabel_0:
   \   000000AC   0000A0E3           MOV      R0,#+0
   \   000000B0   ........           BL       FS_OS_Unlock
    602            return r;
   \   000000B4   0700A0E1           MOV      R0,R7
   \   000000B8   F081BDE8           POP      {R4-R8,PC}       ;; return
    603          }
    604          
    605          /*********************************************************************
    606          *
    607          *       FS_SetVolumeLabel
    608          *
    609          *  Description:
    610          *    Returns a volume label name if one exists.
    611          *
    612          *  Parameters:
    613          *    sVolume            - The volume name
    614          *    pVolumeLabel       - Pointer to a buffer with the new volume label.
    615          *                       - NULL indicates, that the volume label should
    616          *                         be deleted.
    617          *
    618          *  Return value:
    619          *    0     - Success.
    620          *   -1     - Error.
    621          */

   \                                 In section .text, align 4, keep-with-next
    622          int FS_SetVolumeLabel(const char * sVolume, const char * pVolumeLabel) {
   \                     FS_SetVolumeLabel:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
    623            int  r;
    624            FS_VOLUME * pVolume;
    625            r = -1;          /* Error - Failed to get volume information */
   \   00000010   0060E0E3           MVN      R6,#+0
    626            FS_LOCK();
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   ........           BL       FS_OS_Lock
    627            if (sVolume) {
   \   0000001C   000054E3           CMP      R4,#+0
   \   00000020   1D00000A           BEQ      ??FS_SetVolumeLabel_0
    628              pVolume = FS__FindVolume(sVolume, NULL);
   \   00000024   0010A0E3           MOV      R1,#+0
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       FS__FindVolume
   \   00000030   0040B0E1           MOVS     R4,R0
    629              if (pVolume) {
   \   00000034   1800000A           BEQ      ??FS_SetVolumeLabel_0
    630                if (FS__AutoMount(pVolume) == FS_MOUNT_RW)  {
   \   00000038   5D00D4E5           LDRB     R0,[R4, #+93]
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0F00001A           BNE      ??FS_SetVolumeLabel_1
   \   00000044   5E70D4E5           LDRB     R7,[R4, #+94]
   \   00000048   000057E3           CMP      R7,#+0
   \   0000004C   1200000A           BEQ      ??FS_SetVolumeLabel_0
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           BL       FS_LB_GetStatus
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0F00000A           BEQ      ??FS_SetVolumeLabel_2
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       FS_LB_InitMediumIfRequired
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   ........           BL       FS__LocatePartition
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   ........           BL       FS_FAT_CheckBPB
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   5D70C415           STRBNE   R7,[R4, #+93]
   \   00000080   5D00D4E5           LDRB     R0,[R4, #+93]
   \                     ??FS_SetVolumeLabel_1:
   \   00000084   030050E3           CMP      R0,#+3
   \   00000088   0300001A           BNE      ??FS_SetVolumeLabel_0
    631                  FS_LOCK_DRIVER(&pVolume->Partition.Device);
    632                  FS_JOURNAL_BEGIN(pVolume);
    633                  r = FS_SET_VOLUME_LABEL(pVolume, pVolumeLabel);
   \   0000008C   0510A0E1           MOV      R1,R5
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   ........           BL       FS_FAT_SetVolumeLabel
   \   00000098   0060A0E1           MOV      R6,R0
    634                  FS_JOURNAL_END(pVolume);
    635                  FS_UNLOCK_DRIVER(&pVolume->Partition.Device);
    636                }
    637              }
    638            }
    639            FS_UNLOCK();
   \                     ??FS_SetVolumeLabel_0:
   \   0000009C   0000A0E3           MOV      R0,#+0
   \                     ??FS_SetVolumeLabel_2:
   \   000000A0   ........           BL       FS_OS_Unlock
    640            return r;
   \   000000A4   0600A0E1           MOV      R0,R6
   \   000000A8   04D08DE2           ADD      SP,SP,#+4
   \   000000AC   F080BDE8           POP      {R4-R7,PC}       ;; return
    641          }
    642          
    643          /*********************************************************************
    644          *
    645          *       FS_Mount
    646          *
    647          *  Function description:
    648          *    Mounts a volume, if necessary.
    649          *
    650          *  Return value:
    651          *    == 0               - Volume is not mounted.
    652          *    == 1 (FS_MOUNT_R)  - Volume is mounted read only.
    653          *    == 3 (FS_MOUNT_RW) - Volume is mounted read/write.
    654          *    == -1              - Error, Volume can not be mounted.
    655          */

   \                                 In section .text, align 4, keep-with-next
    656          int FS_Mount(const char * sVolume) {
   \                     FS_Mount:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
    657            FS_VOLUME * pVolume;
    658            int         r;
    659          
    660            FS_LOCK();
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   ........           BL       FS_OS_Lock
    661            r       = 1;  // Set as error so far
   \   00000014   0150A0E3           MOV      R5,#+1
    662            pVolume = FS__FindVolume(sVolume, NULL);
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       FS__FindVolume
   \   00000024   0040B0E1           MOVS     R4,R0
    663            if (pVolume) {
   \   00000028   1100000A           BEQ      ??FS_Mount_0
    664              r = FS__Mount(pVolume, FS_MOUNT_RW);
   \   0000002C   5D00D4E5           LDRB     R0,[R4, #+93]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0D00001A           BNE      ??FS_Mount_1
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   ........           BL       FS_LB_GetStatus
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   1200000A           BEQ      ??FS_Mount_2
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   ........           BL       FS_LB_InitMediumIfRequired
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           BL       FS__LocatePartition
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           BL       FS_FAT_CheckBPB
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0700000A           BEQ      ??FS_Mount_3
   \   00000068   0300A0E3           MOV      R0,#+3
   \   0000006C   5D00C4E5           STRB     R0,[R4, #+93]
   \                     ??FS_Mount_1:
   \   00000070   5D50D4E5           LDRB     R5,[R4, #+93]
    665            }
    666            FS_UNLOCK();
   \                     ??FS_Mount_0:
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   ........           BL       FS_OS_Unlock
    667            return r;
   \   0000007C   0500A0E1           MOV      R0,R5
   \   00000080   04D08DE2           ADD      SP,SP,#+4
   \   00000084   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??FS_Mount_3:
   \   00000088   5D00D4E5           LDRB     R0,[R4, #+93]
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   F6FFFF1A           BNE      ??FS_Mount_1
   \                     ??FS_Mount_2:
   \   00000094   005065E2           RSB      R5,R5,#+0
   \   00000098   F5FFFFEA           B        ??FS_Mount_0
    668          }
    669          
    670          /*********************************************************************
    671          *
    672          *       FS_MountEx
    673          *
    674          *  Function description:
    675          *    Mounts a volume, if necessary.
    676          *
    677          *  Parameters:
    678          *    sVolume            - The volume name
    679          *    MountType          - FS_MOUNT_R (1) or FS_MOUNT_RW (3)
    680          *
    681          *  Return value:
    682          *    == 0               - Volume is not mounted.
    683          *    == 1 (FS_MOUNT_R)  - Volume is mounted read only.
    684          *    == 3 (FS_MOUNT_RW) - Volume is mounted read/write.
    685          *    == -1              - Error, Volume can not be mounted.
    686          */

   \                                 In section .text, align 4, keep-with-next
    687          int FS_MountEx(const char * sVolume, U8 MountType) {
   \                     FS_MountEx:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    688            FS_VOLUME * pVolume;
    689            int         r;
    690          
    691            FS_LOCK();
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   ........           BL       FS_OS_Lock
    692            r       = -1;  // Set as error so far
   \   00000014   0060E0E3           MVN      R6,#+0
    693            pVolume = FS__FindVolume(sVolume, NULL);
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       FS__FindVolume
   \   00000024   0040B0E1           MOVS     R4,R0
    694            if (pVolume) {
   \   00000028   1400000A           BEQ      ??FS_MountEx_0
    695              r = FS__Mount(pVolume, MountType);
   \   0000002C   5D00D4E5           LDRB     R0,[R4, #+93]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   1000001A           BNE      ??FS_MountEx_1
   \   00000038   000055E3           CMP      R5,#+0
   \   0000003C   0E00000A           BEQ      ??FS_MountEx_1
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   ........           BL       FS_LB_GetStatus
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0C00000A           BEQ      ??FS_MountEx_2
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           BL       FS_LB_InitMediumIfRequired
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           BL       FS__LocatePartition
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       FS_FAT_CheckBPB
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   5D00D405           LDRBEQ   R0,[R4, #+93]
   \   00000070   5D50C415           STRBNE   R5,[R4, #+93]
   \   00000074   00005003           CMPEQ    R0,#+0
   \   00000078   0100000A           BEQ      ??FS_MountEx_2
   \                     ??FS_MountEx_1:
   \   0000007C   5D60D4E5           LDRB     R6,[R4, #+93]
    696            }
    697            FS_UNLOCK();
   \                     ??FS_MountEx_0:
   \   00000080   0000A0E3           MOV      R0,#+0
   \                     ??FS_MountEx_2:
   \   00000084   ........           BL       FS_OS_Unlock
    698            return r;
   \   00000088   0600A0E1           MOV      R0,R6
   \   0000008C   7080BDE8           POP      {R4-R6,PC}       ;; return
    699          }
    700          
    701          /*********************************************************************
    702          *
    703          *       FS_IsHLFormatted
    704          *
    705          *  Function description:
    706          *    Returns if a volume is high-level formatted or not.
    707          *
    708          *  Return value:
    709          *      1     - Volume is     high-level formatted.
    710          *      0     - Volume is not high-level formatted.
    711          *     -1     - Device is not ready or general error.
    712          */

   \                                 In section .text, align 4, keep-with-next
    713          int FS_IsHLFormatted(const char * sVolume) {
   \                     FS_IsHLFormatted:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
    714            FS_VOLUME * pVolume;
    715            int         r;
    716          
    717            FS_LOCK();
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   ........           BL       FS_OS_Lock
    718            r       = -1;  // Set as error so far
   \   00000014   0050E0E3           MVN      R5,#+0
    719            pVolume = FS__FindVolume(sVolume, NULL);
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       FS__FindVolume
   \   00000024   0040B0E1           MOVS     R4,R0
    720            if (pVolume) {
   \   00000028   1500000A           BEQ      ??FS_IsHLFormatted_0
    721              r = FS__AutoMount(pVolume);
   \   0000002C   5D50D4E5           LDRB     R5,[R4, #+93]
   \   00000030   000055E3           CMP      R5,#+0
   \   00000034   1000001A           BNE      ??FS_IsHLFormatted_1
   \   00000038   5E50D4E5           LDRB     R5,[R4, #+94]
   \   0000003C   000055E3           CMP      R5,#+0
   \   00000040   0D00000A           BEQ      ??FS_IsHLFormatted_1
   \   00000044   ........           BL       FS_LB_GetStatus
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0900000A           BEQ      ??FS_IsHLFormatted_2
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           BL       FS_LB_InitMediumIfRequired
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           BL       FS__LocatePartition
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           BL       FS_FAT_CheckBPB
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   5D50C415           STRBNE   R5,[R4, #+93]
   \   00000070   5D50D4E5           LDRB     R5,[R4, #+93]
   \   00000074   000000EA           B        ??FS_IsHLFormatted_1
   \                     ??FS_IsHLFormatted_2:
   \   00000078   0050E0E3           MVN      R5,#+0
    722              if (r > 0) {
   \                     ??FS_IsHLFormatted_1:
   \   0000007C   010055E3           CMP      R5,#+1
    723                r = 1;
   \   00000080   0150A0A3           MOVGE    R5,#+1
    724              }
    725            }
    726            FS_UNLOCK();
   \                     ??FS_IsHLFormatted_0:
   \   00000084   0000A0E3           MOV      R0,#+0
   \   00000088   ........           BL       FS_OS_Unlock
    727            return r;
   \   0000008C   0500A0E1           MOV      R0,R5
   \   00000090   04D08DE2           ADD      SP,SP,#+4
   \   00000094   3080BDE8           POP      {R4,R5,PC}       ;; return
    728          }
    729          
    730          /*********************************************************************
    731          *
    732          *       FS_CheckDisk
    733          *
    734          *  Function description
    735          *     This function checks the file system for corruption:
    736          *     The following corruption are detected/fixed:
    737          *       * Invalid directory entries.
    738          *       * Lost clusters/cluster chains.
    739          *       * Cross linked clusters.
    740          *       * Clusters are associated to a file with size of 0.
    741          *       * Too few clusters are allocated to a file.
    742          *       * Cluster is not marked as end-of-chain, although it should be.
    743          *
    744          *  Parameters
    745          *    sVolume           - Pointer to a string containing the name of the volume.
    746          *    pBuffer           - Pointer to a buffer that shall be used for checking the cluster entries.
    747          *    BufferSize        - Size of the buffer in bytes.
    748          *    MaxRecursionLevel - The max recursion depth checkdisk shall go.
    749          *    pfOnError         - Pointer to a callback function that shall report the user of the error. NULL is not permitted, but returns an error.
    750          *
    751          *  Return value
    752          *    0    O.K.  - File system is not in a corrupted state.
    753          *    1    Error -> an error has be found and repaired, retry is required.
    754          *    2    User specified an abort of checkdisk operation thru callback or volume not mountable.
    755          */

   \                                 In section .text, align 4, keep-with-next
    756          int FS_CheckDisk(const char * sVolumeName, void *pBuffer, U32 BufferSize, int MaxRecursionLevel, FS_QUERY_F_TYPE * pfOnError) {
   \                     FS_CheckDisk:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   18D04DE2           SUB      SP,SP,#+24
   \   00000008   38709DE5           LDR      R7,[SP, #+56]
   \   0000000C   0090A0E1           MOV      R9,R0
   \   00000010   0140A0E1           MOV      R4,R1
   \   00000014   0250A0E1           MOV      R5,R2
   \   00000018   0360A0E1           MOV      R6,R3
    757            FS_VOLUME    * pVolume;
    758            FS_DISK_INFO   DiskInfo;
    759            int            r = 2;
   \   0000001C   0280A0E3           MOV      R8,#+2
    760          
    761            if (pfOnError == NULL) {
   \   00000020   000057E3           CMP      R7,#+0
   \   00000024   2E00000A           BEQ      ??FS_CheckDisk_0
    762              FS_DEBUG_ERROROUT((FS_MTYPE_API, "No callback for error reporting is specified, returning.\n"));
    763              return 2;
    764            }
    765            FS_LOCK();
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   ........           BL       FS_OS_Lock
    766            pVolume = FS__FindVolume(sVolumeName, NULL);
   \   00000030   0010A0E3           MOV      R1,#+0
   \   00000034   0900A0E1           MOV      R0,R9
   \   00000038   ........           BL       FS__FindVolume
   \   0000003C   0090B0E1           MOVS     R9,R0
    767            if (pVolume) {
   \   00000040   2500000A           BEQ      ??FS_CheckDisk_1
    768              FS__Unmount(pVolume);
   \   00000044   ........           BL       FS__Unmount
    769              r = _GetVolumeInfoEx(pVolume, &DiskInfo, FS_DISKINFO_FLAG_USE_FREE_SPACE);
   \   00000048   5D00D9E5           LDRB     R0,[R9, #+93]
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   1100001A           BNE      ??FS_CheckDisk_2
   \   00000054   5EA0D9E5           LDRB     R10,[R9, #+94]
   \   00000058   00005AE3           CMP      R10,#+0
   \   0000005C   1E00000A           BEQ      ??FS_CheckDisk_1
   \   00000060   0900A0E1           MOV      R0,R9
   \   00000064   ........           BL       FS_LB_GetStatus
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   0900000A           BEQ      ??FS_CheckDisk_3
   \   00000070   0900A0E1           MOV      R0,R9
   \   00000074   ........           BL       FS_LB_InitMediumIfRequired
   \   00000078   0900A0E1           MOV      R0,R9
   \   0000007C   ........           BL       FS__LocatePartition
   \   00000080   0900A0E1           MOV      R0,R9
   \   00000084   ........           BL       FS_FAT_CheckBPB
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   5DA0C915           STRBNE   R10,[R9, #+93]
   \   00000090   5D00D9E5           LDRB     R0,[R9, #+93]
   \   00000094   000000EA           B        ??FS_CheckDisk_2
   \                     ??FS_CheckDisk_3:
   \   00000098   0000E0E3           MVN      R0,#+0
   \                     ??FS_CheckDisk_2:
   \   0000009C   010010E3           TST      R0,#0x1
   \   000000A0   0D00000A           BEQ      ??FS_CheckDisk_1
   \   000000A4   0120A0E3           MOV      R2,#+1
   \   000000A8   08108DE2           ADD      R1,SP,#+8
   \   000000AC   0900A0E1           MOV      R0,R9
   \   000000B0   ........           BL       FS_FAT_GetDiskInfo
   \   000000B4   010070E3           CMN      R0,#+1
   \   000000B8   0700000A           BEQ      ??FS_CheckDisk_1
    770              if (r == 0) {
    771                FS_LOCK_DRIVER(&pVolume->Partition.Device);
    772                FS_JOURNAL_INVALIDATE(pVolume);
    773                r = FS_CHECKDISK(pVolume, &DiskInfo, pBuffer, BufferSize, MaxRecursionLevel, pfOnError);
   \   000000BC   04708DE5           STR      R7,[SP, #+4]
   \   000000C0   00608DE5           STR      R6,[SP, #+0]
   \   000000C4   0530A0E1           MOV      R3,R5
   \   000000C8   0420A0E1           MOV      R2,R4
   \   000000CC   08108DE2           ADD      R1,SP,#+8
   \   000000D0   0900A0E1           MOV      R0,R9
   \   000000D4   ........           BL       FS_FAT__CheckDisk
   \   000000D8   0080A0E1           MOV      R8,R0
    774                if (r == 0) {
    775                  FS_JOURNAL_MOUNT(pVolume);
    776                }
    777                FS_UNLOCK_DRIVER(&pVolume->Partition.Device);
    778              } else {
    779                FS_DEBUG_ERROROUT((FS_MTYPE_API, "Medium does not contain a valid EFS allocation table structure.\n"));
    780                r = 2;
    781              }
    782            }
    783            FS_UNLOCK();
   \                     ??FS_CheckDisk_1:
   \   000000DC   0000A0E3           MOV      R0,#+0
   \   000000E0   ........           BL       FS_OS_Unlock
    784            return r;
   \                     ??FS_CheckDisk_0:
   \   000000E4   0800A0E1           MOV      R0,R8
   \   000000E8   18D08DE2           ADD      SP,SP,#+24
   \   000000EC   F087BDE8           POP      {R4-R10,PC}      ;; return
    785          }
    786          
    787          /*********************************************************************
    788          *
    789          *       FS_SetAutoMount
    790          *
    791          *  Function description:
    792          *    Sets the mount behavior of the specified volume.
    793          *
    794          *  Parameters
    795          *    sVolume           - Pointer to a string containing the name of the volume.
    796          *    MountType         - 3 values are allowed:
    797          *                          FS_MOUNT_R    - Allows to auto mount the volume read only.
    798          *                          FS_MOUNT_RW   - Allows to auto mount the volume read/write.
    799          *                          0             - Disables auto mount for the volume.
    800          *
    801          */

   \                                 In section .text, align 4, keep-with-next
    802          void FS_SetAutoMount(const char  * sVolume, U8 MountType) {
   \                     FS_SetAutoMount:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0150A0E1           MOV      R5,R1
    803           FS_VOLUME * pVolume;
    804          
    805           FS_LOCK();
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   ........           BL       FS_OS_Lock
    806           pVolume = FS__FindVolume(sVolume, NULL);
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       FS__FindVolume
    807           if (pVolume) {
   \   00000024   000050E3           CMP      R0,#+0
    808             FS_LOCK_SYS();
    809             pVolume->AllowAutoMount = MountType;
   \   00000028   5E50C015           STRBNE   R5,[R0, #+94]
    810             FS_UNLOCK_SYS();
    811           }
    812           FS_UNLOCK();
   \   0000002C   0000A013           MOVNE    R0,#+0
   \   00000030   ........           BL       FS_OS_Unlock
    813          
    814          }
   \   00000034   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
    815          
    816          /*********************************************************************
    817          *
    818          *       FS_Sync
    819          *
    820          *  Function Description
    821          *    Synchronize the volume, which includes
    822          *      Flushes the cache
    823          *      All information of each file handle is updated on the volume FS.
    824          *      Clean the journal
    825          *      Updates all relevant FS information
    826          *      
    827          */

   \                                 In section .text, align 4, keep-with-next
    828          int FS_Sync(const char * sVolume) {
   \                     FS_Sync:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
    829            FS_VOLUME * pVolume;
    830            int r = -1;
    831          
    832            FS_LOCK();
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   ........           BL       FS_OS_Lock
    833            if (sVolume) {
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   0F00000A           BEQ      ??FS_Sync_0
    834              pVolume = FS__FindVolume(sVolume, NULL);
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       FS__FindVolume
   \   00000028   0040B0E1           MOVS     R4,R0
    835              if (pVolume) {
   \   0000002C   0A00000A           BEQ      ??FS_Sync_0
    836                FS__Sync(pVolume);
   \   00000030   5D00D4E5           LDRB     R0,[R4, #+93]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0800000A           BEQ      ??FS_Sync_1
   \   0000003C   ........           LDR      R0,??DataTable1
   \   00000040   145090E5           LDR      R5,[R0, #+20]
   \   00000044   000055E3           CMP      R5,#+0
   \   00000048   0800001A           BNE      ??FS_Sync_2
   \                     ??FS_Sync_3:
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       FS_FAT_Clean
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       FS__STORAGE_Sync
    837              }
    838            }
    839            FS_UNLOCK();
   \                     ??FS_Sync_0:
   \   0000005C   0000A0E3           MOV      R0,#+0
   \                     ??FS_Sync_1:
   \   00000060   ........           BL       FS_OS_Unlock
    840            return r;
   \   00000064   0000E0E3           MVN      R0,#+0
   \   00000068   04D08DE2           ADD      SP,SP,#+4
   \   0000006C   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??FS_Sync_2:
   \   00000070   0A00D5E5           LDRB     R0,[R5, #+10]
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   0500000A           BEQ      ??FS_Sync_4
   \   0000007C   000095E5           LDR      R0,[R5, #+0]
   \   00000080   080090E5           LDR      R0,[R0, #+8]
   \   00000084   040050E1           CMP      R0,R4
   \   00000088   0100001A           BNE      ??FS_Sync_4
   \   0000008C   0500A0E1           MOV      R0,R5
   \   00000090   ........           BL       FS_FAT_Close
   \                     ??FS_Sync_4:
   \   00000094   0C5095E5           LDR      R5,[R5, #+12]
   \   00000098   000055E3           CMP      R5,#+0
   \   0000009C   F3FFFF1A           BNE      ??FS_Sync_2
   \   000000A0   E9FFFFEA           B        ??FS_Sync_3
    841          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     FS_Global
    842          
    843          
    844          /*************************** End of file ****************************/
    845          

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     FS_CheckDisk                56
     FS_GetVolumeFreeSpace       24
     FS_GetVolumeFreeSpaceKB     24
     FS_GetVolumeInfo            16
     FS_GetVolumeLabel           24
     FS_GetVolumeSize            24
     FS_GetVolumeSizeKB          24
     FS_IsHLFormatted            16
     FS_IsVolumeMounted          16
     FS_Mount                    16
     FS_MountEx                  16
     FS_SetAutoMount             16
     FS_SetVolumeLabel           24
     FS_Sync                     16
     FS__AutoMount               16
     FS__AutoMountNL             16
     FS__GetVolumeInfo            8
     FS__GetVolumeInfoEx         24
     FS__Mount                   16
     FS__MountNL                 16
     FS__Sync                    16


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     FS__GetVolumeInfoEx      172
     FS__GetVolumeInfo          8
     FS__MountNL              120
     FS__Mount                120
     FS__AutoMount            104
     FS__AutoMountNL          104
     FS__Sync                 112
     FS_IsVolumeMounted        72
     FS_GetVolumeInfo          64
     FS_GetVolumeFreeSpace     96
     FS_GetVolumeFreeSpaceKB   96
     FS_GetVolumeSize          96
     FS_GetVolumeSizeKB        96
     FS_GetVolumeLabel        188
     FS_SetVolumeLabel        176
     FS_Mount                 156
     FS_MountEx               144
     FS_IsHLFormatted         152
     FS_CheckDisk             240
     FS_SetAutoMount           60
     FS_Sync                  164
     ??DataTable1               4

 
 2 544 bytes in section .text
 
 2 544 bytes of CODE memory

Errors: none
Warnings: none
