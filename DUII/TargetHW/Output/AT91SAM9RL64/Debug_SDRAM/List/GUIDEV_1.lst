###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     14/Jul/2015  19:00:27 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDEV_1.c                          #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDEV_1.c -D DEBUG=1 -D            #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D                   #
#                    XIGNORE_TEMPERATURE -D BUILD_DEBUG_PORT -D PROFILER      #
#                    -lCN C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Li #
#                    st\ -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\ #
#                    Obj\ --debug --endian=little --cpu=ARM926EJ-S -e         #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\GU #
#                    IDEV_1.lst                                               #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\GUI #
#                    DEV_1.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDEV_1.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDEV_1.c
     19          Purpose     : Implementation of memory devices
     20                        This file handles 1 bit memory devices.
     21          ---------------------------END-OF-HEADER------------------------------
     22          */
     23          
     24          #include <string.h>
     25          
     26          #include "GUI_Private.h"
     27          
     28          #if GUI_WINSUPPORT
     29            #include "WM.h"
     30          #endif
     31          
     32          /* Memory device capabilities are compiled only if support for them is enabled.*/ 
     33          #if GUI_SUPPORT_MEMDEV
     34          
     35          /*********************************************************************
     36          *
     37          *       Macros
     38          *
     39          **********************************************************************
     40          */
     41          
     42          #define PIXELINDEX                      U8
     43          #define API_LIST      GUI_MEMDEV__APIList1
     44          #define DEVICE_API     GUI_MEMDEV_DEVICE_1
     45          
     46          /*********************************************************************
     47          *
     48          *       static consts
     49          *
     50          **********************************************************************
     51          */
     52          /*********************************************************************
     53          *
     54          *       ID translation table
     55          *
     56          * This table serves as translation table for DDBs
     57          */

   \                                 In section .text, align 4, keep-with-next
     58          static const LCD_PIXELINDEX aID[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
   \                     aID:
   \   00000000                      ; Initializer data, 64 bytes
   \   00000000   000000000100       DC32 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
   \              000002000000
   \              030000000400
   \              000005000000
   \              060000000700
   \              000008000000
   \              09000000    
   \   00000028   0A0000000B00       DC32 10, 11, 12, 13, 14, 15
   \              00000C000000
   \              0D0000000E00
   \              00000F000000
     59          
     60          /*********************************************************************
     61          *
     62          *       static code
     63          *
     64          **********************************************************************
     65          */
     66          /*********************************************************************
     67          *
     68          *       _XY2PTR_BITOFFSET
     69          */
     70          static U8* _XY2PTR_BITOFFSET(int x, int y, int* pBitOffset) {
     71            GUI_ALLOC_DATATYPE_U Offset;
     72            GUI_MEMDEV* pDev;
     73            U8* pData;
     74            pDev  = GUI_MEMDEV_H2P(GUI_Context.hDevData);
     75            pData = (U8*)(pDev + 1);
     76            #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
     77              if ((x >= pDev->x0+pDev->XSize) | (x<pDev->x0) | (y >= pDev->y0+pDev->YSize) | (y<pDev->y0)) {
     78                GUI_DEBUG_ERROROUT2("_XY2PTR: parameters out of bounds", x, y);
     79              }
     80            #endif
     81            x -= pDev->x0;
     82            y -= pDev->y0;
     83            Offset = (GUI_ALLOC_DATATYPE_U)(y) * (GUI_ALLOC_DATATYPE_U)(pDev->BytesPerLine) + (x >> 3);
     84            if (pBitOffset) {
     85              *pBitOffset = 7 - (x & 7);
     86            }
     87            return pData + Offset;
     88          }
     89          
     90          /*********************************************************************
     91          *
     92          *       _DrawBitLine1BPP
     93          */

   \                                 In section .text, align 4, keep-with-next
     94          static void _DrawBitLine1BPP(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * p, int Diff, unsigned int xsize,
     95                                       const LCD_PIXELINDEX* pTrans, GUI_MEMDEV* pDev, PIXELINDEX* pDest)
     96          {
   \                     _DrawBitLine1BPP:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   00A0A0E1           MOV      R10,R0
   \   0000000C   34009DE5           LDR      R0,[SP, #+52]
   \   00000010   0140A0E1           MOV      R4,R1
   \   00000014   30609DE5           LDR      R6,[SP, #+48]
     97            PIXELINDEX pixels;
     98            PIXELINDEX Index1;
     99            unsigned int PixelCnt;
    100            U8 AndMask;
    101            U8 * pData;
    102            int Bit;
    103            unsigned NumPixels;
    104          
    105            GUI_USE_PARA(pUsage);
    106            PixelCnt = 8 - (Diff & 7);
   \   00000018   071000E2           AND      R1,R0,#0x7
   \   0000001C   088061E2           RSB      R8,R1,#+8
    107            pixels = (*p) << (Diff & 7);
   \   00000020   0010D6E5           LDRB     R1,[R6, #+0]
   \   00000024   070000E2           AND      R0,R0,#0x7
   \   00000028   0250A0E1           MOV      R5,R2
   \   0000002C   1190A0E1           LSL      R9,R1,R0
    108            GUI_DEBUG_ERROROUT3_IF( x < pDev->x0, "GUIDEV.c: DrawBitLine1BPP, Act= %d, Border= %d, Clip= %d"
    109                              ,x,pDev->x0, GUI_Context.ClipRect.x0);
    110            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000030   ........           LDR      R0,??DataTable9
   \   00000034   38709DE5           LDR      R7,[SP, #+56]
   \   00000038   1010D0E5           LDRB     R1,[R0, #+16]
   \   0000003C   40B09DE5           LDR      R11,[SP, #+64]
   \   00000040   031001E2           AND      R1,R1,#0x3
   \   00000044   030051E3           CMP      R1,#+3
   \   00000048   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitLine1BPP_0:
   \   0000004C   E700008A           BHI      ??_DrawBitLine1BPP_1
   \   00000050   020000EA           B        ??_DrawBitLine1BPP_2
   \   00000054   D30000EA           B        ??_DrawBitLine1BPP_3
   \   00000058   5D0000EA           B        ??_DrawBitLine1BPP_4
   \   0000005C   D10000EA           B        ??_DrawBitLine1BPP_3
    111            case 0:    // Write mode
    112              pData = _XY2PTR_BITOFFSET(x, y, &Bit);
   \                     ??_DrawBitLine1BPP_2:
   \   00000060   880090E5           LDR      R0,[R0, #+136]
   \   00000064   ........           BL       GUI_ALLOC_h2p
   \   00000068   F410D0E1           LDRSH    R1,[R0, #+4]
   \   0000006C   F630D0E1           LDRSH    R3,[R0, #+6]
   \   00000070   011045E0           SUB      R1,R5,R1
   \   00000074   072001E2           AND      R2,R1,#0x7
   \   00000078   07A062E2           RSB      R10,R2,#+7
   \   0000007C   08209DE5           LDR      R2,[SP, #+8]
    113              //
    114              // First byte
    115              //
    116              if (Bit < 7) {
   \   00000080   07005AE3           CMP      R10,#+7
   \   00000084   032042E0           SUB      R2,R2,R3
   \   00000088   0C3090E5           LDR      R3,[R0, #+12]
   \   0000008C   930202E0           MUL      R2,R3,R2
   \   00000090   C11182E0           ADD      R1,R2,R1, ASR #+3
   \   00000094   000081E0           ADD      R0,R1,R0
   \   00000098   18B080E2           ADD      R11,R0,#+24
   \   0000009C   1F0000AA           BGE      ??_DrawBitLine1BPP_5
    117                AndMask = 0xff << (Bit + 1);
   \   000000A0   FF00A0E3           MOV      R0,#+255
   \   000000A4   01108AE2           ADD      R1,R10,#+1
   \   000000A8   1001A0E1           LSL      R0,R0,R1
    118                AndMask |= (AndMask ^ 0xff) >> xsize;
    119                *pData &= AndMask;
   \   000000AC   FF2000E2           AND      R2,R0,#0xFF
   \   000000B0   0010DBE5           LDRB     R1,[R11, #+0]
   \   000000B4   FF2022E2           EOR      R2,R2,#0xFF
   \   000000B8   520780E1           ORR      R0,R0,R2, ASR R7
   \   000000BC   010000E0           AND      R0,R0,R1
   \   000000C0   0000CBE5           STRB     R0,[R11, #+0]
    120                NumPixels = Bit + 1;
   \   000000C4   01008AE2           ADD      R0,R10,#+1
    121                if (NumPixels > xsize) {
   \   000000C8   000057E1           CMP      R7,R0
   \   000000CC   0700A091           MOVLS    R0,R7
   \   000000D0   00008DE5           STR      R0,[SP, #+0]
    122                  NumPixels = xsize;
    123                }
    124                xsize -= NumPixels;
   \   000000D4   007047E0           SUB      R7,R7,R0
    125                do {
    126                  *pData |= *(pTrans + ((U8)pixels >> 7)) << Bit--;
   \                     ??_DrawBitLine1BPP_6:
   \   000000D8   FF1009E2           AND      R1,R9,#0xFF
   \   000000DC   3C209DE5           LDR      R2,[SP, #+60]
   \   000000E0   0000DBE5           LDRB     R0,[R11, #+0]
   \   000000E4   C113A0E1           ASR      R1,R1,#+7
   \   000000E8   011192E7           LDR      R1,[R2, +R1, LSL #+2]
    127                  pixels <<= 1;
   \   000000EC   8990A0E1           LSL      R9,R9,#+1
   \   000000F0   110A80E1           ORR      R0,R0,R1, LSL R10
   \   000000F4   0000CBE5           STRB     R0,[R11, #+0]
    128                  if (--PixelCnt == 0) {
    129                    PixelCnt = 8;
    130                    pixels = *(++p);
    131                  }
    132                } while (--NumPixels);
   \   000000F8   00009DE5           LDR      R0,[SP, #+0]
   \   000000FC   018058E2           SUBS     R8,R8,#+1
   \   00000100   0880A003           MOVEQ    R8,#+8
   \   00000104   0190F605           LDRBEQ   R9,[R6, #+1]!
   \   00000108   010040E2           SUB      R0,R0,#+1
   \   0000010C   01A04AE2           SUB      R10,R10,#+1
   \   00000110   00008DE5           STR      R0,[SP, #+0]
   \   00000114   000050E3           CMP      R0,#+0
   \   00000118   EEFFFF1A           BNE      ??_DrawBitLine1BPP_6
    133                pData++;
   \   0000011C   01B08BE2           ADD      R11,R11,#+1
    134              }
    135              //
    136              // Complete byte
    137              //
    138              while (xsize >= 8) {
   \                     ??_DrawBitLine1BPP_5:
   \   00000120   080057E3           CMP      R7,#+8
   \   00000124   1400003A           BCC      ??_DrawBitLine1BPP_7
    139                *pData = 0;
   \                     ??_DrawBitLine1BPP_8:
   \   00000128   0000A0E3           MOV      R0,#+0
   \   0000012C   0000CBE5           STRB     R0,[R11, #+0]
    140                for (Bit = 7; Bit >= 0; ) {
   \   00000130   07A0A0E3           MOV      R10,#+7
    141                  *pData |= *(pTrans + ((U8)pixels >> 7)) << Bit--;
   \                     ??_DrawBitLine1BPP_9:
   \   00000134   FF1009E2           AND      R1,R9,#0xFF
   \   00000138   3C209DE5           LDR      R2,[SP, #+60]
   \   0000013C   0000DBE5           LDRB     R0,[R11, #+0]
   \   00000140   C113A0E1           ASR      R1,R1,#+7
   \   00000144   011192E7           LDR      R1,[R2, +R1, LSL #+2]
    142                  pixels <<= 1;
   \   00000148   8990A0E1           LSL      R9,R9,#+1
   \   0000014C   110A80E1           ORR      R0,R0,R1, LSL R10
   \   00000150   0000CBE5           STRB     R0,[R11, #+0]
    143                  if (--PixelCnt == 0) {
   \   00000154   018058E2           SUBS     R8,R8,#+1
   \   00000158   01A04AE2           SUB      R10,R10,#+1
    144                    PixelCnt = 8;
   \   0000015C   0880A003           MOVEQ    R8,#+8
    145                    pixels = *(++p);
   \   00000160   0190F605           LDRBEQ   R9,[R6, #+1]!
    146                  }
    147                }
   \   00000164   00005AE3           CMP      R10,#+0
   \   00000168   F1FFFF5A           BPL      ??_DrawBitLine1BPP_9
    148                pData++;
    149                xsize -= 8;
   \   0000016C   087047E2           SUB      R7,R7,#+8
   \   00000170   01B08BE2           ADD      R11,R11,#+1
   \   00000174   080057E3           CMP      R7,#+8
   \   00000178   EAFFFF2A           BCS      ??_DrawBitLine1BPP_8
    150              }
    151              //
    152              // Last byte
    153              //
    154              if (xsize) {
   \                     ??_DrawBitLine1BPP_7:
   \   0000017C   000057E3           CMP      R7,#+0
   \   00000180   9A00000A           BEQ      ??_DrawBitLine1BPP_1
    155                Bit = 7;
    156                AndMask = 0xff >> xsize;
    157                *pData &= AndMask;
   \   00000184   0000DBE5           LDRB     R0,[R11, #+0]
   \   00000188   FF10A0E3           MOV      R1,#+255
   \   0000018C   07A0A0E3           MOV      R10,#+7
   \   00000190   510700E0           AND      R0,R0,R1, ASR R7
   \   00000194   0000CBE5           STRB     R0,[R11, #+0]
    158                do {
    159                  *pData |= *(pTrans + ((U8)pixels >> 7)) << Bit--;
   \                     ??_DrawBitLine1BPP_10:
   \   00000198   FF1009E2           AND      R1,R9,#0xFF
   \   0000019C   3C209DE5           LDR      R2,[SP, #+60]
   \   000001A0   0000DBE5           LDRB     R0,[R11, #+0]
   \   000001A4   C113A0E1           ASR      R1,R1,#+7
   \   000001A8   011192E7           LDR      R1,[R2, +R1, LSL #+2]
    160                  pixels <<= 1;
   \   000001AC   8990A0E1           LSL      R9,R9,#+1
   \   000001B0   110A80E1           ORR      R0,R0,R1, LSL R10
   \   000001B4   0000CBE5           STRB     R0,[R11, #+0]
    161                  if (--PixelCnt == 0) {
   \   000001B8   018058E2           SUBS     R8,R8,#+1
    162                    PixelCnt = 8;
   \   000001BC   0880A003           MOVEQ    R8,#+8
    163                    pixels = *(++p);
   \   000001C0   0190F605           LDRBEQ   R9,[R6, #+1]!
   \   000001C4   01A04AE2           SUB      R10,R10,#+1
    164                  }
    165                } while (--xsize);
   \   000001C8   017057E2           SUBS     R7,R7,#+1
   \   000001CC   F1FFFF1A           BNE      ??_DrawBitLine1BPP_10
   \   000001D0   860000EA           B        ??_DrawBitLine1BPP_1
    166              }
    167              break;
    168            case LCD_DRAWMODE_TRANS:
    169              Index1 = *(pTrans + 1);
   \                     ??_DrawBitLine1BPP_4:
   \   000001D4   3C109DE5           LDR      R1,[SP, #+60]
    170              pData = _XY2PTR_BITOFFSET(x, y, &Bit);
   \   000001D8   880090E5           LDR      R0,[R0, #+136]
   \   000001DC   041091E5           LDR      R1,[R1, #+4]
   \   000001E0   FF1001E2           AND      R1,R1,#0xFF
   \   000001E4   04108DE5           STR      R1,[SP, #+4]
   \   000001E8   ........           BL       GUI_ALLOC_h2p
   \   000001EC   F410D0E1           LDRSH    R1,[R0, #+4]
   \   000001F0   F630D0E1           LDRSH    R3,[R0, #+6]
   \   000001F4   011045E0           SUB      R1,R5,R1
   \   000001F8   072001E2           AND      R2,R1,#0x7
   \   000001FC   07A062E2           RSB      R10,R2,#+7
   \   00000200   08209DE5           LDR      R2,[SP, #+8]
    171              //
    172              // First byte
    173              //
    174              if (Bit < 7) {
   \   00000204   07005AE3           CMP      R10,#+7
   \   00000208   032042E0           SUB      R2,R2,R3
   \   0000020C   0C3090E5           LDR      R3,[R0, #+12]
   \   00000210   930202E0           MUL      R2,R3,R2
   \   00000214   C11182E0           ADD      R1,R2,R1, ASR #+3
   \   00000218   000081E0           ADD      R0,R1,R0
   \   0000021C   18B080E2           ADD      R11,R0,#+24
   \   00000220   210000AA           BGE      ??_DrawBitLine1BPP_11
    175                NumPixels = Bit + 1;
   \   00000224   01008AE2           ADD      R0,R10,#+1
    176                if (NumPixels > xsize) {
   \   00000228   000057E1           CMP      R7,R0
   \   0000022C   0700A091           MOVLS    R0,R7
   \   00000230   00008DE5           STR      R0,[SP, #+0]
    177                  NumPixels = xsize;
    178                }
    179                xsize -= NumPixels;
   \   00000234   007047E0           SUB      R7,R7,R0
    180                do {
    181                  if (pixels & 0x80) {
   \                     ??_DrawBitLine1BPP_12:
   \   00000238   800019E3           TST      R9,#0x80
   \   0000023C   0E00000A           BEQ      ??_DrawBitLine1BPP_13
    182                    if (Index1) {
   \   00000240   0000DBE5           LDRB     R0,[R11, #+0]
   \   00000244   04209DE5           LDR      R2,[SP, #+4]
   \   00000248   0110A0E3           MOV      R1,#+1
   \   0000024C   000052E3           CMP      R2,#+0
    183                      *pData |= 1 << Bit;
   \   00000250   110A8011           ORRNE    R0,R0,R1, LSL R10
    184                    } else {
    185                      *pData &= ~(1 << Bit);
   \   00000254   110AC001           BICEQ    R0,R0,R1, LSL R10
   \   00000258   0000CBE5           STRB     R0,[R11, #+0]
    186                    }
    187                    if (pUsage) {
   \   0000025C   000054E3           CMP      R4,#+0
   \   00000260   0500000A           BEQ      ??_DrawBitLine1BPP_13
    188                      GUI_USAGE_AddPixel(pUsage, x, y);
   \   00000264   083094E5           LDR      R3,[R4, #+8]
   \   00000268   08209DE5           LDR      R2,[SP, #+8]
   \   0000026C   0510A0E1           MOV      R1,R5
   \   00000270   0400A0E1           MOV      R0,R4
   \   00000274   003093E5           LDR      R3,[R3, #+0]
   \   00000278   33FF2FE1           BLX      R3
    189                    }
    190                  }
    191                  Bit--;
    192                  pixels <<= 1;
    193                  if (--PixelCnt == 0) {
    194                    PixelCnt = 8;
    195                    pixels = *(++p);
    196                  }
    197                  x++;
    198                } while (--NumPixels);
   \                     ??_DrawBitLine1BPP_13:
   \   0000027C   00009DE5           LDR      R0,[SP, #+0]
   \   00000280   8990A0E1           LSL      R9,R9,#+1
   \   00000284   018058E2           SUBS     R8,R8,#+1
   \   00000288   0880A003           MOVEQ    R8,#+8
   \   0000028C   0190F605           LDRBEQ   R9,[R6, #+1]!
   \   00000290   010040E2           SUB      R0,R0,#+1
   \   00000294   01A04AE2           SUB      R10,R10,#+1
   \   00000298   015085E2           ADD      R5,R5,#+1
   \   0000029C   00008DE5           STR      R0,[SP, #+0]
   \   000002A0   000050E3           CMP      R0,#+0
   \   000002A4   E3FFFF1A           BNE      ??_DrawBitLine1BPP_12
    199                pData++;
   \   000002A8   01B08BE2           ADD      R11,R11,#+1
    200              }
    201              //
    202              // Complete byte
    203              //
    204              while (xsize >= 8) {
   \                     ??_DrawBitLine1BPP_11:
   \   000002AC   080057E3           CMP      R7,#+8
   \   000002B0   1D00003A           BCC      ??_DrawBitLine1BPP_14
    205                for (Bit = 7; Bit >= 0; ) {
   \                     ??_DrawBitLine1BPP_15:
   \   000002B4   07A0A0E3           MOV      R10,#+7
    206                  if (pixels & 0x80) {
   \                     ??_DrawBitLine1BPP_16:
   \   000002B8   800019E3           TST      R9,#0x80
   \   000002BC   0E00000A           BEQ      ??_DrawBitLine1BPP_17
    207                    if (Index1) {
   \   000002C0   0000DBE5           LDRB     R0,[R11, #+0]
   \   000002C4   04209DE5           LDR      R2,[SP, #+4]
   \   000002C8   0110A0E3           MOV      R1,#+1
   \   000002CC   000052E3           CMP      R2,#+0
    208                      *pData |= 1 << Bit;
   \   000002D0   110A8011           ORRNE    R0,R0,R1, LSL R10
    209                    } else {
    210                      *pData &= ~(1 << Bit);
   \   000002D4   110AC001           BICEQ    R0,R0,R1, LSL R10
   \   000002D8   0000CBE5           STRB     R0,[R11, #+0]
    211                    }
    212                    if (pUsage) {
   \   000002DC   000054E3           CMP      R4,#+0
   \   000002E0   0500000A           BEQ      ??_DrawBitLine1BPP_17
    213                      GUI_USAGE_AddPixel(pUsage, x, y);
   \   000002E4   083094E5           LDR      R3,[R4, #+8]
   \   000002E8   08209DE5           LDR      R2,[SP, #+8]
   \   000002EC   0510A0E1           MOV      R1,R5
   \   000002F0   0400A0E1           MOV      R0,R4
   \   000002F4   003093E5           LDR      R3,[R3, #+0]
   \   000002F8   33FF2FE1           BLX      R3
    214                    }
    215                  }
    216                  Bit--;
    217                  pixels <<= 1;
   \                     ??_DrawBitLine1BPP_17:
   \   000002FC   8990A0E1           LSL      R9,R9,#+1
    218                  if (--PixelCnt == 0) {
   \   00000300   018058E2           SUBS     R8,R8,#+1
   \   00000304   01A04AE2           SUB      R10,R10,#+1
    219                    PixelCnt = 8;
   \   00000308   0880A003           MOVEQ    R8,#+8
    220                    pixels = *(++p);
   \   0000030C   0190F605           LDRBEQ   R9,[R6, #+1]!
    221                  }
    222                  x++;
   \   00000310   015085E2           ADD      R5,R5,#+1
    223                }
   \   00000314   00005AE3           CMP      R10,#+0
   \   00000318   E6FFFF5A           BPL      ??_DrawBitLine1BPP_16
    224                pData++;
    225                xsize -= 8;
   \   0000031C   087047E2           SUB      R7,R7,#+8
   \   00000320   01B08BE2           ADD      R11,R11,#+1
   \   00000324   080057E3           CMP      R7,#+8
   \   00000328   E1FFFF2A           BCS      ??_DrawBitLine1BPP_15
    226              }
    227              //
    228              // Last byte
    229              //
    230              if (xsize) {
   \                     ??_DrawBitLine1BPP_14:
   \   0000032C   000057E3           CMP      R7,#+0
   \   00000330   2E00000A           BEQ      ??_DrawBitLine1BPP_1
    231                Bit = 7;
   \   00000334   07A0A0E3           MOV      R10,#+7
    232                do {
    233                  if (pixels & 0x80) {
   \                     ??_DrawBitLine1BPP_18:
   \   00000338   800019E3           TST      R9,#0x80
   \   0000033C   0E00000A           BEQ      ??_DrawBitLine1BPP_19
    234                    if (Index1) {
   \   00000340   0000DBE5           LDRB     R0,[R11, #+0]
   \   00000344   04209DE5           LDR      R2,[SP, #+4]
   \   00000348   0110A0E3           MOV      R1,#+1
   \   0000034C   000052E3           CMP      R2,#+0
    235                      *pData |= 1 << Bit;
   \   00000350   110A8011           ORRNE    R0,R0,R1, LSL R10
    236                    } else {
    237                      *pData &= ~(1 << Bit);
   \   00000354   110AC001           BICEQ    R0,R0,R1, LSL R10
   \   00000358   0000CBE5           STRB     R0,[R11, #+0]
    238                    }
    239                    if (pUsage) {
   \   0000035C   000054E3           CMP      R4,#+0
   \   00000360   0500000A           BEQ      ??_DrawBitLine1BPP_19
    240                      GUI_USAGE_AddPixel(pUsage, x, y);
   \   00000364   083094E5           LDR      R3,[R4, #+8]
   \   00000368   08209DE5           LDR      R2,[SP, #+8]
   \   0000036C   0510A0E1           MOV      R1,R5
   \   00000370   0400A0E1           MOV      R0,R4
   \   00000374   003093E5           LDR      R3,[R3, #+0]
   \   00000378   33FF2FE1           BLX      R3
    241                    }
    242                  }
    243                  Bit--;
    244                  pixels <<= 1;
   \                     ??_DrawBitLine1BPP_19:
   \   0000037C   8990A0E1           LSL      R9,R9,#+1
    245                  if (--PixelCnt == 0) {
   \   00000380   018058E2           SUBS     R8,R8,#+1
    246                    PixelCnt = 8;
   \   00000384   0880A003           MOVEQ    R8,#+8
    247                    pixels = *(++p);
   \   00000388   0190F605           LDRBEQ   R9,[R6, #+1]!
   \   0000038C   01A04AE2           SUB      R10,R10,#+1
    248                  }
    249                  x++;
   \   00000390   015085E2           ADD      R5,R5,#+1
    250                } while (--xsize);
   \   00000394   017057E2           SUBS     R7,R7,#+1
   \   00000398   E6FFFF1A           BNE      ??_DrawBitLine1BPP_18
   \   0000039C   130000EA           B        ??_DrawBitLine1BPP_1
    251              }
    252              break;
    253            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    254            case LCD_DRAWMODE_XOR:
    255            PixelLoopXor:
    256              if (PixelCnt > xsize) {
    257                PixelCnt = xsize;
    258              }
    259              xsize -= PixelCnt;
    260              do {
    261                if ((pixels & 0x80)) {
    262                  (*pDev->pDevice->pDeviceAPI->pfXorPixel)(pDevice, x, y);
    263                }
    264                x++;
    265                pDest++;
    266                pixels <<= 1;
    267              } while (--PixelCnt);
    268              if (xsize) {
    269                PixelCnt = 8;
   \                     ??_DrawBitLine1BPP_20:
   \   000003A0   0880A0E3           MOV      R8,#+8
    270                pixels = *(++p);
   \   000003A4   0190F6E5           LDRB     R9,[R6, #+1]!
    271                goto PixelLoopXor;
    272              }
   \                     ??_DrawBitLine1BPP_3:
   \   000003A8   080057E1           CMP      R7,R8
   \   000003AC   0780A091           MOVLS    R8,R7
   \   000003B0   087047E0           SUB      R7,R7,R8
   \                     ??_DrawBitLine1BPP_21:
   \   000003B4   800019E3           TST      R9,#0x80
   \   000003B8   0600000A           BEQ      ??_DrawBitLine1BPP_22
   \   000003BC   00309BE5           LDR      R3,[R11, #+0]
   \   000003C0   08209DE5           LDR      R2,[SP, #+8]
   \   000003C4   0C3093E5           LDR      R3,[R3, #+12]
   \   000003C8   0510A0E1           MOV      R1,R5
   \   000003CC   0A00A0E1           MOV      R0,R10
   \   000003D0   1C3093E5           LDR      R3,[R3, #+28]
   \   000003D4   33FF2FE1           BLX      R3
   \                     ??_DrawBitLine1BPP_22:
   \   000003D8   015085E2           ADD      R5,R5,#+1
   \   000003DC   8990A0E1           LSL      R9,R9,#+1
   \   000003E0   018058E2           SUBS     R8,R8,#+1
   \   000003E4   F2FFFF1A           BNE      ??_DrawBitLine1BPP_21
   \   000003E8   000057E3           CMP      R7,#+0
   \   000003EC   EBFFFF1A           BNE      ??_DrawBitLine1BPP_20
    273              break;
    274            }
    275          }
   \                     ??_DrawBitLine1BPP_1:
   \   000003F0   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   000003F4   F08FBDE8           POP      {R4-R11,PC}      ;; return
    276          
    277          /*********************************************************************
    278          *
    279          *       _DrawBitLine2BPP
    280          */

   \                                 In section .text, align 4, keep-with-next
    281          static void _DrawBitLine2BPP(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * p, int Diff, int xsize,
    282                                       const LCD_PIXELINDEX* pTrans, GUI_MEMDEV* pDev, PIXELINDEX* pDest)
    283          {
   \                     _DrawBitLine2BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   2C009DE5           LDR      R0,[SP, #+44]
    284            U8 pixels;
    285            U8  PixelCnt;
    286            GUI_USE_PARA(pUsage);
    287            GUI_USE_PARA(pDest);
    288            PixelCnt = 4 - (Diff & 3);
    289            pixels = (*p) << ((Diff & 3) << 1);
   \   00000010   28109DE5           LDR      R1,[SP, #+40]
   \   00000014   030000E2           AND      R0,R0,#0x3
   \   00000018   0010D1E5           LDRB     R1,[R1, #+0]
   \   0000001C   04A060E2           RSB      R10,R0,#+4
   \   00000020   8000A0E1           LSL      R0,R0,#+1
   \   00000024   1190A0E1           LSL      R9,R1,R0
    290            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000028   ........           LDR      R0,??DataTable9
   \   0000002C   0250A0E1           MOV      R5,R2
   \   00000030   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000034   0360A0E1           MOV      R6,R3
   \   00000038   30B09DE5           LDR      R11,[SP, #+48]
   \   0000003C   34709DE5           LDR      R7,[SP, #+52]
   \   00000040   38809DE5           LDR      R8,[SP, #+56]
   \   00000044   030010E2           ANDS     R0,R0,#0x3
   \   00000048   0200000A           BEQ      ??_DrawBitLine2BPP_0
   \   0000004C   020050E2           SUBS     R0,R0,#+2
   \   00000050   2100000A           BEQ      ??_DrawBitLine2BPP_1
   \   00000054   380000EA           B        ??_DrawBitLine2BPP_2
    291            case 0:    // Write mode
    292            PixelLoopWrite:
    293              if (PixelCnt > xsize) {
   \                     ??_DrawBitLine2BPP_0:
   \   00000058   0A0CA0E1           MOV      R0,R10, LSL #+24
   \   0000005C   200C5BE1           CMP      R11,R0, LSR #+24
    294                PixelCnt = xsize;
   \   00000060   0BA0A0B1           MOVLT    R10,R11
    295              }
    296              xsize -= PixelCnt;
   \   00000064   FF000AE2           AND      R0,R10,#0xFF
   \   00000068   00B04BE0           SUB      R11,R11,R0
    297              do {
    298                (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x++, y, *(pTrans + (pixels >> 6)));
   \                     ??_DrawBitLine2BPP_3:
   \   0000006C   00C098E5           LDR      R12,[R8, #+0]
   \   00000070   FF0009E2           AND      R0,R9,#0xFF
   \   00000074   4003A0E1           ASR      R0,R0,#+6
   \   00000078   0CC09CE5           LDR      R12,[R12, #+12]
   \   0000007C   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   00000080   0620A0E1           MOV      R2,R6
   \   00000084   0510A0E1           MOV      R1,R5
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   18C09CE5           LDR      R12,[R12, #+24]
   \   00000090   3CFF2FE1           BLX      R12
    299                pixels <<= 2;
    300              } while (--PixelCnt);
   \   00000094   01A04AE2           SUB      R10,R10,#+1
   \   00000098   015085E2           ADD      R5,R5,#+1
   \   0000009C   0991A0E1           LSL      R9,R9,#+2
   \   000000A0   FFA01AE2           ANDS     R10,R10,#0xFF
   \   000000A4   F0FFFF1A           BNE      ??_DrawBitLine2BPP_3
    301              if (xsize) {
   \   000000A8   00005BE3           CMP      R11,#+0
   \   000000AC   2200000A           BEQ      ??_DrawBitLine2BPP_2
    302                PixelCnt = 4;
    303                pixels = *(++p);
   \   000000B0   28109DE5           LDR      R1,[SP, #+40]
   \   000000B4   04A0A0E3           MOV      R10,#+4
   \   000000B8   011081E2           ADD      R1,R1,#+1
   \   000000BC   28108DE5           STR      R1,[SP, #+40]
   \   000000C0   0090D1E5           LDRB     R9,[R1, #+0]
    304                goto PixelLoopWrite;
   \   000000C4   E3FFFFEA           B        ??_DrawBitLine2BPP_0
    305              }
    306              break;
    307            case LCD_DRAWMODE_TRANS:
    308            PixelLoopTrans:
    309              if (PixelCnt > xsize)
    310                PixelCnt = xsize;
    311              xsize -= PixelCnt;
    312              do {
    313                if (pixels & 0xc0) {
    314                  (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x, y, *(pTrans + (pixels >> 6)));
    315                }
    316                x++;
    317                pixels <<= 2;
    318              } while (--PixelCnt);
    319              if (xsize) {
    320                PixelCnt = 4;
    321                pixels = *(++p);
   \                     ??_DrawBitLine2BPP_4:
   \   000000C8   28109DE5           LDR      R1,[SP, #+40]
   \   000000CC   04A0A0E3           MOV      R10,#+4
   \   000000D0   011081E2           ADD      R1,R1,#+1
   \   000000D4   28108DE5           STR      R1,[SP, #+40]
   \   000000D8   0090D1E5           LDRB     R9,[R1, #+0]
    322                goto PixelLoopTrans;
    323              }
   \                     ??_DrawBitLine2BPP_1:
   \   000000DC   0A0CA0E1           MOV      R0,R10, LSL #+24
   \   000000E0   200C5BE1           CMP      R11,R0, LSR #+24
   \   000000E4   0BA0A0B1           MOVLT    R10,R11
   \   000000E8   FF000AE2           AND      R0,R10,#0xFF
   \   000000EC   00B04BE0           SUB      R11,R11,R0
   \                     ??_DrawBitLine2BPP_5:
   \   000000F0   C00019E3           TST      R9,#0xC0
   \   000000F4   0900000A           BEQ      ??_DrawBitLine2BPP_6
   \   000000F8   00C098E5           LDR      R12,[R8, #+0]
   \   000000FC   FF0009E2           AND      R0,R9,#0xFF
   \   00000100   4003A0E1           ASR      R0,R0,#+6
   \   00000104   0CC09CE5           LDR      R12,[R12, #+12]
   \   00000108   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   0000010C   0620A0E1           MOV      R2,R6
   \   00000110   0510A0E1           MOV      R1,R5
   \   00000114   0400A0E1           MOV      R0,R4
   \   00000118   18C09CE5           LDR      R12,[R12, #+24]
   \   0000011C   3CFF2FE1           BLX      R12
   \                     ??_DrawBitLine2BPP_6:
   \   00000120   01A04AE2           SUB      R10,R10,#+1
   \   00000124   015085E2           ADD      R5,R5,#+1
   \   00000128   0991A0E1           LSL      R9,R9,#+2
   \   0000012C   FFA01AE2           ANDS     R10,R10,#0xFF
   \   00000130   EEFFFF1A           BNE      ??_DrawBitLine2BPP_5
   \   00000134   00005BE3           CMP      R11,#+0
   \   00000138   E2FFFF1A           BNE      ??_DrawBitLine2BPP_4
    324              break;
    325            }
    326          }
   \                     ??_DrawBitLine2BPP_2:
   \   0000013C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000140   F08FBDE8           POP      {R4-R11,PC}      ;; return
    327          
    328          /*********************************************************************
    329          *
    330          *       _DrawBitLine4BPP
    331          */

   \                                 In section .text, align 4, keep-with-next
    332          static void _DrawBitLine4BPP(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * p, int Diff, int xsize,
    333                                       const LCD_PIXELINDEX* pTrans, GUI_MEMDEV* pDev, PIXELINDEX* pDest)
    334          {
   \                     _DrawBitLine4BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   28609DE5           LDR      R6,[SP, #+40]
   \   00000010   2C009DE5           LDR      R0,[SP, #+44]
   \   00000014   0290A0E1           MOV      R9,R2
    335            U8 pixels;
    336            GUI_USE_PARA(pUsage);
    337            GUI_USE_PARA(pDest);
    338            pixels = (*p) << ((Diff & 1) << 2);
   \   00000018   0010D6E5           LDRB     R1,[R6, #+0]
   \   0000001C   012000E2           AND      R2,R0,#0x1
   \   00000020   0221A0E1           LSL      R2,R2,#+2
   \   00000024   11A2A0E1           LSL      R10,R1,R2
    339            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000028   ........           LDR      R1,??DataTable9
   \   0000002C   0350A0E1           MOV      R5,R3
   \   00000030   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000034   30B09DE5           LDR      R11,[SP, #+48]
   \   00000038   34709DE5           LDR      R7,[SP, #+52]
   \   0000003C   38809DE5           LDR      R8,[SP, #+56]
   \   00000040   FFA00AE2           AND      R10,R10,#0xFF
   \   00000044   031011E2           ANDS     R1,R1,#0x3
   \   00000048   0200000A           BEQ      ??_DrawBitLine4BPP_0
   \   0000004C   021051E2           SUBS     R1,R1,#+2
   \   00000050   3200000A           BEQ      ??_DrawBitLine4BPP_1
   \   00000054   680000EA           B        ??_DrawBitLine4BPP_2
    340            case 0:
    341              //
    342              // Draw incomplete bytes to the left of center area
    343              //
    344              if (Diff) {
   \                     ??_DrawBitLine4BPP_0:
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0B00000A           BEQ      ??_DrawBitLine4BPP_3
    345                (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x++, y, *(pTrans + (pixels >> 4)));
   \   00000060   00C098E5           LDR      R12,[R8, #+0]
   \   00000064   4A02A0E1           ASR      R0,R10,#+4
   \   00000068   0CC09CE5           LDR      R12,[R12, #+12]
   \   0000006C   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   00000070   0520A0E1           MOV      R2,R5
   \   00000074   0910A0E1           MOV      R1,R9
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   18C09CE5           LDR      R12,[R12, #+24]
   \   00000080   3CFF2FE1           BLX      R12
   \   00000084   019089E2           ADD      R9,R9,#+1
    346                xsize--;
   \   00000088   01B04BE2           SUB      R11,R11,#+1
    347                pixels = *++p;
   \   0000008C   01A0F6E5           LDRB     R10,[R6, #+1]!
    348              }
    349              //
    350              // Draw center area (2 pixels in one byte)
    351              //
    352              if (xsize >= 2) {
   \                     ??_DrawBitLine4BPP_3:
   \   00000090   02005BE3           CMP      R11,#+2
   \   00000094   1C0000BA           BLT      ??_DrawBitLine4BPP_4
    353                int i = xsize >> 1;
   \   00000098   CB10A0E1           ASR      R1,R11,#+1
   \   0000009C   00108DE5           STR      R1,[SP, #+0]
    354                xsize &= 1;
   \   000000A0   01B00BE2           AND      R11,R11,#0x1
    355                do {
    356                  (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x++, y, *(pTrans + (pixels >>  4)));
   \                     ??_DrawBitLine4BPP_5:
   \   000000A4   00C098E5           LDR      R12,[R8, #+0]
   \   000000A8   4A02A0E1           ASR      R0,R10,#+4
   \   000000AC   0CC09CE5           LDR      R12,[R12, #+12]
   \   000000B0   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   000000B4   0520A0E1           MOV      R2,R5
   \   000000B8   0910A0E1           MOV      R1,R9
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   18C09CE5           LDR      R12,[R12, #+24]
   \   000000C4   3CFF2FE1           BLX      R12
    357                  (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x++, y, *(pTrans + (pixels  & 15)));
   \   000000C8   00C098E5           LDR      R12,[R8, #+0]
   \   000000CC   0F000AE2           AND      R0,R10,#0xF
   \   000000D0   0CC09CE5           LDR      R12,[R12, #+12]
   \   000000D4   019089E2           ADD      R9,R9,#+1
   \   000000D8   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   000000DC   0520A0E1           MOV      R2,R5
   \   000000E0   0910A0E1           MOV      R1,R9
   \   000000E4   0400A0E1           MOV      R0,R4
   \   000000E8   18C09CE5           LDR      R12,[R12, #+24]
   \   000000EC   3CFF2FE1           BLX      R12
    358                  pixels = *++p;
    359                } while (--i);
   \   000000F0   00109DE5           LDR      R1,[SP, #+0]
   \   000000F4   01A0F6E5           LDRB     R10,[R6, #+1]!
   \   000000F8   011041E2           SUB      R1,R1,#+1
   \   000000FC   019089E2           ADD      R9,R9,#+1
   \   00000100   00108DE5           STR      R1,[SP, #+0]
   \   00000104   000051E3           CMP      R1,#+0
   \   00000108   E5FFFF1A           BNE      ??_DrawBitLine4BPP_5
    360              }
    361              //
    362              // Draw incomplete bytes to the right of center area
    363              //
    364              if (xsize) {
   \                     ??_DrawBitLine4BPP_4:
   \   0000010C   00005BE3           CMP      R11,#+0
   \   00000110   3900000A           BEQ      ??_DrawBitLine4BPP_2
    365                (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x++, y, *(pTrans + (pixels >> 4)));
   \   00000114   4A02A0E1           ASR      R0,R10,#+4
   \   00000118   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   0000011C   2F0000EA           B        ??_DrawBitLine4BPP_6
    366              }
    367              break;
    368            case LCD_DRAWMODE_TRANS:
    369              //
    370              // Draw incomplete bytes to the left of center area
    371              //
    372              if (Diff) {
   \                     ??_DrawBitLine4BPP_1:
   \   00000120   000050E3           CMP      R0,#+0
   \   00000124   0D00000A           BEQ      ??_DrawBitLine4BPP_7
    373                if (pixels & 0xF0) {
   \   00000128   F0001AE3           TST      R10,#0xF0
   \   0000012C   0800000A           BEQ      ??_DrawBitLine4BPP_8
    374                  (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x, y, *(pTrans + (pixels >> 4)));
   \   00000130   00C098E5           LDR      R12,[R8, #+0]
   \   00000134   4A02A0E1           ASR      R0,R10,#+4
   \   00000138   0CC09CE5           LDR      R12,[R12, #+12]
   \   0000013C   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   00000140   0520A0E1           MOV      R2,R5
   \   00000144   0910A0E1           MOV      R1,R9
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   18C09CE5           LDR      R12,[R12, #+24]
   \   00000150   3CFF2FE1           BLX      R12
    375                }
    376                x++;
   \                     ??_DrawBitLine4BPP_8:
   \   00000154   019089E2           ADD      R9,R9,#+1
    377                xsize--;
   \   00000158   01B04BE2           SUB      R11,R11,#+1
    378                pixels = *++p;
   \   0000015C   01A0F6E5           LDRB     R10,[R6, #+1]!
    379              }
    380              //
    381              // Draw center area (2 pixels in one byte)
    382              //
    383              while (xsize >= 2) {
   \                     ??_DrawBitLine4BPP_7:
   \   00000160   02005BE3           CMP      R11,#+2
   \   00000164   190000BA           BLT      ??_DrawBitLine4BPP_9
    384                //
    385                // Draw 1. (left) pixel
    386                //
    387                if (pixels & 0xF0) {
   \                     ??_DrawBitLine4BPP_10:
   \   00000168   F0001AE3           TST      R10,#0xF0
   \   0000016C   0800000A           BEQ      ??_DrawBitLine4BPP_11
    388                  (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x, y, *(pTrans + (pixels >> 4)));
   \   00000170   00C098E5           LDR      R12,[R8, #+0]
   \   00000174   4A02A0E1           ASR      R0,R10,#+4
   \   00000178   0CC09CE5           LDR      R12,[R12, #+12]
   \   0000017C   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   00000180   0520A0E1           MOV      R2,R5
   \   00000184   0910A0E1           MOV      R1,R9
   \   00000188   0400A0E1           MOV      R0,R4
   \   0000018C   18C09CE5           LDR      R12,[R12, #+24]
   \   00000190   3CFF2FE1           BLX      R12
    389                }
    390                //
    391                // Draw 2. (right) pixel
    392                //
    393                if (pixels &= 15) {
   \                     ??_DrawBitLine4BPP_11:
   \   00000194   0F001AE2           ANDS     R0,R10,#0xF
   \   00000198   0700000A           BEQ      ??_DrawBitLine4BPP_12
    394                  (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x + 1, y, *(pTrans + pixels));
   \   0000019C   00C098E5           LDR      R12,[R8, #+0]
   \   000001A0   003197E7           LDR      R3,[R7, +R0, LSL #+2]
   \   000001A4   0CC09CE5           LDR      R12,[R12, #+12]
   \   000001A8   0520A0E1           MOV      R2,R5
   \   000001AC   011089E2           ADD      R1,R9,#+1
   \   000001B0   0400A0E1           MOV      R0,R4
   \   000001B4   18C09CE5           LDR      R12,[R12, #+24]
   \   000001B8   3CFF2FE1           BLX      R12
    395                }
    396                x += 2;
    397                xsize -= 2;
   \                     ??_DrawBitLine4BPP_12:
   \   000001BC   02B04BE2           SUB      R11,R11,#+2
   \   000001C0   029089E2           ADD      R9,R9,#+2
    398                pixels = *++p;
   \   000001C4   01A0F6E5           LDRB     R10,[R6, #+1]!
   \   000001C8   02005BE3           CMP      R11,#+2
   \   000001CC   E5FFFFAA           BGE      ??_DrawBitLine4BPP_10
    399              }
    400              //
    401              // Draw incomplete bytes to the right of center area
    402              //
    403              if (xsize) {
   \                     ??_DrawBitLine4BPP_9:
   \   000001D0   00005BE3           CMP      R11,#+0
    404                if (pixels >>= 4) {
   \   000001D4   2AA2B011           LSRSNE   R10,R10,#+4
   \   000001D8   0700000A           BEQ      ??_DrawBitLine4BPP_2
    405                  (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x, y, *(pTrans + pixels));
   \   000001DC   0A3197E7           LDR      R3,[R7, +R10, LSL #+2]
   \                     ??_DrawBitLine4BPP_6:
   \   000001E0   00C098E5           LDR      R12,[R8, #+0]
   \   000001E4   0520A0E1           MOV      R2,R5
   \   000001E8   0CC09CE5           LDR      R12,[R12, #+12]
   \   000001EC   0910A0E1           MOV      R1,R9
   \   000001F0   0400A0E1           MOV      R0,R4
   \   000001F4   18C09CE5           LDR      R12,[R12, #+24]
   \   000001F8   3CFF2FE1           BLX      R12
    406                }
    407              }
    408              break;
    409            }
    410          }
   \                     ??_DrawBitLine4BPP_2:
   \   000001FC   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000200   F08FBDE8           POP      {R4-R11,PC}      ;; return
    411          
    412          /*********************************************************************
    413          *
    414          *       _DrawBitLine8BPP
    415          */
    416          static void _DrawBitLine8BPP(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * pSrc, int xsize,
    417                                       const LCD_PIXELINDEX* pTrans, GUI_MEMDEV* pDev, PIXELINDEX* pDest) {
    418            GUI_USE_PARA(pUsage);
    419            GUI_USE_PARA(pDest);
    420            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    421            case 0:    // Write mode
    422              do {
    423                (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x++, y, *(pTrans + *pSrc));
    424                pSrc++;
    425              } while (--xsize);
    426              break;
    427            case LCD_DRAWMODE_TRANS:
    428              do {
    429                if (*pSrc) {
    430                  (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x, y, *(pTrans + *pSrc));
    431                }
    432                x++;
    433                pSrc++;
    434              } while (--xsize);
    435              break;
    436            }
    437          }
    438          
    439          /*********************************************************************
    440          *
    441          *       _DrawBitLine8BPP_DDB
    442          */
    443          static void _DrawBitLine8BPP_DDB(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * pSrc, int xsize, GUI_MEMDEV* pDev, PIXELINDEX* pDest) {
    444            GUI_USE_PARA(pUsage);
    445            GUI_USE_PARA(pDest);
    446            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    447            case 0:    // Write mode
    448              do {
    449                (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x++, y, *pSrc);
    450                pSrc++;
    451              } while (--xsize);
    452              break;
    453            case LCD_DRAWMODE_TRANS:
    454              do {
    455                if (*pSrc) {
    456                  (*pDev->pDevice->pDeviceAPI->pfSetPixelIndex)(pDevice, x, y, *pSrc);
    457                }
    458                x++;
    459                pSrc++;
    460              } while (--xsize);
    461              break;
    462            }
    463          }
    464          
    465          /*********************************************************************
    466          *
    467          *       _DrawBitmap
    468          */

   \                                 In section .text, align 4, keep-with-next
    469          static void _DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize,
    470                                  int BitsPerPixel, int BytesPerLine,
    471                                  const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX* pTrans)
    472          {
   \                     _DrawBitmap:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   ........           LDR      R0,??DataTable9
   \   0000000C   20D04DE2           SUB      SP,SP,#+32
   \   00000010   01A0A0E1           MOV      R10,R1
   \   00000014   0280A0E1           MOV      R8,R2
   \   00000018   54509DE5           LDR      R5,[SP, #+84]
   \   0000001C   5C609DE5           LDR      R6,[SP, #+92]
   \   00000020   880090E5           LDR      R0,[R0, #+136]
    473            int i;
    474            GUI_MEMDEV* pDev   = GUI_MEMDEV_H2P(GUI_Context.hDevData);
   \   00000024   ........           BL       GUI_ALLOC_h2p
   \   00000028   0070A0E1           MOV      R7,R0
    475            GUI_USAGE*  pUsage = (pDev->hUsage) ? GUI_USAGE_H2P(pDev->hUsage) : 0;
   \   0000002C   140097E5           LDR      R0,[R7, #+20]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0200000A           BEQ      ??_DrawBitmap_0
   \   00000038   ........           BL       GUI_ALLOC_h2p
   \   0000003C   0090A0E1           MOV      R9,R0
   \   00000040   000000EA           B        ??_DrawBitmap_1
   \                     ??_DrawBitmap_0:
   \   00000044   0090A0E3           MOV      R9,#+0
    476            unsigned    BytesPerLineDest;
    477            PIXELINDEX* pDest;
    478            BytesPerLineDest = pDev->BytesPerLine;
   \                     ??_DrawBitmap_1:
   \   00000048   0C0097E5           LDR      R0,[R7, #+12]
    479            x0 += Diff;
    480            //
    481            // Mark all affected pixels dirty unless transparency is set
    482            //
    483            if (pUsage) {
   \   0000004C   000059E3           CMP      R9,#+0
   \   00000050   1C008DE5           STR      R0,[SP, #+28]
   \   00000054   58009DE5           LDR      R0,[SP, #+88]
   \   00000058   0A0080E0           ADD      R0,R0,R10
   \   0000005C   18008DE5           STR      R0,[SP, #+24]
   \   00000060   0A00000A           BEQ      ??_DrawBitmap_2
    484              if ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) == 0) {
   \   00000064   ........           LDR      R0,??DataTable9
   \   00000068   1000D0E5           LDRB     R0,[R0, #+16]
   \   0000006C   020010E3           TST      R0,#0x2
   \   00000070   0600001A           BNE      ??_DrawBitmap_2
    485                GUI_USAGE_AddRect(pUsage, x0, y0 , xsize, ysize);
   \   00000074   48009DE5           LDR      R0,[SP, #+72]
   \   00000078   20309DE5           LDR      R3,[SP, #+32]
   \   0000007C   00008DE5           STR      R0,[SP, #+0]
   \   00000080   0820A0E1           MOV      R2,R8
   \   00000084   18109DE5           LDR      R1,[SP, #+24]
   \   00000088   0900A0E1           MOV      R0,R9
   \   0000008C   ........           BL       GUI_USAGE_AddRect
    486              }
    487            }
    488            pDest = _XY2PTR_BITOFFSET(x0, y0, 0);
   \                     ??_DrawBitmap_2:
   \   00000090   ........           LDR      R0,??DataTable9
   \   00000094   880090E5           LDR      R0,[R0, #+136]
   \   00000098   ........           BL       GUI_ALLOC_h2p
   \   0000009C   F610D0E1           LDRSH    R1,[R0, #+6]
   \   000000A0   0C2090E5           LDR      R2,[R0, #+12]
   \   000000A4   F430D0E1           LDRSH    R3,[R0, #+4]
   \   000000A8   011048E0           SUB      R1,R8,R1
   \   000000AC   920101E0           MUL      R1,R2,R1
   \   000000B0   18209DE5           LDR      R2,[SP, #+24]
   \   000000B4   032042E0           SUB      R2,R2,R3
   \   000000B8   C21181E0           ADD      R1,R1,R2, ASR #+3
   \   000000BC   000081E0           ADD      R0,R1,R0
   \   000000C0   18A080E2           ADD      R10,R0,#+24
    489            //
    490            // Handle 8 bpp bitmaps seperately as we have different routine bitmaps with or without palette
    491            //
    492            if (BitsPerPixel == 8) {
   \   000000C4   4C009DE5           LDR      R0,[SP, #+76]
   \   000000C8   080050E3           CMP      R0,#+8
   \   000000CC   5900001A           BNE      ??_DrawBitmap_3
    493              for (i = 0; i < ysize; i++) {
   \   000000D0   48009DE5           LDR      R0,[SP, #+72]
   \   000000D4   0010A0E3           MOV      R1,#+0
   \   000000D8   04108DE5           STR      R1,[SP, #+4]
   \   000000DC   010050E3           CMP      R0,#+1
   \   000000E0   930000BA           BLT      ??_DrawBitmap_4
   \   000000E4   00808DE5           STR      R8,[SP, #+0]
    494                if (pTrans) {
   \                     ??_DrawBitmap_5:
   \   000000E8   ........           LDR      R0,??DataTable9
   \   000000EC   000056E3           CMP      R6,#+0
   \   000000F0   20809DE5           LDR      R8,[SP, #+32]
   \   000000F4   0590A0E1           MOV      R9,R5
   \   000000F8   00A09DE5           LDR      R10,[SP, #+0]
   \   000000FC   18B09DE5           LDR      R11,[SP, #+24]
   \   00000100   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000104   2000000A           BEQ      ??_DrawBitmap_6
    495                  _DrawBitLine8BPP(pDevice, pUsage, x0, i + y0, pData, xsize, pTrans, pDev, pDest);
   \   00000108   030010E2           ANDS     R0,R0,#0x3
   \   0000010C   1100000A           BEQ      ??_DrawBitmap_7
   \   00000110   020050E2           SUBS     R0,R0,#+2
   \   00000114   3A00001A           BNE      ??_DrawBitmap_8
   \                     ??_DrawBitmap_9:
   \   00000118   0000D9E5           LDRB     R0,[R9, #+0]
   \   0000011C   000050E3           CMP      R0,#+0
   \   00000120   0700000A           BEQ      ??_DrawBitmap_10
   \   00000124   00C097E5           LDR      R12,[R7, #+0]
   \   00000128   003196E7           LDR      R3,[R6, +R0, LSL #+2]
   \   0000012C   0CC09CE5           LDR      R12,[R12, #+12]
   \   00000130   0A20A0E1           MOV      R2,R10
   \   00000134   0B10A0E1           MOV      R1,R11
   \   00000138   0400A0E1           MOV      R0,R4
   \   0000013C   18C09CE5           LDR      R12,[R12, #+24]
   \   00000140   3CFF2FE1           BLX      R12
   \                     ??_DrawBitmap_10:
   \   00000144   01B08BE2           ADD      R11,R11,#+1
   \   00000148   019089E2           ADD      R9,R9,#+1
   \   0000014C   018058E2           SUBS     R8,R8,#+1
   \   00000150   F0FFFF1A           BNE      ??_DrawBitmap_9
   \   00000154   2A0000EA           B        ??_DrawBitmap_8
   \                     ??_DrawBitmap_7:
   \   00000158   0100D9E4           LDRB     R0,[R9], #+1
   \   0000015C   00C097E5           LDR      R12,[R7, #+0]
   \   00000160   0A20A0E1           MOV      R2,R10
   \   00000164   0CC09CE5           LDR      R12,[R12, #+12]
   \   00000168   003196E7           LDR      R3,[R6, +R0, LSL #+2]
   \   0000016C   0B10A0E1           MOV      R1,R11
   \   00000170   0400A0E1           MOV      R0,R4
   \   00000174   18C09CE5           LDR      R12,[R12, #+24]
   \   00000178   3CFF2FE1           BLX      R12
   \   0000017C   01B08BE2           ADD      R11,R11,#+1
   \   00000180   018058E2           SUBS     R8,R8,#+1
   \   00000184   F3FFFF1A           BNE      ??_DrawBitmap_7
   \   00000188   1D0000EA           B        ??_DrawBitmap_8
    496                } else {
    497                  _DrawBitLine8BPP_DDB(pDevice, pUsage, x0, i + y0, pData, xsize, pDev, pDest);
   \                     ??_DrawBitmap_6:
   \   0000018C   030010E2           ANDS     R0,R0,#0x3
   \   00000190   1000000A           BEQ      ??_DrawBitmap_11
   \   00000194   020050E2           SUBS     R0,R0,#+2
   \   00000198   1900001A           BNE      ??_DrawBitmap_8
   \                     ??_DrawBitmap_12:
   \   0000019C   0030D9E5           LDRB     R3,[R9, #+0]
   \   000001A0   000053E3           CMP      R3,#+0
   \   000001A4   0600000A           BEQ      ??_DrawBitmap_13
   \   000001A8   00C097E5           LDR      R12,[R7, #+0]
   \   000001AC   0A20A0E1           MOV      R2,R10
   \   000001B0   0CC09CE5           LDR      R12,[R12, #+12]
   \   000001B4   0B10A0E1           MOV      R1,R11
   \   000001B8   0400A0E1           MOV      R0,R4
   \   000001BC   18C09CE5           LDR      R12,[R12, #+24]
   \   000001C0   3CFF2FE1           BLX      R12
   \                     ??_DrawBitmap_13:
   \   000001C4   01B08BE2           ADD      R11,R11,#+1
   \   000001C8   019089E2           ADD      R9,R9,#+1
   \   000001CC   018058E2           SUBS     R8,R8,#+1
   \   000001D0   F1FFFF1A           BNE      ??_DrawBitmap_12
   \   000001D4   0A0000EA           B        ??_DrawBitmap_8
   \                     ??_DrawBitmap_11:
   \   000001D8   00C097E5           LDR      R12,[R7, #+0]
   \   000001DC   0130D9E4           LDRB     R3,[R9], #+1
   \   000001E0   0CC09CE5           LDR      R12,[R12, #+12]
   \   000001E4   0A20A0E1           MOV      R2,R10
   \   000001E8   0B10A0E1           MOV      R1,R11
   \   000001EC   0400A0E1           MOV      R0,R4
   \   000001F0   18C09CE5           LDR      R12,[R12, #+24]
   \   000001F4   3CFF2FE1           BLX      R12
   \   000001F8   01B08BE2           ADD      R11,R11,#+1
   \   000001FC   018058E2           SUBS     R8,R8,#+1
   \   00000200   F4FFFF1A           BNE      ??_DrawBitmap_11
    498                }
    499                pData += BytesPerLine;
   \                     ??_DrawBitmap_8:
   \   00000204   50009DE5           LDR      R0,[SP, #+80]
    500                pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
    501              }
   \   00000208   48109DE5           LDR      R1,[SP, #+72]
   \   0000020C   055080E0           ADD      R5,R0,R5
   \   00000210   04009DE5           LDR      R0,[SP, #+4]
   \   00000214   010080E2           ADD      R0,R0,#+1
   \   00000218   04008DE5           STR      R0,[SP, #+4]
   \   0000021C   00009DE5           LDR      R0,[SP, #+0]
   \   00000220   010080E2           ADD      R0,R0,#+1
   \   00000224   00008DE5           STR      R0,[SP, #+0]
   \   00000228   04009DE5           LDR      R0,[SP, #+4]
   \   0000022C   010050E1           CMP      R0,R1
   \   00000230   3F0000AA           BGE      ??_DrawBitmap_4
   \   00000234   ABFFFFEA           B        ??_DrawBitmap_5
    502              return;
    503            }
    504            //
    505            // Use aID for bitmaps without palette
    506            //
    507            if (!pTrans) {
   \                     ??_DrawBitmap_3:
   \   00000238   000056E3           CMP      R6,#+0
    508              pTrans = aID;
    509            }
    510            for (i = 0; i < ysize; i++) {
   \   0000023C   48009DE5           LDR      R0,[SP, #+72]
   \   00000240   ............       ADRLEQ   R6,aID
   \              ....        
   \   00000248   010050E3           CMP      R0,#+1
   \   0000024C   380000BA           BLT      ??_DrawBitmap_4
   \   00000250   00B0A0E1           MOV      R11,R0
    511              switch (BitsPerPixel) {
   \                     ??_DrawBitmap_14:
   \   00000254   4C009DE5           LDR      R0,[SP, #+76]
   \   00000258   010050E2           SUBS     R0,R0,#+1
   \   0000025C   0400000A           BEQ      ??_DrawBitmap_15
   \   00000260   010050E2           SUBS     R0,R0,#+1
   \   00000264   1000000A           BEQ      ??_DrawBitmap_16
   \   00000268   020050E2           SUBS     R0,R0,#+2
   \   0000026C   1C00000A           BEQ      ??_DrawBitmap_17
   \   00000270   280000EA           B        ??_DrawBitmap_18
    512              case 1:
    513                _DrawBitLine1BPP(pDevice, pUsage, x0, i + y0, pData, Diff, xsize, pTrans, pDev, pDest);
   \                     ??_DrawBitmap_15:
   \   00000274   20009DE5           LDR      R0,[SP, #+32]
   \   00000278   14A08DE5           STR      R10,[SP, #+20]
   \   0000027C   08008DE5           STR      R0,[SP, #+8]
   \   00000280   58009DE5           LDR      R0,[SP, #+88]
   \   00000284   10708DE5           STR      R7,[SP, #+16]
   \   00000288   04008DE5           STR      R0,[SP, #+4]
   \   0000028C   0C608DE5           STR      R6,[SP, #+12]
   \   00000290   00508DE5           STR      R5,[SP, #+0]
   \   00000294   0830A0E1           MOV      R3,R8
   \   00000298   18209DE5           LDR      R2,[SP, #+24]
   \   0000029C   0910A0E1           MOV      R1,R9
   \   000002A0   0400A0E1           MOV      R0,R4
   \   000002A4   ........           BL       _DrawBitLine1BPP
    514                break;
   \   000002A8   1A0000EA           B        ??_DrawBitmap_18
    515              case 2:
    516                _DrawBitLine2BPP(pDevice, pUsage, x0, i + y0, pData, Diff, xsize, pTrans, pDev, pDest);
   \                     ??_DrawBitmap_16:
   \   000002AC   20009DE5           LDR      R0,[SP, #+32]
   \   000002B0   14A08DE5           STR      R10,[SP, #+20]
   \   000002B4   08008DE5           STR      R0,[SP, #+8]
   \   000002B8   58009DE5           LDR      R0,[SP, #+88]
   \   000002BC   10708DE5           STR      R7,[SP, #+16]
   \   000002C0   04008DE5           STR      R0,[SP, #+4]
   \   000002C4   0C608DE5           STR      R6,[SP, #+12]
   \   000002C8   00508DE5           STR      R5,[SP, #+0]
   \   000002CC   0830A0E1           MOV      R3,R8
   \   000002D0   18209DE5           LDR      R2,[SP, #+24]
   \   000002D4   0910A0E1           MOV      R1,R9
   \   000002D8   0400A0E1           MOV      R0,R4
   \   000002DC   ........           BL       _DrawBitLine2BPP
    517                break;
   \   000002E0   0C0000EA           B        ??_DrawBitmap_18
    518              case 4:
    519                _DrawBitLine4BPP(pDevice, pUsage, x0, i + y0, pData, Diff, xsize, pTrans, pDev, pDest);
   \                     ??_DrawBitmap_17:
   \   000002E4   20009DE5           LDR      R0,[SP, #+32]
   \   000002E8   14A08DE5           STR      R10,[SP, #+20]
   \   000002EC   08008DE5           STR      R0,[SP, #+8]
   \   000002F0   58009DE5           LDR      R0,[SP, #+88]
   \   000002F4   10708DE5           STR      R7,[SP, #+16]
   \   000002F8   04008DE5           STR      R0,[SP, #+4]
   \   000002FC   0C608DE5           STR      R6,[SP, #+12]
   \   00000300   00508DE5           STR      R5,[SP, #+0]
   \   00000304   0830A0E1           MOV      R3,R8
   \   00000308   18209DE5           LDR      R2,[SP, #+24]
   \   0000030C   0910A0E1           MOV      R1,R9
   \   00000310   0400A0E1           MOV      R0,R4
   \   00000314   ........           BL       _DrawBitLine4BPP
    520                break;
    521              }
    522              pData += BytesPerLine;
   \                     ??_DrawBitmap_18:
   \   00000318   50009DE5           LDR      R0,[SP, #+80]
    523              pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
    524            }
   \   0000031C   018088E2           ADD      R8,R8,#+1
   \   00000320   055080E0           ADD      R5,R0,R5
   \   00000324   1C009DE5           LDR      R0,[SP, #+28]
   \   00000328   01B05BE2           SUBS     R11,R11,#+1
   \   0000032C   0AA080E0           ADD      R10,R0,R10
   \   00000330   C7FFFF1A           BNE      ??_DrawBitmap_14
   \                     ??_DrawBitmap_4:
   \   00000334   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   00000338   F08FBDE8           POP      {R4-R11,PC}      ;; return
    525          }
    526          
    527          /*********************************************************************
    528          *
    529          *       _FillRect
    530          */

   \                                 In section .text, align 4, keep-with-next
    531          static void _FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
    532            GUI_MEMDEV * pDev;
    533            U8 * pData;
    534            int Bit, Len, NumBytes, RemPixels, Color, FillByte;
    535            LCD_PIXELINDEX ColorIndex;
    536          
    537            GUI_USE_PARA(pDevice);
    538            pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
   \   00000004   ........           LDR      R6,??DataTable9
   \   00000008   08D04DE2           SUB      SP,SP,#+8
   \   0000000C   0240A0E1           MOV      R4,R2
   \   00000010   0370A0E1           MOV      R7,R3
   \   00000014   30509DE5           LDR      R5,[SP, #+48]
   \   00000018   880096E5           LDR      R0,[R6, #+136]
   \   0000001C   ........           BL       GUI_ALLOC_h2p
    539            Len = x1 - x0 + 1;
   \   00000020   08109DE5           LDR      R1,[SP, #+8]
    540            //
    541            // Mark rectangle as modified
    542            //
    543            if (pDev->hUsage) {
   \   00000024   140090E5           LDR      R0,[R0, #+20]
   \   00000028   011047E0           SUB      R1,R7,R1
   \   0000002C   017081E2           ADD      R7,R1,#+1
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0700000A           BEQ      ??_FillRect_0
    544              GUI_USAGE_AddRect(GUI_USAGE_H2P(pDev->hUsage), x0, y0, Len, y1 - y0 + 1);
   \   00000038   ........           BL       GUI_ALLOC_h2p
   \   0000003C   041045E0           SUB      R1,R5,R4
   \   00000040   011081E2           ADD      R1,R1,#+1
   \   00000044   00108DE5           STR      R1,[SP, #+0]
   \   00000048   0730A0E1           MOV      R3,R7
   \   0000004C   0420A0E1           MOV      R2,R4
   \   00000050   08109DE5           LDR      R1,[SP, #+8]
   \   00000054   ........           BL       GUI_USAGE_AddRect
    545            }
    546            //
    547            // Do the drawing
    548            //
    549            for (; y0 <= y1; y0++) {
   \                     ??_FillRect_0:
   \   00000058   040055E1           CMP      R5,R4
   \   0000005C   760000BA           BLT      ??_FillRect_1
    550              pData = _XY2PTR_BITOFFSET(x0, y0, &Bit);
   \                     ??_FillRect_2:
   \   00000060   880096E5           LDR      R0,[R6, #+136]
   \   00000064   ........           BL       GUI_ALLOC_h2p
   \   00000068   F630D0E1           LDRSH    R3,[R0, #+6]
   \   0000006C   F420D0E1           LDRSH    R2,[R0, #+4]
   \   00000070   0CC090E5           LDR      R12,[R0, #+12]
   \   00000074   08109DE5           LDR      R1,[SP, #+8]
   \   00000078   033044E0           SUB      R3,R4,R3
   \   0000007C   9C0303E0           MUL      R3,R12,R3
   \   00000080   021041E0           SUB      R1,R1,R2
   \   00000084   072001E2           AND      R2,R1,#0x7
   \   00000088   C11183E0           ADD      R1,R3,R1, ASR #+3
   \   0000008C   000081E0           ADD      R0,R1,R0
   \   00000090   188080E2           ADD      R8,R0,#+24
    551              RemPixels = Len;
    552              if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000094   1000D6E5           LDRB     R0,[R6, #+16]
   \   00000098   072062E2           RSB      R2,R2,#+7
   \   0000009C   0790A0E1           MOV      R9,R7
   \   000000A0   010010E3           TST      R0,#0x1
   \   000000A4   2C00000A           BEQ      ??_FillRect_3
    553                if (Bit < 7) {
   \   000000A8   070052E3           CMP      R2,#+7
   \   000000AC   0A0000AA           BGE      ??_FillRect_4
   \                     ??_FillRect_5:
   \   000000B0   0900A0E1           MOV      R0,R9
   \   000000B4   019040E2           SUB      R9,R0,#+1
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   0500000A           BEQ      ??_FillRect_6
    554                  while ((Bit >= 0) && RemPixels--) {
    555                    *pData ^= 1 << (Bit--);
   \   000000C0   0000D8E5           LDRB     R0,[R8, #+0]
   \   000000C4   0110A0E3           MOV      R1,#+1
   \   000000C8   110220E0           EOR      R0,R0,R1, LSL R2
   \   000000CC   0000C8E5           STRB     R0,[R8, #+0]
   \   000000D0   012052E2           SUBS     R2,R2,#+1
    556                  }
   \   000000D4   F5FFFF5A           BPL      ??_FillRect_5
    557                  pData++;
   \                     ??_FillRect_6:
   \   000000D8   018088E2           ADD      R8,R8,#+1
    558                }
    559                if (RemPixels > 0) {
   \                     ??_FillRect_4:
   \   000000DC   010059E3           CMP      R9,#+1
   \   000000E0   520000BA           BLT      ??_FillRect_7
    560                  NumBytes = RemPixels >> 3;
   \   000000E4   C9B1A0E1           ASR      R11,R9,#+3
    561                  if (NumBytes > 0) {
   \   000000E8   01005BE3           CMP      R11,#+1
   \   000000EC   050000BA           BLT      ??_FillRect_8
    562                    RemPixels -= NumBytes << 3;
   \   000000F0   8B9149E0           SUB      R9,R9,R11, LSL #+3
    563                    do {
    564                      *pData ^= 0xFF;
   \                     ??_FillRect_9:
   \   000000F4   0000D8E5           LDRB     R0,[R8, #+0]
    565                      pData++;
    566                    } while (--NumBytes);
   \   000000F8   01B05BE2           SUBS     R11,R11,#+1
   \   000000FC   FF0020E2           EOR      R0,R0,#0xFF
   \   00000100   0100C8E4           STRB     R0,[R8], #+1
   \   00000104   FAFFFF1A           BNE      ??_FillRect_9
    567                  }
    568                  Bit = 7;
   \                     ??_FillRect_8:
   \   00000108   0720A0E3           MOV      R2,#+7
   \   0000010C   000059E3           CMP      R9,#+0
   \   00000110   4600000A           BEQ      ??_FillRect_7
   \   00000114   0100A0E3           MOV      R0,#+1
   \   00000118   010019E3           TST      R9,#0x1
   \   0000011C   0300000A           BEQ      ??_FillRect_10
    569                  while (RemPixels--) {
    570                    *pData ^= 1 << (Bit--);
   \   00000120   0010D8E5           LDRB     R1,[R8, #+0]
   \   00000124   0620A0E3           MOV      R2,#+6
   \   00000128   801021E2           EOR      R1,R1,#0x80
   \   0000012C   0010C8E5           STRB     R1,[R8, #+0]
   \                     ??_FillRect_10:
   \   00000130   A910B0E1           LSRS     R1,R9,#+1
   \   00000134   3D00000A           BEQ      ??_FillRect_7
   \                     ??_FillRect_11:
   \   00000138   0030D8E5           LDRB     R3,[R8, #+0]
   \   0000013C   011051E2           SUBS     R1,R1,#+1
   \   00000140   103223E0           EOR      R3,R3,R0, LSL R2
   \   00000144   012042E2           SUB      R2,R2,#+1
   \   00000148   103223E0           EOR      R3,R3,R0, LSL R2
   \   0000014C   0030C8E5           STRB     R3,[R8, #+0]
   \   00000150   012042E2           SUB      R2,R2,#+1
   \   00000154   F7FFFF1A           BNE      ??_FillRect_11
   \   00000158   340000EA           B        ??_FillRect_7
    571                  }
    572                }
    573              } else {  // Fill
    574                ColorIndex = LCD__GetColorIndex();
    575                Color    = (ColorIndex & 1);
   \                     ??_FillRect_3:
   \   0000015C   ........           LDR      R0,??DataTable11
    576                FillByte = (-Color) & 0xFF;
    577                if (Bit < 7) {
   \   00000160   070052E3           CMP      R2,#+7
   \   00000164   000090E5           LDR      R0,[R0, #+0]
   \   00000168   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000016C   01A000E2           AND      R10,R0,#0x1
   \   00000170   00006AE2           RSB      R0,R10,#+0
   \   00000174   FF1000E2           AND      R1,R0,#0xFF
   \   00000178   0B0000AA           BGE      ??_FillRect_12
   \                     ??_FillRect_13:
   \   0000017C   0900A0E1           MOV      R0,R9
   \   00000180   019040E2           SUB      R9,R0,#+1
   \   00000184   000050E3           CMP      R0,#+0
   \   00000188   0600000A           BEQ      ??_FillRect_14
    578                  while ((Bit >= 0) && RemPixels--) {
    579                    *pData &= ~(1 << Bit);
    580                    *pData |= Color << (Bit--);
   \   0000018C   0000D8E5           LDRB     R0,[R8, #+0]
   \   00000190   0130A0E3           MOV      R3,#+1
   \   00000194   1302C0E1           BIC      R0,R0,R3, LSL R2
   \   00000198   1A0280E1           ORR      R0,R0,R10, LSL R2
   \   0000019C   0000C8E5           STRB     R0,[R8, #+0]
   \   000001A0   012052E2           SUBS     R2,R2,#+1
    581                  }
   \   000001A4   F4FFFF5A           BPL      ??_FillRect_13
    582                  pData++;
   \                     ??_FillRect_14:
   \   000001A8   018088E2           ADD      R8,R8,#+1
    583                }
    584                if (RemPixels > 0) {
   \                     ??_FillRect_12:
   \   000001AC   010059E3           CMP      R9,#+1
   \   000001B0   1E0000BA           BLT      ??_FillRect_7
    585                  NumBytes = RemPixels >> 3;
   \   000001B4   C9B1A0E1           ASR      R11,R9,#+3
    586                  if (NumBytes > 0) {
   \   000001B8   01005BE3           CMP      R11,#+1
   \   000001BC   040000BA           BLT      ??_FillRect_15
    587                    GUI_MEMSET(pData, FillByte, NumBytes);
   \   000001C0   0B20A0E1           MOV      R2,R11
   \   000001C4   0800A0E1           MOV      R0,R8
   \   000001C8   ........           BL       GUI__memset
    588                    pData += NumBytes;
   \   000001CC   08808BE0           ADD      R8,R11,R8
    589                    RemPixels -= NumBytes << 3;
   \   000001D0   8B9149E0           SUB      R9,R9,R11, LSL #+3
    590                  }
    591                  Bit = 7;
   \                     ??_FillRect_15:
   \   000001D4   0720A0E3           MOV      R2,#+7
   \   000001D8   000059E3           CMP      R9,#+0
   \   000001DC   1300000A           BEQ      ??_FillRect_7
   \   000001E0   0100A0E3           MOV      R0,#+1
   \   000001E4   010019E3           TST      R9,#0x1
   \   000001E8   0400000A           BEQ      ??_FillRect_16
    592                  while (RemPixels--) {
    593                    *pData &= ~(1 << Bit);
    594                    *pData |= Color << (Bit--);
   \   000001EC   0010D8E5           LDRB     R1,[R8, #+0]
   \   000001F0   0620A0E3           MOV      R2,#+6
   \   000001F4   7F1001E2           AND      R1,R1,#0x7F
   \   000001F8   8A1381E1           ORR      R1,R1,R10, LSL #+7
   \   000001FC   0010C8E5           STRB     R1,[R8, #+0]
   \                     ??_FillRect_16:
   \   00000200   A910B0E1           LSRS     R1,R9,#+1
   \   00000204   0900000A           BEQ      ??_FillRect_7
   \                     ??_FillRect_17:
   \   00000208   0030D8E5           LDRB     R3,[R8, #+0]
   \   0000020C   011051E2           SUBS     R1,R1,#+1
   \   00000210   1032C3E1           BIC      R3,R3,R0, LSL R2
   \   00000214   1A3283E1           ORR      R3,R3,R10, LSL R2
   \   00000218   012042E2           SUB      R2,R2,#+1
   \   0000021C   1032C3E1           BIC      R3,R3,R0, LSL R2
   \   00000220   1A3283E1           ORR      R3,R3,R10, LSL R2
   \   00000224   0030C8E5           STRB     R3,[R8, #+0]
   \   00000228   012042E2           SUB      R2,R2,#+1
   \   0000022C   F5FFFF1A           BNE      ??_FillRect_17
    595                  }
    596                }
    597              }
    598            }
   \                     ??_FillRect_7:
   \   00000230   014084E2           ADD      R4,R4,#+1
   \   00000234   040055E1           CMP      R5,R4
   \   00000238   88FFFFAA           BGE      ??_FillRect_2
    599          }
   \                     ??_FillRect_1:
   \   0000023C   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000240   F08FBDE8           POP      {R4-R11,PC}      ;; return
    600          
    601          /*********************************************************************
    602          *
    603          *       _DrawHLine
    604          */

   \                                 In section .text, align 4, keep-with-next
    605          static void _DrawHLine(GUI_DEVICE * pDevice, int x0, int y, int x1) {
   \                     _DrawHLine:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
    606            _FillRect(pDevice, x0, y, x1, y);
   \   00000008   00208DE5           STR      R2,[SP, #+0]
   \   0000000C   ........           BL       _FillRect
    607          }
   \   00000010   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000014   0080BDE8           POP      {PC}             ;; return
    608          
    609          /*********************************************************************
    610          *
    611          *       _DrawVLine
    612          */

   \                                 In section .text, align 4, keep-with-next
    613          static void _DrawVLine(GUI_DEVICE * pDevice, int x , int y0, int y1) {
   \                     _DrawVLine:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    614            GUI_MEMDEV * pDev;
    615            GUI_USAGE_h  hUsage; 
    616            GUI_USAGE  * pUsage;
    617            U8         * pData;
    618            int Bit, Mask, Pixel;
    619            LCD_PIXELINDEX ColorIndex;
    620          
    621            GUI_USE_PARA(pDevice);
    622            pDev   = GUI_MEMDEV_H2P(GUI_Context.hDevData);
   \   00000004   ........           LDR      R7,??DataTable9
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   0360A0E1           MOV      R6,R3
   \   00000018   880097E5           LDR      R0,[R7, #+136]
   \   0000001C   ........           BL       GUI_ALLOC_h2p
   \   00000020   0080A0E1           MOV      R8,R0
    623            hUsage = pDev->hUsage; 
   \   00000024   140098E5           LDR      R0,[R8, #+20]
    624            pUsage = hUsage ? GUI_USAGE_H2P(hUsage) : NULL;
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0200000A           BEQ      ??_DrawVLine_0
   \   00000030   ........           BL       GUI_ALLOC_h2p
   \   00000034   0090A0E1           MOV      R9,R0
   \   00000038   000000EA           B        ??_DrawVLine_1
   \                     ??_DrawVLine_0:
   \   0000003C   0090A0E3           MOV      R9,#+0
    625            pData  = _XY2PTR_BITOFFSET(x, y0, &Bit);
   \                     ??_DrawVLine_1:
   \   00000040   880097E5           LDR      R0,[R7, #+136]
   \   00000044   ........           BL       GUI_ALLOC_h2p
   \   00000048   F630D0E1           LDRSH    R3,[R0, #+6]
   \   0000004C   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000050   0CC090E5           LDR      R12,[R0, #+12]
   \   00000054   033045E0           SUB      R3,R5,R3
   \   00000058   9C0303E0           MUL      R3,R12,R3
   \   0000005C   012044E0           SUB      R2,R4,R1
   \   00000060   071002E2           AND      R1,R2,#0x7
   \   00000064   C22183E0           ADD      R2,R3,R2, ASR #+3
   \   00000068   000082E0           ADD      R0,R2,R0
   \   0000006C   18B080E2           ADD      R11,R0,#+24
   \   00000070   071061E2           RSB      R1,R1,#+7
    626            Mask   = (1 << Bit);
   \   00000074   0100A0E3           MOV      R0,#+1
   \   00000078   10A1A0E1           LSL      R10,R0,R1
    627            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   0000007C   1000D7E5           LDRB     R0,[R7, #+16]
   \   00000080   010010E3           TST      R0,#0x1
   \   00000084   1000000A           BEQ      ??_DrawVLine_2
    628              do {
    629                *pData ^= Mask;
   \                     ??_DrawVLine_3:
   \   00000088   0000DBE5           LDRB     R0,[R11, #+0]
    630                if (pUsage) {
   \   0000008C   000059E3           CMP      R9,#+0
   \   00000090   00002AE0           EOR      R0,R10,R0
   \   00000094   0000CBE5           STRB     R0,[R11, #+0]
   \   00000098   0500000A           BEQ      ??_DrawVLine_4
    631                  GUI_USAGE_AddPixel(pUsage, x, y0);
   \   0000009C   083099E5           LDR      R3,[R9, #+8]
   \   000000A0   0520A0E1           MOV      R2,R5
   \   000000A4   0410A0E1           MOV      R1,R4
   \   000000A8   0900A0E1           MOV      R0,R9
   \   000000AC   003093E5           LDR      R3,[R3, #+0]
   \   000000B0   33FF2FE1           BLX      R3
    632                }
    633                pData += pDev->BytesPerLine;
   \                     ??_DrawVLine_4:
   \   000000B4   0C0098E5           LDR      R0,[R8, #+12]
    634              } while (++y0 <= y1);
   \   000000B8   015085E2           ADD      R5,R5,#+1
   \   000000BC   0BB080E0           ADD      R11,R0,R11
   \   000000C0   050056E1           CMP      R6,R5
   \   000000C4   EFFFFFAA           BGE      ??_DrawVLine_3
   \   000000C8   160000EA           B        ??_DrawVLine_5
    635            } else {
    636              ColorIndex = LCD__GetColorIndex();
    637              Pixel = (ColorIndex & 1) << Bit;
   \                     ??_DrawVLine_2:
   \   000000CC   ........           LDR      R0,??DataTable11
   \   000000D0   0AA0E0E1           MVN      R10,R10
   \   000000D4   000090E5           LDR      R0,[R0, #+0]
   \   000000D8   0000D0E5           LDRB     R0,[R0, #+0]
   \   000000DC   010000E2           AND      R0,R0,#0x1
   \   000000E0   1071A0E1           LSL      R7,R0,R1
    638              do {
    639                *pData &= ~Mask;
    640                *pData |= Pixel;
   \                     ??_DrawVLine_6:
   \   000000E4   0000DBE5           LDRB     R0,[R11, #+0]
    641                if (pUsage) {
   \   000000E8   000059E3           CMP      R9,#+0
   \   000000EC   00000AE0           AND      R0,R10,R0
   \   000000F0   000087E1           ORR      R0,R7,R0
   \   000000F4   0000CBE5           STRB     R0,[R11, #+0]
   \   000000F8   0500000A           BEQ      ??_DrawVLine_7
    642                  GUI_USAGE_AddPixel(pUsage, x, y0);
   \   000000FC   083099E5           LDR      R3,[R9, #+8]
   \   00000100   0520A0E1           MOV      R2,R5
   \   00000104   0410A0E1           MOV      R1,R4
   \   00000108   0900A0E1           MOV      R0,R9
   \   0000010C   003093E5           LDR      R3,[R3, #+0]
   \   00000110   33FF2FE1           BLX      R3
    643                }
    644                pData += pDev->BytesPerLine;
   \                     ??_DrawVLine_7:
   \   00000114   0C0098E5           LDR      R0,[R8, #+12]
    645              } while (++y0 <= y1);
   \   00000118   015085E2           ADD      R5,R5,#+1
   \   0000011C   0BB080E0           ADD      R11,R0,R11
   \   00000120   050056E1           CMP      R6,R5
   \   00000124   EEFFFFAA           BGE      ??_DrawVLine_6
    646            }
    647          }
   \                     ??_DrawVLine_5:
   \   00000128   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000012C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    648          
    649          /*********************************************************************
    650          *
    651          *       _SetPixelIndex
    652          */

   \                                 In section .text, align 4, keep-with-next
    653          static void _SetPixelIndex(GUI_DEVICE * pDevice, int x, int y, int Index) {
   \                     _SetPixelIndex:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    654            GUI_MEMDEV * pDev;
    655            U8 * pData;
    656            int Bit;
    657          
    658            GUI_USE_PARA(pDevice);
    659            pDev    = GUI_MEMDEV_H2P(GUI_Context.hDevData);
   \   00000004   ........           LDR      R8,??DataTable11_1
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   0360A0E1           MOV      R6,R3
   \   00000014   880098E5           LDR      R0,[R8, #+136]
   \   00000018   ........           BL       GUI_ALLOC_h2p
   \   0000001C   0070A0E1           MOV      R7,R0
    660            pData   = _XY2PTR_BITOFFSET(x, y, &Bit);
   \   00000020   880098E5           LDR      R0,[R8, #+136]
   \   00000024   ........           BL       GUI_ALLOC_h2p
   \   00000028   F630D0E1           LDRSH    R3,[R0, #+6]
   \   0000002C   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000030   0CC090E5           LDR      R12,[R0, #+12]
   \   00000034   033045E0           SUB      R3,R5,R3
   \   00000038   9C0303E0           MUL      R3,R12,R3
   \   0000003C   012044E0           SUB      R2,R4,R1
   \   00000040   071002E2           AND      R1,R2,#0x7
   \   00000044   C22183E0           ADD      R2,R3,R2, ASR #+3
   \   00000048   000082E0           ADD      R0,R2,R0
    661            *pData &= ~(1 << Bit);
    662            *pData |= (Index & 1) << Bit;
   \   0000004C   1820F0E5           LDRB     R2,[R0, #+24]!
   \   00000050   071061E2           RSB      R1,R1,#+7
   \   00000054   0130A0E3           MOV      R3,#+1
   \   00000058   1321C2E1           BIC      R2,R2,R3, LSL R1
   \   0000005C   013006E2           AND      R3,R6,#0x1
   \   00000060   131182E1           ORR      R1,R2,R3, LSL R1
   \   00000064   0010C0E5           STRB     R1,[R0, #+0]
    663            if (pDev->hUsage) {
   \   00000068   140097E5           LDR      R0,[R7, #+20]
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   0A00000A           BEQ      ??_SetPixelIndex_0
    664              GUI_USAGE_AddPixel(GUI_USAGE_H2P(pDev->hUsage), x, y);
   \   00000074   ........           BL       GUI_ALLOC_h2p
   \   00000078   0060A0E1           MOV      R6,R0
   \   0000007C   140097E5           LDR      R0,[R7, #+20]
   \   00000080   ........           BL       GUI_ALLOC_h2p
   \   00000084   0030A0E1           MOV      R3,R0
   \   00000088   083093E5           LDR      R3,[R3, #+8]
   \   0000008C   0520A0E1           MOV      R2,R5
   \   00000090   0410A0E1           MOV      R1,R4
   \   00000094   0600A0E1           MOV      R0,R6
   \   00000098   003093E5           LDR      R3,[R3, #+0]
   \   0000009C   33FF2FE1           BLX      R3
    665            }
    666          }
   \                     ??_SetPixelIndex_0:
   \   000000A0   F081BDE8           POP      {R4-R8,PC}       ;; return
    667          
    668          /*********************************************************************
    669          *
    670          *       _XorPixel
    671          */

   \                                 In section .text, align 4, keep-with-next
    672          static void _XorPixel(GUI_DEVICE * pDevice, int x, int y) {
   \                     _XorPixel:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
    673            GUI_MEMDEV * pDev;
    674            U8 * pData;
    675            int Bit;
    676          
    677            GUI_USE_PARA(pDevice);
    678            pDev    = GUI_MEMDEV_H2P(GUI_Context.hDevData);
   \   00000004   ........           LDR      R7,??DataTable11_1
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   880097E5           LDR      R0,[R7, #+136]
   \   00000018   ........           BL       GUI_ALLOC_h2p
   \   0000001C   0060A0E1           MOV      R6,R0
    679            pData   = _XY2PTR_BITOFFSET(x, y, &Bit);
   \   00000020   880097E5           LDR      R0,[R7, #+136]
   \   00000024   ........           BL       GUI_ALLOC_h2p
   \   00000028   F620D0E1           LDRSH    R2,[R0, #+6]
   \   0000002C   0C3090E5           LDR      R3,[R0, #+12]
   \   00000030   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000034   022045E0           SUB      R2,R5,R2
   \   00000038   930202E0           MUL      R2,R3,R2
   \   0000003C   011044E0           SUB      R1,R4,R1
   \   00000040   C12182E0           ADD      R2,R2,R1, ASR #+3
   \   00000044   000082E0           ADD      R0,R2,R0
    680            *pData ^= (1 << Bit);
   \   00000048   1820F0E5           LDRB     R2,[R0, #+24]!
   \   0000004C   071001E2           AND      R1,R1,#0x7
   \   00000050   0130A0E3           MOV      R3,#+1
   \   00000054   071061E2           RSB      R1,R1,#+7
   \   00000058   131122E0           EOR      R1,R2,R3, LSL R1
   \   0000005C   0010C0E5           STRB     R1,[R0, #+0]
    681            if (pDev->hUsage) {
   \   00000060   140096E5           LDR      R0,[R6, #+20]
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   0A00000A           BEQ      ??_XorPixel_0
    682              GUI_USAGE_AddPixel(GUI_USAGE_H2P(pDev->hUsage), x, y);
   \   0000006C   ........           BL       GUI_ALLOC_h2p
   \   00000070   0070A0E1           MOV      R7,R0
   \   00000074   140096E5           LDR      R0,[R6, #+20]
   \   00000078   ........           BL       GUI_ALLOC_h2p
   \   0000007C   0030A0E1           MOV      R3,R0
   \   00000080   083093E5           LDR      R3,[R3, #+8]
   \   00000084   0520A0E1           MOV      R2,R5
   \   00000088   0410A0E1           MOV      R1,R4
   \   0000008C   0700A0E1           MOV      R0,R7
   \   00000090   003093E5           LDR      R3,[R3, #+0]
   \   00000094   33FF2FE1           BLX      R3
    683            }
    684          }
   \                     ??_XorPixel_0:
   \   00000098   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000009C   F080BDE8           POP      {R4-R7,PC}       ;; return
    685          
    686          /*********************************************************************
    687          *
    688          *       _GetPixelIndex
    689          */

   \                                 In section .text, align 4, keep-with-next
    690          static unsigned int _GetPixelIndex(GUI_DEVICE * pDevice, int x, int y) {
   \                     _GetPixelIndex:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    691            U8 * pData;
    692            int Bit;
    693          
    694            GUI_USE_PARA(pDevice);
    695            pData = _XY2PTR_BITOFFSET(x, y, &Bit);
   \   00000004   ........           LDR      R0,??DataTable11_1
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   880090E5           LDR      R0,[R0, #+136]
   \   00000018   ........           BL       GUI_ALLOC_h2p
    696            return (*pData >> Bit) & 1;
   \   0000001C   F620D0E1           LDRSH    R2,[R0, #+6]
   \   00000020   0C3090E5           LDR      R3,[R0, #+12]
   \   00000024   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000028   022045E0           SUB      R2,R5,R2
   \   0000002C   930202E0           MUL      R2,R3,R2
   \   00000030   011044E0           SUB      R1,R4,R1
   \   00000034   C12182E0           ADD      R2,R2,R1, ASR #+3
   \   00000038   000082E0           ADD      R0,R2,R0
   \   0000003C   1800D0E5           LDRB     R0,[R0, #+24]
   \   00000040   071001E2           AND      R1,R1,#0x7
   \   00000044   071061E2           RSB      R1,R1,#+7
   \   00000048   0120A0E3           MOV      R2,#+1
   \   0000004C   500102E0           AND      R0,R2,R0, ASR R1
   \   00000050   04D08DE2           ADD      SP,SP,#+4
   \   00000054   3080BDE8           POP      {R4,R5,PC}       ;; return
    697          }
    698          
    699          /*********************************************************************
    700          *
    701          *       _GetRect
    702          */

   \                                 In section .text, align 4, keep-with-next
    703          static void _GetRect(GUI_DEVICE * pDevice, LCD_RECT * pRect) {
   \                     _GetRect:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0140A0E1           MOV      R4,R1
    704            GUI_MEMDEV * pDev;
    705            
    706            pDev = GUI_MEMDEV_H2P(pDevice->u.hContext);
   \   00000008   080090E5           LDR      R0,[R0, #+8]
   \   0000000C   ........           BL       GUI_ALLOC_h2p
    707            pRect->x0 = pDev->x0;
   \   00000010   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000014   B010C4E1           STRH     R1,[R4, #+0]
    708            pRect->y0 = pDev->y0;
   \   00000018   F610D0E1           LDRSH    R1,[R0, #+6]
   \   0000001C   B210C4E1           STRH     R1,[R4, #+2]
    709            pRect->x1 = pDev->x0 + pDev->XSize-1;
   \   00000020   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000024   F820D0E1           LDRSH    R2,[R0, #+8]
   \   00000028   011082E0           ADD      R1,R2,R1
   \   0000002C   011041E2           SUB      R1,R1,#+1
   \   00000030   B410C4E1           STRH     R1,[R4, #+4]
    710            pRect->y1 = pDev->y0 + pDev->YSize-1;
   \   00000034   F610D0E1           LDRSH    R1,[R0, #+6]
   \   00000038   FA00D0E1           LDRSH    R0,[R0, #+10]
   \   0000003C   010080E0           ADD      R0,R0,R1
   \   00000040   010040E2           SUB      R0,R0,#+1
   \   00000044   B600C4E1           STRH     R0,[R4, #+6]
    711          }
   \   00000048   1080BDE8           POP      {R4,PC}          ;; return
    712          
    713          /*********************************************************************
    714          *
    715          *       _GetDevData
    716          */

   \                                 In section .text, align 4, keep-with-next
    717          static void * _GetDevData(GUI_DEVICE * pDevice, int Index) {
    718            GUI_USE_PARA(pDevice);
    719            switch (Index) {
   \                     _GetDevData:
   \   00000000   010051E3           CMP      R1,#+1
   \   00000004   0100001A           BNE      ??_GetDevData_0
    720            case LCD_DEVDATA_MEMDEV:
    721              return (void *)&DEVICE_API;
   \   00000008   ........           ADR      R0,GUI_MEMDEV_DEVICE_1
   \   0000000C   1EFF2FE1           BX       LR
    722            }
    723            return NULL;
   \                     ??_GetDevData_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
    724          }
    725          
    726          /*********************************************************************
    727          *
    728          *       _GetDevFunc
    729          */

   \                                 In section .text, align 4, keep-with-next
    730          static void (* _GetDevFunc(GUI_DEVICE ** ppDevice, int Index))(void) {
    731            GUI_USE_PARA(ppDevice);
    732            switch (Index) {
   \                     _GetDevFunc:
   \   00000000   160051E3           CMP      R1,#+22
   \   00000004   0100001A           BNE      ??_GetDevFunc_0
    733            case MEMDEV_DEVFUNC_WRITETOACTIVE:
    734              return (void (*)(void))GUI_MEMDEV__WriteToActiveOpaque;
   \   00000008   ........           LDR      R0,??DataTable11_2
   \   0000000C   1EFF2FE1           BX       LR
    735            }
    736            return NULL;
   \                     ??_GetDevFunc_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
    737          }
    738          
    739          /*********************************************************************
    740          *
    741          *       GUI_DEVICE_API functions: From here there is nothing to do except routing...
    742          */

   \                                 In section .text, align 4, keep-with-next
    743          static void _SetOrg(GUI_DEVICE * pDevice, int x, int y) {
    744            pDevice = pDevice->pNext;
   \                     _SetOrg:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    745            pDevice->pDeviceAPI->pfSetOrg(pDevice, x, y);
   \   00000004   0C3090E5           LDR      R3,[R0, #+12]
   \   00000008   203093E5           LDR      R3,[R3, #+32]
   \   0000000C   13FF2FE1           BX       R3               ;; tailcall
    746          }

   \                                 In section .text, align 4, keep-with-next
    747          static I32 _GetDevProp(GUI_DEVICE * pDevice, int Index) {
    748            pDevice = pDevice->pNext;
   \                     _GetDevProp:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    749            return pDevice->pDeviceAPI->pfGetDevProp(pDevice, Index);
   \   00000004   0C2090E5           LDR      R2,[R0, #+12]
   \   00000008   282092E5           LDR      R2,[R2, #+40]
   \   0000000C   12FF2FE1           BX       R2               ;; tailcall
    750          }
    751          
    752          /*********************************************************************
    753          *
    754          *       GUI_DEVICE_API structure
    755          */

   \                                 In section .text, align 4, keep-with-next
    756          const GUI_DEVICE_API DEVICE_API = {
   \                     GUI_MEMDEV_DEVICE_1:
   \   00000000                      ; Initializer data, 52 bytes
   \   00000000   04000000....       DC32 4, _DrawBitmap, _DrawHLine, _DrawVLine, _FillRect, _GetPixelIndex, _SetPixelIndex, _XorPixel, _SetOrg, _GetDevFunc
   \              ............
   \              ............
   \              ............
   \              ............
   \              ............
   \              ........    
   \   00000028   ............       DC32 _GetDevProp, _GetDevData, _GetRect
   \              ............

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   ........           DC32     GUI_MEMDEV__WriteToActiveOpaque
    757            //
    758            // Data
    759            //
    760            DEVICE_CLASS_MEMDEV,
    761            //
    762            // Drawing functions
    763            //
    764            _DrawBitmap   ,
    765            _DrawHLine    ,
    766            _DrawVLine    ,
    767            _FillRect     ,
    768            _GetPixelIndex,
    769            _SetPixelIndex,
    770            _XorPixel     ,
    771            //
    772            // Set origin
    773            //
    774            _SetOrg       ,
    775            //
    776            // Initialization
    777            //
    778            //
    779            // Request information
    780            //
    781            _GetDevFunc   ,
    782            _GetDevProp   ,
    783            _GetDevData,
    784            _GetRect      ,
    785          };
    786          
    787          
    788          
    789          #else
    790          
    791          void GUIDEV1_C(void);
    792          void GUIDEV1_C(void) {}
    793          
    794          #endif /* GUI_SUPPORT_MEMDEV */
    795          
    796          /*************************** end of file ****************************/

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     _DrawBitLine1BPP     48
     _DrawBitLine2BPP     40
     _DrawBitLine4BPP     40
     _DrawBitmap          72
     _DrawHLine            8
     _DrawVLine           40
     _FillRect            48
     _GetDevData           0
     _GetDevFunc           0
     _GetDevProp           8
     _GetPixelIndex       16
     _GetRect              8
     _SetOrg               8
     _SetPixelIndex       24
     _XorPixel            24


   Section sizes:

     Function/Label      Bytes
     --------------      -----
     aID                   64
     _DrawBitLine1BPP    1016
     _DrawBitLine2BPP     324
     _DrawBitLine4BPP     516
     _DrawBitmap          828
     _FillRect            580
     _DrawHLine            24
     _DrawVLine           304
     _SetPixelIndex       164
     _XorPixel            160
     _GetPixelIndex        88
     _GetRect              76
     _GetDevData           24
     _GetDevFunc           24
     _SetOrg               16
     _GetDevProp           16
     GUI_MEMDEV_DEVICE_1   52
     ??DataTable9           4
     ??DataTable11          4
     ??DataTable11_1        4
     ??DataTable11_2        4

 
 4 292 bytes in section .text
 
 4 292 bytes of CODE memory

Errors: none
Warnings: none
