###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     14/Jul/2015  18:59:18 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\WM_Touch.c                          #
#    Command line =  C:\DUII\TargetHW\GUI\WM_Touch.c -D DEBUG=1 -D            #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D                   #
#                    XIGNORE_TEMPERATURE -D BUILD_DEBUG_PORT -D PROFILER      #
#                    -lCN C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Li #
#                    st\ -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\ #
#                    Obj\ --debug --endian=little --cpu=ARM926EJ-S -e         #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\WM #
#                    _Touch.lst                                               #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\WM_ #
#                    Touch.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\WM_Touch.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : WMTouch.c
     19          Purpose     : Windows manager, touch support
     20          ----------------------------------------------------------------------
     21          */
     22          
     23          #include <stddef.h>           /* needed for definition of NULL */
     24          #include "WM_Intern.h"
     25          #include "GUI_Debug.h"
     26          
     27          #if (GUI_WINSUPPORT)
     28          
     29          /*********************************************************************
     30          *
     31          *       Static data
     32          *
     33          **********************************************************************
     34          */

   \                                 In section .bss, align 4
     35          static GUI_PID_STATE _aStateLast[GUI_NUM_LAYERS];
   \                     _aStateLast:
   \   00000000                      DS8 192
     36          
     37          /*********************************************************************
     38          *
     39          *       Public data
     40          *
     41          **********************************************************************
     42          */
     43          
     44          WM_CRITICAL_HANDLE  WM__aCHWinModal[GUI_NUM_LAYERS];
   \                     WM__aCHWinModal:
   \   000000C0                      DS8 128
     45          WM_CRITICAL_HANDLE  WM__aCHWinLast[GUI_NUM_LAYERS];
   \                     WM__aCHWinLast:
   \   00000140                      DS8 128
     46          #if GUI_SUPPORT_MOUSE
     47            WM_CRITICAL_HANDLE  WM__aCHWinMouseOver[GUI_NUM_LAYERS];
   \                     WM__aCHWinMouseOver:
   \   000001C0                      DS8 128
     48          #endif
     49          
     50          /*********************************************************************
     51          *
     52          *       Static code
     53          *
     54          **********************************************************************
     55          */
     56          /*********************************************************************
     57          *
     58          *       _Screen2Win
     59          */
     60          static WM_HWIN _Screen2Win(GUI_PID_STATE* pState) {
     61            if (WM__ahCapture[WM__TOUCHED_LAYER] == 0) {
     62              return WM_Screen2hWin(pState->x, pState->y);
     63            } 
     64            return WM__ahCapture[WM__TOUCHED_LAYER];
     65          }
     66          
     67          /*********************************************************************
     68          *
     69          *       Private code
     70          *
     71          **********************************************************************
     72          */
     73          /*********************************************************************
     74          *
     75          *       WM__IsInModalArea
     76          */

   \                                 In section .text, align 4, keep-with-next
     77          int WM__IsInModalArea(WM_HWIN hWin) {
   \                     WM__IsInModalArea:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
     78            if ((WM__aCHWinModal[WM__TOUCHED_LAYER].hWin == 0) || WM__IsAncestor(hWin, WM__aCHWinModal[WM__TOUCHED_LAYER].hWin) || (hWin == WM__aCHWinModal[WM__TOUCHED_LAYER].hWin)) {
   \   00000004   ........           LDR      R5,??DataTable3
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   ........           LDR      R6,??DataTable3_1
   \   00000010   000095E5           LDR      R0,[R5, #+0]
   \   00000014   800186E0           ADD      R0,R6,R0, LSL #+3
   \   00000018   C41090E5           LDR      R1,[R0, #+196]
   \   0000001C   000051E3           CMP      R1,#+0
   \   00000020   0900000A           BEQ      ??WM__IsInModalArea_0
   \   00000024   C41090E5           LDR      R1,[R0, #+196]
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       WM__IsAncestor
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0400001A           BNE      ??WM__IsInModalArea_0
   \   00000038   000095E5           LDR      R0,[R5, #+0]
   \   0000003C   800186E0           ADD      R0,R6,R0, LSL #+3
   \   00000040   C40090E5           LDR      R0,[R0, #+196]
   \   00000044   000054E1           CMP      R4,R0
   \   00000048   0100001A           BNE      ??WM__IsInModalArea_1
     79              return 1;
   \                     ??WM__IsInModalArea_0:
   \   0000004C   0100A0E3           MOV      R0,#+1
   \   00000050   7080BDE8           POP      {R4-R6,PC}
     80            }
     81            return 0;
   \                     ??WM__IsInModalArea_1:
   \   00000054   0000A0E3           MOV      R0,#+0
   \   00000058   7080BDE8           POP      {R4-R6,PC}       ;; return
     82          }
     83          
     84          /*********************************************************************
     85          *
     86          *       WM__SendPIDMessage
     87          *
     88          * Purpose:
     89          *   Sends a PID -type message to the affected window.
     90          *   All ancestors are notified of this by sending a WM_TOUCH_CHILD
     91          *   message.
     92          *
     93          */

   \                                 In section .text, align 4, keep-with-next
     94          void WM__SendPIDMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
   \                     WM__SendPIDMessage:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
     95            #if 1
     96            WM_HWIN iWin;
     97            WM_MESSAGE Msg;
     98            Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
   \   00000008   0E10B5E8           LDM      R5!,{R1-R3,R12}
   \   0000000C   10D04DE2           SUB      SP,SP,#+16
   \   00000010   0040A0E1           MOV      R4,R0
   \   00000014   0D00A0E1           MOV      R0,SP
   \   00000018   0E10A0E8           STM      R0!,{R1-R3,R12}
     99            /* Send notification to all ancestors.
    100               We need to check if the window which has received the last message still exists,
    101               since it may have deleted itself and its parent as result of the message.
    102            */
    103            Msg.hWinSrc = hWin;
    104            Msg.MsgId   = WM_TOUCH_CHILD;
   \   0000001C   0D10A0E3           MOV      R1,#+13
   \   00000020   105045E2           SUB      R5,R5,#+16
   \   00000024   08408DE5           STR      R4,[SP, #+8]
   \   00000028   00108DE5           STR      R1,[SP, #+0]
    105            iWin = hWin;
   \   0000002C   0460A0E1           MOV      R6,R4
   \   00000030   060000EA           B        ??WM__SendPIDMessage_0
    106            while (WM_IsWindow(iWin)) {
    107              iWin = WM_GetParent(iWin);
   \                     ??WM__SendPIDMessage_1:
   \   00000034   0600A0E1           MOV      R0,R6
   \   00000038   ........           BL       WM_GetParent
   \   0000003C   0060B0E1           MOVS     R6,R0
    108              if (iWin) {
   \   00000040   0200000A           BEQ      ??WM__SendPIDMessage_0
    109                Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
   \   00000044   0C508DE5           STR      R5,[SP, #+12]
    110                WM__SendMessageIfEnabled(iWin, &Msg);    /* Send message to the ancestors */
   \   00000048   0D10A0E1           MOV      R1,SP
   \   0000004C   ........           BL       WM__SendMessageIfEnabled
    111              }
    112            }
   \                     ??WM__SendPIDMessage_0:
   \   00000050   0600A0E1           MOV      R0,R6
   \   00000054   ........           BL       WM_IsWindow
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   F4FFFF1A           BNE      ??WM__SendPIDMessage_1
    113            /* Send message to the affected window */
    114            WM__SendMessageIfEnabled(hWin, pMsg);
   \   00000060   0510A0E1           MOV      R1,R5
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           BL       WM__SendMessageIfEnabled
    115            #else
    116            WM_MESSAGE Msg;
    117            /* Send message to the affected window */
    118            Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
    119            WM__SendMessageIfEnabled(hWin, &Msg);
    120            /* Send notification to all ancestors.
    121               We need to check if the window which has received the last message still exists,
    122               since it may have deleted itself and its parent as result of the message.
    123            */
    124            Msg.hWinSrc = hWin;
    125            Msg.MsgId   = WM_TOUCH_CHILD;
    126            while (WM_IsWindow(hWin)) {
    127              hWin = WM_GetParent(hWin);
    128              if (hWin) {
    129                Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
    130                WM__SendMessageIfEnabled(hWin, &Msg);    /* Send message to the ancestors */
    131              }
    132            }
    133            #endif
    134          }
   \   0000006C   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   00000070   7080BDE8           POP      {R4-R6,PC}       ;; return
    135          
    136          /*********************************************************************
    137          *
    138          *       WM__SendTouchMessage
    139          */

   \                                 In section .text, align 4, keep-with-next
    140          void WM__SendTouchMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
   \                     WM__SendTouchMessage:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    141            GUI_PID_STATE* pState;
    142            pState     = (GUI_PID_STATE*)pMsg->Data.p;
   \   00000008   0C6095E5           LDR      R6,[R5, #+12]
   \   0000000C   10D04DE2           SUB      SP,SP,#+16
   \   00000010   0040A0E1           MOV      R4,R0
    143            if (pState) {
   \   00000014   000056E3           CMP      R6,#+0
   \   00000018   0800000A           BEQ      ??WM__SendTouchMessage_0
    144              WM_Obj* pWin;
    145              pWin       = WM_H2P(hWin);
   \   0000001C   ........           BL       GUI_ALLOC_h2p
    146              pState->x -= pWin->Rect.x0;
   \   00000020   F020D0E1           LDRSH    R2,[R0, #+0]
   \   00000024   001096E5           LDR      R1,[R6, #+0]
   \   00000028   021041E0           SUB      R1,R1,R2
   \   0000002C   001086E5           STR      R1,[R6, #+0]
    147              pState->y -= pWin->Rect.y0;
   \   00000030   F200D0E1           LDRSH    R0,[R0, #+2]
   \   00000034   041096E5           LDR      R1,[R6, #+4]
   \   00000038   000041E0           SUB      R0,R1,R0
   \   0000003C   040086E5           STR      R0,[R6, #+4]
    148            }
    149            WM__SendPIDMessage(hWin, pMsg);
   \                     ??WM__SendTouchMessage_0:
   \   00000040   0E10B5E8           LDM      R5!,{R1-R3,R12}
   \   00000044   0D00A0E1           MOV      R0,SP
   \   00000048   0E10A0E8           STM      R0!,{R1-R3,R12}
   \   0000004C   0D10A0E3           MOV      R1,#+13
   \   00000050   105045E2           SUB      R5,R5,#+16
   \   00000054   08408DE5           STR      R4,[SP, #+8]
   \   00000058   00108DE5           STR      R1,[SP, #+0]
   \   0000005C   0460A0E1           MOV      R6,R4
   \   00000060   060000EA           B        ??WM__SendTouchMessage_1
   \                     ??WM__SendTouchMessage_2:
   \   00000064   0600A0E1           MOV      R0,R6
   \   00000068   ........           BL       WM_GetParent
   \   0000006C   0060B0E1           MOVS     R6,R0
   \   00000070   0200000A           BEQ      ??WM__SendTouchMessage_1
   \   00000074   0C508DE5           STR      R5,[SP, #+12]
   \   00000078   0D10A0E1           MOV      R1,SP
   \   0000007C   ........           BL       WM__SendMessageIfEnabled
   \                     ??WM__SendTouchMessage_1:
   \   00000080   0600A0E1           MOV      R0,R6
   \   00000084   ........           BL       WM_IsWindow
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   F4FFFF1A           BNE      ??WM__SendTouchMessage_2
   \   00000090   0510A0E1           MOV      R1,R5
   \   00000094   0400A0E1           MOV      R0,R4
   \   00000098   ........           BL       WM__SendMessageIfEnabled
    150          }
   \   0000009C   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   000000A0   7080BDE8           POP      {R4-R6,PC}       ;; return
    151          
    152          /*********************************************************************
    153          *
    154          *       WM__SetLastTouched
    155          */

   \                                 In section .text, align 4, keep-with-next
    156          void WM__SetLastTouched(WM_HWIN hWin) {
   \                     WM__SetLastTouched:
   \   00000000   ........           LDR      R1,??DataTable3
   \   00000004   ........           LDR      R2,??DataTable3_1
   \   00000008   001091E5           LDR      R1,[R1, #+0]
   \   0000000C   811182E0           ADD      R1,R2,R1, LSL #+3
   \   00000010   440181E5           STR      R0,[R1, #+324]
   \   00000014   C40181E5           STR      R0,[R1, #+452]
    157          #if GUI_SUPPORT_MOUSE
    158            WM__aCHWinMouseOver[WM__TOUCHED_LAYER].hWin = WM__aCHWinLast[WM__TOUCHED_LAYER].hWin = hWin;
    159          #else
    160            GUI_USE_PARA(hWin);
    161          #endif
    162          }
   \   00000018   1EFF2FE1           BX       LR               ;; return
    163          
    164          /*********************************************************************
    165          *
    166          *       Public code
    167          *
    168          **********************************************************************
    169          */
    170          /*********************************************************************
    171          *
    172          *       WM_HandlePID       
    173          *
    174          * Polls the touch screen. If something has changed,
    175          * sends a message to the concerned window.
    176          *
    177          * Return value:
    178          *   0 if nothing has been done
    179          *   1 if touch message has been sent
    180          */

   \                                 In section .text, align 4, keep-with-next
    181          int WM_HandlePID(void) {
   \                     WM_HandlePID:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   60D04DE2           SUB      SP,SP,#+96
    182            int r = 0;
    183            int xPosLayer, yPosLayer;
    184            WM_MESSAGE Msg;
    185            WM_CRITICAL_HANDLE CHWin;
    186            GUI_PID_STATE State = {0}, StateNew;
   \   00000008   14008DE2           ADD      R0,SP,#+20
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   0020A0E3           MOV      R2,#+0
   \   00000014   0030A0E3           MOV      R3,#+0
   \   00000018   0E00A0E8           STM      R0!,{R1-R3}
   \   0000001C   0040A0E3           MOV      R4,#+0
    187            WM_HWIN hWin;
    188            
    189            GUI_PID_GetState(&StateNew);
   \   00000020   0D00A0E1           MOV      R0,SP
   \   00000024   ........           BL       GUI_PID_GetState
    190            if ((StateNew.x == -1) && (StateNew.y == -1) && (_aStateLast[WM__TOUCHED_LAYER].Pressed == StateNew.Pressed)) {
   \   00000028   00009DE5           LDR      R0,[SP, #+0]
   \   0000002C   0450E0E1           MVN      R5,R4
   \   00000030   050050E1           CMP      R0,R5
   \   00000034   04009D05           LDREQ    R0,[SP, #+4]
   \   00000038   05005001           CMPEQ    R0,R5
   \   0000003C   0800001A           BNE      ??WM_HandlePID_0
   \   00000040   ........           LDR      R0,??DataTable3
   \   00000044   0C10A0E3           MOV      R1,#+12
   \   00000048   000090E5           LDR      R0,[R0, #+0]
   \   0000004C   ........           LDR      R2,??DataTable3_1
   \   00000050   912020E0           MLA      R0,R1,R0,R2
   \   00000054   0810DDE5           LDRB     R1,[SP, #+8]
   \   00000058   0800D0E5           LDRB     R0,[R0, #+8]
   \   0000005C   010050E1           CMP      R0,R1
   \   00000060   8501000A           BEQ      ??WM_HandlePID_1
    191              return r;
    192            }
    193            WM_LOCK();
   \                     ??WM_HandlePID_0:
   \   00000064   ........           BL       GUI_Lock
    194            /*
    195            if ((StateNew.x >= 0) && (StateNew.y >= 0)) {
    196              StateNew.x += GUI_OrgX;
    197              StateNew.y += GUI_OrgY;
    198            }
    199            */
    200            if ((StateNew.x >= 0) && (StateNew.y >= 0)) {
   \   00000068   00009DE5           LDR      R0,[SP, #+0]
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   0B00004A           BMI      ??WM_HandlePID_2
   \   00000074   04009DE5           LDR      R0,[SP, #+4]
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   1600004A           BMI      ??WM_HandlePID_3
    201              StateNew.x += GUI_OrgX;
   \   00000080   ........           LDR      R2,??DataTable3_2
   \   00000084   00109DE5           LDR      R1,[SP, #+0]
   \   00000088   F020D2E1           LDRSH    R2,[R2, #+0]
   \   0000008C   011082E0           ADD      R1,R2,R1
   \   00000090   00108DE5           STR      R1,[SP, #+0]
    202              StateNew.y += GUI_OrgY;
   \   00000094   ........           LDR      R1,??DataTable3_3
   \   00000098   F010D1E1           LDRSH    R1,[R1, #+0]
   \   0000009C   000081E0           ADD      R0,R1,R0
   \   000000A0   0C0000EA           B        ??WM_HandlePID_4
    203            } else if ((StateNew.x == -1) && (StateNew.y == -1)) {
   \                     ??WM_HandlePID_2:
   \   000000A4   050050E1           CMP      R0,R5
   \   000000A8   04009D05           LDREQ    R0,[SP, #+4]
   \   000000AC   05005001           CMPEQ    R0,R5
   \   000000B0   0900001A           BNE      ??WM_HandlePID_3
    204              StateNew.x = _aStateLast[WM__TOUCHED_LAYER].x;
   \   000000B4   ........           LDR      R5,??DataTable3
   \   000000B8   0C60A0E3           MOV      R6,#+12
   \   000000BC   000095E5           LDR      R0,[R5, #+0]
   \   000000C0   ........           LDR      R7,??DataTable3_1
   \   000000C4   960000E0           MUL      R0,R6,R0
   \   000000C8   071090E7           LDR      R1,[R0, +R7]
    205              StateNew.y = _aStateLast[WM__TOUCHED_LAYER].y;
   \   000000CC   070080E0           ADD      R0,R0,R7
   \   000000D0   00108DE5           STR      R1,[SP, #+0]
   \   000000D4   040090E5           LDR      R0,[R0, #+4]
   \                     ??WM_HandlePID_4:
   \   000000D8   04008DE5           STR      R0,[SP, #+4]
    206            }
    207            WM__AddCriticalHandle(&CHWin);
   \                     ??WM_HandlePID_3:
   \   000000DC   0C008DE2           ADD      R0,SP,#+12
   \   000000E0   ........           BL       WM__AddCriticalHandle
    208            #if (GUI_NUM_LAYERS > 1)
    209              if (StateNew.Layer < GUI_NUM_LAYERS) {
   \   000000E4   0900DDE5           LDRB     R0,[SP, #+9]
   \   000000E8   ........           LDR      R5,??DataTable3
    210                WM__TouchedLayer = StateNew.Layer;
    211              }
    212            #endif
    213            GUI_GetLayerPosEx(WM__TOUCHED_LAYER, &xPosLayer, &yPosLayer);
   \   000000EC   40208DE2           ADD      R2,SP,#+64
   \   000000F0   100050E3           CMP      R0,#+16
   \   000000F4   00008535           STRCC    R0,[R5, #+0]
   \   000000F8   44108DE2           ADD      R1,SP,#+68
   \   000000FC   000095E5           LDR      R0,[R5, #+0]
   \   00000100   ........           BL       GUI_GetLayerPosEx
    214            StateNew.x -= xPosLayer;
   \   00000104   00009DE5           LDR      R0,[SP, #+0]
   \   00000108   44109DE5           LDR      R1,[SP, #+68]
    215            StateNew.y -= yPosLayer;
   \   0000010C   0C60A0E3           MOV      R6,#+12
   \   00000110   010040E0           SUB      R0,R0,R1
   \   00000114   00008DE5           STR      R0,[SP, #+0]
   \   00000118   04009DE5           LDR      R0,[SP, #+4]
   \   0000011C   40109DE5           LDR      R1,[SP, #+64]
   \   00000120   ........           LDR      R7,??DataTable3_1
   \   00000124   011040E0           SUB      R1,R0,R1
   \   00000128   000095E5           LDR      R0,[R5, #+0]
   \   0000012C   04108DE5           STR      R1,[SP, #+4]
   \   00000130   960000E0           MUL      R0,R6,R0
   \   00000134   00309DE5           LDR      R3,[SP, #+0]
   \   00000138   072090E7           LDR      R2,[R0, +R7]
   \   0000013C   030052E1           CMP      R2,R3
   \   00000140   0700001A           BNE      ??WM_HandlePID_5
   \   00000144   070080E0           ADD      R0,R0,R7
   \   00000148   042090E5           LDR      R2,[R0, #+4]
   \   0000014C   010052E1           CMP      R2,R1
   \   00000150   0300001A           BNE      ??WM_HandlePID_5
   \   00000154   0800D0E5           LDRB     R0,[R0, #+8]
   \   00000158   0820DDE5           LDRB     R2,[SP, #+8]
   \   0000015C   020050E1           CMP      R0,R2
   \   00000160   4201000A           BEQ      ??WM_HandlePID_6
    216            if (((_aStateLast[WM__TOUCHED_LAYER].x != StateNew.x) || 
    217                 (_aStateLast[WM__TOUCHED_LAYER].y != StateNew.y) || 
    218                 (_aStateLast[WM__TOUCHED_LAYER].Pressed != StateNew.Pressed)
    219                )) {
    220              #if GUI_SUPPORT_CURSOR
    221                GUI_CURSOR_SetPositionEx(StateNew.x, StateNew.y, StateNew.Layer);
   \                     ??WM_HandlePID_5:
   \   00000164   0920DDE5           LDRB     R2,[SP, #+9]
   \   00000168   0300A0E1           MOV      R0,R3
   \   0000016C   ........           BL       GUI_CURSOR_SetPositionEx
   \   00000170   000095E5           LDR      R0,[R5, #+0]
   \   00000174   ........           LDR      R1,??DataTable3_4
   \   00000178   000191E7           LDR      R0,[R1, +R0, LSL #+2]
   \   0000017C   000050E3           CMP      R0,#+0
   \   00000180   0200001A           BNE      ??WM_HandlePID_7
    222                /*
    223                if ((StateNew.x >= 0) && (StateNew.y >= 0)) {
    224                  GUI_CURSOR_SetPositionEx(StateNew.x, StateNew.y, StateNew.Layer);
    225                }
    226                */
    227              #endif
    228              CHWin.hWin = _Screen2Win(&StateNew);
   \   00000184   04109DE5           LDR      R1,[SP, #+4]
   \   00000188   00009DE5           LDR      R0,[SP, #+0]
   \   0000018C   ........           BL       WM_Screen2hWin
   \                     ??WM_HandlePID_7:
   \   00000190   10008DE5           STR      R0,[SP, #+16]
   \   00000194   000095E5           LDR      R0,[R5, #+0]
   \   00000198   800187E0           ADD      R0,R7,R0, LSL #+3
   \   0000019C   C41190E5           LDR      R1,[R0, #+452]
    229              #if GUI_SUPPORT_MOUSE
    230              /* Send WM_MOUSEOVER_END Message */
    231              hWin = WM__aCHWinMouseOver[WM__TOUCHED_LAYER].hWin; // Suppress warning: 'undefined behavior: the order of volatile accesses is undefined'
    232              if (hWin && (hWin != CHWin.hWin)) {
   \   000001A0   000051E3           CMP      R1,#+0
   \   000001A4   10209D15           LDRNE    R2,[SP, #+16]
   \   000001A8   02005111           CMPNE    R1,R2
   \   000001AC   4300000A           BEQ      ??WM_HandlePID_8
    233                if (WM__IsInModalArea(WM__aCHWinMouseOver[WM__TOUCHED_LAYER].hWin)) {
   \   000001B0   C48190E5           LDR      R8,[R0, #+452]
   \   000001B4   C41090E5           LDR      R1,[R0, #+196]
   \   000001B8   000051E3           CMP      R1,#+0
   \   000001BC   0900000A           BEQ      ??WM_HandlePID_9
   \   000001C0   C41090E5           LDR      R1,[R0, #+196]
   \   000001C4   0800A0E1           MOV      R0,R8
   \   000001C8   ........           BL       WM__IsAncestor
   \   000001CC   000050E3           CMP      R0,#+0
   \   000001D0   0400001A           BNE      ??WM_HandlePID_9
   \   000001D4   000095E5           LDR      R0,[R5, #+0]
   \   000001D8   800187E0           ADD      R0,R7,R0, LSL #+3
   \   000001DC   C40090E5           LDR      R0,[R0, #+196]
   \   000001E0   000058E1           CMP      R8,R0
   \   000001E4   3500001A           BNE      ??WM_HandlePID_8
    234                  /* Do not send messages to disabled windows */
    235                  if (WM__IsEnabled(WM__aCHWinMouseOver[WM__TOUCHED_LAYER].hWin)) {
   \                     ??WM_HandlePID_9:
   \   000001E8   000095E5           LDR      R0,[R5, #+0]
   \   000001EC   800187E0           ADD      R0,R7,R0, LSL #+3
   \   000001F0   C40190E5           LDR      R0,[R0, #+452]
   \   000001F4   ........           BL       WM__IsEnabled
   \   000001F8   000050E3           CMP      R0,#+0
   \   000001FC   2F00000A           BEQ      ??WM_HandlePID_8
    236                    State      = StateNew;
   \   00000200   0D10A0E1           MOV      R1,SP
   \   00000204   0C10B1E8           LDM      R1!,{R2,R3,R12}
   \   00000208   14008DE2           ADD      R0,SP,#+20
   \   0000020C   0C10A0E8           STM      R0!,{R2,R3,R12}
    237                    Msg.MsgId  = WM_MOUSEOVER_END;
   \   00000210   1210A0E3           MOV      R1,#+18
   \   00000214   30108DE5           STR      R1,[SP, #+48]
    238                    Msg.Data.p = (void*)&State;
    239                    WM__SendTouchMessage(WM__aCHWinMouseOver[WM__TOUCHED_LAYER].hWin, &Msg);
   \   00000218   000095E5           LDR      R0,[R5, #+0]
   \   0000021C   14108DE2           ADD      R1,SP,#+20
   \   00000220   3C108DE5           STR      R1,[SP, #+60]
   \   00000224   800187E0           ADD      R0,R7,R0, LSL #+3
   \   00000228   C48190E5           LDR      R8,[R0, #+452]
   \   0000022C   0800A0E1           MOV      R0,R8
   \   00000230   ........           BL       GUI_ALLOC_h2p
   \   00000234   F020D0E1           LDRSH    R2,[R0, #+0]
   \   00000238   14109DE5           LDR      R1,[SP, #+20]
   \   0000023C   0890A0E1           MOV      R9,R8
   \   00000240   021041E0           SUB      R1,R1,R2
   \   00000244   14108DE5           STR      R1,[SP, #+20]
   \   00000248   F200D0E1           LDRSH    R0,[R0, #+2]
   \   0000024C   18109DE5           LDR      R1,[SP, #+24]
   \   00000250   000041E0           SUB      R0,R1,R0
   \   00000254   18008DE5           STR      R0,[SP, #+24]
   \   00000258   30108DE2           ADD      R1,SP,#+48
   \   0000025C   0C50B1E8           LDM      R1!,{R2,R3,R12,LR}
   \   00000260   20008DE2           ADD      R0,SP,#+32
   \   00000264   0C50A0E8           STM      R0!,{R2,R3,R12,LR}
   \   00000268   0D10A0E3           MOV      R1,#+13
   \   0000026C   28808DE5           STR      R8,[SP, #+40]
   \   00000270   20108DE5           STR      R1,[SP, #+32]
   \   00000274   070000EA           B        ??WM_HandlePID_10
   \                     ??WM_HandlePID_11:
   \   00000278   0900A0E1           MOV      R0,R9
   \   0000027C   ........           BL       WM_GetParent
   \   00000280   0090B0E1           MOVS     R9,R0
   \   00000284   0300000A           BEQ      ??WM_HandlePID_10
   \   00000288   30108DE2           ADD      R1,SP,#+48
   \   0000028C   2C108DE5           STR      R1,[SP, #+44]
   \   00000290   20108DE2           ADD      R1,SP,#+32
   \   00000294   ........           BL       WM__SendMessageIfEnabled
   \                     ??WM_HandlePID_10:
   \   00000298   0900A0E1           MOV      R0,R9
   \   0000029C   ........           BL       WM_IsWindow
   \   000002A0   000050E3           CMP      R0,#+0
   \   000002A4   F3FFFF1A           BNE      ??WM_HandlePID_11
   \   000002A8   30108DE2           ADD      R1,SP,#+48
   \   000002AC   0800A0E1           MOV      R0,R8
   \   000002B0   ........           BL       WM__SendMessageIfEnabled
    240                    WM__aCHWinMouseOver[WM__TOUCHED_LAYER].hWin = 0;
   \   000002B4   000095E5           LDR      R0,[R5, #+0]
   \   000002B8   800187E0           ADD      R0,R7,R0, LSL #+3
   \   000002BC   C44180E5           STR      R4,[R0, #+452]
    241                  }
    242                }
    243              }
    244              #endif
    245              if (WM__IsInModalArea(CHWin.hWin)) {
   \                     ??WM_HandlePID_8:
   \   000002C0   10809DE5           LDR      R8,[SP, #+16]
   \   000002C4   000095E5           LDR      R0,[R5, #+0]
   \   000002C8   800187E0           ADD      R0,R7,R0, LSL #+3
   \   000002CC   C41090E5           LDR      R1,[R0, #+196]
   \   000002D0   000051E3           CMP      R1,#+0
   \   000002D4   0900000A           BEQ      ??WM_HandlePID_12
   \   000002D8   C41090E5           LDR      R1,[R0, #+196]
   \   000002DC   0800A0E1           MOV      R0,R8
   \   000002E0   ........           BL       WM__IsAncestor
   \   000002E4   000050E3           CMP      R0,#+0
   \   000002E8   0400001A           BNE      ??WM_HandlePID_12
   \   000002EC   000095E5           LDR      R0,[R5, #+0]
   \   000002F0   800187E0           ADD      R0,R7,R0, LSL #+3
   \   000002F4   C40090E5           LDR      R0,[R0, #+196]
   \   000002F8   000058E1           CMP      R8,R0
   \   000002FC   D400001A           BNE      ??WM_HandlePID_13
    246                #if GUI_SUPPORT_MOUSE
    247                  WM__aCHWinMouseOver[WM__TOUCHED_LAYER].hWin = CHWin.hWin;
   \                     ??WM_HandlePID_12:
   \   00000300   000095E5           LDR      R0,[R5, #+0]
   \   00000304   10209DE5           LDR      R2,[SP, #+16]
   \   00000308   801187E0           ADD      R1,R7,R0, LSL #+3
    248                #endif
    249                /*
    250                 * Send WM_PID_STATE_CHANGED message if state has changed (just pressed or just released)
    251                 */
    252                if ((_aStateLast[WM__TOUCHED_LAYER].Pressed != StateNew.Pressed) && CHWin.hWin) {
   \   0000030C   967020E0           MLA      R0,R6,R0,R7
   \   00000310   C42181E5           STR      R2,[R1, #+452]
   \   00000314   0800D0E5           LDRB     R0,[R0, #+8]
   \   00000318   0810DDE5           LDRB     R1,[SP, #+8]
   \   0000031C   010050E1           CMP      R0,R1
   \   00000320   10009D15           LDRNE    R0,[SP, #+16]
   \   00000324   00005013           CMPNE    R0,#+0
   \   00000328   3900000A           BEQ      ??WM_HandlePID_14
    253                  GUI_PID_STATE PID_StateOld;
    254                  WM_HWIN hWinOld, hWinLast;
    255                  WM_PID_STATE_CHANGED_INFO Info;
    256                  WM_Obj* pWin;
    257                  pWin = WM_H2P(CHWin.hWin);
   \   0000032C   10009DE5           LDR      R0,[SP, #+16]
   \   00000330   ........           BL       GUI_ALLOC_h2p
    258                  Info.State     = StateNew.Pressed;
   \   00000334   0820DDE5           LDRB     R2,[SP, #+8]
    259                  Info.StatePrev = _aStateLast[WM__TOUCHED_LAYER].Pressed;
   \   00000338   001095E5           LDR      R1,[R5, #+0]
    260                  Info.x         = StateNew.x - pWin->Rect.x0;
   \   0000033C   00C09DE5           LDR      R12,[SP, #+0]
   \   00000340   5020CDE5           STRB     R2,[SP, #+80]
   \   00000344   960102E0           MUL      R2,R6,R1
   \   00000348   073082E0           ADD      R3,R2,R7
   \   0000034C   08E0D3E5           LDRB     LR,[R3, #+8]
    261                  Info.y         = StateNew.y - pWin->Rect.y0;
    262                  Msg.Data.p = &Info;
    263                  Msg.MsgId  = WM_PID_STATE_CHANGED;
    264                  /* Make sure that this routine does not react a second time on the same press event.
    265                   * This could happen if for example a dialog is executed during the WM_PID_STATE_CHANGED message processing
    266                   */
    267                  PID_StateOld = _aStateLast[WM__TOUCHED_LAYER];
   \   00000350   072082E0           ADD      R2,R2,R7
   \   00000354   51E0CDE5           STRB     LR,[SP, #+81]
   \   00000358   F0E0D0E1           LDRSH    LR,[R0, #+0]
   \   0000035C   0EC04CE0           SUB      R12,R12,LR
   \   00000360   48C08DE5           STR      R12,[SP, #+72]
   \   00000364   F200D0E1           LDRSH    R0,[R0, #+2]
   \   00000368   04C09DE5           LDR      R12,[SP, #+4]
   \   0000036C   00004CE0           SUB      R0,R12,R0
   \   00000370   48C08DE2           ADD      R12,SP,#+72
   \   00000374   3CC08DE5           STR      R12,[SP, #+60]
   \   00000378   11C0A0E3           MOV      R12,#+17
   \   0000037C   4C008DE5           STR      R0,[SP, #+76]
   \   00000380   30C08DE5           STR      R12,[SP, #+48]
   \   00000384   0051B2E8           LDM      R2!,{R8,R12,LR}
   \   00000388   54008DE2           ADD      R0,SP,#+84
   \   0000038C   0051A0E8           STM      R0!,{R8,R12,LR}
    268                  /* Make sure that in case of creating a new window over the current PID position
    269                   * during the WM_PID_STATE_CHANGED message processing the old window
    270                   * will be informed that it is no longer pressed.
    271                   */
    272                  _aStateLast[WM__TOUCHED_LAYER].Pressed = StateNew.Pressed;
   \   00000390   0800DDE5           LDRB     R0,[SP, #+8]
   \   00000394   0800C3E5           STRB     R0,[R3, #+8]
    273                  if (State.Pressed) {
   \   00000398   810187E0           ADD      R0,R7,R1, LSL #+3
   \   0000039C   1C10DDE5           LDRB     R1,[SP, #+28]
   \   000003A0   000051E3           CMP      R1,#+0
   \   000003A4   0300000A           BEQ      ??WM_HandlePID_15
    274                    hWinOld            = WM__aCHWinLast[WM__TOUCHED_LAYER].hWin;
   \   000003A8   448190E5           LDR      R8,[R0, #+324]
    275                    WM__aCHWinLast[WM__TOUCHED_LAYER].hWin = CHWin.hWin;
   \   000003AC   10109DE5           LDR      R1,[SP, #+16]
   \   000003B0   441180E5           STR      R1,[R0, #+324]
   \   000003B4   000000EA           B        ??WM_HandlePID_16
    276                  } else {
    277                    hWinOld            = 0;
   \                     ??WM_HandlePID_15:
   \   000003B8   0080A0E3           MOV      R8,#+0
    278                  }
    279                  hWinLast = WM__aCHWinLast[WM__TOUCHED_LAYER].hWin;
   \                     ??WM_HandlePID_16:
   \   000003BC   449190E5           LDR      R9,[R0, #+324]
    280                  WM__SendMessageIfEnabled(CHWin.hWin, &Msg);
   \   000003C0   30108DE2           ADD      R1,SP,#+48
   \   000003C4   10009DE5           LDR      R0,[SP, #+16]
   \   000003C8   ........           BL       WM__SendMessageIfEnabled
    281                  if (hWinLast != WM__aCHWinLast[WM__TOUCHED_LAYER].hWin) {
   \   000003CC   000095E5           LDR      R0,[R5, #+0]
   \   000003D0   801187E0           ADD      R1,R7,R0, LSL #+3
   \   000003D4   442191E5           LDR      R2,[R1, #+324]
   \   000003D8   020059E1           CMP      R9,R2
    282                    CHWin.hWin = WM__aCHWinLast[WM__TOUCHED_LAYER].hWin;
   \   000003DC   44119115           LDRNE    R1,[R1, #+324]
   \   000003E0   10108D15           STRNE    R1,[SP, #+16]
    283                  }
    284                  /* Restore state for further processing */
    285                  _aStateLast[WM__TOUCHED_LAYER] = PID_StateOld;
   \   000003E4   54108DE2           ADD      R1,SP,#+84
   \   000003E8   0C10B1E8           LDM      R1!,{R2,R3,R12}
   \   000003EC   967020E0           MLA      R0,R6,R0,R7
    286                  if (hWinOld) {
   \   000003F0   000058E3           CMP      R8,#+0
   \   000003F4   0C10A0E8           STM      R0!,{R2,R3,R12}
   \   000003F8   0500000A           BEQ      ??WM_HandlePID_14
    287                    /* hWinOld could be deleted during message processing. So check if it is a Window
    288                     * before using it.
    289                     */
    290                    if (WM_IsWindow(hWinOld)) {
   \   000003FC   0800A0E1           MOV      R0,R8
   \   00000400   ........           BL       WM_IsWindow
   \   00000404   000050E3           CMP      R0,#+0
    291                      WM__aCHWinLast[WM__TOUCHED_LAYER].hWin        = hWinOld;
   \   00000408   00009515           LDRNE    R0,[R5, #+0]
   \   0000040C   80018710           ADDNE    R0,R7,R0, LSL #+3
   \   00000410   44818015           STRNE    R8,[R0, #+324]
    292                    }
    293                  }
    294                }
    295                /*
    296                 * Send WM_TOUCH message(s)
    297                 * Note that we may have to send 2 touch messages.
    298                 */
    299                if (_aStateLast[WM__TOUCHED_LAYER].Pressed | StateNew.Pressed) {    /* Only if pressed or just released */
   \                     ??WM_HandlePID_14:
   \   00000414   003095E5           LDR      R3,[R5, #+0]
   \   00000418   0820DDE5           LDRB     R2,[SP, #+8]
   \   0000041C   960300E0           MUL      R0,R6,R3
   \   00000420   071080E0           ADD      R1,R0,R7
   \   00000424   08C0D1E5           LDRB     R12,[R1, #+8]
   \   00000428   0CC092E1           ORRS     R12,R2,R12
   \   0000042C   5600000A           BEQ      ??WM_HandlePID_17
    300                  Msg.MsgId = WM_TOUCH;
   \   00000430   30608DE5           STR      R6,[SP, #+48]
    301                  r = 1;
    302                  /*
    303                   * Tell window that it is no longer pressed.
    304                   * This happens for 2 possible reasons:
    305                   * a) PID is released
    306                   * b) PID is moved out
    307                   */
    308                  hWin = WM__aCHWinLast[WM__TOUCHED_LAYER].hWin; // Suppress warning: 'undefined behavior: the order of volatile accesses is undefined'
   \   00000434   833187E0           ADD      R3,R7,R3, LSL #+3
   \   00000438   44C193E5           LDR      R12,[R3, #+324]
    309                  if (hWin != CHWin.hWin) {
   \   0000043C   10E09DE5           LDR      LR,[SP, #+16]
   \   00000440   0140A0E3           MOV      R4,#+1
   \   00000444   0E005CE1           CMP      R12,LR
    310                    if (WM__aCHWinLast[WM__TOUCHED_LAYER].hWin != 0) {
   \   00000448   44C19315           LDRNE    R12,[R3, #+324]
   \   0000044C   00005C13           CMPNE    R12,#+0
   \   00000450   3300000A           BEQ      ??WM_HandlePID_18
    311                      if (StateNew.Pressed) {
   \   00000454   0080A0E3           MOV      R8,#+0
   \   00000458   000052E3           CMP      R2,#+0
    312                        /* Moved out -> no longer in this window
    313                         * Send a NULL pointer as data
    314                         */
    315                        Msg.Data.p = NULL;
   \   0000045C   3C808D15           STRNE    R8,[SP, #+60]
   \   00000460   0600001A           BNE      ??WM_HandlePID_19
    316                      } else {
    317                        /* Last window needs to know that it has been "Released"
    318                         * Send last coordinates 
    319                         */
    320                        State.x       = _aStateLast[WM__TOUCHED_LAYER].x;
   \   00000464   070090E7           LDR      R0,[R0, +R7]
   \   00000468   14008DE5           STR      R0,[SP, #+20]
    321                        State.y       = _aStateLast[WM__TOUCHED_LAYER].y;
   \   0000046C   041091E5           LDR      R1,[R1, #+4]
    322                        State.Pressed = 0;
   \   00000470   1C80CDE5           STRB     R8,[SP, #+28]
   \   00000474   18108DE5           STR      R1,[SP, #+24]
    323                        Msg.Data.p = (void*)&State;
   \   00000478   14108DE2           ADD      R1,SP,#+20
   \   0000047C   3C108DE5           STR      R1,[SP, #+60]
    324                      }
    325                      GUI_DEBUG_LOG1 ("\nSending WM_Touch to LastWindow %d (out of area)", WM__aCHWinLast[WM__TOUCHED_LAYER].hWin);
    326                      WM__SendTouchMessage(WM__aCHWinLast[WM__TOUCHED_LAYER].hWin, &Msg);
   \                     ??WM_HandlePID_19:
   \   00000480   449193E5           LDR      R9,[R3, #+324]
   \   00000484   3CA09DE5           LDR      R10,[SP, #+60]
   \   00000488   00005AE3           CMP      R10,#+0
   \   0000048C   0900000A           BEQ      ??WM_HandlePID_20
   \   00000490   0900A0E1           MOV      R0,R9
   \   00000494   ........           BL       GUI_ALLOC_h2p
   \   00000498   F020D0E1           LDRSH    R2,[R0, #+0]
   \   0000049C   00109AE5           LDR      R1,[R10, #+0]
   \   000004A0   021041E0           SUB      R1,R1,R2
   \   000004A4   00108AE5           STR      R1,[R10, #+0]
   \   000004A8   F200D0E1           LDRSH    R0,[R0, #+2]
   \   000004AC   04109AE5           LDR      R1,[R10, #+4]
   \   000004B0   000041E0           SUB      R0,R1,R0
   \   000004B4   04008AE5           STR      R0,[R10, #+4]
   \                     ??WM_HandlePID_20:
   \   000004B8   30108DE2           ADD      R1,SP,#+48
   \   000004BC   0C50B1E8           LDM      R1!,{R2,R3,R12,LR}
   \   000004C0   20008DE2           ADD      R0,SP,#+32
   \   000004C4   0C50A0E8           STM      R0!,{R2,R3,R12,LR}
   \   000004C8   0D10A0E3           MOV      R1,#+13
   \   000004CC   28908DE5           STR      R9,[SP, #+40]
   \   000004D0   20108DE5           STR      R1,[SP, #+32]
   \   000004D4   09A0A0E1           MOV      R10,R9
   \   000004D8   070000EA           B        ??WM_HandlePID_21
   \                     ??WM_HandlePID_22:
   \   000004DC   0A00A0E1           MOV      R0,R10
   \   000004E0   ........           BL       WM_GetParent
   \   000004E4   00A0B0E1           MOVS     R10,R0
   \   000004E8   0300000A           BEQ      ??WM_HandlePID_21
   \   000004EC   30108DE2           ADD      R1,SP,#+48
   \   000004F0   2C108DE5           STR      R1,[SP, #+44]
   \   000004F4   20108DE2           ADD      R1,SP,#+32
   \   000004F8   ........           BL       WM__SendMessageIfEnabled
   \                     ??WM_HandlePID_21:
   \   000004FC   0A00A0E1           MOV      R0,R10
   \   00000500   ........           BL       WM_IsWindow
   \   00000504   000050E3           CMP      R0,#+0
   \   00000508   F3FFFF1A           BNE      ??WM_HandlePID_22
   \   0000050C   30108DE2           ADD      R1,SP,#+48
   \   00000510   0900A0E1           MOV      R0,R9
   \   00000514   ........           BL       WM__SendMessageIfEnabled
    327                      WM__aCHWinLast[WM__TOUCHED_LAYER].hWin = 0;
   \   00000518   000095E5           LDR      R0,[R5, #+0]
   \   0000051C   800187E0           ADD      R0,R7,R0, LSL #+3
   \   00000520   448180E5           STR      R8,[R0, #+324]
    328                    }
    329                  }
    330                  /* Make sure that this routine does not react a second time on the same event.
    331                   * This could happen if for example a dialog is executed during the WM_TOUCH message processing
    332                   */
    333                  _aStateLast[WM__TOUCHED_LAYER].Pressed = StateNew.Pressed;
   \                     ??WM_HandlePID_18:
   \   00000524   000095E5           LDR      R0,[R5, #+0]
   \   00000528   0820DDE5           LDRB     R2,[SP, #+8]
   \   0000052C   967021E0           MLA      R1,R6,R0,R7
   \   00000530   0820C1E5           STRB     R2,[R1, #+8]
    334                  /* Sending WM_Touch to current window */
    335                  if (CHWin.hWin) {
   \   00000534   10109DE5           LDR      R1,[SP, #+16]
   \   00000538   000051E3           CMP      R1,#+0
   \   0000053C   4400000A           BEQ      ??WM_HandlePID_13
    336                    /* convert screen into window coordinates */
    337                    State = StateNew;
   \   00000540   0D20A0E1           MOV      R2,SP
   \   00000544   0850B2E8           LDM      R2!,{R3,R12,LR}
   \   00000548   14108DE2           ADD      R1,SP,#+20
   \   0000054C   0850A1E8           STM      R1!,{R3,R12,LR}
    338                    /* Remember window */
    339                    if (State.Pressed) {
   \   00000550   1C10DDE5           LDRB     R1,[SP, #+28]
   \   00000554   000051E3           CMP      R1,#+0
    340                      WM__aCHWinLast[WM__TOUCHED_LAYER].hWin = CHWin.hWin;
   \   00000558   80018710           ADDNE    R0,R7,R0, LSL #+3
   \   0000055C   10109D15           LDRNE    R1,[SP, #+16]
   \   00000560   0700001A           BNE      ??WM_HandlePID_23
    341                    } else {
    342                      /* Handle automatic capture release */
    343                      if (WM__CaptureReleaseAuto) {
   \   00000564   ........           LDR      R0,??DataTable3_5
   \   00000568   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000056C   000050E3           CMP      R0,#+0
   \   00000570   0000000A           BEQ      ??WM_HandlePID_24
    344                        WM_ReleaseCapture();
   \   00000574   ........           BL       WM_ReleaseCapture
    345                      }
    346                      WM__aCHWinLast[WM__TOUCHED_LAYER].hWin = 0;
   \                     ??WM_HandlePID_24:
   \   00000578   000095E5           LDR      R0,[R5, #+0]
   \   0000057C   0010A0E3           MOV      R1,#+0
   \   00000580   800187E0           ADD      R0,R7,R0, LSL #+3
   \                     ??WM_HandlePID_23:
   \   00000584   441180E5           STR      R1,[R0, #+324]
    347                    }
    348                    Msg.Data.p = (void*)&State;
   \   00000588   0C0000EA           B        ??WM_HandlePID_25
    349                    WM__SendTouchMessage(CHWin.hWin, &Msg);
    350                  }
    351                }
    352                /*
    353                 * Send WM_MOUSEOVER message
    354                 */
    355                #if GUI_SUPPORT_MOUSE
    356                else {
    357                  /* Send WM_MOUSEOVER Message */
    358                  if (CHWin.hWin) {
   \                     ??WM_HandlePID_17:
   \   0000058C   10009DE5           LDR      R0,[SP, #+16]
   \   00000590   000050E3           CMP      R0,#+0
   \   00000594   2E00000A           BEQ      ??WM_HandlePID_13
    359                    /* Do not send messages to disabled windows */
    360                    if (WM__IsEnabled(CHWin.hWin)) {
   \   00000598   10009DE5           LDR      R0,[SP, #+16]
   \   0000059C   ........           BL       WM__IsEnabled
   \   000005A0   000050E3           CMP      R0,#+0
   \   000005A4   2A00000A           BEQ      ??WM_HandlePID_13
    361                      State      = StateNew;
   \   000005A8   0D10A0E1           MOV      R1,SP
   \   000005AC   0C10B1E8           LDM      R1!,{R2,R3,R12}
   \   000005B0   14008DE2           ADD      R0,SP,#+20
   \   000005B4   0C10A0E8           STM      R0!,{R2,R3,R12}
    362                      Msg.MsgId  = WM_MOUSEOVER;
   \   000005B8   1010A0E3           MOV      R1,#+16
   \   000005BC   30108DE5           STR      R1,[SP, #+48]
    363                      Msg.Data.p = (void*)&State;
   \                     ??WM_HandlePID_25:
   \   000005C0   14108DE2           ADD      R1,SP,#+20
   \   000005C4   3C108DE5           STR      R1,[SP, #+60]
    364                      WM__SendTouchMessage(CHWin.hWin, &Msg);
   \   000005C8   10809DE5           LDR      R8,[SP, #+16]
   \   000005CC   0800A0E1           MOV      R0,R8
   \   000005D0   ........           BL       GUI_ALLOC_h2p
   \   000005D4   F020D0E1           LDRSH    R2,[R0, #+0]
   \   000005D8   14109DE5           LDR      R1,[SP, #+20]
   \   000005DC   0890A0E1           MOV      R9,R8
   \   000005E0   021041E0           SUB      R1,R1,R2
   \   000005E4   14108DE5           STR      R1,[SP, #+20]
   \   000005E8   F200D0E1           LDRSH    R0,[R0, #+2]
   \   000005EC   18109DE5           LDR      R1,[SP, #+24]
   \   000005F0   000041E0           SUB      R0,R1,R0
   \   000005F4   18008DE5           STR      R0,[SP, #+24]
   \   000005F8   30108DE2           ADD      R1,SP,#+48
   \   000005FC   0C50B1E8           LDM      R1!,{R2,R3,R12,LR}
   \   00000600   20008DE2           ADD      R0,SP,#+32
   \   00000604   0C50A0E8           STM      R0!,{R2,R3,R12,LR}
   \   00000608   0D10A0E3           MOV      R1,#+13
   \   0000060C   28808DE5           STR      R8,[SP, #+40]
   \   00000610   20108DE5           STR      R1,[SP, #+32]
   \   00000614   070000EA           B        ??WM_HandlePID_26
   \                     ??WM_HandlePID_27:
   \   00000618   0900A0E1           MOV      R0,R9
   \   0000061C   ........           BL       WM_GetParent
   \   00000620   0090B0E1           MOVS     R9,R0
   \   00000624   0300000A           BEQ      ??WM_HandlePID_26
   \   00000628   30108DE2           ADD      R1,SP,#+48
   \   0000062C   2C108DE5           STR      R1,[SP, #+44]
   \   00000630   20108DE2           ADD      R1,SP,#+32
   \   00000634   ........           BL       WM__SendMessageIfEnabled
   \                     ??WM_HandlePID_26:
   \   00000638   0900A0E1           MOV      R0,R9
   \   0000063C   ........           BL       WM_IsWindow
   \   00000640   000050E3           CMP      R0,#+0
   \   00000644   F3FFFF1A           BNE      ??WM_HandlePID_27
   \   00000648   30108DE2           ADD      R1,SP,#+48
   \   0000064C   0800A0E1           MOV      R0,R8
   \   00000650   ........           BL       WM__SendMessageIfEnabled
    365                    }
    366                  }
    367                }
    368                #endif
    369              }
    370              /* Store the new state */
    371              _aStateLast[WM__TOUCHED_LAYER] = StateNew;
   \                     ??WM_HandlePID_13:
   \   00000654   0D20A0E1           MOV      R2,SP
   \   00000658   001095E5           LDR      R1,[R5, #+0]
   \   0000065C   0850B2E8           LDM      R2!,{R3,R12,LR}
   \   00000660   967120E0           MLA      R0,R6,R1,R7
   \   00000664   0850A0E8           STM      R0!,{R3,R12,LR}
    372              WM_PID__SetPrevState(&StateNew, WM__TOUCHED_LAYER);
   \   00000668   0D00A0E1           MOV      R0,SP
   \   0000066C   ........           BL       WM_PID__SetPrevState
    373            }
    374            WM__RemoveCriticalHandle(&CHWin);
   \                     ??WM_HandlePID_6:
   \   00000670   0C008DE2           ADD      R0,SP,#+12
   \   00000674   ........           BL       WM__RemoveCriticalHandle
    375            WM_UNLOCK();
   \   00000678   ........           BL       GUI_Unlock
    376            return r;
   \                     ??WM_HandlePID_1:
   \   0000067C   0400A0E1           MOV      R0,R4
   \   00000680   60D08DE2           ADD      SP,SP,#+96
   \   00000684   F087BDE8           POP      {R4-R10,PC}      ;; return
    377          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     WM__TouchedLayer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   ........           DC32     _aStateLast

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   ........           DC32     GUI_OrgX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   ........           DC32     GUI_OrgY

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   ........           DC32     WM__ahCapture

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   ........           DC32     WM__CaptureReleaseAuto

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 12 bytes
   \   00000000   00000000           DC32 0
   \   00000004   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
    378          
    379          #else
    380            void WM_Touch_c(void) {} /* avoid empty object files */
    381          #endif  /* (GUI_WINSUPPORT & GUI_SUPPORT_TOUCH) */
    382          
    383          /*************************** End of file ****************************/
    384          

   Maximum stack usage in bytes:

     Function             .cstack
     --------             -------
     WM_HandlePID            128
     WM__IsInModalArea        16
     WM__SendPIDMessage       32
     WM__SendTouchMessage     32
     WM__SetLastTouched        0


   Section sizes:

     Function/Label       Bytes
     --------------       -----
     _aStateLast           576
     WM__aCHWinModal
     WM__aCHWinLast
     WM__aCHWinMouseOver
     WM__IsInModalArea      92
     WM__SendPIDMessage    116
     WM__SendTouchMessage  164
     WM__SetLastTouched     28
     WM_HandlePID         1672
     ??DataTable3            4
     ??DataTable3_1          4
     ??DataTable3_2          4
     ??DataTable3_3          4
     ??DataTable3_4          4
     ??DataTable3_5          4
     ?<Constant {0}>        12

 
   576 bytes in section .bss
    12 bytes in section .rodata
 2 096 bytes in section .text
 
 2 096 bytes of CODE  memory
    12 bytes of CONST memory
   576 bytes of DATA  memory

Errors: none
Warnings: none
