###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     14/Jul/2015  19:01:19 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\LCD.c                               #
#    Command line =  C:\DUII\TargetHW\GUI\LCD.c -D DEBUG=1 -D SDRAM_TARGET=1  #
#                    -D USB_IS_HIGH_SPEED -D XIGNORE_TEMPERATURE -D           #
#                    BUILD_DEBUG_PORT -D PROFILER -lCN                        #
#                    C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\   #
#                    -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\ #
#                     --debug --endian=little --cpu=ARM926EJ-S -e --fpu=None  #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\LC #
#                    D.lst                                                    #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\LCD #
#                    .o                                                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\LCD.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : LCD.c
     19          Purpose     : Link between GUI and LCD_L0
     20                        Performs most of the clipping.
     21          ---------------------------END-OF-HEADER------------------------------
     22          */
     23          
     24          #include "GUI_Private.h"
     25          
     26          /*********************************************************************
     27          *
     28          *       Defines
     29          *
     30          **********************************************************************
     31          */
     32          
     33          #define RETURN_IF_Y_OUT() \
     34            if (y < GUI_Context.ClipRect.y0) return;             \
     35            if (y > GUI_Context.ClipRect.y1) return;
     36          
     37          #define RETURN_IF_X_OUT() \
     38            if (x < GUI_Context.ClipRect.x0) return;             \
     39            if (x > GUI_Context.ClipRect.x1) return;
     40          
     41          #define CLIP_X() \
     42            if (x0 < GUI_Context.ClipRect.x0) { x0 = GUI_Context.ClipRect.x0; } \
     43            if (x1 > GUI_Context.ClipRect.x1) { x1 = GUI_Context.ClipRect.x1; }
     44          
     45          #define CLIP_Y() \
     46            if (y0 < GUI_Context.ClipRect.y0) { y0 = GUI_Context.ClipRect.y0; } \
     47            if (y1 > GUI_Context.ClipRect.y1) { y1 = GUI_Context.ClipRect.y1; }
     48          
     49          /*********************************************************************
     50          *
     51          *       Static code
     52          *
     53          **********************************************************************
     54          */
     55          /*********************************************************************
     56          *
     57          *       _SetBkColor
     58          */

   \                                 In section .text, align 4, keep-with-next
     59          static void _SetBkColor(GUI_COLOR color) {
   \                     _SetBkColor:
   \   00000000   10402DE9           PUSH     {R4,LR}
     60            if (GUI_Context.BkColor != color) {
   \   00000004   ........           LDR      R4,??DataTable17
   \   00000008   341094E5           LDR      R1,[R4, #+52]
   \   0000000C   000051E1           CMP      R1,R0
   \   00000010   0C00000A           BEQ      ??_SetBkColor_0
     61              GUI_Context.BkColor = color;
     62              LCD_SetBkColorIndex(LCD_Color2Index(color));
   \   00000014   1110D4E5           LDRB     R1,[R4, #+17]
   \   00000018   340084E5           STR      R0,[R4, #+52]
   \   0000001C   011184E0           ADD      R1,R4,R1, LSL #+2
   \   00000020   481091E5           LDR      R1,[R1, #+72]
   \   00000024   101091E5           LDR      R1,[R1, #+16]
   \   00000028   001091E5           LDR      R1,[R1, #+0]
   \   0000002C   31FF2FE1           BLX      R1
   \   00000030   1010D4E5           LDRB     R1,[R4, #+16]
   \   00000034   040011E3           TST      R1,#0x4
   \   00000038   ........           LDRNE    R1,??DataTable17_1
   \   0000003C   ........           LDREQ    R1,??DataTable17_2
   \   00000040   001091E5           LDR      R1,[R1, #+0]
   \   00000044   000081E5           STR      R0,[R1, #+0]
     63            }
     64          }
   \                     ??_SetBkColor_0:
   \   00000048   1080BDE8           POP      {R4,PC}          ;; return
     65          
     66          /*********************************************************************
     67          *
     68          *       _SetColor
     69          */

   \                                 In section .text, align 4, keep-with-next
     70          static void _SetColor(GUI_COLOR color) {
   \                     _SetColor:
   \   00000000   10402DE9           PUSH     {R4,LR}
     71            if (GUI_Context.Color != color) {
   \   00000004   ........           LDR      R4,??DataTable17
   \   00000008   301094E5           LDR      R1,[R4, #+48]
   \   0000000C   000051E1           CMP      R1,R0
   \   00000010   0C00000A           BEQ      ??_SetColor_0
     72              GUI_Context.Color = color;
     73              LCD_SetColorIndex(LCD_Color2Index(color));
   \   00000014   1110D4E5           LDRB     R1,[R4, #+17]
   \   00000018   300084E5           STR      R0,[R4, #+48]
   \   0000001C   011184E0           ADD      R1,R4,R1, LSL #+2
   \   00000020   481091E5           LDR      R1,[R1, #+72]
   \   00000024   101091E5           LDR      R1,[R1, #+16]
   \   00000028   001091E5           LDR      R1,[R1, #+0]
   \   0000002C   31FF2FE1           BLX      R1
   \   00000030   1010D4E5           LDRB     R1,[R4, #+16]
   \   00000034   040011E3           TST      R1,#0x4
   \   00000038   ........           LDRNE    R1,??DataTable17_2
   \   0000003C   ........           LDREQ    R1,??DataTable17_1
   \   00000040   001091E5           LDR      R1,[R1, #+0]
   \   00000044   000081E5           STR      R0,[R1, #+0]
     74            }
     75          }
   \                     ??_SetColor_0:
   \   00000048   1080BDE8           POP      {R4,PC}          ;; return
     76          
     77          /*********************************************************************
     78          *
     79          *       _SetDrawMode
     80          */

   \                                 In section .text, align 4, keep-with-next
     81          static LCD_DRAWMODE _SetDrawMode(LCD_DRAWMODE dm) {
   \                     _SetDrawMode:
   \   00000000   10402DE9           PUSH     {R4,LR}
     82            LCD_PIXELINDEX temp;
     83            LCD_DRAWMODE OldDM;
     84          
     85            OldDM = GUI_Context.DrawMode;
   \   00000004   ........           LDR      R2,??DataTable17
   \   00000008   1030D2E5           LDRB     R3,[R2, #+16]
   \   0000000C   0310A0E1           MOV      R1,R3
     86            if ((GUI_Context.DrawMode ^ dm) & LCD_DRAWMODE_REV) {
   \   00000010   033020E0           EOR      R3,R0,R3
   \   00000014   040013E3           TST      R3,#0x4
   \   00000018   0700000A           BEQ      ??_SetDrawMode_0
     87              temp = LCD__GetBkColorIndex();
     88              LCD__SetBkColorIndex(LCD__GetColorIndex());
   \   0000001C   ........           LDR      LR,??DataTable17_1
   \   00000020   ........           LDR      R3,??DataTable17_2
   \   00000024   00E09EE5           LDR      LR,[LR, #+0]
   \   00000028   003093E5           LDR      R3,[R3, #+0]
   \   0000002C   00409EE5           LDR      R4,[LR, #+0]
   \   00000030   00C093E5           LDR      R12,[R3, #+0]
   \   00000034   004083E5           STR      R4,[R3, #+0]
     89              LCD__SetColorIndex(temp);
   \   00000038   00C08EE5           STR      R12,[LR, #+0]
     90            }
     91            GUI_Context.DrawMode = dm;
   \                     ??_SetDrawMode_0:
   \   0000003C   1000C2E5           STRB     R0,[R2, #+16]
     92            return OldDM;
   \   00000040   0100A0E1           MOV      R0,R1
   \   00000044   1080BDE8           POP      {R4,PC}          ;; return
     93          }
     94          
     95          /*********************************************************************
     96          *
     97          *       Static data, API table
     98          *
     99          **********************************************************************
    100          */

   \                                 In section .rodata, align 4, keep-with-next
    101          static const LCD_SET_COLOR_API _SetColorAPI = {
   \                     _SetColorAPI:
   \   00000000                      ; Initializer data, 12 bytes
   \   00000000   ............       DC32 _SetColor, _SetBkColor, _SetDrawMode
   \              ............
    102            _SetColor,
    103            _SetBkColor,
    104            _SetDrawMode,
    105          };
    106          
    107          /*********************************************************************
    108          *
    109          *       Private data
    110          *
    111          **********************************************************************
    112          */

   \                                 In section .data, align 4
    113          const LCD_SET_COLOR_API * LCD__pSetColorAPI = &_SetColorAPI;
   \                     LCD__pSetColorAPI:
   \   00000000   ........           DC32 _SetColorAPI
    114          
    115          /*********************************************************************
    116          *
    117          *       Public code
    118          *
    119          **********************************************************************
    120          */
    121          /*********************************************************************
    122          *
    123          *       LCD_SetDrawMode
    124          */

   \                                 In section .text, align 4, keep-with-next
    125          LCD_DRAWMODE LCD_SetDrawMode(LCD_DRAWMODE dm) {
    126            return LCD__pSetColorAPI->pfSetDrawMode(dm);
   \                     LCD_SetDrawMode:
   \   00000000   ........           LDR      R1,??DataTable17_3
   \   00000004   001091E5           LDR      R1,[R1, #+0]
   \   00000008   081091E5           LDR      R1,[R1, #+8]
   \   0000000C   11FF2FE1           BX       R1               ;; tailcall
    127          }
    128          
    129          /*********************************************************************
    130          *
    131          *       LCD_DrawPixel
    132          */

   \                                 In section .text, align 4, keep-with-next
    133          void LCD_DrawPixel(int x, int y) {
    134            RETURN_IF_Y_OUT();
   \                     LCD_DrawPixel:
   \   00000000   ........           LDR      R2,??DataTable17
   \   00000004   00C0A0E1           MOV      R12,R0
   \   00000008   FA00D2E1           LDRSH    R0,[R2, #+10]
   \   0000000C   000051E1           CMP      R1,R0
   \   00000010   FE00D2A1           LDRSHGE  R0,[R2, #+14]
   \   00000014   010050A1           CMPGE    R0,R1
    135            RETURN_IF_X_OUT();
   \   00000018   F800D2A1           LDRSHGE  R0,[R2, #+8]
   \   0000001C   00005CA1           CMPGE    R12,R0
   \   00000020   FC00D2A1           LDRSHGE  R0,[R2, #+12]
   \   00000024   0C0050A1           CMPGE    R0,R12
   \   00000028   000000AA           BGE      ??LCD_DrawPixel_0
   \   0000002C   1EFF2FE1           BX       LR
   \                     ??LCD_DrawPixel_0:
   \   00000030   00402DE9           PUSH     {LR}
   \   00000034   1100D2E5           LDRB     R0,[R2, #+17]
   \   00000038   04D04DE2           SUB      SP,SP,#+4
   \   0000003C   000182E0           ADD      R0,R2,R0, LSL #+2
   \   00000040   1020D2E5           LDRB     R2,[R2, #+16]
   \   00000044   480090E5           LDR      R0,[R0, #+72]
   \   00000048   010012E3           TST      R2,#0x1
   \   0000004C   0500000A           BEQ      ??LCD_DrawPixel_1
    136            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
    137              LCDDEV_L0_XorPixel(GUI_Context.apDevice[GUI_Context.SelLayer], x, y);
   \   00000050   0C3090E5           LDR      R3,[R0, #+12]
   \   00000054   0120A0E1           MOV      R2,R1
   \   00000058   0C10A0E1           MOV      R1,R12
   \   0000005C   1C3093E5           LDR      R3,[R3, #+28]
   \   00000060   33FF2FE1           BLX      R3
   \   00000064   070000EA           B        ??LCD_DrawPixel_2
    138            } else {
    139              LCDDEV_L0_SetPixelIndex(GUI_Context.apDevice[GUI_Context.SelLayer], x, y, LCD__GetColorIndex());
   \                     ??LCD_DrawPixel_1:
   \   00000068   ........           LDR      R2,??DataTable17_1
   \   0000006C   002092E5           LDR      R2,[R2, #+0]
   \   00000070   003092E5           LDR      R3,[R2, #+0]
   \   00000074   0120A0E1           MOV      R2,R1
   \   00000078   0C10A0E1           MOV      R1,R12
   \   0000007C   0CC090E5           LDR      R12,[R0, #+12]
   \   00000080   18C09CE5           LDR      R12,[R12, #+24]
   \   00000084   3CFF2FE1           BLX      R12
   \                     ??LCD_DrawPixel_2:
   \   00000088   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000008C   0080BDE8           POP      {PC}             ;; return
    140            }
    141          }
    142          
    143          /*********************************************************************
    144          *
    145          *       LCD_DrawHLine
    146          */

   \                                 In section .text, align 4, keep-with-next
    147          void LCD_DrawHLine(int x0, int y,  int x1) {
   \                     LCD_DrawHLine:
   \   00000000   00C0A0E1           MOV      R12,R0
    148            /* Perform clipping and check if there is something to do */
    149            RETURN_IF_Y_OUT();
   \   00000004   ........           LDR      R0,??DataTable17
   \   00000008   FA30D0E1           LDRSH    R3,[R0, #+10]
   \   0000000C   030051E1           CMP      R1,R3
   \   00000010   FE30D0A1           LDRSHGE  R3,[R0, #+14]
   \   00000014   010053A1           CMPGE    R3,R1
   \   00000018   000000AA           BGE      ??LCD_DrawHLine_0
   \   0000001C   1EFF2FE1           BX       LR
   \                     ??LCD_DrawHLine_0:
   \   00000020   00402DE9           PUSH     {LR}
   \   00000024   F830D0E1           LDRSH    R3,[R0, #+8]
   \   00000028   04D04DE2           SUB      SP,SP,#+4
   \   0000002C   03005CE1           CMP      R12,R3
    150            CLIP_X();
   \   00000030   03C0A0B1           MOVLT    R12,R3
   \   00000034   FC30D0E1           LDRSH    R3,[R0, #+12]
   \   00000038   020053E1           CMP      R3,R2
   \   0000003C   0320A0B1           MOVLT    R2,R3
    151            if (x1 < x0) {
   \   00000040   0C0052E1           CMP      R2,R12
   \   00000044   080000BA           BLT      ??LCD_DrawHLine_1
   \   00000048   1130D0E5           LDRB     R3,[R0, #+17]
   \   0000004C   030180E0           ADD      R0,R0,R3, LSL #+2
   \   00000050   0230A0E1           MOV      R3,R2
   \   00000054   480090E5           LDR      R0,[R0, #+72]
   \   00000058   0120A0E1           MOV      R2,R1
   \   0000005C   0C10A0E1           MOV      R1,R12
   \   00000060   0CC090E5           LDR      R12,[R0, #+12]
   \   00000064   08C09CE5           LDR      R12,[R12, #+8]
    152              return;
    153            }
    154            LCDDEV_L0_DrawHLine(GUI_Context.apDevice[GUI_Context.SelLayer], x0, y, x1);
   \   00000068   3CFF2FE1           BLX      R12
    155          }
   \                     ??LCD_DrawHLine_1:
   \   0000006C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000070   0080BDE8           POP      {PC}             ;; return
    156          
    157          /*********************************************************************
    158          *
    159          *       LCD_DrawVLine
    160          */

   \                                 In section .text, align 4, keep-with-next
    161          void LCD_DrawVLine(int x, int y0,  int y1) {
   \                     LCD_DrawVLine:
   \   00000000   00C0A0E1           MOV      R12,R0
    162            /* Perform clipping and check if there is something to do */
    163            RETURN_IF_X_OUT();
   \   00000004   ........           LDR      R0,??DataTable17
   \   00000008   F830D0E1           LDRSH    R3,[R0, #+8]
   \   0000000C   03005CE1           CMP      R12,R3
   \   00000010   FC30D0A1           LDRSHGE  R3,[R0, #+12]
   \   00000014   0C0053A1           CMPGE    R3,R12
   \   00000018   000000AA           BGE      ??LCD_DrawVLine_0
   \   0000001C   1EFF2FE1           BX       LR
   \                     ??LCD_DrawVLine_0:
   \   00000020   00402DE9           PUSH     {LR}
   \   00000024   FA30D0E1           LDRSH    R3,[R0, #+10]
   \   00000028   04D04DE2           SUB      SP,SP,#+4
   \   0000002C   030051E1           CMP      R1,R3
    164            CLIP_Y();
   \   00000030   0310A0B1           MOVLT    R1,R3
   \   00000034   FE30D0E1           LDRSH    R3,[R0, #+14]
   \   00000038   020053E1           CMP      R3,R2
   \   0000003C   0320A0B1           MOVLT    R2,R3
    165            if (y1 < y0) {
   \   00000040   010052E1           CMP      R2,R1
   \   00000044   080000BA           BLT      ??LCD_DrawVLine_1
   \   00000048   1130D0E5           LDRB     R3,[R0, #+17]
   \   0000004C   030180E0           ADD      R0,R0,R3, LSL #+2
   \   00000050   0230A0E1           MOV      R3,R2
   \   00000054   480090E5           LDR      R0,[R0, #+72]
   \   00000058   0120A0E1           MOV      R2,R1
   \   0000005C   0C10A0E1           MOV      R1,R12
   \   00000060   0CC090E5           LDR      R12,[R0, #+12]
   \   00000064   0CC09CE5           LDR      R12,[R12, #+12]
    166              return;
    167            }
    168            LCDDEV_L0_DrawVLine(GUI_Context.apDevice[GUI_Context.SelLayer], x, y0, y1);
   \   00000068   3CFF2FE1           BLX      R12
    169          }
   \                     ??LCD_DrawVLine_1:
   \   0000006C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000070   0080BDE8           POP      {PC}             ;; return
    170          
    171          /*********************************************************************
    172          *
    173          *       LCD_FillRect
    174          */

   \                                 In section .text, align 4, keep-with-next
    175          void LCD_FillRect(int x0, int y0, int x1, int y1) {
   \                     LCD_FillRect:
   \   00000000   00C0A0E1           MOV      R12,R0
   \   00000004   00402DE9           PUSH     {LR}
    176            /* Perform clipping and check if there is something to do */
    177            CLIP_X();
   \   00000008   ........           LDR      R0,??DataTable17
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   F8E0D0E1           LDRSH    LR,[R0, #+8]
   \   00000014   0E005CE1           CMP      R12,LR
   \   00000018   0EC0A0B1           MOVLT    R12,LR
   \   0000001C   FCE0D0E1           LDRSH    LR,[R0, #+12]
   \   00000020   02005EE1           CMP      LR,R2
   \   00000024   0E20A0B1           MOVLT    R2,LR
    178            if (x1 < x0) {
   \   00000028   0C0052E1           CMP      R2,R12
   \   0000002C   110000BA           BLT      ??LCD_FillRect_0
   \   00000030   FAE0D0E1           LDRSH    LR,[R0, #+10]
   \   00000034   0E0051E1           CMP      R1,LR
    179              return;
    180            }
    181            CLIP_Y();
   \   00000038   0E10A0B1           MOVLT    R1,LR
   \   0000003C   FEE0D0E1           LDRSH    LR,[R0, #+14]
   \   00000040   03005EE1           CMP      LR,R3
   \   00000044   0E30A0B1           MOVLT    R3,LR
    182            if (y1 < y0) {
   \   00000048   010053E1           CMP      R3,R1
   \   0000004C   090000BA           BLT      ??LCD_FillRect_0
   \   00000050   11E0D0E5           LDRB     LR,[R0, #+17]
   \   00000054   0E0180E0           ADD      R0,R0,LR, LSL #+2
   \   00000058   480090E5           LDR      R0,[R0, #+72]
   \   0000005C   00308DE5           STR      R3,[SP, #+0]
   \   00000060   0230A0E1           MOV      R3,R2
   \   00000064   0120A0E1           MOV      R2,R1
   \   00000068   0C10A0E1           MOV      R1,R12
   \   0000006C   0CC090E5           LDR      R12,[R0, #+12]
   \   00000070   10C09CE5           LDR      R12,[R12, #+16]
    183              return;
    184            }
    185            LCDDEV_L0_FillRect(GUI_Context.apDevice[GUI_Context.SelLayer], x0, y0, x1, y1);
   \   00000074   3CFF2FE1           BLX      R12
    186          }
   \                     ??LCD_FillRect_0:
   \   00000078   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000007C   0080BDE8           POP      {PC}             ;; return
    187          
    188          /*********************************************************************
    189          *
    190          *       LCD_DrawBitmap
    191          */

   \                                 In section .text, align 4, keep-with-next
    192          void LCD_DrawBitmap(int x0, int y0, int xsize, int ysize, int xMul, int yMul,
    193                                 int BitsPerPixel, int BytesPerLine,
    194                                 const U8 GUI_UNI_PTR * pPixel, const LCD_PIXELINDEX* pTrans)
    195          {
   \                     LCD_DrawBitmap:
   \   00000000   F54F2DE9           PUSH     {R0,R2,R4-R11,LR}
    196            U8  Data = 0;
    197            int x1, y1;
    198            /* Handle rotation if necessary */
    199            #if GUI_SUPPORT_ROTATION
    200            if (GUI_pLCD_APIList) {
   \   00000004   ........           LDR      R0,??DataTable17_4
   \   00000008   1CD04DE2           SUB      SP,SP,#+28
   \   0000000C   00C090E5           LDR      R12,[R0, #+0]
   \   00000010   50409DE5           LDR      R4,[SP, #+80]
   \   00000014   5C509DE5           LDR      R5,[SP, #+92]
   \   00000018   00005CE3           CMP      R12,#+0
   \   0000001C   0E00000A           BEQ      ??LCD_DrawBitmap_1
    201              GUI_pLCD_APIList->pfDrawBitmap(x0, y0, xsize, ysize, xMul, yMul, BitsPerPixel, BytesPerLine, pPixel, pTrans);
   \   00000020   58009DE5           LDR      R0,[SP, #+88]
   \   00000024   14508DE5           STR      R5,[SP, #+20]
   \   00000028   10008DE5           STR      R0,[SP, #+16]
   \   0000002C   54009DE5           LDR      R0,[SP, #+84]
   \   00000030   08408DE5           STR      R4,[SP, #+8]
   \   00000034   0C008DE5           STR      R0,[SP, #+12]
   \   00000038   4C009DE5           LDR      R0,[SP, #+76]
   \   0000003C   20209DE5           LDR      R2,[SP, #+32]
   \   00000040   04008DE5           STR      R0,[SP, #+4]
   \   00000044   48009DE5           LDR      R0,[SP, #+72]
   \   00000048   00008DE5           STR      R0,[SP, #+0]
   \   0000004C   1C009DE5           LDR      R0,[SP, #+28]
   \   00000050   00C09CE5           LDR      R12,[R12, #+0]
   \   00000054   3CFF2FE1           BLX      R12
    202              return;
   \   00000058   F00000EA           B        ??LCD_DrawBitmap_2
    203            }
    204            #endif
    205            y1 = y0 + ysize - 1;
    206            x1 = x0 + xsize - 1;
   \                     ??LCD_DrawBitmap_1:
   \   0000005C   1C209DE5           LDR      R2,[SP, #+28]
   \   00000060   20C09DE5           LDR      R12,[SP, #+32]
    207            if ((xMul | yMul) == 1) {
   \   00000064   4CE09DE5           LDR      LR,[SP, #+76]
   \   00000068   02208CE0           ADD      R2,R12,R2
   \   0000006C   48C09DE5           LDR      R12,[SP, #+72]
   \   00000070   010083E0           ADD      R0,R3,R1
   \   00000074   0CC08EE1           ORR      R12,LR,R12
   \   00000078   010040E2           SUB      R0,R0,#+1
   \   0000007C   012042E2           SUB      R2,R2,#+1
   \   00000080   01005CE3           CMP      R12,#+1
   \   00000084   8200001A           BNE      ??LCD_DrawBitmap_3
    208              /*  Handle BITMAP without magnification */
    209              int Diff;
    210              /*  Clip y0 (top) */
    211              Diff = GUI_Context.ClipRect.y0 - y0;
   \   00000088   ........           LDR      R6,??DataTable17
   \   0000008C   FAE0D6E1           LDRSH    LR,[R6, #+10]
   \   00000090   01C04EE0           SUB      R12,LR,R1
    212              if (Diff > 0) {
   \   00000094   01005CE3           CMP      R12,#+1
   \   00000098   070000BA           BLT      ??LCD_DrawBitmap_4
    213                ysize -= Diff;
   \   0000009C   0C3043E0           SUB      R3,R3,R12
    214                if (ysize <= 0) {
   \   000000A0   010053E3           CMP      R3,#+1
   \   000000A4   DD0000BA           BLT      ??LCD_DrawBitmap_2
    215          		    return;
    216                }
    217                y0     = GUI_Context.ClipRect.y0;
   \   000000A8   0E10A0E1           MOV      R1,LR
    218                #if GUI_SUPPORT_LARGE_BITMAPS                       /* Required only for 16 bit CPUs if some bitmaps are >64kByte */
    219                  pPixel += (U32)     Diff * (U32)     BytesPerLine;
   \   000000AC   54E09DE5           LDR      LR,[SP, #+84]
   \   000000B0   58709DE5           LDR      R7,[SP, #+88]
   \   000000B4   9E7C2CE0           MLA      R12,LR,R12,R7
   \   000000B8   58C08DE5           STR      R12,[SP, #+88]
    220                #else
    221                  pPixel += (unsigned)Diff * (unsigned)BytesPerLine;
    222                #endif
    223              }
    224              /*  Clip y1 (bottom) */
    225              Diff = y1 - GUI_Context.ClipRect.y1;
   \                     ??LCD_DrawBitmap_4:
   \   000000BC   FEC0D6E1           LDRSH    R12,[R6, #+14]
   \   000000C0   0CC040E0           SUB      R12,R0,R12
    226              if (Diff > 0) {
   \   000000C4   01005CE3           CMP      R12,#+1
   \   000000C8   020000BA           BLT      ??LCD_DrawBitmap_5
    227                ysize -= Diff;
   \   000000CC   0C3043E0           SUB      R3,R3,R12
    228                if (ysize <= 0) {
   \   000000D0   010053E3           CMP      R3,#+1
   \   000000D4   D10000BA           BLT      ??LCD_DrawBitmap_2
    229          		    return;
    230                }
    231              }
    232              /* Clip right side */
    233              Diff = x1 - GUI_Context.ClipRect.x1;
   \                     ??LCD_DrawBitmap_5:
   \   000000D8   FC00D6E1           LDRSH    R0,[R6, #+12]
    234              if (Diff > 0) {
    235                xsize -= Diff;
    236              }
    237              /* Clip left side ... (The difficult side ...) */
    238              Diff = 0;
   \   000000DC   00C0A0E3           MOV      R12,#+0
   \   000000E0   000042E0           SUB      R0,R2,R0
   \   000000E4   010050E3           CMP      R0,#+1
   \   000000E8   20209DA5           LDRGE    R2,[SP, #+32]
   \   000000EC   000042A0           SUBGE    R0,R2,R0
   \   000000F0   20008DA5           STRGE    R0,[SP, #+32]
   \   000000F4   F800D6E1           LDRSH    R0,[R6, #+8]
   \   000000F8   1C209DE5           LDR      R2,[SP, #+28]
   \   000000FC   000052E1           CMP      R2,R0
   \   00000100   4E0000AA           BGE      ??LCD_DrawBitmap_6
    239              if (x0 < GUI_Context.ClipRect.x0) {
    240                Diff = GUI_Context.ClipRect.x0 - x0;
   \   00000104   02C040E0           SUB      R12,R0,R2
    241          			xsize -= Diff;
   \   00000108   20009DE5           LDR      R0,[SP, #+32]
   \   0000010C   0C0040E0           SUB      R0,R0,R12
   \   00000110   20008DE5           STR      R0,[SP, #+32]
    242          			switch (BitsPerPixel) {
   \   00000114   010044E2           SUB      R0,R4,#+1
   \   00000118   1F0050E3           CMP      R0,#+31
   \   0000011C   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??LCD_DrawBitmap_0:
   \   00000120   4600008A           BHI      ??LCD_DrawBitmap_6
   \   00000124   1E0000EA           B        ??LCD_DrawBitmap_7
   \   00000128   260000EA           B        ??LCD_DrawBitmap_8
   \   0000012C   430000EA           B        ??LCD_DrawBitmap_6
   \   00000130   2C0000EA           B        ??LCD_DrawBitmap_9
   \   00000134   410000EA           B        ??LCD_DrawBitmap_6
   \   00000138   400000EA           B        ??LCD_DrawBitmap_6
   \   0000013C   3F0000EA           B        ??LCD_DrawBitmap_6
   \   00000140   310000EA           B        ??LCD_DrawBitmap_10
   \   00000144   3D0000EA           B        ??LCD_DrawBitmap_6
   \   00000148   3C0000EA           B        ??LCD_DrawBitmap_6
   \   0000014C   3B0000EA           B        ??LCD_DrawBitmap_6
   \   00000150   3A0000EA           B        ??LCD_DrawBitmap_6
   \   00000154   390000EA           B        ??LCD_DrawBitmap_6
   \   00000158   380000EA           B        ??LCD_DrawBitmap_6
   \   0000015C   370000EA           B        ??LCD_DrawBitmap_6
   \   00000160   2C0000EA           B        ??LCD_DrawBitmap_11
   \   00000164   350000EA           B        ??LCD_DrawBitmap_6
   \   00000168   340000EA           B        ??LCD_DrawBitmap_6
   \   0000016C   330000EA           B        ??LCD_DrawBitmap_6
   \   00000170   320000EA           B        ??LCD_DrawBitmap_6
   \   00000174   310000EA           B        ??LCD_DrawBitmap_6
   \   00000178   300000EA           B        ??LCD_DrawBitmap_6
   \   0000017C   2F0000EA           B        ??LCD_DrawBitmap_6
   \   00000180   270000EA           B        ??LCD_DrawBitmap_12
   \   00000184   2D0000EA           B        ??LCD_DrawBitmap_6
   \   00000188   2C0000EA           B        ??LCD_DrawBitmap_6
   \   0000018C   2B0000EA           B        ??LCD_DrawBitmap_6
   \   00000190   2A0000EA           B        ??LCD_DrawBitmap_6
   \   00000194   290000EA           B        ??LCD_DrawBitmap_6
   \   00000198   280000EA           B        ??LCD_DrawBitmap_6
   \   0000019C   270000EA           B        ??LCD_DrawBitmap_6
   \   000001A0   1F0000EA           B        ??LCD_DrawBitmap_12
    243          			case 1:
    244            			pPixel += (Diff >> 3); x0 += (Diff >> 3) << 3; Diff &= 7;
   \                     ??LCD_DrawBitmap_7:
   \   000001A4   58209DE5           LDR      R2,[SP, #+88]
   \   000001A8   CC01A0E1           ASR      R0,R12,#+3
   \   000001AC   022080E0           ADD      R2,R0,R2
   \   000001B0   58208DE5           STR      R2,[SP, #+88]
   \   000001B4   1C209DE5           LDR      R2,[SP, #+28]
   \   000001B8   07C00CE2           AND      R12,R12,#0x7
   \   000001BC   800182E0           ADD      R0,R2,R0, LSL #+3
   \                     ??LCD_DrawBitmap_13:
   \   000001C0   1C008DE5           STR      R0,[SP, #+28]
    245          				break;
   \   000001C4   1D0000EA           B        ??LCD_DrawBitmap_6
    246          			case 2:
    247          	  		pPixel += (Diff >> 2); x0 += (Diff >> 2) << 2; Diff &= 3;
   \                     ??LCD_DrawBitmap_8:
   \   000001C8   58209DE5           LDR      R2,[SP, #+88]
   \   000001CC   4C01A0E1           ASR      R0,R12,#+2
   \   000001D0   022080E0           ADD      R2,R0,R2
   \   000001D4   58208DE5           STR      R2,[SP, #+88]
   \   000001D8   1C209DE5           LDR      R2,[SP, #+28]
   \   000001DC   03C00CE2           AND      R12,R12,#0x3
   \   000001E0   000182E0           ADD      R0,R2,R0, LSL #+2
   \   000001E4   F5FFFFEA           B        ??LCD_DrawBitmap_13
    248          				break;
    249          			case 4:
    250          				pPixel += (Diff >> 1); x0 += (Diff >> 1) << 1; Diff &= 1;
   \                     ??LCD_DrawBitmap_9:
   \   000001E8   58209DE5           LDR      R2,[SP, #+88]
   \   000001EC   CC00A0E1           ASR      R0,R12,#+1
   \   000001F0   022080E0           ADD      R2,R0,R2
   \   000001F4   58208DE5           STR      R2,[SP, #+88]
   \   000001F8   1C209DE5           LDR      R2,[SP, #+28]
   \   000001FC   01C00CE2           AND      R12,R12,#0x1
   \   00000200   800082E0           ADD      R0,R2,R0, LSL #+1
   \   00000204   1C008DE5           STR      R0,[SP, #+28]
    251          				break;
   \   00000208   0C0000EA           B        ??LCD_DrawBitmap_6
    252          			case 8:
    253          				pPixel += Diff;        x0 += Diff; Diff = 0;
   \                     ??LCD_DrawBitmap_10:
   \   0000020C   58009DE5           LDR      R0,[SP, #+88]
   \   00000210   00008CE0           ADD      R0,R12,R0
   \   00000214   040000EA           B        ??LCD_DrawBitmap_14
    254          				break;
    255          			case 16:
    256          				pPixel += (Diff << 1); x0 += Diff; Diff = 0;
   \                     ??LCD_DrawBitmap_11:
   \   00000218   58009DE5           LDR      R0,[SP, #+88]
   \   0000021C   8C0080E0           ADD      R0,R0,R12, LSL #+1
   \   00000220   010000EA           B        ??LCD_DrawBitmap_14
    257          				break;
    258          			case 24:
    259          			case 32:
    260          				pPixel += (Diff << 2); x0 += Diff; Diff = 0;
   \                     ??LCD_DrawBitmap_12:
   \   00000224   58009DE5           LDR      R0,[SP, #+88]
   \   00000228   0C0180E0           ADD      R0,R0,R12, LSL #+2
   \                     ??LCD_DrawBitmap_14:
   \   0000022C   58008DE5           STR      R0,[SP, #+88]
   \   00000230   1C009DE5           LDR      R0,[SP, #+28]
   \   00000234   00008CE0           ADD      R0,R12,R0
   \   00000238   1C008DE5           STR      R0,[SP, #+28]
   \   0000023C   00C0A0E3           MOV      R12,#+0
    261          				break;
    262          			}
    263              }
    264              if (xsize <=0) {
   \                     ??LCD_DrawBitmap_6:
   \   00000240   20009DE5           LDR      R0,[SP, #+32]
   \   00000244   010050E3           CMP      R0,#+1
   \   00000248   740000BA           BLT      ??LCD_DrawBitmap_2
   \   0000024C   1100D6E5           LDRB     R0,[R6, #+17]
   \   00000250   58209DE5           LDR      R2,[SP, #+88]
   \   00000254   000186E0           ADD      R0,R6,R0, LSL #+2
   \   00000258   480090E5           LDR      R0,[R0, #+72]
   \   0000025C   0C208DE5           STR      R2,[SP, #+12]
   \   00000260   54209DE5           LDR      R2,[SP, #+84]
   \   00000264   14508DE5           STR      R5,[SP, #+20]
   \   00000268   10C08DE5           STR      R12,[SP, #+16]
   \   0000026C   08208DE5           STR      R2,[SP, #+8]
   \   00000270   04408DE5           STR      R4,[SP, #+4]
   \   00000274   00308DE5           STR      R3,[SP, #+0]
   \   00000278   0CC090E5           LDR      R12,[R0, #+12]
   \   0000027C   0120A0E1           MOV      R2,R1
   \   00000280   20309DE5           LDR      R3,[SP, #+32]
   \   00000284   1C109DE5           LDR      R1,[SP, #+28]
   \   00000288   04C09CE5           LDR      R12,[R12, #+4]
    265          		  return;
    266              }
    267              /*
    268               * Get low level function pointer for drawing already clipped bitmaps
    269               * and pass the bitmap data to it.
    270               */
    271              LCDDEV_L0_DrawBitmap(GUI_Context.apDevice[GUI_Context.SelLayer], x0, y0, xsize, ysize, BitsPerPixel, BytesPerLine, pPixel, Diff, pTrans);
   \   0000028C   3CFF2FE1           BLX      R12
   \   00000290   620000EA           B        ??LCD_DrawBitmap_2
    272            } else {
    273              /* Handle BITMAP with magnification */
    274              int x, y;
    275              int yi;
    276              int Shift;
    277              Shift = 8 - BitsPerPixel;
   \                     ??LCD_DrawBitmap_3:
   \   00000294   080064E2           RSB      R0,R4,#+8
   \   00000298   14008DE5           STR      R0,[SP, #+20]
    278              for (y = y0, yi = 0; yi < ysize; yi++, y += yMul, pPixel += BytesPerLine) {
   \   0000029C   04108DE5           STR      R1,[SP, #+4]
   \   000002A0   010053E3           CMP      R3,#+1
   \   000002A4   5D0000BA           BLT      ??LCD_DrawBitmap_2
   \   000002A8   08308DE5           STR      R3,[SP, #+8]
   \   000002AC   ........           LDR      R6,??DataTable17
    279                int yMax;
    280                yMax = y + yMul - 1;
   \                     ??LCD_DrawBitmap_15:
   \   000002B0   4C009DE5           LDR      R0,[SP, #+76]
   \   000002B4   04109DE5           LDR      R1,[SP, #+4]
   \   000002B8   000081E0           ADD      R0,R1,R0
    281                /* Draw if within clip area (Optimization ... "if" is not required !) */
    282                if ((yMax >= GUI_Context.ClipRect.y0) && (y <= GUI_Context.ClipRect.y1)) {
   \   000002BC   FA10D6E1           LDRSH    R1,[R6, #+10]
   \   000002C0   010040E2           SUB      R0,R0,#+1
   \   000002C4   0C008DE5           STR      R0,[SP, #+12]
   \   000002C8   010050E1           CMP      R0,R1
   \   000002CC   460000BA           BLT      ??LCD_DrawBitmap_16
   \   000002D0   FE00D6E1           LDRSH    R0,[R6, #+14]
   \   000002D4   04109DE5           LDR      R1,[SP, #+4]
   \   000002D8   010050E1           CMP      R0,R1
   \   000002DC   420000BA           BLT      ??LCD_DrawBitmap_16
    283                  int BitsLeft = 0;
    284                  int xi;
    285                  const U8 GUI_UNI_PTR * pDataLine = pPixel;
   \   000002E0   58109DE5           LDR      R1,[SP, #+88]
    286                  for (x = x0, xi = 0; xi < xsize; xi++, x += xMul) {
   \   000002E4   20009DE5           LDR      R0,[SP, #+32]
   \   000002E8   10108DE5           STR      R1,[SP, #+16]
   \   000002EC   1C709DE5           LDR      R7,[SP, #+28]
   \   000002F0   010050E3           CMP      R0,#+1
   \   000002F4   3C0000BA           BLT      ??LCD_DrawBitmap_16
   \   000002F8   20809DE5           LDR      R8,[SP, #+32]
   \   000002FC   010000EA           B        ??LCD_DrawBitmap_17
    287                    U8 Index;
    288                    if (!BitsLeft) {
   \                     ??LCD_DrawBitmap_18:
   \   00000300   00005AE3           CMP      R10,#+0
   \   00000304   0300001A           BNE      ??LCD_DrawBitmap_19
    289                      Data = *pDataLine++;
   \                     ??LCD_DrawBitmap_17:
   \   00000308   10109DE5           LDR      R1,[SP, #+16]
    290                      BitsLeft =8;
   \   0000030C   08A0A0E3           MOV      R10,#+8
   \   00000310   0190D1E4           LDRB     R9,[R1], #+1
   \   00000314   10108DE5           STR      R1,[SP, #+16]
    291                    }
    292                    Index = Data >> Shift;
   \                     ??LCD_DrawBitmap_19:
   \   00000318   14109DE5           LDR      R1,[SP, #+20]
   \   0000031C   FF0009E2           AND      R0,R9,#0xFF
   \   00000320   5001A0E1           ASR      R0,R0,R1
   \   00000324   FF0000E2           AND      R0,R0,#0xFF
    293                    Data    <<= BitsPerPixel;
   \   00000328   1994A0E1           LSL      R9,R9,R4
    294                    BitsLeft -= BitsPerPixel;
   \   0000032C   04A04AE0           SUB      R10,R10,R4
    295                    if (Index || ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) == 0)) {
   \   00000330   000050E3           CMP      R0,#+0
   \   00000334   0200001A           BNE      ??LCD_DrawBitmap_20
   \   00000338   1010D6E5           LDRB     R1,[R6, #+16]
   \   0000033C   020011E3           TST      R1,#0x2
   \   00000340   2500001A           BNE      ??LCD_DrawBitmap_21
    296                      LCD_PIXELINDEX  OldColor = LCD__GetColorIndex();
   \                     ??LCD_DrawBitmap_20:
   \   00000344   ........           LDR      R1,??DataTable17_1
    297                      if (pTrans) {
   \   00000348   000055E3           CMP      R5,#+0
   \   0000034C   001091E5           LDR      R1,[R1, #+0]
    298                        LCD__SetColorIndex(*(pTrans + Index));
   \   00000350   00019517           LDRNE    R0,[R5, +R0, LSL #+2]
   \   00000354   00B091E5           LDR      R11,[R1, #+0]
    299                      } else {
    300                        LCD__SetColorIndex(Index);
   \   00000358   000081E5           STR      R0,[R1, #+0]
    301                      }
    302                      LCD_FillRect(x, y, x + xMul - 1, yMax);
   \   0000035C   48009DE5           LDR      R0,[SP, #+72]
   \   00000360   0710A0E1           MOV      R1,R7
   \   00000364   000087E0           ADD      R0,R7,R0
   \   00000368   013040E2           SUB      R3,R0,#+1
   \   0000036C   F800D6E1           LDRSH    R0,[R6, #+8]
   \   00000370   0CC09DE5           LDR      R12,[SP, #+12]
   \   00000374   04209DE5           LDR      R2,[SP, #+4]
   \   00000378   000051E1           CMP      R1,R0
   \   0000037C   0010A0B1           MOVLT    R1,R0
   \   00000380   FC00D6E1           LDRSH    R0,[R6, #+12]
   \   00000384   030050E1           CMP      R0,R3
   \   00000388   0030A0B1           MOVLT    R3,R0
   \   0000038C   010053E1           CMP      R3,R1
   \   00000390   0E0000BA           BLT      ??LCD_DrawBitmap_22
   \   00000394   FA00D6E1           LDRSH    R0,[R6, #+10]
   \   00000398   000052E1           CMP      R2,R0
   \   0000039C   0020A0B1           MOVLT    R2,R0
   \   000003A0   FE00D6E1           LDRSH    R0,[R6, #+14]
   \   000003A4   0C0050E1           CMP      R0,R12
   \   000003A8   00C0A0B1           MOVLT    R12,R0
   \   000003AC   02005CE1           CMP      R12,R2
   \   000003B0   060000BA           BLT      ??LCD_DrawBitmap_22
   \   000003B4   1100D6E5           LDRB     R0,[R6, #+17]
   \   000003B8   000186E0           ADD      R0,R6,R0, LSL #+2
   \   000003BC   480090E5           LDR      R0,[R0, #+72]
   \   000003C0   00C08DE5           STR      R12,[SP, #+0]
   \   000003C4   0CC090E5           LDR      R12,[R0, #+12]
   \   000003C8   10C09CE5           LDR      R12,[R12, #+16]
   \   000003CC   3CFF2FE1           BLX      R12
    303                      LCD__SetColorIndex(OldColor);
   \                     ??LCD_DrawBitmap_22:
   \   000003D0   ........           LDR      R0,??DataTable17_1
   \   000003D4   000090E5           LDR      R0,[R0, #+0]
   \   000003D8   00B080E5           STR      R11,[R0, #+0]
    304                    }
    305                  }
   \                     ??LCD_DrawBitmap_21:
   \   000003DC   48009DE5           LDR      R0,[SP, #+72]
   \   000003E0   018058E2           SUBS     R8,R8,#+1
   \   000003E4   077080E0           ADD      R7,R0,R7
   \   000003E8   C4FFFF1A           BNE      ??LCD_DrawBitmap_18
    306                }
    307              }
   \                     ??LCD_DrawBitmap_16:
   \   000003EC   04009DE5           LDR      R0,[SP, #+4]
   \   000003F0   4C109DE5           LDR      R1,[SP, #+76]
   \   000003F4   000081E0           ADD      R0,R1,R0
   \   000003F8   04008DE5           STR      R0,[SP, #+4]
   \   000003FC   54009DE5           LDR      R0,[SP, #+84]
   \   00000400   58109DE5           LDR      R1,[SP, #+88]
   \   00000404   010080E0           ADD      R0,R0,R1
   \   00000408   58008DE5           STR      R0,[SP, #+88]
   \   0000040C   08009DE5           LDR      R0,[SP, #+8]
   \   00000410   010040E2           SUB      R0,R0,#+1
   \   00000414   08008DE5           STR      R0,[SP, #+8]
   \   00000418   000050E3           CMP      R0,#+0
   \   0000041C   A3FFFF1A           BNE      ??LCD_DrawBitmap_15
   \                     ??LCD_DrawBitmap_2:
   \   00000420   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   00000424   F08FBDE8           POP      {R4-R11,PC}      ;; return
    308            }
    309          }
    310          
    311          /*********************************************************************
    312          *
    313          *       LCD_SetClipRectMax
    314          */

   \                                 In section .text, align 4, keep-with-next
    315          void LCD_SetClipRectMax(void) {
    316            LCDDEV_L0_GetRect(GUI_Context.apDevice[GUI_Context.SelLayer], &GUI_Context.ClipRect);
   \                     LCD_SetClipRectMax:
   \   00000000   ........           LDR      R1,??DataTable17
   \   00000004   1100D1E5           LDRB     R0,[R1, #+17]
   \   00000008   000181E0           ADD      R0,R1,R0, LSL #+2
   \   0000000C   480090E5           LDR      R0,[R0, #+72]
   \   00000010   081081E2           ADD      R1,R1,#+8
   \   00000014   0C2090E5           LDR      R2,[R0, #+12]
   \   00000018   302092E5           LDR      R2,[R2, #+48]
   \   0000001C   12FF2FE1           BX       R2               ;; tailcall
    317          }
    318          
    319          /*********************************************************************
    320          *
    321          *       LCD_Init
    322          */

   \                                 In section .text, align 4, keep-with-next
    323          int LCD_Init(void) {
   \                     LCD_Init:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    324            GUI_DEVICE * pDevice;
    325            int  (* pfInit)(GUI_DEVICE * pDevice);
    326            void (* pfOn  )(GUI_DEVICE * pDevice);
    327            int r, i;
    328          
    329            GUI_DEBUG_LOG("\nLCD_Init...");
    330            LCD_SetClipRectMax();
   \   00000004   ........           LDR      R4,??DataTable17
   \   00000008   08D04DE2           SUB      SP,SP,#+8
   \   0000000C   1100D4E5           LDRB     R0,[R4, #+17]
   \   00000010   081084E2           ADD      R1,R4,#+8
   \   00000014   000184E0           ADD      R0,R4,R0, LSL #+2
   \   00000018   480090E5           LDR      R0,[R0, #+72]
   \   0000001C   0C2090E5           LDR      R2,[R0, #+12]
   \   00000020   302092E5           LDR      R2,[R2, #+48]
   \   00000024   32FF2FE1           BLX      R2
    331            r = 0;
   \   00000028   0050A0E3           MOV      R5,#+0
    332            for (i = 0; i < GUI_NUM_LAYERS; i++) {
   \   0000002C   0060A0E3           MOV      R6,#+0
    333              pDevice = GUI_DEVICE__GetpDriver(i);
   \                     ??LCD_Init_0:
   \   00000030   0600A0E1           MOV      R0,R6
   \   00000034   ........           BL       GUI_DEVICE__GetpDriver
   \   00000038   04008DE5           STR      R0,[SP, #+4]
    334              if (pDevice) {
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0A00000A           BEQ      ??LCD_Init_1
    335                pfInit = (int (*)(GUI_DEVICE *))pDevice->pDeviceAPI->pfGetDevFunc(&pDevice, LCD_DEVFUNC_INIT);
   \   00000044   04209DE5           LDR      R2,[SP, #+4]
   \   00000048   0C10A0E3           MOV      R1,#+12
   \   0000004C   0C2092E5           LDR      R2,[R2, #+12]
   \   00000050   04008DE2           ADD      R0,SP,#+4
   \   00000054   242092E5           LDR      R2,[R2, #+36]
   \   00000058   32FF2FE1           BLX      R2
   \   0000005C   0010B0E1           MOVS     R1,R0
    336                if (pfInit) {
   \   00000060   4200000A           BEQ      ??LCD_Init_2
    337                  r |= pfInit(pDevice);
   \   00000064   04009DE5           LDR      R0,[SP, #+4]
   \   00000068   31FF2FE1           BLX      R1
   \   0000006C   055080E1           ORR      R5,R0,R5
    338                } else {
   \                     ??LCD_Init_1:
   \   00000070   016086E2           ADD      R6,R6,#+1
   \   00000074   100056E3           CMP      R6,#+16
   \   00000078   ECFFFFBA           BLT      ??LCD_Init_0
    339                  return 1;
    340                }
    341              }
    342            }
    343            LCD_InitLUT();
   \   0000007C   ........           BL       LCD_InitLUT
    344            #if (GUI_DEFAULT_BKCOLOR != GUI_INVALID_COLOR)
    345              for (i = GUI_NUM_LAYERS - 1; i >= 0; i--) {
   \   00000080   0F60A0E3           MOV      R6,#+15
   \   00000084   FF8E86E3           ORR      R8,R6,#0xFF0
   \   00000088   ........           LDR      R7,??DataTable17_3
    346                pDevice = GUI_DEVICE__GetpDriver(i);
   \                     ??LCD_Init_3:
   \   0000008C   0600A0E1           MOV      R0,R6
   \   00000090   ........           BL       GUI_DEVICE__GetpDriver
   \   00000094   04008DE5           STR      R0,[SP, #+4]
    347                if (pDevice) {
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   2E00000A           BEQ      ??LCD_Init_4
    348                  //
    349                  // Clear video memory
    350                  //
    351                  GUI_SelectLayer(i);
   \   000000A0   0600A0E1           MOV      R0,R6
   \   000000A4   ........           BL       GUI_SelectLayer
    352                  LCD_SetDrawMode(GUI_DRAWMODE_REV);
   \   000000A8   001097E5           LDR      R1,[R7, #+0]
   \   000000AC   0400A0E3           MOV      R0,#+4
   \   000000B0   081091E5           LDR      R1,[R1, #+8]
   \   000000B4   31FF2FE1           BLX      R1
    353                  LCD_FillRect(0, 0, GUI_XMAX, GUI_YMAX);
   \   000000B8   F800D4E1           LDRSH    R0,[R4, #+8]
   \   000000BC   0010A0E3           MOV      R1,#+0
   \   000000C0   0830A0E1           MOV      R3,R8
   \   000000C4   010050E3           CMP      R0,#+1
   \   000000C8   0010A0A1           MOVGE    R1,R0
   \   000000CC   FC00D4E1           LDRSH    R0,[R4, #+12]
   \   000000D0   08C0A0E1           MOV      R12,R8
   \   000000D4   0020A0E3           MOV      R2,#+0
   \   000000D8   080050E1           CMP      R0,R8
   \   000000DC   0030A0B1           MOVLT    R3,R0
   \   000000E0   010053E1           CMP      R3,R1
   \   000000E4   0E0000BA           BLT      ??LCD_Init_5
   \   000000E8   FA00D4E1           LDRSH    R0,[R4, #+10]
   \   000000EC   010050E3           CMP      R0,#+1
   \   000000F0   0020A0A1           MOVGE    R2,R0
   \   000000F4   FE00D4E1           LDRSH    R0,[R4, #+14]
   \   000000F8   080050E1           CMP      R0,R8
   \   000000FC   00C0A0B1           MOVLT    R12,R0
   \   00000100   02005CE1           CMP      R12,R2
   \   00000104   060000BA           BLT      ??LCD_Init_5
   \   00000108   1100D4E5           LDRB     R0,[R4, #+17]
   \   0000010C   000184E0           ADD      R0,R4,R0, LSL #+2
   \   00000110   480090E5           LDR      R0,[R0, #+72]
   \   00000114   00C08DE5           STR      R12,[SP, #+0]
   \   00000118   0CC090E5           LDR      R12,[R0, #+12]
   \   0000011C   10C09CE5           LDR      R12,[R12, #+16]
   \   00000120   3CFF2FE1           BLX      R12
    354                  LCD_SetDrawMode(0);
   \                     ??LCD_Init_5:
   \   00000124   001097E5           LDR      R1,[R7, #+0]
   \   00000128   0000A0E3           MOV      R0,#+0
   \   0000012C   081091E5           LDR      R1,[R1, #+8]
   \   00000130   31FF2FE1           BLX      R1
    355                  //
    356                  // Switch on display
    357                  //
    358                  pfOn = (void (*)(GUI_DEVICE *))pDevice->pDeviceAPI->pfGetDevFunc(&pDevice, LCD_DEVFUNC_ON);
   \   00000134   04209DE5           LDR      R2,[SP, #+4]
   \   00000138   0E10A0E3           MOV      R1,#+14
   \   0000013C   0C2092E5           LDR      R2,[R2, #+12]
   \   00000140   04008DE2           ADD      R0,SP,#+4
   \   00000144   242092E5           LDR      R2,[R2, #+36]
   \   00000148   32FF2FE1           BLX      R2
   \   0000014C   0010B0E1           MOVS     R1,R0
    359                  if (pfOn) {
   \   00000150   0100000A           BEQ      ??LCD_Init_4
    360                    pfOn(pDevice);
   \   00000154   04009DE5           LDR      R0,[SP, #+4]
   \   00000158   31FF2FE1           BLX      R1
    361                  }
    362                }
    363              }
   \                     ??LCD_Init_4:
   \   0000015C   016056E2           SUBS     R6,R6,#+1
   \   00000160   C9FFFF5A           BPL      ??LCD_Init_3
    364            #endif
    365            return r;
   \   00000164   0500A0E1           MOV      R0,R5
   \                     ??LCD_Init_6:
   \   00000168   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   0000016C   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??LCD_Init_2:
   \   00000170   0100A0E3           MOV      R0,#+1
   \   00000174   FBFFFFEA           B        ??LCD_Init_6
    366          }
    367          
    368          /*********************************************************************
    369          *
    370          *       LCD_Color2Index
    371          */

   \                                 In section .text, align 4, keep-with-next
    372          unsigned LCD_Color2Index(LCD_COLOR Color) {
    373            return LCDDEV_L0_Color2Index(Color);
   \                     LCD_Color2Index:
   \   00000000   ........           LDR      R1,??DataTable17
   \   00000004   1120D1E5           LDRB     R2,[R1, #+17]
   \   00000008   021181E0           ADD      R1,R1,R2, LSL #+2
   \   0000000C   481091E5           LDR      R1,[R1, #+72]
   \   00000010   101091E5           LDR      R1,[R1, #+16]
   \   00000014   001091E5           LDR      R1,[R1, #+0]
   \   00000018   11FF2FE1           BX       R1               ;; tailcall
    374          }
    375          
    376          /*********************************************************************
    377          *
    378          *       LCD_Index2Color
    379          */

   \                                 In section .text, align 4, keep-with-next
    380          LCD_COLOR LCD_Index2Color(int Index) {
    381            return LCDDEV_L0_Index2Color(Index);
   \                     LCD_Index2Color:
   \   00000000   ........           LDR      R1,??DataTable17
   \   00000004   1120D1E5           LDRB     R2,[R1, #+17]
   \   00000008   021181E0           ADD      R1,R1,R2, LSL #+2
   \   0000000C   481091E5           LDR      R1,[R1, #+72]
   \   00000010   101091E5           LDR      R1,[R1, #+16]
   \   00000014   041091E5           LDR      R1,[R1, #+4]
   \   00000018   11FF2FE1           BX       R1               ;; tailcall
    382          }
    383          
    384          /*********************************************************************
    385          *
    386          *       LCD_SetColorIndex
    387          */

   \                                 In section .text, align 4, keep-with-next
    388          void LCD_SetColorIndex(unsigned PixelIndex) {
    389            if (GUI_Context.DrawMode & LCD_DRAWMODE_REV) {
   \                     LCD_SetColorIndex:
   \   00000000   ........           LDR      R1,??DataTable17
   \   00000004   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000008   040011E3           TST      R1,#0x4
    390              LCD__SetBkColorIndex(PixelIndex);
   \   0000000C   ........           LDRNE    R1,??DataTable17_2
    391            } else {
    392              LCD__SetColorIndex(PixelIndex);
   \   00000010   ........           LDREQ    R1,??DataTable17_1
   \   00000014   001091E5           LDR      R1,[R1, #+0]
   \   00000018   000081E5           STR      R0,[R1, #+0]
    393            }
    394          }
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    395          
    396          /*********************************************************************
    397          *
    398          *       LCD_SetBkColorIndex
    399          */

   \                                 In section .text, align 4, keep-with-next
    400          void LCD_SetBkColorIndex(unsigned PixelIndex) {
    401            if (GUI_Context.DrawMode & LCD_DRAWMODE_REV) {
   \                     LCD_SetBkColorIndex:
   \   00000000   ........           LDR      R1,??DataTable17
   \   00000004   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000008   040011E3           TST      R1,#0x4
    402              LCD__SetColorIndex(PixelIndex);
   \   0000000C   ........           LDRNE    R1,??DataTable17_1
    403            } else {
    404              LCD__SetBkColorIndex(PixelIndex);
   \   00000010   ........           LDREQ    R1,??DataTable17_2
   \   00000014   001091E5           LDR      R1,[R1, #+0]
   \   00000018   000081E5           STR      R0,[R1, #+0]
    405            }
    406          }
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    407          
    408          /*********************************************************************
    409          *
    410          *       LCD_SetBkColor
    411          */

   \                                 In section .text, align 4, keep-with-next
    412          void LCD_SetBkColor(GUI_COLOR color) {
    413            LCD__pSetColorAPI->pfSetBkColor(color);
   \                     LCD_SetBkColor:
   \   00000000   ........           LDR      R1,??DataTable17_3
   \   00000004   001091E5           LDR      R1,[R1, #+0]
   \   00000008   041091E5           LDR      R1,[R1, #+4]
   \   0000000C   11FF2FE1           BX       R1               ;; tailcall
    414          }
    415          
    416          /*********************************************************************
    417          *
    418          *       LCD_SetColor
    419          */

   \                                 In section .text, align 4, keep-with-next
    420          void LCD_SetColor(GUI_COLOR color) {
    421            LCD__pSetColorAPI->pfSetColor(color);
   \                     LCD_SetColor:
   \   00000000   ........           LDR      R1,??DataTable17_3
   \   00000004   001091E5           LDR      R1,[R1, #+0]
   \   00000008   001091E5           LDR      R1,[R1, #+0]
   \   0000000C   11FF2FE1           BX       R1               ;; tailcall
    422          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   ........           DC32     LCD_pBkColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   ........           DC32     LCD__pSetColorAPI

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   ........           DC32     GUI_pLCD_APIList
    423          
    424          
    425          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function            .cstack
     --------            -------
     LCD_Color2Index          8
     LCD_DrawBitmap          72
     LCD_DrawHLine            8
     LCD_DrawPixel            8
     LCD_DrawVLine            8
     LCD_FillRect             8
     LCD_Index2Color          8
     LCD_Init                32
     LCD_SetBkColor           8
     LCD_SetBkColorIndex      0
     LCD_SetClipRectMax       8
     LCD_SetColor             8
     LCD_SetColorIndex        0
     LCD_SetDrawMode          8
     _SetBkColor              8
     _SetColor                8
     _SetDrawMode             8


   Section sizes:

     Function/Label      Bytes
     --------------      -----
     _SetBkColor           76
     _SetColor             76
     _SetDrawMode          72
     _SetColorAPI          12
     LCD__pSetColorAPI      4
     LCD_SetDrawMode       16
     LCD_DrawPixel        144
     LCD_DrawHLine        116
     LCD_DrawVLine        116
     LCD_FillRect         128
     LCD_DrawBitmap      1064
     LCD_SetClipRectMax    32
     LCD_Init             376
     LCD_Color2Index       28
     LCD_Index2Color       28
     LCD_SetColorIndex     32
     LCD_SetBkColorIndex   32
     LCD_SetBkColor        16
     LCD_SetColor          16
     ??DataTable17          4
     ??DataTable17_1        4
     ??DataTable17_2        4
     ??DataTable17_3        4
     ??DataTable17_4        4

 
     4 bytes in section .data
    12 bytes in section .rodata
 2 388 bytes in section .text
 
 2 388 bytes of CODE  memory
    12 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
