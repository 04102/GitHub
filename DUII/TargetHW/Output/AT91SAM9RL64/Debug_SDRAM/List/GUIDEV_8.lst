###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     14/Jul/2015  18:59:21 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDEV_8.c                          #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDEV_8.c -D DEBUG=1 -D            #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D                   #
#                    XIGNORE_TEMPERATURE -D BUILD_DEBUG_PORT -D PROFILER      #
#                    -lCN C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Li #
#                    st\ -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\ #
#                    Obj\ --debug --endian=little --cpu=ARM926EJ-S -e         #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\GU #
#                    IDEV_8.lst                                               #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\GUI #
#                    DEV_8.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDEV_8.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDEV_8.c
     19          Purpose     : Implementation of memory devices
     20                        This file handles 8 bit memory devices, but also 16 bit
     21                        memory devices when included by GUIDEV_16.c
     22          ---------------------------END-OF-HEADER------------------------------
     23          */
     24          
     25          
     26          #include <string.h>
     27          
     28          #include "GUI_Private.h"
     29          
     30          #if GUI_WINSUPPORT
     31            #include "WM.h"
     32          #endif
     33          
     34          /* Memory device capabilities are compiled only if support for them is enabled.*/ 
     35          #if GUI_SUPPORT_MEMDEV
     36          
     37          /*********************************************************************
     38          *
     39          *       Macros
     40          *
     41          **********************************************************************
     42          */
     43          
     44          #ifndef PIXELINDEX
     45            #define PIXELINDEX                      U8
     46            #define BITSPERPIXEL                     8
     47            #define API_LIST      GUI_MEMDEV__APIList8
     48            #define DEVICE_API     GUI_MEMDEV_DEVICE_8
     49          #endif
     50          
     51          
     52          /*********************************************************************
     53          *
     54          *       static consts
     55          *
     56          **********************************************************************
     57          */
     58          /*********************************************************************
     59          *
     60          *       ID translation table
     61          *
     62          * This table serves as translation table for DDBs
     63          */

   \                                 In section .text, align 4, keep-with-next
     64          static const LCD_PIXELINDEX aID[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
   \                     aID:
   \   00000000                      ; Initializer data, 64 bytes
   \   00000000   000000000100       DC32 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
   \              000002000000
   \              030000000400
   \              000005000000
   \              060000000700
   \              000008000000
   \              09000000    
   \   00000028   0A0000000B00       DC32 10, 11, 12, 13, 14, 15
   \              00000C000000
   \              0D0000000E00
   \              00000F000000
     65          
     66          /*********************************************************************
     67          *
     68          *       static code
     69          *
     70          **********************************************************************
     71          */
     72          /*********************************************************************
     73          *
     74          *       _XY2PTR
     75          */
     76          static PIXELINDEX* _XY2PTR(int x, int y) {
     77            GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
     78            U8 *pData = (U8*)(pDev + 1);
     79            #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
     80              if ((x >= pDev->x0+pDev->XSize) | (x<pDev->x0) | (y >= pDev->y0+pDev->YSize) | (y<pDev->y0)) {
     81                GUI_DEBUG_ERROROUT2("_XY2PTR: parameters out of bounds",x,y);
     82              }
     83            #endif
     84            pData += (GUI_ALLOC_DATATYPE_U)(y - pDev->y0) * (GUI_ALLOC_DATATYPE_U)pDev->BytesPerLine;
     85            return ((PIXELINDEX*)pData) + x - pDev->x0;
     86          }
     87          
     88          /*********************************************************************
     89          *
     90          *       _DrawBitLine1BPP
     91          */

   \                                 In section .text, align 4, keep-with-next
     92          static void _DrawBitLine1BPP(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * p, int Diff, unsigned int xsize,
     93                                       const LCD_PIXELINDEX* pTrans, GUI_MEMDEV* pDev, PIXELINDEX* pDest)
     94          {
   \                     _DrawBitLine1BPP:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   28609DE5           LDR      R6,[SP, #+40]
     95            PIXELINDEX Index1;
     96            PIXELINDEX IndexMask;
     97            unsigned pixels;
     98            unsigned PixelCnt;
     99          
    100            GUI_USE_PARA(pDev);
    101            PixelCnt = 8 - Diff;
   \   00000008   ........           LDR      R12,??DataTable11
   \   0000000C   0030D6E5           LDRB     R3,[R6, #+0]
   \   00000010   0140A0E1           MOV      R4,R1
   \   00000014   2C109DE5           LDR      R1,[SP, #+44]
   \   00000018   0C30D3E7           LDRB     R3,[R3, +R12]
   \   0000001C   089061E2           RSB      R9,R1,#+8
   \   00000020   0250A0E1           MOV      R5,R2
   \   00000024   53A1A0E1           ASR      R10,R3,R1
    102            pixels = LCD_aMirror[*p] >> Diff;
    103          
    104            GUI_DEBUG_ERROROUT3_IF( x < pDev->x0, "GUIDEV.c: DrawBitLine1BPP, Act= %d, Border= %d, Clip= %d", x,pDev->x0, GUI_Context.ClipRect.x0);
    105          
    106            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000028   ........           LDR      R1,??DataTable11_1
   \   0000002C   30709DE5           LDR      R7,[SP, #+48]
   \   00000030   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000034   34209DE5           LDR      R2,[SP, #+52]
   \   00000038   3C809DE5           LDR      R8,[SP, #+60]
   \   0000003C   031001E2           AND      R1,R1,#0x3
   \   00000040   030051E3           CMP      R1,#+3
   \   00000044   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitLine1BPP_0:
   \   00000048   5200008A           BHI      ??_DrawBitLine1BPP_1
   \   0000004C   020000EA           B        ??_DrawBitLine1BPP_2
   \   00000050   3B0000EA           B        ??_DrawBitLine1BPP_3
   \   00000054   0F0000EA           B        ??_DrawBitLine1BPP_4
   \   00000058   390000EA           B        ??_DrawBitLine1BPP_3
    107            case 0:    /* Write mode */
    108              do {
    109                /* Prepare loop */
    110                if (PixelCnt > xsize) {
   \                     ??_DrawBitLine1BPP_2:
   \   0000005C   090057E1           CMP      R7,R9
   \   00000060   0790A091           MOVLS    R9,R7
    111                  PixelCnt = xsize;
    112                }
    113                xsize -= PixelCnt;
   \   00000064   097047E0           SUB      R7,R7,R9
    114                /* Write as many pixels as we are allowed to and have loaded in this inner loop */
    115                do {
    116                  *pDest++ = *(pTrans + (pixels & 1));
   \                     ??_DrawBitLine1BPP_5:
   \   00000068   01000AE2           AND      R0,R10,#0x1
   \   0000006C   000192E7           LDR      R0,[R2, +R0, LSL #+2]
    117                  pixels >>= 1;
   \   00000070   AAA0A0E1           LSR      R10,R10,#+1
   \   00000074   0100C8E4           STRB     R0,[R8], #+1
    118                } while (--PixelCnt);
   \   00000078   019059E2           SUBS     R9,R9,#+1
   \   0000007C   F9FFFF1A           BNE      ??_DrawBitLine1BPP_5
    119                /* Check if an other Source byte needs to be loaded */
    120                if (xsize == 0) {
   \   00000080   000057E3           CMP      R7,#+0
   \   00000084   4300000A           BEQ      ??_DrawBitLine1BPP_1
    121                  return;
    122                }
    123                PixelCnt = 8;
    124                pixels = LCD_aMirror[*++p];
   \   00000088   0100F6E5           LDRB     R0,[R6, #+1]!
   \   0000008C   0890A0E3           MOV      R9,#+8
   \   00000090   0CA0D0E7           LDRB     R10,[R0, +R12]
    125              } while (1);
   \   00000094   F0FFFFEA           B        ??_DrawBitLine1BPP_2
    126            case LCD_DRAWMODE_TRANS:
    127              Index1 = *(pTrans + 1);
   \                     ??_DrawBitLine1BPP_4:
   \   00000098   04B092E5           LDR      R11,[R2, #+4]
   \   0000009C   0A0000EA           B        ??_DrawBitLine1BPP_6
    128              do {
    129                /* Prepare loop */
    130                if (PixelCnt > xsize) {
    131                  PixelCnt = xsize;
    132                }
    133                xsize -= PixelCnt;
    134                if (pUsage) {
    135                  do {
    136                    if (pixels == 0) {      /* Early out optimization; not required */
    137                      pDest += PixelCnt;
    138                      x     += PixelCnt;
    139                      break;
    140                    }
    141                    if ((pixels & 1)) {
    142                      GUI_USAGE_AddPixel(pUsage, x, y);
    143                      *pDest = Index1;
    144                    }
    145                    x++;
    146                    pDest++;
    147                    if (--PixelCnt == 0) {
    148                      break;
    149                    }
    150                    pixels >>= 1;
    151                  } while (1);
    152                } else {
    153                  do {
    154                    if (pixels == 0) {      /* Early out optimization; not required */
    155                      pDest += PixelCnt;
    156                      break;
    157                    }
    158                    if ((pixels & 1)) {
   \                     ??_DrawBitLine1BPP_7:
   \   000000A0   01001AE3           TST      R10,#0x1
    159                      *pDest = Index1;
   \   000000A4   00B0C815           STRBNE   R11,[R8, #+0]
    160                    }
    161                    pDest++;
   \   000000A8   018088E2           ADD      R8,R8,#+1
    162                    if (--PixelCnt == 0) {
   \   000000AC   019059E2           SUBS     R9,R9,#+1
   \   000000B0   1E00001A           BNE      ??_DrawBitLine1BPP_8
    163                      break;
    164                    }
    165                    pixels >>= 1;
    166                  } while (1);
    167                }
    168                /* Check if an other Source byte needs to be loaded */
    169                if (xsize == 0) {
   \                     ??_DrawBitLine1BPP_9:
   \   000000B4   000057E3           CMP      R7,#+0
   \   000000B8   3600000A           BEQ      ??_DrawBitLine1BPP_1
    170                  return;
    171                }
    172                PixelCnt = 8;
    173                pixels = LCD_aMirror[*(++p)];
   \   000000BC   0100F6E5           LDRB     R0,[R6, #+1]!
   \   000000C0   ........           LDR      R1,??DataTable11
   \   000000C4   0890A0E3           MOV      R9,#+8
   \   000000C8   01A0D0E7           LDRB     R10,[R0, +R1]
    174              } while (1);
   \                     ??_DrawBitLine1BPP_6:
   \   000000CC   090057E1           CMP      R7,R9
   \   000000D0   0790A091           MOVLS    R9,R7
   \   000000D4   097047E0           SUB      R7,R7,R9
   \   000000D8   000054E3           CMP      R4,#+0
   \   000000DC   1400000A           BEQ      ??_DrawBitLine1BPP_10
   \   000000E0   0D0000EA           B        ??_DrawBitLine1BPP_11
   \                     ??_DrawBitLine1BPP_12:
   \   000000E4   01001AE3           TST      R10,#0x1
   \   000000E8   0600000A           BEQ      ??_DrawBitLine1BPP_13
   \   000000EC   083094E5           LDR      R3,[R4, #+8]
   \   000000F0   00209DE5           LDR      R2,[SP, #+0]
   \   000000F4   0510A0E1           MOV      R1,R5
   \   000000F8   0400A0E1           MOV      R0,R4
   \   000000FC   003093E5           LDR      R3,[R3, #+0]
   \   00000100   33FF2FE1           BLX      R3
   \   00000104   00B0C8E5           STRB     R11,[R8, #+0]
   \                     ??_DrawBitLine1BPP_13:
   \   00000108   015085E2           ADD      R5,R5,#+1
   \   0000010C   018088E2           ADD      R8,R8,#+1
   \   00000110   019059E2           SUBS     R9,R9,#+1
   \   00000114   E6FFFF0A           BEQ      ??_DrawBitLine1BPP_9
   \   00000118   AAA0A0E1           LSR      R10,R10,#+1
   \                     ??_DrawBitLine1BPP_11:
   \   0000011C   00005AE3           CMP      R10,#+0
   \   00000120   EFFFFF1A           BNE      ??_DrawBitLine1BPP_12
   \   00000124   088089E0           ADD      R8,R9,R8
   \   00000128   055089E0           ADD      R5,R9,R5
   \   0000012C   E0FFFFEA           B        ??_DrawBitLine1BPP_9
   \                     ??_DrawBitLine1BPP_8:
   \   00000130   AAA0A0E1           LSR      R10,R10,#+1
   \                     ??_DrawBitLine1BPP_10:
   \   00000134   00005AE3           CMP      R10,#+0
   \   00000138   D8FFFF1A           BNE      ??_DrawBitLine1BPP_7
   \   0000013C   088089E0           ADD      R8,R9,R8
   \   00000140   DBFFFFEA           B        ??_DrawBitLine1BPP_9
    175            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    176            case LCD_DRAWMODE_XOR:
    177              IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \                     ??_DrawBitLine1BPP_3:
   \   00000144   100090E5           LDR      R0,[R0, #+16]
   \   00000148   080090E5           LDR      R0,[R0, #+8]
   \   0000014C   30FF2FE1           BLX      R0
   \   00000150   030000EA           B        ??_DrawBitLine1BPP_14
    178              do {
    179                /* Prepare loop */
    180                if (PixelCnt > xsize) {
    181                  PixelCnt = xsize;
    182                }
    183                xsize -= PixelCnt;
    184                /* Write as many pixels as we are allowed to and have loaded in this inner loop */
    185                do {
    186                  if ((pixels & 1)) {
    187                    *pDest ^= IndexMask;
    188                  }
    189                  pDest++;
    190                  pixels >>= 1;
    191                } while (--PixelCnt);
    192                /* Check if an other Source byte needs to be loaded */
    193                if (xsize == 0) {
    194                  return;
    195                }
    196                PixelCnt = 8;
    197                pixels = LCD_aMirror[*(++p)];
   \                     ??_DrawBitLine1BPP_15:
   \   00000154   0110F6E5           LDRB     R1,[R6, #+1]!
   \   00000158   ........           LDR      R2,??DataTable11
   \   0000015C   0890A0E3           MOV      R9,#+8
   \   00000160   02A0D1E7           LDRB     R10,[R1, +R2]
    198              } while (1);
   \                     ??_DrawBitLine1BPP_14:
   \   00000164   090057E1           CMP      R7,R9
   \   00000168   0790A091           MOVLS    R9,R7
   \   0000016C   097047E0           SUB      R7,R7,R9
   \                     ??_DrawBitLine1BPP_16:
   \   00000170   01001AE3           TST      R10,#0x1
   \   00000174   0010D815           LDRBNE   R1,[R8, #+0]
   \   00000178   AAA0A0E1           LSR      R10,R10,#+1
   \   0000017C   01102010           EORNE    R1,R0,R1
   \   00000180   0010C815           STRBNE   R1,[R8, #+0]
   \   00000184   018088E2           ADD      R8,R8,#+1
   \   00000188   019059E2           SUBS     R9,R9,#+1
   \   0000018C   F7FFFF1A           BNE      ??_DrawBitLine1BPP_16
   \   00000190   000057E3           CMP      R7,#+0
   \   00000194   EEFFFF1A           BNE      ??_DrawBitLine1BPP_15
   \                     ??_DrawBitLine1BPP_1:
   \   00000198   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000019C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    199            }
    200          }
    201          
    202          /*********************************************************************
    203          *
    204          *       _DrawBitLine2BPP
    205          */

   \                                 In section .text, align 4, keep-with-next
    206          static void _DrawBitLine2BPP(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * p, int Diff, int xsize,
    207                                       const LCD_PIXELINDEX* pTrans, PIXELINDEX* pDest)
    208          {
   \                     _DrawBitLine2BPP:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   28609DE5           LDR      R6,[SP, #+40]
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   2C009DE5           LDR      R0,[SP, #+44]
    209            U8 pixels;
    210            U8  PixelCnt;
    211          
    212            GUI_USE_PARA(pDevice);
    213            PixelCnt = 4 - Diff;
    214            pixels = (*p) << (Diff << 1);
   \   00000010   0010D6E5           LDRB     R1,[R6, #+0]
   \   00000014   04A060E2           RSB      R10,R0,#+4
   \   00000018   8000A0E1           LSL      R0,R0,#+1
   \   0000001C   11B0A0E1           LSL      R11,R1,R0
    215            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000020   ........           LDR      R0,??DataTable11_1
   \   00000024   0250A0E1           MOV      R5,R2
   \   00000028   1000D0E5           LDRB     R0,[R0, #+16]
   \   0000002C   30709DE5           LDR      R7,[SP, #+48]
   \   00000030   34809DE5           LDR      R8,[SP, #+52]
   \   00000034   38909DE5           LDR      R9,[SP, #+56]
   \   00000038   030010E2           ANDS     R0,R0,#0x3
   \   0000003C   0300000A           BEQ      ??_DrawBitLine2BPP_0
   \   00000040   020050E3           CMP      R0,#+2
   \   00000044   1300000A           BEQ      ??_DrawBitLine2BPP_1
   \   00000048   3200003A           BCC      ??_DrawBitLine2BPP_2
   \   0000004C   410000EA           B        ??_DrawBitLine2BPP_3
    216            case 0:    /* Write mode */
    217            PixelLoopWrite:
    218              if (PixelCnt > xsize) {
   \                     ??_DrawBitLine2BPP_0:
   \   00000050   0A0CA0E1           MOV      R0,R10, LSL #+24
   \   00000054   200C57E1           CMP      R7,R0, LSR #+24
    219                PixelCnt = xsize;
   \   00000058   07A0A0B1           MOVLT    R10,R7
    220              }
    221              xsize -= PixelCnt;
   \   0000005C   FF000AE2           AND      R0,R10,#0xFF
   \   00000060   007047E0           SUB      R7,R7,R0
    222              do {
    223                *pDest++ = *(pTrans + (pixels >> 6));
   \                     ??_DrawBitLine2BPP_4:
   \   00000064   FF000BE2           AND      R0,R11,#0xFF
   \   00000068   4003A0E1           ASR      R0,R0,#+6
   \   0000006C   000198E7           LDR      R0,[R8, +R0, LSL #+2]
    224                pixels <<= 2;
    225              } while (--PixelCnt);
   \   00000070   01A04AE2           SUB      R10,R10,#+1
   \   00000074   0100C9E4           STRB     R0,[R9], #+1
   \   00000078   0BB1A0E1           LSL      R11,R11,#+2
   \   0000007C   FFA01AE2           ANDS     R10,R10,#0xFF
   \   00000080   F7FFFF1A           BNE      ??_DrawBitLine2BPP_4
    226              if (xsize) {
   \   00000084   000057E3           CMP      R7,#+0
   \   00000088   3200000A           BEQ      ??_DrawBitLine2BPP_3
    227                PixelCnt = 4;
   \   0000008C   04A0A0E3           MOV      R10,#+4
    228                pixels = *(++p);
   \   00000090   01B0F6E5           LDRB     R11,[R6, #+1]!
    229                goto PixelLoopWrite;
   \   00000094   EDFFFFEA           B        ??_DrawBitLine2BPP_0
    230              }
    231              break;
    232            case LCD_DRAWMODE_TRANS:
    233            PixelLoopTrans:
    234              if (PixelCnt > xsize)
   \                     ??_DrawBitLine2BPP_1:
   \   00000098   0A0CA0E1           MOV      R0,R10, LSL #+24
   \   0000009C   200C57E1           CMP      R7,R0, LSR #+24
    235                PixelCnt = xsize;
   \   000000A0   07A0A0B1           MOVLT    R10,R7
    236              xsize -= PixelCnt;
   \   000000A4   FF000AE2           AND      R0,R10,#0xFF
   \   000000A8   007047E0           SUB      R7,R7,R0
    237              do {
    238                if (pixels & 0xc0) {
   \                     ??_DrawBitLine2BPP_5:
   \   000000AC   C0001BE3           TST      R11,#0xC0
   \   000000B0   0B00000A           BEQ      ??_DrawBitLine2BPP_6
    239                  *pDest = *(pTrans + (pixels >> 6));
   \   000000B4   FF000BE2           AND      R0,R11,#0xFF
   \   000000B8   4003A0E1           ASR      R0,R0,#+6
   \   000000BC   000198E7           LDR      R0,[R8, +R0, LSL #+2]
    240                  if (pUsage) {
   \   000000C0   000054E3           CMP      R4,#+0
   \   000000C4   0000C9E5           STRB     R0,[R9, #+0]
   \   000000C8   0500000A           BEQ      ??_DrawBitLine2BPP_6
    241                    GUI_USAGE_AddPixel(pUsage, x, y);
   \   000000CC   083094E5           LDR      R3,[R4, #+8]
   \   000000D0   00209DE5           LDR      R2,[SP, #+0]
   \   000000D4   0510A0E1           MOV      R1,R5
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   003093E5           LDR      R3,[R3, #+0]
   \   000000E0   33FF2FE1           BLX      R3
    242                  }
    243                }
    244                pDest++;
    245                x++;
    246                pixels <<= 2;
    247              } while (--PixelCnt);
   \                     ??_DrawBitLine2BPP_6:
   \   000000E4   01A04AE2           SUB      R10,R10,#+1
   \   000000E8   019089E2           ADD      R9,R9,#+1
   \   000000EC   015085E2           ADD      R5,R5,#+1
   \   000000F0   0BB1A0E1           LSL      R11,R11,#+2
   \   000000F4   FFA01AE2           ANDS     R10,R10,#0xFF
   \   000000F8   EBFFFF1A           BNE      ??_DrawBitLine2BPP_5
    248              if (xsize) {
   \   000000FC   000057E3           CMP      R7,#+0
   \   00000100   1400000A           BEQ      ??_DrawBitLine2BPP_3
    249                PixelCnt = 4;
   \   00000104   04A0A0E3           MOV      R10,#+4
    250                pixels = *(++p);
   \   00000108   01B0F6E5           LDRB     R11,[R6, #+1]!
    251                goto PixelLoopTrans;
   \   0000010C   E1FFFFEA           B        ??_DrawBitLine2BPP_1
    252              }
    253              break;
    254            case LCD_DRAWMODE_XOR:;
    255            PixelLoopXor:
    256              if (PixelCnt > xsize)
    257                PixelCnt = xsize;
    258              xsize -= PixelCnt;
    259              do {
    260                if ((pixels & 0xc0))
    261                  *pDest ^= 255;
    262                pDest++;
    263                pixels <<= 2;
    264              } while (--PixelCnt);
    265              if (xsize) {
    266                PixelCnt = 4;
   \                     ??_DrawBitLine2BPP_7:
   \   00000110   04A0A0E3           MOV      R10,#+4
    267                pixels = *(++p);
   \   00000114   01B0F6E5           LDRB     R11,[R6, #+1]!
    268                goto PixelLoopXor;
    269              }
   \                     ??_DrawBitLine2BPP_2:
   \   00000118   0A0CA0E1           MOV      R0,R10, LSL #+24
   \   0000011C   200C57E1           CMP      R7,R0, LSR #+24
   \   00000120   07A0A0B1           MOVLT    R10,R7
   \   00000124   FF000AE2           AND      R0,R10,#0xFF
   \   00000128   007047E0           SUB      R7,R7,R0
   \                     ??_DrawBitLine2BPP_8:
   \   0000012C   C0001BE3           TST      R11,#0xC0
   \   00000130   0000D915           LDRBNE   R0,[R9, #+0]
   \   00000134   01A04AE2           SUB      R10,R10,#+1
   \   00000138   0BB1A0E1           LSL      R11,R11,#+2
   \   0000013C   FF002012           EORNE    R0,R0,#0xFF
   \   00000140   0000C915           STRBNE   R0,[R9, #+0]
   \   00000144   019089E2           ADD      R9,R9,#+1
   \   00000148   FFA01AE2           ANDS     R10,R10,#0xFF
   \   0000014C   F6FFFF1A           BNE      ??_DrawBitLine2BPP_8
   \   00000150   000057E3           CMP      R7,#+0
   \   00000154   EDFFFF1A           BNE      ??_DrawBitLine2BPP_7
    270              break;
    271            }
    272          }
   \                     ??_DrawBitLine2BPP_3:
   \   00000158   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000015C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    273          
    274          /*********************************************************************
    275          *
    276          *       _DrawBitLine4BPP
    277          */

   \                                 In section .text, align 4, keep-with-next
    278          static void _DrawBitLine4BPP(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * p, int Diff, int xsize,
    279                                       const LCD_PIXELINDEX* pTrans, PIXELINDEX* pDest)
    280          {
   \                     _DrawBitLine4BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   28509DE5           LDR      R5,[SP, #+40]
   \   0000000C   02A0A0E1           MOV      R10,R2
   \   00000010   2C009DE5           LDR      R0,[SP, #+44]
    281            U8 pixels;
    282            U8 PixelCnt;
    283          
    284            GUI_USE_PARA(pDevice);
    285            PixelCnt = 2 - Diff;
    286            pixels = (*p) << (Diff << 2);
   \   00000014   0020D5E5           LDRB     R2,[R5, #+0]
   \   00000018   03B0A0E1           MOV      R11,R3
   \   0000001C   0031A0E1           LSL      R3,R0,#+2
   \   00000020   1243A0E1           LSL      R4,R2,R3
    287            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000024   ........           LDR      R2,??DataTable11_1
   \   00000028   0190A0E1           MOV      R9,R1
   \   0000002C   1020D2E5           LDRB     R2,[R2, #+16]
   \   00000030   0010A0E1           MOV      R1,R0
   \   00000034   30609DE5           LDR      R6,[SP, #+48]
   \   00000038   34709DE5           LDR      R7,[SP, #+52]
   \   0000003C   38809DE5           LDR      R8,[SP, #+56]
   \   00000040   021061E2           RSB      R1,R1,#+2
   \   00000044   032012E2           ANDS     R2,R2,#0x3
   \   00000048   0300000A           BEQ      ??_DrawBitLine4BPP_0
   \   0000004C   020052E3           CMP      R2,#+2
   \   00000050   1E00000A           BEQ      ??_DrawBitLine4BPP_1
   \   00000054   6400003A           BCC      ??_DrawBitLine4BPP_2
   \   00000058   730000EA           B        ??_DrawBitLine4BPP_3
    288          /*
    289                    * Write mode *
    290          */
    291            case 0:
    292              /* Draw incomplete bytes to the left of center area */
    293              if (Diff) {
   \                     ??_DrawBitLine4BPP_0:
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   0500000A           BEQ      ??_DrawBitLine4BPP_4
    294                *pDest = *(pTrans + (pixels >> 4));
   \   00000064   FF4004E2           AND      R4,R4,#0xFF
   \   00000068   4402A0E1           ASR      R0,R4,#+4
   \   0000006C   000197E7           LDR      R0,[R7, +R0, LSL #+2]
    295                pDest++;
    296                xsize--;
   \   00000070   016046E2           SUB      R6,R6,#+1
   \   00000074   0100C8E4           STRB     R0,[R8], #+1
    297                pixels = *++p;
   \   00000078   0140F5E5           LDRB     R4,[R5, #+1]!
    298              }
    299              /* Draw center area (2 pixels in one byte) */
    300              if (xsize >= 2) {
   \                     ??_DrawBitLine4BPP_4:
   \   0000007C   020056E3           CMP      R6,#+2
   \   00000080   0B0000BA           BLT      ??_DrawBitLine4BPP_5
    301                int i = xsize >> 1;
   \   00000084   C600A0E1           ASR      R0,R6,#+1
    302                xsize &= 1;
   \   00000088   016006E2           AND      R6,R6,#0x1
    303                do {
    304                  *pDest     = *(pTrans + (pixels >> 4));   /* Draw 1. (left) pixel */
   \                     ??_DrawBitLine4BPP_6:
   \   0000008C   FF4004E2           AND      R4,R4,#0xFF
   \   00000090   4412A0E1           ASR      R1,R4,#+4
   \   00000094   011197E7           LDR      R1,[R7, +R1, LSL #+2]
    305                  *(pDest+1) = *(pTrans + (pixels & 15));   /* Draw 2. (right) pixel */
    306                  pDest += 2;
    307                  pixels = *++p;
    308                } while (--i);
   \   00000098   010050E2           SUBS     R0,R0,#+1
   \   0000009C   0110C8E4           STRB     R1,[R8], #+1
   \   000000A0   0F1004E2           AND      R1,R4,#0xF
   \   000000A4   011197E7           LDR      R1,[R7, +R1, LSL #+2]
   \   000000A8   0110C8E4           STRB     R1,[R8], #+1
   \   000000AC   0140F5E5           LDRB     R4,[R5, #+1]!
   \   000000B0   F5FFFF1A           BNE      ??_DrawBitLine4BPP_6
    309              }
    310              /* Draw incomplete bytes to the right of center area */
    311              if (xsize) {
   \                     ??_DrawBitLine4BPP_5:
   \   000000B4   000056E3           CMP      R6,#+0
   \   000000B8   5B00000A           BEQ      ??_DrawBitLine4BPP_3
    312                *pDest = * (pTrans + (pixels >> 4));
   \   000000BC   FF4004E2           AND      R4,R4,#0xFF
   \   000000C0   4402A0E1           ASR      R0,R4,#+4
   \   000000C4   000197E7           LDR      R0,[R7, +R0, LSL #+2]
   \   000000C8   0000C8E5           STRB     R0,[R8, #+0]
   \   000000CC   560000EA           B        ??_DrawBitLine4BPP_3
    313              }
    314              break;
    315          /*
    316                    * Transparent draw mode *
    317          */
    318            case LCD_DRAWMODE_TRANS:
    319              /* Draw incomplete bytes to the left of center area */
    320              if (Diff) {
   \                     ??_DrawBitLine4BPP_1:
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   1100000A           BEQ      ??_DrawBitLine4BPP_7
    321                if (pixels & 0xF0) {
   \   000000D8   F00014E3           TST      R4,#0xF0
   \   000000DC   0B00000A           BEQ      ??_DrawBitLine4BPP_8
    322                  *pDest = *(pTrans + (pixels >> 4));
   \   000000E0   FF4004E2           AND      R4,R4,#0xFF
   \   000000E4   4402A0E1           ASR      R0,R4,#+4
   \   000000E8   000197E7           LDR      R0,[R7, +R0, LSL #+2]
    323                  if (pUsage) {
   \   000000EC   000059E3           CMP      R9,#+0
   \   000000F0   0000C8E5           STRB     R0,[R8, #+0]
   \   000000F4   0500000A           BEQ      ??_DrawBitLine4BPP_8
    324                    GUI_USAGE_AddPixel(pUsage, x, y);
   \   000000F8   083099E5           LDR      R3,[R9, #+8]
   \   000000FC   0B20A0E1           MOV      R2,R11
   \   00000100   0A10A0E1           MOV      R1,R10
   \   00000104   0900A0E1           MOV      R0,R9
   \   00000108   003093E5           LDR      R3,[R3, #+0]
   \   0000010C   33FF2FE1           BLX      R3
    325                  }
    326                }
    327                pDest++;
   \                     ??_DrawBitLine4BPP_8:
   \   00000110   018088E2           ADD      R8,R8,#+1
    328                x++;
   \   00000114   01A08AE2           ADD      R10,R10,#+1
    329                xsize--;
   \   00000118   016046E2           SUB      R6,R6,#+1
    330                pixels = *++p;
   \   0000011C   0140F5E5           LDRB     R4,[R5, #+1]!
    331              }
    332              /* Draw center area (2 pixels in one byte) */
    333              while (xsize >= 2) {
   \                     ??_DrawBitLine4BPP_7:
   \   00000120   020056E3           CMP      R6,#+2
   \   00000124   1F0000BA           BLT      ??_DrawBitLine4BPP_9
    334                /* Draw 1. (left) pixel */
    335                if (pixels & 0xF0) {
   \                     ??_DrawBitLine4BPP_10:
   \   00000128   F00014E3           TST      R4,#0xF0
   \   0000012C   0B00000A           BEQ      ??_DrawBitLine4BPP_11
    336                  *pDest = *(pTrans + (pixels >> 4));
   \   00000130   FF0004E2           AND      R0,R4,#0xFF
   \   00000134   4002A0E1           ASR      R0,R0,#+4
   \   00000138   000197E7           LDR      R0,[R7, +R0, LSL #+2]
    337                  if (pUsage) {
   \   0000013C   000059E3           CMP      R9,#+0
   \   00000140   0000C8E5           STRB     R0,[R8, #+0]
   \   00000144   0500000A           BEQ      ??_DrawBitLine4BPP_11
    338                    GUI_USAGE_AddPixel(pUsage, x, y);
   \   00000148   083099E5           LDR      R3,[R9, #+8]
   \   0000014C   0B20A0E1           MOV      R2,R11
   \   00000150   0A10A0E1           MOV      R1,R10
   \   00000154   0900A0E1           MOV      R0,R9
   \   00000158   003093E5           LDR      R3,[R3, #+0]
   \   0000015C   33FF2FE1           BLX      R3
    339                  }
    340                }
    341                /* Draw 2. (right) pixel */
    342                if (pixels &= 15) {
   \                     ??_DrawBitLine4BPP_11:
   \   00000160   0F0014E2           ANDS     R0,R4,#0xF
   \   00000164   0900000A           BEQ      ??_DrawBitLine4BPP_12
    343                  *(pDest + 1) = *(pTrans + pixels);
   \   00000168   000197E7           LDR      R0,[R7, +R0, LSL #+2]
    344                  if (pUsage) {
   \   0000016C   000059E3           CMP      R9,#+0
   \   00000170   0100C8E5           STRB     R0,[R8, #+1]
   \   00000174   0500000A           BEQ      ??_DrawBitLine4BPP_12
    345                    GUI_USAGE_AddPixel(pUsage, x + 1, y);
   \   00000178   083099E5           LDR      R3,[R9, #+8]
   \   0000017C   0B20A0E1           MOV      R2,R11
   \   00000180   01108AE2           ADD      R1,R10,#+1
   \   00000184   0900A0E1           MOV      R0,R9
   \   00000188   003093E5           LDR      R3,[R3, #+0]
   \   0000018C   33FF2FE1           BLX      R3
    346                  }
    347                }
    348                pDest += 2;
    349                x += 2;
    350                xsize -= 2;
   \                     ??_DrawBitLine4BPP_12:
   \   00000190   026046E2           SUB      R6,R6,#+2
   \   00000194   028088E2           ADD      R8,R8,#+2
   \   00000198   02A08AE2           ADD      R10,R10,#+2
    351                pixels = *++p;
   \   0000019C   0140F5E5           LDRB     R4,[R5, #+1]!
   \   000001A0   020056E3           CMP      R6,#+2
   \   000001A4   DFFFFFAA           BGE      ??_DrawBitLine4BPP_10
    352              }
    353              /* Draw incomplete bytes to the right of center area */
    354              if (xsize) {
   \                     ??_DrawBitLine4BPP_9:
   \   000001A8   000056E3           CMP      R6,#+0
    355                if (pixels >>= 4) {
   \   000001AC   044CA011           LSLNE    R4,R4,#+24
   \   000001B0   244EB011           LSRSNE   R4,R4,#+28
   \   000001B4   1C00000A           BEQ      ??_DrawBitLine4BPP_3
    356                  *pDest = *(pTrans + pixels);
   \   000001B8   040197E7           LDR      R0,[R7, +R4, LSL #+2]
    357                  if (pUsage) {
   \   000001BC   000059E3           CMP      R9,#+0
   \   000001C0   0000C8E5           STRB     R0,[R8, #+0]
   \   000001C4   1800000A           BEQ      ??_DrawBitLine4BPP_3
    358                    GUI_USAGE_AddPixel(pUsage, x, y);
   \   000001C8   083099E5           LDR      R3,[R9, #+8]
   \   000001CC   0B20A0E1           MOV      R2,R11
   \   000001D0   0A10A0E1           MOV      R1,R10
   \   000001D4   0900A0E1           MOV      R0,R9
   \   000001D8   003093E5           LDR      R3,[R3, #+0]
   \   000001DC   33FF2FE1           BLX      R3
   \   000001E0   110000EA           B        ??_DrawBitLine4BPP_3
    359                  }
    360                }
    361              }
    362              break;
    363            case LCD_DRAWMODE_XOR:;
    364            PixelLoopXor:
    365              if (PixelCnt > xsize)
    366                PixelCnt = xsize;
    367              xsize -= PixelCnt;
    368              do {
    369                if ((pixels & 0xc0)) {
    370                  *pDest ^= 255;
    371                }
    372                pDest++;
    373                pixels <<= 4;
    374              } while (--PixelCnt);
    375              if (xsize) {
    376                PixelCnt = 2;
   \                     ??_DrawBitLine4BPP_13:
   \   000001E4   0210A0E3           MOV      R1,#+2
    377                pixels = *(++p);
   \   000001E8   0140F5E5           LDRB     R4,[R5, #+1]!
    378                goto PixelLoopXor;
    379              }
   \                     ??_DrawBitLine4BPP_2:
   \   000001EC   010CA0E1           MOV      R0,R1, LSL #+24
   \   000001F0   200C56E1           CMP      R6,R0, LSR #+24
   \   000001F4   0610A0B1           MOVLT    R1,R6
   \   000001F8   FF0001E2           AND      R0,R1,#0xFF
   \   000001FC   006046E0           SUB      R6,R6,R0
   \                     ??_DrawBitLine4BPP_14:
   \   00000200   C00014E3           TST      R4,#0xC0
   \   00000204   0000D815           LDRBNE   R0,[R8, #+0]
   \   00000208   011041E2           SUB      R1,R1,#+1
   \   0000020C   0442A0E1           LSL      R4,R4,#+4
   \   00000210   FF002012           EORNE    R0,R0,#0xFF
   \   00000214   0000C815           STRBNE   R0,[R8, #+0]
   \   00000218   018088E2           ADD      R8,R8,#+1
   \   0000021C   FF1011E2           ANDS     R1,R1,#0xFF
   \   00000220   F6FFFF1A           BNE      ??_DrawBitLine4BPP_14
   \   00000224   000056E3           CMP      R6,#+0
   \   00000228   EDFFFF1A           BNE      ??_DrawBitLine4BPP_13
    380              break;
    381            }
    382          }
   \                     ??_DrawBitLine4BPP_3:
   \   0000022C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000230   F08FBDE8           POP      {R4-R11,PC}      ;; return
    383          
    384          /*********************************************************************
    385          *
    386          *       _DrawBitLine8BPP
    387          */
    388          static void _DrawBitLine8BPP(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * pSrc, int xsize,
    389                                       const LCD_PIXELINDEX* pTrans, PIXELINDEX* pDest) {
    390            GUI_USE_PARA(pDevice);
    391            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    392            case 0:    /* Write mode */
    393              do {
    394                *pDest = *(pTrans + *pSrc);
    395                pDest++;
    396                pSrc++;
    397              } while (--xsize);
    398              break;
    399            case LCD_DRAWMODE_TRANS:
    400              do {
    401                if (*pSrc) {
    402                  *pDest = *(pTrans + *pSrc);
    403                  if (pUsage) {
    404                    GUI_USAGE_AddPixel(pUsage, x, y);
    405                  }
    406                }
    407                x++;
    408                pDest++;
    409                pSrc++;
    410              } while (--xsize);
    411              break;
    412            }
    413          }
    414          
    415          #if GUI_UNI_PTR_USED
    416          /*********************************************************************
    417          *
    418          *       _Memcopy
    419          */
    420          static void _Memcopy(PIXELINDEX * pDest, const U8 GUI_UNI_PTR * pSrc, int NumBytes) {
    421            while(NumBytes--) {
    422              *pDest++ = *pSrc++;
    423            }
    424          }
    425          #endif
    426          
    427          /*********************************************************************
    428          *
    429          *       _DrawBitLine8BPP_DDB
    430          */
    431          static void _DrawBitLine8BPP_DDB(GUI_DEVICE * pDevice, GUI_USAGE* pUsage, int x, int y, const U8 GUI_UNI_PTR * pSrc, int xsize, PIXELINDEX* pDest) {
    432            GUI_USE_PARA(pDevice);
    433            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
    434            case 0:    /* Write mode */
    435              #if GUI_UNI_PTR_USED
    436                _Memcopy(pDest, pSrc, xsize);
    437              #else
    438                GUI_MEMCPY(pDest, pSrc, xsize);
    439              #endif
    440              break;
    441            case LCD_DRAWMODE_TRANS:
    442              do {
    443                if (*pSrc) {
    444                  *pDest = *pSrc;
    445                  if (pUsage) {
    446                    GUI_USAGE_AddPixel(pUsage, x, y);
    447                  }
    448                }
    449                x++;
    450                pDest++;
    451                pSrc++;
    452              } while (--xsize);
    453              break;
    454            }
    455          }
    456          
    457          /*********************************************************************
    458          *
    459          *       _DrawBitmap
    460          */

   \                                 In section .text, align 4, keep-with-next
    461          static void _DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize,
    462                                  int BitsPerPixel, int BytesPerLine,
    463                                  const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX* pTrans)
    464          {
   \                     _DrawBitmap:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   ........           LDR      R0,??DataTable11_1
   \   0000000C   28D04DE2           SUB      SP,SP,#+40
   \   00000010   01A0A0E1           MOV      R10,R1
   \   00000014   0240A0E1           MOV      R4,R2
   \   00000018   5C609DE5           LDR      R6,[SP, #+92]
   \   0000001C   60709DE5           LDR      R7,[SP, #+96]
   \   00000020   64809DE5           LDR      R8,[SP, #+100]
   \   00000024   880090E5           LDR      R0,[R0, #+136]
    465            int i;
    466            GUI_MEMDEV* pDev   = GUI_MEMDEV_H2P(GUI_Context.hDevData);
   \   00000028   ........           BL       GUI_ALLOC_h2p
   \   0000002C   1C008DE5           STR      R0,[SP, #+28]
    467            GUI_USAGE*  pUsage = (pDev->hUsage) ? GUI_USAGE_H2P(pDev->hUsage) : 0;
   \   00000030   140090E5           LDR      R0,[R0, #+20]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0200000A           BEQ      ??_DrawBitmap_0
   \   0000003C   ........           BL       GUI_ALLOC_h2p
   \   00000040   0090A0E1           MOV      R9,R0
   \   00000044   000000EA           B        ??_DrawBitmap_1
   \                     ??_DrawBitmap_0:
   \   00000048   0090A0E3           MOV      R9,#+0
    468            unsigned    BytesPerLineDest;
    469            PIXELINDEX* pDest;
    470            BytesPerLineDest = pDev->BytesPerLine;
   \                     ??_DrawBitmap_1:
   \   0000004C   1C009DE5           LDR      R0,[SP, #+28]
    471            x0 += Diff;
    472            /* Mark all affected pixels dirty unless transparency is set */
    473            if (pUsage) {
   \   00000050   000059E3           CMP      R9,#+0
   \   00000054   0C0090E5           LDR      R0,[R0, #+12]
   \   00000058   20008DE5           STR      R0,[SP, #+32]
   \   0000005C   0A0087E0           ADD      R0,R7,R10
   \   00000060   18008DE5           STR      R0,[SP, #+24]
   \   00000064   0A00000A           BEQ      ??_DrawBitmap_2
    474              if ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) == 0) {
   \   00000068   ........           LDR      R0,??DataTable11_1
   \   0000006C   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000070   020010E3           TST      R0,#0x2
   \   00000074   0600001A           BNE      ??_DrawBitmap_2
    475                GUI_USAGE_AddRect(pUsage, x0, y0 , xsize, ysize);
   \   00000078   50009DE5           LDR      R0,[SP, #+80]
   \   0000007C   28309DE5           LDR      R3,[SP, #+40]
   \   00000080   00008DE5           STR      R0,[SP, #+0]
   \   00000084   0420A0E1           MOV      R2,R4
   \   00000088   18109DE5           LDR      R1,[SP, #+24]
   \   0000008C   0900A0E1           MOV      R0,R9
   \   00000090   ........           BL       GUI_USAGE_AddRect
    476              }
    477            }
    478            pDest = _XY2PTR(x0, y0);
   \                     ??_DrawBitmap_2:
   \   00000094   ........           LDR      R0,??DataTable11_1
   \   00000098   880090E5           LDR      R0,[R0, #+136]
   \   0000009C   ........           BL       GUI_ALLOC_h2p
   \   000000A0   F630D0E1           LDRSH    R3,[R0, #+6]
   \   000000A4   0CC090E5           LDR      R12,[R0, #+12]
   \   000000A8   F410D0E1           LDRSH    R1,[R0, #+4]
   \   000000AC   033044E0           SUB      R3,R4,R3
   \   000000B0   9C0320E0           MLA      R0,R12,R3,R0
   \   000000B4   18209DE5           LDR      R2,[SP, #+24]
   \   000000B8   001061E2           RSB      R1,R1,#+0
   \   000000BC   000082E0           ADD      R0,R2,R0
   \   000000C0   000081E0           ADD      R0,R1,R0
   \   000000C4   18A080E2           ADD      R10,R0,#+24
    479          #if BITSPERPIXEL == 16
    480            /* handle 16 bpp bitmaps in high color modes, but only without palette */
    481            if (BitsPerPixel == 16) {
    482              for (i = 0; i < ysize; i++) {
    483                _DrawBitLine16BPP_DDB(pDevice, pUsage, x0, i + y0, (const U16*)pData, xsize, pDest);
    484                pData += BytesPerLine;
    485                pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
    486              }
    487              return;
    488            } else if (BitsPerPixel >= 24) {
    489              for (i = 0; i < ysize; i++) {
    490                _DrawBitLine32BPP(pDevice, pUsage, x0, i + y0, (const U32 *)pData, xsize, pDest);
    491                pData += BytesPerLine;
    492                pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
    493              }
    494              return;
    495            }
    496          #endif
    497          #if BITSPERPIXEL == 32
    498            /* handle 32 bpp bitmaps in high color modes, but only without palette */
    499            if (BitsPerPixel >= 24) {
    500              for (i = 0; i < ysize; i++) {
    501                _DrawBitLine32BPP_DDB(pDevice, pUsage, x0, i + y0, (const U32*)pData, xsize, pDest);
    502                pData += BytesPerLine;
    503                pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
    504              }
    505              return;
    506            } else if (BitsPerPixel == 16) {
    507              for (i = 0; i < ysize; i++) {
    508                _DrawBitLine16BPP(pDevice, pUsage, x0, i + y0, (const U16 *)pData, xsize, pDest);
    509                pData += BytesPerLine;
    510                pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
    511              }
    512              return;
    513            }
    514          #endif
    515            /* Handle 8 bpp bitmaps seperately as we have different routine bitmaps with or without palette */
    516            if (BitsPerPixel == 8) {
   \   000000C8   54009DE5           LDR      R0,[SP, #+84]
   \   000000CC   080050E3           CMP      R0,#+8
   \   000000D0   5400001A           BNE      ??_DrawBitmap_3
    517              for (i = 0; i < ysize; i++) {
   \   000000D4   50009DE5           LDR      R0,[SP, #+80]
   \   000000D8   0010A0E3           MOV      R1,#+0
   \   000000DC   04108DE5           STR      R1,[SP, #+4]
   \   000000E0   010050E3           CMP      R0,#+1
   \   000000E4   8A0000BA           BLT      ??_DrawBitmap_4
   \   000000E8   00408DE5           STR      R4,[SP, #+0]
    518                if (pTrans) {
   \                     ??_DrawBitmap_5:
   \   000000EC   00109DE5           LDR      R1,[SP, #+0]
   \   000000F0   ........           LDR      R0,??DataTable11_1
   \   000000F4   000058E3           CMP      R8,#+0
   \   000000F8   0A40A0E1           MOV      R4,R10
   \   000000FC   28509DE5           LDR      R5,[SP, #+40]
   \   00000100   0670A0E1           MOV      R7,R6
   \   00000104   08108DE5           STR      R1,[SP, #+8]
   \   00000108   18B09DE5           LDR      R11,[SP, #+24]
   \   0000010C   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000110   1C00000A           BEQ      ??_DrawBitmap_6
    519                  _DrawBitLine8BPP(pDevice, pUsage, x0, i + y0, pData, xsize, pTrans, pDest);
   \   00000114   030010E2           ANDS     R0,R0,#0x3
   \   00000118   1400000A           BEQ      ??_DrawBitmap_7
   \   0000011C   020050E2           SUBS     R0,R0,#+2
   \   00000120   3100001A           BNE      ??_DrawBitmap_8
   \                     ??_DrawBitmap_9:
   \   00000124   0000D7E5           LDRB     R0,[R7, #+0]
   \   00000128   000050E3           CMP      R0,#+0
   \   0000012C   0900000A           BEQ      ??_DrawBitmap_10
   \   00000130   000198E7           LDR      R0,[R8, +R0, LSL #+2]
   \   00000134   000059E3           CMP      R9,#+0
   \   00000138   0000C4E5           STRB     R0,[R4, #+0]
   \   0000013C   0500000A           BEQ      ??_DrawBitmap_10
   \   00000140   083099E5           LDR      R3,[R9, #+8]
   \   00000144   08209DE5           LDR      R2,[SP, #+8]
   \   00000148   0B10A0E1           MOV      R1,R11
   \   0000014C   0900A0E1           MOV      R0,R9
   \   00000150   003093E5           LDR      R3,[R3, #+0]
   \   00000154   33FF2FE1           BLX      R3
   \                     ??_DrawBitmap_10:
   \   00000158   01B08BE2           ADD      R11,R11,#+1
   \   0000015C   014084E2           ADD      R4,R4,#+1
   \   00000160   017087E2           ADD      R7,R7,#+1
   \   00000164   015055E2           SUBS     R5,R5,#+1
   \   00000168   EDFFFF1A           BNE      ??_DrawBitmap_9
   \   0000016C   1E0000EA           B        ??_DrawBitmap_8
   \                     ??_DrawBitmap_7:
   \   00000170   0100D7E4           LDRB     R0,[R7], #+1
   \   00000174   015055E2           SUBS     R5,R5,#+1
   \   00000178   000198E7           LDR      R0,[R8, +R0, LSL #+2]
   \   0000017C   0100C4E4           STRB     R0,[R4], #+1
   \   00000180   FAFFFF1A           BNE      ??_DrawBitmap_7
   \   00000184   180000EA           B        ??_DrawBitmap_8
    520                } else {
    521                  _DrawBitLine8BPP_DDB(pDevice, pUsage, x0, i + y0, pData, xsize, pDest);
   \                     ??_DrawBitmap_6:
   \   00000188   030010E2           ANDS     R0,R0,#0x3
   \   0000018C   1200000A           BEQ      ??_DrawBitmap_11
   \   00000190   020050E2           SUBS     R0,R0,#+2
   \   00000194   1400001A           BNE      ??_DrawBitmap_8
   \                     ??_DrawBitmap_12:
   \   00000198   0000D7E5           LDRB     R0,[R7, #+0]
   \   0000019C   000050E3           CMP      R0,#+0
   \   000001A0   0000C415           STRBNE   R0,[R4, #+0]
   \   000001A4   00005913           CMPNE    R9,#+0
   \   000001A8   0500000A           BEQ      ??_DrawBitmap_13
   \   000001AC   083099E5           LDR      R3,[R9, #+8]
   \   000001B0   08209DE5           LDR      R2,[SP, #+8]
   \   000001B4   0B10A0E1           MOV      R1,R11
   \   000001B8   0900A0E1           MOV      R0,R9
   \   000001BC   003093E5           LDR      R3,[R3, #+0]
   \   000001C0   33FF2FE1           BLX      R3
   \                     ??_DrawBitmap_13:
   \   000001C4   01B08BE2           ADD      R11,R11,#+1
   \   000001C8   014084E2           ADD      R4,R4,#+1
   \   000001CC   017087E2           ADD      R7,R7,#+1
   \   000001D0   015055E2           SUBS     R5,R5,#+1
   \   000001D4   EFFFFF1A           BNE      ??_DrawBitmap_12
   \   000001D8   030000EA           B        ??_DrawBitmap_8
   \                     ??_DrawBitmap_11:
   \   000001DC   0520A0E1           MOV      R2,R5
   \   000001E0   0710A0E1           MOV      R1,R7
   \   000001E4   0400A0E1           MOV      R0,R4
   \   000001E8   ........           BL       __aeabi_memcpy
    522                }
    523                pData += BytesPerLine;
   \                     ??_DrawBitmap_8:
   \   000001EC   58009DE5           LDR      R0,[SP, #+88]
    524                pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
    525              }
   \   000001F0   50109DE5           LDR      R1,[SP, #+80]
   \   000001F4   066080E0           ADD      R6,R0,R6
   \   000001F8   20009DE5           LDR      R0,[SP, #+32]
   \   000001FC   0AA080E0           ADD      R10,R0,R10
   \   00000200   04009DE5           LDR      R0,[SP, #+4]
   \   00000204   010080E2           ADD      R0,R0,#+1
   \   00000208   04008DE5           STR      R0,[SP, #+4]
   \   0000020C   00009DE5           LDR      R0,[SP, #+0]
   \   00000210   010080E2           ADD      R0,R0,#+1
   \   00000214   00008DE5           STR      R0,[SP, #+0]
   \   00000218   04009DE5           LDR      R0,[SP, #+4]
   \   0000021C   010050E1           CMP      R0,R1
   \   00000220   3B0000AA           BGE      ??_DrawBitmap_4
   \   00000224   B0FFFFEA           B        ??_DrawBitmap_5
    526              return;
    527            }
    528            /* Use aID for bitmaps without palette */
    529            if (!pTrans) {
   \                     ??_DrawBitmap_3:
   \   00000228   000058E3           CMP      R8,#+0
    530              pTrans = aID;
    531            }
    532            for (i = 0; i < ysize; i++) {
   \   0000022C   50009DE5           LDR      R0,[SP, #+80]
   \   00000230   ............       ADRLEQ   R8,aID
   \              ....        
   \   00000238   010050E3           CMP      R0,#+1
   \   0000023C   340000BA           BLT      ??_DrawBitmap_4
   \   00000240   00B0A0E1           MOV      R11,R0
    533              switch (BitsPerPixel) {
   \                     ??_DrawBitmap_14:
   \   00000244   54009DE5           LDR      R0,[SP, #+84]
   \   00000248   010050E2           SUBS     R0,R0,#+1
   \   0000024C   0400000A           BEQ      ??_DrawBitmap_15
   \   00000250   010050E2           SUBS     R0,R0,#+1
   \   00000254   1000000A           BEQ      ??_DrawBitmap_16
   \   00000258   020050E2           SUBS     R0,R0,#+2
   \   0000025C   1A00000A           BEQ      ??_DrawBitmap_17
   \   00000260   240000EA           B        ??_DrawBitmap_18
    534              case 1:
    535                _DrawBitLine1BPP(pDevice, pUsage, x0, i + y0, pData, Diff, xsize, pTrans, pDev, pDest);
   \                     ??_DrawBitmap_15:
   \   00000264   1C009DE5           LDR      R0,[SP, #+28]
   \   00000268   14A08DE5           STR      R10,[SP, #+20]
   \   0000026C   10008DE5           STR      R0,[SP, #+16]
   \   00000270   28009DE5           LDR      R0,[SP, #+40]
   \   00000274   0C808DE5           STR      R8,[SP, #+12]
   \   00000278   08008DE5           STR      R0,[SP, #+8]
   \   0000027C   04708DE5           STR      R7,[SP, #+4]
   \   00000280   00608DE5           STR      R6,[SP, #+0]
   \   00000284   0430A0E1           MOV      R3,R4
   \   00000288   18209DE5           LDR      R2,[SP, #+24]
   \   0000028C   0910A0E1           MOV      R1,R9
   \   00000290   0500A0E1           MOV      R0,R5
   \   00000294   ........           BL       _DrawBitLine1BPP
    536                break;
   \   00000298   160000EA           B        ??_DrawBitmap_18
    537              case 2:
    538                _DrawBitLine2BPP(pDevice, pUsage, x0, i + y0, pData, Diff, xsize, pTrans, pDest);
   \                     ??_DrawBitmap_16:
   \   0000029C   28009DE5           LDR      R0,[SP, #+40]
   \   000002A0   10A08DE5           STR      R10,[SP, #+16]
   \   000002A4   08008DE5           STR      R0,[SP, #+8]
   \   000002A8   0C808DE5           STR      R8,[SP, #+12]
   \   000002AC   04708DE5           STR      R7,[SP, #+4]
   \   000002B0   00608DE5           STR      R6,[SP, #+0]
   \   000002B4   0430A0E1           MOV      R3,R4
   \   000002B8   18209DE5           LDR      R2,[SP, #+24]
   \   000002BC   0910A0E1           MOV      R1,R9
   \   000002C0   0500A0E1           MOV      R0,R5
   \   000002C4   ........           BL       _DrawBitLine2BPP
    539                break;
   \   000002C8   0A0000EA           B        ??_DrawBitmap_18
    540              case 4:
    541                _DrawBitLine4BPP(pDevice, pUsage, x0, i + y0, pData, Diff, xsize, pTrans, pDest);
   \                     ??_DrawBitmap_17:
   \   000002CC   28009DE5           LDR      R0,[SP, #+40]
   \   000002D0   10A08DE5           STR      R10,[SP, #+16]
   \   000002D4   08008DE5           STR      R0,[SP, #+8]
   \   000002D8   0C808DE5           STR      R8,[SP, #+12]
   \   000002DC   04708DE5           STR      R7,[SP, #+4]
   \   000002E0   00608DE5           STR      R6,[SP, #+0]
   \   000002E4   0430A0E1           MOV      R3,R4
   \   000002E8   18209DE5           LDR      R2,[SP, #+24]
   \   000002EC   0910A0E1           MOV      R1,R9
   \   000002F0   0500A0E1           MOV      R0,R5
   \   000002F4   ........           BL       _DrawBitLine4BPP
    542                break;
    543              }
    544              pData += BytesPerLine;
   \                     ??_DrawBitmap_18:
   \   000002F8   58009DE5           LDR      R0,[SP, #+88]
    545              pDest = (PIXELINDEX*)((U8*)pDest + BytesPerLineDest); 
    546            }
   \   000002FC   014084E2           ADD      R4,R4,#+1
   \   00000300   066080E0           ADD      R6,R0,R6
   \   00000304   20009DE5           LDR      R0,[SP, #+32]
   \   00000308   01B05BE2           SUBS     R11,R11,#+1
   \   0000030C   0AA080E0           ADD      R10,R0,R10
   \   00000310   CBFFFF1A           BNE      ??_DrawBitmap_14
   \                     ??_DrawBitmap_4:
   \   00000314   2CD08DE2           ADD      SP,SP,#+44       ;; stack cleaning
   \   00000318   F08FBDE8           POP      {R4-R11,PC}      ;; return
    547          }
    548          
    549          /*********************************************************************
    550          *
    551          *       _FillRect
    552          */

   \                                 In section .text, align 4, keep-with-next
    553          static void _FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect:
   \   00000000   F14F2DE9           PUSH     {R0,R4-R11,LR}
   \   00000004   0140A0E1           MOV      R4,R1
    554            unsigned BytesPerLine;
    555            int Len, RemPixels;
    556            GUI_MEMDEV * pDev;
    557            PIXELINDEX * pData;
    558            PIXELINDEX * pDest;
    559            PIXELINDEX IndexMask;
    560            LCD_PIXELINDEX ColorIndex;
    561          
    562            ColorIndex = LCD__GetColorIndex();
   \   00000008   ........           LDR      R1,??DataTable11_2
    563            pDev   = GUI_MEMDEV_H2P(GUI_Context.hDevData);
   \   0000000C   ........           LDR      R7,??DataTable11_1
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   001091E5           LDR      R1,[R1, #+0]
   \   0000001C   0250A0E1           MOV      R5,R2
   \   00000020   03A0A0E1           MOV      R10,R3
   \   00000024   30609DE5           LDR      R6,[SP, #+48]
   \   00000028   04108DE5           STR      R1,[SP, #+4]
   \   0000002C   880097E5           LDR      R0,[R7, #+136]
   \   00000030   ........           BL       GUI_ALLOC_h2p
   \   00000034   00B0A0E1           MOV      R11,R0
    564            pData  = _XY2PTR(x0, y0);
   \   00000038   880097E5           LDR      R0,[R7, #+136]
   \   0000003C   ........           BL       GUI_ALLOC_h2p
   \   00000040   F620D0E1           LDRSH    R2,[R0, #+6]
   \   00000044   0C3090E5           LDR      R3,[R0, #+12]
   \   00000048   F410D0E1           LDRSH    R1,[R0, #+4]
   \   0000004C   022045E0           SUB      R2,R5,R2
   \   00000050   930220E0           MLA      R0,R3,R2,R0
   \   00000054   001061E2           RSB      R1,R1,#+0
   \   00000058   000084E0           ADD      R0,R4,R0
   \   0000005C   000081E0           ADD      R0,R1,R0
   \   00000060   188080E2           ADD      R8,R0,#+24
    565            BytesPerLine = pDev->BytesPerLine;
    566            Len = x1 - x0 + 1;
   \   00000064   04004AE0           SUB      R0,R10,R4
   \   00000068   01A080E2           ADD      R10,R0,#+1
    567            /* Mark rectangle as modified */
    568            if (pDev->hUsage) {
   \   0000006C   14009BE5           LDR      R0,[R11, #+20]
   \   00000070   0C909BE5           LDR      R9,[R11, #+12]
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   0700000A           BEQ      ??_FillRect_0
    569              GUI_USAGE_AddRect(GUI_USAGE_H2P(pDev->hUsage), x0, y0, Len, y1 - y0 + 1);
   \   0000007C   ........           BL       GUI_ALLOC_h2p
   \   00000080   051046E0           SUB      R1,R6,R5
   \   00000084   011081E2           ADD      R1,R1,#+1
   \   00000088   00108DE5           STR      R1,[SP, #+0]
   \   0000008C   0A30A0E1           MOV      R3,R10
   \   00000090   0520A0E1           MOV      R2,R5
   \   00000094   0410A0E1           MOV      R1,R4
   \   00000098   ........           BL       GUI_USAGE_AddRect
    570            }
    571            /* Do the drawing */
    572            for (; y0 <= y1; y0++) {
   \                     ??_FillRect_0:
   \   0000009C   050056E1           CMP      R6,R5
   \   000000A0   170000BA           BLT      ??_FillRect_1
    573              if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \                     ??_FillRect_2:
   \   000000A4   1000D7E5           LDRB     R0,[R7, #+16]
   \   000000A8   010010E3           TST      R0,#0x1
   \   000000AC   0B00000A           BEQ      ??_FillRect_3
    574                RemPixels = Len;
    575                pDest  = pData;
    576                IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \   000000B0   08009DE5           LDR      R0,[SP, #+8]
   \   000000B4   0A40A0E1           MOV      R4,R10
   \   000000B8   100090E5           LDR      R0,[R0, #+16]
   \   000000BC   08B0A0E1           MOV      R11,R8
   \   000000C0   080090E5           LDR      R0,[R0, #+8]
   \   000000C4   30FF2FE1           BLX      R0
    577                do {
    578                  *pDest = *pDest ^ IndexMask;
   \                     ??_FillRect_4:
   \   000000C8   0010DBE5           LDRB     R1,[R11, #+0]
    579                  pDest++;
    580                } while (--RemPixels);
   \   000000CC   014054E2           SUBS     R4,R4,#+1
   \   000000D0   011020E0           EOR      R1,R0,R1
   \   000000D4   0110CBE4           STRB     R1,[R11], #+1
   \   000000D8   FAFFFF1A           BNE      ??_FillRect_4
   \   000000DC   040000EA           B        ??_FillRect_5
    581              } else {  /* Fill */
    582                #if BITSPERPIXEL == 8
    583                  GUI_MEMSET(pData, ColorIndex, Len);
   \                     ??_FillRect_3:
   \   000000E0   04109DE5           LDR      R1,[SP, #+4]
   \   000000E4   0A20A0E1           MOV      R2,R10
   \   000000E8   FF1001E2           AND      R1,R1,#0xFF
   \   000000EC   0800A0E1           MOV      R0,R8
   \   000000F0   ........           BL       GUI__memset
    584                #elif BITSPERPIXEL == 16
    585                  GUI__memset16(pData, ColorIndex, Len);
    586                #elif (BITSPERPIXEL == 24) || (BITSPERPIXEL == 32)
    587                  unsigned Cnt;
    588                  if (Len > 0) {
    589                    Cnt = Len;
    590                    pDest = pData;
    591                    do {
    592                      *pDest++ = ColorIndex;
    593                    } while (--Cnt);
    594                  }
    595                #else
    596                  #error Unsupported
    597                #endif
    598              }
    599              pData = (PIXELINDEX*)((U8*)pData + BytesPerLine); 
    600            }
   \                     ??_FillRect_5:
   \   000000F4   015085E2           ADD      R5,R5,#+1
   \   000000F8   088089E0           ADD      R8,R9,R8
   \   000000FC   050056E1           CMP      R6,R5
   \   00000100   E7FFFFAA           BGE      ??_FillRect_2
    601          }
   \                     ??_FillRect_1:
   \   00000104   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000108   F08FBDE8           POP      {R4-R11,PC}      ;; return
    602          
    603          /*********************************************************************
    604          *
    605          *       _DrawHLine
    606          */

   \                                 In section .text, align 4, keep-with-next
    607          static void _DrawHLine(GUI_DEVICE * pDevice, int x0, int y, int x1) {
   \                     _DrawHLine:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
    608            _FillRect(pDevice, x0, y, x1, y);
   \   00000008   00208DE5           STR      R2,[SP, #+0]
   \   0000000C   ........           BL       _FillRect
    609          }
   \   00000010   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000014   0080BDE8           POP      {PC}             ;; return
    610          
    611          /*********************************************************************
    612          *
    613          *       _DrawVLine
    614          */

   \                                 In section .text, align 4, keep-with-next
    615          static void _DrawVLine(GUI_DEVICE * pDevice, int x , int y0, int y1) {
   \                     _DrawVLine:
   \   00000000   F14F2DE9           PUSH     {R0,R4-R11,LR}
   \   00000004   ........           LDR      R0,??DataTable11_1
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0290A0E1           MOV      R9,R2
   \   00000010   0350A0E1           MOV      R5,R3
   \   00000014   880090E5           LDR      R0,[R0, #+136]
    616            GUI_MEMDEV * pDev;
    617            GUI_USAGE_h  hUsage; 
    618            GUI_USAGE  * pUsage;
    619            PIXELINDEX * pData;
    620            unsigned     BytesPerLine;
    621            PIXELINDEX   IndexMask;
    622            unsigned     NumPixels;
    623            LCD_PIXELINDEX ColorIndex;
    624          
    625            pDev   = GUI_MEMDEV_H2P(GUI_Context.hDevData);
   \   00000018   ........           BL       GUI_ALLOC_h2p
   \   0000001C   00B0A0E1           MOV      R11,R0
    626            hUsage = pDev->hUsage; 
   \   00000020   14609BE5           LDR      R6,[R11, #+20]
    627            pUsage = hUsage ? GUI_USAGE_H2P(hUsage) : NULL;
   \   00000024   000056E3           CMP      R6,#+0
   \   00000028   0300000A           BEQ      ??_DrawVLine_0
   \   0000002C   0600A0E1           MOV      R0,R6
   \   00000030   ........           BL       GUI_ALLOC_h2p
   \   00000034   0070A0E1           MOV      R7,R0
   \   00000038   000000EA           B        ??_DrawVLine_1
   \                     ??_DrawVLine_0:
   \   0000003C   0070A0E3           MOV      R7,#+0
    628            pData  = _XY2PTR(x, y0);
   \                     ??_DrawVLine_1:
   \   00000040   ........           LDR      R0,??DataTable11_1
   \   00000044   880090E5           LDR      R0,[R0, #+136]
   \   00000048   ........           BL       GUI_ALLOC_h2p
   \   0000004C   F620D0E1           LDRSH    R2,[R0, #+6]
   \   00000050   0C3090E5           LDR      R3,[R0, #+12]
   \   00000054   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000058   022049E0           SUB      R2,R9,R2
   \   0000005C   930220E0           MLA      R0,R3,R2,R0
   \   00000060   001061E2           RSB      R1,R1,#+0
   \   00000064   000084E0           ADD      R0,R4,R0
   \   00000068   000081E0           ADD      R0,R1,R0
   \   0000006C   188080E2           ADD      R8,R0,#+24
    629            BytesPerLine = pDev->BytesPerLine;
    630            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000070   ........           LDR      R0,??DataTable11_1
   \   00000074   0CA09BE5           LDR      R10,[R11, #+12]
   \   00000078   1000D0E5           LDRB     R0,[R0, #+16]
   \   0000007C   010010E3           TST      R0,#0x1
   \   00000080   1500000A           BEQ      ??_DrawVLine_2
    631              IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \   00000084   00009DE5           LDR      R0,[SP, #+0]
   \   00000088   100090E5           LDR      R0,[R0, #+16]
   \   0000008C   080090E5           LDR      R0,[R0, #+8]
   \   00000090   30FF2FE1           BLX      R0
   \   00000094   00A0A0E1           MOV      R10,R0
    632              do {
    633                if (hUsage) {
   \                     ??_DrawVLine_3:
   \   00000098   000056E3           CMP      R6,#+0
   \   0000009C   0500000A           BEQ      ??_DrawVLine_4
    634                  GUI_USAGE_AddPixel(pUsage, x, y0);
   \   000000A0   083097E5           LDR      R3,[R7, #+8]
   \   000000A4   0920A0E1           MOV      R2,R9
   \   000000A8   0410A0E1           MOV      R1,R4
   \   000000AC   0700A0E1           MOV      R0,R7
   \   000000B0   003093E5           LDR      R3,[R3, #+0]
   \   000000B4   33FF2FE1           BLX      R3
    635                }
    636                *pData = *pData ^ IndexMask;
   \                     ??_DrawVLine_4:
   \   000000B8   0000D8E5           LDRB     R0,[R8, #+0]
    637                pData = (PIXELINDEX*)((U8*)pData + pDev->BytesPerLine); /* Same as "pData += pDev->BytesPerLine >> 1;", Just more efficient */
    638              } while (++y0 <= y1);
   \   000000BC   019089E2           ADD      R9,R9,#+1
   \   000000C0   090055E1           CMP      R5,R9
   \   000000C4   00002AE0           EOR      R0,R10,R0
   \   000000C8   0000C8E5           STRB     R0,[R8, #+0]
   \   000000CC   0C009BE5           LDR      R0,[R11, #+12]
   \   000000D0   088080E0           ADD      R8,R0,R8
   \   000000D4   EFFFFFAA           BGE      ??_DrawVLine_3
   \   000000D8   160000EA           B        ??_DrawVLine_5
    639            } else {
    640              ColorIndex = LCD__GetColorIndex();
   \                     ??_DrawVLine_2:
   \   000000DC   ........           LDR      R0,??DataTable11_2
    641              if (hUsage) {
   \   000000E0   000056E3           CMP      R6,#+0
   \   000000E4   000090E5           LDR      R0,[R0, #+0]
   \   000000E8   00B090E5           LDR      R11,[R0, #+0]
   \   000000EC   0B00000A           BEQ      ??_DrawVLine_6
    642                do {
    643                  GUI_USAGE_AddPixel(pUsage, x, y0);
   \                     ??_DrawVLine_7:
   \   000000F0   083097E5           LDR      R3,[R7, #+8]
   \   000000F4   0920A0E1           MOV      R2,R9
   \   000000F8   0410A0E1           MOV      R1,R4
   \   000000FC   0700A0E1           MOV      R0,R7
   \   00000100   003093E5           LDR      R3,[R3, #+0]
   \   00000104   33FF2FE1           BLX      R3
    644                  *pData = ColorIndex;
   \   00000108   00B0C8E5           STRB     R11,[R8, #+0]
    645                  pData = (PIXELINDEX *)((U8 *)pData + BytesPerLine); /* Same as "pData += pDev->BytesPerLine >> 1;", Just more efficient */
    646                } while (++y0 <= y1);
   \   0000010C   019089E2           ADD      R9,R9,#+1
   \   00000110   08808AE0           ADD      R8,R10,R8
   \   00000114   090055E1           CMP      R5,R9
   \   00000118   F4FFFFAA           BGE      ??_DrawVLine_7
   \   0000011C   050000EA           B        ??_DrawVLine_5
    647              } else {
    648                NumPixels = y1 - y0 + 1;
   \                     ??_DrawVLine_6:
   \   00000120   090045E0           SUB      R0,R5,R9
   \   00000124   010080E2           ADD      R0,R0,#+1
    649                do {
    650                  *pData = ColorIndex;
   \                     ??_DrawVLine_8:
   \   00000128   00B0C8E5           STRB     R11,[R8, #+0]
    651                  pData = (PIXELINDEX *)((U8 *)pData + BytesPerLine); /* Same as "pData += pDev->BytesPerLine >> 1;", Just more efficient */
   \   0000012C   08808AE0           ADD      R8,R10,R8
    652                } while (--NumPixels);
   \   00000130   010050E2           SUBS     R0,R0,#+1
   \   00000134   FBFFFF1A           BNE      ??_DrawVLine_8
    653              }
    654            }
    655          }
   \                     ??_DrawVLine_5:
   \   00000138   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000013C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    656          
    657          /*********************************************************************
    658          *
    659          *       _SetPixelIndex
    660          */

   \                                 In section .text, align 4, keep-with-next
    661          static void _SetPixelIndex(GUI_DEVICE * pDevice, int x, int y, int Index) {
   \                     _SetPixelIndex:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    662            GUI_MEMDEV * pDev;
    663            GUI_USAGE_h hUsage; 
    664            PIXELINDEX * pData;
    665          
    666            GUI_USE_PARA(pDevice);
    667            pDev   = GUI_MEMDEV_H2P(GUI_Context.hDevData);
    668            hUsage = pDev->hUsage; 
   \   00000004   ........           LDR      R8,??DataTable11_1
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   0370A0E1           MOV      R7,R3
   \   00000014   880098E5           LDR      R0,[R8, #+136]
   \   00000018   ........           BL       GUI_ALLOC_h2p
   \   0000001C   146090E5           LDR      R6,[R0, #+20]
    669            pData  = _XY2PTR(x, y);
   \   00000020   880098E5           LDR      R0,[R8, #+136]
   \   00000024   ........           BL       GUI_ALLOC_h2p
    670            *pData = Index;
   \   00000028   F620D0E1           LDRSH    R2,[R0, #+6]
   \   0000002C   0C3090E5           LDR      R3,[R0, #+12]
   \   00000030   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000034   022045E0           SUB      R2,R5,R2
   \   00000038   930220E0           MLA      R0,R3,R2,R0
   \   0000003C   001061E2           RSB      R1,R1,#+0
   \   00000040   000084E0           ADD      R0,R4,R0
   \   00000044   000081E0           ADD      R0,R1,R0
   \   00000048   1870C0E5           STRB     R7,[R0, #+24]
    671            if (hUsage) {
   \   0000004C   000056E3           CMP      R6,#+0
   \   00000050   0B00000A           BEQ      ??_SetPixelIndex_0
    672              GUI_USAGE_AddPixel(GUI_USAGE_H2P(hUsage), x, y);
   \   00000054   0600A0E1           MOV      R0,R6
   \   00000058   ........           BL       GUI_ALLOC_h2p
   \   0000005C   0070A0E1           MOV      R7,R0
   \   00000060   0600A0E1           MOV      R0,R6
   \   00000064   ........           BL       GUI_ALLOC_h2p
   \   00000068   0030A0E1           MOV      R3,R0
   \   0000006C   083093E5           LDR      R3,[R3, #+8]
   \   00000070   0520A0E1           MOV      R2,R5
   \   00000074   0410A0E1           MOV      R1,R4
   \   00000078   0700A0E1           MOV      R0,R7
   \   0000007C   003093E5           LDR      R3,[R3, #+0]
   \   00000080   33FF2FE1           BLX      R3
    673            }
    674          }
   \                     ??_SetPixelIndex_0:
   \   00000084   F081BDE8           POP      {R4-R8,PC}       ;; return
    675          
    676          /*********************************************************************
    677          *
    678          *       _XorPixel
    679          */

   \                                 In section .text, align 4, keep-with-next
    680          static void _XorPixel(GUI_DEVICE * pDevice, int x, int y) {
   \                     _XorPixel:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    681            PIXELINDEX IndexMask;
    682            GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
    683            GUI_USAGE_h hUsage = pDev->hUsage; 
   \   00000004   ........           LDR      R8,??DataTable11_1
   \   00000008   0070A0E1           MOV      R7,R0
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   880098E5           LDR      R0,[R8, #+136]
   \   00000018   ........           BL       GUI_ALLOC_h2p
   \   0000001C   146090E5           LDR      R6,[R0, #+20]
    684            PIXELINDEX* pData = _XY2PTR(x, y);
   \   00000020   880098E5           LDR      R0,[R8, #+136]
   \   00000024   ........           BL       GUI_ALLOC_h2p
   \   00000028   F620D0E1           LDRSH    R2,[R0, #+6]
   \   0000002C   0C3090E5           LDR      R3,[R0, #+12]
   \   00000030   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000034   022045E0           SUB      R2,R5,R2
   \   00000038   930220E0           MLA      R0,R3,R2,R0
   \   0000003C   001061E2           RSB      R1,R1,#+0
   \   00000040   000084E0           ADD      R0,R4,R0
   \   00000044   000081E0           ADD      R0,R1,R0
   \   00000048   188080E2           ADD      R8,R0,#+24
    685            IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \   0000004C   100097E5           LDR      R0,[R7, #+16]
   \   00000050   080090E5           LDR      R0,[R0, #+8]
   \   00000054   30FF2FE1           BLX      R0
    686            *pData = *pData ^ IndexMask;
   \   00000058   0010D8E5           LDRB     R1,[R8, #+0]
    687            if (hUsage) {
   \   0000005C   000056E3           CMP      R6,#+0
   \   00000060   010020E0           EOR      R0,R0,R1
   \   00000064   0000C8E5           STRB     R0,[R8, #+0]
   \   00000068   0B00000A           BEQ      ??_XorPixel_0
    688              GUI_USAGE_AddPixel(GUI_USAGE_H2P(hUsage), x, y);
   \   0000006C   0600A0E1           MOV      R0,R6
   \   00000070   ........           BL       GUI_ALLOC_h2p
   \   00000074   0070A0E1           MOV      R7,R0
   \   00000078   0600A0E1           MOV      R0,R6
   \   0000007C   ........           BL       GUI_ALLOC_h2p
   \   00000080   0030A0E1           MOV      R3,R0
   \   00000084   083093E5           LDR      R3,[R3, #+8]
   \   00000088   0520A0E1           MOV      R2,R5
   \   0000008C   0410A0E1           MOV      R1,R4
   \   00000090   0700A0E1           MOV      R0,R7
   \   00000094   003093E5           LDR      R3,[R3, #+0]
   \   00000098   33FF2FE1           BLX      R3
    689            }
    690          }
   \                     ??_XorPixel_0:
   \   0000009C   F081BDE8           POP      {R4-R8,PC}       ;; return
    691          
    692          /*********************************************************************
    693          *
    694          *       _GetPixelIndex
    695          */

   \                                 In section .text, align 4, keep-with-next
    696          static unsigned int _GetPixelIndex(GUI_DEVICE * pDevice, int x, int y) {
   \                     _GetPixelIndex:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    697            PIXELINDEX * pData;
    698          
    699            GUI_USE_PARA(pDevice);
    700            pData = _XY2PTR(x, y);
   \   00000004   ........           LDR      R0,??DataTable11_1
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   880090E5           LDR      R0,[R0, #+136]
   \   00000018   ........           BL       GUI_ALLOC_h2p
    701            return *pData;
   \   0000001C   F620D0E1           LDRSH    R2,[R0, #+6]
   \   00000020   0C3090E5           LDR      R3,[R0, #+12]
   \   00000024   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000028   022045E0           SUB      R2,R5,R2
   \   0000002C   930220E0           MLA      R0,R3,R2,R0
   \   00000030   001061E2           RSB      R1,R1,#+0
   \   00000034   000084E0           ADD      R0,R4,R0
   \   00000038   000081E0           ADD      R0,R1,R0
   \   0000003C   1800D0E5           LDRB     R0,[R0, #+24]
   \   00000040   04D08DE2           ADD      SP,SP,#+4
   \   00000044   3080BDE8           POP      {R4,R5,PC}       ;; return
    702          }
    703          
    704          /*********************************************************************
    705          *
    706          *       _GetRect
    707          */

   \                                 In section .text, align 4, keep-with-next
    708          static void _GetRect(GUI_DEVICE * pDevice, LCD_RECT * pRect) {
   \                     _GetRect:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0140A0E1           MOV      R4,R1
    709            GUI_MEMDEV * pDev;
    710            
    711            pDev = GUI_MEMDEV_H2P(pDevice->u.hContext);
   \   00000008   080090E5           LDR      R0,[R0, #+8]
   \   0000000C   ........           BL       GUI_ALLOC_h2p
    712            pRect->x0 = pDev->x0;
   \   00000010   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000014   B010C4E1           STRH     R1,[R4, #+0]
    713            pRect->y0 = pDev->y0;
   \   00000018   F610D0E1           LDRSH    R1,[R0, #+6]
   \   0000001C   B210C4E1           STRH     R1,[R4, #+2]
    714            pRect->x1 = pDev->x0 + pDev->XSize-1;
   \   00000020   F410D0E1           LDRSH    R1,[R0, #+4]
   \   00000024   F820D0E1           LDRSH    R2,[R0, #+8]
   \   00000028   011082E0           ADD      R1,R2,R1
   \   0000002C   011041E2           SUB      R1,R1,#+1
   \   00000030   B410C4E1           STRH     R1,[R4, #+4]
    715            pRect->y1 = pDev->y0 + pDev->YSize-1;
   \   00000034   F610D0E1           LDRSH    R1,[R0, #+6]
   \   00000038   FA00D0E1           LDRSH    R0,[R0, #+10]
   \   0000003C   010080E0           ADD      R0,R0,R1
   \   00000040   010040E2           SUB      R0,R0,#+1
   \   00000044   B600C4E1           STRH     R0,[R4, #+6]
    716          }
   \   00000048   1080BDE8           POP      {R4,PC}          ;; return
    717          
    718          /*********************************************************************
    719          *
    720          *       _GetDevData
    721          */

   \                                 In section .text, align 4, keep-with-next
    722          static void * _GetDevData(GUI_DEVICE * pDevice, int Index) {
    723            GUI_USE_PARA(pDevice);
    724            switch (Index) {
   \                     _GetDevData:
   \   00000000   010051E3           CMP      R1,#+1
   \   00000004   0100001A           BNE      ??_GetDevData_0
    725            case LCD_DEVDATA_MEMDEV:
    726              return (void *)&DEVICE_API;
   \   00000008   ........           ADR      R0,GUI_MEMDEV_DEVICE_8
   \   0000000C   1EFF2FE1           BX       LR
    727            }
    728            return NULL;
   \                     ??_GetDevData_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
    729          }
    730          
    731          /*********************************************************************
    732          *
    733          *       _GetDevFunc
    734          */

   \                                 In section .text, align 4, keep-with-next
    735          static void (* _GetDevFunc(GUI_DEVICE ** ppDevice, int Index))(void) {
    736            GUI_USE_PARA(ppDevice);
    737            switch (Index) {
   \                     _GetDevFunc:
   \   00000000   160051E3           CMP      R1,#+22
   \   00000004   0100001A           BNE      ??_GetDevFunc_0
    738            case MEMDEV_DEVFUNC_WRITETOACTIVE:
    739              return (void (*)(void))GUI_MEMDEV__WriteToActiveOpaque;
   \   00000008   ........           LDR      R0,??DataTable11_3
   \   0000000C   1EFF2FE1           BX       LR
    740            }
    741            return NULL;
   \                     ??_GetDevFunc_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
    742          }
    743          
    744          /*********************************************************************
    745          *
    746          *       GUI_DEVICE_API functions: From here there is nothing to do except routing...
    747          */

   \                                 In section .text, align 4, keep-with-next
    748          static void _SetOrg(GUI_DEVICE * pDevice, int x, int y) {
    749            pDevice = pDevice->pNext;
   \                     _SetOrg:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    750            pDevice->pDeviceAPI->pfSetOrg(pDevice, x, y);
   \   00000004   0C3090E5           LDR      R3,[R0, #+12]
   \   00000008   203093E5           LDR      R3,[R3, #+32]
   \   0000000C   13FF2FE1           BX       R3               ;; tailcall
    751          }

   \                                 In section .text, align 4, keep-with-next
    752          static I32 _GetDevProp(GUI_DEVICE * pDevice, int Index) {
    753            pDevice = pDevice->pNext;
   \                     _GetDevProp:
   \   00000000   000090E5           LDR      R0,[R0, #+0]
    754            return pDevice->pDeviceAPI->pfGetDevProp(pDevice, Index);
   \   00000004   0C2090E5           LDR      R2,[R0, #+12]
   \   00000008   282092E5           LDR      R2,[R2, #+40]
   \   0000000C   12FF2FE1           BX       R2               ;; tailcall
    755          }
    756          
    757          /*********************************************************************
    758          *
    759          *       GUI_DEVICE_API structure
    760          */

   \                                 In section .text, align 4, keep-with-next
    761          const GUI_DEVICE_API DEVICE_API = {
   \                     GUI_MEMDEV_DEVICE_8:
   \   00000000                      ; Initializer data, 52 bytes
   \   00000000   04000000....       DC32 4, _DrawBitmap, _DrawHLine, _DrawVLine, _FillRect, _GetPixelIndex, _SetPixelIndex, _XorPixel, _SetOrg, _GetDevFunc
   \              ............
   \              ............
   \              ............
   \              ............
   \              ............
   \              ........    
   \   00000028   ............       DC32 _GetDevProp, _GetDevData, _GetRect
   \              ............

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     LCD_aMirror

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   ........           DC32     GUI_MEMDEV__WriteToActiveOpaque
    762            //
    763            // Data
    764            //
    765            DEVICE_CLASS_MEMDEV,
    766            //
    767            // Drawing functions
    768            //
    769            _DrawBitmap   ,
    770            _DrawHLine    ,
    771            _DrawVLine    ,
    772            _FillRect     ,
    773            _GetPixelIndex,
    774            _SetPixelIndex,
    775            _XorPixel     ,
    776            //
    777            // Set origin
    778            //
    779            _SetOrg       ,
    780            //
    781            // Request information
    782            //
    783            _GetDevFunc   ,
    784            _GetDevProp   ,
    785            _GetDevData,
    786            _GetRect      ,
    787          };
    788          
    789          #else
    790          
    791          void GUIDEV8_C(void);
    792          void GUIDEV8_C(void) {}
    793          
    794          #endif /* GUI_SUPPORT_MEMDEV */
    795          
    796          /*************************** end of file ****************************/

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     _DrawBitLine1BPP     40
     _DrawBitLine2BPP     40
     _DrawBitLine4BPP     40
     _DrawBitmap          80
     _DrawHLine            8
     _DrawVLine           40
     _FillRect            48
     _GetDevData           0
     _GetDevFunc           0
     _GetDevProp           8
     _GetPixelIndex       16
     _GetRect              8
     _SetOrg               8
     _SetPixelIndex       24
     _XorPixel            24


   Section sizes:

     Function/Label      Bytes
     --------------      -----
     aID                   64
     _DrawBitLine1BPP     416
     _DrawBitLine2BPP     352
     _DrawBitLine4BPP     564
     _DrawBitmap          796
     _FillRect            268
     _DrawHLine            24
     _DrawVLine           320
     _SetPixelIndex       136
     _XorPixel            160
     _GetPixelIndex        72
     _GetRect              76
     _GetDevData           24
     _GetDevFunc           24
     _SetOrg               16
     _GetDevProp           16
     GUI_MEMDEV_DEVICE_8   52
     ??DataTable11          4
     ??DataTable11_1        4
     ??DataTable11_2        4
     ??DataTable11_3        4

 
 3 396 bytes in section .text
 
 3 396 bytes of CODE memory

Errors: none
Warnings: none
