###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     14/Jul/2015  19:01:21 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\LCD_Rotate180.c                     #
#    Command line =  C:\DUII\TargetHW\GUI\LCD_Rotate180.c -D DEBUG=1 -D       #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D                   #
#                    XIGNORE_TEMPERATURE -D BUILD_DEBUG_PORT -D PROFILER      #
#                    -lCN C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Li #
#                    st\ -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\ #
#                    Obj\ --debug --endian=little --cpu=ARM926EJ-S -e         #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\LC #
#                    D_Rotate180.lst                                          #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\LCD #
#                    _Rotate180.o                                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\LCD_Rotate180.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : LCD_Rotate180.c
     19          Purpose     : Implementation of GUI_SetRotation
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include "GUI_Private.h"
     24          
     25          #if GUI_WINSUPPORT
     26            #include "WM.h"
     27          #endif
     28          
     29          #if GUI_SUPPORT_ROTATION
     30          
     31          /*********************************************************************
     32          *
     33          *       Static code
     34          *
     35          **********************************************************************
     36          */
     37          /*********************************************************************
     38          *
     39          *       _GetpfSetPixel
     40          */
     41          static tLCD_SetPixelAA * _GetpfSetPixel(void) {
     42            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
     43            case 0:
     44              return &LCD_SetPixelAA_NoTrans;
     45            case LCD_DRAWMODE_TRANS:
     46              return &LCD_SetPixelAA;
     47            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
     48            case LCD_DRAWMODE_XOR:
     49              return &LCD_SetPixelAA_Xor;
     50            }
     51            return NULL; // Never reach...
     52          }
     53          
     54          /*********************************************************************
     55          *
     56          *       _DrawBitLine1BPP
     57          */

   \                                 In section .text, align 4, keep-with-next
     58          static void  _DrawBitLine1BPP(int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine1BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0370A0E1           MOV      R7,R3
     59            LCD_PIXELINDEX Index0, Index1;
     60            unsigned IndexMask, Pixel;
     61          
     62            Index0 = *(pTrans + 0);
     63            Index1 = *(pTrans + 1);
     64            x -= Diff;
     65            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000008   ........           LDR      R5,??DataTable4
   \   0000000C   076040E0           SUB      R6,R0,R7
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   0140A0E1           MOV      R4,R1
   \   00000018   1000D5E5           LDRB     R0,[R5, #+16]
   \   0000001C   2C109DE5           LDR      R1,[SP, #+44]
   \   00000020   0280A0E1           MOV      R8,R2
   \   00000024   28909DE5           LDR      R9,[SP, #+40]
   \   00000028   00A091E5           LDR      R10,[R1, #+0]
   \   0000002C   04B091E5           LDR      R11,[R1, #+4]
   \   00000030   030010E2           ANDS     R0,R0,#0x3
   \   00000034   0300000A           BEQ      ??_DrawBitLine1BPP_0
   \   00000038   020050E3           CMP      R0,#+2
   \   0000003C   1600000A           BEQ      ??_DrawBitLine1BPP_1
   \   00000040   2A00003A           BCC      ??_DrawBitLine1BPP_2
   \   00000044   4D0000EA           B        ??_DrawBitLine1BPP_3
     66            case 0:
     67              do {
     68                LCDDEV_L0_SetPixelIndex(GUI_Context.apDevice[GUI_Context.SelLayer], x, y, (*p & (0x80 >> Diff)) ? Index1 : Index0);
   \                     ??_DrawBitLine1BPP_0:
   \   00000048   0000D8E5           LDRB     R0,[R8, #+0]
   \   0000004C   8010A0E3           MOV      R1,#+128
   \   00000050   0420A0E1           MOV      R2,R4
   \   00000054   510710E1           TST      R0,R1, ASR R7
   \   00000058   1100D5E5           LDRB     R0,[R5, #+17]
   \   0000005C   0B30A011           MOVNE    R3,R11
   \   00000060   0A30A001           MOVEQ    R3,R10
   \   00000064   000185E0           ADD      R0,R5,R0, LSL #+2
   \   00000068   480090E5           LDR      R0,[R0, #+72]
   \   0000006C   0610A0E1           MOV      R1,R6
   \   00000070   0CC090E5           LDR      R12,[R0, #+12]
   \   00000074   18C09CE5           LDR      R12,[R12, #+24]
   \   00000078   3CFF2FE1           BLX      R12
     69                x--;
     70                if (++Diff == 8) {
   \   0000007C   017087E2           ADD      R7,R7,#+1
   \   00000080   080057E3           CMP      R7,#+8
     71                  Diff = 0;
   \   00000084   0070A003           MOVEQ    R7,#+0
     72                  p++;
   \   00000088   01808802           ADDEQ    R8,R8,#+1
   \   0000008C   016046E2           SUB      R6,R6,#+1
     73                }
     74              } while (--xsize);
   \   00000090   019059E2           SUBS     R9,R9,#+1
   \   00000094   EBFFFF1A           BNE      ??_DrawBitLine1BPP_0
   \   00000098   380000EA           B        ??_DrawBitLine1BPP_3
     75              break;
     76            case LCD_DRAWMODE_TRANS:
     77              do {
     78                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_1:
   \   0000009C   0000D8E5           LDRB     R0,[R8, #+0]
   \   000000A0   8010A0E3           MOV      R1,#+128
   \   000000A4   510710E1           TST      R0,R1, ASR R7
   \   000000A8   0800000A           BEQ      ??_DrawBitLine1BPP_4
   \   000000AC   1100D5E5           LDRB     R0,[R5, #+17]
   \   000000B0   0B30A0E1           MOV      R3,R11
   \   000000B4   0420A0E1           MOV      R2,R4
   \   000000B8   000185E0           ADD      R0,R5,R0, LSL #+2
   \   000000BC   480090E5           LDR      R0,[R0, #+72]
   \   000000C0   0610A0E1           MOV      R1,R6
   \   000000C4   0CC090E5           LDR      R12,[R0, #+12]
   \   000000C8   18C09CE5           LDR      R12,[R12, #+24]
     79                  LCDDEV_L0_SetPixelIndex(GUI_Context.apDevice[GUI_Context.SelLayer], x, y, Index1);
   \   000000CC   3CFF2FE1           BLX      R12
     80                }
     81                x--;
     82                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_4:
   \   000000D0   017087E2           ADD      R7,R7,#+1
   \   000000D4   080057E3           CMP      R7,#+8
     83                  Diff = 0;
   \   000000D8   0070A003           MOVEQ    R7,#+0
     84                  p++;
   \   000000DC   01808802           ADDEQ    R8,R8,#+1
   \   000000E0   016046E2           SUB      R6,R6,#+1
     85                }
     86              } while (--xsize);
   \   000000E4   019059E2           SUBS     R9,R9,#+1
   \   000000E8   EBFFFF1A           BNE      ??_DrawBitLine1BPP_1
   \   000000EC   230000EA           B        ??_DrawBitLine1BPP_3
     87              break;
     88            case LCD_DRAWMODE_XOR:;
     89              IndexMask = GUI_Context.apDevice[GUI_Context.SelLayer]->pColorConvAPI->pfGetIndexMask();
   \                     ??_DrawBitLine1BPP_2:
   \   000000F0   1100D5E5           LDRB     R0,[R5, #+17]
   \   000000F4   000185E0           ADD      R0,R5,R0, LSL #+2
   \   000000F8   480090E5           LDR      R0,[R0, #+72]
   \   000000FC   100090E5           LDR      R0,[R0, #+16]
   \   00000100   080090E5           LDR      R0,[R0, #+8]
   \   00000104   30FF2FE1           BLX      R0
   \   00000108   00A0A0E1           MOV      R10,R0
   \   0000010C   80B0A0E3           MOV      R11,#+128
     90              do {
     91                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_5:
   \   00000110   0000D8E5           LDRB     R0,[R8, #+0]
   \   00000114   5B0710E1           TST      R0,R11, ASR R7
   \   00000118   1100000A           BEQ      ??_DrawBitLine1BPP_6
   \   0000011C   1100D5E5           LDRB     R0,[R5, #+17]
   \   00000120   0420A0E1           MOV      R2,R4
   \   00000124   0610A0E1           MOV      R1,R6
   \   00000128   000185E0           ADD      R0,R5,R0, LSL #+2
   \   0000012C   480090E5           LDR      R0,[R0, #+72]
   \   00000130   0C3090E5           LDR      R3,[R0, #+12]
   \   00000134   143093E5           LDR      R3,[R3, #+20]
     92                  Pixel = LCDDEV_L0_GetPixelIndex(GUI_Context.apDevice[GUI_Context.SelLayer], x, y);
   \   00000138   33FF2FE1           BLX      R3
   \   0000013C   0010A0E1           MOV      R1,R0
   \   00000140   1100D5E5           LDRB     R0,[R5, #+17]
   \   00000144   01302AE0           EOR      R3,R10,R1
   \   00000148   0420A0E1           MOV      R2,R4
   \   0000014C   000185E0           ADD      R0,R5,R0, LSL #+2
   \   00000150   480090E5           LDR      R0,[R0, #+72]
   \   00000154   0610A0E1           MOV      R1,R6
   \   00000158   0CC090E5           LDR      R12,[R0, #+12]
   \   0000015C   18C09CE5           LDR      R12,[R12, #+24]
     93                  LCDDEV_L0_SetPixelIndex(GUI_Context.apDevice[GUI_Context.SelLayer], x, y, Pixel ^ IndexMask);
   \   00000160   3CFF2FE1           BLX      R12
     94                }
     95                x--;
     96                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_6:
   \   00000164   017087E2           ADD      R7,R7,#+1
   \   00000168   080057E3           CMP      R7,#+8
     97                  Diff = 0;
   \   0000016C   0070A003           MOVEQ    R7,#+0
     98                  p++;
   \   00000170   01808802           ADDEQ    R8,R8,#+1
   \   00000174   016046E2           SUB      R6,R6,#+1
     99                }
    100              } while (--xsize);
   \   00000178   019059E2           SUBS     R9,R9,#+1
   \   0000017C   E3FFFF1A           BNE      ??_DrawBitLine1BPP_5
    101              break;
    102            }
    103          }
   \                     ??_DrawBitLine1BPP_3:
   \   00000180   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000184   F08FBDE8           POP      {R4-R11,PC}      ;; return
    104          
    105          /*********************************************************************
    106          *
    107          *       _DrawBitLine2BPP
    108          */
    109          static void  _DrawBitLine2BPP(int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize) {
    110            LCD_PIXELINDEX Pixels, PixelIndex;
    111            int CurrentPixel, Shift, Index;
    112            tLCD_SetPixelAA * pfSetPixelAA;
    113            const int aConvTable[4] = {0, 5, 10, 15};
    114          
    115            Pixels = *p;
    116            CurrentPixel = Diff;
    117            x -= Diff;
    118            pfSetPixelAA = _GetpfSetPixel();
    119            do {
    120              Shift = (3 - CurrentPixel) << 1;
    121              Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    122              PixelIndex = *(aConvTable + Index);
    123              pfSetPixelAA(x, y, PixelIndex);
    124              x--;
    125              if (++CurrentPixel == 4) {
    126                CurrentPixel = 0;
    127                Pixels = *(++p);
    128              }
    129            } while (--xsize);
    130          }
    131          
    132          /*********************************************************************
    133          *
    134          *       _DrawBitLine4BPP
    135          */
    136          static void  _DrawBitLine4BPP(int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize) {
    137            LCD_PIXELINDEX Pixels;
    138            int CurrentPixel, Shift, Index;
    139            tLCD_SetPixelAA * pfSetPixelAA;
    140          
    141            Pixels = *p;
    142            CurrentPixel = Diff;
    143            x -= Diff;
    144            pfSetPixelAA = _GetpfSetPixel();
    145            do {
    146              Shift = (1 - CurrentPixel) << 2;
    147              Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    148              pfSetPixelAA(x, y, Index);
    149              x--;
    150              if (++CurrentPixel == 2) {
    151                CurrentPixel = 0;
    152                Pixels = *(++p);
    153              }
    154            } while (--xsize);
    155          }
    156          
    157          /*********************************************************************
    158          *
    159          *       _DrawBitmap
    160          *
    161          * Purpose:
    162          *   Draws a bitmap (1bpp) rotated by 180 degrees.
    163          */

   \                                 In section .text, align 4, keep-with-next
    164          static void _DrawBitmap(int x0, int y0,
    165                                  int xsize, int ysize,
    166                                  int BitsPerPixel, 
    167                                  int BytesPerLine,
    168                                  const U8 GUI_UNI_PTR * pData, int Diff,
    169                                  const LCD_PIXELINDEX * pTrans)
    170          {
   \                     _DrawBitmap:
   \   00000000   704F2DE9           PUSH     {R4-R6,R8-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0F002DE9           PUSH     {R0-R3}
   \   0000000C   1CD04DE2           SUB      SP,SP,#+28
    171            int i;
    172            /* Use _DrawBitLineXBPP */
    173            for (i = 0; i < ysize; i++) {
   \   00000010   28009DE5           LDR      R0,[SP, #+40]
   \   00000014   0010A0E3           MOV      R1,#+0
   \   00000018   08108DE5           STR      R1,[SP, #+8]
   \   0000001C   010050E3           CMP      R0,#+1
   \   00000020   770000BA           BLT      ??_DrawBitmap_2
   \   00000024   20409DE5           LDR      R4,[SP, #+32]
    174              switch (BitsPerPixel) {
   \                     ??_DrawBitmap_3:
   \   00000028   50009DE5           LDR      R0,[SP, #+80]
   \   0000002C   010050E2           SUBS     R0,R0,#+1
   \   00000030   0400000A           BEQ      ??_DrawBitmap_4
   \   00000034   010050E2           SUBS     R0,R0,#+1
   \   00000038   0C00000A           BEQ      ??_DrawBitmap_5
   \   0000003C   020050E2           SUBS     R0,R0,#+2
   \   00000040   3B00000A           BEQ      ??_DrawBitmap_6
   \   00000044   630000EA           B        ??_DrawBitmap_7
    175              case 1:
    176                _DrawBitLine1BPP(x0, y0 - i, pData, Diff, xsize, pTrans);
   \                     ??_DrawBitmap_4:
   \   00000048   60009DE5           LDR      R0,[SP, #+96]
   \   0000004C   5C309DE5           LDR      R3,[SP, #+92]
   \   00000050   04008DE5           STR      R0,[SP, #+4]
   \   00000054   24009DE5           LDR      R0,[SP, #+36]
   \   00000058   58209DE5           LDR      R2,[SP, #+88]
   \   0000005C   00008DE5           STR      R0,[SP, #+0]
   \   00000060   0410A0E1           MOV      R1,R4
   \   00000064   1C009DE5           LDR      R0,[SP, #+28]
   \   00000068   ........           BL       _DrawBitLine1BPP
    177                break;
   \   0000006C   590000EA           B        ??_DrawBitmap_7
    178              case 2:
    179                _DrawBitLine2BPP(x0, y0 - i, pData, Diff, xsize);
   \                     ??_DrawBitmap_5:
   \   00000070   ............       ADRL     R1,`?<Constant {0, 5, 10, 15}>`
   \              ....        
   \   00000078   24509DE5           LDR      R5,[SP, #+36]
   \   0000007C   0C50B1E8           LDM      R1!,{R2,R3,R12,LR}
   \   00000080   58609DE5           LDR      R6,[SP, #+88]
   \   00000084   0C008DE2           ADD      R0,SP,#+12
   \   00000088   0C50A0E8           STM      R0!,{R2,R3,R12,LR}
   \   0000008C   5C909DE5           LDR      R9,[SP, #+92]
   \   00000090   1C009DE5           LDR      R0,[SP, #+28]
   \   00000094   0080D6E5           LDRB     R8,[R6, #+0]
   \   00000098   09A040E0           SUB      R10,R0,R9
   \   0000009C   ........           LDR      R0,??DataTable4
   \   000000A0   1000D0E5           LDRB     R0,[R0, #+16]
   \   000000A4   030000E2           AND      R0,R0,#0x3
   \   000000A8   030050E3           CMP      R0,#+3
   \   000000AC   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_DrawBitmap_0:
   \   000000B0   0900008A           BHI      ??_DrawBitmap_8
   \   000000B4   060000EA           B        ??_DrawBitmap_9
   \   000000B8   010000EA           B        ??_DrawBitmap_10
   \   000000BC   020000EA           B        ??_DrawBitmap_11
   \   000000C0   FFFFFFEA           B        ??_DrawBitmap_10
   \                     ??_DrawBitmap_10:
   \   000000C4   ........           LDR      R11,??DataTable4_1
   \   000000C8   040000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_11:
   \   000000CC   ........           LDR      R11,??DataTable4_2
   \   000000D0   020000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_9:
   \   000000D4   ........           LDR      R11,??DataTable4_3
   \   000000D8   000000EA           B        ??_DrawBitmap_12
   \                     ??_DrawBitmap_8:
   \   000000DC   00B0A0E3           MOV      R11,#+0
   \                     ??_DrawBitmap_12:
   \   000000E0   030069E2           RSB      R0,R9,#+3
   \   000000E4   8000A0E1           LSL      R0,R0,#+1
   \   000000E8   0020A0E1           MOV      R2,R0
   \   000000EC   C010A0E3           MOV      R1,#+192
   \   000000F0   062062E2           RSB      R2,R2,#+6
   \   000000F4   511208E0           AND      R1,R8,R1, ASR R2
   \   000000F8   3100A0E1           LSR      R0,R1,R0
   \   000000FC   0C108DE2           ADD      R1,SP,#+12
   \   00000100   002191E7           LDR      R2,[R1, +R0, LSL #+2]
   \   00000104   0410A0E1           MOV      R1,R4
   \   00000108   FF2002E2           AND      R2,R2,#0xFF
   \   0000010C   0A00A0E1           MOV      R0,R10
   \   00000110   3BFF2FE1           BLX      R11
   \   00000114   019089E2           ADD      R9,R9,#+1
   \   00000118   040059E3           CMP      R9,#+4
   \   0000011C   0090A003           MOVEQ    R9,#+0
   \   00000120   0180F605           LDRBEQ   R8,[R6, #+1]!
   \   00000124   01A04AE2           SUB      R10,R10,#+1
   \   00000128   015055E2           SUBS     R5,R5,#+1
   \   0000012C   EBFFFF1A           BNE      ??_DrawBitmap_12
   \   00000130   280000EA           B        ??_DrawBitmap_7
    180                break;
    181              case 4:
    182                _DrawBitLine4BPP(x0, y0 - i, pData, Diff, xsize);
   \                     ??_DrawBitmap_6:
   \   00000134   5C909DE5           LDR      R9,[SP, #+92]
   \   00000138   1C009DE5           LDR      R0,[SP, #+28]
   \   0000013C   58609DE5           LDR      R6,[SP, #+88]
   \   00000140   09A040E0           SUB      R10,R0,R9
   \   00000144   ........           LDR      R0,??DataTable4
   \   00000148   24509DE5           LDR      R5,[SP, #+36]
   \   0000014C   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000150   0080D6E5           LDRB     R8,[R6, #+0]
   \   00000154   030000E2           AND      R0,R0,#0x3
   \   00000158   030050E3           CMP      R0,#+3
   \   0000015C   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_DrawBitmap_1:
   \   00000160   0900008A           BHI      ??_DrawBitmap_13
   \   00000164   060000EA           B        ??_DrawBitmap_14
   \   00000168   010000EA           B        ??_DrawBitmap_15
   \   0000016C   020000EA           B        ??_DrawBitmap_16
   \   00000170   FFFFFFEA           B        ??_DrawBitmap_15
   \                     ??_DrawBitmap_15:
   \   00000174   ........           LDR      R11,??DataTable4_1
   \   00000178   040000EA           B        ??_DrawBitmap_17
   \                     ??_DrawBitmap_16:
   \   0000017C   ........           LDR      R11,??DataTable4_2
   \   00000180   020000EA           B        ??_DrawBitmap_17
   \                     ??_DrawBitmap_14:
   \   00000184   ........           LDR      R11,??DataTable4_3
   \   00000188   000000EA           B        ??_DrawBitmap_17
   \                     ??_DrawBitmap_13:
   \   0000018C   00B0A0E3           MOV      R11,#+0
   \                     ??_DrawBitmap_17:
   \   00000190   010069E2           RSB      R0,R9,#+1
   \   00000194   0001A0E1           LSL      R0,R0,#+2
   \   00000198   0020A0E1           MOV      R2,R0
   \   0000019C   F010A0E3           MOV      R1,#+240
   \   000001A0   042062E2           RSB      R2,R2,#+4
   \   000001A4   511208E0           AND      R1,R8,R1, ASR R2
   \   000001A8   3120A0E1           LSR      R2,R1,R0
   \   000001AC   FF2002E2           AND      R2,R2,#0xFF
   \   000001B0   0410A0E1           MOV      R1,R4
   \   000001B4   0A00A0E1           MOV      R0,R10
   \   000001B8   3BFF2FE1           BLX      R11
   \   000001BC   019089E2           ADD      R9,R9,#+1
   \   000001C0   020059E3           CMP      R9,#+2
   \   000001C4   0090A003           MOVEQ    R9,#+0
   \   000001C8   0180F605           LDRBEQ   R8,[R6, #+1]!
   \   000001CC   01A04AE2           SUB      R10,R10,#+1
   \   000001D0   015055E2           SUBS     R5,R5,#+1
   \   000001D4   EDFFFF1A           BNE      ??_DrawBitmap_17
    183                break;
    184              }
    185              pData += BytesPerLine;
   \                     ??_DrawBitmap_7:
   \   000001D8   54009DE5           LDR      R0,[SP, #+84]
   \   000001DC   58109DE5           LDR      R1,[SP, #+88]
    186            }
   \   000001E0   014044E2           SUB      R4,R4,#+1
   \   000001E4   010080E0           ADD      R0,R0,R1
   \   000001E8   58008DE5           STR      R0,[SP, #+88]
   \   000001EC   08009DE5           LDR      R0,[SP, #+8]
   \   000001F0   28109DE5           LDR      R1,[SP, #+40]
   \   000001F4   010080E2           ADD      R0,R0,#+1
   \   000001F8   08008DE5           STR      R0,[SP, #+8]
   \   000001FC   010050E1           CMP      R0,R1
   \   00000200   88FFFFBA           BLT      ??_DrawBitmap_3
    187          }
   \                     ??_DrawBitmap_2:
   \   00000204   30D08DE2           ADD      SP,SP,#+48       ;; stack cleaning
   \   00000208   708FBDE8           POP      {R4-R6,R8-R11,PC}  ;; return
    188          
    189          /*********************************************************************
    190          *
    191          *       _Rect2TextRect
    192          *
    193          * Purpose:
    194          *   This function transforms a given rectangle (window coordinates)
    195          *   to the rectangle used to clip the text.
    196          */

   \                                 In section .text, align 4, keep-with-next
    197          static void _Rect2TextRect(GUI_RECT * pRect) {
    198            GUI_USE_PARA(pRect);
    199            /* nothing to do in case of rotating text by 180 degrees */
    200          }
   \                     _Rect2TextRect:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    201          
    202          /*********************************************************************
    203          *
    204          *       _TransformPoint180
    205          *
    206          * Purpose:
    207          *   This function transforms an unrotated point (window
    208          *   coordinates) into a rotated point in desktop coordinates
    209          *   and handles the rotation of the current text rectangle.
    210          */
    211          static void _TransformPoint180(int * pXPos, int * pYPos) {
    212            GUI_RECT ClientRect = {0};
    213            int xPos, yPos, xNumPixel, yNumPixel;
    214            /* Get the client rectangle */
    215            #if GUI_WINSUPPORT
    216              WM_GetWindowRect(&ClientRect);
    217            #else
    218              GUI_GetClientRect(&ClientRect);
    219            #endif
    220            xNumPixel = LCD_GetXSize() - 1;
    221            yNumPixel = LCD_GetYSize() - 1;
    222            if (ClientRect.x1 > xNumPixel) {
    223              ClientRect.x1 = xNumPixel;
    224            }
    225            if (ClientRect.y1 > yNumPixel) {
    226              ClientRect.y1 = yNumPixel;
    227            }
    228            /* Save old positions */
    229            xPos = *pXPos;
    230            yPos = *pYPos;
    231            /* Handle rotation of text rectangle */
    232            *pXPos = ClientRect.x0 + GUI_RectDispString.x1 - (xPos - GUI_RectDispString.x0);
    233            *pYPos = ClientRect.y0 + GUI_RectDispString.y1 - (yPos - GUI_RectDispString.y0);
    234          }
    235          
    236          /*********************************************************************
    237          *
    238          *       _DrawBitmap180
    239          */

   \                                 In section .text, align 4, keep-with-next
    240          static void _DrawBitmap180(int x0, int y0, int xsize, int ysize, int xMul, int yMul,
    241                                     int BitsPerPixel, int BytesPerLine,
    242                                     const U8 GUI_UNI_PTR * pPixel, const LCD_PIXELINDEX* pTrans)
    243          {
   \                     _DrawBitmap180:
   \   00000000   F44F2DE9           PUSH     {R2,R4-R11,LR}
   \   00000004   0060A0E1           MOV      R6,R0
   \   00000008   0170A0E1           MOV      R7,R1
   \   0000000C   0350A0E1           MOV      R5,R3
    244            U8  Data = 0;
    245            int x1, y1, Diff;
    246            /* Handle the optional Y-magnification */
    247            y1 = y0 + ysize - 1;
   \   00000010   070085E0           ADD      R0,R5,R7
   \   00000014   18D04DE2           SUB      SP,SP,#+24
   \   00000018   010040E2           SUB      R0,R0,#+1
   \   0000001C   08008DE5           STR      R0,[SP, #+8]
    248            x1 = x0 + xsize - 1;
   \   00000020   18009DE5           LDR      R0,[SP, #+24]
    249            /* Rotate positions */
    250            _TransformPoint180(&x0, &y0);
   \   00000024   ........           ADR      R9,`?<Constant {0}>`
   \   00000028   060080E0           ADD      R0,R0,R6
   \   0000002C   018040E2           SUB      R8,R0,#+1
   \   00000030   000099E5           LDR      R0,[R9, #+0]
   \   00000034   041099E5           LDR      R1,[R9, #+4]
   \   00000038   48409DE5           LDR      R4,[SP, #+72]
   \   0000003C   0D20A0E1           MOV      R2,SP
   \   00000040   030082E8           STM      R2,{R0,R1}
   \   00000044   0D00A0E1           MOV      R0,SP
   \   00000048   ........           BL       WM_GetWindowRect
   \   0000004C   ........           BL       LCD_GetXSize
   \   00000050   01A040E2           SUB      R10,R0,#+1
   \   00000054   ........           BL       LCD_GetYSize
   \   00000058   F410DDE1           LDRSH    R1,[SP, #+4]
   \   0000005C   010040E2           SUB      R0,R0,#+1
    251            _TransformPoint180(&x1, &y1);
   \   00000060   0D20A0E1           MOV      R2,SP
   \   00000064   01005AE1           CMP      R10,R1
   \   00000068   F610DDE1           LDRSH    R1,[SP, #+6]
   \   0000006C   B4A0CDB1           STRHLT   R10,[SP, #+4]
   \   00000070   ........           LDR      R10,??DataTable4_4
   \   00000074   010050E1           CMP      R0,R1
   \   00000078   B600CDB1           STRHLT   R0,[SP, #+6]
   \   0000007C   F000DDE1           LDRSH    R0,[SP, #+0]
   \   00000080   F410DAE1           LDRSH    R1,[R10, #+4]
   \   00000084   000081E0           ADD      R0,R1,R0
   \   00000088   F010DAE1           LDRSH    R1,[R10, #+0]
   \   0000008C   060040E0           SUB      R0,R0,R6
   \   00000090   000081E0           ADD      R0,R1,R0
   \   00000094   14008DE5           STR      R0,[SP, #+20]
   \   00000098   F200DDE1           LDRSH    R0,[SP, #+2]
   \   0000009C   F610DAE1           LDRSH    R1,[R10, #+6]
   \   000000A0   000081E0           ADD      R0,R1,R0
   \   000000A4   F210DAE1           LDRSH    R1,[R10, #+2]
   \   000000A8   070040E0           SUB      R0,R0,R7
   \   000000AC   00B081E0           ADD      R11,R1,R0
   \   000000B0   000099E5           LDR      R0,[R9, #+0]
   \   000000B4   041099E5           LDR      R1,[R9, #+4]
   \   000000B8   030082E8           STM      R2,{R0,R1}
   \   000000BC   0D00A0E1           MOV      R0,SP
   \   000000C0   ........           BL       WM_GetWindowRect
   \   000000C4   ........           BL       LCD_GetXSize
   \   000000C8   016040E2           SUB      R6,R0,#+1
   \   000000CC   ........           BL       LCD_GetYSize
   \   000000D0   F410DDE1           LDRSH    R1,[SP, #+4]
   \   000000D4   010040E2           SUB      R0,R0,#+1
   \   000000D8   F620DAE1           LDRSH    R2,[R10, #+6]
   \   000000DC   010056E1           CMP      R6,R1
   \   000000E0   F610DDE1           LDRSH    R1,[SP, #+6]
   \   000000E4   B460CDB1           STRHLT   R6,[SP, #+4]
   \   000000E8   010050E1           CMP      R0,R1
   \   000000EC   B600CDB1           STRHLT   R0,[SP, #+6]
   \   000000F0   F000DDE1           LDRSH    R0,[SP, #+0]
   \   000000F4   F410DAE1           LDRSH    R1,[R10, #+4]
   \   000000F8   000081E0           ADD      R0,R1,R0
   \   000000FC   F010DAE1           LDRSH    R1,[R10, #+0]
   \   00000100   080040E0           SUB      R0,R0,R8
   \   00000104   000081E0           ADD      R0,R1,R0
   \   00000108   F210DDE1           LDRSH    R1,[SP, #+2]
   \   0000010C   011082E0           ADD      R1,R2,R1
   \   00000110   08209DE5           LDR      R2,[SP, #+8]
   \   00000114   021041E0           SUB      R1,R1,R2
   \   00000118   F220DAE1           LDRSH    R2,[R10, #+2]
   \   0000011C   011082E0           ADD      R1,R2,R1
    252            /*  Handle BITMAP without magnification */
    253            if ((xMul == 1) && (yMul == 1)) {
   \   00000120   40209DE5           LDR      R2,[SP, #+64]
   \   00000124   010052E3           CMP      R2,#+1
   \   00000128   44209D05           LDREQ    R2,[SP, #+68]
   \   0000012C   01005203           CMPEQ    R2,#+1
   \   00000130   3E00001A           BNE      ??_DrawBitmap180_0
   \   00000134   ........           LDR      R2,??DataTable4
   \   00000138   FE30D2E1           LDRSH    R3,[R2, #+14]
   \   0000013C   0B0053E1           CMP      R3,R11
   \   00000140   060000AA           BGE      ??_DrawBitmap180_1
    254              /* Clip top */
    255              if (y0 > GUI_Context.ClipRect.y1) {
    256                Diff     = y0 - GUI_Context.ClipRect.y1;
   \   00000144   03204BE0           SUB      R2,R11,R3
    257                y0       = GUI_Context.ClipRect.y1;
   \   00000148   03B0A0E1           MOV      R11,R3
    258                pPixel  += Diff * BytesPerLine;
   \   0000014C   4C309DE5           LDR      R3,[SP, #+76]
   \   00000150   50C09DE5           LDR      R12,[SP, #+80]
   \   00000154   93C22CE0           MLA      R12,R3,R2,R12
    259                ysize   -= Diff;
   \   00000158   025045E0           SUB      R5,R5,R2
   \   0000015C   50C08DE5           STR      R12,[SP, #+80]
   \                     ??_DrawBitmap180_1:
   \   00000160   ........           LDR      R2,??DataTable4
   \   00000164   FA20D2E1           LDRSH    R2,[R2, #+10]
   \   00000168   020051E1           CMP      R1,R2
    260              }
    261              /* Clip bottom */
    262              if (y1 < GUI_Context.ClipRect.y0) {
    263                Diff = GUI_Context.ClipRect.y0 - y1;
    264                ysize -= Diff;
   \   0000016C   022045B0           SUBLT    R2,R5,R2
   \   00000170   025081B0           ADDLT    R5,R1,R2
    265              }
    266              if (ysize <= 0) {
   \   00000174   010055E3           CMP      R5,#+1
   \   00000178   760000BA           BLT      ??_DrawBitmap180_2
   \   0000017C   ........           LDR      R1,??DataTable4
   \   00000180   F810D1E1           LDRSH    R1,[R1, #+8]
   \   00000184   010050E1           CMP      R0,R1
   \   00000188   030000AA           BGE      ??_DrawBitmap180_3
    267                return;
    268              }
    269              /* Clip right side */
    270              if (x1 < GUI_Context.ClipRect.x0) {
    271                Diff = GUI_Context.ClipRect.x0 - x1;
    272                xsize   -= Diff;
   \   0000018C   18209DE5           LDR      R2,[SP, #+24]
   \   00000190   011042E0           SUB      R1,R2,R1
   \   00000194   010080E0           ADD      R0,R0,R1
   \   00000198   18008DE5           STR      R0,[SP, #+24]
    273              }
    274              /* Clip left side */
    275              Diff = 0;
   \                     ??_DrawBitmap180_3:
   \   0000019C   ........           LDR      R0,??DataTable4
   \   000001A0   14109DE5           LDR      R1,[SP, #+20]
   \   000001A4   FC00D0E1           LDRSH    R0,[R0, #+12]
   \   000001A8   0020A0E3           MOV      R2,#+0
   \   000001AC   010050E1           CMP      R0,R1
   \   000001B0   0D0000AA           BGE      ??_DrawBitmap180_4
    276              if (x0 > GUI_Context.ClipRect.x1) {
    277                Diff   = x0 - GUI_Context.ClipRect.x1;
   \   000001B4   002041E0           SUB      R2,R1,R0
    278                xsize -= Diff;
   \   000001B8   18009DE5           LDR      R0,[SP, #+24]
    279                switch (BitsPerPixel) {
   \   000001BC   010054E3           CMP      R4,#+1
   \   000001C0   020040E0           SUB      R0,R0,R2
   \   000001C4   18008DE5           STR      R0,[SP, #+24]
   \   000001C8   0700001A           BNE      ??_DrawBitmap180_4
    280                case 1:
    281                  pPixel += (Diff >> 3); x0 += (Diff >> 3) << 3; Diff &= 7;
   \   000001CC   50109DE5           LDR      R1,[SP, #+80]
   \   000001D0   C201A0E1           ASR      R0,R2,#+3
   \   000001D4   011080E0           ADD      R1,R0,R1
   \   000001D8   50108DE5           STR      R1,[SP, #+80]
   \   000001DC   14109DE5           LDR      R1,[SP, #+20]
   \   000001E0   072002E2           AND      R2,R2,#0x7
   \   000001E4   800181E0           ADD      R0,R1,R0, LSL #+3
   \   000001E8   14008DE5           STR      R0,[SP, #+20]
    282                  break;
    283                }
    284              }
    285              if (xsize <= 0) {
   \                     ??_DrawBitmap180_4:
   \   000001EC   18009DE5           LDR      R0,[SP, #+24]
   \   000001F0   010050E3           CMP      R0,#+1
   \   000001F4   570000BA           BLT      ??_DrawBitmap180_2
    286                return;
    287              }
    288              _DrawBitmap(x0, y0, xsize, ysize, BitsPerPixel, BytesPerLine, pPixel, Diff, pTrans);
   \   000001F8   54009DE5           LDR      R0,[SP, #+84]
   \   000001FC   0C208DE5           STR      R2,[SP, #+12]
   \   00000200   10008DE5           STR      R0,[SP, #+16]
   \   00000204   50009DE5           LDR      R0,[SP, #+80]
   \   00000208   00408DE5           STR      R4,[SP, #+0]
   \   0000020C   08008DE5           STR      R0,[SP, #+8]
   \   00000210   4C009DE5           LDR      R0,[SP, #+76]
   \   00000214   0530A0E1           MOV      R3,R5
   \   00000218   04008DE5           STR      R0,[SP, #+4]
   \   0000021C   18209DE5           LDR      R2,[SP, #+24]
   \   00000220   0B10A0E1           MOV      R1,R11
   \   00000224   14009DE5           LDR      R0,[SP, #+20]
   \   00000228   ........           BL       _DrawBitmap
   \   0000022C   490000EA           B        ??_DrawBitmap180_2
    289            } else {
    290              /* Handle BITMAP with magnification */
    291              int x, y;
    292              int yi;
    293              int Shift = 8 - BitsPerPixel;
   \                     ??_DrawBitmap180_0:
   \   00000230   080064E2           RSB      R0,R4,#+8
   \   00000234   08008DE5           STR      R0,[SP, #+8]
    294              for (y = y0, yi = 0; yi < ysize; yi++, y -= yMul, pPixel += BytesPerLine) {
   \   00000238   010055E3           CMP      R5,#+1
   \   0000023C   450000BA           BLT      ??_DrawBitmap180_2
   \   00000240   00508DE5           STR      R5,[SP, #+0]
    295                int yMax = y + yMul - 1;
   \                     ??_DrawBitmap180_5:
   \   00000244   44009DE5           LDR      R0,[SP, #+68]
   \   00000248   00008BE0           ADD      R0,R11,R0
   \   0000024C   015040E2           SUB      R5,R0,#+1
    296                /* Draw if within clip area (Optimization ... "if" is not required !) */
    297                if ((yMax >= GUI_Context.ClipRect.y0) && (y <= GUI_Context.ClipRect.y1)) {
   \   00000250   ........           LDR      R0,??DataTable4
   \   00000254   FA00D0E1           LDRSH    R0,[R0, #+10]
   \   00000258   000055E1           CMP      R5,R0
   \   0000025C   320000BA           BLT      ??_DrawBitmap180_6
   \   00000260   ........           LDR      R0,??DataTable4
   \   00000264   FE00D0E1           LDRSH    R0,[R0, #+14]
   \   00000268   0B0050E1           CMP      R0,R11
   \   0000026C   2E0000BA           BLT      ??_DrawBitmap180_6
    298                  int BitsLeft = 0;
    299                  int xi;
    300                  const U8 GUI_UNI_PTR * pDataLine = pPixel;
   \   00000270   50109DE5           LDR      R1,[SP, #+80]
    301                  for (x = x0, xi = 0; xi < xsize; xi++, x -= xMul) {
   \   00000274   18009DE5           LDR      R0,[SP, #+24]
   \   00000278   04108DE5           STR      R1,[SP, #+4]
   \   0000027C   14609DE5           LDR      R6,[SP, #+20]
   \   00000280   010050E3           CMP      R0,#+1
   \   00000284   280000BA           BLT      ??_DrawBitmap180_6
   \   00000288   18709DE5           LDR      R7,[SP, #+24]
   \   0000028C   010000EA           B        ??_DrawBitmap180_7
    302                    U8  Index;
    303                    if (!BitsLeft) {
   \                     ??_DrawBitmap180_8:
   \   00000290   000058E3           CMP      R8,#+0
   \   00000294   0300001A           BNE      ??_DrawBitmap180_9
    304                      Data = *pDataLine++;
   \                     ??_DrawBitmap180_7:
   \   00000298   04109DE5           LDR      R1,[SP, #+4]
    305                      BitsLeft =8;
   \   0000029C   0880A0E3           MOV      R8,#+8
   \   000002A0   0190D1E4           LDRB     R9,[R1], #+1
   \   000002A4   04108DE5           STR      R1,[SP, #+4]
    306                    }
    307                    Index = Data >> Shift;
   \                     ??_DrawBitmap180_9:
   \   000002A8   08109DE5           LDR      R1,[SP, #+8]
   \   000002AC   FF0009E2           AND      R0,R9,#0xFF
   \   000002B0   5001A0E1           ASR      R0,R0,R1
   \   000002B4   FF0000E2           AND      R0,R0,#0xFF
    308                    Data    <<= BitsPerPixel;
   \   000002B8   1994A0E1           LSL      R9,R9,R4
    309                    BitsLeft -= BitsPerPixel;
   \   000002BC   048048E0           SUB      R8,R8,R4
    310                    if (Index || ((GUI_Context.DrawMode & LCD_DRAWMODE_TRANS) == 0)) {
   \   000002C0   000050E3           CMP      R0,#+0
   \   000002C4   0300001A           BNE      ??_DrawBitmap180_10
   \   000002C8   ........           LDR      R1,??DataTable4
   \   000002CC   1010D1E5           LDRB     R1,[R1, #+16]
   \   000002D0   020011E3           TST      R1,#0x2
   \   000002D4   1000001A           BNE      ??_DrawBitmap180_11
    311                      LCD_PIXELINDEX OldColor = LCD__GetColorIndex();
   \                     ??_DrawBitmap180_10:
   \   000002D8   ........           LDR      R1,??DataTable4_5
    312                      if (pTrans) {
   \   000002DC   54209DE5           LDR      R2,[SP, #+84]
   \   000002E0   001091E5           LDR      R1,[R1, #+0]
   \   000002E4   000052E3           CMP      R2,#+0
    313                        LCD__SetColorIndex(*(pTrans + Index));
   \   000002E8   00019217           LDRNE    R0,[R2, +R0, LSL #+2]
   \   000002EC   00A091E5           LDR      R10,[R1, #+0]
    314                      } else {
    315                        LCD__SetColorIndex(Index);
   \   000002F0   000081E5           STR      R0,[R1, #+0]
    316                      }
    317                      LCD_FillRect(x - xMul + 1, y, x, yMax);
   \   000002F4   40009DE5           LDR      R0,[SP, #+64]
   \   000002F8   0530A0E1           MOV      R3,R5
   \   000002FC   000046E0           SUB      R0,R6,R0
   \   00000300   0620A0E1           MOV      R2,R6
   \   00000304   0B10A0E1           MOV      R1,R11
   \   00000308   010080E2           ADD      R0,R0,#+1
   \   0000030C   ........           BL       LCD_FillRect
    318                      LCD__SetColorIndex(OldColor);
   \   00000310   ........           LDR      R0,??DataTable4_5
   \   00000314   000090E5           LDR      R0,[R0, #+0]
   \   00000318   00A080E5           STR      R10,[R0, #+0]
    319                    }
    320                  }
   \                     ??_DrawBitmap180_11:
   \   0000031C   40009DE5           LDR      R0,[SP, #+64]
   \   00000320   017057E2           SUBS     R7,R7,#+1
   \   00000324   006046E0           SUB      R6,R6,R0
   \   00000328   D8FFFF1A           BNE      ??_DrawBitmap180_8
    321                }
    322              }
   \                     ??_DrawBitmap180_6:
   \   0000032C   44009DE5           LDR      R0,[SP, #+68]
   \   00000330   50109DE5           LDR      R1,[SP, #+80]
   \   00000334   00B04BE0           SUB      R11,R11,R0
   \   00000338   4C009DE5           LDR      R0,[SP, #+76]
   \   0000033C   010080E0           ADD      R0,R0,R1
   \   00000340   50008DE5           STR      R0,[SP, #+80]
   \   00000344   00009DE5           LDR      R0,[SP, #+0]
   \   00000348   010040E2           SUB      R0,R0,#+1
   \   0000034C   00008DE5           STR      R0,[SP, #+0]
   \   00000350   000050E3           CMP      R0,#+0
   \   00000354   BAFFFF1A           BNE      ??_DrawBitmap180_5
   \                     ??_DrawBitmap180_2:
   \   00000358   1CD08DE2           ADD      SP,SP,#+28       ;; stack cleaning
   \   0000035C   F08FBDE8           POP      {R4-R11,PC}      ;; return
    323            }
    324          }
    325          
    326          /*********************************************************************
    327          *
    328          *       Global data
    329          *
    330          **********************************************************************
    331          */
    332          /*********************************************************************
    333          *
    334          *       LCD_APIList180
    335          *
    336          * Purpose:
    337          *   Function pointer table for rotating text 180
    338          */

   \                                 In section .data, align 4
    339          tLCD_APIList LCD_APIList180 = {
   \                     LCD_APIList180:
   \   00000000   ............       DC32 _DrawBitmap180, _Rect2TextRect
   \              ....        

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   ........           DC32     LCD_SetPixelAA_Xor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   ........           DC32     LCD_SetPixelAA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   ........           DC32     LCD_SetPixelAA_NoTrans

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   ........           DC32     GUI_RectDispString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 5, 10, 15}>`:
   \   00000000                      ; Initializer data, 16 bytes
   \   00000000   000000000500       DC32 0, 5, 10, 15
   \              00000A000000
   \              0F000000    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   0000               DC16 0
   \   00000002   000000000000       DC8 0, 0, 0, 0, 0, 0
    340            (tLCD_DrawBitmap*)&_DrawBitmap180,
    341            &_Rect2TextRect
    342          };
    343          
    344          #else
    345          void LCD_Rotate180_C(void);
    346          void LCD_Rotate180_C(void){}
    347          #endif
    348          

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     _DrawBitLine1BPP     40
     _DrawBitmap          80
     _DrawBitmap180       64
     _Rect2TextRect        0


   Section sizes:

     Function/Label             Bytes
     --------------             -----
     _DrawBitLine1BPP            392
     _DrawBitmap                 524
     _Rect2TextRect                4
     _DrawBitmap180              864
     LCD_APIList180                8
     ??DataTable4                  4
     ??DataTable4_1                4
     ??DataTable4_2                4
     ??DataTable4_3                4
     ??DataTable4_4                4
     ??DataTable4_5                4
     ?<Constant {0, 5, 10, 15}>   16
     ?<Constant {0}>               8

 
     8 bytes in section .data
 1 832 bytes in section .text
 
 1 832 bytes of CODE memory
     8 bytes of DATA memory

Errors: none
Warnings: none
