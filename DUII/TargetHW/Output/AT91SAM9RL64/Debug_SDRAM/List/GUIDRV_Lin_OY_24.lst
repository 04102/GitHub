###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     14/Jul/2015  18:59:09 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_OY_24.c                  #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_OY_24.c -D DEBUG=1 -D    #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D                   #
#                    XIGNORE_TEMPERATURE -D BUILD_DEBUG_PORT -D PROFILER      #
#                    -lCN C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Li #
#                    st\ -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\ #
#                    Obj\ --debug --endian=little --cpu=ARM926EJ-S -e         #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\GU #
#                    IDRV_Lin_OY_24.lst                                       #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\GUI #
#                    DRV_Lin_OY_24.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDRV_Lin_OY_24.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDRV_Lin_OY_24.c
     19          Purpose     : Driver for accessing linear video memory
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stddef.h>
     24          
     25          #include "LCD_Private.h"
     26          #include "GUI_Private.h"
     27          #include "LCD_SIM.h"
     28          #include "LCD_ConfDefaults.h"
     29          
     30          #include "GUIDRV_Lin.h"
     31          
     32          #if (!defined(WIN32) | defined(LCD_SIMCONTROLLER))
     33          
     34          /*********************************************************************
     35          *
     36          *       Defines
     37          *
     38          **********************************************************************
     39          */
     40          #ifdef WIN32
     41            //
     42            // Simulation prototypes
     43            //
     44            U16  SIM_Lin_ReadMem16  (unsigned int Off);
     45            U32  SIM_Lin_ReadMem32  (unsigned int Off);
     46            U32  SIM_Lin_ReadMem32p (U32 * p);
     47            void SIM_Lin_WriteMem16 (unsigned int Off, U16 Data);
     48            void SIM_Lin_WriteMem32 (unsigned int Off, U32 Data);
     49            void SIM_Lin_WriteMem16p(U16 * p, U16 Data);
     50            void SIM_Lin_WriteMem32p(U32 * p, U32 Data);
     51            void SIM_Lin_memcpy     (void * pDst, const void * pSrc, int Len);
     52            void SIM_Lin_SetVRAMAddr(int LayerIndex, void * pVRAM);
     53            void SIM_Lin_SetVRAMSize(int LayerIndex, int xSize, int ySize);
     54            //
     55            // Access macro definition for internal simulation
     56            //
     57            #define LCD_READ_MEM16(VRAMAddr, Off)        SIM_Lin_ReadMem16(Off)
     58            #define LCD_READ_MEM32(VRAMAddr, Off)        SIM_Lin_ReadMem32(Off)
     59            #define LCD_READ_MEM32P(p)                   SIM_Lin_ReadMem32p(p)
     60            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) SIM_Lin_WriteMem16(Off, Data)
     61            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) SIM_Lin_WriteMem32(Off, Data)
     62            #define LCD_WRITE_MEM16P(p, Data)            SIM_Lin_WriteMem16p(p, Data)
     63            #define LCD_WRITE_MEM32P(p, Data)            SIM_Lin_WriteMem32p(p, Data)
     64            #undef  GUI_MEMCPY
     65            #define GUI_MEMCPY(pDst, pSrc, Len) SIM_Lin_memcpy(pDst, pSrc, Len)
     66          #else
     67            //
     68            // Access macro definition for hardware
     69            //
     70            #define LCD_READ_MEM16(VRAMAddr, Off)        (*((U16 *)VRAMAddr + (U32)Off))
     71            #define LCD_READ_MEM32(VRAMAddr, Off)        (*((U32 *)VRAMAddr + (U32)Off))
     72            #define LCD_READ_MEM32P(p)                   (*((U32 *)p))
     73            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) *((U16 *)VRAMAddr + (U32)Off) = Data
     74            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) *((U32 *)VRAMAddr + (U32)Off) = Data
     75            #define LCD_WRITE_MEM16P(p, Data)            *((U16 *)p) = Data
     76            #define LCD_WRITE_MEM32P(p, Data)            *((U32 *)p) = Data
     77          #endif
     78          
     79          #define WRITE_MEM16(VRAMAddr, Off, Data) LCD_WRITE_MEM16(VRAMAddr, Off, Data)
     80          #define WRITE_MEM32(VRAMAddr, Off, Data) LCD_WRITE_MEM32(VRAMAddr, Off, Data)
     81          #define READ_MEM16(VRAMAddr, Off)        LCD_READ_MEM16(VRAMAddr, Off)
     82          #define READ_MEM32(VRAMAddr, Off)        LCD_READ_MEM32(VRAMAddr, Off)
     83          #define READ_MEM32P(p)                   LCD_READ_MEM32P(p)
     84          #define WRITE_MEM16P(p, Data)            LCD_WRITE_MEM16P(p, Data)
     85          #define WRITE_MEM32P(p, Data)            LCD_WRITE_MEM32P(p, Data)
     86          
     87          #define OFF2PTR16(VRAMAddr, Off)     (U16 *)((U8 *)VRAMAddr + (Off << 1))
     88          #define OFF2PTR32(VRAMAddr, Off)     (U32 *)((U8 *)VRAMAddr + (Off << 2))
     89          
     90          #define XY2OFF32(vxSizePhys, x, y)      (((U32)(y * (vxSizePhys + vxSizePhys + vxSizePhys)) + ((unsigned)(x + x + x))) >> 2)
     91          
     92          /*********************************************************************
     93          *
     94          *       Types
     95          *
     96          **********************************************************************
     97          */
     98          typedef struct {
     99            U32 VRAMAddr;
    100            int xSize, ySize;
    101            int vxSize, vySize;
    102            int vxSizePhys;
    103            int xPos, yPos;
    104            int Alpha;
    105            int IsVisible;
    106            void (* pfFillRect)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex);
    107          } DRIVER_CONTEXT;
    108          
    109          /*********************************************************************
    110          *
    111          *       Static functions
    112          *
    113          **********************************************************************
    114          */
    115          /*********************************************************************
    116          *
    117          *       _SetPixelIndex
    118          *
    119          * Purpose:
    120          *   Sets the index of the given pixel. The upper layers
    121          *   calling this routine make sure that the coordinates are in range, so
    122          *   that no check on the parameters needs to be performed.
    123          */

   \                                 In section .text, align 4, keep-with-next
    124          static void _SetPixelIndex(GUI_DEVICE * pDevice, int x, int y, int PixelIndex) {
   \                     _SetPixelIndex:
   \   00000000   00402DE9           PUSH     {LR}
    125            DRIVER_CONTEXT * pContext;
    126            U32 Off, Data;
    127          
    128            //
    129            // Get context
    130            //
    131            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000004   080090E5           LDR      R0,[R0, #+8]
    132            //
    133            // Mirror y
    134            //
    135            y = (pContext->vySize - 1 - (y));
    136            //
    137            // Write into hardware
    138            //
    139            Off      = XY2OFF32(pContext->vxSizePhys, x, y);
    140            Data     = READ_MEM32(pContext->VRAMAddr, Off);
    141            PixelIndex &= 0xFFFFFF;
   \   00000008   0334A0E1           LSL      R3,R3,#+8
   \   0000000C   10C090E5           LDR      R12,[R0, #+16]
   \   00000010   2334A0E1           LSR      R3,R3,#+8
   \   00000014   01C04CE2           SUB      R12,R12,#+1
   \   00000018   02204CE0           SUB      R2,R12,R2
   \   0000001C   14C090E5           LDR      R12,[R0, #+20]
   \   00000020   9C0202E0           MUL      R2,R12,R2
   \   00000024   81C081E0           ADD      R12,R1,R1, LSL #+1
   \   00000028   822082E0           ADD      R2,R2,R2, LSL #+1
   \   0000002C   02208CE0           ADD      R2,R12,R2
   \   00000030   00C090E5           LDR      R12,[R0, #+0]
   \   00000034   2221A0E1           LSR      R2,R2,#+2
    142            switch (x & 3) {
   \   00000038   031001E2           AND      R1,R1,#0x3
   \   0000003C   02E19CE7           LDR      LR,[R12, +R2, LSL #+2]
   \   00000040   030051E3           CMP      R1,#+3
   \   00000044   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_SetPixelIndex_0:
   \   00000048   1D00008A           BHI      ??_SetPixelIndex_1
   \   0000004C   020000EA           B        ??_SetPixelIndex_2
   \   00000050   040000EA           B        ??_SetPixelIndex_3
   \   00000054   0E0000EA           B        ??_SetPixelIndex_4
   \   00000058   170000EA           B        ??_SetPixelIndex_5
    143            case 0:
    144              Data &= 0xFF000000;
    145              Data |= PixelIndex;
   \                     ??_SetPixelIndex_2:
   \   0000005C   FF140EE2           AND      R1,LR,#0xFF000000
   \   00000060   01E083E1           ORR      LR,R3,R1
    146              break;
   \   00000064   160000EA           B        ??_SetPixelIndex_1
    147            case 1:
    148              Data &= 0x00FFFFFF;
    149              Data |= (PixelIndex << 24);
    150              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_SetPixelIndex_3:
   \   00000068   0E14A0E1           LSL      R1,LR,#+8
   \   0000006C   03ECA0E1           LSL      LR,R3,#+24
   \   00000070   21148EE1           ORR      R1,LR,R1, LSR #+8
   \   00000074   02118CE7           STR      R1,[R12, +R2, LSL #+2]
    151              Off++;
    152              Data = READ_MEM32(pContext->VRAMAddr, Off);
    153              Data &= 0xFFFF0000;
    154              Data |= (PixelIndex >> 8);
   \   00000078   001090E5           LDR      R1,[R0, #+0]
   \   0000007C   012082E2           ADD      R2,R2,#+1
   \   00000080   021191E7           LDR      R1,[R1, +R2, LSL #+2]
   \   00000084   4334A0E1           ASR      R3,R3,#+8
   \   00000088   2118A0E1           LSR      R1,R1,#+16
   \   0000008C   01E883E1           ORR      LR,R3,R1, LSL #+16
    155              break;
   \   00000090   0B0000EA           B        ??_SetPixelIndex_1
    156            case 2:
    157              Data &= 0x0000FFFF;
    158              Data |= (PixelIndex << 16);
    159              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_SetPixelIndex_4:
   \   00000094   0E18A0E1           LSL      R1,LR,#+16
   \   00000098   03E8A0E1           LSL      LR,R3,#+16
   \   0000009C   21188EE1           ORR      R1,LR,R1, LSR #+16
   \   000000A0   02118CE7           STR      R1,[R12, +R2, LSL #+2]
    160              Off++;
    161              Data = READ_MEM32(pContext->VRAMAddr, Off);
    162              Data &= 0xFFFFFF00;
    163              Data |= (PixelIndex >> 16);
   \   000000A4   001090E5           LDR      R1,[R0, #+0]
   \   000000A8   012082E2           ADD      R2,R2,#+1
   \   000000AC   021191E7           LDR      R1,[R1, +R2, LSL #+2]
   \   000000B0   FF10C1E3           BIC      R1,R1,#0xFF
   \   000000B4   43E881E1           ORR      LR,R1,R3, ASR #+16
    164              break;
   \   000000B8   010000EA           B        ??_SetPixelIndex_1
    165            case 3:
    166              Data &= 0x000000FF;
    167              Data |= (PixelIndex << 8);
   \                     ??_SetPixelIndex_5:
   \   000000BC   FF100EE2           AND      R1,LR,#0xFF
   \   000000C0   03E481E1           ORR      LR,R1,R3, LSL #+8
    168              break;
    169            }
    170            WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_SetPixelIndex_1:
   \   000000C4   000090E5           LDR      R0,[R0, #+0]
   \   000000C8   02E180E7           STR      LR,[R0, +R2, LSL #+2]
    171          }
   \   000000CC   0080BDE8           POP      {PC}             ;; return
    172          
    173          /*********************************************************************
    174          *
    175          *       _GetPixelIndex
    176          *
    177          * Purpose:
    178          *   Returns the index of the given pixel. The upper layers
    179          *   calling this routine make sure that the coordinates are in range, so
    180          *   that no check on the parameters needs to be performed.
    181          */

   \                                 In section .text, align 4, keep-with-next
    182          static unsigned int _GetPixelIndex(GUI_DEVICE * pDevice, int x, int y) {
    183            DRIVER_CONTEXT * pContext;
    184            U32 Off, Data, PixelIndex;
    185          
    186            //
    187            // Get context
    188            //
    189            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetPixelIndex:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    190            //
    191            // Mirror y
    192            //
    193            y = (pContext->vySize - 1 - (y));
    194            //
    195            // Read from hardware
    196            //
    197            Off      = XY2OFF32(pContext->vxSizePhys, x, y);
   \   00000004   10C090E5           LDR      R12,[R0, #+16]
   \   00000008   01C04CE2           SUB      R12,R12,#+1
   \   0000000C   02304CE0           SUB      R3,R12,R2
   \   00000010   14C090E5           LDR      R12,[R0, #+20]
   \   00000014   9C0303E0           MUL      R3,R12,R3
   \   00000018   81C081E0           ADD      R12,R1,R1, LSL #+1
   \   0000001C   833083E0           ADD      R3,R3,R3, LSL #+1
   \   00000020   03308CE0           ADD      R3,R12,R3
    198            Data     = READ_MEM32(pContext->VRAMAddr, Off);
   \   00000024   00C090E5           LDR      R12,[R0, #+0]
   \   00000028   2331A0E1           LSR      R3,R3,#+2
    199            switch (x & 3) {
   \   0000002C   031001E2           AND      R1,R1,#0x3
   \   00000030   03019CE7           LDR      R0,[R12, +R3, LSL #+2]
   \   00000034   030051E3           CMP      R1,#+3
   \   00000038   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetPixelIndex_0:
   \   0000003C   1200008A           BHI      ??_GetPixelIndex_1
   \   00000040   020000EA           B        ??_GetPixelIndex_2
   \   00000044   030000EA           B        ??_GetPixelIndex_3
   \   00000048   090000EA           B        ??_GetPixelIndex_4
   \   0000004C   0D0000EA           B        ??_GetPixelIndex_5
    200            case 0:
    201              PixelIndex  = (Data & 0x00FFFFFF);
   \                     ??_GetPixelIndex_2:
   \   00000050   0004A0E1           LSL      R0,R0,#+8
   \   00000054   0B0000EA           B        ??_GetPixelIndex_5
    202              break;
    203            case 1:
    204              PixelIndex  = (Data & 0xFF000000) >> 24;
    205              Off++;
    206              Data        = READ_MEM32(pContext->VRAMAddr, Off);
    207              PixelIndex |= (Data & 0x0000FFFF) << 8;
   \                     ??_GetPixelIndex_3:
   \   00000058   03118CE0           ADD      R1,R12,R3, LSL #+2
   \   0000005C   B410D1E1           LDRH     R1,[R1, #+4]
   \   00000060   0118A0E1           LSL      R1,R1,#+16
   \   00000064   2118A0E1           LSR      R1,R1,#+16
   \   00000068   0114A0E1           LSL      R1,R1,#+8
   \   0000006C   202C81E1           ORR      R2,R1,R0, LSR #+24
    208              break;
   \   00000070   050000EA           B        ??_GetPixelIndex_1
    209            case 2:
    210              PixelIndex  = (Data & 0xFFFF0000) >> 16;
    211              Off++;
    212              Data        = READ_MEM32(pContext->VRAMAddr, Off);
    213              PixelIndex |= (Data & 0x000000FF) << 16;
   \                     ??_GetPixelIndex_4:
   \   00000074   03118CE0           ADD      R1,R12,R3, LSL #+2
   \   00000078   0410D1E5           LDRB     R1,[R1, #+4]
   \   0000007C   0118A0E1           LSL      R1,R1,#+16
   \   00000080   202881E1           ORR      R2,R1,R0, LSR #+16
    214              break;
   \   00000084   000000EA           B        ??_GetPixelIndex_1
    215            case 3:
    216              PixelIndex  = (Data & 0xFFFFFF00) >> 8;
   \                     ??_GetPixelIndex_5:
   \   00000088   2024A0E1           LSR      R2,R0,#+8
    217              break;
    218            }
    219            return PixelIndex;
   \                     ??_GetPixelIndex_1:
   \   0000008C   0200A0E1           MOV      R0,R2
   \   00000090   1EFF2FE1           BX       LR               ;; return
    220          }
    221          
    222          /*********************************************************************
    223          *
    224          *       _XorPixel
    225          */

   \                                 In section .text, align 4, keep-with-next
    226          static void _XorPixel(GUI_DEVICE * pDevice, int x, int y) {
   \                     _XorPixel:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    227            LCD_PIXELINDEX PixelIndex;
    228            LCD_PIXELINDEX IndexMask;
    229          
    230            PixelIndex = _GetPixelIndex(pDevice, x, y);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   101090E5           LDR      R1,[R0, #+16]
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   011041E2           SUB      R1,R1,#+1
   \   0000001C   142090E5           LDR      R2,[R0, #+20]
   \   00000020   061041E0           SUB      R1,R1,R6
   \   00000024   920101E0           MUL      R1,R2,R1
   \   00000028   852085E0           ADD      R2,R5,R5, LSL #+1
   \   0000002C   811081E0           ADD      R1,R1,R1, LSL #+1
   \   00000030   011082E0           ADD      R1,R2,R1
   \   00000034   002090E5           LDR      R2,[R0, #+0]
   \   00000038   2111A0E1           LSR      R1,R1,#+2
   \   0000003C   033005E2           AND      R3,R5,#0x3
   \   00000040   04D04DE2           SUB      SP,SP,#+4
   \   00000044   010192E7           LDR      R0,[R2, +R1, LSL #+2]
   \   00000048   030053E3           CMP      R3,#+3
   \   0000004C   03F18F90           ADDLS    PC,PC,R3, LSL #+2
   \                     ??_XorPixel_0:
   \   00000050   1100008A           BHI      ??_XorPixel_1
   \   00000054   0E0000EA           B        ??_XorPixel_2
   \   00000058   060000EA           B        ??_XorPixel_3
   \   0000005C   000000EA           B        ??_XorPixel_4
   \   00000060   0C0000EA           B        ??_XorPixel_5
   \                     ??_XorPixel_4:
   \   00000064   011182E0           ADD      R1,R2,R1, LSL #+2
   \   00000068   0410D1E5           LDRB     R1,[R1, #+4]
   \   0000006C   0118A0E1           LSL      R1,R1,#+16
   \   00000070   207881E1           ORR      R7,R1,R0, LSR #+16
   \   00000074   080000EA           B        ??_XorPixel_1
   \                     ??_XorPixel_3:
   \   00000078   011182E0           ADD      R1,R2,R1, LSL #+2
   \   0000007C   B410D1E1           LDRH     R1,[R1, #+4]
   \   00000080   0118A0E1           LSL      R1,R1,#+16
   \   00000084   2118A0E1           LSR      R1,R1,#+16
   \   00000088   0114A0E1           LSL      R1,R1,#+8
   \   0000008C   207C81E1           ORR      R7,R1,R0, LSR #+24
   \   00000090   010000EA           B        ??_XorPixel_1
   \                     ??_XorPixel_2:
   \   00000094   0004A0E1           LSL      R0,R0,#+8
   \                     ??_XorPixel_5:
   \   00000098   2074A0E1           LSR      R7,R0,#+8
    231            IndexMask  = pDevice->pColorConvAPI->pfGetIndexMask();
   \                     ??_XorPixel_1:
   \   0000009C   100094E5           LDR      R0,[R4, #+16]
   \   000000A0   080090E5           LDR      R0,[R0, #+8]
   \   000000A4   30FF2FE1           BLX      R0
    232            _SetPixelIndex(pDevice, x, y, PixelIndex ^ IndexMask);
   \   000000A8   073020E0           EOR      R3,R0,R7
   \   000000AC   0620A0E1           MOV      R2,R6
   \   000000B0   0510A0E1           MOV      R1,R5
   \   000000B4   0400A0E1           MOV      R0,R4
   \   000000B8   04D08DE2           ADD      SP,SP,#+4
   \   000000BC   F040BDE8           POP      {R4-R7,LR}
   \   000000C0   ........           B        _SetPixelIndex   ;; tailcall
    233          }
    234          
    235          /*********************************************************************
    236          *
    237          *       _DrawHLine
    238          */

   \                                 In section .text, align 4, keep-with-next
    239          static void _DrawHLine  (GUI_DEVICE * pDevice, int x0, int y,  int x1) {
   \                     _DrawHLine:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0070A0E1           MOV      R7,R0
    240            DRIVER_CONTEXT * pContext;
    241            int Off, RemPixels, Odd;
    242            U32 Data;
    243            LCD_PIXELINDEX ColorIndex;
    244          
    245            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable12
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0150A0E1           MOV      R5,R1
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   0340A0E1           MOV      R4,R3
   \   00000020   010010E3           TST      R0,#0x1
   \   00000024   3000000A           BEQ      ??_DrawHLine_1
   \   00000028   050054E1           CMP      R4,R5
   \   0000002C   9D0000BA           BLT      ??_DrawHLine_2
   \   00000030   FF80A0E3           MOV      R8,#+255
   \   00000034   FF8C88E3           ORR      R8,R8,#0xFF00
    246              for (; x0 <= x1; x0++) {
    247                _XorPixel(pDevice, x0, y);
   \                     ??_DrawHLine_3:
   \   00000038   080097E5           LDR      R0,[R7, #+8]
   \   0000003C   033005E2           AND      R3,R5,#0x3
   \   00000040   102090E5           LDR      R2,[R0, #+16]
   \   00000044   141090E5           LDR      R1,[R0, #+20]
   \   00000048   012042E2           SUB      R2,R2,#+1
   \   0000004C   062042E0           SUB      R2,R2,R6
   \   00000050   920101E0           MUL      R1,R2,R1
   \   00000054   852085E0           ADD      R2,R5,R5, LSL #+1
   \   00000058   811081E0           ADD      R1,R1,R1, LSL #+1
   \   0000005C   011082E0           ADD      R1,R2,R1
   \   00000060   002090E5           LDR      R2,[R0, #+0]
   \   00000064   2111A0E1           LSR      R1,R1,#+2
   \   00000068   010192E7           LDR      R0,[R2, +R1, LSL #+2]
   \   0000006C   030053E3           CMP      R3,#+3
   \   00000070   03F18F90           ADDLS    PC,PC,R3, LSL #+2
   \                     ??_DrawHLine_0:
   \   00000074   1000008A           BHI      ??_DrawHLine_4
   \   00000078   0D0000EA           B        ??_DrawHLine_5
   \   0000007C   060000EA           B        ??_DrawHLine_6
   \   00000080   000000EA           B        ??_DrawHLine_7
   \   00000084   0B0000EA           B        ??_DrawHLine_8
   \                     ??_DrawHLine_7:
   \   00000088   011182E0           ADD      R1,R2,R1, LSL #+2
   \   0000008C   0410D1E5           LDRB     R1,[R1, #+4]
   \   00000090   0118A0E1           LSL      R1,R1,#+16
   \   00000094   209881E1           ORR      R9,R1,R0, LSR #+16
   \   00000098   070000EA           B        ??_DrawHLine_4
   \                     ??_DrawHLine_6:
   \   0000009C   011182E0           ADD      R1,R2,R1, LSL #+2
   \   000000A0   041091E5           LDR      R1,[R1, #+4]
   \   000000A4   011008E0           AND      R1,R8,R1
   \   000000A8   0114A0E1           LSL      R1,R1,#+8
   \   000000AC   209C81E1           ORR      R9,R1,R0, LSR #+24
   \   000000B0   010000EA           B        ??_DrawHLine_4
   \                     ??_DrawHLine_5:
   \   000000B4   0004A0E1           LSL      R0,R0,#+8
   \                     ??_DrawHLine_8:
   \   000000B8   2094A0E1           LSR      R9,R0,#+8
   \                     ??_DrawHLine_4:
   \   000000BC   100097E5           LDR      R0,[R7, #+16]
   \   000000C0   080090E5           LDR      R0,[R0, #+8]
   \   000000C4   30FF2FE1           BLX      R0
   \   000000C8   093020E0           EOR      R3,R0,R9
   \   000000CC   0620A0E1           MOV      R2,R6
   \   000000D0   0510A0E1           MOV      R1,R5
   \   000000D4   0700A0E1           MOV      R0,R7
   \   000000D8   ........           BL       _SetPixelIndex
    248              }
   \   000000DC   015085E2           ADD      R5,R5,#+1
   \   000000E0   050054E1           CMP      R4,R5
   \   000000E4   D3FFFFAA           BGE      ??_DrawHLine_3
   \   000000E8   6E0000EA           B        ??_DrawHLine_2
    249            } else {
    250              ColorIndex = LCD__GetColorIndex();
    251              //
    252              // Get context
    253              //
    254              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     ??_DrawHLine_1:
   \   000000EC   081097E5           LDR      R1,[R7, #+8]
   \   000000F0   ........           LDR      R0,??DataTable13
    255              //
    256              // Mirror y
    257              //
    258              y = (pContext->vySize - 1 - (y));
    259              Off = XY2OFF32(pContext->vxSizePhys, x0, y);
   \   000000F4   102091E5           LDR      R2,[R1, #+16]
   \   000000F8   143091E5           LDR      R3,[R1, #+20]
   \   000000FC   012042E2           SUB      R2,R2,#+1
   \   00000100   062042E0           SUB      R2,R2,R6
   \   00000104   930202E0           MUL      R2,R3,R2
   \   00000108   853085E0           ADD      R3,R5,R5, LSL #+1
   \   0000010C   822082E0           ADD      R2,R2,R2, LSL #+1
   \   00000110   000090E5           LDR      R0,[R0, #+0]
   \   00000114   022083E0           ADD      R2,R3,R2
    260              RemPixels = x1 - x0 + 1;
   \   00000118   053044E0           SUB      R3,R4,R5
   \   0000011C   000090E5           LDR      R0,[R0, #+0]
   \   00000120   2221A0E1           LSR      R2,R2,#+2
   \   00000124   013083E2           ADD      R3,R3,#+1
    261              //
    262              // First triple DWORD
    263              //
    264              Odd = x0 & 3;
   \   00000128   03C015E2           ANDS     R12,R5,#0x3
    265              if (Odd) {
   \   0000012C   2900000A           BEQ      ??_DrawHLine_9
    266                Data  = READ_MEM32(pContext->VRAMAddr, Off);
   \   00000130   00E091E5           LDR      LR,[R1, #+0]
    267                switch (Odd) {
   \   00000134   01005CE3           CMP      R12,#+1
   \   00000138   02419EE7           LDR      R4,[LR, +R2, LSL #+2]
   \   0000013C   0400000A           BEQ      ??_DrawHLine_10
   \   00000140   2400003A           BCC      ??_DrawHLine_9
   \   00000144   03005CE3           CMP      R12,#+3
   \   00000148   1C00000A           BEQ      ??_DrawHLine_11
   \   0000014C   0F00003A           BCC      ??_DrawHLine_12
   \   00000150   200000EA           B        ??_DrawHLine_9
    268                case 1:
    269                  Data &= 0x00FFFFFF;
    270                  Data |= ColorIndex << 24;
    271                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_10:
   \   00000154   04C4A0E1           LSL      R12,R4,#+8
   \   00000158   004CA0E1           LSL      R4,R0,#+24
   \   0000015C   2CC484E1           ORR      R12,R4,R12, LSR #+8
   \   00000160   02C18EE7           STR      R12,[LR, +R2, LSL #+2]
    272                  Off++;
    273                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    274                  Data &= 0xFFFF0000;
    275                  Data |= ColorIndex >> 8;
   \   00000164   00C091E5           LDR      R12,[R1, #+0]
   \   00000168   012082E2           ADD      R2,R2,#+1
   \   0000016C   02C19CE7           LDR      R12,[R12, +R2, LSL #+2]
   \   00000170   20E4A0E1           LSR      LR,R0,#+8
   \   00000174   2CC8A0E1           LSR      R12,R12,#+16
   \   00000178   0C488EE1           ORR      R4,LR,R12, LSL #+16
    276                  RemPixels--;
   \   0000017C   013053E2           SUBS     R3,R3,#+1
    277                  if (!RemPixels) {
   \   00000180   0200001A           BNE      ??_DrawHLine_12
    278                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_13:
   \   00000184   00C091E5           LDR      R12,[R1, #+0]
   \   00000188   02418CE7           STR      R4,[R12, +R2, LSL #+2]
    279                    break;
   \   0000018C   110000EA           B        ??_DrawHLine_9
    280                  }
    281                  //
    282                  // no break at this position required...
    283                  //
    284                case 2:
    285                  Data &= 0x0000FFFF;
    286                  Data |= ColorIndex << 16;
    287                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_12:
   \   00000190   04C8A0E1           LSL      R12,R4,#+16
   \   00000194   00E8A0E1           LSL      LR,R0,#+16
   \   00000198   2CC88EE1           ORR      R12,LR,R12, LSR #+16
   \   0000019C   00E091E5           LDR      LR,[R1, #+0]
    288                  Off++;
    289                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    290                  Data &= 0xFFFFFF00;
    291                  Data |= ColorIndex >> 16;
    292                  RemPixels--;
   \   000001A0   013053E2           SUBS     R3,R3,#+1
   \   000001A4   02C18EE7           STR      R12,[LR, +R2, LSL #+2]
   \   000001A8   00C091E5           LDR      R12,[R1, #+0]
   \   000001AC   012082E2           ADD      R2,R2,#+1
   \   000001B0   02C19CE7           LDR      R12,[R12, +R2, LSL #+2]
   \   000001B4   FFC0CCE3           BIC      R12,R12,#0xFF
   \   000001B8   20488CE1           ORR      R4,R12,R0, LSR #+16
    293                  if (!RemPixels) {
   \   000001BC   F0FFFF0A           BEQ      ??_DrawHLine_13
    294                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    295                    break;
    296                  }
    297                  //
    298                  // no break at this position required...
    299                  //
    300                case 3:
    301                  Data &= 0x000000FF;
    302                  Data |= ColorIndex << 8;
    303                  RemPixels--;
    304                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_11:
   \   000001C0   FFC004E2           AND      R12,R4,#0xFF
   \   000001C4   00E091E5           LDR      LR,[R1, #+0]
   \   000001C8   00C48CE1           ORR      R12,R12,R0, LSL #+8
   \   000001CC   02C18EE7           STR      R12,[LR, +R2, LSL #+2]
   \   000001D0   013043E2           SUB      R3,R3,#+1
    305                  Off++;
   \   000001D4   012082E2           ADD      R2,R2,#+1
    306                }
    307              }
    308              //
    309              // Complete triple DWORDS
    310              //
    311              if (RemPixels >= 4) {
   \                     ??_DrawHLine_9:
   \   000001D8   040053E3           CMP      R3,#+4
   \   000001DC   100000BA           BLT      ??_DrawHLine_14
    312                U32 Data0, Data1, Data2;
    313                Data0 = (ColorIndex      ) | (ColorIndex << 24);
    314                Data1 = (ColorIndex >>  8) | (ColorIndex << 16);
   \   000001E0   00E8A0E1           LSL      LR,R0,#+16
    315                Data2 = (ColorIndex >> 16) | (ColorIndex <<  8);
   \   000001E4   0044A0E1           LSL      R4,R0,#+8
   \   000001E8   00CC80E1           ORR      R12,R0,R0, LSL #+24
   \   000001EC   20E48EE1           ORR      LR,LR,R0, LSR #+8
   \   000001F0   204884E1           ORR      R4,R4,R0, LSR #+16
    316                do {
    317                  WRITE_MEM32(pContext->VRAMAddr, Off + 0, Data0);
   \                     ??_DrawHLine_15:
   \   000001F4   005091E5           LDR      R5,[R1, #+0]
    318                  WRITE_MEM32(pContext->VRAMAddr, Off + 1, Data1);
    319                  WRITE_MEM32(pContext->VRAMAddr, Off + 2, Data2);
    320                  Off += 3;
    321                } while ((RemPixels -= 4) >= 4);
   \   000001F8   043043E2           SUB      R3,R3,#+4
   \   000001FC   02C185E7           STR      R12,[R5, +R2, LSL #+2]
   \   00000200   005091E5           LDR      R5,[R1, #+0]
   \   00000204   040053E3           CMP      R3,#+4
   \   00000208   025185E0           ADD      R5,R5,R2, LSL #+2
   \   0000020C   04E085E5           STR      LR,[R5, #+4]
   \   00000210   005091E5           LDR      R5,[R1, #+0]
   \   00000214   025185E0           ADD      R5,R5,R2, LSL #+2
   \   00000218   084085E5           STR      R4,[R5, #+8]
   \   0000021C   032082E2           ADD      R2,R2,#+3
   \   00000220   F3FFFFAA           BGE      ??_DrawHLine_15
    322              }
    323              //
    324              // Last triple DWORD
    325              //
    326              if (RemPixels) {
   \                     ??_DrawHLine_14:
   \   00000224   000053E3           CMP      R3,#+0
   \   00000228   1E00000A           BEQ      ??_DrawHLine_2
    327                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    328                Data &= 0xFF000000;
    329                Data |= ColorIndex;
   \   0000022C   00C091E5           LDR      R12,[R1, #+0]
    330                RemPixels--;
   \   00000230   013053E2           SUBS     R3,R3,#+1
   \   00000234   02E19CE7           LDR      LR,[R12, +R2, LSL #+2]
   \   00000238   FFE40EE2           AND      LR,LR,#0xFF000000
   \   0000023C   0E4080E1           ORR      R4,R0,LR
    331                if (!RemPixels) {
   \   00000240   0200001A           BNE      ??_DrawHLine_16
    332                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_17:
   \   00000244   000091E5           LDR      R0,[R1, #+0]
   \   00000248   024180E7           STR      R4,[R0, +R2, LSL #+2]
    333                  return;
   \   0000024C   150000EA           B        ??_DrawHLine_2
    334                }
    335                Data &= 0x00FFFFFF;
    336                Data |= ColorIndex << 24;
    337                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawHLine_16:
   \   00000250   04E4A0E1           LSL      LR,R4,#+8
   \   00000254   004CA0E1           LSL      R4,R0,#+24
   \   00000258   2EE484E1           ORR      LR,R4,LR, LSR #+8
   \   0000025C   02E18CE7           STR      LR,[R12, +R2, LSL #+2]
    338                Off++;
    339                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    340                Data &= 0xFFFF0000;
    341                Data |= ColorIndex >> 8;
   \   00000260   00C091E5           LDR      R12,[R1, #+0]
   \   00000264   012082E2           ADD      R2,R2,#+1
   \   00000268   02E19CE7           LDR      LR,[R12, +R2, LSL #+2]
   \   0000026C   2044A0E1           LSR      R4,R0,#+8
   \   00000270   2EE8A0E1           LSR      LR,LR,#+16
   \   00000274   0E4884E1           ORR      R4,R4,LR, LSL #+16
    342                RemPixels--;
    343                if (!RemPixels) {
   \   00000278   013053E2           SUBS     R3,R3,#+1
   \   0000027C   F0FFFF0A           BEQ      ??_DrawHLine_17
    344                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    345                  return;
    346                }
    347                Data &= 0x0000FFFF;
    348                Data |= ColorIndex << 16;
    349                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000280   0438A0E1           LSL      R3,R4,#+16
   \   00000284   00E8A0E1           LSL      LR,R0,#+16
   \   00000288   23388EE1           ORR      R3,LR,R3, LSR #+16
   \   0000028C   02318CE7           STR      R3,[R12, +R2, LSL #+2]
    350                Off++;
    351                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    352                Data &= 0xFFFFFF00;
    353                Data |= ColorIndex >> 16;
    354                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000290   001091E5           LDR      R1,[R1, #+0]
   \   00000294   012082E2           ADD      R2,R2,#+1
   \   00000298   023191E7           LDR      R3,[R1, +R2, LSL #+2]
   \   0000029C   FF30C3E3           BIC      R3,R3,#0xFF
   \   000002A0   200883E1           ORR      R0,R3,R0, LSR #+16
   \   000002A4   020181E7           STR      R0,[R1, +R2, LSL #+2]
   \                     ??_DrawHLine_2:
   \   000002A8   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000002AC   F083BDE8           POP      {R4-R9,PC}       ;; return
    355              }
    356            }
    357          }
    358          
    359          /*********************************************************************
    360          *
    361          *       _DrawVLine, not optimized
    362          */

   \                                 In section .text, align 4, keep-with-next
    363          static void _DrawVLine  (GUI_DEVICE * pDevice, int x, int y0,  int y1) {
   \                     _DrawVLine:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    364            LCD_PIXELINDEX ColorIndex;
    365          
    366            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable12
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0160A0E1           MOV      R6,R1
   \   00000018   0270A0E1           MOV      R7,R2
   \   0000001C   0380A0E1           MOV      R8,R3
   \   00000020   010010E3           TST      R0,#0x1
   \   00000024   3000000A           BEQ      ??_DrawVLine_1
   \   00000028   070058E1           CMP      R8,R7
   \   0000002C   3B0000BA           BLT      ??_DrawVLine_2
   \   00000030   FFA0A0E3           MOV      R10,#+255
   \   00000034   039006E2           AND      R9,R6,#0x3
   \   00000038   864086E0           ADD      R4,R6,R6, LSL #+1
   \   0000003C   FFAC8AE3           ORR      R10,R10,#0xFF00
    367              for (; y0 <= y1; y0++) {
    368                _XorPixel(pDevice, x, y0);
   \                     ??_DrawVLine_3:
   \   00000040   080095E5           LDR      R0,[R5, #+8]
   \   00000044   030059E3           CMP      R9,#+3
   \   00000048   102090E5           LDR      R2,[R0, #+16]
   \   0000004C   141090E5           LDR      R1,[R0, #+20]
   \   00000050   012042E2           SUB      R2,R2,#+1
   \   00000054   072042E0           SUB      R2,R2,R7
   \   00000058   920101E0           MUL      R1,R2,R1
   \   0000005C   002090E5           LDR      R2,[R0, #+0]
   \   00000060   811081E0           ADD      R1,R1,R1, LSL #+1
   \   00000064   011084E0           ADD      R1,R4,R1
   \   00000068   2111A0E1           LSR      R1,R1,#+2
   \   0000006C   010192E7           LDR      R0,[R2, +R1, LSL #+2]
   \   00000070   09F18F90           ADDLS    PC,PC,R9, LSL #+2
   \                     ??_DrawVLine_0:
   \   00000074   1000008A           BHI      ??_DrawVLine_4
   \   00000078   0D0000EA           B        ??_DrawVLine_5
   \   0000007C   060000EA           B        ??_DrawVLine_6
   \   00000080   000000EA           B        ??_DrawVLine_7
   \   00000084   0B0000EA           B        ??_DrawVLine_8
   \                     ??_DrawVLine_7:
   \   00000088   011182E0           ADD      R1,R2,R1, LSL #+2
   \   0000008C   0410D1E5           LDRB     R1,[R1, #+4]
   \   00000090   0118A0E1           LSL      R1,R1,#+16
   \   00000094   20B881E1           ORR      R11,R1,R0, LSR #+16
   \   00000098   070000EA           B        ??_DrawVLine_4
   \                     ??_DrawVLine_6:
   \   0000009C   011182E0           ADD      R1,R2,R1, LSL #+2
   \   000000A0   041091E5           LDR      R1,[R1, #+4]
   \   000000A4   01100AE0           AND      R1,R10,R1
   \   000000A8   0114A0E1           LSL      R1,R1,#+8
   \   000000AC   20BC81E1           ORR      R11,R1,R0, LSR #+24
   \   000000B0   010000EA           B        ??_DrawVLine_4
   \                     ??_DrawVLine_5:
   \   000000B4   0004A0E1           LSL      R0,R0,#+8
   \                     ??_DrawVLine_8:
   \   000000B8   20B4A0E1           LSR      R11,R0,#+8
   \                     ??_DrawVLine_4:
   \   000000BC   100095E5           LDR      R0,[R5, #+16]
   \   000000C0   080090E5           LDR      R0,[R0, #+8]
   \   000000C4   30FF2FE1           BLX      R0
   \   000000C8   0B3020E0           EOR      R3,R0,R11
   \   000000CC   0720A0E1           MOV      R2,R7
   \   000000D0   0610A0E1           MOV      R1,R6
   \   000000D4   0500A0E1           MOV      R0,R5
   \   000000D8   ........           BL       _SetPixelIndex
    369              }
   \   000000DC   017087E2           ADD      R7,R7,#+1
   \   000000E0   070058E1           CMP      R8,R7
   \   000000E4   D5FFFFAA           BGE      ??_DrawVLine_3
   \   000000E8   0C0000EA           B        ??_DrawVLine_2
    370            } else {
    371              ColorIndex = LCD__GetColorIndex();
   \                     ??_DrawVLine_1:
   \   000000EC   ........           LDR      R0,??DataTable13
   \   000000F0   070058E1           CMP      R8,R7
   \   000000F4   000090E5           LDR      R0,[R0, #+0]
   \   000000F8   004090E5           LDR      R4,[R0, #+0]
   \   000000FC   070000BA           BLT      ??_DrawVLine_2
    372              for (; y0 <= y1; y0++) {
    373                _SetPixelIndex(pDevice, x, y0, ColorIndex);
   \                     ??_DrawVLine_9:
   \   00000100   0430A0E1           MOV      R3,R4
   \   00000104   0720A0E1           MOV      R2,R7
   \   00000108   0610A0E1           MOV      R1,R6
   \   0000010C   0500A0E1           MOV      R0,R5
   \   00000110   ........           BL       _SetPixelIndex
    374              }
   \   00000114   017087E2           ADD      R7,R7,#+1
   \   00000118   070058E1           CMP      R8,R7
   \   0000011C   F7FFFFAA           BGE      ??_DrawVLine_9
    375            }
    376          }
   \                     ??_DrawVLine_2:
   \   00000120   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000124   F08FBDE8           POP      {R4-R11,PC}      ;; return
    377          
    378          /*********************************************************************
    379          *
    380          *       _FillRect
    381          */

   \                                 In section .text, align 4, keep-with-next
    382          static void _FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   18809DE5           LDR      R8,[SP, #+24]
   \   00000008   0260A0E1           MOV      R6,R2
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0370A0E1           MOV      R7,R3
   \   00000018   060058E1           CMP      R8,R6
   \   0000001C   070000BA           BLT      ??_FillRect_0
    383            #ifdef LCD_FILL_RECT
    384               LCD_FILL_RECT(x0, y0, x1, y1, LCD__GetColorIndex());
    385            #else
    386              for (; y0 <= y1; y0++) {
    387                _DrawHLine(pDevice, x0, y0, x1);
   \                     ??_FillRect_1:
   \   00000020   0730A0E1           MOV      R3,R7
   \   00000024   0620A0E1           MOV      R2,R6
   \   00000028   0510A0E1           MOV      R1,R5
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       _DrawHLine
    388              }
   \   00000034   016086E2           ADD      R6,R6,#+1
   \   00000038   060058E1           CMP      R8,R6
   \   0000003C   F7FFFFAA           BGE      ??_FillRect_1
    389            #endif
    390          }
   \                     ??_FillRect_0:
   \   00000040   F081BDE8           POP      {R4-R8,PC}       ;; return
    391          
    392          /*********************************************************************
    393          *
    394          *       Draw Bitmap 1 BPP
    395          */

   \                                 In section .text, align 4, keep-with-next
    396          static void _DrawBitLine1BPP(GUI_DEVICE * pDevice, unsigned x, unsigned y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine1BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0360A0E1           MOV      R6,R3
    397            #define GET_PIXEL_INDEX(Index) {               \
    398              Index = ((Pixels & 1) ? Index1 : Index0);    \
    399              PixelCnt--;                                  \
    400              Pixels >>= 1;                                \
    401              if (PixelCnt == 0) {                         \
    402                Pixels |= LCD_aMirror[*(++p)] << PixelCnt; \
    403                PixelCnt += 8;                             \
    404              }                                            \
    405            }
    406            #define GET_PIXEL_INDEX_TRANS(Index, Bit) {    \
    407              Bit = Pixels & 1;                            \
    408              GET_PIXEL_INDEX(Index);                      \
    409            }
    410            DRIVER_CONTEXT * pContext;
    411            LCD_PIXELINDEX Index0, Index1;
    412            LCD_PIXELINDEX IndexMask;
    413            U32 Off, Data, Data0, Data1, Data2, Index;
    414            unsigned Pixels, PixelCnt, Odd, Bit;
    415          
    416            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    417            Index0 = *(pTrans + 0);
    418            Index1 = *(pTrans + 1);
    419            x += Diff;
    420            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000008   ........           LDR      R3,??DataTable12
   \   0000000C   0CD04DE2           SUB      SP,SP,#+12
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   1030D3E5           LDRB     R3,[R3, #+16]
   \   00000018   38209DE5           LDR      R2,[SP, #+56]
   \   0000001C   01C0A0E1           MOV      R12,R1
   \   00000020   30709DE5           LDR      R7,[SP, #+48]
   \   00000024   0040A0E1           MOV      R4,R0
   \   00000028   001092E5           LDR      R1,[R2, #+0]
   \   0000002C   033003E2           AND      R3,R3,#0x3
   \   00000030   34809DE5           LDR      R8,[SP, #+52]
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   042092E5           LDR      R2,[R2, #+4]
   \   0000003C   0C9087E0           ADD      R9,R7,R12
   \   00000040   030053E3           CMP      R3,#+3
   \   00000044   03F18F90           ADDLS    PC,PC,R3, LSL #+2
   \                     ??_DrawBitLine1BPP_0:
   \   00000048   1902008A           BHI      ??_DrawBitLine1BPP_2
   \   0000004C   020000EA           B        ??_DrawBitLine1BPP_3
   \   00000050   DE0100EA           B        ??_DrawBitLine1BPP_4
   \   00000054   D10000EA           B        ??_DrawBitLine1BPP_5
   \   00000058   DC0100EA           B        ??_DrawBitLine1BPP_4
    421            case 0:
    422              //
    423              // Mirror y
    424              //
    425              y = (pContext->vySize - 1 - (y));
    426              PixelCnt = 8 - Diff;
    427              Pixels   = LCD_aMirror[*p] >> Diff;
   \                     ??_DrawBitLine1BPP_3:
   \   0000005C   00E0D6E5           LDRB     LR,[R6, #+0]
   \   00000060   ........           LDR      R3,??DataTable14
    428              Off      = XY2OFF32(pContext->vxSizePhys, x, y);
   \   00000064   104090E5           LDR      R4,[R0, #+16]
   \   00000068   03E0DEE7           LDRB     LR,[LR, +R3]
   \   0000006C   014044E2           SUB      R4,R4,#+1
   \   00000070   054044E0           SUB      R4,R4,R5
   \   00000074   145090E5           LDR      R5,[R0, #+20]
   \   00000078   08C067E2           RSB      R12,R7,#+8
   \   0000007C   5EE7A0E1           ASR      LR,LR,R7
   \   00000080   855085E0           ADD      R5,R5,R5, LSL #+1
   \   00000084   897089E0           ADD      R7,R9,R9, LSL #+1
   \   00000088   957424E0           MLA      R4,R5,R4,R7
    429              //
    430              // First triple DWORD
    431              //
    432              Odd = x & 3;
   \   0000008C   039019E2           ANDS     R9,R9,#0x3
   \   00000090   2441A0E1           LSR      R4,R4,#+2
    433              if (Odd) {                    
   \   00000094   4A00000A           BEQ      ??_DrawBitLine1BPP_6
    434                Data    = READ_MEM32(pContext->VRAMAddr, Off);
   \   00000098   005090E5           LDR      R5,[R0, #+0]
    435                switch (Odd) {
   \   0000009C   010059E3           CMP      R9,#+1
   \   000000A0   047195E7           LDR      R7,[R5, +R4, LSL #+2]
   \   000000A4   0400000A           BEQ      ??_DrawBitLine1BPP_7
   \   000000A8   4500003A           BCC      ??_DrawBitLine1BPP_6
   \   000000AC   030059E3           CMP      R9,#+3
   \   000000B0   3200000A           BEQ      ??_DrawBitLine1BPP_8
   \   000000B4   1A00003A           BCC      ??_DrawBitLine1BPP_9
   \   000000B8   410000EA           B        ??_DrawBitLine1BPP_6
    436                case 1:
    437                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_7:
   \   000000BC   01001EE3           TST      LR,#0x1
   \   000000C0   02B0A011           MOVNE    R11,R2
   \   000000C4   01B0A001           MOVEQ    R11,R1
   \   000000C8   01C04CE2           SUB      R12,R12,#+1
   \   000000CC   AEE0A0E1           LSR      LR,LR,#+1
   \   000000D0   00005CE3           CMP      R12,#+0
   \   000000D4   0300001A           BNE      ??_DrawBitLine1BPP_10
   \   000000D8   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   000000DC   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000000E0   0EE08CE1           ORR      LR,R12,LR
   \   000000E4   08C0A0E3           MOV      R12,#+8
    438                  Data &= 0x00FFFFFF;
    439                  Data |= Index << 24;
    440                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_10:
   \   000000E8   0774A0E1           LSL      R7,R7,#+8
   \   000000EC   0B9CA0E1           LSL      R9,R11,#+24
   \   000000F0   277489E1           ORR      R7,R9,R7, LSR #+8
   \   000000F4   047185E7           STR      R7,[R5, +R4, LSL #+2]
    441                  Off++;
    442                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    443                  Data &= 0xFFFF0000;
    444                  Data |= Index >> 8;
   \   000000F8   005090E5           LDR      R5,[R0, #+0]
   \   000000FC   014084E2           ADD      R4,R4,#+1
   \   00000100   045195E7           LDR      R5,[R5, +R4, LSL #+2]
   \   00000104   2B74A0E1           LSR      R7,R11,#+8
   \   00000108   2558A0E1           LSR      R5,R5,#+16
   \   0000010C   057887E1           ORR      R7,R7,R5, LSL #+16
    445                  xsize--;
   \   00000110   018058E2           SUBS     R8,R8,#+1
    446                  if (!xsize) {
   \   00000114   0200001A           BNE      ??_DrawBitLine1BPP_9
    447                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_11:
   \   00000118   005090E5           LDR      R5,[R0, #+0]
   \   0000011C   047185E7           STR      R7,[R5, +R4, LSL #+2]
    448                    break;
   \   00000120   270000EA           B        ??_DrawBitLine1BPP_6
    449                  }
    450                case 2:
    451                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_9:
   \   00000124   01001EE3           TST      LR,#0x1
   \   00000128   02B0A011           MOVNE    R11,R2
   \   0000012C   01B0A001           MOVEQ    R11,R1
   \   00000130   01C04CE2           SUB      R12,R12,#+1
   \   00000134   AEE0A0E1           LSR      LR,LR,#+1
   \   00000138   00005CE3           CMP      R12,#+0
   \   0000013C   0300001A           BNE      ??_DrawBitLine1BPP_12
   \   00000140   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000144   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000148   0EE08CE1           ORR      LR,R12,LR
   \   0000014C   08C0A0E3           MOV      R12,#+8
    452                  Data &= 0x0000FFFF;
    453                  Data |= Index << 16;
    454                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_12:
   \   00000150   0758A0E1           LSL      R5,R7,#+16
   \   00000154   0B78A0E1           LSL      R7,R11,#+16
   \   00000158   255887E1           ORR      R5,R7,R5, LSR #+16
   \   0000015C   007090E5           LDR      R7,[R0, #+0]
    455                  Off++;
    456                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    457                  Data &= 0xFFFFFF00;
    458                  Data |= Index >> 16;
    459                  xsize--;
   \   00000160   018058E2           SUBS     R8,R8,#+1
   \   00000164   045187E7           STR      R5,[R7, +R4, LSL #+2]
   \   00000168   005090E5           LDR      R5,[R0, #+0]
   \   0000016C   014084E2           ADD      R4,R4,#+1
   \   00000170   045195E7           LDR      R5,[R5, +R4, LSL #+2]
   \   00000174   FF50C5E3           BIC      R5,R5,#0xFF
   \   00000178   2B7885E1           ORR      R7,R5,R11, LSR #+16
    460                  if (!xsize) {
   \   0000017C   E5FFFF0A           BEQ      ??_DrawBitLine1BPP_11
    461                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    462                    break;
    463                  }
    464                case 3:
    465                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_8:
   \   00000180   01001EE3           TST      LR,#0x1
   \   00000184   02B0A011           MOVNE    R11,R2
   \   00000188   01B0A001           MOVEQ    R11,R1
   \   0000018C   01C04CE2           SUB      R12,R12,#+1
   \   00000190   AEE0A0E1           LSR      LR,LR,#+1
   \   00000194   00005CE3           CMP      R12,#+0
   \   00000198   0300001A           BNE      ??_DrawBitLine1BPP_13
   \   0000019C   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   000001A0   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000001A4   0EE08CE1           ORR      LR,R12,LR
   \   000001A8   08C0A0E3           MOV      R12,#+8
    466                  Data &= 0x000000FF;
    467                  Data |= Index << 8;
    468                  xsize--;
    469                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_13:
   \   000001AC   FF5007E2           AND      R5,R7,#0xFF
   \   000001B0   007090E5           LDR      R7,[R0, #+0]
   \   000001B4   0B5485E1           ORR      R5,R5,R11, LSL #+8
   \   000001B8   045187E7           STR      R5,[R7, +R4, LSL #+2]
   \   000001BC   018048E2           SUB      R8,R8,#+1
    470                  Off++;
   \   000001C0   014084E2           ADD      R4,R4,#+1
    471                }
    472              }
    473              //
    474              // Complete triple DWORDS
    475              //
    476              if (xsize >= 4) {
   \                     ??_DrawBitLine1BPP_6:
   \   000001C4   040058E3           CMP      R8,#+4
   \   000001C8   3C0000BA           BLT      ??_DrawBitLine1BPP_14
    477                do {
    478                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_15:
   \   000001CC   01001EE3           TST      LR,#0x1
   \   000001D0   0250A011           MOVNE    R5,R2
   \   000001D4   0150A001           MOVEQ    R5,R1
   \   000001D8   01C04CE2           SUB      R12,R12,#+1
   \   000001DC   AEE0A0E1           LSR      LR,LR,#+1
   \   000001E0   00005CE3           CMP      R12,#+0
   \   000001E4   0300001A           BNE      ??_DrawBitLine1BPP_16
   \   000001E8   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   000001EC   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000001F0   0EE08CE1           ORR      LR,R12,LR
   \   000001F4   08C0A0E3           MOV      R12,#+8
    479                  Data0  = (Index      );
    480                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_16:
   \   000001F8   01001EE3           TST      LR,#0x1
   \   000001FC   0290A011           MOVNE    R9,R2
   \   00000200   0190A001           MOVEQ    R9,R1
   \   00000204   01C04CE2           SUB      R12,R12,#+1
   \   00000208   AEE0A0E1           LSR      LR,LR,#+1
   \   0000020C   00005CE3           CMP      R12,#+0
   \   00000210   0300001A           BNE      ??_DrawBitLine1BPP_17
   \   00000214   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000218   03C0DCE7           LDRB     R12,[R12, +R3]
   \   0000021C   0EE08CE1           ORR      LR,R12,LR
   \   00000220   08C0A0E3           MOV      R12,#+8
    481                  Data0 |= (Index << 24);
   \                     ??_DrawBitLine1BPP_17:
   \   00000224   097C85E1           ORR      R7,R5,R9, LSL #+24
    482                  Data1  = (Index >>  8);
    483                  GET_PIXEL_INDEX(Index);
   \   00000228   01001EE3           TST      LR,#0x1
   \   0000022C   0250A011           MOVNE    R5,R2
   \   00000230   0150A001           MOVEQ    R5,R1
   \   00000234   01C04CE2           SUB      R12,R12,#+1
   \   00000238   2994A0E1           LSR      R9,R9,#+8
   \   0000023C   AEE0A0E1           LSR      LR,LR,#+1
   \   00000240   00005CE3           CMP      R12,#+0
   \   00000244   0300001A           BNE      ??_DrawBitLine1BPP_18
   \   00000248   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   0000024C   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000250   0EE08CE1           ORR      LR,R12,LR
   \   00000254   08C0A0E3           MOV      R12,#+8
    484                  Data1 |= (Index << 16);
    485                  Data2  = (Index >> 16);
    486                  GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_18:
   \   00000258   01001EE3           TST      LR,#0x1
   \   0000025C   059889E1           ORR      R9,R9,R5, LSL #+16
   \   00000260   02B0A011           MOVNE    R11,R2
   \   00000264   01B0A001           MOVEQ    R11,R1
   \   00000268   01C04CE2           SUB      R12,R12,#+1
   \   0000026C   2558A0E1           LSR      R5,R5,#+16
   \   00000270   AEE0A0E1           LSR      LR,LR,#+1
   \   00000274   00005CE3           CMP      R12,#+0
   \   00000278   0300001A           BNE      ??_DrawBitLine1BPP_19
   \   0000027C   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000280   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000284   0EE08CE1           ORR      LR,R12,LR
   \   00000288   08C0A0E3           MOV      R12,#+8
    487                  Data2 |= (Index <<  8);
    488                  WRITE_MEM32(pContext->VRAMAddr, Off + 0, Data0);
   \                     ??_DrawBitLine1BPP_19:
   \   0000028C   00A090E5           LDR      R10,[R0, #+0]
    489                  WRITE_MEM32(pContext->VRAMAddr, Off + 1, Data1);
    490                  WRITE_MEM32(pContext->VRAMAddr, Off + 2, Data2);
   \   00000290   0B5485E1           ORR      R5,R5,R11, LSL #+8
   \   00000294   04718AE7           STR      R7,[R10, +R4, LSL #+2]
   \   00000298   007090E5           LDR      R7,[R0, #+0]
    491                  Off += 3;
    492                } while ((xsize -= 4) >= 4);
   \   0000029C   048048E2           SUB      R8,R8,#+4
   \   000002A0   047187E0           ADD      R7,R7,R4, LSL #+2
   \   000002A4   049087E5           STR      R9,[R7, #+4]
   \   000002A8   007090E5           LDR      R7,[R0, #+0]
   \   000002AC   040058E3           CMP      R8,#+4
   \   000002B0   047187E0           ADD      R7,R7,R4, LSL #+2
   \   000002B4   085087E5           STR      R5,[R7, #+8]
   \   000002B8   034084E2           ADD      R4,R4,#+3
   \   000002BC   C2FFFFAA           BGE      ??_DrawBitLine1BPP_15
    493              }
    494              //
    495              // Last triple DWORD
    496              //
    497              if (xsize) {
   \                     ??_DrawBitLine1BPP_14:
   \   000002C0   000058E3           CMP      R8,#+0
   \   000002C4   7A01000A           BEQ      ??_DrawBitLine1BPP_2
    498                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    499                Data &= 0xFF000000;
   \   000002C8   005090E5           LDR      R5,[R0, #+0]
    500                GET_PIXEL_INDEX(Index);
   \   000002CC   01001EE3           TST      LR,#0x1
   \   000002D0   047195E7           LDR      R7,[R5, +R4, LSL #+2]
   \   000002D4   02B0A011           MOVNE    R11,R2
   \   000002D8   01B0A001           MOVEQ    R11,R1
   \   000002DC   01C04CE2           SUB      R12,R12,#+1
   \   000002E0   FF7407E2           AND      R7,R7,#0xFF000000
   \   000002E4   AEE0A0E1           LSR      LR,LR,#+1
   \   000002E8   00005CE3           CMP      R12,#+0
   \   000002EC   0300001A           BNE      ??_DrawBitLine1BPP_20
   \   000002F0   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   000002F4   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000002F8   0EE08CE1           ORR      LR,R12,LR
   \   000002FC   08C0A0E3           MOV      R12,#+8
    501                Data |= Index;
   \                     ??_DrawBitLine1BPP_20:
   \   00000300   07708BE1           ORR      R7,R11,R7
    502                xsize--;
   \   00000304   018058E2           SUBS     R8,R8,#+1
    503                if (!xsize) {
   \   00000308   0200001A           BNE      ??_DrawBitLine1BPP_21
    504                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_22:
   \   0000030C   000090E5           LDR      R0,[R0, #+0]
   \   00000310   047180E7           STR      R7,[R0, +R4, LSL #+2]
    505                  return;
   \   00000314   660100EA           B        ??_DrawBitLine1BPP_2
    506                }
    507                Data &= 0x00FFFFFF;
    508                GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine1BPP_21:
   \   00000318   01001EE3           TST      LR,#0x1
   \   0000031C   02B0A011           MOVNE    R11,R2
   \   00000320   01B0A001           MOVEQ    R11,R1
   \   00000324   01C05CE2           SUBS     R12,R12,#+1
   \   00000328   01C0D605           LDRBEQ   R12,[R6, #+1]
   \   0000032C   0774A0E1           LSL      R7,R7,#+8
   \   00000330   AEE0A0E1           LSR      LR,LR,#+1
   \   00000334   0330DC07           LDRBEQ   R3,[R12, +R3]
   \   00000338   2774A0E1           LSR      R7,R7,#+8
   \   0000033C   0EE08301           ORREQ    LR,R3,LR
    509                Data |= Index << 24;
    510                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000340   0B3C87E1           ORR      R3,R7,R11, LSL #+24
   \   00000344   043185E7           STR      R3,[R5, +R4, LSL #+2]
    511                Off++;
    512                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    513                Data &= 0xFFFF0000;
    514                Data |= Index >> 8;
   \   00000348   003090E5           LDR      R3,[R0, #+0]
   \   0000034C   014084E2           ADD      R4,R4,#+1
   \   00000350   04C193E7           LDR      R12,[R3, +R4, LSL #+2]
   \   00000354   2B54A0E1           LSR      R5,R11,#+8
   \   00000358   2CC8A0E1           LSR      R12,R12,#+16
   \   0000035C   0C7885E1           ORR      R7,R5,R12, LSL #+16
    515                xsize--;
    516                if (!xsize) {
   \   00000360   01C058E2           SUBS     R12,R8,#+1
   \   00000364   E8FFFF0A           BEQ      ??_DrawBitLine1BPP_22
    517                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    518                  return;
    519                }
    520                Data &= 0x0000FFFF;
   \   00000368   07C8A0E1           LSL      R12,R7,#+16
    521                GET_PIXEL_INDEX(Index);
   \   0000036C   01001EE3           TST      LR,#0x1
   \   00000370   2C78A0E1           LSR      R7,R12,#+16
   \   00000374   02B0A011           MOVNE    R11,R2
   \   00000378   01B0A001           MOVEQ    R11,R1
    522                Data |= Index << 16;
    523                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   0000037C   0B1887E1           ORR      R1,R7,R11, LSL #+16
   \   00000380   041183E7           STR      R1,[R3, +R4, LSL #+2]
    524                Off++;
    525                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    526                Data &= 0xFFFFFF00;
    527                Data |= Index >> 16;
    528                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_23:
   \   00000384   000090E5           LDR      R0,[R0, #+0]
   \   00000388   014084E2           ADD      R4,R4,#+1
   \   0000038C   041190E7           LDR      R1,[R0, +R4, LSL #+2]
   \   00000390   FF10C1E3           BIC      R1,R1,#0xFF
   \   00000394   2B1881E1           ORR      R1,R1,R11, LSR #+16
   \   00000398   041180E7           STR      R1,[R0, +R4, LSL #+2]
   \   0000039C   440100EA           B        ??_DrawBitLine1BPP_2
    529              }
    530              break;
    531            case LCD_DRAWMODE_TRANS:
    532              //
    533              // Mirror y
    534              //
    535              y = (pContext->vySize - 1 - (y));
    536              PixelCnt = 8 - Diff;
    537              Pixels   = LCD_aMirror[*p] >> Diff;
   \                     ??_DrawBitLine1BPP_5:
   \   000003A0   00E0D6E5           LDRB     LR,[R6, #+0]
   \   000003A4   ........           LDR      R3,??DataTable14
    538              Off      = XY2OFF32(pContext->vxSizePhys, x, y);
   \   000003A8   104090E5           LDR      R4,[R0, #+16]
   \   000003AC   03E0DEE7           LDRB     LR,[LR, +R3]
   \   000003B0   014044E2           SUB      R4,R4,#+1
   \   000003B4   054044E0           SUB      R4,R4,R5
   \   000003B8   145090E5           LDR      R5,[R0, #+20]
   \   000003BC   08C067E2           RSB      R12,R7,#+8
   \   000003C0   5EE7A0E1           ASR      LR,LR,R7
   \   000003C4   855085E0           ADD      R5,R5,R5, LSL #+1
   \   000003C8   897089E0           ADD      R7,R9,R9, LSL #+1
   \   000003CC   957424E0           MLA      R4,R5,R4,R7
    539              //
    540              // First triple DWORD
    541              //
    542              Odd = x & 3;
   \   000003D0   039019E2           ANDS     R9,R9,#0x3
   \   000003D4   2441A0E1           LSR      R4,R4,#+2
    543              if (Odd) {
   \   000003D8   5E00000A           BEQ      ??_DrawBitLine1BPP_24
    544                Data    = READ_MEM32(pContext->VRAMAddr, Off);
   \   000003DC   005090E5           LDR      R5,[R0, #+0]
    545                switch (Odd) {
   \   000003E0   010059E3           CMP      R9,#+1
   \   000003E4   047195E7           LDR      R7,[R5, +R4, LSL #+2]
   \   000003E8   0400000A           BEQ      ??_DrawBitLine1BPP_25
   \   000003EC   5900003A           BCC      ??_DrawBitLine1BPP_24
   \   000003F0   030059E3           CMP      R9,#+3
   \   000003F4   4500000A           BEQ      ??_DrawBitLine1BPP_26
   \   000003F8   2200003A           BCC      ??_DrawBitLine1BPP_27
   \   000003FC   550000EA           B        ??_DrawBitLine1BPP_24
    546                case 1:
    547                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_25:
   \   00000400   01A01EE2           ANDS     R10,LR,#0x1
   \   00000404   02B0A011           MOVNE    R11,R2
   \   00000408   01B0A001           MOVEQ    R11,R1
   \   0000040C   01C04CE2           SUB      R12,R12,#+1
   \   00000410   AEE0A0E1           LSR      LR,LR,#+1
   \   00000414   00005CE3           CMP      R12,#+0
   \   00000418   0300001A           BNE      ??_DrawBitLine1BPP_28
   \   0000041C   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000420   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000424   0EE08CE1           ORR      LR,R12,LR
   \   00000428   08C0A0E3           MOV      R12,#+8
    548                  if (Bit) {
   \                     ??_DrawBitLine1BPP_28:
   \   0000042C   019084E2           ADD      R9,R4,#+1
   \   00000430   018048E2           SUB      R8,R8,#+1
   \   00000434   00005AE3           CMP      R10,#+0
   \   00000438   0E00000A           BEQ      ??_DrawBitLine1BPP_29
    549                    Data &= 0x00FFFFFF;
    550                    Data |= Index << 24;
    551                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   0000043C   0774A0E1           LSL      R7,R7,#+8
   \   00000440   0BACA0E1           LSL      R10,R11,#+24
   \   00000444   27748AE1           ORR      R7,R10,R7, LSR #+8
   \   00000448   047185E7           STR      R7,[R5, +R4, LSL #+2]
    552                    Off++;
    553                    Data  = READ_MEM32(pContext->VRAMAddr, Off);
    554                    Data &= 0xFFFF0000;
    555                    Data |= Index >> 8;
   \   0000044C   005090E5           LDR      R5,[R0, #+0]
   \   00000450   0940A0E1           MOV      R4,R9
   \   00000454   045195E7           LDR      R5,[R5, +R4, LSL #+2]
   \   00000458   2B74A0E1           LSR      R7,R11,#+8
   \   0000045C   2558A0E1           LSR      R5,R5,#+16
   \   00000460   057887E1           ORR      R7,R7,R5, LSL #+16
    556                    xsize--;
    557                    if (!xsize) {
   \   00000464   000058E3           CMP      R8,#+0
   \   00000468   0600001A           BNE      ??_DrawBitLine1BPP_27
    558                      WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_30:
   \   0000046C   005090E5           LDR      R5,[R0, #+0]
   \   00000470   047185E7           STR      R7,[R5, +R4, LSL #+2]
    559                      break;
   \   00000474   370000EA           B        ??_DrawBitLine1BPP_24
    560                    }
    561                  } else {
    562                    Off++;
   \                     ??_DrawBitLine1BPP_29:
   \   00000478   0940A0E1           MOV      R4,R9
    563                    xsize--;
    564                    if (!xsize) {
   \   0000047C   000058E3           CMP      R8,#+0
   \   00000480   0B01000A           BEQ      ??_DrawBitLine1BPP_2
    565                      break;
    566                    }
    567                    Data = READ_MEM32(pContext->VRAMAddr, Off);
   \   00000484   047195E7           LDR      R7,[R5, +R4, LSL #+2]
    568                  }
    569                case 2:
    570                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_27:
   \   00000488   01A01EE2           ANDS     R10,LR,#0x1
   \   0000048C   02B0A011           MOVNE    R11,R2
   \   00000490   01B0A001           MOVEQ    R11,R1
   \   00000494   01C04CE2           SUB      R12,R12,#+1
   \   00000498   AEE0A0E1           LSR      LR,LR,#+1
   \   0000049C   00005CE3           CMP      R12,#+0
   \   000004A0   0300001A           BNE      ??_DrawBitLine1BPP_31
   \   000004A4   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   000004A8   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000004AC   0EE08CE1           ORR      LR,R12,LR
   \   000004B0   08C0A0E3           MOV      R12,#+8
    571                  if (Bit) {
   \                     ??_DrawBitLine1BPP_31:
   \   000004B4   005090E5           LDR      R5,[R0, #+0]
   \   000004B8   018048E2           SUB      R8,R8,#+1
   \   000004BC   019084E2           ADD      R9,R4,#+1
   \   000004C0   00005AE3           CMP      R10,#+0
   \   000004C4   0B00000A           BEQ      ??_DrawBitLine1BPP_32
    572                    Data &= 0x0000FFFF;
    573                    Data |= Index << 16;
    574                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000004C8   0778A0E1           LSL      R7,R7,#+16
   \   000004CC   0BA8A0E1           LSL      R10,R11,#+16
   \   000004D0   27788AE1           ORR      R7,R10,R7, LSR #+16
   \   000004D4   047185E7           STR      R7,[R5, +R4, LSL #+2]
    575                    Off++;
    576                    Data  = READ_MEM32(pContext->VRAMAddr, Off);
    577                    Data &= 0xFFFFFF00;
    578                    Data |= Index >> 16;
   \   000004D8   005090E5           LDR      R5,[R0, #+0]
   \   000004DC   0940A0E1           MOV      R4,R9
   \   000004E0   045195E7           LDR      R5,[R5, +R4, LSL #+2]
    579                    xsize--;
    580                    if (!xsize) {
   \   000004E4   000058E3           CMP      R8,#+0
   \   000004E8   FF50C5E3           BIC      R5,R5,#0xFF
   \   000004EC   2B7885E1           ORR      R7,R5,R11, LSR #+16
   \   000004F0   0600001A           BNE      ??_DrawBitLine1BPP_26
   \   000004F4   DCFFFFEA           B        ??_DrawBitLine1BPP_30
    581                      WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    582                      break;
    583                    }
    584                  } else {
    585                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_32:
   \   000004F8   047185E7           STR      R7,[R5, +R4, LSL #+2]
    586                    Off++;
   \   000004FC   0940A0E1           MOV      R4,R9
    587                    xsize--;
    588                    if (!xsize) {
   \   00000500   000058E3           CMP      R8,#+0
   \   00000504   EA00000A           BEQ      ??_DrawBitLine1BPP_2
    589                      break;
    590                    }
    591                    Data = READ_MEM32(pContext->VRAMAddr, Off);
   \   00000508   005090E5           LDR      R5,[R0, #+0]
   \   0000050C   047195E7           LDR      R7,[R5, +R4, LSL #+2]
    592                  }
    593                case 3:
    594                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_26:
   \   00000510   01A01EE2           ANDS     R10,LR,#0x1
   \   00000514   02B0A011           MOVNE    R11,R2
   \   00000518   01B0A001           MOVEQ    R11,R1
   \   0000051C   01C04CE2           SUB      R12,R12,#+1
   \   00000520   AEE0A0E1           LSR      LR,LR,#+1
   \   00000524   00005CE3           CMP      R12,#+0
   \   00000528   0300001A           BNE      ??_DrawBitLine1BPP_33
   \   0000052C   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000530   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000534   0EE08CE1           ORR      LR,R12,LR
   \   00000538   08C0A0E3           MOV      R12,#+8
    595                  if (Bit) {
   \                     ??_DrawBitLine1BPP_33:
   \   0000053C   00005AE3           CMP      R10,#+0
    596                    Data &= 0x000000FF;
    597                    Data |= Index << 8;
   \   00000540   FF500712           ANDNE    R5,R7,#0xFF
   \   00000544   0B748511           ORRNE    R7,R5,R11, LSL #+8
    598                  }
    599                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000548   005090E5           LDR      R5,[R0, #+0]
    600                  xsize--;
   \   0000054C   018048E2           SUB      R8,R8,#+1
   \   00000550   047185E7           STR      R7,[R5, +R4, LSL #+2]
    601                  Off++;
   \   00000554   014084E2           ADD      R4,R4,#+1
    602                }
    603              }
    604              //
    605              // Complete triple DWORDS
    606              //
    607              if (xsize >= 4) {
   \                     ??_DrawBitLine1BPP_24:
   \   00000558   040058E3           CMP      R8,#+4
   \   0000055C   590000BA           BLT      ??_DrawBitLine1BPP_34
    608                do {
    609                  Data0  = READ_MEM32(pContext->VRAMAddr, Off + 0);
   \                     ??_DrawBitLine1BPP_35:
   \   00000560   007090E5           LDR      R7,[R0, #+0]
   \   00000564   04708DE5           STR      R7,[SP, #+4]
   \   00000568   0750A0E1           MOV      R5,R7
   \   0000056C   047195E7           LDR      R7,[R5, +R4, LSL #+2]
    610                  Data1  = READ_MEM32(pContext->VRAMAddr, Off + 1);
   \   00000570   045185E0           ADD      R5,R5,R4, LSL #+2
   \   00000574   049095E5           LDR      R9,[R5, #+4]
    611                  Data2  = READ_MEM32(pContext->VRAMAddr, Off + 2);
   \   00000578   085095E5           LDR      R5,[R5, #+8]
    612                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \   0000057C   01A01EE2           ANDS     R10,LR,#0x1
   \   00000580   00A08DE5           STR      R10,[SP, #+0]
   \   00000584   02B0A011           MOVNE    R11,R2
   \   00000588   01B0A001           MOVEQ    R11,R1
   \   0000058C   01A04CE2           SUB      R10,R12,#+1
   \   00000590   AEE0A0E1           LSR      LR,LR,#+1
   \   00000594   00005AE3           CMP      R10,#+0
   \   00000598   0300001A           BNE      ??_DrawBitLine1BPP_36
   \   0000059C   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   000005A0   08A0A0E3           MOV      R10,#+8
   \   000005A4   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000005A8   0EE08CE1           ORR      LR,R12,LR
    613                  if (Bit) {
   \                     ??_DrawBitLine1BPP_36:
   \   000005AC   00C09DE5           LDR      R12,[SP, #+0]
   \   000005B0   00005CE3           CMP      R12,#+0
    614                    Data0 &= 0xFF000000;
    615                    Data0 |= (Index      );
   \   000005B4   FFC40712           ANDNE    R12,R7,#0xFF000000
   \   000005B8   0C708B11           ORRNE    R7,R11,R12
    616                  }
    617                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \   000005BC   01C01EE2           ANDS     R12,LR,#0x1
   \   000005C0   00C08DE5           STR      R12,[SP, #+0]
   \   000005C4   02C0A011           MOVNE    R12,R2
   \   000005C8   01C0A001           MOVEQ    R12,R1
   \   000005CC   01B04AE2           SUB      R11,R10,#+1
   \   000005D0   AEE0A0E1           LSR      LR,LR,#+1
   \   000005D4   00005BE3           CMP      R11,#+0
   \   000005D8   0300001A           BNE      ??_DrawBitLine1BPP_37
   \   000005DC   01A0F6E5           LDRB     R10,[R6, #+1]!
   \   000005E0   08B0A0E3           MOV      R11,#+8
   \   000005E4   03A0DAE7           LDRB     R10,[R10, +R3]
   \   000005E8   0EE08AE1           ORR      LR,R10,LR
    618                  if (Bit) {
   \                     ??_DrawBitLine1BPP_37:
   \   000005EC   00A09DE5           LDR      R10,[SP, #+0]
   \   000005F0   00005AE3           CMP      R10,#+0
   \   000005F4   0500000A           BEQ      ??_DrawBitLine1BPP_38
    619                    Data0 &= 0x00FFFFFF;
    620                    Data0 |= (Index << 24);
   \   000005F8   0CACA0E1           LSL      R10,R12,#+24
   \   000005FC   0774A0E1           LSL      R7,R7,#+8
    621                    Data1 &= 0xFFFF0000;
    622                    Data1 |= (Index >>  8);
   \   00000600   2998A0E1           LSR      R9,R9,#+16
   \   00000604   2CC4A0E1           LSR      R12,R12,#+8
   \   00000608   27748AE1           ORR      R7,R10,R7, LSR #+8
   \   0000060C   09988CE1           ORR      R9,R12,R9, LSL #+16
    623                  }
    624                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_38:
   \   00000610   01C01EE2           ANDS     R12,LR,#0x1
   \   00000614   00C08DE5           STR      R12,[SP, #+0]
   \   00000618   02A0A011           MOVNE    R10,R2
   \   0000061C   01A0A001           MOVEQ    R10,R1
   \   00000620   01C04BE2           SUB      R12,R11,#+1
   \   00000624   AEE0A0E1           LSR      LR,LR,#+1
   \   00000628   00005CE3           CMP      R12,#+0
   \   0000062C   0300001A           BNE      ??_DrawBitLine1BPP_39
   \   00000630   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000634   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000638   0EE08CE1           ORR      LR,R12,LR
   \   0000063C   08C0A0E3           MOV      R12,#+8
    625                  if (Bit) {
   \                     ??_DrawBitLine1BPP_39:
   \   00000640   00B09DE5           LDR      R11,[SP, #+0]
   \   00000644   00005BE3           CMP      R11,#+0
   \   00000648   0400000A           BEQ      ??_DrawBitLine1BPP_40
    626                    Data1 &= 0x0000FFFF;
    627                    Data1 |= (Index << 16);
   \   0000064C   0998A0E1           LSL      R9,R9,#+16
   \   00000650   0AB8A0E1           LSL      R11,R10,#+16
    628                    Data2 &= 0xFFFFFF00;
    629                    Data2 |= (Index >> 16);
   \   00000654   FF50C5E3           BIC      R5,R5,#0xFF
   \   00000658   29988BE1           ORR      R9,R11,R9, LSR #+16
   \   0000065C   2A5885E1           ORR      R5,R5,R10, LSR #+16
    630                  }
    631                  GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_40:
   \   00000660   01A01EE2           ANDS     R10,LR,#0x1
   \   00000664   02B0A011           MOVNE    R11,R2
   \   00000668   01B0A001           MOVEQ    R11,R1
   \   0000066C   01C04CE2           SUB      R12,R12,#+1
   \   00000670   AEE0A0E1           LSR      LR,LR,#+1
   \   00000674   00005CE3           CMP      R12,#+0
   \   00000678   0300001A           BNE      ??_DrawBitLine1BPP_41
   \   0000067C   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   00000680   03C0DCE7           LDRB     R12,[R12, +R3]
   \   00000684   0EE08CE1           ORR      LR,R12,LR
   \   00000688   08C0A0E3           MOV      R12,#+8
    632                  if (Bit) {
   \                     ??_DrawBitLine1BPP_41:
   \   0000068C   00005AE3           CMP      R10,#+0
    633                    Data2 &= 0x000000FF;
    634                    Data2 |= (Index <<  8);
    635                  }
    636                  WRITE_MEM32(pContext->VRAMAddr, Off + 0, Data0);
   \   00000690   04A09DE5           LDR      R10,[SP, #+4]
   \   00000694   FF500512           ANDNE    R5,R5,#0xFF
   \   00000698   04718AE7           STR      R7,[R10, +R4, LSL #+2]
    637                  WRITE_MEM32(pContext->VRAMAddr, Off + 1, Data1);
   \   0000069C   007090E5           LDR      R7,[R0, #+0]
   \   000006A0   0B548511           ORRNE    R5,R5,R11, LSL #+8
   \   000006A4   047187E0           ADD      R7,R7,R4, LSL #+2
   \   000006A8   049087E5           STR      R9,[R7, #+4]
    638                  WRITE_MEM32(pContext->VRAMAddr, Off + 2, Data2);
   \   000006AC   007090E5           LDR      R7,[R0, #+0]
    639                  Off += 3;
    640                } while ((xsize -= 4) >= 4);
   \   000006B0   048048E2           SUB      R8,R8,#+4
   \   000006B4   047187E0           ADD      R7,R7,R4, LSL #+2
   \   000006B8   085087E5           STR      R5,[R7, #+8]
   \   000006BC   034084E2           ADD      R4,R4,#+3
   \   000006C0   040058E3           CMP      R8,#+4
   \   000006C4   A5FFFFAA           BGE      ??_DrawBitLine1BPP_35
    641              }
    642              //
    643              // Last triple DWORD
    644              //
    645              if (xsize) {
   \                     ??_DrawBitLine1BPP_34:
   \   000006C8   000058E3           CMP      R8,#+0
   \   000006CC   7800000A           BEQ      ??_DrawBitLine1BPP_2
    646                Data  = READ_MEM32(pContext->VRAMAddr, Off);
   \   000006D0   005090E5           LDR      R5,[R0, #+0]
    647                GET_PIXEL_INDEX_TRANS(Index, Bit);
   \   000006D4   01A01EE2           ANDS     R10,LR,#0x1
   \   000006D8   02B0A011           MOVNE    R11,R2
   \   000006DC   01B0A001           MOVEQ    R11,R1
   \   000006E0   01C04CE2           SUB      R12,R12,#+1
   \   000006E4   047195E7           LDR      R7,[R5, +R4, LSL #+2]
   \   000006E8   AEE0A0E1           LSR      LR,LR,#+1
   \   000006EC   00005CE3           CMP      R12,#+0
   \   000006F0   0300001A           BNE      ??_DrawBitLine1BPP_42
   \   000006F4   01C0F6E5           LDRB     R12,[R6, #+1]!
   \   000006F8   03C0DCE7           LDRB     R12,[R12, +R3]
   \   000006FC   0EE08CE1           ORR      LR,R12,LR
   \   00000700   08C0A0E3           MOV      R12,#+8
    648                if (Bit) {
   \                     ??_DrawBitLine1BPP_42:
   \   00000704   018048E2           SUB      R8,R8,#+1
   \   00000708   00005AE3           CMP      R10,#+0
   \   0000070C   0400000A           BEQ      ??_DrawBitLine1BPP_43
    649                  Data &= 0xFF000000;
    650                  Data |= Index;
   \   00000710   FF7407E2           AND      R7,R7,#0xFF000000
   \   00000714   07708BE1           ORR      R7,R11,R7
    651                  xsize--;
    652                  if (!xsize) {
   \   00000718   000058E3           CMP      R8,#+0
   \   0000071C   0200001A           BNE      ??_DrawBitLine1BPP_44
   \   00000720   F9FEFFEA           B        ??_DrawBitLine1BPP_22
    653                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    654                    return;
    655                  }
    656                } else {
    657                  xsize--;
    658                  if (!xsize) {
   \                     ??_DrawBitLine1BPP_43:
   \   00000724   000058E3           CMP      R8,#+0
   \   00000728   6100000A           BEQ      ??_DrawBitLine1BPP_2
    659                    return;
    660                  }
    661                }
    662                GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_44:
   \   0000072C   01A01EE2           ANDS     R10,LR,#0x1
   \   00000730   02B0A011           MOVNE    R11,R2
   \   00000734   01B0A001           MOVEQ    R11,R1
   \   00000738   01C05CE2           SUBS     R12,R12,#+1
   \   0000073C   01C0D605           LDRBEQ   R12,[R6, #+1]
   \   00000740   AEE0A0E1           LSR      LR,LR,#+1
   \   00000744   0330DC07           LDRBEQ   R3,[R12, +R3]
    663                if (Bit) {
   \   00000748   01C084E2           ADD      R12,R4,#+1
   \   0000074C   0EE08301           ORREQ    LR,R3,LR
   \   00000750   013048E2           SUB      R3,R8,#+1
   \   00000754   00005AE3           CMP      R10,#+0
   \   00000758   0C00000A           BEQ      ??_DrawBitLine1BPP_45
    664                  Data &= 0x00FFFFFF;
    665                  Data |= Index << 24;
    666                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   0000075C   0764A0E1           LSL      R6,R7,#+8
   \   00000760   0B7CA0E1           LSL      R7,R11,#+24
   \   00000764   266487E1           ORR      R6,R7,R6, LSR #+8
   \   00000768   046185E7           STR      R6,[R5, +R4, LSL #+2]
    667                  Off++;
   \   0000076C   0C40A0E1           MOV      R4,R12
    668                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    669                  Data &= 0xFFFF0000;
    670                  Data |= Index >> 8;
   \   00000770   00C090E5           LDR      R12,[R0, #+0]
   \   00000774   2B54A0E1           LSR      R5,R11,#+8
   \   00000778   04C19CE7           LDR      R12,[R12, +R4, LSL #+2]
    671                  xsize--;
    672                  if (!xsize) {
   \   0000077C   000053E3           CMP      R3,#+0
   \   00000780   2CC8A0E1           LSR      R12,R12,#+16
   \   00000784   0C7885E1           ORR      R7,R5,R12, LSL #+16
   \   00000788   0600001A           BNE      ??_DrawBitLine1BPP_46
   \   0000078C   DEFEFFEA           B        ??_DrawBitLine1BPP_22
    673                    WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    674                    return;
    675                  }
    676                } else {
    677                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine1BPP_45:
   \   00000790   047185E7           STR      R7,[R5, +R4, LSL #+2]
    678                  Off++;
   \   00000794   0C40A0E1           MOV      R4,R12
    679                  xsize--;
    680                  if (!xsize) {
   \   00000798   000053E3           CMP      R3,#+0
   \   0000079C   4400000A           BEQ      ??_DrawBitLine1BPP_2
    681                    return;
    682                  }
    683                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
   \   000007A0   003090E5           LDR      R3,[R0, #+0]
   \   000007A4   047193E7           LDR      R7,[R3, +R4, LSL #+2]
    684                }
    685                GET_PIXEL_INDEX_TRANS(Index, Bit);
   \                     ??_DrawBitLine1BPP_46:
   \   000007A8   01A01EE2           ANDS     R10,LR,#0x1
   \   000007AC   02B0A011           MOVNE    R11,R2
   \   000007B0   01B0A001           MOVEQ    R11,R1
    686                if (Bit) {
   \   000007B4   D4FEFF0A           BEQ      ??_DrawBitLine1BPP_22
    687                  Data &= 0x0000FFFF;
    688                  Data |= Index << 16;
    689                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000007B8   0718A0E1           LSL      R1,R7,#+16
   \   000007BC   0B28A0E1           LSL      R2,R11,#+16
   \   000007C0   211882E1           ORR      R1,R2,R1, LSR #+16
   \   000007C4   002090E5           LDR      R2,[R0, #+0]
   \   000007C8   041182E7           STR      R1,[R2, +R4, LSL #+2]
    690                  Off++;
   \   000007CC   ECFEFFEA           B        ??_DrawBitLine1BPP_23
    691                  Data  = READ_MEM32(pContext->VRAMAddr, Off);
    692                  Data &= 0xFFFFFF00;
    693                  Data |= Index >> 16;
    694                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    695                } else {
    696                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    697                }
    698              }
    699              break;
    700            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    701            case LCD_DRAWMODE_XOR:
    702              IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \                     ??_DrawBitLine1BPP_4:
   \   000007D0   100094E5           LDR      R0,[R4, #+16]
   \   000007D4   080090E5           LDR      R0,[R0, #+8]
   \   000007D8   30FF2FE1           BLX      R0
   \   000007DC   00A0A0E1           MOV      R10,R0
   \   000007E0   80B0A0E3           MOV      R11,#+128
    703              do {
    704                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_47:
   \   000007E4   0000D6E5           LDRB     R0,[R6, #+0]
   \   000007E8   5B17A0E1           ASR      R1,R11,R7
   \   000007EC   000011E1           TST      R1,R0
   \   000007F0   2800000A           BEQ      ??_DrawBitLine1BPP_48
    705                  int Pixel = _GetPixelIndex(pDevice, x, y);
   \   000007F4   080094E5           LDR      R0,[R4, #+8]
   \   000007F8   103090E5           LDR      R3,[R0, #+16]
   \   000007FC   142090E5           LDR      R2,[R0, #+20]
   \   00000800   013043E2           SUB      R3,R3,#+1
   \   00000804   053043E0           SUB      R3,R3,R5
   \   00000808   930202E0           MUL      R2,R3,R2
   \   0000080C   893089E0           ADD      R3,R9,R9, LSL #+1
   \   00000810   822082E0           ADD      R2,R2,R2, LSL #+1
   \   00000814   022083E0           ADD      R2,R3,R2
   \   00000818   003090E5           LDR      R3,[R0, #+0]
   \   0000081C   2221A0E1           LSR      R2,R2,#+2
   \   00000820   030009E2           AND      R0,R9,#0x3
   \   00000824   02C193E7           LDR      R12,[R3, +R2, LSL #+2]
   \   00000828   030050E3           CMP      R0,#+3
   \   0000082C   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_DrawBitLine1BPP_1:
   \   00000830   1300008A           BHI      ??_DrawBitLine1BPP_49
   \   00000834   100000EA           B        ??_DrawBitLine1BPP_50
   \   00000838   080000EA           B        ??_DrawBitLine1BPP_51
   \   0000083C   020000EA           B        ??_DrawBitLine1BPP_52
   \   00000840   FFFFFFEA           B        ??_DrawBitLine1BPP_53
   \                     ??_DrawBitLine1BPP_53:
   \   00000844   2C14A0E1           LSR      R1,R12,#+8
   \   00000848   0D0000EA           B        ??_DrawBitLine1BPP_49
   \                     ??_DrawBitLine1BPP_52:
   \   0000084C   020183E0           ADD      R0,R3,R2, LSL #+2
   \   00000850   0400D0E5           LDRB     R0,[R0, #+4]
   \   00000854   0008A0E1           LSL      R0,R0,#+16
   \   00000858   2C1880E1           ORR      R1,R0,R12, LSR #+16
   \   0000085C   080000EA           B        ??_DrawBitLine1BPP_49
   \                     ??_DrawBitLine1BPP_51:
   \   00000860   020183E0           ADD      R0,R3,R2, LSL #+2
   \   00000864   B400D0E1           LDRH     R0,[R0, #+4]
   \   00000868   0008A0E1           LSL      R0,R0,#+16
   \   0000086C   2008A0E1           LSR      R0,R0,#+16
   \   00000870   0004A0E1           LSL      R0,R0,#+8
   \   00000874   2C1C80E1           ORR      R1,R0,R12, LSR #+24
   \   00000878   010000EA           B        ??_DrawBitLine1BPP_49
   \                     ??_DrawBitLine1BPP_50:
   \   0000087C   0C04A0E1           LSL      R0,R12,#+8
   \   00000880   2014A0E1           LSR      R1,R0,#+8
    706                  _SetPixelIndex(pDevice, x, y, Pixel ^ IndexMask);
   \                     ??_DrawBitLine1BPP_49:
   \   00000884   01302AE0           EOR      R3,R10,R1
   \   00000888   0520A0E1           MOV      R2,R5
   \   0000088C   0910A0E1           MOV      R1,R9
   \   00000890   0400A0E1           MOV      R0,R4
   \   00000894   ........           BL       _SetPixelIndex
    707                }
    708                x++;
    709                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_48:
   \   00000898   017087E2           ADD      R7,R7,#+1
   \   0000089C   080057E3           CMP      R7,#+8
    710                  Diff = 0;
   \   000008A0   0070A003           MOVEQ    R7,#+0
    711                  p++;
   \   000008A4   01608602           ADDEQ    R6,R6,#+1
   \   000008A8   019089E2           ADD      R9,R9,#+1
    712                }
    713              } while (--xsize);
   \   000008AC   018058E2           SUBS     R8,R8,#+1
   \   000008B0   CBFFFF1A           BNE      ??_DrawBitLine1BPP_47
   \                     ??_DrawBitLine1BPP_2:
   \   000008B4   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   000008B8   F08FBDE8           POP      {R4-R11,PC}      ;; return
    714              break;
    715            }
    716            #undef GET_PIXEL_INDEX
    717            #undef GET_PIXEL_INDEX_TRANS
    718          }
    719          
    720          /*********************************************************************
    721          *
    722          *       Draw Bitmap 2 BPP
    723          */

   \                                 In section .text, align 4, keep-with-next
    724          static void  _DrawBitLine2BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine2BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    725            LCD_PIXELINDEX Pixels, PixelIndex;
    726            int CurrentPixel, Shift, Index;
    727          
    728            Pixels = *p;
    729            CurrentPixel = Diff;
    730            x += Diff;
    731            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000008   ........           LDR      R0,??DataTable12
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   28409DE5           LDR      R4,[SP, #+40]
   \   00000018   0370A0E1           MOV      R7,R3
   \   0000001C   0260A0E1           MOV      R6,R2
   \   00000020   2C809DE5           LDR      R8,[SP, #+44]
   \   00000024   0090D7E5           LDRB     R9,[R7, #+0]
   \   00000028   01A084E0           ADD      R10,R4,R1
   \   0000002C   030010E2           ANDS     R0,R0,#0x3
   \   00000030   0200000A           BEQ      ??_DrawBitLine2BPP_0
   \   00000034   020050E2           SUBS     R0,R0,#+2
   \   00000038   2A00000A           BEQ      ??_DrawBitLine2BPP_1
   \   0000003C   540000EA           B        ??_DrawBitLine2BPP_2
    732            case 0:
    733              if (pTrans) {
   \                     ??_DrawBitLine2BPP_0:
   \   00000040   30009DE5           LDR      R0,[SP, #+48]
   \   00000044   C0B0A0E3           MOV      R11,#+192
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   1300000A           BEQ      ??_DrawBitLine2BPP_3
    734                do {
    735                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_4:
   \   00000050   030064E2           RSB      R0,R4,#+3
   \   00000054   8000A0E1           LSL      R0,R0,#+1
    736                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    737                  PixelIndex = *(pTrans + Index);
    738                  _SetPixelIndex(pDevice, x++, y, PixelIndex);
   \   00000058   0010A0E1           MOV      R1,R0
   \   0000005C   061061E2           RSB      R1,R1,#+6
   \   00000060   5B1109E0           AND      R1,R9,R11, ASR R1
   \   00000064   3100A0E1           LSR      R0,R1,R0
   \   00000068   30109DE5           LDR      R1,[SP, #+48]
   \   0000006C   0620A0E1           MOV      R2,R6
   \   00000070   003191E7           LDR      R3,[R1, +R0, LSL #+2]
   \   00000074   0A10A0E1           MOV      R1,R10
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           BL       _SetPixelIndex
    739                  if (++CurrentPixel == 4) {
   \   00000080   014084E2           ADD      R4,R4,#+1
   \   00000084   040054E3           CMP      R4,#+4
    740                    CurrentPixel = 0;
   \   00000088   0040A003           MOVEQ    R4,#+0
    741                    Pixels = *(++p);
   \   0000008C   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   00000090   01A08AE2           ADD      R10,R10,#+1
    742                  }
    743                } while (--xsize);
   \   00000094   018058E2           SUBS     R8,R8,#+1
   \   00000098   ECFFFF1A           BNE      ??_DrawBitLine2BPP_4
   \   0000009C   3C0000EA           B        ??_DrawBitLine2BPP_2
    744              } else {
    745                do {
    746                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_3:
   \   000000A0   030064E2           RSB      R0,R4,#+3
   \   000000A4   8000A0E1           LSL      R0,R0,#+1
    747                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    748                  _SetPixelIndex(pDevice, x++, y, Index);
   \   000000A8   0010A0E1           MOV      R1,R0
   \   000000AC   061061E2           RSB      R1,R1,#+6
   \   000000B0   5B1109E0           AND      R1,R9,R11, ASR R1
   \   000000B4   3130A0E1           LSR      R3,R1,R0
   \   000000B8   0620A0E1           MOV      R2,R6
   \   000000BC   0A10A0E1           MOV      R1,R10
   \   000000C0   0500A0E1           MOV      R0,R5
   \   000000C4   ........           BL       _SetPixelIndex
    749                  if (++CurrentPixel == 4) {
   \   000000C8   014084E2           ADD      R4,R4,#+1
   \   000000CC   040054E3           CMP      R4,#+4
    750                    CurrentPixel = 0;
   \   000000D0   0040A003           MOVEQ    R4,#+0
    751                    Pixels = *(++p);
   \   000000D4   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   000000D8   01A08AE2           ADD      R10,R10,#+1
    752                  }
    753                } while (--xsize);
   \   000000DC   018058E2           SUBS     R8,R8,#+1
   \   000000E0   EEFFFF1A           BNE      ??_DrawBitLine2BPP_3
   \   000000E4   2A0000EA           B        ??_DrawBitLine2BPP_2
    754              }
    755              break;
    756            case LCD_DRAWMODE_TRANS:
    757              if (pTrans) {
   \                     ??_DrawBitLine2BPP_1:
   \   000000E8   30009DE5           LDR      R0,[SP, #+48]
   \   000000EC   C0B0A0E3           MOV      R11,#+192
   \   000000F0   000050E3           CMP      R0,#+0
   \   000000F4   1400000A           BEQ      ??_DrawBitLine2BPP_5
    758                do {
    759                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_6:
   \   000000F8   030064E2           RSB      R0,R4,#+3
   \   000000FC   8000A0E1           LSL      R0,R0,#+1
    760                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000100   0010A0E1           MOV      R1,R0
   \   00000104   061061E2           RSB      R1,R1,#+6
   \   00000108   5B1109E0           AND      R1,R9,R11, ASR R1
   \   0000010C   3130B0E1           LSRS     R3,R1,R0
    761                  if (Index) {
   \   00000110   0500000A           BEQ      ??_DrawBitLine2BPP_7
    762                    PixelIndex = *(pTrans + Index);
    763                    _SetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000114   30009DE5           LDR      R0,[SP, #+48]
   \   00000118   0620A0E1           MOV      R2,R6
   \   0000011C   033190E7           LDR      R3,[R0, +R3, LSL #+2]
   \   00000120   0A10A0E1           MOV      R1,R10
   \   00000124   0500A0E1           MOV      R0,R5
   \   00000128   ........           BL       _SetPixelIndex
    764                  }
    765                  x++;
    766                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_7:
   \   0000012C   014084E2           ADD      R4,R4,#+1
   \   00000130   040054E3           CMP      R4,#+4
    767                    CurrentPixel = 0;
   \   00000134   0040A003           MOVEQ    R4,#+0
    768                    Pixels = *(++p);
   \   00000138   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   0000013C   01A08AE2           ADD      R10,R10,#+1
    769                  }
    770                } while (--xsize);
   \   00000140   018058E2           SUBS     R8,R8,#+1
   \   00000144   EBFFFF1A           BNE      ??_DrawBitLine2BPP_6
   \   00000148   110000EA           B        ??_DrawBitLine2BPP_2
    771              } else {
    772                do {
    773                  Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_5:
   \   0000014C   030064E2           RSB      R0,R4,#+3
   \   00000150   8000A0E1           LSL      R0,R0,#+1
    774                  Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   00000154   0010A0E1           MOV      R1,R0
   \   00000158   061061E2           RSB      R1,R1,#+6
   \   0000015C   5B1109E0           AND      R1,R9,R11, ASR R1
   \   00000160   3130B0E1           LSRS     R3,R1,R0
    775                  if (Index) {
   \   00000164   0300000A           BEQ      ??_DrawBitLine2BPP_8
    776                    _SetPixelIndex(pDevice, x, y, Index);
   \   00000168   0620A0E1           MOV      R2,R6
   \   0000016C   0A10A0E1           MOV      R1,R10
   \   00000170   0500A0E1           MOV      R0,R5
   \   00000174   ........           BL       _SetPixelIndex
    777                  }
    778                  x++;
    779                  if (++CurrentPixel == 4) {
   \                     ??_DrawBitLine2BPP_8:
   \   00000178   014084E2           ADD      R4,R4,#+1
   \   0000017C   040054E3           CMP      R4,#+4
    780                    CurrentPixel = 0;
   \   00000180   0040A003           MOVEQ    R4,#+0
    781                    Pixels = *(++p);
   \   00000184   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   00000188   01A08AE2           ADD      R10,R10,#+1
    782                  }
    783                } while (--xsize);
   \   0000018C   018058E2           SUBS     R8,R8,#+1
   \   00000190   EDFFFF1A           BNE      ??_DrawBitLine2BPP_5
    784              }
    785              break;
    786            }
    787          }
   \                     ??_DrawBitLine2BPP_2:
   \   00000194   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000198   F08FBDE8           POP      {R4-R11,PC}      ;; return
    788          
    789          /*********************************************************************
    790          *
    791          *       Draw Bitmap 4 BPP
    792          */

   \                                 In section .text, align 4, keep-with-next
    793          static void  _DrawBitLine4BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine4BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    794            LCD_PIXELINDEX Pixels, PixelIndex;
    795            int CurrentPixel, Shift, Index;
    796          
    797            Pixels = *p;
    798            CurrentPixel = Diff;
    799            x += Diff;
    800            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000008   ........           LDR      R0,??DataTable15
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   28409DE5           LDR      R4,[SP, #+40]
   \   00000018   0370A0E1           MOV      R7,R3
   \   0000001C   0260A0E1           MOV      R6,R2
   \   00000020   2C809DE5           LDR      R8,[SP, #+44]
   \   00000024   0090D7E5           LDRB     R9,[R7, #+0]
   \   00000028   01A084E0           ADD      R10,R4,R1
   \   0000002C   030010E2           ANDS     R0,R0,#0x3
   \   00000030   0200000A           BEQ      ??_DrawBitLine4BPP_0
   \   00000034   020050E2           SUBS     R0,R0,#+2
   \   00000038   2A00000A           BEQ      ??_DrawBitLine4BPP_1
   \   0000003C   540000EA           B        ??_DrawBitLine4BPP_2
    801            case 0:
    802              if (pTrans) {
   \                     ??_DrawBitLine4BPP_0:
   \   00000040   30009DE5           LDR      R0,[SP, #+48]
   \   00000044   F0B0A0E3           MOV      R11,#+240
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   1300000A           BEQ      ??_DrawBitLine4BPP_3
    803                do {
    804                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_4:
   \   00000050   010064E2           RSB      R0,R4,#+1
   \   00000054   0001A0E1           LSL      R0,R0,#+2
    805                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    806                  PixelIndex = *(pTrans + Index);
    807                  _SetPixelIndex(pDevice, x++, y, PixelIndex);
   \   00000058   0010A0E1           MOV      R1,R0
   \   0000005C   041061E2           RSB      R1,R1,#+4
   \   00000060   5B1109E0           AND      R1,R9,R11, ASR R1
   \   00000064   3100A0E1           LSR      R0,R1,R0
   \   00000068   30109DE5           LDR      R1,[SP, #+48]
   \   0000006C   0620A0E1           MOV      R2,R6
   \   00000070   003191E7           LDR      R3,[R1, +R0, LSL #+2]
   \   00000074   0A10A0E1           MOV      R1,R10
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           BL       _SetPixelIndex
    808                  if (++CurrentPixel == 2) {
   \   00000080   014084E2           ADD      R4,R4,#+1
   \   00000084   020054E3           CMP      R4,#+2
    809                    CurrentPixel = 0;
   \   00000088   0040A003           MOVEQ    R4,#+0
    810                    Pixels = *(++p);
   \   0000008C   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   00000090   01A08AE2           ADD      R10,R10,#+1
    811                  }
    812                } while (--xsize);
   \   00000094   018058E2           SUBS     R8,R8,#+1
   \   00000098   ECFFFF1A           BNE      ??_DrawBitLine4BPP_4
   \   0000009C   3C0000EA           B        ??_DrawBitLine4BPP_2
    813              } else {
    814                do {
    815                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_3:
   \   000000A0   010064E2           RSB      R0,R4,#+1
   \   000000A4   0001A0E1           LSL      R0,R0,#+2
    816                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    817                  _SetPixelIndex(pDevice, x++, y, Index);
   \   000000A8   0010A0E1           MOV      R1,R0
   \   000000AC   041061E2           RSB      R1,R1,#+4
   \   000000B0   5B1109E0           AND      R1,R9,R11, ASR R1
   \   000000B4   3130A0E1           LSR      R3,R1,R0
   \   000000B8   0620A0E1           MOV      R2,R6
   \   000000BC   0A10A0E1           MOV      R1,R10
   \   000000C0   0500A0E1           MOV      R0,R5
   \   000000C4   ........           BL       _SetPixelIndex
    818                  if (++CurrentPixel == 2) {
   \   000000C8   014084E2           ADD      R4,R4,#+1
   \   000000CC   020054E3           CMP      R4,#+2
    819                    CurrentPixel = 0;
   \   000000D0   0040A003           MOVEQ    R4,#+0
    820                    Pixels = *(++p);
   \   000000D4   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   000000D8   01A08AE2           ADD      R10,R10,#+1
    821                  }
    822                } while (--xsize);
   \   000000DC   018058E2           SUBS     R8,R8,#+1
   \   000000E0   EEFFFF1A           BNE      ??_DrawBitLine4BPP_3
   \   000000E4   2A0000EA           B        ??_DrawBitLine4BPP_2
    823              }
    824              break;
    825            case LCD_DRAWMODE_TRANS:
    826              if (pTrans) {
   \                     ??_DrawBitLine4BPP_1:
   \   000000E8   30009DE5           LDR      R0,[SP, #+48]
   \   000000EC   F0B0A0E3           MOV      R11,#+240
   \   000000F0   000050E3           CMP      R0,#+0
   \   000000F4   1400000A           BEQ      ??_DrawBitLine4BPP_5
    827                do {
    828                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_6:
   \   000000F8   010064E2           RSB      R0,R4,#+1
   \   000000FC   0001A0E1           LSL      R0,R0,#+2
    829                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000100   0010A0E1           MOV      R1,R0
   \   00000104   041061E2           RSB      R1,R1,#+4
   \   00000108   5B1109E0           AND      R1,R9,R11, ASR R1
   \   0000010C   3130B0E1           LSRS     R3,R1,R0
    830                  if (Index) {
   \   00000110   0500000A           BEQ      ??_DrawBitLine4BPP_7
    831                    PixelIndex = *(pTrans + Index);
    832                    _SetPixelIndex(pDevice, x, y, PixelIndex);
   \   00000114   30009DE5           LDR      R0,[SP, #+48]
   \   00000118   0620A0E1           MOV      R2,R6
   \   0000011C   033190E7           LDR      R3,[R0, +R3, LSL #+2]
   \   00000120   0A10A0E1           MOV      R1,R10
   \   00000124   0500A0E1           MOV      R0,R5
   \   00000128   ........           BL       _SetPixelIndex
    833                  }
    834                  x++;
    835                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_7:
   \   0000012C   014084E2           ADD      R4,R4,#+1
   \   00000130   020054E3           CMP      R4,#+2
    836                    CurrentPixel = 0;
   \   00000134   0040A003           MOVEQ    R4,#+0
    837                    Pixels = *(++p);
   \   00000138   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   0000013C   01A08AE2           ADD      R10,R10,#+1
    838                  }
    839                } while (--xsize);
   \   00000140   018058E2           SUBS     R8,R8,#+1
   \   00000144   EBFFFF1A           BNE      ??_DrawBitLine4BPP_6
   \   00000148   110000EA           B        ??_DrawBitLine4BPP_2
    840              } else {
    841                do {
    842                  Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_5:
   \   0000014C   010064E2           RSB      R0,R4,#+1
   \   00000150   0001A0E1           LSL      R0,R0,#+2
    843                  Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   00000154   0010A0E1           MOV      R1,R0
   \   00000158   041061E2           RSB      R1,R1,#+4
   \   0000015C   5B1109E0           AND      R1,R9,R11, ASR R1
   \   00000160   3130B0E1           LSRS     R3,R1,R0
    844                  if (Index) {
   \   00000164   0300000A           BEQ      ??_DrawBitLine4BPP_8
    845                    _SetPixelIndex(pDevice, x, y, Index);
   \   00000168   0620A0E1           MOV      R2,R6
   \   0000016C   0A10A0E1           MOV      R1,R10
   \   00000170   0500A0E1           MOV      R0,R5
   \   00000174   ........           BL       _SetPixelIndex
    846                  }
    847                  x++;
    848                  if (++CurrentPixel == 2) {
   \                     ??_DrawBitLine4BPP_8:
   \   00000178   014084E2           ADD      R4,R4,#+1
   \   0000017C   020054E3           CMP      R4,#+2
    849                    CurrentPixel = 0;
   \   00000180   0040A003           MOVEQ    R4,#+0
    850                    Pixels = *(++p);
   \   00000184   0190F705           LDRBEQ   R9,[R7, #+1]!
   \   00000188   01A08AE2           ADD      R10,R10,#+1
    851                  }
    852                } while (--xsize);
   \   0000018C   018058E2           SUBS     R8,R8,#+1
   \   00000190   EDFFFF1A           BNE      ??_DrawBitLine4BPP_5
    853              }
    854              break;
    855            }
    856          }
   \                     ??_DrawBitLine4BPP_2:
   \   00000194   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000198   F08FBDE8           POP      {R4-R11,PC}      ;; return
    857          
    858          /*********************************************************************
    859          *
    860          *       Draw Bitmap 8 BPP
    861          */

   \                                 In section .text, align 4, keep-with-next
    862          static void  _DrawBitLine8BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine8BPP:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    863            LCD_PIXELINDEX Pixel;
    864          
    865            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000008   ........           LDR      R0,??DataTable15
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0170A0E1           MOV      R7,R1
   \   00000018   0250A0E1           MOV      R5,R2
   \   0000001C   0360A0E1           MOV      R6,R3
   \   00000020   20909DE5           LDR      R9,[SP, #+32]
   \   00000024   24809DE5           LDR      R8,[SP, #+36]
   \   00000028   030010E2           ANDS     R0,R0,#0x3
   \   0000002C   0200000A           BEQ      ??_DrawBitLine8BPP_0
   \   00000030   020050E2           SUBS     R0,R0,#+2
   \   00000034   3700000A           BEQ      ??_DrawBitLine8BPP_1
   \   00000038   850000EA           B        ??_DrawBitLine8BPP_2
    866            case 0:
    867              if (pTrans) {
   \                     ??_DrawBitLine8BPP_0:
   \   0000003C   000058E3           CMP      R8,#+0
   \   00000040   1B00000A           BEQ      ??_DrawBitLine8BPP_3
   \   00000044   010059E3           CMP      R9,#+1
   \   00000048   810000BA           BLT      ??_DrawBitLine8BPP_2
   \   0000004C   010019E3           TST      R9,#0x1
   \   00000050   0400000A           BEQ      ??_DrawBitLine8BPP_4
    868                for (; xsize > 0; xsize--, x++, p++) {
    869                  Pixel = *p;
    870                  _SetPixelIndex(pDevice, x, y, *(pTrans + Pixel));
   \   00000054   0100D6E4           LDRB     R0,[R6], #+1
   \   00000058   003198E7           LDR      R3,[R8, +R0, LSL #+2]
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           BL       _SetPixelIndex
   \   00000064   017087E2           ADD      R7,R7,#+1
   \                     ??_DrawBitLine8BPP_4:
   \   00000068   A990B0E1           LSRS     R9,R9,#+1
   \   0000006C   7800000A           BEQ      ??_DrawBitLine8BPP_2
   \                     ??_DrawBitLine8BPP_5:
   \   00000070   0100D6E4           LDRB     R0,[R6], #+1
   \   00000074   0520A0E1           MOV      R2,R5
   \   00000078   0710A0E1           MOV      R1,R7
   \   0000007C   003198E7           LDR      R3,[R8, +R0, LSL #+2]
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   ........           BL       _SetPixelIndex
   \   00000088   0100D6E4           LDRB     R0,[R6], #+1
   \   0000008C   017087E2           ADD      R7,R7,#+1
   \   00000090   0520A0E1           MOV      R2,R5
   \   00000094   003198E7           LDR      R3,[R8, +R0, LSL #+2]
   \   00000098   0710A0E1           MOV      R1,R7
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   ........           BL       _SetPixelIndex
    871                }
   \   000000A4   017087E2           ADD      R7,R7,#+1
   \   000000A8   019059E2           SUBS     R9,R9,#+1
   \   000000AC   EFFFFF1A           BNE      ??_DrawBitLine8BPP_5
   \   000000B0   670000EA           B        ??_DrawBitLine8BPP_2
    872              } else {
   \                     ??_DrawBitLine8BPP_3:
   \   000000B4   010059E3           CMP      R9,#+1
   \   000000B8   650000BA           BLT      ??_DrawBitLine8BPP_2
   \   000000BC   010019E3           TST      R9,#0x1
   \   000000C0   0300000A           BEQ      ??_DrawBitLine8BPP_6
    873                for (; xsize > 0; xsize--, x++, p++) {
    874                  _SetPixelIndex(pDevice, x, y, *p);
   \   000000C4   0130D6E4           LDRB     R3,[R6], #+1
   \   000000C8   0400A0E1           MOV      R0,R4
   \   000000CC   ........           BL       _SetPixelIndex
   \   000000D0   017087E2           ADD      R7,R7,#+1
   \                     ??_DrawBitLine8BPP_6:
   \   000000D4   A980B0E1           LSRS     R8,R9,#+1
   \   000000D8   5D00000A           BEQ      ??_DrawBitLine8BPP_2
   \                     ??_DrawBitLine8BPP_7:
   \   000000DC   0130D6E4           LDRB     R3,[R6], #+1
   \   000000E0   0520A0E1           MOV      R2,R5
   \   000000E4   0710A0E1           MOV      R1,R7
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       _SetPixelIndex
   \   000000F0   017087E2           ADD      R7,R7,#+1
   \   000000F4   0130D6E4           LDRB     R3,[R6], #+1
   \   000000F8   0520A0E1           MOV      R2,R5
   \   000000FC   0710A0E1           MOV      R1,R7
   \   00000100   0400A0E1           MOV      R0,R4
   \   00000104   ........           BL       _SetPixelIndex
    875                }
   \   00000108   017087E2           ADD      R7,R7,#+1
   \   0000010C   018058E2           SUBS     R8,R8,#+1
   \   00000110   F1FFFF1A           BNE      ??_DrawBitLine8BPP_7
   \   00000114   4E0000EA           B        ??_DrawBitLine8BPP_2
    876              }
    877              break;
    878            case LCD_DRAWMODE_TRANS:
    879              if (pTrans) {
   \                     ??_DrawBitLine8BPP_1:
   \   00000118   000058E3           CMP      R8,#+0
   \   0000011C   2600000A           BEQ      ??_DrawBitLine8BPP_8
   \   00000120   010059E3           CMP      R9,#+1
   \   00000124   4A0000BA           BLT      ??_DrawBitLine8BPP_2
   \   00000128   019049E2           SUB      R9,R9,#+1
   \   0000012C   0030D6E5           LDRB     R3,[R6, #+0]
   \   00000130   010019E3           TST      R9,#0x1
   \   00000134   0600000A           BEQ      ??_DrawBitLine8BPP_9
    880                for (; xsize > 0; xsize--, x++, p++) {
    881                  Pixel = *p;
    882                  if (Pixel) {
   \   00000138   000053E3           CMP      R3,#+0
   \   0000013C   0200000A           BEQ      ??_DrawBitLine8BPP_10
    883                    _SetPixelIndex(pDevice, x, y, *(pTrans + Pixel));
   \   00000140   033198E7           LDR      R3,[R8, +R3, LSL #+2]
   \   00000144   0400A0E1           MOV      R0,R4
   \   00000148   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_10:
   \   0000014C   017087E2           ADD      R7,R7,#+1
   \   00000150   0130F6E5           LDRB     R3,[R6, #+1]!
   \                     ??_DrawBitLine8BPP_9:
   \   00000154   A990B0E1           LSRS     R9,R9,#+1
   \   00000158   1300000A           BEQ      ??_DrawBitLine8BPP_11
   \                     ??_DrawBitLine8BPP_12:
   \   0000015C   000053E3           CMP      R3,#+0
   \   00000160   0400000A           BEQ      ??_DrawBitLine8BPP_13
   \   00000164   033198E7           LDR      R3,[R8, +R3, LSL #+2]
   \   00000168   0520A0E1           MOV      R2,R5
   \   0000016C   0710A0E1           MOV      R1,R7
   \   00000170   0400A0E1           MOV      R0,R4
   \   00000174   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_13:
   \   00000178   0130F6E5           LDRB     R3,[R6, #+1]!
   \   0000017C   017087E2           ADD      R7,R7,#+1
   \   00000180   000053E3           CMP      R3,#+0
   \   00000184   0400000A           BEQ      ??_DrawBitLine8BPP_14
   \   00000188   033198E7           LDR      R3,[R8, +R3, LSL #+2]
   \   0000018C   0520A0E1           MOV      R2,R5
   \   00000190   0710A0E1           MOV      R1,R7
   \   00000194   0400A0E1           MOV      R0,R4
   \   00000198   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_14:
   \   0000019C   017087E2           ADD      R7,R7,#+1
   \   000001A0   0130F6E5           LDRB     R3,[R6, #+1]!
   \   000001A4   019059E2           SUBS     R9,R9,#+1
   \   000001A8   EBFFFF1A           BNE      ??_DrawBitLine8BPP_12
   \                     ??_DrawBitLine8BPP_11:
   \   000001AC   000053E3           CMP      R3,#+0
   \   000001B0   2700000A           BEQ      ??_DrawBitLine8BPP_2
   \   000001B4   033198E7           LDR      R3,[R8, +R3, LSL #+2]
   \   000001B8   210000EA           B        ??_DrawBitLine8BPP_15
    884                  }
    885                }
    886              } else {
   \                     ??_DrawBitLine8BPP_8:
   \   000001BC   010059E3           CMP      R9,#+1
   \   000001C0   230000BA           BLT      ??_DrawBitLine8BPP_2
   \   000001C4   018049E2           SUB      R8,R9,#+1
   \   000001C8   0030D6E5           LDRB     R3,[R6, #+0]
   \   000001CC   010018E3           TST      R8,#0x1
   \   000001D0   0500000A           BEQ      ??_DrawBitLine8BPP_16
    887                for (; xsize > 0; xsize--, x++, p++) {
    888                  Pixel = *p;
    889                  if (Pixel) {
   \   000001D4   000053E3           CMP      R3,#+0
   \   000001D8   0100000A           BEQ      ??_DrawBitLine8BPP_17
    890                    _SetPixelIndex(pDevice, x, y, Pixel);
   \   000001DC   0400A0E1           MOV      R0,R4
   \   000001E0   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_17:
   \   000001E4   017087E2           ADD      R7,R7,#+1
   \   000001E8   0130F6E5           LDRB     R3,[R6, #+1]!
   \                     ??_DrawBitLine8BPP_16:
   \   000001EC   A880B0E1           LSRS     R8,R8,#+1
   \   000001F0   1100000A           BEQ      ??_DrawBitLine8BPP_18
   \                     ??_DrawBitLine8BPP_19:
   \   000001F4   000053E3           CMP      R3,#+0
   \   000001F8   0300000A           BEQ      ??_DrawBitLine8BPP_20
   \   000001FC   0520A0E1           MOV      R2,R5
   \   00000200   0710A0E1           MOV      R1,R7
   \   00000204   0400A0E1           MOV      R0,R4
   \   00000208   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_20:
   \   0000020C   0130F6E5           LDRB     R3,[R6, #+1]!
   \   00000210   017087E2           ADD      R7,R7,#+1
   \   00000214   000053E3           CMP      R3,#+0
   \   00000218   0300000A           BEQ      ??_DrawBitLine8BPP_21
   \   0000021C   0520A0E1           MOV      R2,R5
   \   00000220   0710A0E1           MOV      R1,R7
   \   00000224   0400A0E1           MOV      R0,R4
   \   00000228   ........           BL       _SetPixelIndex
   \                     ??_DrawBitLine8BPP_21:
   \   0000022C   017087E2           ADD      R7,R7,#+1
   \   00000230   0130F6E5           LDRB     R3,[R6, #+1]!
   \   00000234   018058E2           SUBS     R8,R8,#+1
   \   00000238   EDFFFF1A           BNE      ??_DrawBitLine8BPP_19
   \                     ??_DrawBitLine8BPP_18:
   \   0000023C   000053E3           CMP      R3,#+0
   \   00000240   0300000A           BEQ      ??_DrawBitLine8BPP_2
   \                     ??_DrawBitLine8BPP_15:
   \   00000244   0520A0E1           MOV      R2,R5
   \   00000248   0710A0E1           MOV      R1,R7
   \   0000024C   0400A0E1           MOV      R0,R4
   \   00000250   ........           BL       _SetPixelIndex
    891                  }
    892                }
    893              }
    894              break;
    895            }
    896          }
   \                     ??_DrawBitLine8BPP_2:
   \   00000254   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000258   F083BDE8           POP      {R4-R9,PC}       ;; return
    897          
    898          /*********************************************************************
    899          *
    900          *       Draw Bitmap 32 BPP
    901          */

   \                                 In section .text, align 4, keep-with-next
    902          static void _DrawBitLine32BPP(GUI_DEVICE * pDevice, int x, int y, U32 const GUI_UNI_PTR * p, int xsize) {
   \                     _DrawBitLine32BPP:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    903            #define GET_PIXEL_INDEX(Index) Index = *p++
    904            DRIVER_CONTEXT * pContext;
    905            U32 Data, Data0, Data1, Data2, Index;
    906            unsigned Off, Odd;
    907          
    908            //
    909            // Get context
    910            //
    911            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   10C09DE5           LDR      R12,[SP, #+16]
    912            //
    913            // Mirror y
    914            //
    915            y = (pContext->vySize - 1 - (y));
    916            //
    917            // First triple DWORD
    918            //
    919            Off = XY2OFF32(pContext->vxSizePhys, x, y);
   \   0000000C   10E090E5           LDR      LR,[R0, #+16]
   \   00000010   01E04EE2           SUB      LR,LR,#+1
   \   00000014   02204EE0           SUB      R2,LR,R2
   \   00000018   14E090E5           LDR      LR,[R0, #+20]
   \   0000001C   9E0202E0           MUL      R2,LR,R2
   \   00000020   81E081E0           ADD      LR,R1,R1, LSL #+1
   \   00000024   822082E0           ADD      R2,R2,R2, LSL #+1
   \   00000028   02208EE0           ADD      R2,LR,R2
   \   0000002C   2221A0E1           LSR      R2,R2,#+2
    920            Odd = x & 3;
   \   00000030   031011E2           ANDS     R1,R1,#0x3
    921            if (Odd) {
   \   00000034   2C00000A           BEQ      ??_DrawBitLine32BPP_0
    922              Data    = READ_MEM32(pContext->VRAMAddr, Off);
   \   00000038   00E090E5           LDR      LR,[R0, #+0]
    923              switch (Odd) {
   \   0000003C   010051E3           CMP      R1,#+1
   \   00000040   02419EE7           LDR      R4,[LR, +R2, LSL #+2]
   \   00000044   0400000A           BEQ      ??_DrawBitLine32BPP_1
   \   00000048   2700003A           BCC      ??_DrawBitLine32BPP_0
   \   0000004C   030051E3           CMP      R1,#+3
   \   00000050   1E00000A           BEQ      ??_DrawBitLine32BPP_2
   \   00000054   1000003A           BCC      ??_DrawBitLine32BPP_3
   \   00000058   230000EA           B        ??_DrawBitLine32BPP_0
    924              case 1:
    925                GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine32BPP_1:
   \   0000005C   041093E4           LDR      R1,[R3], #+4
    926                Data &= 0x00FFFFFF;
    927                Data |= Index << 24;
    928                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   00000060   0444A0E1           LSL      R4,R4,#+8
   \   00000064   015CA0E1           LSL      R5,R1,#+24
   \   00000068   244485E1           ORR      R4,R5,R4, LSR #+8
   \   0000006C   02418EE7           STR      R4,[LR, +R2, LSL #+2]
    929                Off++;
    930                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    931                Data &= 0xFFFF0000;
    932                Data |= Index >> 8;
   \   00000070   00E090E5           LDR      LR,[R0, #+0]
   \   00000074   012082E2           ADD      R2,R2,#+1
   \   00000078   02E19EE7           LDR      LR,[LR, +R2, LSL #+2]
   \   0000007C   2114A0E1           LSR      R1,R1,#+8
   \   00000080   2EE8A0E1           LSR      LR,LR,#+16
   \   00000084   0E4881E1           ORR      R4,R1,LR, LSL #+16
    933                xsize--;
   \   00000088   01C05CE2           SUBS     R12,R12,#+1
    934                if (!xsize) {
   \   0000008C   0200001A           BNE      ??_DrawBitLine32BPP_3
    935                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine32BPP_4:
   \   00000090   001090E5           LDR      R1,[R0, #+0]
   \   00000094   024181E7           STR      R4,[R1, +R2, LSL #+2]
    936                  break;
   \   00000098   130000EA           B        ??_DrawBitLine32BPP_0
    937                }
    938              case 2:
    939                GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine32BPP_3:
   \   0000009C   041093E4           LDR      R1,[R3], #+4
    940                Data &= 0x0000FFFF;
    941                Data |= Index << 16;
    942                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000000A0   04E8A0E1           LSL      LR,R4,#+16
   \   000000A4   0148A0E1           LSL      R4,R1,#+16
   \   000000A8   2EE884E1           ORR      LR,R4,LR, LSR #+16
   \   000000AC   004090E5           LDR      R4,[R0, #+0]
    943                Off++;
    944                Data  = READ_MEM32(pContext->VRAMAddr, Off);
    945                Data &= 0xFFFFFF00;
    946                Data |= Index >> 16;
    947                xsize--;
   \   000000B0   01C05CE2           SUBS     R12,R12,#+1
   \   000000B4   02E184E7           STR      LR,[R4, +R2, LSL #+2]
   \   000000B8   00E090E5           LDR      LR,[R0, #+0]
   \   000000BC   012082E2           ADD      R2,R2,#+1
   \   000000C0   02E19EE7           LDR      LR,[LR, +R2, LSL #+2]
   \   000000C4   FFE0CEE3           BIC      LR,LR,#0xFF
   \   000000C8   21488EE1           ORR      R4,LR,R1, LSR #+16
    948                if (!xsize) {
   \   000000CC   EFFFFF0A           BEQ      ??_DrawBitLine32BPP_4
    949                  WRITE_MEM32(pContext->VRAMAddr, Off, Data);
    950                  break;
    951                }
    952              case 3:
    953                GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine32BPP_2:
   \   000000D0   041093E4           LDR      R1,[R3], #+4
    954                Data &= 0x000000FF;
    955                Data |= Index << 8;
    956                xsize--;
    957                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000000D4   FFE004E2           AND      LR,R4,#0xFF
   \   000000D8   01148EE1           ORR      R1,LR,R1, LSL #+8
   \   000000DC   00E090E5           LDR      LR,[R0, #+0]
   \   000000E0   01C04CE2           SUB      R12,R12,#+1
   \   000000E4   02118EE7           STR      R1,[LR, +R2, LSL #+2]
    958                Off++;
   \   000000E8   012082E2           ADD      R2,R2,#+1
    959              }
    960            }
    961            //
    962            // Complete triple DWORDS
    963            //
    964            if (xsize >= 4) {
   \                     ??_DrawBitLine32BPP_0:
   \   000000EC   04005CE3           CMP      R12,#+4
   \   000000F0   140000BA           BLT      ??_DrawBitLine32BPP_5
    965              do {
    966                GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine32BPP_6:
   \   000000F4   041093E4           LDR      R1,[R3], #+4
    967                Data0  = (Index      );
    968                GET_PIXEL_INDEX(Index);
   \   000000F8   04E093E4           LDR      LR,[R3], #+4
    969                Data0 |= (Index << 24);
    970                Data1  = (Index >>  8);
    971                GET_PIXEL_INDEX(Index);
    972                Data1 |= (Index << 16);
    973                Data2  = (Index >> 16);
    974                GET_PIXEL_INDEX(Index);
    975                Data2 |= (Index <<  8);
    976                WRITE_MEM32(pContext->VRAMAddr, Off + 0, Data0);
   \   000000FC   006090E5           LDR      R6,[R0, #+0]
   \   00000100   0E4C81E1           ORR      R4,R1,LR, LSL #+24
   \   00000104   2E14A0E1           LSR      R1,LR,#+8
   \   00000108   04E093E4           LDR      LR,[R3], #+4
    977                WRITE_MEM32(pContext->VRAMAddr, Off + 1, Data1);
    978                WRITE_MEM32(pContext->VRAMAddr, Off + 2, Data2);
    979                Off += 3;
    980              } while ((xsize -= 4) >= 4);
   \   0000010C   04C04CE2           SUB      R12,R12,#+4
   \   00000110   0E5881E1           ORR      R5,R1,LR, LSL #+16
   \   00000114   041093E4           LDR      R1,[R3], #+4
   \   00000118   024186E7           STR      R4,[R6, +R2, LSL #+2]
   \   0000011C   004090E5           LDR      R4,[R0, #+0]
   \   00000120   2EE8A0E1           LSR      LR,LR,#+16
   \   00000124   024184E0           ADD      R4,R4,R2, LSL #+2
   \   00000128   045084E5           STR      R5,[R4, #+4]
   \   0000012C   004090E5           LDR      R4,[R0, #+0]
   \   00000130   01148EE1           ORR      R1,LR,R1, LSL #+8
   \   00000134   024184E0           ADD      R4,R4,R2, LSL #+2
   \   00000138   081084E5           STR      R1,[R4, #+8]
   \   0000013C   032082E2           ADD      R2,R2,#+3
   \   00000140   04005CE3           CMP      R12,#+4
   \   00000144   EAFFFFAA           BGE      ??_DrawBitLine32BPP_6
    981            }
    982            //
    983            // Last triple DWORD
    984            //
    985            if (xsize) {
   \                     ??_DrawBitLine32BPP_5:
   \   00000148   00005CE3           CMP      R12,#+0
   \   0000014C   2100000A           BEQ      ??_DrawBitLine32BPP_7
    986              Data  = READ_MEM32(pContext->VRAMAddr, Off);
    987              Data &= 0xFF000000;
    988              GET_PIXEL_INDEX(Index);
    989              Data |= Index;
   \   00000150   00E090E5           LDR      LR,[R0, #+0]
   \   00000154   041093E4           LDR      R1,[R3], #+4
   \   00000158   02419EE7           LDR      R4,[LR, +R2, LSL #+2]
    990              xsize--;
   \   0000015C   01C05CE2           SUBS     R12,R12,#+1
   \   00000160   FF4404E2           AND      R4,R4,#0xFF000000
   \   00000164   044081E1           ORR      R4,R1,R4
    991              if (!xsize) {
   \   00000168   0200001A           BNE      ??_DrawBitLine32BPP_8
    992                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \                     ??_DrawBitLine32BPP_9:
   \   0000016C   000090E5           LDR      R0,[R0, #+0]
   \   00000170   024180E7           STR      R4,[R0, +R2, LSL #+2]
    993                return;
   \   00000174   7080BDE8           POP      {R4-R6,PC}
    994              }
    995              Data &= 0x00FFFFFF;
    996              GET_PIXEL_INDEX(Index);
   \                     ??_DrawBitLine32BPP_8:
   \   00000178   041093E4           LDR      R1,[R3], #+4
    997              Data |= Index << 24;
    998              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   0000017C   0444A0E1           LSL      R4,R4,#+8
   \   00000180   015CA0E1           LSL      R5,R1,#+24
   \   00000184   244485E1           ORR      R4,R5,R4, LSR #+8
   \   00000188   02418EE7           STR      R4,[LR, +R2, LSL #+2]
    999              Off++;
   1000              Data  = READ_MEM32(pContext->VRAMAddr, Off);
   1001              Data &= 0xFFFF0000;
   1002              Data |= Index >> 8;
   \   0000018C   00E090E5           LDR      LR,[R0, #+0]
   \   00000190   012082E2           ADD      R2,R2,#+1
   \   00000194   02419EE7           LDR      R4,[LR, +R2, LSL #+2]
   \   00000198   2114A0E1           LSR      R1,R1,#+8
   \   0000019C   2448A0E1           LSR      R4,R4,#+16
   \   000001A0   044881E1           ORR      R4,R1,R4, LSL #+16
   1003              xsize--;
   1004              if (!xsize) {
   \   000001A4   01105CE2           SUBS     R1,R12,#+1
   \   000001A8   EFFFFF0A           BEQ      ??_DrawBitLine32BPP_9
   1005                WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   1006                return;
   1007              }
   1008              Data &= 0x0000FFFF;
   1009              GET_PIXEL_INDEX(Index);
   \   000001AC   001093E5           LDR      R1,[R3, #+0]
   1010              Data |= Index << 16;
   1011              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000001B0   0438A0E1           LSL      R3,R4,#+16
   \   000001B4   01C8A0E1           LSL      R12,R1,#+16
   \   000001B8   23388CE1           ORR      R3,R12,R3, LSR #+16
   \   000001BC   02318EE7           STR      R3,[LR, +R2, LSL #+2]
   1012              Off++;
   1013              Data  = READ_MEM32(pContext->VRAMAddr, Off);
   1014              Data &= 0xFFFFFF00;
   1015              Data |= Index >> 16;
   1016              WRITE_MEM32(pContext->VRAMAddr, Off, Data);
   \   000001C0   000090E5           LDR      R0,[R0, #+0]
   \   000001C4   012082E2           ADD      R2,R2,#+1
   \   000001C8   023190E7           LDR      R3,[R0, +R2, LSL #+2]
   \   000001CC   FF30C3E3           BIC      R3,R3,#0xFF
   \   000001D0   211883E1           ORR      R1,R3,R1, LSR #+16
   \   000001D4   021180E7           STR      R1,[R0, +R2, LSL #+2]
   \                     ??_DrawBitLine32BPP_7:
   \   000001D8   7080BDE8           POP      {R4-R6,PC}       ;; return
   1017            }
   1018            #undef GET_PIXEL_INDEX
   1019          }
   1020          
   1021          /*********************************************************************
   1022          *
   1023          *       _DrawBitmap
   1024          */

   \                                 In section .text, align 4, keep-with-next
   1025          static void _DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0,
   1026                                 int xSize, int ySize,
   1027                                 int BitsPerPixel, 
   1028                                 int BytesPerLine,
   1029                                 const U8 GUI_UNI_PTR * pData, int Diff,
   1030                                 const LCD_PIXELINDEX* pTrans) {
   \                     _DrawBitmap:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   3C109DE5           LDR      R1,[SP, #+60]
   \   00000010   0040A0E1           MOV      R4,R0
   1031            int i;
   1032          
   1033            //
   1034            // Use _DrawBitLineXBPP and _DrawBitLineXBPP_Swap
   1035            //
   1036            switch (BitsPerPixel) {
   \   00000014   011041E2           SUB      R1,R1,#+1
   \   00000018   0360A0E1           MOV      R6,R3
   \   0000001C   38009DE5           LDR      R0,[SP, #+56]
   \   00000020   40709DE5           LDR      R7,[SP, #+64]
   \   00000024   44809DE5           LDR      R8,[SP, #+68]
   \   00000028   48909DE5           LDR      R9,[SP, #+72]
   \   0000002C   4CA09DE5           LDR      R10,[SP, #+76]
   \   00000030   1F0051E3           CMP      R1,#+31
   \   00000034   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitmap_0:
   \   00000038   EC00008A           BHI      ??_DrawBitmap_1
   \   0000003C   1E0000EA           B        ??_DrawBitmap_2
   \   00000040   4A0000EA           B        ??_DrawBitmap_3
   \   00000044   E90000EA           B        ??_DrawBitmap_1
   \   00000048   750000EA           B        ??_DrawBitmap_4
   \   0000004C   E70000EA           B        ??_DrawBitmap_1
   \   00000050   E60000EA           B        ??_DrawBitmap_1
   \   00000054   E50000EA           B        ??_DrawBitmap_1
   \   00000058   9E0000EA           B        ??_DrawBitmap_5
   \   0000005C   E30000EA           B        ??_DrawBitmap_1
   \   00000060   E20000EA           B        ??_DrawBitmap_1
   \   00000064   E10000EA           B        ??_DrawBitmap_1
   \   00000068   E00000EA           B        ??_DrawBitmap_1
   \   0000006C   DF0000EA           B        ??_DrawBitmap_1
   \   00000070   DE0000EA           B        ??_DrawBitmap_1
   \   00000074   DD0000EA           B        ??_DrawBitmap_1
   \   00000078   DC0000EA           B        ??_DrawBitmap_1
   \   0000007C   DB0000EA           B        ??_DrawBitmap_1
   \   00000080   DA0000EA           B        ??_DrawBitmap_1
   \   00000084   D90000EA           B        ??_DrawBitmap_1
   \   00000088   D80000EA           B        ??_DrawBitmap_1
   \   0000008C   D70000EA           B        ??_DrawBitmap_1
   \   00000090   D60000EA           B        ??_DrawBitmap_1
   \   00000094   D50000EA           B        ??_DrawBitmap_1
   \   00000098   D40000EA           B        ??_DrawBitmap_1
   \   0000009C   D30000EA           B        ??_DrawBitmap_1
   \   000000A0   D20000EA           B        ??_DrawBitmap_1
   \   000000A4   D10000EA           B        ??_DrawBitmap_1
   \   000000A8   D00000EA           B        ??_DrawBitmap_1
   \   000000AC   CF0000EA           B        ??_DrawBitmap_1
   \   000000B0   CE0000EA           B        ??_DrawBitmap_1
   \   000000B4   CD0000EA           B        ??_DrawBitmap_1
   \   000000B8   AB0000EA           B        ??_DrawBitmap_6
   1037            case 1:
   1038              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_2:
   \   000000BC   010050E3           CMP      R0,#+1
   \   000000C0   CA0000BA           BLT      ??_DrawBitmap_1
   \   000000C4   02B0A0E1           MOV      R11,R2
   \   000000C8   10008DE5           STR      R0,[SP, #+16]
   \   000000CC   010010E3           TST      R0,#0x1
   \   000000D0   0800000A           BEQ      ??_DrawBitmap_7
   1039                _DrawBitLine1BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   000000D4   08A08DE5           STR      R10,[SP, #+8]
   \   000000D8   04608DE5           STR      R6,[SP, #+4]
   \   000000DC   00908DE5           STR      R9,[SP, #+0]
   \   000000E0   0830A0E1           MOV      R3,R8
   \   000000E4   0510A0E1           MOV      R1,R5
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       _DrawBitLine1BPP
   1040                pData += BytesPerLine;
   \   000000F0   088087E0           ADD      R8,R7,R8
   \   000000F4   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_7:
   \   000000F8   10109DE5           LDR      R1,[SP, #+16]
   \   000000FC   A110A0E1           LSR      R1,R1,#+1
   \   00000100   0C108DE5           STR      R1,[SP, #+12]
   \   00000104   000051E3           CMP      R1,#+0
   \   00000108   B800000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_8:
   \   0000010C   08A08DE5           STR      R10,[SP, #+8]
   \   00000110   04608DE5           STR      R6,[SP, #+4]
   \   00000114   00908DE5           STR      R9,[SP, #+0]
   \   00000118   0830A0E1           MOV      R3,R8
   \   0000011C   0B20A0E1           MOV      R2,R11
   \   00000120   0510A0E1           MOV      R1,R5
   \   00000124   0400A0E1           MOV      R0,R4
   \   00000128   ........           BL       _DrawBitLine1BPP
   \   0000012C   088087E0           ADD      R8,R7,R8
   \   00000130   08A08DE5           STR      R10,[SP, #+8]
   \   00000134   04608DE5           STR      R6,[SP, #+4]
   \   00000138   00908DE5           STR      R9,[SP, #+0]
   \   0000013C   0830A0E1           MOV      R3,R8
   \   00000140   01208BE2           ADD      R2,R11,#+1
   \   00000144   0510A0E1           MOV      R1,R5
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   ........           BL       _DrawBitLine1BPP
   1041              }
   \   00000150   0C109DE5           LDR      R1,[SP, #+12]
   \   00000154   088087E0           ADD      R8,R7,R8
   \   00000158   011041E2           SUB      R1,R1,#+1
   \   0000015C   0C108DE5           STR      R1,[SP, #+12]
   \   00000160   02B08BE2           ADD      R11,R11,#+2
   \   00000164   000051E3           CMP      R1,#+0
   \   00000168   E7FFFF1A           BNE      ??_DrawBitmap_8
   \   0000016C   9F0000EA           B        ??_DrawBitmap_1
   1042              break;
   1043            case 2:
   1044              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_3:
   \   00000170   010050E3           CMP      R0,#+1
   \   00000174   9D0000BA           BLT      ??_DrawBitmap_1
   \   00000178   02B0A0E1           MOV      R11,R2
   \   0000017C   10008DE5           STR      R0,[SP, #+16]
   \   00000180   010010E3           TST      R0,#0x1
   \   00000184   0800000A           BEQ      ??_DrawBitmap_9
   1045                _DrawBitLine2BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   00000188   08A08DE5           STR      R10,[SP, #+8]
   \   0000018C   04608DE5           STR      R6,[SP, #+4]
   \   00000190   00908DE5           STR      R9,[SP, #+0]
   \   00000194   0830A0E1           MOV      R3,R8
   \   00000198   0510A0E1           MOV      R1,R5
   \   0000019C   0400A0E1           MOV      R0,R4
   \   000001A0   ........           BL       _DrawBitLine2BPP
   1046                pData += BytesPerLine;
   \   000001A4   088087E0           ADD      R8,R7,R8
   \   000001A8   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_9:
   \   000001AC   10109DE5           LDR      R1,[SP, #+16]
   \   000001B0   A110A0E1           LSR      R1,R1,#+1
   \   000001B4   0C108DE5           STR      R1,[SP, #+12]
   \   000001B8   000051E3           CMP      R1,#+0
   \   000001BC   8B00000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_10:
   \   000001C0   08A08DE5           STR      R10,[SP, #+8]
   \   000001C4   04608DE5           STR      R6,[SP, #+4]
   \   000001C8   00908DE5           STR      R9,[SP, #+0]
   \   000001CC   0830A0E1           MOV      R3,R8
   \   000001D0   0B20A0E1           MOV      R2,R11
   \   000001D4   0510A0E1           MOV      R1,R5
   \   000001D8   0400A0E1           MOV      R0,R4
   \   000001DC   ........           BL       _DrawBitLine2BPP
   \   000001E0   088087E0           ADD      R8,R7,R8
   \   000001E4   08A08DE5           STR      R10,[SP, #+8]
   \   000001E8   04608DE5           STR      R6,[SP, #+4]
   \   000001EC   00908DE5           STR      R9,[SP, #+0]
   \   000001F0   0830A0E1           MOV      R3,R8
   \   000001F4   01208BE2           ADD      R2,R11,#+1
   \   000001F8   0510A0E1           MOV      R1,R5
   \   000001FC   0400A0E1           MOV      R0,R4
   \   00000200   ........           BL       _DrawBitLine2BPP
   1047              }
   \   00000204   0C109DE5           LDR      R1,[SP, #+12]
   \   00000208   088087E0           ADD      R8,R7,R8
   \   0000020C   011041E2           SUB      R1,R1,#+1
   \   00000210   0C108DE5           STR      R1,[SP, #+12]
   \   00000214   02B08BE2           ADD      R11,R11,#+2
   \   00000218   000051E3           CMP      R1,#+0
   \   0000021C   E7FFFF1A           BNE      ??_DrawBitmap_10
   \   00000220   720000EA           B        ??_DrawBitmap_1
   1048              break;
   1049            case 4:
   1050              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_4:
   \   00000224   010050E3           CMP      R0,#+1
   \   00000228   700000BA           BLT      ??_DrawBitmap_1
   \   0000022C   02B0A0E1           MOV      R11,R2
   \   00000230   10008DE5           STR      R0,[SP, #+16]
   \   00000234   010010E3           TST      R0,#0x1
   \   00000238   0800000A           BEQ      ??_DrawBitmap_11
   1051                _DrawBitLine4BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   0000023C   08A08DE5           STR      R10,[SP, #+8]
   \   00000240   04608DE5           STR      R6,[SP, #+4]
   \   00000244   00908DE5           STR      R9,[SP, #+0]
   \   00000248   0830A0E1           MOV      R3,R8
   \   0000024C   0510A0E1           MOV      R1,R5
   \   00000250   0400A0E1           MOV      R0,R4
   \   00000254   ........           BL       _DrawBitLine4BPP
   1052                pData += BytesPerLine;
   \   00000258   088087E0           ADD      R8,R7,R8
   \   0000025C   01B08BE2           ADD      R11,R11,#+1
   \                     ??_DrawBitmap_11:
   \   00000260   10109DE5           LDR      R1,[SP, #+16]
   \   00000264   A110A0E1           LSR      R1,R1,#+1
   \   00000268   0C108DE5           STR      R1,[SP, #+12]
   \   0000026C   000051E3           CMP      R1,#+0
   \   00000270   5E00000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_12:
   \   00000274   08A08DE5           STR      R10,[SP, #+8]
   \   00000278   04608DE5           STR      R6,[SP, #+4]
   \   0000027C   00908DE5           STR      R9,[SP, #+0]
   \   00000280   0830A0E1           MOV      R3,R8
   \   00000284   0B20A0E1           MOV      R2,R11
   \   00000288   0510A0E1           MOV      R1,R5
   \   0000028C   0400A0E1           MOV      R0,R4
   \   00000290   ........           BL       _DrawBitLine4BPP
   \   00000294   088087E0           ADD      R8,R7,R8
   \   00000298   08A08DE5           STR      R10,[SP, #+8]
   \   0000029C   04608DE5           STR      R6,[SP, #+4]
   \   000002A0   00908DE5           STR      R9,[SP, #+0]
   \   000002A4   0830A0E1           MOV      R3,R8
   \   000002A8   01208BE2           ADD      R2,R11,#+1
   \   000002AC   0510A0E1           MOV      R1,R5
   \   000002B0   0400A0E1           MOV      R0,R4
   \   000002B4   ........           BL       _DrawBitLine4BPP
   1053              }
   \   000002B8   0C109DE5           LDR      R1,[SP, #+12]
   \   000002BC   088087E0           ADD      R8,R7,R8
   \   000002C0   011041E2           SUB      R1,R1,#+1
   \   000002C4   0C108DE5           STR      R1,[SP, #+12]
   \   000002C8   02B08BE2           ADD      R11,R11,#+2
   \   000002CC   000051E3           CMP      R1,#+0
   \   000002D0   E7FFFF1A           BNE      ??_DrawBitmap_12
   \   000002D4   450000EA           B        ??_DrawBitmap_1
   1054              break;
   1055            case 8:
   1056              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_5:
   \   000002D8   010050E3           CMP      R0,#+1
   \   000002DC   430000BA           BLT      ??_DrawBitmap_1
   \   000002E0   00B0A0E1           MOV      R11,R0
   \   000002E4   0290A0E1           MOV      R9,R2
   \   000002E8   01001BE3           TST      R11,#0x1
   \   000002EC   0700000A           BEQ      ??_DrawBitmap_13
   1057                _DrawBitLine8BPP(pDevice, x0, i + y0, pData, xSize, pTrans);
   \   000002F0   04A08DE5           STR      R10,[SP, #+4]
   \   000002F4   00608DE5           STR      R6,[SP, #+0]
   \   000002F8   0830A0E1           MOV      R3,R8
   \   000002FC   0510A0E1           MOV      R1,R5
   \   00000300   0400A0E1           MOV      R0,R4
   \   00000304   ........           BL       _DrawBitLine8BPP
   1058                pData += BytesPerLine;
   \   00000308   088087E0           ADD      R8,R7,R8
   \   0000030C   019089E2           ADD      R9,R9,#+1
   \                     ??_DrawBitmap_13:
   \   00000310   ABB0B0E1           LSRS     R11,R11,#+1
   \   00000314   3500000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_14:
   \   00000318   04A08DE5           STR      R10,[SP, #+4]
   \   0000031C   00608DE5           STR      R6,[SP, #+0]
   \   00000320   0830A0E1           MOV      R3,R8
   \   00000324   0920A0E1           MOV      R2,R9
   \   00000328   0510A0E1           MOV      R1,R5
   \   0000032C   0400A0E1           MOV      R0,R4
   \   00000330   ........           BL       _DrawBitLine8BPP
   \   00000334   088087E0           ADD      R8,R7,R8
   \   00000338   04A08DE5           STR      R10,[SP, #+4]
   \   0000033C   00608DE5           STR      R6,[SP, #+0]
   \   00000340   0830A0E1           MOV      R3,R8
   \   00000344   012089E2           ADD      R2,R9,#+1
   \   00000348   0510A0E1           MOV      R1,R5
   \   0000034C   0400A0E1           MOV      R0,R4
   \   00000350   ........           BL       _DrawBitLine8BPP
   1059              }
   \   00000354   01B04BE2           SUB      R11,R11,#+1
   \   00000358   088087E0           ADD      R8,R7,R8
   \   0000035C   029089E2           ADD      R9,R9,#+2
   \   00000360   00005BE3           CMP      R11,#+0
   \   00000364   EBFFFF1A           BNE      ??_DrawBitmap_14
   \   00000368   200000EA           B        ??_DrawBitmap_1
   1060              break;
   1061            case 32:
   1062              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_6:
   \   0000036C   010050E3           CMP      R0,#+1
   \   00000370   1E0000BA           BLT      ??_DrawBitmap_1
   \   00000374   00A0A0E1           MOV      R10,R0
   \   00000378   0290A0E1           MOV      R9,R2
   \   0000037C   01001AE3           TST      R10,#0x1
   \   00000380   0600000A           BEQ      ??_DrawBitmap_15
   1063                _DrawBitLine32BPP(pDevice, x0, i + y0, (const U32 *)pData, xSize);
   \   00000384   00608DE5           STR      R6,[SP, #+0]
   \   00000388   0830A0E1           MOV      R3,R8
   \   0000038C   0510A0E1           MOV      R1,R5
   \   00000390   0400A0E1           MOV      R0,R4
   \   00000394   ........           BL       _DrawBitLine32BPP
   1064                pData += BytesPerLine;
   \   00000398   088087E0           ADD      R8,R7,R8
   \   0000039C   019089E2           ADD      R9,R9,#+1
   \                     ??_DrawBitmap_15:
   \   000003A0   AAA0B0E1           LSRS     R10,R10,#+1
   \   000003A4   1100000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_16:
   \   000003A8   00608DE5           STR      R6,[SP, #+0]
   \   000003AC   0830A0E1           MOV      R3,R8
   \   000003B0   0920A0E1           MOV      R2,R9
   \   000003B4   0510A0E1           MOV      R1,R5
   \   000003B8   0400A0E1           MOV      R0,R4
   \   000003BC   ........           BL       _DrawBitLine32BPP
   \   000003C0   088087E0           ADD      R8,R7,R8
   \   000003C4   00608DE5           STR      R6,[SP, #+0]
   \   000003C8   0830A0E1           MOV      R3,R8
   \   000003CC   012089E2           ADD      R2,R9,#+1
   \   000003D0   0510A0E1           MOV      R1,R5
   \   000003D4   0400A0E1           MOV      R0,R4
   \   000003D8   ........           BL       _DrawBitLine32BPP
   1065              }
   \   000003DC   01A04AE2           SUB      R10,R10,#+1
   \   000003E0   088087E0           ADD      R8,R7,R8
   \   000003E4   029089E2           ADD      R9,R9,#+2
   \   000003E8   00005AE3           CMP      R10,#+0
   \   000003EC   EDFFFF1A           BNE      ??_DrawBitmap_16
   1066              break;
   1067            }
   1068          }
   \                     ??_DrawBitmap_1:
   \   000003F0   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000003F4   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1069          
   1070          /*********************************************************************
   1071          *
   1072          *       _SetOrg
   1073          */

   \                                 In section .text, align 4, keep-with-next
   1074          static void _SetOrg(GUI_DEVICE * pDevice, int x, int y) {
   \                     _SetOrg:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1075            #ifndef WIN32
   1076              DRIVER_CONTEXT * pContext;
   1077            #endif
   1078            LCD_X_SETORG_INFO Data = {0};
   \   00000004   ............       ADRL     R12,`?<Constant {0}>`
   \              ....        
   \   0000000C   0CD04DE2           SUB      SP,SP,#+12
   \   00000010   00409CE5           LDR      R4,[R12, #+0]
   \   00000014   04509CE5           LDR      R5,[R12, #+4]
   \   00000018   0D30A0E1           MOV      R3,SP
   \   0000001C   300083E8           STM      R3,{R4,R5}
   1079          
   1080            #ifdef WIN32
   1081              LCDSIM_SetOrg(x, y, pDevice->LayerIndex);
   1082            #else
   1083              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000020   083090E5           LDR      R3,[R0, #+8]
   1084              Data.xPos = x;
   \   00000024   00108DE5           STR      R1,[SP, #+0]
   1085              Data.yPos = pContext->vySize - pContext->ySize - y;
   \   00000028   101093E5           LDR      R1,[R3, #+16]
   \   0000002C   083093E5           LDR      R3,[R3, #+8]
   \   00000030   031041E0           SUB      R1,R1,R3
   \   00000034   021041E0           SUB      R1,R1,R2
   \   00000038   04108DE5           STR      R1,[SP, #+4]
   1086              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETORG, (void *)&Data);
   \   0000003C   0D20A0E1           MOV      R2,SP
   \   00000040   0310A0E3           MOV      R1,#+3
   \   00000044   180090E5           LDR      R0,[R0, #+24]
   \   00000048   ........           BL       LCD_X_DisplayDriver
   1087            #endif
   1088          }
   \   0000004C   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000050   3080BDE8           POP      {R4,R5,PC}       ;; return
   1089          
   1090          /*********************************************************************
   1091          *
   1092          *       _InitOnce
   1093          *
   1094          * Purpose:
   1095          *   Allocates a fixed block for the context of the driver
   1096          *
   1097          * Return value:
   1098          *   0 on success, 1 on error
   1099          */
   1100          static int _InitOnce(GUI_DEVICE * pDevice) {
   1101            if (pDevice->u.pContext == NULL) {
   1102              pDevice->u.pContext = GUI_ALLOC_GetFixedBlock(sizeof(DRIVER_CONTEXT));
   1103              GUI__memset((U8 *)pDevice->u.pContext, 0, sizeof(DRIVER_CONTEXT));
   1104            }
   1105            return pDevice->u.pContext ? 0 : 1;
   1106          }
   1107          
   1108          /*********************************************************************
   1109          *
   1110          *       _GetRect
   1111          */

   \                                 In section .text, align 4, keep-with-next
   1112          static void _GetRect(GUI_DEVICE * pDevice, LCD_RECT * pRect) {
   1113            DRIVER_CONTEXT * pContext;
   1114          
   1115            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetRect:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
   1116            pRect->x0 = 0;
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   B020C1E1           STRH     R2,[R1, #+0]
   1117            pRect->y0 = 0;
   \   0000000C   B220C1E1           STRH     R2,[R1, #+2]
   1118            pRect->x1 = pContext->vxSize - 1;
   \   00000010   0C2090E5           LDR      R2,[R0, #+12]
   \   00000014   012042E2           SUB      R2,R2,#+1
   \   00000018   B420C1E1           STRH     R2,[R1, #+4]
   1119            pRect->y1 = pContext->vySize - 1;
   \   0000001C   100090E5           LDR      R0,[R0, #+16]
   \   00000020   010040E2           SUB      R0,R0,#+1
   \   00000024   B600C1E1           STRH     R0,[R1, #+6]
   1120          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
   1121          
   1122          /*********************************************************************
   1123          *
   1124          *       _GetDevProp
   1125          */

   \                                 In section .text, align 4, keep-with-next
   1126          static I32 _GetDevProp(GUI_DEVICE * pDevice, int Index) {
   1127            DRIVER_CONTEXT * pContext;
   1128          
   1129            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1130            switch (Index) {
   \                     _GetDevProp:
   \   00000000   011041E2           SUB      R1,R1,#+1
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   0D0051E3           CMP      R1,#+13
   \   0000000C   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevProp_0:
   \   00000010   1B00008A           BHI      ??_GetDevProp_1
   \   00000014   0C0000EA           B        ??_GetDevProp_2
   \   00000018   0D0000EA           B        ??_GetDevProp_3
   \   0000001C   0E0000EA           B        ??_GetDevProp_4
   \   00000020   0F0000EA           B        ??_GetDevProp_5
   \   00000024   160000EA           B        ??_GetDevProp_1
   \   00000028   150000EA           B        ??_GetDevProp_1
   \   0000002C   140000EA           B        ??_GetDevProp_1
   \   00000030   0D0000EA           B        ??_GetDevProp_6
   \   00000034   0E0000EA           B        ??_GetDevProp_7
   \   00000038   0F0000EA           B        ??_GetDevProp_8
   \   0000003C   0E0000EA           B        ??_GetDevProp_8
   \   00000040   0B0000EA           B        ??_GetDevProp_7
   \   00000044   0C0000EA           B        ??_GetDevProp_8
   \   00000048   090000EA           B        ??_GetDevProp_7
   1131            case LCD_DEVCAP_XSIZE:
   1132              return pContext->xSize;
   \                     ??_GetDevProp_2:
   \   0000004C   040090E5           LDR      R0,[R0, #+4]
   \   00000050   1EFF2FE1           BX       LR
   1133            case LCD_DEVCAP_YSIZE:
   1134              return pContext->ySize;
   \                     ??_GetDevProp_3:
   \   00000054   080090E5           LDR      R0,[R0, #+8]
   \   00000058   1EFF2FE1           BX       LR
   1135            case LCD_DEVCAP_VXSIZE:
   1136              return pContext->vxSize;
   \                     ??_GetDevProp_4:
   \   0000005C   0C0090E5           LDR      R0,[R0, #+12]
   \   00000060   1EFF2FE1           BX       LR
   1137            case LCD_DEVCAP_VYSIZE:
   1138              return pContext->vySize;
   \                     ??_GetDevProp_5:
   \   00000064   100090E5           LDR      R0,[R0, #+16]
   \   00000068   1EFF2FE1           BX       LR
   1139            case LCD_DEVCAP_BITSPERPIXEL:
   1140              return 24;
   \                     ??_GetDevProp_6:
   \   0000006C   1800A0E3           MOV      R0,#+24
   \   00000070   1EFF2FE1           BX       LR
   1141            case LCD_DEVCAP_NUMCOLORS:
   1142              return 0;
   \                     ??_GetDevProp_7:
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   1EFF2FE1           BX       LR
   1143            case LCD_DEVCAP_XMAG:
   1144              return 1;
   \                     ??_GetDevProp_8:
   \   0000007C   0100A0E3           MOV      R0,#+1
   \   00000080   1EFF2FE1           BX       LR
   1145            case LCD_DEVCAP_YMAG:
   1146              return 1;
   1147            case LCD_DEVCAP_MIRROR_X:
   1148              return 0;
   1149            case LCD_DEVCAP_MIRROR_Y:
   1150              return 1;
   1151            case LCD_DEVCAP_SWAP_XY:
   1152              return 0;
   1153            }
   1154            return -1;
   \                     ??_GetDevProp_1:
   \   00000084   0000E0E3           MVN      R0,#+0
   \   00000088   1EFF2FE1           BX       LR               ;; return
   1155          }
   1156          
   1157          /*********************************************************************
   1158          *
   1159          *       _GetDevData
   1160          */

   \                                 In section .text, align 4, keep-with-next
   1161          static void * _GetDevData(GUI_DEVICE * pDevice, int Index) {
   1162            GUI_USE_PARA(pDevice);
   1163            switch (Index) {
   \                     _GetDevData:
   \   00000000   010051E3           CMP      R1,#+1
   \   00000004   0100001A           BNE      ??_GetDevData_0
   1164            #if GUI_SUPPORT_MEMDEV
   1165              case LCD_DEVDATA_MEMDEV:
   1166                return (void *)&GUI_MEMDEV_DEVICE_32;
   \   00000008   ........           LDR      R0,??DataTable16
   \   0000000C   1EFF2FE1           BX       LR
   1167            #endif
   1168            }
   1169            return NULL;
   \                     ??_GetDevData_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
   1170          }
   1171          
   1172          /*********************************************************************
   1173          *
   1174          *       Static code: Functions available by _GetDevFunc()
   1175          *
   1176          **********************************************************************
   1177          */
   1178          /*********************************************************************
   1179          *
   1180          *       _SetVRAMAddr
   1181          */

   \                                 In section .text, align 4, keep-with-next
   1182          static void _SetVRAMAddr(GUI_DEVICE * pDevice, void * pVRAM) {
   \                     _SetVRAMAddr:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1183            DRIVER_CONTEXT * pContext;
   1184            LCD_X_SETVRAMADDR_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {(void *)0}>`
   \              ....        
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   001091E5           LDR      R1,[R1, #+0]
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
   1185          
   1186            _InitOnce(pDevice);
   \   00000020   080094E5           LDR      R0,[R4, #+8]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0500001A           BNE      ??_SetVRAMAddr_0
   \   0000002C   2C00A0E3           MOV      R0,#+44
   \   00000030   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000034   080084E5           STR      R0,[R4, #+8]
   \   00000038   2C20A0E3           MOV      R2,#+44
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   ........           BL       GUI__memset
   1187            if (pDevice->u.pContext) {
   \                     ??_SetVRAMAddr_0:
   \   00000044   080094E5           LDR      R0,[R4, #+8]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0500000A           BEQ      ??_SetVRAMAddr_1
   1188              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1189              pContext->VRAMAddr = (U32)pVRAM;
   \   00000050   005080E5           STR      R5,[R0, #+0]
   1190              Data.pVRAM = pVRAM;
   \   00000054   00508DE5           STR      R5,[SP, #+0]
   1191              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVRAMADDR, (void *)&Data);
   \   00000058   0D20A0E1           MOV      R2,SP
   \   0000005C   0210A0E3           MOV      R1,#+2
   \   00000060   180094E5           LDR      R0,[R4, #+24]
   \   00000064   ........           BL       LCD_X_DisplayDriver
   1192            }
   1193            #ifdef WIN32
   1194              SIM_Lin_SetVRAMAddr(pDevice->LayerIndex, pVRAM);
   1195            #endif
   1196          }
   \                     ??_SetVRAMAddr_1:
   \   00000068   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000006C   3080BDE8           POP      {R4,R5,PC}       ;; return
   1197          
   1198          /*********************************************************************
   1199          *
   1200          *       _SetVSize
   1201          */

   \                                 In section .text, align 4, keep-with-next
   1202          static void _SetVSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetVSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1203            DRIVER_CONTEXT * pContext;
   1204          
   1205            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetVSize_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
   1206            if (pDevice->u.pContext) {
   \                     ??_SetVSize_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   1207              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1208              pContext->vxSize = xSize;
   \   0000003C   0C508015           STRNE    R5,[R0, #+12]
   1209              pContext->vySize = ySize;
   \   00000040   10608015           STRNE    R6,[R0, #+16]
   1210              pContext->vxSizePhys = xSize;
   \   00000044   14508015           STRNE    R5,[R0, #+20]
   1211            }
   1212            #ifdef WIN32
   1213              SIM_Lin_SetVRAMSize(pDevice->LayerIndex, xSize, ySize);
   1214            #endif
   1215          }
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1216          
   1217          /*********************************************************************
   1218          *
   1219          *       _SetSize
   1220          */

   \                                 In section .text, align 4, keep-with-next
   1221          static void _SetSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1222            DRIVER_CONTEXT * pContext;
   1223            LCD_X_SETSIZE_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_1`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
   1224          
   1225            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetSize_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
   1226            if (pDevice->u.pContext) {
   \                     ??_SetSize_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0A00000A           BEQ      ??_SetSize_1
   1227              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1228              if (pContext->vxSizePhys == 0) {
   \   0000005C   141090E5           LDR      R1,[R0, #+20]
   1229                pContext->vxSizePhys = xSize;
   1230              }
   1231              pContext->xSize = xSize;
   1232              pContext->ySize = ySize;
   1233              Data.xSize = xSize;
   1234              Data.ySize = ySize;
   1235              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETSIZE, (void *)&Data);
   \   00000060   0D20A0E1           MOV      R2,SP
   \   00000064   000051E3           CMP      R1,#+0
   \   00000068   14508005           STREQ    R5,[R0, #+20]
   \   0000006C   045080E5           STR      R5,[R0, #+4]
   \   00000070   086080E5           STR      R6,[R0, #+8]
   \   00000074   00508DE5           STR      R5,[SP, #+0]
   \   00000078   04608DE5           STR      R6,[SP, #+4]
   \   0000007C   0710A0E3           MOV      R1,#+7
   \   00000080   180094E5           LDR      R0,[R4, #+24]
   \   00000084   ........           BL       LCD_X_DisplayDriver
   1236            }
   1237          }
   \                     ??_SetSize_1:
   \   00000088   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   0000008C   7080BDE8           POP      {R4-R6,PC}       ;; return
   1238          
   1239          /*********************************************************************
   1240          *
   1241          *       _SetPos
   1242          */

   \                                 In section .text, align 4, keep-with-next
   1243          static void _SetPos(GUI_DEVICE * pDevice, int xPos, int yPos) {
   \                     _SetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1244            DRIVER_CONTEXT * pContext;
   1245            LCD_X_SETPOS_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_2`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
   1246          
   1247            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetPos_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
   1248            if (pDevice->u.pContext) {
   \                     ??_SetPos_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0700000A           BEQ      ??_SetPos_1
   1249              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1250              pContext->xPos = xPos;
   \   0000005C   185080E5           STR      R5,[R0, #+24]
   1251              pContext->yPos = yPos;
   \   00000060   1C6080E5           STR      R6,[R0, #+28]
   1252              Data.xPos = xPos;
   \   00000064   00508DE5           STR      R5,[SP, #+0]
   1253              Data.yPos = yPos;
   \   00000068   04608DE5           STR      R6,[SP, #+4]
   1254              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETPOS, (void *)&Data);
   \   0000006C   0D20A0E1           MOV      R2,SP
   \   00000070   0810A0E3           MOV      R1,#+8
   \   00000074   180094E5           LDR      R0,[R4, #+24]
   \   00000078   ........           BL       LCD_X_DisplayDriver
   1255            }
   1256          }
   \                     ??_SetPos_1:
   \   0000007C   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000080   7080BDE8           POP      {R4-R6,PC}       ;; return
   1257          
   1258          /*********************************************************************
   1259          *
   1260          *       _GetPos
   1261          */

   \                                 In section .text, align 4, keep-with-next
   1262          static void _GetPos(GUI_DEVICE * pDevice, int * pxPos, int * pyPos) {
   \                     _GetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1263            DRIVER_CONTEXT * pContext;
   1264          
   1265            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_GetPos_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
   1266            if (pDevice->u.pContext) {
   \                     ??_GetPos_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0300000A           BEQ      ??_GetPos_1
   1267              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1268              *pxPos = pContext->xPos;
   \   00000040   181090E5           LDR      R1,[R0, #+24]
   \   00000044   001085E5           STR      R1,[R5, #+0]
   1269              *pyPos = pContext->yPos;
   \   00000048   1C0090E5           LDR      R0,[R0, #+28]
   \   0000004C   000086E5           STR      R0,[R6, #+0]
   1270            }
   1271          }
   \                     ??_GetPos_1:
   \   00000050   7080BDE8           POP      {R4-R6,PC}       ;; return
   1272          
   1273          /*********************************************************************
   1274          *
   1275          *       _SetAlpha
   1276          */

   \                                 In section .text, align 4, keep-with-next
   1277          static void _SetAlpha(GUI_DEVICE * pDevice, int Alpha) {
   \                     _SetAlpha:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1278            DRIVER_CONTEXT * pContext;
   1279            LCD_X_SETALPHA_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_3`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
   1280          
   1281            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetAlpha_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
   1282            if (pDevice->u.pContext) {
   \                     ??_SetAlpha_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetAlpha_1
   1283              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1284              pContext->Alpha = Alpha;
   \   0000004C   205080E5           STR      R5,[R0, #+32]
   1285              Data.Alpha = Alpha;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
   1286              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHA, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0A10A0E3           MOV      R1,#+10
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
   1287            }
   1288          }
   \                     ??_SetAlpha_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
   1289          
   1290          /*********************************************************************
   1291          *
   1292          *       _SetVis
   1293          */

   \                                 In section .text, align 4, keep-with-next
   1294          static void _SetVis(GUI_DEVICE * pDevice, int OnOff) {
   \                     _SetVis:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   1295            DRIVER_CONTEXT * pContext;
   1296            LCD_X_SETVIS_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_4`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
   1297          
   1298            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetVis_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
   1299            if (pDevice->u.pContext) {
   \                     ??_SetVis_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetVis_1
   1300              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1301              pContext->IsVisible = OnOff;
   \   0000004C   245080E5           STR      R5,[R0, #+36]
   1302              Data.OnOff = OnOff;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
   1303              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVIS, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0910A0E3           MOV      R1,#+9
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
   1304            }
   1305          }
   \                     ??_SetVis_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
   1306          
   1307          /*********************************************************************
   1308          *
   1309          *       _Init
   1310          */

   \                                 In section .text, align 4, keep-with-next
   1311          static int  _Init(GUI_DEVICE * pDevice) {
   \                     _Init:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1312            int r;
   1313          
   1314            r = _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0500001A           BNE      ??_Init_0
   \   00000018   2C00A0E3           MOV      R0,#+44
   \   0000001C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000020   080084E5           STR      R0,[R4, #+8]
   \   00000024   2C20A0E3           MOV      R2,#+44
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   ........           BL       GUI__memset
   \                     ??_Init_0:
   \   00000030   080094E5           LDR      R0,[R4, #+8]
   1315            r |= LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_INITCONTROLLER, NULL);
   1316            return r;
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0150A003           MOVEQ    R5,#+1
   \   00000040   0050A013           MOVNE    R5,#+0
   \   00000044   0110A0E3           MOV      R1,#+1
   \   00000048   180094E5           LDR      R0,[R4, #+24]
   \   0000004C   ........           BL       LCD_X_DisplayDriver
   \   00000050   050080E1           ORR      R0,R0,R5
   \   00000054   04D08DE2           ADD      SP,SP,#+4
   \   00000058   3080BDE8           POP      {R4,R5,PC}       ;; return
   1317          }
   1318          
   1319          /*********************************************************************
   1320          *
   1321          *       _On
   1322          */

   \                                 In section .text, align 4, keep-with-next
   1323          static void _On (GUI_DEVICE * pDevice) {
   1324            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_ON, NULL);
   \                     _On:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0510A0E3           MOV      R1,#+5
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
   1325          }
   1326          
   1327          /*********************************************************************
   1328          *
   1329          *       _Off
   1330          */

   \                                 In section .text, align 4, keep-with-next
   1331          static void _Off (GUI_DEVICE * pDevice) {
   1332            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_OFF, NULL);
   \                     _Off:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0610A0E3           MOV      R1,#+6
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
   1333          }
   1334          
   1335          /*********************************************************************
   1336          *
   1337          *       _SetLUTEntry
   1338          */

   \                                 In section .text, align 4, keep-with-next
   1339          static void _SetLUTEntry(GUI_DEVICE * pDevice, U8 Pos, LCD_COLOR Color) {
   \                     _SetLUTEntry:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1340            LCD_X_SETLUTENTRY_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
   1341          
   1342            Data.Pos   = Pos;
   \   0000001C   0410CDE5           STRB     R1,[SP, #+4]
   1343            Data.Color = Color;
   \   00000020   00208DE5           STR      R2,[SP, #+0]
   1344            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETLUTENTRY, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0410A0E3           MOV      R1,#+4
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
   1345          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
   1346          
   1347          /*********************************************************************
   1348          *
   1349          *       _SetAlphaMode
   1350          */

   \                                 In section .text, align 4, keep-with-next
   1351          static void _SetAlphaMode(GUI_DEVICE * pDevice, int AlphaMode) {
   \                     _SetAlphaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1352            LCD_X_SETALPHAMODE_INFO Data = {0};
   1353          
   1354            Data.AlphaMode = AlphaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
   1355            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0B10A0E3           MOV      R1,#+11
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
   1356          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1357          
   1358          /*********************************************************************
   1359          *
   1360          *       _SetChromaMode
   1361          */

   \                                 In section .text, align 4, keep-with-next
   1362          static void _SetChromaMode(GUI_DEVICE * pDevice, int ChromaMode) {
   \                     _SetChromaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1363            LCD_X_SETCHROMAMODE_INFO Data = {0};
   1364          
   1365            Data.ChromaMode = ChromaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
   1366            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0C10A0E3           MOV      R1,#+12
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
   1367          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1368          
   1369          /*********************************************************************
   1370          *
   1371          *       _SetChroma
   1372          */

   \                                 In section .text, align 4, keep-with-next
   1373          static void _SetChroma(GUI_DEVICE * pDevice, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax) {
   \                     _SetChroma:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1374            LCD_X_SETCHROMA_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>_1`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
   1375          
   1376            Data.ChromaMin = ChromaMin;
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
   1377            Data.ChromaMax = ChromaMax;
   \   00000020   04208DE5           STR      R2,[SP, #+4]
   1378            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMA, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0D10A0E3           MOV      R1,#+13
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
   1379          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
   1380          
   1381          /*********************************************************************
   1382          *
   1383          *       _SetFunc
   1384          */

   \                                 In section .text, align 4, keep-with-next
   1385          static void _SetFunc(GUI_DEVICE * pDevice, int Index, void (* pFunc)(void)) {
   \                     _SetFunc:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1386            DRIVER_CONTEXT * pContext;
   1387          
   1388            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetFunc_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
   1389            if (pDevice->u.pContext) {
   \                     ??_SetFunc_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0100000A           BEQ      ??_SetFunc_1
   1390              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1391              switch (Index) {
   \   00000040   170055E3           CMP      R5,#+23
   1392              case LCD_DEVFUNC_FILLRECT:
   1393                pContext->pfFillRect = (void (*)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex))pFunc;
   \   00000044   28608005           STREQ    R6,[R0, #+40]
   1394                break;
   1395              }
   1396            }
   1397          }
   \                     ??_SetFunc_1:
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1398          
   1399          /*********************************************************************
   1400          *
   1401          *       _GetDevFunc
   1402          */

   \                                 In section .text, align 4, keep-with-next
   1403          static void (* _GetDevFunc(GUI_DEVICE ** ppDevice, int Index))(void) {
   1404            GUI_USE_PARA(ppDevice);
   1405            switch (Index) {
   \                     _GetDevFunc:
   \   00000000   021041E2           SUB      R1,R1,#+2
   \   00000004   140051E3           CMP      R1,#+20
   \   00000008   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevFunc_0:
   \   0000000C   3200008A           BHI      ??_GetDevFunc_1
   \   00000010   1D0000EA           B        ??_GetDevFunc_2
   \   00000014   180000EA           B        ??_GetDevFunc_3
   \   00000018   190000EA           B        ??_GetDevFunc_4
   \   0000001C   2E0000EA           B        ??_GetDevFunc_1
   \   00000020   1B0000EA           B        ??_GetDevFunc_5
   \   00000024   2C0000EA           B        ??_GetDevFunc_1
   \   00000028   2B0000EA           B        ??_GetDevFunc_1
   \   0000002C   0C0000EA           B        ??_GetDevFunc_6
   \   00000030   0D0000EA           B        ??_GetDevFunc_7
   \   00000034   0E0000EA           B        ??_GetDevFunc_8
   \   00000038   170000EA           B        ??_GetDevFunc_9
   \   0000003C   260000EA           B        ??_GetDevFunc_1
   \   00000040   170000EA           B        ??_GetDevFunc_10
   \   00000044   180000EA           B        ??_GetDevFunc_11
   \   00000048   190000EA           B        ??_GetDevFunc_12
   \   0000004C   220000EA           B        ??_GetDevFunc_1
   \   00000050   210000EA           B        ??_GetDevFunc_1
   \   00000054   180000EA           B        ??_GetDevFunc_13
   \   00000058   190000EA           B        ??_GetDevFunc_14
   \   0000005C   1A0000EA           B        ??_GetDevFunc_15
   \   00000060   1B0000EA           B        ??_GetDevFunc_16
   1406            case LCD_DEVFUNC_SET_VRAM_ADDR:
   1407              return (void (*)(void))_SetVRAMAddr;
   \                     ??_GetDevFunc_6:
   \   00000064   ........           LDR      R0,??DataTable16_1
   \   00000068   1EFF2FE1           BX       LR
   1408            case LCD_DEVFUNC_SET_VSIZE:
   1409              return (void (*)(void))_SetVSize;
   \                     ??_GetDevFunc_7:
   \   0000006C   ........           LDR      R0,??DataTable16_2
   \   00000070   1EFF2FE1           BX       LR
   1410            case LCD_DEVFUNC_SET_SIZE:
   1411              return (void (*)(void))_SetSize;
   \                     ??_GetDevFunc_8:
   \   00000074   ........           LDR      R0,??DataTable16_3
   \   00000078   1EFF2FE1           BX       LR
   1412            case LCD_DEVFUNC_SETPOS:
   1413              return (void (*)(void))_SetPos;
   \                     ??_GetDevFunc_3:
   \   0000007C   ........           LDR      R0,??DataTable16_4
   \   00000080   1EFF2FE1           BX       LR
   1414            case LCD_DEVFUNC_GETPOS:
   1415              return (void (*)(void))_GetPos;
   \                     ??_GetDevFunc_4:
   \   00000084   ........           LDR      R0,??DataTable16_5
   \   00000088   1EFF2FE1           BX       LR
   1416            case LCD_DEVFUNC_SETALPHA:
   1417              return (void (*)(void))_SetAlpha;
   \                     ??_GetDevFunc_2:
   \   0000008C   ........           LDR      R0,??DataTable16_6
   \   00000090   1EFF2FE1           BX       LR
   1418            case LCD_DEVFUNC_SETVIS:
   1419              return (void (*)(void))_SetVis;
   \                     ??_GetDevFunc_5:
   \   00000094   ........           LDR      R0,??DataTable16_7
   \   00000098   1EFF2FE1           BX       LR
   1420            case LCD_DEVFUNC_INIT:
   1421              return (void (*)(void))_Init;
   \                     ??_GetDevFunc_9:
   \   0000009C   ........           LDR      R0,??DataTable16_8
   \   000000A0   1EFF2FE1           BX       LR
   1422            case LCD_DEVFUNC_ON:
   1423              return (void (*)(void))_On;
   \                     ??_GetDevFunc_10:
   \   000000A4   ........           LDR      R0,??DataTable16_9
   \   000000A8   1EFF2FE1           BX       LR
   1424            case LCD_DEVFUNC_OFF:
   1425              return (void (*)(void))_Off;
   \                     ??_GetDevFunc_11:
   \   000000AC   ........           LDR      R0,??DataTable16_10
   \   000000B0   1EFF2FE1           BX       LR
   1426            case LCD_DEVFUNC_SETLUTENTRY:
   1427              return (void (*)(void))_SetLUTEntry;
   \                     ??_GetDevFunc_12:
   \   000000B4   ........           LDR      R0,??DataTable16_11
   \   000000B8   1EFF2FE1           BX       LR
   1428          
   1429            case LCD_DEVFUNC_ALPHAMODE:
   1430              return (void (*)(void))_SetAlphaMode;
   \                     ??_GetDevFunc_13:
   \   000000BC   ........           LDR      R0,??DataTable16_12
   \   000000C0   1EFF2FE1           BX       LR
   1431            case LCD_DEVFUNC_CHROMAMODE:
   1432              return (void (*)(void))_SetChromaMode;
   \                     ??_GetDevFunc_14:
   \   000000C4   ........           LDR      R0,??DataTable16_13
   \   000000C8   1EFF2FE1           BX       LR
   1433            case LCD_DEVFUNC_CHROMA:
   1434              return (void (*)(void))_SetChroma;
   \                     ??_GetDevFunc_15:
   \   000000CC   ........           LDR      R0,??DataTable16_14
   \   000000D0   1EFF2FE1           BX       LR
   1435            
   1436            case LCD_DEVFUNC_SETFUNC:
   1437              return (void (*)(void))_SetFunc;
   \                     ??_GetDevFunc_16:
   \   000000D4   ........           LDR      R0,??DataTable16_15
   \   000000D8   1EFF2FE1           BX       LR
   1438            }
   1439            return NULL;
   \                     ??_GetDevFunc_1:
   \   000000DC   0000A0E3           MOV      R0,#+0
   \   000000E0   1EFF2FE1           BX       LR               ;; return
   1440          }
   1441          
   1442          /*********************************************************************
   1443          *
   1444          *       Public data
   1445          *
   1446          **********************************************************************
   1447          */
   1448          /*********************************************************************
   1449          *
   1450          *       GUI_DEVICE_API structure
   1451          */

   \                                 In section .rodata, align 4, keep-with-next
   1452          const GUI_DEVICE_API GUIDRV_Lin_OY_24_API = {
   \                     GUIDRV_Lin_OY_24_API:
   \   00000000                      ; Initializer data, 52 bytes
   \   00000000   00000000....       DC32 0, _DrawBitmap, _DrawHLine, _DrawVLine, _FillRect, _GetPixelIndex, _SetPixelIndex, _XorPixel, _SetOrg, _GetDevFunc
   \              ............
   \              ............
   \              ............
   \              ............
   \              ............
   \              ........    
   \   00000028   ............       DC32 _GetDevProp, _GetDevData, _GetRect
   \              ............

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   ........           DC32     LCD_aMirror

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     GUI_MEMDEV_DEVICE_32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   ........           DC32     _SetVRAMAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   ........           DC32     _SetVSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   ........           DC32     _SetSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   ........           DC32     _SetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   ........           DC32     _GetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   ........           DC32     _SetAlpha

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   ........           DC32     _SetVis

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   ........           DC32     _Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   ........           DC32     _On

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   ........           DC32     _Off

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   ........           DC32     _SetLUTEntry

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   ........           DC32     _SetAlphaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   ........           DC32     _SetChromaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   ........           DC32     _SetChroma

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   ........           DC32     _SetFunc

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {(void *)0}>`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_2`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_3`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_4`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0
   1453            //
   1454            // Data
   1455            //
   1456            DEVICE_CLASS_DRIVER,
   1457            //
   1458            // Drawing functions
   1459            //
   1460            _DrawBitmap,
   1461            _DrawHLine,
   1462            _DrawVLine,
   1463            _FillRect,
   1464            _GetPixelIndex,
   1465            _SetPixelIndex,
   1466            _XorPixel,
   1467            //
   1468            // Set origin
   1469            //
   1470            _SetOrg,
   1471            //
   1472            // Request information
   1473            //
   1474            _GetDevFunc,
   1475            _GetDevProp,
   1476            _GetDevData,
   1477            _GetRect,
   1478          };
   1479          
   1480          #else
   1481          
   1482          void GUIDRV_Lin_OY_24_C(void);   // Avoid empty object files
   1483          void GUIDRV_Lin_OY_24_C(void) {}
   1484          
   1485          #endif
   1486          
   1487          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function          .cstack
     --------          -------
     _DrawBitLine1BPP      48
     _DrawBitLine2BPP      40
     _DrawBitLine32BPP     16
     _DrawBitLine4BPP      40
     _DrawBitLine8BPP      32
     _DrawBitmap           56
     _DrawHLine            32
     _DrawVLine            40
     _FillRect             24
     _GetDevData            0
     _GetDevFunc            0
     _GetDevProp            0
     _GetPixelIndex         4
     _GetPos               16
     _GetRect               0
     _Init                 16
     _Off                   8
     _On                    8
     _SetAlpha             16
     _SetAlphaMode          8
     _SetChroma            24
     _SetChromaMode         8
     _SetFunc              16
     _SetLUTEntry          24
     _SetOrg               24
     _SetPixelIndex         8
     _SetPos               24
     _SetSize              24
     _SetVRAMAddr          16
     _SetVSize             16
     _SetVis               16
     _XorPixel             24


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     _SetPixelIndex           208
     _GetPixelIndex           148
     _XorPixel                196
     _DrawHLine               688
     _DrawVLine               296
     _FillRect                 68
     _DrawBitLine1BPP        2236
     _DrawBitLine2BPP         412
     _DrawBitLine4BPP         412
     _DrawBitLine8BPP         604
     _DrawBitLine32BPP        476
     _DrawBitmap             1016
     _SetOrg                   84
     _GetRect                  44
     _GetDevProp              140
     _GetDevData               24
     _SetVRAMAddr             112
     _SetVSize                 76
     _SetSize                 144
     _SetPos                  132
     _GetPos                   84
     _SetAlpha                108
     _SetVis                  108
     _Init                     92
     _On                       16
     _Off                      16
     _SetLUTEntry              60
     _SetAlphaMode             36
     _SetChromaMode            36
     _SetChroma                60
     _SetFunc                  76
     _GetDevFunc              228
     GUIDRV_Lin_OY_24_API      52
     ??DataTable12              4
     ??DataTable13              4
     ??DataTable14              4
     ??DataTable15              4
     ??DataTable16              4
     ??DataTable16_1            4
     ??DataTable16_2            4
     ??DataTable16_3            4
     ??DataTable16_4            4
     ??DataTable16_5            4
     ??DataTable16_6            4
     ??DataTable16_7            4
     ??DataTable16_8            4
     ??DataTable16_9            4
     ??DataTable16_10           4
     ??DataTable16_11           4
     ??DataTable16_12           4
     ??DataTable16_13           4
     ??DataTable16_14           4
     ??DataTable16_15           4
     ?<Constant {0}>            8
     ?<Constant {(void *)0}>    4
     ?<Constant {0}>_1          8
     ?<Constant {0}>_2          8
     ?<Constant {0}>_3          4
     ?<Constant {0}>_4          4
     ?<Constant {0L}>           8
     ?<Constant {0L}>_1         8

 
    52 bytes in section .rodata
 8 568 bytes in section .text
 
 8 568 bytes of CODE  memory
    52 bytes of CONST memory

Errors: none
Warnings: none
