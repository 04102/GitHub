###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     14/Jul/2015  19:00:08 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\FS\FAT_Open.c                           #
#    Command line =  C:\DUII\TargetHW\FS\FAT_Open.c -D DEBUG=1 -D             #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D                   #
#                    XIGNORE_TEMPERATURE -D BUILD_DEBUG_PORT -D PROFILER      #
#                    -lCN C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Li #
#                    st\ -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\ #
#                    Obj\ --debug --endian=little --cpu=ARM926EJ-S -e         #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\FA #
#                    T_Open.lst                                               #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\FAT #
#                    _Open.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\FS\FAT_Open.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          **** emFile file system for embedded applications ****
     13          emFile is protected by international copyright laws. Knowledge of the
     14          source code may not be used to write a similar product. This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : FAT_Open.c
     19          Purpose     : FAT routines for open/delete files
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          /*********************************************************************
     24          *
     25          *       #include Section
     26          *
     27          **********************************************************************
     28          */
     29          
     30          #include "FAT_Intern.h"
     31          
     32          /*********************************************************************
     33          *
     34          *       Static code
     35          *
     36          **********************************************************************
     37          */
     38          
     39          /*********************************************************************
     40          *
     41          *       _CopyDirText
     42          *
     43          */
     44          static void _CopyDirText(char * pDest, const char  * pSrc, int NumBytes, int EndPos, char Extension) {
     45            int i;
     46            FS_MEMSET(pDest, ' ', NumBytes);
     47            for (i = 0; i < EndPos; i++) {
     48              U8 c;
     49              c = *pSrc++;
     50              if ((Extension == 0) && (c == 0xE5) && (i == 0)) {
     51                c = 0x05;
     52              } else {
     53                c = (U8)FS_TOUPPER(c);
     54              }
     55              *pDest++ = c;
     56            }
     57          }
     58          
     59          /*********************************************************************
     60          *
     61          *       Public code
     62          *
     63          **********************************************************************
     64          */
     65          
     66          /*********************************************************************
     67          *
     68          *       Public code 1
     69          *
     70          **********************************************************************
     71          
     72            Functions in this section are global, but are used inside the FAT
     73            File System Layer only.
     74          
     75          */
     76          
     77          /*********************************************************************
     78          *
     79          *       FS_FAT_WriteDirEntry83
     80          *
     81          */

   \                                 In section .text, align 4, keep-with-next
     82          void FS_FAT_WriteDirEntry83(FS_FAT_DENTRY * pDirEntry, const FS_83NAME * pFileName, U32 ClusterId, U8 Attributes, U32 Size, U16 Time, U16 Date) {
   \                     FS_FAT_WriteDirEntry83:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
   \   00000014   20809DE5           LDR      R8,[SP, #+32]
   \   00000018   B492DDE1           LDRH     R9,[SP, #+36]
   \   0000001C   B8A2DDE1           LDRH     R10,[SP, #+40]
     83            FS_MEMSET(pDirEntry, 0, sizeof(FS_FAT_DENTRY));
   \   00000020   2010A0E3           MOV      R1,#+32
   \   00000024   ........           BL       __aeabi_memclr
     84            FS_MEMCPY((char*)pDirEntry->data, pFileName, 11);
   \   00000028   0B20A0E3           MOV      R2,#+11
   \   0000002C   0510A0E1           MOV      R1,R5
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       FS_memcpy
     85            pDirEntry->data[DIR_ENTRY_OFF_ATTRIBUTES]                       = Attributes;
   \   00000038   0B70C4E5           STRB     R7,[R4, #+11]
     86            FS_StoreU16LE(&pDirEntry->data[DIR_ENTRY_OFF_CREATION_TIME],        Time);
   \   0000003C   0910A0E1           MOV      R1,R9
   \   00000040   0E0084E2           ADD      R0,R4,#+14
   \   00000044   ........           BL       FS_StoreU16LE
     87            FS_StoreU16LE(&pDirEntry->data[DIR_ENTRY_OFF_CREATION_DATE],        Date);
   \   00000048   0A10A0E1           MOV      R1,R10
   \   0000004C   100084E2           ADD      R0,R4,#+16
   \   00000050   ........           BL       FS_StoreU16LE
     88            FS_StoreU16LE(&pDirEntry->data[DIR_ENTRY_OFF_WRITE_TIME],           Time);
   \   00000054   0910A0E1           MOV      R1,R9
   \   00000058   160084E2           ADD      R0,R4,#+22
   \   0000005C   ........           BL       FS_StoreU16LE
     89            FS_StoreU16LE(&pDirEntry->data[DIR_ENTRY_OFF_WRITE_DATE],           Date);
   \   00000060   0A10A0E1           MOV      R1,R10
   \   00000064   180084E2           ADD      R0,R4,#+24
   \   00000068   ........           BL       FS_StoreU16LE
     90            FS_FAT_WriteDirEntryCluster(pDirEntry, ClusterId);
   \   0000006C   0618A0E1           LSL      R1,R6,#+16
   \   00000070   2118A0E1           LSR      R1,R1,#+16
   \   00000074   1A0084E2           ADD      R0,R4,#+26
   \   00000078   ........           BL       FS_StoreU16LE
   \   0000007C   2618A0E1           LSR      R1,R6,#+16
   \   00000080   140084E2           ADD      R0,R4,#+20
   \   00000084   ........           BL       FS_StoreU16LE
     91            FS_StoreU32LE(&pDirEntry->data[DIR_ENTRY_OFF_SIZE],                 Size);
   \   00000088   0810A0E1           MOV      R1,R8
   \   0000008C   1C0084E2           ADD      R0,R4,#+28
   \   00000090   F047BDE8           POP      {R4-R10,LR}
   \   00000094   ........           B        FS_StoreU32LE    ;; tailcall
     92          }
     93          
     94          
     95          /*********************************************************************
     96          *
     97          *       FS_FAT_WriteDirEntryShort
     98          *
     99          */

   \                                 In section .text, align 4, keep-with-next
    100          void FS_FAT_WriteDirEntryShort(FS_FAT_DENTRY * pDirEntry, const char * pFileName, U32 ClusterId, U8 Attributes, U32 Size, U16 Time, U16 Date) {
   \                     FS_FAT_WriteDirEntryShort:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   0360A0E1           MOV      R6,R3
   \   00000014   28709DE5           LDR      R7,[SP, #+40]
   \   00000018   BC82DDE1           LDRH     R8,[SP, #+44]
   \   0000001C   B093DDE1           LDRH     R9,[SP, #+48]
    101            FS_83NAME Name83;
    102            FS_FAT_Make83Name(&Name83, pFileName, 0);
   \   00000020   0020A0E3           MOV      R2,#+0
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   ........           BL       FS_FAT_Make83Name
    103            FS_FAT_WriteDirEntry83(pDirEntry, &Name83, ClusterId, Attributes, Size, Time, Date);
   \   0000002C   2010A0E3           MOV      R1,#+32
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       __aeabi_memclr
   \   00000038   0B20A0E3           MOV      R2,#+11
   \   0000003C   0D10A0E1           MOV      R1,SP
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   ........           BL       FS_memcpy
   \   00000048   0B60C4E5           STRB     R6,[R4, #+11]
   \   0000004C   0810A0E1           MOV      R1,R8
   \   00000050   0E0084E2           ADD      R0,R4,#+14
   \   00000054   ........           BL       FS_StoreU16LE
   \   00000058   0910A0E1           MOV      R1,R9
   \   0000005C   100084E2           ADD      R0,R4,#+16
   \   00000060   ........           BL       FS_StoreU16LE
   \   00000064   0810A0E1           MOV      R1,R8
   \   00000068   160084E2           ADD      R0,R4,#+22
   \   0000006C   ........           BL       FS_StoreU16LE
   \   00000070   0910A0E1           MOV      R1,R9
   \   00000074   180084E2           ADD      R0,R4,#+24
   \   00000078   ........           BL       FS_StoreU16LE
   \   0000007C   0518A0E1           LSL      R1,R5,#+16
   \   00000080   2118A0E1           LSR      R1,R1,#+16
   \   00000084   1A0084E2           ADD      R0,R4,#+26
   \   00000088   ........           BL       FS_StoreU16LE
   \   0000008C   2518A0E1           LSR      R1,R5,#+16
   \   00000090   140084E2           ADD      R0,R4,#+20
   \   00000094   ........           BL       FS_StoreU16LE
   \   00000098   0710A0E1           MOV      R1,R7
   \   0000009C   1C0084E2           ADD      R0,R4,#+28
   \   000000A0   ........           BL       FS_StoreU32LE
    104          }
   \   000000A4   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   000000A8   F083BDE8           POP      {R4-R9,PC}       ;; return
    105          
    106          /*********************************************************************
    107          *
    108          *       FS_FAT_WriteDirEntryCluster
    109          *
    110          */

   \                                 In section .text, align 4, keep-with-next
    111          void FS_FAT_WriteDirEntryCluster(FS_FAT_DENTRY * pDirEntry, U32 Cluster) {
   \                     FS_FAT_WriteDirEntryCluster:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   \   00000008   0040A0E1           MOV      R4,R0
    112            FS_StoreU16LE(&pDirEntry->data[DIR_ENTRY_OFF_FIRSTCLUSTER_LOW],  (U16)Cluster);
   \   0000000C   0118A0E1           LSL      R1,R1,#+16
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   2118A0E1           LSR      R1,R1,#+16
   \   00000018   1A0084E2           ADD      R0,R4,#+26
   \   0000001C   ........           BL       FS_StoreU16LE
    113            FS_StoreU16LE(&pDirEntry->data[DIR_ENTRY_OFF_FIRSTCLUSTER_HIGH], (U16)(Cluster >> 16));
   \   00000020   2518A0E1           LSR      R1,R5,#+16
   \   00000024   140084E2           ADD      R0,R4,#+20
   \   00000028   04D08DE2           ADD      SP,SP,#+4
   \   0000002C   3040BDE8           POP      {R4,R5,LR}
   \   00000030   ........           B        FS_StoreU16LE    ;; tailcall
    114          }
    115          
    116          /*********************************************************************
    117          *
    118          *       FS_FAT_GetFirstCluster
    119          *
    120          */

   \                                 In section .text, align 4, keep-with-next
    121          U32 FS_FAT_GetFirstCluster(FS_FAT_DENTRY * pDirEntry) {
   \                     FS_FAT_GetFirstCluster:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   04D04DE2           SUB      SP,SP,#+4
    122            U32 r;
    123            r = FS_LoadU16LE(&pDirEntry->data[DIR_ENTRY_OFF_FIRSTCLUSTER_LOW]) | (((U32)FS_LoadU16LE(&pDirEntry->data[DIR_ENTRY_OFF_FIRSTCLUSTER_HIGH])) << 16);
    124            return r;
   \   0000000C   1A0084E2           ADD      R0,R4,#+26
   \   00000010   ........           BL       FS_LoadU16LE
   \   00000014   0050A0E1           MOV      R5,R0
   \   00000018   140084E2           ADD      R0,R4,#+20
   \   0000001C   ........           BL       FS_LoadU16LE
   \   00000020   000885E1           ORR      R0,R5,R0, LSL #+16
   \   00000024   04D08DE2           ADD      SP,SP,#+4
   \   00000028   3080BDE8           POP      {R4,R5,PC}       ;; return
    125          }
    126          
    127          /*********************************************************************
    128          *
    129          *       FS_FAT_InitDirEntryScan
    130          *
    131          *  Description:
    132          *
    133          *  Parameters:
    134          *
    135          *  Return value:
    136          */

   \                                 In section .text, align 4, keep-with-next
    137          void FS_FAT_InitDirEntryScan(FS_FAT_INFO * pFATInfo, FS_DIR_POS * pDirPos, U32 DirCluster) {
    138            pDirPos->DirEntryIndex = 0;
   \                     FS_FAT_InitDirEntryScan:
   \   00000000   0030A0E3           MOV      R3,#+0
   \   00000004   083081E5           STR      R3,[R1, #+8]
    139            if (pFATInfo->FATType == FS_FAT_TYPE_FAT32) {
   \   00000008   1E30D0E5           LDRB     R3,[R0, #+30]
   \   0000000C   200053E3           CMP      R3,#+32
    140              if (DirCluster == 0) {
   \   00000010   00005203           CMPEQ    R2,#+0
    141                DirCluster = pFATInfo->RootDirPos;
   \   00000014   14209005           LDREQ    R2,[R0, #+20]
    142              }
    143            }
    144            pDirPos->FirstCluster  = DirCluster;
   \   00000018   042081E5           STR      R2,[R1, #+4]
    145            pDirPos->Cluster       = DirCluster;
   \   0000001C   002081E5           STR      R2,[R1, #+0]
    146          }
   \   00000020   1EFF2FE1           BX       LR               ;; return
    147          
    148          /*********************************************************************
    149          *
    150          *       FS_FAT_GetDirEntry
    151          *
    152          *  Description:
    153          *
    154          *  Parameters:
    155          *
    156          *  Return value:
    157          *    >  0             Directory sector
    158          *    == 0             Error, no more sectors
    159          */

   \                                 In section .text, align 4, keep-with-next
    160          FS_FAT_DENTRY * FS_FAT_GetDirEntry(FS_VOLUME * pVolume, FS_SB* pSB, FS_DIR_POS * pDirPos) {
   \                     FS_FAT_GetDirEntry:
   \   00000000   F14F2DE9           PUSH     {R0,R4-R11,LR}
   \   00000004   0250A0E1           MOV      R5,R2
    161            U32 Cluster;
    162            U32 DirSector;
    163            U32 DirEntryIndex;
    164            U32 DirSectorIndex;
    165            U32 CurClusterIndex;
    166            FS_FAT_INFO        *  pFATInfo;
    167            unsigned ShiftPerEntry;
    168          
    169            pFATInfo      = &pVolume->FSInfo.FATInfo;
    170            Cluster       = pDirPos->Cluster;
    171            DirEntryIndex = pDirPos->DirEntryIndex;
   \   00000008   088095E5           LDR      R8,[R5, #+8]
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   1C6080E2           ADD      R6,R0,#+28
    172            CurClusterIndex = (DirEntryIndex << DIR_ENTRY_SHIFT) / pFATInfo->BytesPerCluster;
   \   00000014   8802A0E1           LSL      R0,R8,#+5
   \   00000018   0C1096E5           LDR      R1,[R6, #+12]
   \   0000001C   ........           BL       __aeabi_uidiv
   \   00000020   0090A0E1           MOV      R9,R0
    173            if (CurClusterIndex < pDirPos->ClusterIndex) {
   \   00000024   0C0095E5           LDR      R0,[R5, #+12]
   \   00000028   007095E5           LDR      R7,[R5, #+0]
   \   0000002C   000059E1           CMP      R9,R0
    174              pDirPos->ClusterIndex = 0;
   \   00000030   0000A033           MOVCC    R0,#+0
   \   00000034   0C008535           STRCC    R0,[R5, #+12]
    175            }
    176            /*
    177             * Walk to the right cluster starting from the last known cluster position.
    178             */
    179            ShiftPerEntry = pFATInfo->ldBytesPerSector - DIR_ENTRY_SHIFT;    /* 4 for 512 byte sectors. */
   \   00000038   B600D6E1           LDRH     R0,[R6, #+6]
   \   0000003C   08D04DE2           SUB      SP,SP,#+8
   \   00000040   05A040E2           SUB      R10,R0,#+5
    180            if (pDirPos->ClusterIndex == 0) {
   \   00000044   0C0095E5           LDR      R0,[R5, #+12]
    181              Cluster = pDirPos->FirstCluster;
    182            }
    183            DirSectorIndex = DirEntryIndex >> ShiftPerEntry;
   \   00000048   38BAA0E1           LSR      R11,R8,R10
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   04709505           LDREQ    R7,[R5, #+4]
    184            if (Cluster) {
   \   00000054   000057E3           CMP      R7,#+0
   \   00000058   1C00000A           BEQ      ??FS_FAT_GetDirEntry_0
    185              int SectorMask;
    186              U32 NumClustersToWalk;
    187              SectorMask =  pFATInfo->SecPerClus - 1;
   \   0000005C   1C20D6E5           LDRB     R2,[R6, #+28]
    188              NumClustersToWalk = CurClusterIndex - pDirPos->ClusterIndex;
   \   00000060   003059E0           SUBS     R3,R9,R0
   \   00000064   012042E2           SUB      R2,R2,#+1
   \   00000068   00208DE5           STR      R2,[SP, #+0]
    189              /* Go to next cluster */
    190              if (NumClustersToWalk) {
   \   0000006C   0700000A           BEQ      ??FS_FAT_GetDirEntry_1
    191                Cluster = FS_FAT_WalkCluster(pVolume, pSB, Cluster, NumClustersToWalk);
   \   00000070   0720A0E1           MOV      R2,R7
   \   00000074   0410A0E1           MOV      R1,R4
   \   00000078   08009DE5           LDR      R0,[SP, #+8]
   \   0000007C   ........           BL       FS_FAT_WalkCluster
   \   00000080   0070B0E1           MOVS     R7,R0
    192              }
    193              if (Cluster == 0) {
   \   00000084   0100001A           BNE      ??FS_FAT_GetDirEntry_1
    194                return 0;               /* No more clusters */
   \                     ??FS_FAT_GetDirEntry_2:
   \   00000088   0000A0E3           MOV      R0,#+0
   \   0000008C   1B0000EA           B        ??FS_FAT_GetDirEntry_3
    195              }
    196              DirSector = FS_FAT_ClusterId2SectorNo(pFATInfo, Cluster) + (DirSectorIndex & SectorMask);
   \                     ??FS_FAT_GetDirEntry_1:
   \   00000090   0710A0E1           MOV      R1,R7
   \   00000094   0600A0E1           MOV      R0,R6
   \   00000098   ........           BL       FS_FAT_ClusterId2SectorNo
   \   0000009C   00109DE5           LDR      R1,[SP, #+0]
   \   000000A0   0B1001E0           AND      R1,R1,R11
   \   000000A4   001081E0           ADD      R1,R1,R0
    197            } else {
    198              U32 MaxDirSectorIndex;
    199              MaxDirSectorIndex = pFATInfo->RootEntCnt >> ShiftPerEntry;
    200              if (DirSectorIndex  < MaxDirSectorIndex) {
    201                DirSector = pFATInfo->RootDirPos + DirSectorIndex;
    202              } else {
    203                /*
    204                 *  We reach the limit
    205                 */
    206                 return NULL;
    207              }
    208            }
    209            pDirPos->Cluster      = Cluster;
   \                     ??FS_FAT_GetDirEntry_4:
   \   000000A8   007085E5           STR      R7,[R5, #+0]
    210            pDirPos->ClusterIndex = CurClusterIndex;
   \   000000AC   0C9085E5           STR      R9,[R5, #+12]
    211            FS__SB_SetSector(pSB, DirSector, FS_SB_TYPE_DIRECTORY);
   \   000000B0   0120A0E3           MOV      R2,#+1
   \   000000B4   0400A0E1           MOV      R0,R4
   \   000000B8   ........           BL       FS__SB_SetSector
    212            if (FS__SB_Read(pSB)) {
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   ........           BL       FS__SB_Read
   \   000000C4   000050E3           CMP      R0,#+0
   \   000000C8   0600000A           BEQ      ??FS_FAT_GetDirEntry_5
    213              FS_DEBUG_ERROROUT((FS_MTYPE_FS, "FS_FAT_FindNextDirEntry: Failed to read sector %d.\n", pSB->SectorNo));
    214              return NULL;
   \   000000CC   EDFFFFEA           B        ??FS_FAT_GetDirEntry_2
    215            }
   \                     ??FS_FAT_GetDirEntry_0:
   \   000000D0   B801D6E1           LDRH     R0,[R6, #+24]
   \   000000D4   500A5BE1           CMP      R11,R0, ASR R10
   \   000000D8   14009635           LDRCC    R0,[R6, #+20]
   \   000000DC   00108B30           ADDCC    R1,R11,R0
   \   000000E0   F0FFFF3A           BCC      ??FS_FAT_GetDirEntry_4
   \   000000E4   E7FFFFEA           B        ??FS_FAT_GetDirEntry_2
    216            return ((FS_FAT_DENTRY *)pSB->pBuffer) + (DirEntryIndex & ((1 << ShiftPerEntry)- 1));
   \                     ??FS_FAT_GetDirEntry_5:
   \   000000E8   0100A0E3           MOV      R0,#+1
   \   000000EC   001060E2           RSB      R1,R0,#+0
   \   000000F0   100A81E0           ADD      R0,R1,R0, LSL R10
   \   000000F4   081094E5           LDR      R1,[R4, #+8]
   \   000000F8   080000E0           AND      R0,R0,R8
   \   000000FC   800281E0           ADD      R0,R1,R0, LSL #+5
   \                     ??FS_FAT_GetDirEntry_3:
   \   00000100   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000104   F08FBDE8           POP      {R4-R11,PC}      ;; return
    217          }
    218          
    219          /*********************************************************************
    220          *
    221          *       FS_FAT_IncDirPos
    222          *
    223          *  Description:
    224          *    Increments the position in the directory
    225          */

   \                                 In section .text, align 4, keep-with-next
    226          void FS_FAT_IncDirPos(FS_DIR_POS * pDirPos) {
    227            pDirPos->DirEntryIndex++;
   \                     FS_FAT_IncDirPos:
   \   00000000   081090E5           LDR      R1,[R0, #+8]
   \   00000004   011081E2           ADD      R1,R1,#+1
   \   00000008   081080E5           STR      R1,[R0, #+8]
    228          }
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    229          
    230          
    231          /*********************************************************************
    232          *
    233          *       FS_FAT_FindEmptyDirEntry
    234          *
    235          *  Description:
    236          *    Tries to find an empty directory entry in the specified directory.
    237          *    If there is no free entry, try to increase directory size.
    238          *
    239          *  Parameters:
    240          *    pVolume     - Volume information
    241          *    DirStart    - Start of directory, where to create pDirName.
    242          *    DirSize     - Sector size of the directory starting at DirStart.
    243          *
    244          *  Return value:
    245          *    != NULL     - Free entry found
    246          *    NULL        - An error has occurred.
    247          */

   \                                 In section .text, align 4, keep-with-next
    248          FS_FAT_DENTRY * FS_FAT_FindEmptyDirEntry(FS_VOLUME * pVolume,  FS_SB* pSB, U32 DirStart) {
   \                     FS_FAT_FindEmptyDirEntry:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0270A0E1           MOV      R7,R2
   \   00000008   14D04DE2           SUB      SP,SP,#+20
   \   0000000C   0060A0E1           MOV      R6,R0
    249            FS_FAT_DENTRY       * pDirEntry;
    250            int                   i;
    251            U32                DirSector;
    252            FS_FAT_INFO         * pFATInfo;
    253            FS_DIR_POS            DirPos;
    254          
    255            pFATInfo    = &pVolume->FSInfo.FATInfo;
    256          
    257            /* Read directory, trying to find an empty slot */
    258            FS_FAT_InitDirEntryScan(pFATInfo, &DirPos, DirStart);
   \   00000010   0020A0E3           MOV      R2,#+0
   \   00000014   0140A0E1           MOV      R4,R1
   \   00000018   1C5086E2           ADD      R5,R6,#+28
   \   0000001C   08208DE5           STR      R2,[SP, #+8]
   \   00000020   1E10D5E5           LDRB     R1,[R5, #+30]
   \   00000024   0700A0E1           MOV      R0,R7
   \   00000028   200051E3           CMP      R1,#+32
   \   0000002C   00005003           CMPEQ    R0,#+0
   \   00000030   14009505           LDREQ    R0,[R5, #+20]
   \   00000034   04008DE5           STR      R0,[SP, #+4]
   \   00000038   00008DE5           STR      R0,[SP, #+0]
    259            do {
    260              U8 c;
    261              pDirEntry = FS_FAT_GetDirEntry(pVolume, pSB, &DirPos);
   \                     ??FS_FAT_FindEmptyDirEntry_0:
   \   0000003C   0D20A0E1           MOV      R2,SP
   \   00000040   0410A0E1           MOV      R1,R4
   \   00000044   0600A0E1           MOV      R0,R6
   \   00000048   ........           BL       FS_FAT_GetDirEntry
    262              FS_FAT_IncDirPos(&DirPos);
   \   0000004C   08109DE5           LDR      R1,[SP, #+8]
    263              if (!pDirEntry) {
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   011081E2           ADD      R1,R1,#+1
   \   00000058   08108DE5           STR      R1,[SP, #+8]
   \   0000005C   2900001A           BNE      ??FS_FAT_FindEmptyDirEntry_1
    264                if ((DirStart == 0) && (pFATInfo->RootEntCnt)) {
   \   00000060   000057E3           CMP      R7,#+0
   \   00000064   0400001A           BNE      ??FS_FAT_FindEmptyDirEntry_2
   \   00000068   B801D5E1           LDRH     R0,[R5, #+24]
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   0100000A           BEQ      ??FS_FAT_FindEmptyDirEntry_2
    265                  /* Root directory of FAT12/16 medium can not be increased */
    266                  FS_DEBUG_ERROROUT((FS_MTYPE_FS, "FS_FAT_FindEmptyDirEntry: Root directory too small.\n"));
    267                  return NULL;                  /* Can not create, directory is full */
   \                     ??FS_FAT_FindEmptyDirEntry_3:
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   260000EA           B        ??FS_FAT_FindEmptyDirEntry_4
    268                } else {
    269                  U32 NewCluster;
    270                  U32 LastCluster;
    271                  LastCluster = FS_FAT_FindLastCluster(pVolume, pSB, DirPos.Cluster, (U32*)NULL);
   \                     ??FS_FAT_FindEmptyDirEntry_2:
   \   0000007C   0030A0E3           MOV      R3,#+0
   \   00000080   00209DE5           LDR      R2,[SP, #+0]
   \   00000084   0410A0E1           MOV      R1,R4
   \   00000088   0600A0E1           MOV      R0,R6
   \   0000008C   ........           BL       FS_FAT_FindLastCluster
   \   00000090   0020A0E1           MOV      R2,R0
    272                  NewCluster  = FS_FAT_AllocCluster   (pVolume, pSB, LastCluster, NULL);
   \   00000094   0030A0E3           MOV      R3,#+0
   \   00000098   0410A0E1           MOV      R1,R4
   \   0000009C   0600A0E1           MOV      R0,R6
   \   000000A0   ........           BL       FS_FAT_AllocCluster
   \   000000A4   0060A0E1           MOV      R6,R0
    273                  FS__SB_Flush(pSB);
   \   000000A8   0400A0E1           MOV      R0,R4
   \   000000AC   ........           BL       FS__SB_Flush
    274                  if (NewCluster) {
   \   000000B0   000056E3           CMP      R6,#+0
   \   000000B4   EEFFFF0A           BEQ      ??FS_FAT_FindEmptyDirEntry_3
    275                    /*
    276                     * Clean new directory cluster  (Fill with 0)
    277                     */
    278                    FS_MEMSET(pSB->pBuffer, 0x00, pFATInfo->BytesPerSec);
   \   000000B8   B410D5E1           LDRH     R1,[R5, #+4]
   \   000000BC   080094E5           LDR      R0,[R4, #+8]
   \   000000C0   ........           BL       __aeabi_memclr
    279                    DirSector = FS_FAT_ClusterId2SectorNo(pFATInfo, NewCluster);
   \   000000C4   0610A0E1           MOV      R1,R6
   \   000000C8   0500A0E1           MOV      R0,R5
   \   000000CC   ........           BL       FS_FAT_ClusterId2SectorNo
   \   000000D0   0060A0E1           MOV      R6,R0
    280                    for (i = pFATInfo->SecPerClus - 1; i >= 0; i--) {
   \   000000D4   1C00D5E5           LDRB     R0,[R5, #+28]
   \   000000D8   015050E2           SUBS     R5,R0,#+1
   \   000000DC   0700004A           BMI      ??FS_FAT_FindEmptyDirEntry_5
    281                      FS__SB_SetSector(pSB, DirSector + i, FS_SB_TYPE_DIRECTORY);
   \                     ??FS_FAT_FindEmptyDirEntry_6:
   \   000000E0   0120A0E3           MOV      R2,#+1
   \   000000E4   061085E0           ADD      R1,R5,R6
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       FS__SB_SetSector
    282                      FS__SB_Write(pSB);
   \   000000F0   0400A0E1           MOV      R0,R4
   \   000000F4   ........           BL       FS__SB_Write
    283                    }
   \   000000F8   015055E2           SUBS     R5,R5,#+1
   \   000000FC   F7FFFF5A           BPL      ??FS_FAT_FindEmptyDirEntry_6
    284                    pDirEntry = (FS_FAT_DENTRY *)pSB->pBuffer;
   \                     ??FS_FAT_FindEmptyDirEntry_5:
   \   00000100   080094E5           LDR      R0,[R4, #+8]
    285                  } else {
    286                    FS_DEBUG_ERROROUT((FS_MTYPE_FS, "FS_FAT_FindEmptyDirEntry: Disk is full.\n"));
    287                    return NULL;
    288                  }
    289                }
    290                break;
   \   00000104   030000EA           B        ??FS_FAT_FindEmptyDirEntry_4
    291              }
    292              c = pDirEntry->data[0];
   \                     ??FS_FAT_FindEmptyDirEntry_1:
   \   00000108   0010D0E5           LDRB     R1,[R0, #+0]
    293              if ((c == 0x00) || (c == 0xE5)) {        /* A free entry has either 0 or 0xe5 as first byte */
   \   0000010C   000051E3           CMP      R1,#+0
   \   00000110   E5005113           CMPNE    R1,#+229
   \   00000114   C8FFFF1A           BNE      ??FS_FAT_FindEmptyDirEntry_0
    294                /* Free entry found. */
    295                break;
    296              }
    297            } while (1);
    298            return pDirEntry;
   \                     ??FS_FAT_FindEmptyDirEntry_4:
   \   00000118   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   0000011C   F080BDE8           POP      {R4-R7,PC}       ;; return
    299          }
    300          
    301          /*********************************************************************
    302          *
    303          *       FS_FAT_DeleteFileOrDir
    304          *
    305          *  Description:
    306          *    Deletes a directory entry and frees all clusters allocated to it
    307          *
    308          *  Parameters:
    309          *    pVolume     - Volume information
    310          *    pSB         - Smart buffer
    311          *    pDirEntry   - Pointer to directory entry to be deleted (in smart buffer)
    312          *    IsFile      - 1 => remove a file
    313          *                  0 => remove a directory
    314          *
    315          */

   \                                 In section .text, align 4, keep-with-next
    316          char FS_FAT_DeleteFileOrDir(FS_VOLUME * pVolume, FS_SB * pSB, FS_FAT_DENTRY  * pDirEntry, U8 IsFile) {
   \                     FS_FAT_DeleteFileOrDir:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0260A0E1           MOV      R6,R2
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0370A0E1           MOV      R7,R3
    317            I32           FirstCluster;
    318            I32           NumClusters;
    319            FS_FAT_INFO    * pFATInfo;
    320          
    321            pFATInfo = &pVolume->FSInfo.FATInfo;
   \   00000014   1C8084E2           ADD      R8,R4,#+28
    322            if (pDirEntry) {
   \   00000018   000056E3           CMP      R6,#+0
   \   0000001C   1800000A           BEQ      ??FS_FAT_DeleteFileOrDir_0
    323              /* Entry has been found, delete directory entry */
    324              pDirEntry->data[0]  = 0xe5;
   \   00000020   E500A0E3           MOV      R0,#+229
   \   00000024   0000C6E5           STRB     R0,[R6, #+0]
    325              /* Free blocks in FAT */
    326              //
    327              //  For normal files, there are no more clusters freed than the entry's file size
    328              //  does indicate. That avoids corruption of the complete media in case there is
    329              //  no EOF mark found for the file (FAT is corrupt!!!).
    330              //  If the function should remove a directory, file size if always 0 and cannot
    331              //  be used for that purpose. To avoid running into endless loop,
    332              //  NumClusters is set to a reasonable limit.
    333              //
    334              FS__SB_MarkDirty(pSB);
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   ........           BL       FS__SB_MarkDirty
    335              if (IsFile) {
   \   00000030   000057E3           CMP      R7,#+0
   \   00000034   0700000A           BEQ      ??FS_FAT_DeleteFileOrDir_1
    336                U32 FileSize;
    337                FileSize  = FS_LoadU32LE(&pDirEntry->data[28]);
   \   00000038   1C0086E2           ADD      R0,R6,#+28
   \   0000003C   ........           BL       FS_LoadU32LE
    338                NumClusters      = (FileSize + pFATInfo->BytesPerCluster - 1) / pFATInfo->BytesPerCluster;
   \   00000040   0C1098E5           LDR      R1,[R8, #+12]
   \   00000044   000081E0           ADD      R0,R1,R0
   \   00000048   010040E2           SUB      R0,R0,#+1
   \   0000004C   ........           BL       __aeabi_uidiv
   \   00000050   0070A0E1           MOV      R7,R0
   \   00000054   000000EA           B        ??FS_FAT_DeleteFileOrDir_2
    339              } else {
    340                NumClusters = 1000;     /* Max. number of clusters for directory */
   \                     ??FS_FAT_DeleteFileOrDir_1:
   \   00000058   FA7FA0E3           MOV      R7,#+1000
    341              }
    342              FirstCluster = FS_FAT_GetFirstCluster(pDirEntry);
   \                     ??FS_FAT_DeleteFileOrDir_2:
   \   0000005C   1A0086E2           ADD      R0,R6,#+26
   \   00000060   ........           BL       FS_LoadU16LE
   \   00000064   0080A0E1           MOV      R8,R0
   \   00000068   140086E2           ADD      R0,R6,#+20
   \   0000006C   ........           BL       FS_LoadU16LE
    343              FS_FAT_FreeClusterChain(pVolume, pSB, FirstCluster, NumClusters);
   \   00000070   002888E1           ORR      R2,R8,R0, LSL #+16
   \   00000074   0730A0E1           MOV      R3,R7
   \   00000078   0510A0E1           MOV      R1,R5
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   ........           BL       FS_FAT_FreeClusterChain
    344            }
    345            return pSB->HasError;
   \                     ??FS_FAT_DeleteFileOrDir_0:
   \   00000084   0D00D5E5           LDRB     R0,[R5, #+13]
   \   00000088   F081BDE8           POP      {R4-R8,PC}       ;; return
    346          }
    347          
    348          /*********************************************************************
    349          *
    350          *       FS_FAT_Make83Name
    351          *
    352          *  Description:
    353          *    FS internal function. Convert a given name to the format, which is
    354          *    used in the FAT directory.
    355          *
    356          *  Parameters:
    357          *    pOrgName    - Pointer to name to be translated
    358          *    pEntryName  - Pointer to a buffer for storing the real name used
    359          *                  in a directory.
    360          *    Len         - Len of the name. 0 means no defined length.
    361          *
    362          *  Return value:
    363          *    0             Success: Name could be converted
    364          *    1             Error:   Name did not comply with 8.3 criteria
    365          *
    366          *  Notes
    367          *    (1) Allowed file names
    368          *        The filename must conform to 8.3 standards.
    369          *        The extension is optional, the name may be 8 characters at most.
    370          */

   \                                 In section .text, align 4, keep-with-next
    371          char FS_FAT_Make83Name(FS_83NAME * pOutName, const char *pOrgName, int Len) {
   \                     FS_FAT_Make83Name:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0270B0E1           MOVS     R7,R2
    372            int          i;
    373            int          ExtPos;
    374          
    375            ExtPos = -1;
   \   00000010   0060E0E3           MVN      R6,#+0
   \   00000014   04D04DE2           SUB      SP,SP,#+4
    376            if (Len == 0) {
    377              Len = -1;        /* Change to a safe value, which can never occur in comparison */
   \   00000018   0670A001           MOVEQ    R7,R6
    378            }
    379            //
    380            //  In special case of ".." we manually generate the 8.3 entry
    381            //
    382            if (FS_STRCMP(pOrgName, "..") == 0) {    
   \   0000001C   ........           ADR      R1,??DataTable1  ;; 0x2E, 0x2E, 0x00, 0x00
   \   00000020   0500A0E1           MOV      R0,R5
   \   00000024   ........           BL       strcmp
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0A00001A           BNE      ??FS_FAT_Make83Name_0
    383              FS_MEMCPY(&pOutName->ac[0], pOrgName, 2);
   \   00000030   0220A0E3           MOV      R2,#+2
   \   00000034   0510A0E1           MOV      R1,R5
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   ........           BL       FS_memcpy
    384              FS_MEMSET(&pOutName->ac[2], ' ', sizeof(FS_83NAME) - 2);
   \   00000040   2020A0E3           MOV      R2,#+32
   \   00000044   0910A0E3           MOV      R1,#+9
   \   00000048   020084E2           ADD      R0,R4,#+2
   \   0000004C   ........           BL       __aeabi_memset
    385              return 0;    
   \                     ??FS_FAT_Make83Name_1:
   \   00000050   0000A0E3           MOV      R0,#+0
   \                     ??FS_FAT_Make83Name_2:
   \   00000054   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000058   F08FBDE8           POP      {R4-R11,PC}      ;; return
    386            }
    387            for (i = 0; ; i++) {
   \                     ??FS_FAT_Make83Name_0:
   \   0000005C   0080A0E3           MOV      R8,#+0
   \   00000060   0590A0E1           MOV      R9,R5
    388              char c;
    389              if (i == 13) {
    390                return 1;                     /* Error, file name too long*/
    391              }
    392              c = *(pOrgName + i);
   \                     ??FS_FAT_Make83Name_3:
   \   00000064   00A0D9E5           LDRB     R10,[R9, #+0]
    393              if ((c == 0) || (i == Len)) {    /* End of name ? */
   \   00000068   00005AE3           CMP      R10,#+0
   \   0000006C   07005811           CMPNE    R8,R7
   \   00000070   0500001A           BNE      ??FS_FAT_Make83Name_4
    394                if (ExtPos == -1) {
   \   00000074   010076E3           CMN      R6,#+1
    395                  ExtPos = i;
   \   00000078   0860A001           MOVEQ    R6,R8
    396                }
    397                break;
    398              }
    399              if (FS_FAT_IsValidShortNameChar(c) == 0) {
    400                return 1;                      // Invalid character used in string
    401              }
    402              if (c == '.') {
    403                ExtPos = i;
    404              }
    405            }
    406            /* Perform some checks */
    407            if (ExtPos == 0) {
   \   0000007C   000056E3           CMP      R6,#+0
   \   00000080   0C00001A           BNE      ??FS_FAT_Make83Name_5
   \                     ??FS_FAT_Make83Name_6:
   \   00000084   0100A0E3           MOV      R0,#+1
   \   00000088   F1FFFFEA           B        ??FS_FAT_Make83Name_2
   \                     ??FS_FAT_Make83Name_4:
   \   0000008C   0A00A0E1           MOV      R0,R10
   \   00000090   ........           BL       FS_FAT_IsValidShortNameChar
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   F9FFFF0A           BEQ      ??FS_FAT_Make83Name_6
   \   0000009C   2E005AE3           CMP      R10,#+46
   \   000000A0   0860A001           MOVEQ    R6,R8
   \   000000A4   018088E2           ADD      R8,R8,#+1
   \   000000A8   019089E2           ADD      R9,R9,#+1
   \   000000AC   0D0058E3           CMP      R8,#+13
   \   000000B0   EBFFFF1A           BNE      ??FS_FAT_Make83Name_3
   \   000000B4   F2FFFFEA           B        ??FS_FAT_Make83Name_6
    408              return 1;                     /* Error, no file name*/
    409            }
    410            if (ExtPos > 8) {
   \                     ??FS_FAT_Make83Name_5:
   \   000000B8   090056E3           CMP      R6,#+9
    411              return 1;                     /* Error, file name too long */
    412            }
    413            if ((i - ExtPos) > 4) {
   \   000000BC   067048B0           SUBLT    R7,R8,R6
   \   000000C0   050057B3           CMPLT    R7,#+5
   \   000000C4   EEFFFFAA           BGE      ??FS_FAT_Make83Name_6
    414              return 1;                     /* Error, extension too long */
    415            }
    416            /* All checks passed, copy filename and extension */
    417            _CopyDirText(&pOutName->ac[0], pOrgName,              8, ExtPos,         0);
   \   000000C8   0480A0E1           MOV      R8,R4
   \   000000CC   0590A0E1           MOV      R9,R5
   \   000000D0   2020A0E3           MOV      R2,#+32
   \   000000D4   0810A0E3           MOV      R1,#+8
   \   000000D8   0800A0E1           MOV      R0,R8
   \   000000DC   ........           BL       __aeabi_memset
   \   000000E0   00A0A0E3           MOV      R10,#+0
   \   000000E4   010056E3           CMP      R6,#+1
   \   000000E8   3C0000BA           BLT      ??FS_FAT_Make83Name_7
   \   000000EC   01B046E2           SUB      R11,R6,#+1
   \   000000F0   0000D9E5           LDRB     R0,[R9, #+0]
   \   000000F4   01001BE3           TST      R11,#0x1
   \   000000F8   0600000A           BEQ      ??FS_FAT_Make83Name_8
   \   000000FC   E50050E3           CMP      R0,#+229
   \   00000100   019089E2           ADD      R9,R9,#+1
   \   00000104   0500A003           MOVEQ    R0,#+5
   \   00000108   ........           BLNE     toupper
   \   0000010C   0100C8E4           STRB     R0,[R8], #+1
   \   00000110   01A0A0E3           MOV      R10,#+1
   \   00000114   0000D9E5           LDRB     R0,[R9, #+0]
   \                     ??FS_FAT_Make83Name_8:
   \   00000118   ABB0B0E1           LSRS     R11,R11,#+1
   \   0000011C   2800000A           BEQ      ??FS_FAT_Make83Name_9
   \                     ??FS_FAT_Make83Name_10:
   \   00000120   E50050E3           CMP      R0,#+229
   \   00000124   019089E2           ADD      R9,R9,#+1
   \   00000128   00005A03           CMPEQ    R10,#+0
   \   0000012C   0100000A           BEQ      ??FS_FAT_Make83Name_11
   \   00000130   ........           BL       toupper
   \   00000134   000000EA           B        ??FS_FAT_Make83Name_12
   \                     ??FS_FAT_Make83Name_11:
   \   00000138   0500A0E3           MOV      R0,#+5
   \                     ??FS_FAT_Make83Name_12:
   \   0000013C   0100C8E4           STRB     R0,[R8], #+1
   \   00000140   0100D9E4           LDRB     R0,[R9], #+1
   \   00000144   01A08AE2           ADD      R10,R10,#+1
   \   00000148   E50050E3           CMP      R0,#+229
   \   0000014C   00005A03           CMPEQ    R10,#+0
   \   00000150   1500000A           BEQ      ??FS_FAT_Make83Name_13
   \   00000154   ........           BL       toupper
   \   00000158   140000EA           B        ??FS_FAT_Make83Name_14
   \                     ??FS_FAT_Make83Name_15:
   \   0000015C   014047E2           SUB      R4,R7,#+1
   \   00000160   0000D5E5           LDRB     R0,[R5, #+0]
   \   00000164   010014E3           TST      R4,#0x1
   \   00000168   0200000A           BEQ      ??FS_FAT_Make83Name_16
   \   0000016C   ........           BL       toupper
   \   00000170   0100C6E4           STRB     R0,[R6], #+1
   \   00000174   0100F5E5           LDRB     R0,[R5, #+1]!
   \                     ??FS_FAT_Make83Name_16:
   \   00000178   A440B0E1           LSRS     R4,R4,#+1
   \   0000017C   0700000A           BEQ      ??FS_FAT_Make83Name_17
   \                     ??FS_FAT_Make83Name_18:
   \   00000180   ........           BL       toupper
   \   00000184   0100C6E4           STRB     R0,[R6], #+1
   \   00000188   0100F5E5           LDRB     R0,[R5, #+1]!
   \   0000018C   ........           BL       toupper
   \   00000190   0100C6E4           STRB     R0,[R6], #+1
   \   00000194   0100F5E5           LDRB     R0,[R5, #+1]!
   \   00000198   014054E2           SUBS     R4,R4,#+1
   \   0000019C   F7FFFF1A           BNE      ??FS_FAT_Make83Name_18
   \                     ??FS_FAT_Make83Name_17:
   \   000001A0   ........           BL       toupper
   \   000001A4   0000C6E5           STRB     R0,[R6, #+0]
   \   000001A8   A8FFFFEA           B        ??FS_FAT_Make83Name_1
   \                     ??FS_FAT_Make83Name_13:
   \   000001AC   0500A0E3           MOV      R0,#+5
   \                     ??FS_FAT_Make83Name_14:
   \   000001B0   0100C8E4           STRB     R0,[R8], #+1
   \   000001B4   01A08AE2           ADD      R10,R10,#+1
   \   000001B8   0000D9E5           LDRB     R0,[R9, #+0]
   \   000001BC   01B05BE2           SUBS     R11,R11,#+1
   \   000001C0   D6FFFF1A           BNE      ??FS_FAT_Make83Name_10
   \                     ??FS_FAT_Make83Name_9:
   \   000001C4   E50050E3           CMP      R0,#+229
   \   000001C8   00005A03           CMPEQ    R10,#+0
   \   000001CC   0100000A           BEQ      ??FS_FAT_Make83Name_19
   \   000001D0   ........           BL       toupper
   \   000001D4   000000EA           B        ??FS_FAT_Make83Name_20
   \                     ??FS_FAT_Make83Name_19:
   \   000001D8   0500A0E3           MOV      R0,#+5
   \                     ??FS_FAT_Make83Name_20:
   \   000001DC   0000C8E5           STRB     R0,[R8, #+0]
    418            _CopyDirText(&pOutName->ac[8], pOrgName + ExtPos + 1, 3, i - ExtPos - 1, 1);
   \                     ??FS_FAT_Make83Name_7:
   \   000001E0   050086E0           ADD      R0,R6,R5
   \   000001E4   015080E2           ADD      R5,R0,#+1
   \   000001E8   086084E2           ADD      R6,R4,#+8
   \   000001EC   017047E2           SUB      R7,R7,#+1
   \   000001F0   2020A0E3           MOV      R2,#+32
   \   000001F4   0310A0E3           MOV      R1,#+3
   \   000001F8   0600A0E1           MOV      R0,R6
   \   000001FC   ........           BL       __aeabi_memset
   \   00000200   010057E3           CMP      R7,#+1
   \   00000204   D4FFFFAA           BGE      ??FS_FAT_Make83Name_15
    419            return 0;                     /* O.K., file name successfully converted */
   \   00000208   90FFFFEA           B        ??FS_FAT_Make83Name_1
    420          }
    421          
    422          
    423          /*********************************************************************
    424          *
    425          *       FS_FAT_FindDirEntryShortEx
    426          *
    427          *  Description:
    428          *    Tries to locate the short directory entry in the specified directory
    429          *
    430          *  Return value:
    431          *    != NULL     - pointer to directory entry (in the smart buffer)
    432          *    NULL        - Entry not found
    433          */

   \                                 In section .text, align 4, keep-with-next
    434          FS_FAT_DENTRY * FS_FAT_FindDirEntryShortEx(FS_VOLUME * pVolume, FS_SB * pSB, const char *pEntryName, int Len, FS_DIR_POS * pDirPos, U8 AttributeReq) {
   \                     FS_FAT_FindDirEntryShortEx:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   \   00000008   10D04DE2           SUB      SP,SP,#+16
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0210A0E1           MOV      R1,R2
   \   00000014   0320A0E1           MOV      R2,R3
   \   00000018   28609DE5           LDR      R6,[SP, #+40]
   \   0000001C   2C70DDE5           LDRB     R7,[SP, #+44]
    435            FS_FAT_DENTRY       * pDirEntry;
    436            FS_83NAME             FATEntryName;
    437          
    438            if (FS_FAT_Make83Name(&FATEntryName, pEntryName, Len)) {
   \   00000020   0D00A0E1           MOV      R0,SP
   \   00000024   ........           BL       FS_FAT_Make83Name
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0400000A           BEQ      ??FS_FAT_FindDirEntryShortEx_0
    439              return NULL;  /* Entry name could not be converted */
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   190000EA           B        ??FS_FAT_FindDirEntryShortEx_1
    440            }
    441            /* Read directory */
    442            do {
    443              pDirEntry = FS_FAT_GetDirEntry(pVolume, pSB, pDirPos);
    444              if (!pDirEntry) {
    445                break;
    446              }
    447              if (pDirEntry->data[0] == 0) {
    448                pDirEntry = (FS_FAT_DENTRY*)NULL;
    449                break;  /* No more entries. Not found. */
    450              }
    451              if (FS_MEMCMP(pDirEntry->data, &FATEntryName, 11) == 0) { /* Name does match */
    452                U8 Attrib;
    453                //
    454                // Do the attribute match ?
    455                //
    456                Attrib = pDirEntry->data[DIR_ENTRY_OFF_ATTRIBUTES];
    457                if (((Attrib & AttributeReq) == AttributeReq) && (Attrib != FS_FAT_ATTR_VOLUME_ID)) {
    458                  break;
    459                }
    460              }
    461              FS_FAT_IncDirPos(pDirPos);
   \                     ??FS_FAT_FindDirEntryShortEx_2:
   \   00000038   080096E5           LDR      R0,[R6, #+8]
   \   0000003C   010080E2           ADD      R0,R0,#+1
   \   00000040   080086E5           STR      R0,[R6, #+8]
    462            } while (1);
   \                     ??FS_FAT_FindDirEntryShortEx_0:
   \   00000044   0620A0E1           MOV      R2,R6
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       FS_FAT_GetDirEntry
   \   00000054   0080B0E1           MOVS     R8,R0
   \   00000058   0F00000A           BEQ      ??FS_FAT_FindDirEntryShortEx_3
   \   0000005C   0000D8E5           LDRB     R0,[R8, #+0]
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0080A003           MOVEQ    R8,#+0
   \   00000068   0B00000A           BEQ      ??FS_FAT_FindDirEntryShortEx_3
   \   0000006C   0B20A0E3           MOV      R2,#+11
   \   00000070   0D10A0E1           MOV      R1,SP
   \   00000074   0800A0E1           MOV      R0,R8
   \   00000078   ........           BL       memcmp
   \   0000007C   000050E3           CMP      R0,#+0
   \   00000080   ECFFFF1A           BNE      ??FS_FAT_FindDirEntryShortEx_2
   \   00000084   0B00D8E5           LDRB     R0,[R8, #+11]
   \   00000088   002007E0           AND      R2,R7,R0
   \   0000008C   070052E1           CMP      R2,R7
   \   00000090   E8FFFF1A           BNE      ??FS_FAT_FindDirEntryShortEx_2
   \   00000094   080050E3           CMP      R0,#+8
   \   00000098   E6FFFF0A           BEQ      ??FS_FAT_FindDirEntryShortEx_2
    463            return pDirEntry;
   \                     ??FS_FAT_FindDirEntryShortEx_3:
   \   0000009C   0800A0E1           MOV      R0,R8
   \                     ??FS_FAT_FindDirEntryShortEx_1:
   \   000000A0   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   000000A4   F081BDE8           POP      {R4-R8,PC}       ;; return
    464          }
    465          
    466          /*********************************************************************
    467          *
    468          *       FS_FAT_FindDirEntryShort
    469          *
    470          *  Description:
    471          *    Tries to locate the short directory entry in the specified directory
    472          *
    473          *  Parameters:
    474          *    pVolume     - Volume information
    475          *    pEntryName  - Directory entry name
    476          *    MaxLen      - Maximum number of characters in EntryName (everything after that is ignored). E.g.: "Dir\File", 3: -> "Dir"
    477          *
    478          *  Return value:
    479          *    != NULL     - pointer to directory entry (in the smart buffer)
    480          *    NULL        - Entry not found
    481          */

   \                                 In section .text, align 4, keep-with-next
    482          FS_FAT_DENTRY * FS_FAT_FindDirEntryShort(FS_VOLUME * pVolume, FS_SB * pSB, const char *pEntryName, int Len, U32 DirStart, U8 AttributeReq) {
   \                     FS_FAT_FindDirEntryShort:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   \   00000008   0210A0E1           MOV      R1,R2
   \   0000000C   20D04DE2           SUB      SP,SP,#+32
   \   00000010   0040A0E1           MOV      R4,R0
   \   00000014   0320A0E1           MOV      R2,R3
    483            FS_DIR_POS            DirPos;
    484            FS_FAT_INFO         * pFATInfo;
    485          
    486            pFATInfo = &pVolume->FSInfo.FATInfo;
    487            FS_FAT_InitDirEntryScan(pFATInfo, &DirPos, DirStart);
   \   00000018   0070A0E3           MOV      R7,#+0
   \   0000001C   1C3084E2           ADD      R3,R4,#+28
   \   00000020   08708DE5           STR      R7,[SP, #+8]
   \   00000024   1EC0D3E5           LDRB     R12,[R3, #+30]
   \   00000028   38009DE5           LDR      R0,[SP, #+56]
   \   0000002C   3C60DDE5           LDRB     R6,[SP, #+60]
   \   00000030   20005CE3           CMP      R12,#+32
   \   00000034   00005003           CMPEQ    R0,#+0
   \   00000038   14009305           LDREQ    R0,[R3, #+20]
   \   0000003C   04008DE5           STR      R0,[SP, #+4]
   \   00000040   00008DE5           STR      R0,[SP, #+0]
    488            return FS_FAT_FindDirEntryShortEx(pVolume, pSB, pEntryName, Len, &DirPos, AttributeReq);
   \   00000044   10008DE2           ADD      R0,SP,#+16
   \   00000048   ........           BL       FS_FAT_Make83Name
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0F00000A           BEQ      ??FS_FAT_FindDirEntryShort_0
   \   00000054   190000EA           B        ??FS_FAT_FindDirEntryShort_1
   \                     ??FS_FAT_FindDirEntryShort_2:
   \   00000058   0B20A0E3           MOV      R2,#+11
   \   0000005C   10108DE2           ADD      R1,SP,#+16
   \   00000060   0800A0E1           MOV      R0,R8
   \   00000064   ........           BL       memcmp
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   0500001A           BNE      ??FS_FAT_FindDirEntryShort_3
   \   00000070   0B00D8E5           LDRB     R0,[R8, #+11]
   \   00000074   002006E0           AND      R2,R6,R0
   \   00000078   060052E1           CMP      R2,R6
   \   0000007C   0100001A           BNE      ??FS_FAT_FindDirEntryShort_3
   \   00000080   080050E3           CMP      R0,#+8
   \   00000084   0C00001A           BNE      ??FS_FAT_FindDirEntryShort_4
   \                     ??FS_FAT_FindDirEntryShort_3:
   \   00000088   08009DE5           LDR      R0,[SP, #+8]
   \   0000008C   010080E2           ADD      R0,R0,#+1
   \   00000090   08008DE5           STR      R0,[SP, #+8]
   \                     ??FS_FAT_FindDirEntryShort_0:
   \   00000094   0D20A0E1           MOV      R2,SP
   \   00000098   0510A0E1           MOV      R1,R5
   \   0000009C   0400A0E1           MOV      R0,R4
   \   000000A0   ........           BL       FS_FAT_GetDirEntry
   \   000000A4   0080B0E1           MOVS     R8,R0
   \   000000A8   0300000A           BEQ      ??FS_FAT_FindDirEntryShort_4
   \   000000AC   0000D8E5           LDRB     R0,[R8, #+0]
   \   000000B0   000050E3           CMP      R0,#+0
   \   000000B4   E7FFFF1A           BNE      ??FS_FAT_FindDirEntryShort_2
   \   000000B8   0080A0E3           MOV      R8,#+0
   \                     ??FS_FAT_FindDirEntryShort_4:
   \   000000BC   0870A0E1           MOV      R7,R8
   \                     ??FS_FAT_FindDirEntryShort_1:
   \   000000C0   0700A0E1           MOV      R0,R7
   \   000000C4   20D08DE2           ADD      SP,SP,#+32
   \   000000C8   F081BDE8           POP      {R4-R8,PC}       ;; return
    489          }
    490          
    491          /*********************************************************************
    492          *
    493          *       FS_FAT_FindPath
    494          *
    495          *  Description:
    496          *    FS internal function. Return start cluster and size of the directory
    497          *    of the file name in pFileName.
    498          *
    499          *  Parameters:
    500          *    pVolume     - Volume information
    501          *    pFullName   - Fully qualified file name w/o device name.
    502          *    ppFileName  - Pointer to a pointer, which is modified to point to the
    503          *                  file name part of pFullName.
    504          *    pDirStart   - Pointer to an U32 for returning the start cluster of the directory.
    505          *
    506          *  Return value:
    507          *    >0          - Path exists
    508          *    ==0         - An error has occurred.
    509          *
    510          *  Add. information
    511          *    The function opens the path of the highest level directory.
    512          *    subdir               -> Opens \
    513          *    subdir\              -> Opens \subdir\
    514          *    subdir\subdir1       -> Opens \subdir\
    515          *    subdir\subdir1\      -> Opens \subdir\subdir1\
    516          */

   \                                 In section .text, align 4, keep-with-next
    517          char FS_FAT_FindPath(FS_VOLUME * pVolume, FS_SB * pSB,  const char *pFullName, const char * *ppFileName, U32 *pDirStart) {
   \                     FS_FAT_FindPath:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0290A0E1           MOV      R9,R2
   \   00000014   0360A0E1           MOV      R6,R3
   \   00000018   30709DE5           LDR      R7,[SP, #+48]
    518            const char *        pDirNameStart;
    519            const char *        pDirNameStop;
    520            I32        i;
    521            U32        DirStart;
    522            FS_FAT_DENTRY * pDirEntry;
    523          
    524            *ppFileName = pFullName;
   \   0000001C   009086E5           STR      R9,[R6, #+0]
    525            // Setup pDirStart/dsize for root directory
    526            DirStart = 0;
   \   00000020   00A0A0E3           MOV      R10,#+0
    527            // descend into sub directory for every \ found
    528            pDirNameStart = pFullName;
    529            pDirNameStop  = FS__strchr(*ppFileName, FS_DIRECTORY_DELIMITER);
   \   00000024   5C10A0E3           MOV      R1,#+92
   \   00000028   0200A0E1           MOV      R0,R2
   \   0000002C   ........           BL       FS__strchr
   \   00000030   0080A0E1           MOV      R8,R0
    530            do {
    531              if (pDirNameStart == pDirNameStop) {
   \                     ??FS_FAT_FindPath_0:
   \   00000034   080059E1           CMP      R9,R8
   \   00000038   0500001A           BNE      ??FS_FAT_FindPath_1
    532                pDirNameStart++;
    533                *ppFileName  = pDirNameStart;
   \   0000003C   019089E2           ADD      R9,R9,#+1
   \   00000040   009086E5           STR      R9,[R6, #+0]
    534                pDirNameStop  = FS__strchr(*ppFileName, FS_DIRECTORY_DELIMITER);
   \   00000044   5C10A0E3           MOV      R1,#+92
   \   00000048   0900A0E1           MOV      R0,R9
   \   0000004C   ........           BL       FS__strchr
   \   00000050   0080A0E1           MOV      R8,R0
    535              }
    536              if (pDirNameStop) {
   \                     ??FS_FAT_FindPath_1:
   \   00000054   000058E3           CMP      R8,#+0
   \   00000058   1400000A           BEQ      ??FS_FAT_FindPath_2
    537                i = pDirNameStop-pDirNameStart;
   \   0000005C   093048E0           SUB      R3,R8,R9
    538                if (i > 0) {
   \   00000060   010053E3           CMP      R3,#+1
   \   00000064   110000BA           BLT      ??FS_FAT_FindPath_2
    539                  pDirEntry = FS_FAT_FindDirEntry(pVolume, pSB, pDirNameStart, i, DirStart, FS_FAT_ATTR_DIRECTORY, NULL);
   \   00000068   0000A0E3           MOV      R0,#+0
   \   0000006C   08008DE5           STR      R0,[SP, #+8]
   \   00000070   1000A0E3           MOV      R0,#+16
   \   00000074   04008DE5           STR      R0,[SP, #+4]
   \   00000078   00A08DE5           STR      R10,[SP, #+0]
   \   0000007C   0920A0E1           MOV      R2,R9
   \   00000080   0510A0E1           MOV      R1,R5
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   ........           BL       FS_FAT_FindDirEntry
   \   0000008C   0090B0E1           MOVS     R9,R0
    540                  if (pDirEntry == NULL) {
    541                    return 0;
   \   00000090   0000A003           MOVEQ    R0,#+0
   \   00000094   0D00000A           BEQ      ??FS_FAT_FindPath_3
    542                  } else {
    543                    DirStart = FS_FAT_GetFirstCluster(pDirEntry);
   \   00000098   1A0089E2           ADD      R0,R9,#+26
   \   0000009C   ........           BL       FS_LoadU16LE
   \   000000A0   00A0A0E1           MOV      R10,R0
   \   000000A4   140089E2           ADD      R0,R9,#+20
   \   000000A8   ........           BL       FS_LoadU16LE
   \   000000AC   00A88AE1           ORR      R10,R10,R0, LSL #+16
    544                  }
    545                }
    546              }
    547              pDirNameStart = pDirNameStop;
   \                     ??FS_FAT_FindPath_2:
   \   000000B0   0890A0E1           MOV      R9,R8
    548              pDirNameStop  = FS__strchr(*ppFileName, FS_DIRECTORY_DELIMITER);
   \   000000B4   5C10A0E3           MOV      R1,#+92
   \   000000B8   000096E5           LDR      R0,[R6, #+0]
   \   000000BC   ........           BL       FS__strchr
   \   000000C0   0080B0E1           MOVS     R8,R0
    549            } while (pDirNameStop);
   \   000000C4   DAFFFF1A           BNE      ??FS_FAT_FindPath_0
    550            *pDirStart = DirStart;
   \   000000C8   00A087E5           STR      R10,[R7, #+0]
    551            return 1;
   \   000000CC   0100A0E3           MOV      R0,#+1
   \                     ??FS_FAT_FindPath_3:
   \   000000D0   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   000000D4   F087BDE8           POP      {R4-R10,PC}      ;; return
    552          }
    553          
    554          
    555          /*********************************************************************
    556          *
    557          *       Public code 2
    558          *
    559          **********************************************************************
    560          
    561            These are real global functions, which are used by the API Layer
    562            of the file system.
    563          
    564          */
    565          
    566          /*********************************************************************
    567          *
    568          *       FS_FAT_FOpen
    569          *
    570          *  Description:
    571          *    FS internal function. Open an existing file or create a new one.
    572          *
    573          *  Parameters:
    574          *    pFileName   - File name.
    575          *    pMode       - Mode for opening the file.
    576          *    pFile       - Pointer to an FS_FILE data structure.
    577          *
    578          *  Return value:
    579          *    0         O.K.
    580          *    1         Error
    581          */

   \                                 In section .text, align 4, keep-with-next
    582          char FS_FAT_Open(const char * pFileName, FS_FILE * pFile, char DoDel, char DoOpen, char DoCreate) {
   \                     FS_FAT_Open:
   \   00000000   FE4F2DE9           PUSH     {R1-R11,LR}
   \   00000004   40D04DE2           SUB      SP,SP,#+64
   \   00000008   0050A0E1           MOV      R5,R0
    583            const char    * pFName;
    584            U32             DirStart;
    585            U8              AccessFlags;
    586            I32             DirEntryIndex;
    587            U32             DirEntrySector;
    588            U32             FirstCluster;
    589            U32             FileSize;
    590            char            r;
    591            FS_FILE_OBJ   * pFileObj;
    592            FS_VOLUME     * pVolume;
    593            FS_SB           SB;
    594            FS_FAT_DENTRY * pDirEntry;
    595            I32             LongDirEntryIndex = -1;
   \   0000000C   0010E0E3           MVN      R1,#+0
    596          
    597            //
    598            // Search directory
    599            //
    600            pFileObj       = pFile->pFileObj;
   \   00000010   40009DE5           LDR      R0,[SP, #+64]
   \   00000014   38108DE5           STR      R1,[SP, #+56]
   \   00000018   006090E5           LDR      R6,[R0, #+0]
    601            pVolume        = pFileObj->pVolume;
    602            DirEntryIndex  = 0;
    603            DirEntrySector = 0;
   \   0000001C   0040A0E3           MOV      R4,#+0
   \   00000020   087096E5           LDR      R7,[R6, #+8]
   \   00000024   70A0DDE5           LDRB     R10,[SP, #+112]
   \   00000028   0080A0E3           MOV      R8,#+0
   \   0000002C   0090A0E3           MOV      R9,#+0
    604            FirstCluster   = 0;
   \   00000030   34408DE5           STR      R4,[SP, #+52]
    605            FileSize       = 0;
   \   00000034   30408DE5           STR      R4,[SP, #+48]
    606            FS__SB_Create(&SB, &pVolume->Partition);
   \   00000038   0710A0E1           MOV      R1,R7
   \   0000003C   1C008DE2           ADD      R0,SP,#+28
   \   00000040   ........           BL       FS__SB_Create
    607            pDirEntry = NULL;
    608          
    609            if (FS_FAT_FindPath(pVolume, &SB, pFileName, &pFName, &DirStart) == 0) {
   \   00000044   14008DE2           ADD      R0,SP,#+20
   \   00000048   00008DE5           STR      R0,[SP, #+0]
   \   0000004C   18308DE2           ADD      R3,SP,#+24
   \   00000050   0520A0E1           MOV      R2,R5
   \   00000054   1C108DE2           ADD      R1,SP,#+28
   \   00000058   0700A0E1           MOV      R0,R7
   \   0000005C   ........           BL       FS_FAT_FindPath
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0300001A           BNE      ??FS_FAT_Open_0
    610              FS__SB_Delete(&SB);
   \                     ??FS_FAT_Open_1:
   \   00000068   1C008DE2           ADD      R0,SP,#+28
   \   0000006C   ........           BL       FS__SB_Delete
    611              return 1;  // Directory not found
   \   00000070   0100A0E3           MOV      R0,#+1
   \   00000074   AE0000EA           B        ??FS_FAT_Open_2
    612            }
    613            r = 0;       // No error so far
    614            AccessFlags = pFile->AccessFlags;
   \                     ??FS_FAT_Open_0:
   \   00000078   40109DE5           LDR      R1,[SP, #+64]
    615            pDirEntry = FS_FAT_FindDirEntry(pVolume, &SB, pFName, 0, DirStart, 0, &LongDirEntryIndex);
   \   0000007C   38008DE2           ADD      R0,SP,#+56
   \   00000080   0B10D1E5           LDRB     R1,[R1, #+11]
   \   00000084   08008DE5           STR      R0,[SP, #+8]
   \   00000088   14009DE5           LDR      R0,[SP, #+20]
   \   0000008C   2C108DE5           STR      R1,[SP, #+44]
   \   00000090   00008DE5           STR      R0,[SP, #+0]
   \   00000094   0050A0E3           MOV      R5,#+0
   \   00000098   04408DE5           STR      R4,[SP, #+4]
   \   0000009C   0030A0E3           MOV      R3,#+0
   \   000000A0   18209DE5           LDR      R2,[SP, #+24]
   \   000000A4   1C108DE2           ADD      R1,SP,#+28
   \   000000A8   0700A0E1           MOV      R0,R7
   \   000000AC   ........           BL       FS_FAT_FindDirEntry
   \   000000B0   00B0B0E1           MOVS     R11,R0
    616            if (pDirEntry) {
   \   000000B4   0600000A           BEQ      ??FS_FAT_Open_3
    617              U8 Attrib;
    618              //
    619              // Check if the directory entry is not a directory
    620              //
    621              Attrib = pDirEntry->data[DIR_ENTRY_OFF_ATTRIBUTES];
    622              if ((Attrib & FS_FAT_ATTR_DIRECTORY) != FS_FAT_ATTR_DIRECTORY) {
   \   000000B8   0B00DBE5           LDRB     R0,[R11, #+11]
   \   000000BC   100010E3           TST      R0,#0x10
   \   000000C0   E8FFFF1A           BNE      ??FS_FAT_Open_1
    623                DirEntryIndex = pDirEntry - (FS_FAT_DENTRY *)SB.pBuffer;
   \   000000C4   24009DE5           LDR      R0,[SP, #+36]
    624                DirEntrySector = SB.SectorNo;
   \   000000C8   1C909DE5           LDR      R9,[SP, #+28]
   \   000000CC   00004BE0           SUB      R0,R11,R0
   \   000000D0   C082A0E1           ASR      R8,R0,#+5
    625              } else {
    626                FS__SB_Delete(&SB);
    627                return 1;  // Specified file name is a directory
    628              }
    629            }
    630            //
    631            // Delete the file if requested
    632            //
    633            if (DoDel) {              // Do we need to delete the file ?
   \                     ??FS_FAT_Open_3:
   \   000000D4   4400DDE5           LDRB     R0,[SP, #+68]
   \   000000D8   000050E3           CMP      R0,#+0
   \   000000DC   4500000A           BEQ      ??FS_FAT_Open_4
    634              if (pDirEntry) {        // Does file exist ?
   \   000000E0   00005BE3           CMP      R11,#+0
   \   000000E4   4000000A           BEQ      ??FS_FAT_Open_5
    635                FS_FILE * pFile2Check;
    636                pFile2Check = FS_Global.pFirstFilehandle;
   \   000000E8   ........           LDR      R0,??DataTable2
   \   000000EC   140090E5           LDR      R0,[R0, #+20]
   \   000000F0   000000EA           B        ??FS_FAT_Open_6
    637                while (pFile2Check) {
    638                  FS_INT_DATA_FAT * pData;
    639                  
    640                  if (pFile2Check->pFileObj && pFile2Check->InUse) {
    641                    pData = &pFile2Check->pFileObj->Data.Fat;
    642                    if ((pData->DirEntryIndex == DirEntryIndex) && (pData->DirEntrySector == DirEntrySector) && (pFile2Check->pFileObj->pVolume == pVolume)){
    643                      pFile->Error = FS_ERR_FILE_ALREADY_OPENED;
    644                      goto OnError;
    645                    }
    646                  }
    647                  pFile2Check = pFile2Check->pNext;
   \                     ??FS_FAT_Open_7:
   \   000000F4   0C0090E5           LDR      R0,[R0, #+12]
   \                     ??FS_FAT_Open_6:
   \   000000F8   000050E3           CMP      R0,#+0
   \   000000FC   1000000A           BEQ      ??FS_FAT_Open_8
   \   00000100   001090E5           LDR      R1,[R0, #+0]
   \   00000104   000051E3           CMP      R1,#+0
   \   00000108   0A20D015           LDRBNE   R2,[R0, #+10]
   \   0000010C   00005213           CMPNE    R2,#+0
   \   00000110   F7FFFF0A           BEQ      ??FS_FAT_Open_7
   \   00000114   102081E2           ADD      R2,R1,#+16
   \   00000118   BC30D2E1           LDRH     R3,[R2, #+12]
   \   0000011C   080053E1           CMP      R3,R8
   \   00000120   08209205           LDREQ    R2,[R2, #+8]
   \   00000124   09005201           CMPEQ    R2,R9
   \   00000128   08109105           LDREQ    R1,[R1, #+8]
   \   0000012C   07005101           CMPEQ    R1,R7
   \   00000130   EFFFFF1A           BNE      ??FS_FAT_Open_7
   \   00000134   40009DE5           LDR      R0,[SP, #+64]
   \   00000138   0810E0E3           MVN      R1,#+8
   \                     ??FS_FAT_Open_9:
   \   0000013C   B810C0E1           STRH     R1,[R0, #+8]
   \   00000140   770000EA           B        ??FS_FAT_Open_10
    648                }
    649                if (FS_FAT_DeleteFileOrDir(pVolume, &SB, pDirEntry, 1) != 0) {
   \                     ??FS_FAT_Open_8:
   \   00000144   1C1087E2           ADD      R1,R7,#+28
   \   00000148   00108DE5           STR      R1,[SP, #+0]
   \   0000014C   E500A0E3           MOV      R0,#+229
   \   00000150   0000CBE5           STRB     R0,[R11, #+0]
   \   00000154   1C008DE2           ADD      R0,SP,#+28
   \   00000158   ........           BL       FS__SB_MarkDirty
   \   0000015C   1C008BE2           ADD      R0,R11,#+28
   \   00000160   ........           BL       FS_LoadU32LE
   \   00000164   00109DE5           LDR      R1,[SP, #+0]
   \   00000168   0C1091E5           LDR      R1,[R1, #+12]
   \   0000016C   000081E0           ADD      R0,R1,R0
   \   00000170   010040E2           SUB      R0,R0,#+1
   \   00000174   ........           BL       __aeabi_uidiv
   \   00000178   04008DE5           STR      R0,[SP, #+4]
   \   0000017C   1A008BE2           ADD      R0,R11,#+26
   \   00000180   ........           BL       FS_LoadU16LE
   \   00000184   B000CDE1           STRH     R0,[SP, #+0]
   \   00000188   14008BE2           ADD      R0,R11,#+20
   \   0000018C   ........           BL       FS_LoadU16LE
   \   00000190   B010DDE1           LDRH     R1,[SP, #+0]
   \   00000194   04309DE5           LDR      R3,[SP, #+4]
   \   00000198   002881E1           ORR      R2,R1,R0, LSL #+16
   \   0000019C   1C108DE2           ADD      R1,SP,#+28
   \   000001A0   0700A0E1           MOV      R0,R7
   \   000001A4   ........           BL       FS_FAT_FreeClusterChain
   \   000001A8   2900DDE5           LDRB     R0,[SP, #+41]
   \   000001AC   000050E3           CMP      R0,#+0
    650                  pFile->Error = -1;
   \   000001B0   40009D15           LDRNE    R0,[SP, #+64]
   \   000001B4   0410E011           MVNNE    R1,R4
   \   000001B8   DFFFFF1A           BNE      ??FS_FAT_Open_9
   \   000001BC   ........           LDR      R0,??DataTable2_1
   \   000001C0   000090E5           LDR      R0,[R0, #+0]
   \   000001C4   0CC090E5           LDR      R12,[R0, #+12]
   \   000001C8   00005CE3           CMP      R12,#+0
   \   000001CC   0400000A           BEQ      ??FS_FAT_Open_11
    651                  goto OnError;
    652                } else {
    653                  if (FAT_pDirEntryAPI->pfDelLongEntry) {
    654                    FAT_pDirEntryAPI->pfDelLongEntry(pVolume, &SB, DirStart, LongDirEntryIndex);
   \   000001D0   38309DE5           LDR      R3,[SP, #+56]
   \   000001D4   14209DE5           LDR      R2,[SP, #+20]
   \   000001D8   1C108DE2           ADD      R1,SP,#+28
   \   000001DC   0700A0E1           MOV      R0,R7
   \   000001E0   3CFF2FE1           BLX      R12
    655                  }
    656                }
    657                pDirEntry = NULL;          // File does not exist any more
   \                     ??FS_FAT_Open_11:
   \   000001E4   00B0A0E3           MOV      R11,#+0
   \   000001E8   020000EA           B        ??FS_FAT_Open_4
    658              } else {
    659                if ((DoOpen | DoCreate) == 0) {
   \                     ??FS_FAT_Open_5:
   \   000001EC   4800DDE5           LDRB     R0,[SP, #+72]
   \   000001F0   00009AE1           ORRS     R0,R10,R0
    660                  r = 1;                   // This is an error unless some other command is executed
   \   000001F4   0150A003           MOVEQ    R5,#+1
    661                }
    662              }
    663            }
    664            //
    665            // Open file if requested
    666            //
    667            if (DoOpen) {
   \                     ??FS_FAT_Open_4:
   \   000001F8   4800DDE5           LDRB     R0,[SP, #+72]
   \   000001FC   000050E3           CMP      R0,#+0
   \   00000200   1800000A           BEQ      ??FS_FAT_Open_12
    668              if (pDirEntry) {       // Does file exist ?
   \   00000204   00005BE3           CMP      R11,#+0
   \   00000208   1400000A           BEQ      ??FS_FAT_Open_13
    669                //
    670                // Check read only
    671                //
    672                if ((((pDirEntry->data[DIR_ENTRY_OFF_ATTRIBUTES] & FS_FAT_ATTR_READ_ONLY) != 0)) &&
    673                         (AccessFlags & (FS_FILE_ACCESS_FLAG_W | FS_FILE_ACCESS_FLAG_A | FS_FILE_ACCESS_FLAG_C)))
   \   0000020C   0B00DBE5           LDRB     R0,[R11, #+11]
   \   00000210   010010E3           TST      R0,#0x1
   \   00000214   2C009D15           LDRNE    R0,[SP, #+44]
   \   00000218   15001013           TSTNE    R0,#0x15
   \   0000021C   0400000A           BEQ      ??FS_FAT_Open_14
    674                {
    675                  // Files is RO and we try to create, write or append
    676                  pFile->Error = FS_ERR_READONLY;
   \   00000220   40009DE5           LDR      R0,[SP, #+64]
   \   00000224   0510E0E3           MVN      R1,#+5
    677                  if (DoCreate == 0) {
   \   00000228   00005AE3           CMP      R10,#+0
   \   0000022C   B810C0E1           STRH     R1,[R0, #+8]
    678                    r = 1;                       // This is an error unless some other command is executed
   \   00000230   0150A003           MOVEQ    R5,#+1
    679                  }
    680                }
    681                FirstCluster = FS_FAT_GetFirstCluster(pDirEntry);
   \                     ??FS_FAT_Open_14:
   \   00000234   1A008BE2           ADD      R0,R11,#+26
   \   00000238   ........           BL       FS_LoadU16LE
   \   0000023C   0070A0E1           MOV      R7,R0
   \   00000240   14008BE2           ADD      R0,R11,#+20
   \   00000244   ........           BL       FS_LoadU16LE
   \   00000248   000887E1           ORR      R0,R7,R0, LSL #+16
   \   0000024C   34008DE5           STR      R0,[SP, #+52]
    682                FileSize     = FS_LoadU32LE(&pDirEntry->data[DIR_ENTRY_OFF_SIZE]);
   \   00000250   1C008BE2           ADD      R0,R11,#+28
   \   00000254   ........           BL       FS_LoadU32LE
   \   00000258   30008DE5           STR      R0,[SP, #+48]
    683                DoCreate = 0;      // Do not create, since it could be opened
   \   0000025C   1F0000EA           B        ??FS_FAT_Open_15
    684              } else {
    685                if (DoCreate == 0) {
   \                     ??FS_FAT_Open_13:
   \   00000260   00005AE3           CMP      R10,#+0
   \   00000264   1C00000A           BEQ      ??FS_FAT_Open_16
    686                  r = 1;                       // This is an error unless some other command is executed
    687                }
    688              }
    689            }
    690            //
    691            // Do we need to create the file ?
    692            //
    693            if (DoCreate == 1 ) {
   \                     ??FS_FAT_Open_12:
   \   00000268   01005AE3           CMP      R10,#+1
   \   0000026C   1B00001A           BNE      ??FS_FAT_Open_15
    694              if (pDirEntry == (FS_FAT_DENTRY *)NULL) {
   \   00000270   00005BE3           CMP      R11,#+0
   \   00000274   1800001A           BNE      ??FS_FAT_Open_16
    695                U32 TimeDate;
    696          
    697                TimeDate = FS_X_GetTimeDate();
   \   00000278   ........           BL       FS_X_GetTimeDate
    698                //
    699                // Create new file
    700                //
    701                pDirEntry = FAT_pDirEntryAPI->pfCreateDirEntry(pVolume, &SB, pFName, DirStart, 0, FS_FAT_ATTR_ARCHIVE, 0, (U16)(TimeDate & 0xffff), (U16)(TimeDate >> 16));
   \   0000027C   2018A0E1           LSR      R1,R0,#+16
   \   00000280   0008A0E1           LSL      R0,R0,#+16
   \   00000284   2008A0E1           LSR      R0,R0,#+16
   \   00000288   ........           LDR      R12,??DataTable2_1
   \   0000028C   0C008DE5           STR      R0,[SP, #+12]
   \   00000290   2000A0E3           MOV      R0,#+32
   \   00000294   00C09CE5           LDR      R12,[R12, #+0]
   \   00000298   10108DE5           STR      R1,[SP, #+16]
   \   0000029C   08408DE5           STR      R4,[SP, #+8]
   \   000002A0   04008DE5           STR      R0,[SP, #+4]
   \   000002A4   00408DE5           STR      R4,[SP, #+0]
   \   000002A8   14309DE5           LDR      R3,[SP, #+20]
   \   000002AC   18209DE5           LDR      R2,[SP, #+24]
   \   000002B0   1C108DE2           ADD      R1,SP,#+28
   \   000002B4   0700A0E1           MOV      R0,R7
   \   000002B8   08C09CE5           LDR      R12,[R12, #+8]
   \   000002BC   3CFF2FE1           BLX      R12
   \   000002C0   00B0B0E1           MOVS     R11,R0
    702                if (pDirEntry) {
   \   000002C4   0400000A           BEQ      ??FS_FAT_Open_16
    703                  /* Free entry found. */
    704                  DirEntryIndex = pDirEntry - (FS_FAT_DENTRY*)SB.pBuffer;
   \   000002C8   24009DE5           LDR      R0,[SP, #+36]
    705                  DirEntrySector = SB.SectorNo;
   \   000002CC   1C909DE5           LDR      R9,[SP, #+28]
   \   000002D0   00004BE0           SUB      R0,R11,R0
   \   000002D4   C082A0E1           ASR      R8,R0,#+5
   \   000002D8   000000EA           B        ??FS_FAT_Open_15
    706                } else {
    707                  r = 1;                       // Error, could not create file
   \                     ??FS_FAT_Open_16:
   \   000002DC   0150A0E3           MOV      R5,#+1
    708                }
    709                FileSize = 0;
    710                FirstCluster = 0;
    711              } else {
    712                r = 1;                        // Error, file already exists, we can recreate am additional directory entry
    713              }
    714            }
    715            pFileObj->Data.Fat.DirEntrySector = DirEntrySector;
   \                     ??FS_FAT_Open_15:
   \   000002E0   189086E5           STR      R9,[R6, #+24]
    716            pFileObj->Data.Fat.DirEntryIndex  = (U16)DirEntryIndex;
   \   000002E4   BC81C6E1           STRH     R8,[R6, #+28]
    717            pFileObj->Data.Fat.CurClusterFile = 0xFFFFFFFF;   // Invalidate
   \   000002E8   0400E0E1           MVN      R0,R4
   \   000002EC   100086E5           STR      R0,[R6, #+16]
    718            pFileObj->FirstCluster            = FirstCluster;
   \   000002F0   34009DE5           LDR      R0,[SP, #+52]
   \   000002F4   000086E5           STR      R0,[R6, #+0]
    719            pFileObj->Size                    = FileSize;
   \   000002F8   30009DE5           LDR      R0,[SP, #+48]
   \   000002FC   040086E5           STR      R0,[R6, #+4]
    720            pFile->FilePos                    = (AccessFlags & FS_FILE_ACCESS_FLAG_A) ? pFileObj->Size : 0;
   \   00000300   2C009DE5           LDR      R0,[SP, #+44]
   \   00000304   010010E3           TST      R0,#0x1
   \   00000308   04409615           LDRNE    R4,[R6, #+4]
   \   0000030C   40009DE5           LDR      R0,[SP, #+64]
   \   00000310   044080E5           STR      R4,[R0, #+4]
    721          OnError:
    722            if (pFile->Error < 0) {
   \   00000314   40009DE5           LDR      R0,[SP, #+64]
   \   00000318   F800D0E1           LDRSH    R0,[R0, #+8]
   \   0000031C   000050E3           CMP      R0,#+0
   \   00000320   0000005A           BPL      ??FS_FAT_Open_17
    723              r = 1;
   \                     ??FS_FAT_Open_10:
   \   00000324   0150A0E3           MOV      R5,#+1
    724            }
    725            FS__SB_Delete(&SB);
   \                     ??FS_FAT_Open_17:
   \   00000328   1C008DE2           ADD      R0,SP,#+28
   \   0000032C   ........           BL       FS__SB_Delete
    726            return r;
   \   00000330   0500A0E1           MOV      R0,R5
   \                     ??FS_FAT_Open_2:
   \   00000334   4CD08DE2           ADD      SP,SP,#+76       ;; stack cleaning
   \   00000338   F08FBDE8           POP      {R4-R11,PC}      ;; return
    727          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   2E2E0000           DC8      0x2E, 0x2E, 0x00, 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     FS_Global

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   ........           DC32     FAT_pDirEntryAPI

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "..">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   2E2E0000           DC8 46, 46, 0, 0
    728          
    729          /*************************** End of file ****************************/
    730          

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     FS_FAT_DeleteFileOrDir          24
     FS_FAT_FindDirEntryShort        56
     FS_FAT_FindDirEntryShortEx      40
     FS_FAT_FindEmptyDirEntry        40
     FS_FAT_FindPath                 48
     FS_FAT_GetDirEntry              48
     FS_FAT_GetFirstCluster          16
     FS_FAT_IncDirPos                 0
     FS_FAT_InitDirEntryScan          0
     FS_FAT_Make83Name               40
     FS_FAT_Open                    112
     FS_FAT_WriteDirEntry83          32
     FS_FAT_WriteDirEntryCluster     16
     FS_FAT_WriteDirEntryShort       40


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     FS_FAT_WriteDirEntry83       152
     FS_FAT_WriteDirEntryShort    172
     FS_FAT_WriteDirEntryCluster   52
     FS_FAT_GetFirstCluster        44
     FS_FAT_InitDirEntryScan       36
     FS_FAT_GetDirEntry           264
     FS_FAT_IncDirPos              16
     FS_FAT_FindEmptyDirEntry     288
     FS_FAT_DeleteFileOrDir       140
     FS_FAT_Make83Name            524
     FS_FAT_FindDirEntryShortEx   168
     FS_FAT_FindDirEntryShort     204
     FS_FAT_FindPath              216
     FS_FAT_Open                  828
     ??DataTable1                   4
     ??DataTable2                   4
     ??DataTable2_1                 4
     ?<Constant "..">               4

 
     4 bytes in section .rodata
 3 116 bytes in section .text
 
 3 116 bytes of CODE  memory
     4 bytes of CONST memory

Errors: none
Warnings: none
