###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     14/Jul/2015  19:00:09 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\FS\FAT_Write.c                          #
#    Command line =  C:\DUII\TargetHW\FS\FAT_Write.c -D DEBUG=1 -D            #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D                   #
#                    XIGNORE_TEMPERATURE -D BUILD_DEBUG_PORT -D PROFILER      #
#                    -lCN C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Li #
#                    st\ -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\ #
#                    Obj\ --debug --endian=little --cpu=ARM926EJ-S -e         #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\FA #
#                    T_Write.lst                                              #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\FAT #
#                    _Write.o                                                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\FS\FAT_Write.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 2003-2010     SEGGER Microcontroller GmbH & Co KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          **** emFile file system for embedded applications ****
     13          emFile is protected by international copyright laws. Knowledge of the
     14          source code may not be used to write a similar product. This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : FAT_Write.c
     19          Purpose     : FAT filesystem file write routines
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          /*********************************************************************
     24          *
     25          *       #include Section
     26          *
     27          **********************************************************************
     28          */
     29          
     30          #include "FAT_Intern.h"
     31          
     32          /*********************************************************************
     33          *
     34          *       Data structures
     35          *
     36          **********************************************************************
     37          */
     38          typedef struct {
     39            U32          FirstSector;
     40            U32          NumSectors;
     41            FS_SB      * pSBData;
     42            const void * pData;
     43          } BURST_INFO_W;
     44          
     45          /*********************************************************************
     46          *
     47          *       Static code
     48          *
     49          **********************************************************************
     50          */
     51          
     52          /*********************************************************************
     53          *
     54          *       _WriteBurst
     55          *
     56          */
     57          static int _WriteBurst(BURST_INFO_W * pBurstInfo) {
     58            if (pBurstInfo->NumSectors) {
     59              if (FS_LB_WriteBurstPart(pBurstInfo->pSBData->pPart,
     60                                       pBurstInfo->FirstSector,
     61                                       pBurstInfo->NumSectors,
     62                                       pBurstInfo->pData, FS_SECTOR_TYPE_DATA))
     63              {
     64                FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_WriteBurst (FAT): Burst write error.\n"));
     65                return 1;     // Write error
     66              }
     67            }
     68            return 0;         // No problem !
     69          }
     70          
     71          /*********************************************************************
     72          *
     73          *       _WriteData
     74          *
     75          *  Return value
     76          *    Number of bytes written
     77          */

   \                                 In section .text, align 4, keep-with-next
     78          static U32 _WriteData(const U8 * pData, U32 NumBytes2Write, FS_FILE *pFile, FS_SB * pSBData, FS_SB * pSBfat) {
   \                     _WriteData:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   \   00000008   24D04DE2           SUB      SP,SP,#+36
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   0810CDE5           STRB     R1,[SP, #+8]
     79            U32           NumBytesWritten;
     80            U32           NumBytesCluster;
     81            U32           BytesPerCluster;
     82            int           SectorOff;
     83            U32           SectorNo;
     84            FS_FILE_OBJ * pFileObj;
     85            FS_FAT_INFO * pFATInfo;
     86            char          DirUpdateRequired;
     87            char          ZeroCopyAllowed;
     88            U32           LastByteInCluster;
     89            BURST_INFO_W  BurstInfo;
     90          #if FS_USE_FILE_BUFFER
     91            FS_FILE_BUFFER * pFileBuffer;
     92          #endif
     93            //
     94            // Init / Compute some values used throughout the routine
     95            //
     96            DirUpdateRequired     = 0;
     97            pFileObj              = pFile->pFileObj;
   \   00000018   001096E5           LDR      R1,[R6, #+0]
   \   0000001C   0040A0E1           MOV      R4,R0
   \   00000020   04108DE5           STR      R1,[SP, #+4]
     98            pFATInfo              = &pFileObj->pVolume->FSInfo.FATInfo;
   \   00000024   080091E5           LDR      R0,[R1, #+8]
     99            BytesPerCluster       = pFATInfo->BytesPerCluster;
    100            NumBytesWritten       = 0;
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   1C0080E2           ADD      R0,R0,#+28
   \   00000030   10008DE5           STR      R0,[SP, #+16]
   \   00000034   0C0090E5           LDR      R0,[R0, #+12]
   \   00000038   0C108DE5           STR      R1,[SP, #+12]
    101            BurstInfo.NumSectors  = 0;
    102            BurstInfo.FirstSector = 0xFFFFFFFFUL;
   \   0000003C   0110E0E1           MVN      R1,R1
   \   00000040   0370A0E1           MOV      R7,R3
   \   00000044   20008DE5           STR      R0,[SP, #+32]
   \   00000048   0080A0E3           MOV      R8,#+0
   \   0000004C   18108DE5           STR      R1,[SP, #+24]
    103            BurstInfo.pSBData     = pSBData;
    104            ZeroCopyAllowed = 1;
    105          #if FS_SUPPORT_CHECK_MEMORY
    106            {
    107              FS_MEMORY_IS_ACCESSIBLE_CALLBACK * pfMemoryIsAccessible;
    108          
    109              pfMemoryIsAccessible = pFileObj->pVolume->Partition.Device.Data.pfMemoryIsAccessible;
    110              if (pfMemoryIsAccessible) {
    111                if (pfMemoryIsAccessible((void *)pData, NumBytes2Write) == 0) {
    112                  ZeroCopyAllowed = 0;
    113                }
    114              }
    115            }
    116          #endif
    117            //
    118            // Main loop
    119            // We determine the cluster (allocate as necessary using the FAT buffer)
    120            // and write data into the cluster
    121            //
    122            do {
    123              //
    124              // Locate current cluster.
    125              //
    126              if (FS_FAT_GotoClusterAllocIfReq(pFile, pSBfat)) {
   \                     ??_WriteData_0:
   \   00000050   48109DE5           LDR      R1,[SP, #+72]
   \   00000054   0600A0E1           MOV      R0,R6
   \   00000058   ........           BL       FS_FAT_GotoClusterAllocIfReq
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   3200000A           BEQ      ??_WriteData_1
    127                FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_WriteData: Could not alloc cluster to file.\n"));
    128                if (_WriteBurst(&BurstInfo)) {
   \   00000064   000058E3           CMP      R8,#+0
   \   00000068   0900000A           BEQ      ??_WriteData_2
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   00008DE5           STR      R0,[SP, #+0]
   \   00000074   1C309DE5           LDR      R3,[SP, #+28]
   \   00000078   0820A0E1           MOV      R2,R8
   \   0000007C   18109DE5           LDR      R1,[SP, #+24]
   \   00000080   040097E5           LDR      R0,[R7, #+4]
   \   00000084   ........           BL       FS_LB_WriteBurstPart
   \   00000088   000050E3           CMP      R0,#+0
    129                  NumBytesWritten = 0;               /* We do not know how many bytes have been written o.k., so reporting 0 is on the safe side */
   \   0000008C   0010A013           MOVNE    R1,#+0
   \   00000090   0C108D15           STRNE    R1,[SP, #+12]
    130                }
    131                FS_FAT_UpdateDirEntry(pFileObj, pSBData);
   \                     ??_WriteData_2:
   \   00000094   04009DE5           LDR      R0,[SP, #+4]
   \   00000098   0120A0E3           MOV      R2,#+1
   \   0000009C   080090E5           LDR      R0,[R0, #+8]
   \   000000A0   B042D0E1           LDRH     R4,[R0, #+32]
   \   000000A4   04009DE5           LDR      R0,[SP, #+4]
   \   000000A8   181090E5           LDR      R1,[R0, #+24]
   \   000000AC   0700A0E1           MOV      R0,R7
   \   000000B0   ........           BL       FS__SB_SetSector
   \   000000B4   04009DE5           LDR      R0,[SP, #+4]
   \   000000B8   011044E2           SUB      R1,R4,#+1
   \   000000BC   BC01D0E1           LDRH     R0,[R0, #+28]
   \   000000C0   800201E0           AND      R0,R1,R0, LSL #+5
   \   000000C4   081097E5           LDR      R1,[R7, #+8]
   \   000000C8   0008A0E1           LSL      R0,R0,#+16
   \   000000CC   204881E0           ADD      R4,R1,R0, LSR #+16
   \   000000D0   0700A0E1           MOV      R0,R7
   \   000000D4   ........           BL       FS__SB_Read
   \   000000D8   000050E3           CMP      R0,#+0
   \   000000DC   8D00001A           BNE      ??_WriteData_3
   \   000000E0   04009DE5           LDR      R0,[SP, #+4]
   \   000000E4   041090E5           LDR      R1,[R0, #+4]
   \   000000E8   1C0084E2           ADD      R0,R4,#+28
   \   000000EC   ........           BL       FS_StoreU32LE
   \   000000F0   04009DE5           LDR      R0,[SP, #+4]
   \   000000F4   001090E5           LDR      R1,[R0, #+0]
   \   000000F8   0400A0E1           MOV      R0,R4
   \   000000FC   ........           BL       FS_FAT_WriteDirEntryCluster
   \   00000100   ........           BL       FS_X_GetTimeDate
   \   00000104   0050A0E1           MOV      R5,R0
   \   00000108   0518A0E1           LSL      R1,R5,#+16
   \   0000010C   2118A0E1           LSR      R1,R1,#+16
   \   00000110   160084E2           ADD      R0,R4,#+22
   \   00000114   ........           BL       FS_StoreU16LE
   \   00000118   2518A0E1           LSR      R1,R5,#+16
   \   0000011C   180084E2           ADD      R0,R4,#+24
   \   00000120   ........           BL       FS_StoreU16LE
   \   00000124   0700A0E1           MOV      R0,R7
   \   00000128   ........           BL       FS__SB_Flush
   \   0000012C   790000EA           B        ??_WriteData_3
    132                return NumBytesWritten;           /* File truncated (too few clusters) */
    133              }
    134              LastByteInCluster = BytesPerCluster * (pFileObj->Data.Fat.CurClusterFile + 1);
    135              NumBytesCluster   = LastByteInCluster - pFile->FilePos;
   \                     ??_WriteData_1:
   \   00000130   04209DE5           LDR      R2,[SP, #+4]
   \   00000134   20109DE5           LDR      R1,[SP, #+32]
   \   00000138   102092E5           LDR      R2,[R2, #+16]
   \   0000013C   040096E5           LDR      R0,[R6, #+4]
   \   00000140   012082E2           ADD      R2,R2,#+1
   \   00000144   920101E0           MUL      R1,R2,R1
    136              SectorOff         = pFile->FilePos & (pFATInfo->BytesPerSec - 1);
   \   00000148   10209DE5           LDR      R2,[SP, #+16]
   \   0000014C   001041E0           SUB      R1,R1,R0
   \   00000150   B420D2E1           LDRH     R2,[R2, #+4]
    137              if (NumBytesCluster > NumBytes2Write) {
   \   00000154   010055E1           CMP      R5,R1
   \   00000158   012042E2           SUB      R2,R2,#+1
   \   0000015C   000002E0           AND      R0,R2,R0
   \   00000160   00008DE5           STR      R0,[SP, #+0]
   \   00000164   0500A0E1           MOV      R0,R5
   \   00000168   0100A081           MOVHI    R0,R1
   \   0000016C   14008DE5           STR      R0,[SP, #+20]
    138                NumBytesCluster = NumBytes2Write;
    139              }
    140              SectorNo  = FS_FAT_ClusterId2SectorNo(pFATInfo, pFileObj->Data.Fat.CurClusterAbs);
   \   00000170   04009DE5           LDR      R0,[SP, #+4]
   \   00000174   141090E5           LDR      R1,[R0, #+20]
   \   00000178   10009DE5           LDR      R0,[SP, #+16]
   \   0000017C   ........           BL       FS_FAT_ClusterId2SectorNo
    141              SectorNo += (pFile->FilePos / pFATInfo->BytesPerSec) & (pFATInfo->SecPerClus -1);
   \   00000180   10109DE5           LDR      R1,[SP, #+16]
   \   00000184   0090A0E1           MOV      R9,R0
   \   00000188   040096E5           LDR      R0,[R6, #+4]
   \   0000018C   B410D1E1           LDRH     R1,[R1, #+4]
   \   00000190   ........           BL       __aeabi_uidiv
   \   00000194   10109DE5           LDR      R1,[SP, #+16]
   \   00000198   1C10D1E5           LDRB     R1,[R1, #+28]
   \   0000019C   011041E2           SUB      R1,R1,#+1
   \   000001A0   000001E0           AND      R0,R1,R0
   \   000001A4   099080E0           ADD      R9,R0,R9
    142              //
    143              // If the file buffer has been filled by previous calls of _WriteData
    144              // we have a special case here:
    145              // Example: 2 previous calls of _WriteData filled the file buffer and it holds data for a complete sector.
    146              // In this case we can not follow our standard procedure: "Write content of file buffer into smart buffer and append user data"
    147              // since the smart buffer can only hold data for 1 sector.
    148              // Moreover, the user data which shall be written now, shall be written to another sector
    149              // Let us simply clean the write buffer, if the current sector and the sector the file buffer shall be written to, differs.
    150              //
    151          #if FS_USE_FILE_BUFFER
    152              if (pFileObj->pBuffer) {
   \   000001A8   04009DE5           LDR      R0,[SP, #+4]
   \   000001AC   240090E5           LDR      R0,[R0, #+36]
   \   000001B0   000050E3           CMP      R0,#+0
    153                if (SectorNo != pFileObj->pBuffer->SectorNo) {
   \   000001B4   08009015           LDRNE    R0,[R0, #+8]
   \   000001B8   00005911           CMPNE    R9,R0
   \   000001BC   0400000A           BEQ      ??_WriteData_4
    154                  FS_FAT_CleanWriteBuffer(pFile, NULL, 0, pSBData);
   \   000001C0   0730A0E1           MOV      R3,R7
   \   000001C4   0020A0E3           MOV      R2,#+0
   \   000001C8   0010A0E3           MOV      R1,#+0
   \   000001CC   0600A0E1           MOV      R0,R6
   \   000001D0   ........           BL       FS_FAT_CleanWriteBuffer
    155                }
    156              }
    157          #endif
    158              //
    159              // Write data into the cluster, iterating over sectors
    160              //
    161              do {
    162                unsigned NumBytesSector;
    163                NumBytesSector = pFATInfo->BytesPerSec - SectorOff;
   \                     ??_WriteData_4:
   \   000001D4   10009DE5           LDR      R0,[SP, #+16]
   \   000001D8   00209DE5           LDR      R2,[SP, #+0]
   \   000001DC   B400D0E1           LDRH     R0,[R0, #+4]
    164                if ((U32)NumBytesSector > NumBytesCluster) {
   \   000001E0   14A09DE5           LDR      R10,[SP, #+20]
   \   000001E4   021040E0           SUB      R1,R0,R2
   \   000001E8   01005AE1           CMP      R10,R1
   \   000001EC   01A0A081           MOVHI    R10,R1
    165                  NumBytesSector = (unsigned)NumBytesCluster;
    166                }
    167                //
    168                // Check if we can write an entire sector
    169                //
    170                if   ((ZeroCopyAllowed == 0)
    171          #if FS_DRIVER_ALIGNMENT > 1      // Not required, just to avoid warnings
    172                  || (((U32)pData & (FS_DRIVER_ALIGNMENT - 1)))
    173          #endif
    174                  || (NumBytesSector != pFATInfo->BytesPerSec))
   \   000001F0   030014E3           TST      R4,#0x3
   \   000001F4   00005A01           CMPEQ    R10,R0
   \   000001F8   5800000A           BEQ      ??_WriteData_5
    175                {
    176                  //
    177                  // If we can not write an entire sector or zero copy is not allowed, there are two behaviors,
    178                  // depending on if file write buffers are supported or not.
    179                  // 1. If they are not supported we behave as before: Read the sector,
    180                  //    merge the content with the data to be written and write back the sector.
    181                  // 2. If file write buffers are supported we can choose our logic arm.
    182                  //
    183          #if FS_USE_FILE_BUFFER
    184                  pFileBuffer = pFileObj->pBuffer;
   \   000001FC   04009DE5           LDR      R0,[SP, #+4]
   \   00000200   240090E5           LDR      R0,[R0, #+36]
   \   00000204   00B0B0E1           MOVS     R11,R0
    185                  if (pFileBuffer) {
   \   00000208   3000000A           BEQ      ??_WriteData_6
    186                    if (pFileBuffer->Flags & FS_FILE_BUFFER_WRITE) {
   \   0000020C   1510DBE5           LDRB     R1,[R11, #+21]
   \   00000210   010011E3           TST      R1,#0x1
   \   00000214   2B00000A           BEQ      ??_WriteData_7
    187                      I32 NumBytesAvail;
    188                      //
    189                      // It is only allowed to fill the file buffer under the following circumstances:
    190                      // a) If the data which shall be written, is immediately written after the previous data
    191                      //    (e.g. the previous call of _Write Data wrote 1 byte to file position 1 we can only
    192                      //    use the file buffer if the current call of _WriteData() writes to file position 2.
    193                      // b) If a sector is written partially and the file buffer is large enough to hold all data which should be written.
    194                      //
    195                      //
    196                      // Clean file buffer if it contains unwritten data and if there is a gap between
    197                      // the data in the file buffer and the data that shall be written now.
    198                      //
    199                      if (pFileBuffer->IsDirty) {
   \   00000218   1400DBE5           LDRB     R0,[R11, #+20]
   \   0000021C   000050E3           CMP      R0,#+0
   \   00000220   0D00000A           BEQ      ??_WriteData_8
    200                        if (pFile->FilePos != (pFileBuffer->FilePos + pFileBuffer->NumBytesInBuffer)) {
   \   00000224   04109BE5           LDR      R1,[R11, #+4]
   \   00000228   10209BE5           LDR      R2,[R11, #+16]
   \   0000022C   040096E5           LDR      R0,[R6, #+4]
   \   00000230   011082E0           ADD      R1,R2,R1
   \   00000234   010050E1           CMP      R0,R1
   \   00000238   0B00000A           BEQ      ??_WriteData_9
    201                          FS_FAT_CleanWriteBuffer(pFile, NULL, 0, pSBData);
   \   0000023C   0730A0E1           MOV      R3,R7
   \   00000240   0020A0E3           MOV      R2,#+0
   \   00000244   0010A0E3           MOV      R1,#+0
   \   00000248   0600A0E1           MOV      R0,R6
   \   0000024C   ........           BL       FS_FAT_CleanWriteBuffer
    202                        }
    203                      }
    204                      //
    205                      // If the file buffer does not contain unwritten data, initialize it.
    206                      //
    207                      if (pFileBuffer->IsDirty == 0) {
   \   00000250   1400DBE5           LDRB     R0,[R11, #+20]
   \   00000254   000050E3           CMP      R0,#+0
   \   00000258   0300001A           BNE      ??_WriteData_9
    208                        pFileBuffer->FilePos          = pFile->FilePos;
   \                     ??_WriteData_8:
   \   0000025C   040096E5           LDR      R0,[R6, #+4]
   \   00000260   04008BE5           STR      R0,[R11, #+4]
    209                        pFileBuffer->NumBytesInBuffer = 0;
   \   00000264   0000A0E3           MOV      R0,#+0
   \   00000268   10008BE5           STR      R0,[R11, #+16]
    210                      }
    211                      //
    212                      // Does data fit into write buffer ?  If so, then copy into buffer and we are done
    213                      //
    214                      NumBytesAvail = pFileBuffer->BufferSize - pFileBuffer->NumBytesInBuffer;
    215                      if ((I32)NumBytes2Write <= (I32)NumBytesAvail) {
   \                     ??_WriteData_9:
   \   0000026C   10009BE5           LDR      R0,[R11, #+16]
   \   00000270   0C109BE5           LDR      R1,[R11, #+12]
   \   00000274   001041E0           SUB      R1,R1,R0
   \   00000278   050051E1           CMP      R1,R5
   \   0000027C   0B0000BA           BLT      ??_WriteData_10
    216                        FS_MEMCPY(pFileBuffer->pData + pFileBuffer->NumBytesInBuffer, pData, NumBytes2Write);
   \   00000280   00309BE5           LDR      R3,[R11, #+0]
   \   00000284   0520A0E1           MOV      R2,R5
   \   00000288   0410A0E1           MOV      R1,R4
   \   0000028C   030080E0           ADD      R0,R0,R3
   \   00000290   ........           BL       FS_memcpy
    217                        pFileBuffer->SectorNo          = SectorNo;
   \   00000294   08908BE5           STR      R9,[R11, #+8]
    218                        pFileBuffer->IsDirty           = 1;
   \   00000298   0100A0E3           MOV      R0,#+1
   \   0000029C   1400CBE5           STRB     R0,[R11, #+20]
    219                        pFileBuffer->NumBytesInBuffer += NumBytes2Write;
   \   000002A0   10009BE5           LDR      R0,[R11, #+16]
   \   000002A4   000085E0           ADD      R0,R5,R0
   \   000002A8   10008BE5           STR      R0,[R11, #+16]
    220                        goto SectorDone;                                     // Updating file pos & size is taken care of at label "SectorDone"
   \   000002AC   3F0000EA           B        ??_WriteData_11
    221                      }
    222                      //
    223                      // Data does not fit into file buffer.
    224                      // We clean the file buffer and append data for the rest of the sector.
    225                      //
    226                      FS_FAT_CleanWriteBuffer(pFile, pData, NumBytesSector, pSBData);
   \                     ??_WriteData_10:
   \   000002B0   0730A0E1           MOV      R3,R7
   \   000002B4   0A20A0E1           MOV      R2,R10
   \   000002B8   0410A0E1           MOV      R1,R4
   \   000002BC   0600A0E1           MOV      R0,R6
   \   000002C0   ........           BL       FS_FAT_CleanWriteBuffer
    227                      goto SectorDone;
   \   000002C4   390000EA           B        ??_WriteData_11
    228                    } else {
    229                      pFileObj->pBuffer->NumBytesInBuffer = 0;     // Invalidate Read buffer
   \                     ??_WriteData_7:
   \   000002C8   0010A0E3           MOV      R1,#+0
   \   000002CC   101080E5           STR      R1,[R0, #+16]
    230                    }
    231                  }
    232          #endif  // FS_USE_FILE_BUFFER
    233                  //
    234                  // Read the sector if we need to modify an existing one
    235                  //
    236                  if (SectorOff || (pFile->FilePos != pFileObj->Size)) {
   \                     ??_WriteData_6:
   \   000002D0   00009DE5           LDR      R0,[SP, #+0]
   \   000002D4   000050E3           CMP      R0,#+0
   \   000002D8   0400001A           BNE      ??_WriteData_12
   \   000002DC   04109DE5           LDR      R1,[SP, #+4]
   \   000002E0   040096E5           LDR      R0,[R6, #+4]
   \   000002E4   041091E5           LDR      R1,[R1, #+4]
   \   000002E8   010050E1           CMP      R0,R1
   \   000002EC   0C00000A           BEQ      ??_WriteData_13
    237                    FS__SB_SetSector(pSBData, SectorNo, FS_SB_TYPE_DATA);
   \                     ??_WriteData_12:
   \   000002F0   0020A0E3           MOV      R2,#+0
   \   000002F4   0910A0E1           MOV      R1,R9
   \   000002F8   0700A0E1           MOV      R0,R7
   \   000002FC   ........           BL       FS__SB_SetSector
    238                    if (FS__SB_Read(pSBData)) {
   \   00000300   0700A0E1           MOV      R0,R7
   \   00000304   ........           BL       FS__SB_Read
   \   00000308   000050E3           CMP      R0,#+0
   \   0000030C   0400000A           BEQ      ??_WriteData_13
    239                      FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_WriteData: Read error during write.\n"));
    240                      pFile->Error = FS_ERR_READERROR;       /* read error during write */
   \   00000310   0600E0E3           MVN      R0,#+6
   \   00000314   B800C6E1           STRH     R0,[R6, #+8]
    241                      return NumBytesWritten;
   \                     ??_WriteData_3:
   \   00000318   0C009DE5           LDR      R0,[SP, #+12]
   \   0000031C   24D08DE2           ADD      SP,SP,#+36
   \   00000320   F08FBDE8           POP      {R4-R11,PC}      ;; return
    242                    }
    243                  }
    244                  //
    245                  // Merge the written data into the sector
    246                  //
    247                  FS_MEMCPY(pSBData->pBuffer + SectorOff, pData, NumBytesSector);
   \                     ??_WriteData_13:
   \   00000324   00009DE5           LDR      R0,[SP, #+0]
   \   00000328   083097E5           LDR      R3,[R7, #+8]
   \   0000032C   0A20A0E1           MOV      R2,R10
   \   00000330   0410A0E1           MOV      R1,R4
   \   00000334   030080E0           ADD      R0,R0,R3
   \   00000338   ........           BL       FS_memcpy
    248                  //
    249                  // Write sector
    250                  //
    251                  FS__SB_SetSector(pSBData, SectorNo, FS_SB_TYPE_DATA);
   \   0000033C   0020A0E3           MOV      R2,#+0
   \   00000340   0910A0E1           MOV      R1,R9
   \   00000344   0700A0E1           MOV      R0,R7
   \   00000348   ........           BL       FS__SB_SetSector
    252                  if (FS__SB_Write(pSBData)) {
   \   0000034C   0700A0E1           MOV      R0,R7
   \   00000350   ........           BL       FS__SB_Write
   \   00000354   000050E3           CMP      R0,#+0
   \   00000358   1400000A           BEQ      ??_WriteData_11
    253                    return NumBytesWritten;          /* Could not write  sector */
   \   0000035C   EDFFFFEA           B        ??_WriteData_3
    254                  }
    255                } else {
    256                  //
    257                  // Write the sector with "Zero-copy"
    258                  //
    259                  if (SectorNo != BurstInfo.FirstSector + BurstInfo.NumSectors) {
   \                     ??_WriteData_5:
   \   00000360   18009DE5           LDR      R0,[SP, #+24]
   \   00000364   000088E0           ADD      R0,R8,R0
   \   00000368   000059E1           CMP      R9,R0
   \   0000036C   0E00000A           BEQ      ??_WriteData_14
    260                    if (_WriteBurst(&BurstInfo)) {
   \   00000370   000058E3           CMP      R8,#+0
   \   00000374   0800000A           BEQ      ??_WriteData_15
   \   00000378   0000A0E3           MOV      R0,#+0
   \   0000037C   00008DE5           STR      R0,[SP, #+0]
   \   00000380   1C309DE5           LDR      R3,[SP, #+28]
   \   00000384   0820A0E1           MOV      R2,R8
   \   00000388   18109DE5           LDR      R1,[SP, #+24]
   \   0000038C   040097E5           LDR      R0,[R7, #+4]
   \   00000390   ........           BL       FS_LB_WriteBurstPart
   \   00000394   000050E3           CMP      R0,#+0
   \   00000398   DEFFFF1A           BNE      ??_WriteData_3
    261                      return NumBytesWritten;
    262                    }
    263                    BurstInfo.FirstSector = SectorNo;
   \                     ??_WriteData_15:
   \   0000039C   18908DE5           STR      R9,[SP, #+24]
    264                    BurstInfo.NumSectors  = 1;
   \   000003A0   0180A0E3           MOV      R8,#+1
    265                    BurstInfo.pData       = pData;
   \   000003A4   1C408DE5           STR      R4,[SP, #+28]
   \   000003A8   000000EA           B        ??_WriteData_11
    266                  } else {
    267                    BurstInfo.NumSectors++;
   \                     ??_WriteData_14:
   \   000003AC   018088E2           ADD      R8,R8,#+1
    268                  }
    269                }
    270                //
    271                // Update management info
    272                //
    273          #if FS_USE_FILE_BUFFER
    274          SectorDone:
    275          #endif
    276                pData           += NumBytesSector;
    277                NumBytesCluster -= NumBytesSector;
   \                     ??_WriteData_11:
   \   000003B0   14009DE5           LDR      R0,[SP, #+20]
    278                NumBytes2Write  -= NumBytesSector;
    279                NumBytesWritten += NumBytesSector;
    280                pFile->FilePos  += NumBytesSector;
    281                SectorNo++;
    282                SectorOff = 0;                /* Next sector will be written from start */
   \   000003B4   0020A0E3           MOV      R2,#+0
   \   000003B8   0A0040E0           SUB      R0,R0,R10
   \   000003BC   14008DE5           STR      R0,[SP, #+20]
   \   000003C0   0C009DE5           LDR      R0,[SP, #+12]
   \   000003C4   04408AE0           ADD      R4,R10,R4
   \   000003C8   00008AE0           ADD      R0,R10,R0
   \   000003CC   0C008DE5           STR      R0,[SP, #+12]
   \   000003D0   040096E5           LDR      R0,[R6, #+4]
   \   000003D4   0A5045E0           SUB      R5,R5,R10
   \   000003D8   00008AE0           ADD      R0,R10,R0
   \   000003DC   040086E5           STR      R0,[R6, #+4]
    283                //
    284                // Update File size
    285                //
    286                if (pFile->FilePos > pFileObj->Size) {
   \   000003E0   04109DE5           LDR      R1,[SP, #+4]
   \   000003E4   00208DE5           STR      R2,[SP, #+0]
   \   000003E8   041091E5           LDR      R1,[R1, #+4]
   \   000003EC   019089E2           ADD      R9,R9,#+1
   \   000003F0   000051E1           CMP      R1,R0
   \   000003F4   0900002A           BCS      ??_WriteData_16
    287                  if (pFileObj->Size == 0) {          // In this case we have allocated a cluster and need to update the dir entry!
   \   000003F8   000051E3           CMP      R1,#+0
   \   000003FC   0300000A           BEQ      ??_WriteData_17
    288                    DirUpdateRequired = 1;
    289                  } else {
    290                    if (FS_Global.WriteMode == FS_WRITEMODE_SAFE) {
   \   00000400   ........           LDR      R1,??DataTable2
   \   00000404   8410D1E5           LDRB     R1,[R1, #+132]
   \   00000408   000051E3           CMP      R1,#+0
   \   0000040C   0100001A           BNE      ??_WriteData_18
    291                      DirUpdateRequired = 1;
   \                     ??_WriteData_17:
   \   00000410   0120A0E3           MOV      R2,#+1
   \   00000414   0820CDE5           STRB     R2,[SP, #+8]
    292                    }
    293                  }
    294                  pFileObj->Size = pFile->FilePos;
   \                     ??_WriteData_18:
   \   00000418   04109DE5           LDR      R1,[SP, #+4]
   \   0000041C   040081E5           STR      R0,[R1, #+4]
    295                }
    296              } while (NumBytesCluster);
   \                     ??_WriteData_16:
   \   00000420   14009DE5           LDR      R0,[SP, #+20]
   \   00000424   000050E3           CMP      R0,#+0
   \   00000428   69FFFF1A           BNE      ??_WriteData_4
    297            } while (NumBytes2Write);
   \   0000042C   000055E3           CMP      R5,#+0
   \   00000430   06FFFF1A           BNE      ??_WriteData_0
    298            //
    299            // Flush Burst
    300            //
    301            if (_WriteBurst(&BurstInfo)) {
   \   00000434   000058E3           CMP      R8,#+0
   \   00000438   0800000A           BEQ      ??_WriteData_19
   \   0000043C   00008DE5           STR      R0,[SP, #+0]
   \   00000440   1C309DE5           LDR      R3,[SP, #+28]
   \   00000444   0820A0E1           MOV      R2,R8
   \   00000448   18109DE5           LDR      R1,[SP, #+24]
   \   0000044C   040097E5           LDR      R0,[R7, #+4]
   \   00000450   ........           BL       FS_LB_WriteBurstPart
   \   00000454   000050E3           CMP      R0,#+0
    302              NumBytesWritten = 0;               /* We do not know how many bytes have been written o.k., so reporting 0 is on the safe side */
   \   00000458   0010A013           MOVNE    R1,#+0
   \   0000045C   0C108D15           STRNE    R1,[SP, #+12]
    303            }
    304            //
    305            // Update directory entry if required
    306            //
    307            if (DirUpdateRequired) {
   \                     ??_WriteData_19:
   \   00000460   0800DDE5           LDRB     R0,[SP, #+8]
   \   00000464   000050E3           CMP      R0,#+0
   \   00000468   AAFFFF0A           BEQ      ??_WriteData_3
    308              FS_FAT_UpdateDirEntry(pFileObj, pSBData);
   \   0000046C   08FFFFEA           B        ??_WriteData_2
    309            }
    310            return NumBytesWritten;
    311          }
    312          
    313          
    314          /*********************************************************************
    315          *
    316          *       Public code
    317          *
    318          **********************************************************************
    319          */
    320          
    321          /*********************************************************************
    322          *
    323          *       FS_FAT_UpdateDirEntry
    324          */

   \                                 In section .text, align 4, keep-with-next
    325          void FS_FAT_UpdateDirEntry(FS_FILE_OBJ * pFileObj, FS_SB * pSB) {
   \                     FS_FAT_UpdateDirEntry:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    326            FS_FAT_DENTRY * pDirEntry;
    327            U32             TimeDate;
    328            U32             DirSectorNo;
    329            U16             BytesPerSector;
    330            U16             SectorOff;
    331          
    332            BytesPerSector = pFileObj->pVolume->FSInfo.FATInfo.BytesPerSec;
   \   00000008   080095E5           LDR      R0,[R5, #+8]
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   B062D0E1           LDRH     R6,[R0, #+32]
    333            DirSectorNo    = pFileObj->Data.Fat.DirEntrySector;
    334            FS__SB_SetSector(pSB, DirSectorNo, FS_SB_TYPE_DIRECTORY);
   \   00000014   0120A0E3           MOV      R2,#+1
   \   00000018   181095E5           LDR      R1,[R5, #+24]
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       FS__SB_SetSector
    335            SectorOff = (pFileObj->Data.Fat.DirEntryIndex  * sizeof(FS_FAT_DENTRY)) & (BytesPerSector - 1);
    336            pDirEntry = (FS_FAT_DENTRY *) (pSB->pBuffer + SectorOff);
   \   00000024   BC01D5E1           LDRH     R0,[R5, #+28]
   \   00000028   011046E2           SUB      R1,R6,#+1
   \   0000002C   800201E0           AND      R0,R1,R0, LSL #+5
   \   00000030   081094E5           LDR      R1,[R4, #+8]
   \   00000034   0008A0E1           LSL      R0,R0,#+16
   \   00000038   206881E0           ADD      R6,R1,R0, LSR #+16
    337          
    338            if (FS__SB_Read(pSB) == 0) {
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       FS__SB_Read
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   1000001A           BNE      ??FS_FAT_UpdateDirEntry_0
    339              //
    340              // Modify directory entry
    341              //
    342              FS_StoreU32LE(&pDirEntry->data[DIR_ENTRY_OFF_SIZE], pFileObj->Size);
   \   0000004C   041095E5           LDR      R1,[R5, #+4]
   \   00000050   1C0086E2           ADD      R0,R6,#+28
   \   00000054   ........           BL       FS_StoreU32LE
    343              FS_FAT_WriteDirEntryCluster(pDirEntry, pFileObj->FirstCluster);
   \   00000058   001095E5           LDR      R1,[R5, #+0]
   \   0000005C   0600A0E1           MOV      R0,R6
   \   00000060   ........           BL       FS_FAT_WriteDirEntryCluster
    344              TimeDate = FS_X_GetTimeDate();
   \   00000064   ........           BL       FS_X_GetTimeDate
   \   00000068   0050A0E1           MOV      R5,R0
    345              FS_StoreU16LE(&pDirEntry->data[DIR_ENTRY_OFF_WRITE_TIME], (U16)(TimeDate & 0xffff));
   \   0000006C   0518A0E1           LSL      R1,R5,#+16
   \   00000070   2118A0E1           LSR      R1,R1,#+16
   \   00000074   160086E2           ADD      R0,R6,#+22
   \   00000078   ........           BL       FS_StoreU16LE
    346              FS_StoreU16LE(&pDirEntry->data[DIR_ENTRY_OFF_WRITE_DATE], (U16)(TimeDate >> 16));
   \   0000007C   2518A0E1           LSR      R1,R5,#+16
   \   00000080   180086E2           ADD      R0,R6,#+24
   \   00000084   ........           BL       FS_StoreU16LE
    347              FS__SB_Flush(pSB);                   /* Write the modified directory entry */
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   ........           BL       FS__SB_Flush
    348            } else {
    349              FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_UpdateDirEntry: Could not read directory sector to update directory entry"));
    350            }
    351          }
   \                     ??FS_FAT_UpdateDirEntry_0:
   \   00000090   7080BDE8           POP      {R4-R6,PC}       ;; return
    352          
    353          
    354          /*********************************************************************
    355          *
    356          *       FS_FAT_CleanWriteBuffer
    357          *
    358          */
    359          #if FS_USE_FILE_BUFFER

   \                                 In section .text, align 4, keep-with-next
    360          void FS_FAT_CleanWriteBuffer(FS_FILE * pFile, const U8 * pData, I32 NumBytesData, FS_SB * pSBData) {
   \                     FS_FAT_CleanWriteBuffer:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    361            FS_FILE_OBJ * pFileObj;
    362            FS_FAT_INFO * pFATInfo;
    363            FS_FILE_BUFFER * pFileBuffer;
    364            int  SectorOff;
    365          
    366            pFileObj    = pFile->pFileObj;
   \   00000008   008094E5           LDR      R8,[R4, #+0]
   \   0000000C   0150A0E1           MOV      R5,R1
    367            pFileBuffer = pFileObj->pBuffer;
   \   00000010   249098E5           LDR      R9,[R8, #+36]
   \   00000014   0260A0E1           MOV      R6,R2
    368            if (pFileBuffer == NULL) {
   \   00000018   000059E3           CMP      R9,#+0
    369              return;
    370            }
    371            if (pFileBuffer->IsDirty == 0) {
   \   0000001C   1400D915           LDRBNE   R0,[R9, #+20]
   \   00000020   0370A0E1           MOV      R7,R3
   \   00000024   00005013           CMPNE    R0,#+0
   \   00000028   3000000A           BEQ      ??FS_FAT_CleanWriteBuffer_0
    372              return;
    373            }
    374            pFATInfo    = &pFileObj->pVolume->FSInfo.FATInfo;
   \   0000002C   080098E5           LDR      R0,[R8, #+8]
    375          
    376            FS__SB_SetSector(pSBData, pFileBuffer->SectorNo, FS_SB_TYPE_DATA);
   \   00000030   0020A0E3           MOV      R2,#+0
   \   00000034   1CA080E2           ADD      R10,R0,#+28
   \   00000038   081099E5           LDR      R1,[R9, #+8]
   \   0000003C   0700A0E1           MOV      R0,R7
   \   00000040   ........           BL       FS__SB_SetSector
    377            SectorOff = pFileBuffer->FilePos & (pFATInfo->BytesPerSec - 1);
   \   00000044   B400DAE1           LDRH     R0,[R10, #+4]
   \   00000048   041099E5           LDR      R1,[R9, #+4]
   \   0000004C   012040E2           SUB      R2,R0,#+1
   \   00000050   01A012E0           ANDS     R10,R2,R1
    378            if (SectorOff || (pFile->FilePos != pFileObj->Size)) {                             // No need to read if we are at the end of file and start of sector
   \   00000054   0300001A           BNE      ??FS_FAT_CleanWriteBuffer_1
   \   00000058   041094E5           LDR      R1,[R4, #+4]
   \   0000005C   042098E5           LDR      R2,[R8, #+4]
   \   00000060   020051E1           CMP      R1,R2
   \   00000064   0800000A           BEQ      ??FS_FAT_CleanWriteBuffer_2
    379              if ((NumBytesData + pFileBuffer->NumBytesInBuffer) != pFATInfo->BytesPerSec) {     // No need to read if sector is written completely
   \                     ??FS_FAT_CleanWriteBuffer_1:
   \   00000068   101099E5           LDR      R1,[R9, #+16]
   \   0000006C   061081E0           ADD      R1,R1,R6
   \   00000070   000051E1           CMP      R1,R0
   \   00000074   0400000A           BEQ      ??FS_FAT_CleanWriteBuffer_2
    380                if (FS__SB_Read(pSBData)) {
   \   00000078   0700A0E1           MOV      R0,R7
   \   0000007C   ........           BL       FS__SB_Read
   \   00000080   000050E3           CMP      R0,#+0
    381                  FS_DEBUG_ERROROUT((FS_MTYPE_FS, "_WriteData: Read error during write.\n"));
    382                  pFile->Error = FS_ERR_READERROR;       /* read error during write */
   \   00000084   0600E013           MVNNE    R0,#+6
   \   00000088   1700001A           BNE      ??FS_FAT_CleanWriteBuffer_3
    383                  return;
    384                }
    385              }
    386            }
    387            //
    388            // Merge the written data into the sector
    389            //
    390            if (pFileBuffer->NumBytesInBuffer) {
   \                     ??FS_FAT_CleanWriteBuffer_2:
   \   0000008C   102099E5           LDR      R2,[R9, #+16]
   \   00000090   000052E3           CMP      R2,#+0
   \   00000094   0300000A           BEQ      ??FS_FAT_CleanWriteBuffer_4
    391              FS_MEMCPY(pSBData->pBuffer + SectorOff, pFileBuffer->pData, pFileBuffer->NumBytesInBuffer);
   \   00000098   080097E5           LDR      R0,[R7, #+8]
   \   0000009C   001099E5           LDR      R1,[R9, #+0]
   \   000000A0   00008AE0           ADD      R0,R10,R0
   \   000000A4   ........           BL       FS_memcpy
    392            }
    393            if (NumBytesData) {
   \                     ??FS_FAT_CleanWriteBuffer_4:
   \   000000A8   000056E3           CMP      R6,#+0
   \   000000AC   0600000A           BEQ      ??FS_FAT_CleanWriteBuffer_5
    394              FS_MEMCPY(pSBData->pBuffer + SectorOff + pFileBuffer->NumBytesInBuffer, pData, NumBytesData);
   \   000000B0   083097E5           LDR      R3,[R7, #+8]
   \   000000B4   100099E5           LDR      R0,[R9, #+16]
   \   000000B8   03308AE0           ADD      R3,R10,R3
   \   000000BC   0620A0E1           MOV      R2,R6
   \   000000C0   0510A0E1           MOV      R1,R5
   \   000000C4   030080E0           ADD      R0,R0,R3
   \   000000C8   ........           BL       FS_memcpy
    395            }
    396            pFileBuffer->IsDirty           = 0;
   \                     ??FS_FAT_CleanWriteBuffer_5:
   \   000000CC   0000A0E3           MOV      R0,#+0
   \   000000D0   1400C9E5           STRB     R0,[R9, #+20]
    397            pFileBuffer->NumBytesInBuffer  = 0;
   \   000000D4   100089E5           STR      R0,[R9, #+16]
    398            //
    399            // Write sector
    400            //
    401            if (FS__SB_Write(pSBData)) {
   \   000000D8   0700A0E1           MOV      R0,R7
   \   000000DC   ........           BL       FS__SB_Write
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   0100000A           BEQ      ??FS_FAT_CleanWriteBuffer_0
    402              pFile->Error = FS_ERR_WRITEERROR;
   \   000000E8   0700E0E3           MVN      R0,#+7
   \                     ??FS_FAT_CleanWriteBuffer_3:
   \   000000EC   B800C4E1           STRH     R0,[R4, #+8]
   \                     ??FS_FAT_CleanWriteBuffer_0:
   \   000000F0   F087BDE8           POP      {R4-R10,PC}      ;; return
    403            }
    404          }
    405          #endif
    406          
    407          /*********************************************************************
    408          *
    409          *       FS_FAT_GotoClusterAllocIfReq
    410          *
    411          *  Purpose
    412          *    Allocates clusters to the file.
    413          *
    414          *  Return value
    415          *    0     if cluster has been located
    416          *    1     error
    417          */

   \                                 In section .text, align 4, keep-with-next
    418          int FS_FAT_GotoClusterAllocIfReq(FS_FILE *pFile, FS_SB * pSBfat) {
   \                     FS_FAT_GotoClusterAllocIfReq:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    419            FS_FILE_OBJ * pFileObj;
    420            FS_VOLUME   * pVolume;
    421            U32           NumClustersToGo;
    422            int           r;
    423          
    424            r               = 0;
    425            pFileObj        = pFile->pFileObj;
   \   00000008   007094E5           LDR      R7,[R4, #+0]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0060A0E3           MOV      R6,#+0
    426            pVolume         = pFileObj->pVolume;
   \   00000018   088097E5           LDR      R8,[R7, #+8]
    427            NumClustersToGo = FS_FAT_GotoCluster(pFile, pSBfat);
   \   0000001C   ........           BL       FS_FAT_GotoCluster
   \   00000020   0090B0E1           MOVS     R9,R0
    428            if (NumClustersToGo > 0) {
   \   00000024   4000000A           BEQ      ??FS_FAT_GotoClusterAllocIfReq_0
    429              //
    430              //
    431              // Make sure at least one cluster is allocated, so that FirstCluster is valid.
    432              // If no cluster has yet been allocated, allocate one
    433              //
    434              if (pFileObj->FirstCluster == 0) {
   \   00000028   000097E5           LDR      R0,[R7, #+0]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   1A00001A           BNE      ??FS_FAT_GotoClusterAllocIfReq_1
    435                U32 CurClusterId;    /* FAT Id of the current cluster */
    436                CurClusterId    = FS_FAT_FindFreeCluster(pVolume, pSBfat, 0, pFile);
   \   00000034   0430A0E1           MOV      R3,R4
   \   00000038   0020A0E3           MOV      R2,#+0
   \   0000003C   0510A0E1           MOV      R1,R5
   \   00000040   0800A0E1           MOV      R0,R8
   \   00000044   ........           BL       FS_FAT_FindFreeCluster
   \   00000048   0010B0E1           MOVS     R1,R0
    437                if (CurClusterId == 0) {
   \   0000004C   0300001A           BNE      ??FS_FAT_GotoClusterAllocIfReq_2
    438                  pFile->Error = FS_ERR_DISKFULL;
   \   00000050   0100E0E3           MVN      R0,#+1
   \   00000054   B800C4E1           STRH     R0,[R4, #+8]
    439                  return 1;                // No free cluster
   \                     ??FS_FAT_GotoClusterAllocIfReq_3:
   \   00000058   0100A0E3           MOV      R0,#+1
   \   0000005C   330000EA           B        ??FS_FAT_GotoClusterAllocIfReq_4
    440                }
    441                pFileObj->FirstCluster = CurClusterId;
   \                     ??FS_FAT_GotoClusterAllocIfReq_2:
   \   00000060   000087E5           STR      R0,[R7, #+0]
    442                NumClustersToGo--;
    443                pFileObj->Data.Fat.CurClusterAbs  = CurClusterId;
   \   00000064   140087E5           STR      R0,[R7, #+20]
    444                pFileObj->Data.Fat.CurClusterFile = 0;
    445                if (FS_Global.WriteMode != FS_WRITEMODE_FAST) {
   \   00000068   ........           LDR      R1,??DataTable2
   \   0000006C   106087E5           STR      R6,[R7, #+16]
   \   00000070   8410D1E5           LDRB     R1,[R1, #+132]
   \   00000074   019049E2           SUB      R9,R9,#+1
   \   00000078   020051E3           CMP      R1,#+2
   \   0000007C   0500000A           BEQ      ??FS_FAT_GotoClusterAllocIfReq_5
    446                  if (FS_FAT_MarkClusterEOC(pVolume, pSBfat, pFileObj->Data.Fat.CurClusterAbs)) {
   \   00000080   0020A0E1           MOV      R2,R0
   \   00000084   0510A0E1           MOV      R1,R5
   \   00000088   0800A0E1           MOV      R0,R8
   \   0000008C   ........           BL       FS_FAT_MarkClusterEOC
   \   00000090   000050E3           CMP      R0,#+0
   \   00000094   EFFFFF1A           BNE      ??FS_FAT_GotoClusterAllocIfReq_3
    447                    FS_DEBUG_ERROROUT((FS_MTYPE_FS, "FS_FAT_GotoClusterAllocIfReq: Could not write FAT entry.\n"));
    448                    return 1;                // Error
    449                  }
    450                }
    451              }
    452              if (NumClustersToGo) {
   \                     ??FS_FAT_GotoClusterAllocIfReq_5:
   \   00000098   000059E3           CMP      R9,#+0
   \   0000009C   2200000A           BEQ      ??FS_FAT_GotoClusterAllocIfReq_0
    453                do {
    454                  U32 NewCluster;
    455                  //
    456                  // Check if we have an other cluster in the chain or if we need to alloc an other one
    457                  //
    458                  NewCluster = FS_FAT_FindFreeCluster(pVolume, pSBfat, pFileObj->Data.Fat.CurClusterAbs, pFile);
   \                     ??FS_FAT_GotoClusterAllocIfReq_1:
   \   000000A0   0430A0E1           MOV      R3,R4
   \   000000A4   142097E5           LDR      R2,[R7, #+20]
   \   000000A8   0510A0E1           MOV      R1,R5
   \   000000AC   0800A0E1           MOV      R0,R8
   \   000000B0   ........           BL       FS_FAT_FindFreeCluster
   \   000000B4   00B0B0E1           MOVS     R11,R0
    459                  if (NewCluster == 0) {
   \   000000B8   ........           LDR      R10,??DataTable2
   \   000000BC   0300001A           BNE      ??FS_FAT_GotoClusterAllocIfReq_6
    460                    pFile->Error = FS_ERR_DISKFULL;
   \   000000C0   0100E0E3           MVN      R0,#+1
   \   000000C4   B800C4E1           STRH     R0,[R4, #+8]
    461                    r =  1;                                /* Error, disk full */
   \   000000C8   0160A0E3           MOV      R6,#+1
    462                    break;
   \   000000CC   0D0000EA           B        ??FS_FAT_GotoClusterAllocIfReq_7
    463                  }
    464                  if (FS_Global.WriteMode != FS_WRITEMODE_FAST) {
   \                     ??FS_FAT_GotoClusterAllocIfReq_6:
   \   000000D0   8400DAE5           LDRB     R0,[R10, #+132]
   \   000000D4   020050E3           CMP      R0,#+2
   \   000000D8   0400000A           BEQ      ??FS_FAT_GotoClusterAllocIfReq_8
    465                    FS_FAT_LinkCluster(pVolume, pSBfat, pFileObj->Data.Fat.CurClusterAbs, NewCluster);
   \   000000DC   0B30A0E1           MOV      R3,R11
   \   000000E0   142097E5           LDR      R2,[R7, #+20]
   \   000000E4   0510A0E1           MOV      R1,R5
   \   000000E8   0800A0E1           MOV      R0,R8
   \   000000EC   ........           BL       FS_FAT_LinkCluster
    466                  }
    467                  pFileObj->Data.Fat.CurClusterAbs = NewCluster;
   \                     ??FS_FAT_GotoClusterAllocIfReq_8:
   \   000000F0   14B087E5           STR      R11,[R7, #+20]
    468                  pFileObj->Data.Fat.CurClusterFile++;
   \   000000F4   100097E5           LDR      R0,[R7, #+16]
    469                } while (--NumClustersToGo);
   \   000000F8   019059E2           SUBS     R9,R9,#+1
   \   000000FC   010080E2           ADD      R0,R0,#+1
   \   00000100   100087E5           STR      R0,[R7, #+16]
   \   00000104   E5FFFF1A           BNE      ??FS_FAT_GotoClusterAllocIfReq_1
    470                //
    471                // Mark the last allocated cluster as the last in the chain.
    472                //
    473                if (FS_Global.WriteMode != FS_WRITEMODE_FAST) {
   \                     ??FS_FAT_GotoClusterAllocIfReq_7:
   \   00000108   8400DAE5           LDRB     R0,[R10, #+132]
   \   0000010C   020050E3           CMP      R0,#+2
   \   00000110   0500000A           BEQ      ??FS_FAT_GotoClusterAllocIfReq_0
    474                  if (FS_FAT_MarkClusterEOC(pVolume, pSBfat, pFileObj->Data.Fat.CurClusterAbs)) {
   \   00000114   142097E5           LDR      R2,[R7, #+20]
   \   00000118   0510A0E1           MOV      R1,R5
   \   0000011C   0800A0E1           MOV      R0,R8
   \   00000120   ........           BL       FS_FAT_MarkClusterEOC
   \   00000124   000050E3           CMP      R0,#+0
   \   00000128   CAFFFF1A           BNE      ??FS_FAT_GotoClusterAllocIfReq_3
    475                    FS_DEBUG_ERROROUT((FS_MTYPE_FS, "FS_FAT_GotoClusterAllocIfReq: Could not write FAT entry.\n"));
    476                    return 1;                // Error
    477                  }
    478                }
    479              }
    480            }
    481            return r;               /* O.K. */
   \                     ??FS_FAT_GotoClusterAllocIfReq_0:
   \   0000012C   0600A0E1           MOV      R0,R6
   \                     ??FS_FAT_GotoClusterAllocIfReq_4:
   \   00000130   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000134   F08FBDE8           POP      {R4-R11,PC}      ;; return
    482          }
    483          
    484          
    485          /*********************************************************************
    486          *
    487          *       FS_FAT_Write
    488          *
    489          *  Description:
    490          *    FS internal function. Write data to a file.
    491          *
    492          *  Parameters:
    493          *    pData           - Pointer to data, which will be written to the file.
    494          *    NumBytes        - Size of an element to be transferred to a file.
    495          *    pFile           - Pointer to a FS_FILE data structure.
    496          *
    497          *  Note:
    498          *    pFile is not checked if it is valid
    499          *
    500          *  Return value:
    501          *    Number of bytes written.
    502          */

   \                                 In section .text, align 4, keep-with-next
    503          U32 FS_FAT_Write(FS_FILE *pFile, const void *pData, U32 NumBytes) {
   \                     FS_FAT_Write:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    504            U32        NumBytesWritten;
    505            FS_SB         sbData;          /* Sector buffer for Data */
    506            FS_SB         sbfat;           /* Sector buffer for FAT handling */
    507            FS_FILE_OBJ * pFileObj;
    508            FS_VOLUME   * pVolume;
    509          
    510            pFileObj = pFile->pFileObj;
    511            pVolume  = pFileObj->pVolume;
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   087090E5           LDR      R7,[R0, #+8]
    512            //
    513            // Check if file status is O.K..
    514            // If not, return.
    515            //
    516            if ((pFile->Error != FS_ERR_EOF) && (pFile->Error != FS_ERR_OK)) {
   \   00000014   F800D4E1           LDRSH    R0,[R4, #+8]
   \   00000018   0010E0E3           MVN      R1,#+0
   \   0000001C   24D04DE2           SUB      SP,SP,#+36
   \   00000020   010050E1           CMP      R0,R1
   \   00000024   00005013           CMPNE    R0,#+0
   \   00000028   0250A0E1           MOV      R5,R2
    517              return 0;                 // Error
   \   0000002C   0000A013           MOVNE    R0,#+0
   \   00000030   1800001A           BNE      ??FS_FAT_Write_0
    518            }
    519            //
    520            // Allocate sector buffers.
    521            //
    522            FS__SB_Create(&sbfat,  &pVolume->Partition);
   \   00000034   0710A0E1           MOV      R1,R7
   \   00000038   04008DE2           ADD      R0,SP,#+4
   \   0000003C   ........           BL       FS__SB_Create
    523            FS__SB_Create(&sbData, &pVolume->Partition);
   \   00000040   0710A0E1           MOV      R1,R7
   \   00000044   14008DE2           ADD      R0,SP,#+20
   \   00000048   ........           BL       FS__SB_Create
    524            //
    525            // Do the work in a static subroutine
    526            //
    527            NumBytesWritten = _WriteData((const U8 *)pData, NumBytes, pFile, &sbData, &sbfat);
   \   0000004C   04008DE2           ADD      R0,SP,#+4
   \   00000050   00008DE5           STR      R0,[SP, #+0]
   \   00000054   14308DE2           ADD      R3,SP,#+20
   \   00000058   0420A0E1           MOV      R2,R4
   \   0000005C   0510A0E1           MOV      R1,R5
   \   00000060   0600A0E1           MOV      R0,R6
   \   00000064   ........           BL       _WriteData
   \   00000068   0060A0E1           MOV      R6,R0
    528            //
    529            // If less bytes have been written than intended
    530            //   - Set error code in file structure (unless already set)
    531            //   - Invalidate the Current cluster Id to make sure we read allocation list from start next time we read
    532            //
    533            if (NumBytesWritten != NumBytes) {
   \   0000006C   050056E1           CMP      R6,R5
   \   00000070   0300000A           BEQ      ??FS_FAT_Write_1
    534              if (pFile->Error == 0) {
   \   00000074   F800D4E1           LDRSH    R0,[R4, #+8]
   \   00000078   000050E3           CMP      R0,#+0
    535                pFile->Error = FS_ERR_WRITEERROR;
   \   0000007C   0700E003           MVNEQ    R0,#+7
   \   00000080   B800C401           STRHEQ   R0,[R4, #+8]
    536              }
    537            }
    538            //
    539            // Cleanup
    540            //
    541            FS__SB_Delete(&sbfat);
   \                     ??FS_FAT_Write_1:
   \   00000084   04008DE2           ADD      R0,SP,#+4
   \   00000088   ........           BL       FS__SB_Delete
    542            FS__SB_Delete(&sbData);
   \   0000008C   14008DE2           ADD      R0,SP,#+20
   \   00000090   ........           BL       FS__SB_Delete
    543            return NumBytesWritten;
   \   00000094   0600A0E1           MOV      R0,R6
   \                     ??FS_FAT_Write_0:
   \   00000098   24D08DE2           ADD      SP,SP,#+36       ;; stack cleaning
   \   0000009C   F080BDE8           POP      {R4-R7,PC}       ;; return
    544          }
    545          
    546          /*********************************************************************
    547          *
    548          *       FS_FAT_Close
    549          *
    550          *  Description:
    551          *    FS internal function. Close a file referred by a file pointer.
    552          *
    553          *  Parameters:
    554          *    pFile       - Pointer to a FS_FILE data structure.
    555          *
    556          *  Return value:
    557          *    None.
    558          */

   \                                 In section .text, align 4, keep-with-next
    559          void FS_FAT_Close(FS_FILE *pFile) {
   \                     FS_FAT_Close:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    560            FS_FILE_OBJ * pFileObj;
    561            FS_VOLUME   * pVolume;
    562          
    563            pFileObj = pFile->pFileObj;
    564            /* Check if media is OK */
    565            pVolume  = pFileObj->pVolume;
    566            if (pFile->Error == 0) {
   \   00000008   F800D4E1           LDRSH    R0,[R4, #+8]
   \   0000000C   006094E5           LDR      R6,[R4, #+0]
   \   00000010   14D04DE2           SUB      SP,SP,#+20
   \   00000014   085096E5           LDR      R5,[R6, #+8]
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   3400001A           BNE      ??FS_FAT_Close_0
    567              //
    568              // Update directory if necessary
    569              //
    570              if (pFile->AccessFlags & FS_FILE_ACCESS_FLAGS_AW) {
   \   00000020   0B00D4E5           LDRB     R0,[R4, #+11]
   \   00000024   EE00D0E3           BICS     R0,R0,#0xEE
   \   00000028   3100000A           BEQ      ??FS_FAT_Close_0
    571                FS_SB     SB;          /* Sector buffer for Data */
    572                FS__SB_Create(&SB, &pVolume->Partition);
   \   0000002C   0510A0E1           MOV      R1,R5
   \   00000030   0D00A0E1           MOV      R0,SP
   \   00000034   ........           BL       FS__SB_Create
    573                FS_FAT_UpdateDirEntry(pFileObj, &SB);
   \   00000038   080096E5           LDR      R0,[R6, #+8]
   \   0000003C   0120A0E3           MOV      R2,#+1
   \   00000040   B072D0E1           LDRH     R7,[R0, #+32]
   \   00000044   181096E5           LDR      R1,[R6, #+24]
   \   00000048   0D00A0E1           MOV      R0,SP
   \   0000004C   ........           BL       FS__SB_SetSector
   \   00000050   BC01D6E1           LDRH     R0,[R6, #+28]
   \   00000054   011047E2           SUB      R1,R7,#+1
   \   00000058   800201E0           AND      R0,R1,R0, LSL #+5
   \   0000005C   08109DE5           LDR      R1,[SP, #+8]
   \   00000060   0008A0E1           LSL      R0,R0,#+16
   \   00000064   207881E0           ADD      R7,R1,R0, LSR #+16
   \   00000068   0D00A0E1           MOV      R0,SP
   \   0000006C   ........           BL       FS__SB_Read
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   1000001A           BNE      ??FS_FAT_Close_1
   \   00000078   041096E5           LDR      R1,[R6, #+4]
   \   0000007C   1C0087E2           ADD      R0,R7,#+28
   \   00000080   ........           BL       FS_StoreU32LE
   \   00000084   001096E5           LDR      R1,[R6, #+0]
   \   00000088   0700A0E1           MOV      R0,R7
   \   0000008C   ........           BL       FS_FAT_WriteDirEntryCluster
   \   00000090   ........           BL       FS_X_GetTimeDate
   \   00000094   0060A0E1           MOV      R6,R0
   \   00000098   0618A0E1           LSL      R1,R6,#+16
   \   0000009C   2118A0E1           LSR      R1,R1,#+16
   \   000000A0   160087E2           ADD      R0,R7,#+22
   \   000000A4   ........           BL       FS_StoreU16LE
   \   000000A8   2618A0E1           LSR      R1,R6,#+16
   \   000000AC   180087E2           ADD      R0,R7,#+24
   \   000000B0   ........           BL       FS_StoreU16LE
   \   000000B4   0D00A0E1           MOV      R0,SP
   \   000000B8   ........           BL       FS__SB_Flush
    574                if (FS_Global.WriteMode == FS_WRITEMODE_FAST) {
   \                     ??FS_FAT_Close_1:
   \   000000BC   ........           LDR      R0,??DataTable2
   \   000000C0   8400D0E5           LDRB     R0,[R0, #+132]
   \   000000C4   020050E3           CMP      R0,#+2
   \   000000C8   0200001A           BNE      ??FS_FAT_Close_2
    575                  FS_FAT_SyncFAT(pVolume, &SB);
   \   000000CC   0D10A0E1           MOV      R1,SP
   \   000000D0   0500A0E1           MOV      R0,R5
   \   000000D4   ........           BL       FS_FAT_SyncFAT
    576                }
    577          #if FS_USE_FILE_BUFFER
    578                FS_FAT_CleanWriteBuffer(pFile, NULL, 0, &SB);
   \                     ??FS_FAT_Close_2:
   \   000000D8   0D30A0E1           MOV      R3,SP
   \   000000DC   0020A0E3           MOV      R2,#+0
   \   000000E0   0010A0E3           MOV      R1,#+0
   \   000000E4   0400A0E1           MOV      R0,R4
   \   000000E8   ........           BL       FS_FAT_CleanWriteBuffer
    579          #endif
    580                FS__SB_Delete(&SB);
   \   000000EC   0D00A0E1           MOV      R0,SP
   \   000000F0   ........           BL       FS__SB_Delete
    581              }
    582            }
    583          }
   \                     ??FS_FAT_Close_0:
   \   000000F4   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000000F8   F080BDE8           POP      {R4-R7,PC}       ;; return
    584          
    585          /*********************************************************************
    586          *
    587          *       FS_FAT_Clean
    588          *
    589          *  Description:
    590          *    Cleans the fs of a volume. If any pending operations need to be done to
    591          *    the FAT FS (eg. Updating the FSInfo on FAT32 media), this is done
    592          *    in this function.
    593          *
    594          *  Parameters:
    595          *    pVolume       - Pointer to a mounted volume.
    596          *
    597          *  Return value:
    598          *    None.
    599          */

   \                                 In section .text, align 4, keep-with-next
    600          void FS_FAT_Clean(FS_VOLUME * pVolume) {
   \                     FS_FAT_Clean:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    601          #if FS_FAT_USE_FSINFO_SECTOR
    602            FS_FAT_INFO * pFATInfo;
    603            pFATInfo = &pVolume->FSInfo.FATInfo;
   \   00000004   1C4080E2           ADD      R4,R0,#+28
    604            if (pFATInfo->FATType == FS_FAT_TYPE_FAT32 && pFATInfo->FSInfoSectorIsInvalidated) {
   \   00000008   1E10D4E5           LDRB     R1,[R4, #+30]
   \   0000000C   14D04DE2           SUB      SP,SP,#+20
   \   00000010   200051E3           CMP      R1,#+32
   \   00000014   1800001A           BNE      ??FS_FAT_Clean_0
   \   00000018   BE12D4E1           LDRH     R1,[R4, #+46]
   \   0000001C   000051E3           CMP      R1,#+0
   \   00000020   1500000A           BEQ      ??FS_FAT_Clean_0
    605              FS_SB         SB;
    606              //
    607              // Update the FSInfo Sector on FAT32 medium.
    608              //
    609              FS__SB_Create(&SB, &pVolume->Partition);
   \   00000024   0010A0E1           MOV      R1,R0
   \   00000028   0D00A0E1           MOV      R0,SP
   \   0000002C   ........           BL       FS__SB_Create
    610              FS__SB_SetSector(&SB, pFATInfo->FSInfoSector, FS_SB_TYPE_DATA);
   \   00000030   0020A0E3           MOV      R2,#+0
   \   00000034   BC12D4E1           LDRH     R1,[R4, #+44]
   \   00000038   0D00A0E1           MOV      R0,SP
   \   0000003C   ........           BL       FS__SB_SetSector
    611              if (FS__SB_Read(&SB) == 0) {
   \   00000040   0D00A0E1           MOV      R0,SP
   \   00000044   ........           BL       FS__SB_Read
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0800001A           BNE      ??FS_FAT_Clean_1
    612                U8 * pBuffer;
    613          
    614                pBuffer = SB.pBuffer;
   \   00000050   08509DE5           LDR      R5,[SP, #+8]
    615                FS_StoreU32LE(&pBuffer[FSINFO_OFF_FREE_CLUSTERS],     pFATInfo->NumFreeClusters);
   \   00000054   241094E5           LDR      R1,[R4, #+36]
   \   00000058   7A0F85E2           ADD      R0,R5,#+488
   \   0000005C   ........           BL       FS_StoreU32LE
    616                FS_StoreU32LE(&pBuffer[FSINFO_OFF_NEXT_FREE_CLUSTER], pFATInfo->NextFreeCluster);
   \   00000060   281094E5           LDR      R1,[R4, #+40]
   \   00000064   7B0F85E2           ADD      R0,R5,#+492
   \   00000068   ........           BL       FS_StoreU32LE
    617                FS__SB_MarkDirty(&SB);
   \   0000006C   0D00A0E1           MOV      R0,SP
   \   00000070   ........           BL       FS__SB_MarkDirty
    618              }
    619              FS__SB_Delete(&SB);
   \                     ??FS_FAT_Clean_1:
   \   00000074   0D00A0E1           MOV      R0,SP
   \   00000078   ........           BL       FS__SB_Delete
    620            }
    621          #else
    622            FS_USE_PARA(pVolume);
    623          #endif
    624          }
   \                     ??FS_FAT_Clean_0:
   \   0000007C   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000080   3080BDE8           POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     FS_Global
    625          
    626          /*************************** End of file ****************************/
    627          

   Maximum stack usage in bytes:

     Function                     .cstack
     --------                     -------
     FS_FAT_Clean                     32
     FS_FAT_CleanWriteBuffer          32
     FS_FAT_Close                     40
     FS_FAT_GotoClusterAllocIfReq     40
     FS_FAT_UpdateDirEntry            16
     FS_FAT_Write                     56
     _WriteData                       72


   Section sizes:

     Function/Label               Bytes
     --------------               -----
     _WriteData                   1136
     FS_FAT_UpdateDirEntry         148
     FS_FAT_CleanWriteBuffer       244
     FS_FAT_GotoClusterAllocIfReq  312
     FS_FAT_Write                  160
     FS_FAT_Close                  252
     FS_FAT_Clean                  132
     ??DataTable2                    4

 
 2 388 bytes in section .text
 
 2 388 bytes of CODE memory

Errors: none
Warnings: none
