###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     14/Jul/2015  19:00:40 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_OXY_32.c                 #
#    Command line =  C:\DUII\TargetHW\GUI\GUIDRV_Lin_OXY_32.c -D DEBUG=1 -D   #
#                    SDRAM_TARGET=1 -D USB_IS_HIGH_SPEED -D                   #
#                    XIGNORE_TEMPERATURE -D BUILD_DEBUG_PORT -D PROFILER      #
#                    -lCN C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Li #
#                    st\ -o C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\ #
#                    Obj\ --debug --endian=little --cpu=ARM926EJ-S -e         #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\DUII\TargetHW\Application\SEGGERDEMO\ -I      #
#                    C:\DUII\TargetHW\Application\SEGGERDEMO\Src\ -I          #
#                    C:\DUII\TargetHW\Config\ -I C:\DUII\TargetHW\FS\ -I      #
#                    C:\DUII\TargetHW\GUI\ -I C:\DUII\TargetHW\Inc\ -I        #
#                    C:\DUII\TargetHW\OS\ -I C:\DUII\TargetHW\Setup\ -I       #
#                    \DUII\DUII\ -I \DUII\DUII\Graphics\ -I PROFILER\         #
#                    --cpu_mode arm -Ohs --use_c++_inline                     #
#                    --require_prototypes                                     #
#    List file    =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\List\GU #
#                    IDRV_Lin_OXY_32.lst                                      #
#    Object file  =  C:\DUII\TargetHW\Output\AT91SAM9RL64\Debug_SDRAM\Obj\GUI #
#                    DRV_Lin_OXY_32.o                                         #
#                                                                             #
#                                                                             #
###############################################################################

C:\DUII\TargetHW\GUI\GUIDRV_Lin_OXY_32.c
      1          /*********************************************************************
      2          *                SEGGER Microcontroller GmbH & Co. KG                *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2010  SEGGER Microcontroller GmbH & Co. KG       *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V5.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUIDRV_Lin_OXY_32.c
     19          Purpose     : Driver for accessing linear video memory
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stddef.h>
     24          
     25          #include "LCD_Private.h"
     26          #include "GUI_Private.h"
     27          #include "LCD_SIM.h"
     28          #include "LCD_ConfDefaults.h"
     29          
     30          #include "GUIDRV_Lin.h"
     31          
     32          #if (!defined(WIN32) | defined(LCD_SIMCONTROLLER))
     33          
     34          /*********************************************************************
     35          *
     36          *       Defines
     37          *
     38          **********************************************************************
     39          */
     40          #ifdef WIN32
     41            //
     42            // Simulation prototypes
     43            //
     44            U16  SIM_Lin_ReadMem16  (unsigned int Off);
     45            U32  SIM_Lin_ReadMem32  (unsigned int Off);
     46            U32  SIM_Lin_ReadMem32p (U32 * p);
     47            void SIM_Lin_WriteMem16 (unsigned int Off, U16 Data);
     48            void SIM_Lin_WriteMem32 (unsigned int Off, U32 Data);
     49            void SIM_Lin_WriteMem16p(U16 * p, U16 Data);
     50            void SIM_Lin_WriteMem32p(U32 * p, U32 Data);
     51            void SIM_Lin_memcpy     (void * pDst, const void * pSrc, int Len);
     52            void SIM_Lin_SetVRAMAddr(int LayerIndex, void * pVRAM);
     53            void SIM_Lin_SetVRAMSize(int LayerIndex, int xSize, int ySize);
     54            //
     55            // Access macro definition for internal simulation
     56            //
     57            #define LCD_READ_MEM16(VRAMAddr, Off)        SIM_Lin_ReadMem16(Off)
     58            #define LCD_READ_MEM32(VRAMAddr, Off)        SIM_Lin_ReadMem32(Off)
     59            #define LCD_READ_MEM32P(p)                   SIM_Lin_ReadMem32p(p)
     60            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) SIM_Lin_WriteMem16(Off, Data)
     61            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) SIM_Lin_WriteMem32(Off, Data)
     62            #define LCD_WRITE_MEM16P(p, Data)            SIM_Lin_WriteMem16p(p, Data)
     63            #define LCD_WRITE_MEM32P(p, Data)            SIM_Lin_WriteMem32p(p, Data)
     64            #undef  GUI_MEMCPY
     65            #define GUI_MEMCPY(pDst, pSrc, Len) SIM_Lin_memcpy(pDst, pSrc, Len)
     66          #else
     67            //
     68            // Access macro definition for hardware
     69            //
     70            #define LCD_READ_MEM16(VRAMAddr, Off)        (*((U16 *)VRAMAddr + (U32)Off))
     71            #define LCD_READ_MEM32(VRAMAddr, Off)        (*((U32 *)VRAMAddr + (U32)Off))
     72            #define LCD_READ_MEM32P(p)                   (*((U32 *)p))
     73            #define LCD_WRITE_MEM16(VRAMAddr, Off, Data) *((U16 *)VRAMAddr + (U32)Off) = Data
     74            #define LCD_WRITE_MEM32(VRAMAddr, Off, Data) *((U32 *)VRAMAddr + (U32)Off) = Data
     75            #define LCD_WRITE_MEM16P(p, Data)            *((U16 *)p) = Data
     76            #define LCD_WRITE_MEM32P(p, Data)            *((U32 *)p) = Data
     77          #endif
     78          
     79          #define WRITE_MEM16(VRAMAddr, Off, Data) LCD_WRITE_MEM16(VRAMAddr, Off, Data)
     80          #define WRITE_MEM32(VRAMAddr, Off, Data) LCD_WRITE_MEM32(VRAMAddr, Off, Data)
     81          #define READ_MEM16(VRAMAddr, Off)        LCD_READ_MEM16(VRAMAddr, Off)
     82          #define READ_MEM32(VRAMAddr, Off)        LCD_READ_MEM32(VRAMAddr, Off)
     83          #define READ_MEM32P(p)                   LCD_READ_MEM32P(p)
     84          #define WRITE_MEM16P(p, Data)            LCD_WRITE_MEM16P(p, Data)
     85          #define WRITE_MEM32P(p, Data)            LCD_WRITE_MEM32P(p, Data)
     86          
     87          #define OFF2PTR16(VRAMAddr, Off)     (U16 *)((U8 *)VRAMAddr + (Off << 1))
     88          #define OFF2PTR32(VRAMAddr, Off)     (U32 *)((U8 *)VRAMAddr + (Off << 2))
     89          
     90          #define XY2OFF16(vxSizePhys, x, y)    ((U32)y * (vxSizePhys << 1) + ((U32)x << 1))
     91          #define XY2OFF32(vxSizePhys, x, y)    ((U32)y *  vxSizePhys       +       x      )
     92          
     93          /*********************************************************************
     94          *
     95          *       Types
     96          *
     97          **********************************************************************
     98          */
     99          typedef struct {
    100            U32 VRAMAddr;
    101            int xSize, ySize;
    102            int vxSize, vySize;
    103            int vxSizePhys;
    104            int xPos, yPos;
    105            int Alpha;
    106            int IsVisible;
    107            void (* pfFillRect)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex);
    108          } DRIVER_CONTEXT;
    109          
    110          /*********************************************************************
    111          *
    112          *       Static functions
    113          *
    114          **********************************************************************
    115          */
    116          /*********************************************************************
    117          *
    118          *       _SetPixelIndex
    119          *
    120          * Purpose:
    121          *   Sets the index of the given pixel. The upper layers
    122          *   calling this routine make sure that the coordinates are in range, so
    123          *   that no check on the parameters needs to be performed.
    124          */

   \                                 In section .text, align 4, keep-with-next
    125          static void _SetPixelIndex(GUI_DEVICE * pDevice, int x, int y, int PixelIndex) {
   \                     _SetPixelIndex:
   \   00000000   00402DE9           PUSH     {LR}
    126            DRIVER_CONTEXT * pContext;
    127            U32 Off;
    128          
    129            //
    130            // Get context
    131            //
    132            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000004   080090E5           LDR      R0,[R0, #+8]
    133            //
    134            // Mirror x
    135            //
    136            x = (pContext->vxSize - 1 - (x));
    137            //
    138            // Mirror y
    139            //
    140            y = (pContext->vySize - 1 - (y));
    141            //
    142            // Write into hardware
    143            //
    144            Off      = XY2OFF32(pContext->vxSizePhys, x, y);
    145            WRITE_MEM32(pContext->VRAMAddr, Off, PixelIndex);
   \   00000008   10C090E5           LDR      R12,[R0, #+16]
   \   0000000C   0CE090E5           LDR      LR,[R0, #+12]
   \   00000010   01C04CE2           SUB      R12,R12,#+1
   \   00000014   02204CE0           SUB      R2,R12,R2
   \   00000018   14C090E5           LDR      R12,[R0, #+20]
   \   0000001C   000090E5           LDR      R0,[R0, #+0]
   \   00000020   9CE222E0           MLA      R2,R12,R2,LR
   \   00000024   012042E2           SUB      R2,R2,#+1
   \   00000028   011042E0           SUB      R1,R2,R1
   \   0000002C   013180E7           STR      R3,[R0, +R1, LSL #+2]
    146          }
   \   00000030   0080BDE8           POP      {PC}             ;; return
    147          
    148          /*********************************************************************
    149          *
    150          *       _GetPixelIndex
    151          *
    152          * Purpose:
    153          *   Returns the index of the given pixel. The upper layers
    154          *   calling this routine make sure that the coordinates are in range, so
    155          *   that no check on the parameters needs to be performed.
    156          */

   \                                 In section .text, align 4, keep-with-next
    157          static unsigned int _GetPixelIndex(GUI_DEVICE * pDevice, int x, int y) {
    158            DRIVER_CONTEXT * pContext;
    159            U32 Off;
    160            LCD_PIXELINDEX PixelIndex;
    161          
    162            //
    163            // Get context
    164            //
    165            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetPixelIndex:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    166            //
    167            // Mirror x
    168            //
    169            x = (pContext->vxSize - 1 - (x));
    170            //
    171            // Mirror y
    172            //
    173            y = (pContext->vySize - 1 - (y));
    174            //
    175            // Read from hardware
    176            //
    177            Off        = XY2OFF32(pContext->vxSizePhys, x, y);
    178            PixelIndex = READ_MEM32(pContext->VRAMAddr, Off);
    179            return PixelIndex;
   \   00000004   103090E5           LDR      R3,[R0, #+16]
   \   00000008   0CC090E5           LDR      R12,[R0, #+12]
   \   0000000C   013043E2           SUB      R3,R3,#+1
   \   00000010   022043E0           SUB      R2,R3,R2
   \   00000014   143090E5           LDR      R3,[R0, #+20]
   \   00000018   000090E5           LDR      R0,[R0, #+0]
   \   0000001C   93C222E0           MLA      R2,R3,R2,R12
   \   00000020   012042E2           SUB      R2,R2,#+1
   \   00000024   011042E0           SUB      R1,R2,R1
   \   00000028   010190E7           LDR      R0,[R0, +R1, LSL #+2]
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    180          }
    181          
    182          /*********************************************************************
    183          *
    184          *       _XorPixel
    185          */

   \                                 In section .text, align 4, keep-with-next
    186          static void _XorPixel(GUI_DEVICE * pDevice, int x, int y) {
   \                     _XorPixel:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0060A0E1           MOV      R6,R0
    187            LCD_PIXELINDEX PixelIndex;
    188            LCD_PIXELINDEX IndexMask;
    189          
    190            PixelIndex = _GetPixelIndex(pDevice, x, y);
   \   00000008   080096E5           LDR      R0,[R6, #+8]
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   101090E5           LDR      R1,[R0, #+16]
   \   00000014   0250A0E1           MOV      R5,R2
   \   00000018   011041E2           SUB      R1,R1,#+1
   \   0000001C   142090E5           LDR      R2,[R0, #+20]
   \   00000020   051041E0           SUB      R1,R1,R5
   \   00000024   0C3090E5           LDR      R3,[R0, #+12]
   \   00000028   923121E0           MLA      R1,R2,R1,R3
   \   0000002C   000090E5           LDR      R0,[R0, #+0]
   \   00000030   011041E2           SUB      R1,R1,#+1
   \   00000034   041041E0           SUB      R1,R1,R4
   \   00000038   017190E7           LDR      R7,[R0, +R1, LSL #+2]
    191            IndexMask  = pDevice->pColorConvAPI->pfGetIndexMask();
   \   0000003C   100096E5           LDR      R0,[R6, #+16]
   \   00000040   04D04DE2           SUB      SP,SP,#+4
   \   00000044   080090E5           LDR      R0,[R0, #+8]
   \   00000048   30FF2FE1           BLX      R0
    192            _SetPixelIndex(pDevice, x, y, PixelIndex ^ IndexMask);
   \   0000004C   081096E5           LDR      R1,[R6, #+8]
   \   00000050   070020E0           EOR      R0,R0,R7
   \   00000054   102091E5           LDR      R2,[R1, #+16]
   \   00000058   143091E5           LDR      R3,[R1, #+20]
   \   0000005C   012042E2           SUB      R2,R2,#+1
   \   00000060   052042E0           SUB      R2,R2,R5
   \   00000064   0CC091E5           LDR      R12,[R1, #+12]
   \   00000068   93C222E0           MLA      R2,R3,R2,R12
   \   0000006C   001091E5           LDR      R1,[R1, #+0]
   \   00000070   012042E2           SUB      R2,R2,#+1
   \   00000074   042042E0           SUB      R2,R2,R4
   \   00000078   020181E7           STR      R0,[R1, +R2, LSL #+2]
    193          }
   \   0000007C   04D08DE2           ADD      SP,SP,#+4
   \   00000080   F080BDE8           POP      {R4-R7,PC}       ;; return
    194          
    195          /*********************************************************************
    196          *
    197          *       _DrawHLine
    198          */

   \                                 In section .text, align 4, keep-with-next
    199          static void _DrawHLine  (GUI_DEVICE * pDevice, int x0, int y,  int x1) {
   \                     _DrawHLine:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0070A0E1           MOV      R7,R0
    200            DRIVER_CONTEXT * pContext;
    201            register LCD_PIXELINDEX Color;
    202            U32 * pDest;
    203            U32 Off, RemPixels;
    204            int temp;
    205            LCD_PIXELINDEX ColorIndex;
    206          
    207            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable16
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0240A0E1           MOV      R4,R2
   \   00000018   0350A0E1           MOV      R5,R3
   \   0000001C   010010E3           TST      R0,#0x1
   \   00000020   1F00000A           BEQ      ??_DrawHLine_0
   \   00000024   060055E1           CMP      R5,R6
   \   00000028   480000BA           BLT      ??_DrawHLine_1
    208              for (; x0 <= x1; x0++) {
    209                _XorPixel(pDevice, x0, y);
   \                     ??_DrawHLine_2:
   \   0000002C   080097E5           LDR      R0,[R7, #+8]
   \   00000030   102090E5           LDR      R2,[R0, #+16]
   \   00000034   143090E5           LDR      R3,[R0, #+20]
   \   00000038   012042E2           SUB      R2,R2,#+1
   \   0000003C   0C1090E5           LDR      R1,[R0, #+12]
   \   00000040   042042E0           SUB      R2,R2,R4
   \   00000044   931221E0           MLA      R1,R3,R2,R1
   \   00000048   000090E5           LDR      R0,[R0, #+0]
   \   0000004C   011041E2           SUB      R1,R1,#+1
   \   00000050   061041E0           SUB      R1,R1,R6
   \   00000054   018190E7           LDR      R8,[R0, +R1, LSL #+2]
   \   00000058   100097E5           LDR      R0,[R7, #+16]
   \   0000005C   080090E5           LDR      R0,[R0, #+8]
   \   00000060   30FF2FE1           BLX      R0
   \   00000064   081097E5           LDR      R1,[R7, #+8]
   \   00000068   080020E0           EOR      R0,R0,R8
   \   0000006C   103091E5           LDR      R3,[R1, #+16]
   \   00000070   14C091E5           LDR      R12,[R1, #+20]
   \   00000074   013043E2           SUB      R3,R3,#+1
   \   00000078   0C2091E5           LDR      R2,[R1, #+12]
   \   0000007C   043043E0           SUB      R3,R3,R4
   \   00000080   9C2322E0           MLA      R2,R12,R3,R2
   \   00000084   001091E5           LDR      R1,[R1, #+0]
   \   00000088   012042E2           SUB      R2,R2,#+1
   \   0000008C   062042E0           SUB      R2,R2,R6
    210              }
   \   00000090   016086E2           ADD      R6,R6,#+1
   \   00000094   020181E7           STR      R0,[R1, +R2, LSL #+2]
   \   00000098   060055E1           CMP      R5,R6
   \   0000009C   E2FFFFAA           BGE      ??_DrawHLine_2
   \   000000A0   F081BDE8           POP      {R4-R8,PC}
    211            } else {
    212              ColorIndex = LCD__GetColorIndex();
    213              //
    214              // Get context
    215              //
    216              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     ??_DrawHLine_0:
   \   000000A4   082097E5           LDR      R2,[R7, #+8]
    217              //
    218              // Mirror x
    219              //
    220              temp = x0;
   \   000000A8   0C3092E5           LDR      R3,[R2, #+12]
    221              x0 = (pContext->vxSize - 1 - x1);
    222              x1 = (pContext->vxSize - 1 - temp);
    223              //
    224              // Mirror y
    225              //
    226              y = (pContext->vySize - 1 - y);
    227              Color = ColorIndex;
    228              Off = XY2OFF32(pContext->vxSizePhys, x0, y);
    229              pDest = OFF2PTR32(pContext->VRAMAddr, Off);
   \   000000AC   10C092E5           LDR      R12,[R2, #+16]
   \   000000B0   013043E2           SUB      R3,R3,#+1
   \   000000B4   01C04CE2           SUB      R12,R12,#+1
   \   000000B8   14E092E5           LDR      LR,[R2, #+20]
   \   000000BC   ........           LDR      R0,??DataTable16_1
   \   000000C0   056043E0           SUB      R6,R3,R5
   \   000000C4   04C04CE0           SUB      R12,R12,R4
   \   000000C8   9E6C2CE0           MLA      R12,LR,R12,R6
    230              RemPixels = x1 - x0 + 1;
   \   000000CC   011043E0           SUB      R1,R3,R1
   \   000000D0   000090E5           LDR      R0,[R0, #+0]
   \   000000D4   002092E5           LDR      R2,[R2, #+0]
   \   000000D8   061041E0           SUB      R1,R1,R6
   \   000000DC   011081E2           ADD      R1,R1,#+1
   \   000000E0   000090E5           LDR      R0,[R0, #+0]
   \   000000E4   0C2182E0           ADD      R2,R2,R12, LSL #+2
    231              if (RemPixels >= 16) {
   \   000000E8   100051E3           CMP      R1,#+16
   \   000000EC   1200003A           BCC      ??_DrawHLine_3
    232                do {
    233                  WRITE_MEM32P(pDest     , Color);
   \                     ??_DrawHLine_4:
   \   000000F0   040082E4           STR      R0,[R2], #+4
    234                  WRITE_MEM32P(pDest +  1, Color);
   \   000000F4   040082E4           STR      R0,[R2], #+4
    235                  WRITE_MEM32P(pDest +  2, Color);
   \   000000F8   040082E4           STR      R0,[R2], #+4
    236                  WRITE_MEM32P(pDest +  3, Color);
   \   000000FC   040082E4           STR      R0,[R2], #+4
    237                  WRITE_MEM32P(pDest +  4, Color);
   \   00000100   040082E4           STR      R0,[R2], #+4
    238                  WRITE_MEM32P(pDest +  5, Color);
   \   00000104   040082E4           STR      R0,[R2], #+4
    239                  WRITE_MEM32P(pDest +  6, Color);
   \   00000108   040082E4           STR      R0,[R2], #+4
    240                  WRITE_MEM32P(pDest +  7, Color);
   \   0000010C   040082E4           STR      R0,[R2], #+4
    241                  WRITE_MEM32P(pDest +  8, Color);
   \   00000110   040082E4           STR      R0,[R2], #+4
    242                  WRITE_MEM32P(pDest +  9, Color);
   \   00000114   040082E4           STR      R0,[R2], #+4
    243                  WRITE_MEM32P(pDest + 10, Color);
   \   00000118   040082E4           STR      R0,[R2], #+4
    244                  WRITE_MEM32P(pDest + 11, Color);
   \   0000011C   040082E4           STR      R0,[R2], #+4
    245                  WRITE_MEM32P(pDest + 12, Color);
   \   00000120   040082E4           STR      R0,[R2], #+4
    246                  WRITE_MEM32P(pDest + 13, Color);
   \   00000124   040082E4           STR      R0,[R2], #+4
    247                  WRITE_MEM32P(pDest + 14, Color);
   \   00000128   040082E4           STR      R0,[R2], #+4
    248                  WRITE_MEM32P(pDest + 15, Color);
    249                  pDest += 16;
    250                  RemPixels -= 16;
   \   0000012C   101041E2           SUB      R1,R1,#+16
   \   00000130   040082E4           STR      R0,[R2], #+4
    251                } while (RemPixels >= 16);
   \   00000134   100051E3           CMP      R1,#+16
   \   00000138   ECFFFF2A           BCS      ??_DrawHLine_4
    252              }
    253              if (RemPixels) {
   \                     ??_DrawHLine_3:
   \   0000013C   000051E3           CMP      R1,#+0
   \   00000140   0200000A           BEQ      ??_DrawHLine_1
    254                do {
    255                  WRITE_MEM32P(pDest, ColorIndex);
   \                     ??_DrawHLine_5:
   \   00000144   040082E4           STR      R0,[R2], #+4
    256                  pDest++;
    257                } while (--RemPixels);
   \   00000148   011051E2           SUBS     R1,R1,#+1
   \   0000014C   FCFFFF1A           BNE      ??_DrawHLine_5
    258              }
    259            }
    260          }
   \                     ??_DrawHLine_1:
   \   00000150   F081BDE8           POP      {R4-R8,PC}       ;; return
    261          
    262          /*********************************************************************
    263          *
    264          *       _DrawVLine, not optimized
    265          */

   \                                 In section .text, align 4, keep-with-next
    266          static void _DrawVLine  (GUI_DEVICE * pDevice, int x, int y0,  int y1) {
   \                     _DrawVLine:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    267            LCD_PIXELINDEX ColorIndex;
    268          
    269            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable16
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   0370A0E1           MOV      R7,R3
   \   0000001C   010010E3           TST      R0,#0x1
   \   00000020   1F00000A           BEQ      ??_DrawVLine_0
   \   00000024   060057E1           CMP      R7,R6
   \   00000028   300000BA           BLT      ??_DrawVLine_1
    270              for (; y0 <= y1; y0++) {
    271                _XorPixel(pDevice, x, y0);
   \                     ??_DrawVLine_2:
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   102090E5           LDR      R2,[R0, #+16]
   \   00000034   143090E5           LDR      R3,[R0, #+20]
   \   00000038   012042E2           SUB      R2,R2,#+1
   \   0000003C   0C1090E5           LDR      R1,[R0, #+12]
   \   00000040   062042E0           SUB      R2,R2,R6
   \   00000044   931221E0           MLA      R1,R3,R2,R1
   \   00000048   000090E5           LDR      R0,[R0, #+0]
   \   0000004C   011041E2           SUB      R1,R1,#+1
   \   00000050   051041E0           SUB      R1,R1,R5
   \   00000054   018190E7           LDR      R8,[R0, +R1, LSL #+2]
   \   00000058   100094E5           LDR      R0,[R4, #+16]
   \   0000005C   080090E5           LDR      R0,[R0, #+8]
   \   00000060   30FF2FE1           BLX      R0
   \   00000064   081094E5           LDR      R1,[R4, #+8]
   \   00000068   080020E0           EOR      R0,R0,R8
   \   0000006C   103091E5           LDR      R3,[R1, #+16]
   \   00000070   14C091E5           LDR      R12,[R1, #+20]
   \   00000074   013043E2           SUB      R3,R3,#+1
   \   00000078   0C2091E5           LDR      R2,[R1, #+12]
   \   0000007C   063043E0           SUB      R3,R3,R6
   \   00000080   9C2322E0           MLA      R2,R12,R3,R2
   \   00000084   001091E5           LDR      R1,[R1, #+0]
   \   00000088   012042E2           SUB      R2,R2,#+1
   \   0000008C   052042E0           SUB      R2,R2,R5
    272              }
   \   00000090   016086E2           ADD      R6,R6,#+1
   \   00000094   020181E7           STR      R0,[R1, +R2, LSL #+2]
   \   00000098   060057E1           CMP      R7,R6
   \   0000009C   E2FFFFAA           BGE      ??_DrawVLine_2
   \   000000A0   F081BDE8           POP      {R4-R8,PC}
    273            } else {
    274              ColorIndex = LCD__GetColorIndex();
   \                     ??_DrawVLine_0:
   \   000000A4   ........           LDR      R0,??DataTable16_1
   \   000000A8   060057E1           CMP      R7,R6
   \   000000AC   000090E5           LDR      R0,[R0, #+0]
   \   000000B0   000090E5           LDR      R0,[R0, #+0]
   \   000000B4   0D0000BA           BLT      ??_DrawVLine_1
    275              for (; y0 <= y1; y0++) {
    276                _SetPixelIndex(pDevice, x, y0, ColorIndex);
   \                     ??_DrawVLine_3:
   \   000000B8   081094E5           LDR      R1,[R4, #+8]
   \   000000BC   103091E5           LDR      R3,[R1, #+16]
   \   000000C0   14C091E5           LDR      R12,[R1, #+20]
   \   000000C4   013043E2           SUB      R3,R3,#+1
   \   000000C8   0C2091E5           LDR      R2,[R1, #+12]
   \   000000CC   063043E0           SUB      R3,R3,R6
   \   000000D0   9C2322E0           MLA      R2,R12,R3,R2
   \   000000D4   001091E5           LDR      R1,[R1, #+0]
   \   000000D8   012042E2           SUB      R2,R2,#+1
   \   000000DC   052042E0           SUB      R2,R2,R5
    277              }
   \   000000E0   016086E2           ADD      R6,R6,#+1
   \   000000E4   020181E7           STR      R0,[R1, +R2, LSL #+2]
   \   000000E8   060057E1           CMP      R7,R6
   \   000000EC   F1FFFFAA           BGE      ??_DrawVLine_3
    278            }
    279          }
   \                     ??_DrawVLine_1:
   \   000000F0   F081BDE8           POP      {R4-R8,PC}       ;; return
    280          
    281          /*********************************************************************
    282          *
    283          *       _FillRect
    284          */

   \                                 In section .text, align 4, keep-with-next
    285          static void _FillRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1) {
   \                     _FillRect:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0080A0E1           MOV      R8,R0
    286            DRIVER_CONTEXT * pContext;
    287            register LCD_PIXELINDEX Color;
    288            U32 * pDest;
    289            U32 Off, RemPixels;
    290            int temp;
    291            LCD_PIXELINDEX ColorIndex;
    292          
    293            if (GUI_Context.DrawMode & LCD_DRAWMODE_XOR) {
   \   00000008   ........           LDR      R0,??DataTable16
   \   0000000C   0170A0E1           MOV      R7,R1
   \   00000010   1000D0E5           LDRB     R0,[R0, #+16]
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   0340A0E1           MOV      R4,R3
   \   0000001C   18509DE5           LDR      R5,[SP, #+24]
   \   00000020   010010E3           TST      R0,#0x1
   \   00000024   0A00000A           BEQ      ??_FillRect_0
   \   00000028   060055E1           CMP      R5,R6
   \   0000002C   3A0000BA           BLT      ??_FillRect_1
    294              for (; y0 <= y1; y0++) {
    295                _DrawHLine(pDevice, x0, y0, x1);
   \                     ??_FillRect_2:
   \   00000030   0430A0E1           MOV      R3,R4
   \   00000034   0620A0E1           MOV      R2,R6
   \   00000038   0710A0E1           MOV      R1,R7
   \   0000003C   0800A0E1           MOV      R0,R8
   \   00000040   ........           BL       _DrawHLine
    296              }
   \   00000044   016086E2           ADD      R6,R6,#+1
   \   00000048   060055E1           CMP      R5,R6
   \   0000004C   F7FFFFAA           BGE      ??_FillRect_2
   \   00000050   F081BDE8           POP      {R4-R8,PC}
    297            } else {
    298              ColorIndex = LCD__GetColorIndex();
    299              //
    300              // Get context
    301              //
    302              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     ??_FillRect_0:
   \   00000054   081098E5           LDR      R1,[R8, #+8]
    303              //
    304              // Mirror x
    305              //
    306              temp = x0;
   \   00000058   0720A0E1           MOV      R2,R7
   \   0000005C   0C3091E5           LDR      R3,[R1, #+12]
   \   00000060   ........           LDR      R0,??DataTable16_1
   \   00000064   013043E2           SUB      R3,R3,#+1
   \   00000068   047043E0           SUB      R7,R3,R4
    307              x0 = (pContext->vxSize - 1 - x1);
    308              x1 = (pContext->vxSize - 1 - temp);
   \   0000006C   024043E0           SUB      R4,R3,R2
    309              //
    310              // Mirror y
    311              //
    312              temp = y0;
   \   00000070   103091E5           LDR      R3,[R1, #+16]
   \   00000074   0620A0E1           MOV      R2,R6
   \   00000078   013043E2           SUB      R3,R3,#+1
   \   0000007C   056043E0           SUB      R6,R3,R5
   \   00000080   000090E5           LDR      R0,[R0, #+0]
    313              y0 = (pContext->vySize - 1 - y1);
    314              y1 = (pContext->vySize - 1 - temp);
   \   00000084   025043E0           SUB      R5,R3,R2
    315              Color = ColorIndex;
   \   00000088   072044E0           SUB      R2,R4,R7
   \   0000008C   000090E5           LDR      R0,[R0, #+0]
   \   00000090   012082E2           ADD      R2,R2,#+1
    316              do {
    317                Off = XY2OFF32(pContext->vxSizePhys, x0, y0);
    318                pDest = OFF2PTR32(pContext->VRAMAddr, Off);
   \                     ??_FillRect_3:
   \   00000094   143091E5           LDR      R3,[R1, #+20]
   \   00000098   93762CE0           MLA      R12,R3,R6,R7
   \   0000009C   003091E5           LDR      R3,[R1, #+0]
   \   000000A0   0C3183E0           ADD      R3,R3,R12, LSL #+2
    319                RemPixels = x1 - x0 + 1;
   \   000000A4   02C0A0E1           MOV      R12,R2
    320                if (RemPixels >= 16) {
   \   000000A8   10005CE3           CMP      R12,#+16
   \   000000AC   1200003A           BCC      ??_FillRect_4
    321                  do {
    322                    WRITE_MEM32P(pDest     , Color);
   \                     ??_FillRect_5:
   \   000000B0   040083E4           STR      R0,[R3], #+4
    323                    WRITE_MEM32P(pDest +  1, Color);
   \   000000B4   040083E4           STR      R0,[R3], #+4
    324                    WRITE_MEM32P(pDest +  2, Color);
   \   000000B8   040083E4           STR      R0,[R3], #+4
    325                    WRITE_MEM32P(pDest +  3, Color);
   \   000000BC   040083E4           STR      R0,[R3], #+4
    326                    WRITE_MEM32P(pDest +  4, Color);
   \   000000C0   040083E4           STR      R0,[R3], #+4
    327                    WRITE_MEM32P(pDest +  5, Color);
   \   000000C4   040083E4           STR      R0,[R3], #+4
    328                    WRITE_MEM32P(pDest +  6, Color);
   \   000000C8   040083E4           STR      R0,[R3], #+4
    329                    WRITE_MEM32P(pDest +  7, Color);
   \   000000CC   040083E4           STR      R0,[R3], #+4
    330                    WRITE_MEM32P(pDest +  8, Color);
   \   000000D0   040083E4           STR      R0,[R3], #+4
    331                    WRITE_MEM32P(pDest +  9, Color);
   \   000000D4   040083E4           STR      R0,[R3], #+4
    332                    WRITE_MEM32P(pDest + 10, Color);
   \   000000D8   040083E4           STR      R0,[R3], #+4
    333                    WRITE_MEM32P(pDest + 11, Color);
   \   000000DC   040083E4           STR      R0,[R3], #+4
    334                    WRITE_MEM32P(pDest + 12, Color);
   \   000000E0   040083E4           STR      R0,[R3], #+4
    335                    WRITE_MEM32P(pDest + 13, Color);
   \   000000E4   040083E4           STR      R0,[R3], #+4
    336                    WRITE_MEM32P(pDest + 14, Color);
   \   000000E8   040083E4           STR      R0,[R3], #+4
    337                    WRITE_MEM32P(pDest + 15, Color);
    338                    pDest += 16;
    339                    RemPixels -= 16;
   \   000000EC   10C04CE2           SUB      R12,R12,#+16
   \   000000F0   040083E4           STR      R0,[R3], #+4
    340                  } while (RemPixels >= 16);
   \   000000F4   10005CE3           CMP      R12,#+16
   \   000000F8   ECFFFF2A           BCS      ??_FillRect_5
    341                }
    342                if (RemPixels) {
   \                     ??_FillRect_4:
   \   000000FC   00005CE3           CMP      R12,#+0
   \   00000100   0200000A           BEQ      ??_FillRect_6
    343                  do {
    344                    WRITE_MEM32P(pDest, ColorIndex);
   \                     ??_FillRect_7:
   \   00000104   040083E4           STR      R0,[R3], #+4
    345                    pDest++;
    346                  } while (--RemPixels);
   \   00000108   01C05CE2           SUBS     R12,R12,#+1
   \   0000010C   FCFFFF1A           BNE      ??_FillRect_7
    347                }
    348              } while (++y0 <= y1);
   \                     ??_FillRect_6:
   \   00000110   016086E2           ADD      R6,R6,#+1
   \   00000114   060055E1           CMP      R5,R6
   \   00000118   DDFFFFAA           BGE      ??_FillRect_3
    349            }
    350          }
   \                     ??_FillRect_1:
   \   0000011C   F081BDE8           POP      {R4-R8,PC}       ;; return
    351          
    352          /*********************************************************************
    353          *
    354          *       Draw Bitmap 1 BPP
    355          */

   \                                 In section .text, align 4, keep-with-next
    356          static void _DrawBitLine1BPP(GUI_DEVICE * pDevice, unsigned x, unsigned y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine1BPP:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   28709DE5           LDR      R7,[SP, #+40]
   \   0000000C   0250A0E1           MOV      R5,R2
    357            DRIVER_CONTEXT * pContext;
    358            LCD_PIXELINDEX Index0, Index1, IndexMask;
    359            U32 * pDest;
    360            U32 Color;
    361            unsigned Pixels, PixelCnt, Off;
    362          
    363            Index0 = *(pTrans + 0);
    364            Index1 = *(pTrans + 1);
    365            //
    366            // Get context
    367            //
    368            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    369            x += Diff;
   \   00000010   019087E0           ADD      R9,R7,R1
    370            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000014   ........           LDR      R1,??DataTable16
   \   00000018   30209DE5           LDR      R2,[SP, #+48]
   \   0000001C   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000020   0040A0E1           MOV      R4,R0
   \   00000024   0360A0E1           MOV      R6,R3
   \   00000028   000092E5           LDR      R0,[R2, #+0]
   \   0000002C   031001E2           AND      R1,R1,#0x3
   \   00000030   2C809DE5           LDR      R8,[SP, #+44]
   \   00000034   042092E5           LDR      R2,[R2, #+4]
   \   00000038   083094E5           LDR      R3,[R4, #+8]
   \   0000003C   030051E3           CMP      R1,#+3
   \   00000040   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_DrawBitLine1BPP_0:
   \   00000044   5B00008A           BHI      ??_DrawBitLine1BPP_1
   \   00000048   020000EA           B        ??_DrawBitLine1BPP_2
   \   0000004C   360000EA           B        ??_DrawBitLine1BPP_3
   \   00000050   1B0000EA           B        ??_DrawBitLine1BPP_4
   \   00000054   340000EA           B        ??_DrawBitLine1BPP_3
    371            case 0:
    372              //
    373              // Mirror x
    374              //
    375              x = (pContext->vxSize - 1 - (x));
    376              //
    377              // Mirror y
    378              //
    379              y = (pContext->vySize - 1 - y);
    380              PixelCnt = 8 - Diff;
    381              Pixels   = LCD_aMirror[*p] >> Diff;
   \                     ??_DrawBitLine1BPP_2:
   \   00000058   00E0D6E5           LDRB     LR,[R6, #+0]
   \   0000005C   ........           LDR      R12,??DataTable16_2
    382              Off      = XY2OFF32(pContext->vxSizePhys, x, y);
    383              pDest    = OFF2PTR32(pContext->VRAMAddr, Off);
   \   00000060   104093E5           LDR      R4,[R3, #+16]
   \   00000064   0CE0DEE7           LDRB     LR,[LR, +R12]
   \   00000068   081067E2           RSB      R1,R7,#+8
   \   0000006C   014044E2           SUB      R4,R4,#+1
   \   00000070   5EE7A0E1           ASR      LR,LR,R7
   \   00000074   054044E0           SUB      R4,R4,R5
   \   00000078   0C7093E5           LDR      R7,[R3, #+12]
   \   0000007C   145093E5           LDR      R5,[R3, #+20]
   \   00000080   017047E2           SUB      R7,R7,#+1
   \   00000084   957424E0           MLA      R4,R5,R4,R7
   \   00000088   003093E5           LDR      R3,[R3, #+0]
   \   0000008C   094044E0           SUB      R4,R4,R9
   \   00000090   043183E0           ADD      R3,R3,R4, LSL #+2
    384              do {
    385                Color    = (Pixels & 1) ? Index1 : Index0;
   \                     ??_DrawBitLine1BPP_5:
   \   00000094   01001EE3           TST      LR,#0x1
   \   00000098   0240A011           MOVNE    R4,R2
   \   0000009C   0040A001           MOVEQ    R4,R0
    386                Pixels >>= 1;
    387                if (--PixelCnt == 0) {
   \   000000A0   011051E2           SUBS     R1,R1,#+1
    388                  Pixels = LCD_aMirror[*(++p)];
   \   000000A4   0110F605           LDRBEQ   R1,[R6, #+1]!
   \   000000A8   AEE0A0E1           LSR      LR,LR,#+1
   \   000000AC   0CE0D107           LDRBEQ   LR,[R1, +R12]
    389                  PixelCnt = 8;
   \   000000B0   0810A003           MOVEQ    R1,#+8
    390                }
    391                WRITE_MEM32P(pDest, Color);
   \   000000B4   044003E4           STR      R4,[R3], #-4
    392                pDest--;
    393              } while (--xsize);
   \   000000B8   018058E2           SUBS     R8,R8,#+1
   \   000000BC   F4FFFF1A           BNE      ??_DrawBitLine1BPP_5
   \   000000C0   3C0000EA           B        ??_DrawBitLine1BPP_1
    394              break;
    395            case LCD_DRAWMODE_TRANS:
    396              //
    397              // Mirror x
    398              //
    399              x = (pContext->vxSize - 1 - (x));
    400              //
    401              // Mirror y
    402              //
    403              y = (pContext->vySize - 1 - y);
    404              PixelCnt = 8 - Diff;
    405              Pixels   = LCD_aMirror[*p] >> Diff;
   \                     ??_DrawBitLine1BPP_4:
   \   000000C4   0000D6E5           LDRB     R0,[R6, #+0]
   \   000000C8   ........           LDR      R12,??DataTable16_2
    406              Off      = XY2OFF32(pContext->vxSizePhys, x, y);
    407              pDest    = OFF2PTR32(pContext->VRAMAddr, Off);
   \   000000CC   144093E5           LDR      R4,[R3, #+20]
   \   000000D0   0C00D0E7           LDRB     R0,[R0, +R12]
   \   000000D4   081067E2           RSB      R1,R7,#+8
   \   000000D8   50E7A0E1           ASR      LR,R0,R7
   \   000000DC   100093E5           LDR      R0,[R3, #+16]
   \   000000E0   010040E2           SUB      R0,R0,#+1
   \   000000E4   050040E0           SUB      R0,R0,R5
   \   000000E8   0C5093E5           LDR      R5,[R3, #+12]
   \   000000EC   003093E5           LDR      R3,[R3, #+0]
   \   000000F0   015045E2           SUB      R5,R5,#+1
   \   000000F4   945020E0           MLA      R0,R4,R0,R5
   \   000000F8   090040E0           SUB      R0,R0,R9
   \   000000FC   003183E0           ADD      R3,R3,R0, LSL #+2
    408              do {
    409                if (Pixels & 1) {
   \                     ??_DrawBitLine1BPP_6:
   \   00000100   01001EE3           TST      LR,#0x1
    410                  WRITE_MEM32P(pDest, Index1);
   \   00000104   00208315           STRNE    R2,[R3, #+0]
    411                }
    412                pDest--;
    413                Pixels >>= 1;
    414                if (--PixelCnt == 0) {
   \   00000108   011051E2           SUBS     R1,R1,#+1
    415                  Pixels = LCD_aMirror[*(++p)];
   \   0000010C   0100F605           LDRBEQ   R0,[R6, #+1]!
   \   00000110   AEE0A0E1           LSR      LR,LR,#+1
    416                  PixelCnt = 8;
   \   00000114   0810A003           MOVEQ    R1,#+8
   \   00000118   0CE0D007           LDRBEQ   LR,[R0, +R12]
   \   0000011C   043043E2           SUB      R3,R3,#+4
    417                }
    418              } while (--xsize);
   \   00000120   018058E2           SUBS     R8,R8,#+1
   \   00000124   F5FFFF1A           BNE      ??_DrawBitLine1BPP_6
   \   00000128   220000EA           B        ??_DrawBitLine1BPP_1
    419              break;
    420            case LCD_DRAWMODE_XOR | LCD_DRAWMODE_TRANS:
    421            case LCD_DRAWMODE_XOR:
    422              IndexMask = pDevice->pColorConvAPI->pfGetIndexMask();
   \                     ??_DrawBitLine1BPP_3:
   \   0000012C   100094E5           LDR      R0,[R4, #+16]
   \   00000130   080090E5           LDR      R0,[R0, #+8]
   \   00000134   30FF2FE1           BLX      R0
   \   00000138   8010A0E3           MOV      R1,#+128
    423              do {
    424                if (*p & (0x80 >> Diff)) {
   \                     ??_DrawBitLine1BPP_7:
   \   0000013C   0020D6E5           LDRB     R2,[R6, #+0]
   \   00000140   510712E1           TST      R2,R1, ASR R7
   \   00000144   1400000A           BEQ      ??_DrawBitLine1BPP_8
    425                  int Pixel = _GetPixelIndex(pDevice, x, y);
   \   00000148   082094E5           LDR      R2,[R4, #+8]
    426                  _SetPixelIndex(pDevice, x, y, Pixel ^ IndexMask);
   \   0000014C   10C092E5           LDR      R12,[R2, #+16]
   \   00000150   10A092E5           LDR      R10,[R2, #+16]
   \   00000154   01C04CE2           SUB      R12,R12,#+1
   \   00000158   14E092E5           LDR      LR,[R2, #+20]
   \   0000015C   0C3092E5           LDR      R3,[R2, #+12]
   \   00000160   05C04CE0           SUB      R12,R12,R5
   \   00000164   01A04AE2           SUB      R10,R10,#+1
   \   00000168   9E3C23E0           MLA      R3,LR,R12,R3
   \   0000016C   05B04AE0           SUB      R11,R10,R5
   \   00000170   14A092E5           LDR      R10,[R2, #+20]
   \   00000174   0CC092E5           LDR      R12,[R2, #+12]
   \   00000178   9ACB2CE0           MLA      R12,R10,R11,R12
   \   0000017C   013043E2           SUB      R3,R3,#+1
   \   00000180   09E043E0           SUB      LR,R3,R9
   \   00000184   003092E5           LDR      R3,[R2, #+0]
   \   00000188   01C04CE2           SUB      R12,R12,#+1
   \   0000018C   09C04CE0           SUB      R12,R12,R9
   \   00000190   0C2193E7           LDR      R2,[R3, +R12, LSL #+2]
   \   00000194   022020E0           EOR      R2,R0,R2
   \   00000198   0E2183E7           STR      R2,[R3, +LR, LSL #+2]
    427                }
    428                x++;
    429                if (++Diff == 8) {
   \                     ??_DrawBitLine1BPP_8:
   \   0000019C   017087E2           ADD      R7,R7,#+1
   \   000001A0   080057E3           CMP      R7,#+8
    430                  Diff = 0;
   \   000001A4   0070A003           MOVEQ    R7,#+0
    431                  p++;
   \   000001A8   01608602           ADDEQ    R6,R6,#+1
   \   000001AC   019089E2           ADD      R9,R9,#+1
    432                }
    433              } while (--xsize);
   \   000001B0   018058E2           SUBS     R8,R8,#+1
   \   000001B4   E0FFFF1A           BNE      ??_DrawBitLine1BPP_7
    434              break;
    435            }
    436          }
   \                     ??_DrawBitLine1BPP_1:
   \   000001B8   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000001BC   F08FBDE8           POP      {R4-R11,PC}      ;; return
    437          
    438          /*********************************************************************
    439          *
    440          *       Draw Bitmap 2 BPP
    441          */

   \                                 In section .text, align 4, keep-with-next
    442          static void  _DrawBitLine2BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine2BPP:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   1C409DE5           LDR      R4,[SP, #+28]
   \   00000008   14C09DE5           LDR      R12,[SP, #+20]
   \   0000000C   18E09DE5           LDR      LR,[SP, #+24]
    443            DRIVER_CONTEXT * pContext;
    444            LCD_PIXELINDEX Pixels, PixelIndex;
    445            int CurrentPixel, Shift, Index;
    446            U32 * pDest;
    447            U32 Off;
    448          
    449            if (pTrans == NULL) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   3300000A           BEQ      ??_DrawBitLine2BPP_0
    450              return; // pTrans is required
    451            }
    452            //
    453            // Get context
    454            //
    455            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000018   085090E5           LDR      R5,[R0, #+8]
    456            CurrentPixel = Diff;
    457            Pixels       = *p;
   \   0000001C   0000D3E5           LDRB     R0,[R3, #+0]
    458            x           += Diff;
    459            //
    460            // Mirror x
    461            //
    462            x = (pContext->vxSize - 1 - (x));
    463            //
    464            // Mirror y
    465            //
    466            y = (pContext->vySize - 1 - y);
    467            Off          = XY2OFF32(pContext->vxSizePhys, x, y);
    468            pDest        = OFF2PTR32(pContext->VRAMAddr, Off);
   \   00000020   106095E5           LDR      R6,[R5, #+16]
   \   00000024   0C7095E5           LDR      R7,[R5, #+12]
   \   00000028   016046E2           SUB      R6,R6,#+1
   \   0000002C   022046E0           SUB      R2,R6,R2
   \   00000030   017047E2           SUB      R7,R7,#+1
   \   00000034   146095E5           LDR      R6,[R5, #+20]
   \   00000038   011047E0           SUB      R1,R7,R1
   \   0000003C   0C1041E0           SUB      R1,R1,R12
   \   00000040   961221E0           MLA      R1,R6,R2,R1
   \   00000044   002095E5           LDR      R2,[R5, #+0]
   \   00000048   011182E0           ADD      R1,R2,R1, LSL #+2
    469            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   0000004C   ........           LDR      R2,??DataTable16
   \   00000050   1020D2E5           LDRB     R2,[R2, #+16]
   \   00000054   032012E2           ANDS     R2,R2,#0x3
   \   00000058   0200000A           BEQ      ??_DrawBitLine2BPP_1
   \   0000005C   022052E2           SUBS     R2,R2,#+2
   \   00000060   1000000A           BEQ      ??_DrawBitLine2BPP_2
   \   00000064   F080BDE8           POP      {R4-R7,PC}
    470            case 0:
    471              do {
    472                Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_1:
   \   00000068   03206CE2           RSB      R2,R12,#+3
   \   0000006C   8220A0E1           LSL      R2,R2,#+1
    473                Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
    474                PixelIndex = *(pTrans + Index);
    475                WRITE_MEM32P(pDest, PixelIndex);
   \   00000070   0260A0E1           MOV      R6,R2
   \   00000074   C050A0E3           MOV      R5,#+192
   \   00000078   066066E2           RSB      R6,R6,#+6
   \   0000007C   555600E0           AND      R5,R0,R5, ASR R6
   \   00000080   3522A0E1           LSR      R2,R5,R2
   \   00000084   022194E7           LDR      R2,[R4, +R2, LSL #+2]
    476                pDest--;
    477                if (++CurrentPixel == 4) {
   \   00000088   01C08CE2           ADD      R12,R12,#+1
   \   0000008C   042001E4           STR      R2,[R1], #-4
   \   00000090   04005CE3           CMP      R12,#+4
    478                  CurrentPixel = 0;
   \   00000094   00C0A003           MOVEQ    R12,#+0
    479                  Pixels = *(++p);
   \   00000098   0100F305           LDRBEQ   R0,[R3, #+1]!
    480                }
    481          		} while (--xsize);
   \   0000009C   01E05EE2           SUBS     LR,LR,#+1
   \   000000A0   F0FFFF1A           BNE      ??_DrawBitLine2BPP_1
   \   000000A4   F080BDE8           POP      {R4-R7,PC}
    482              break;
    483            case LCD_DRAWMODE_TRANS:
    484              do {
    485                Shift = (3 - CurrentPixel) << 1;
   \                     ??_DrawBitLine2BPP_2:
   \   000000A8   03206CE2           RSB      R2,R12,#+3
   \   000000AC   8220A0E1           LSL      R2,R2,#+1
    486                Index = (Pixels & (0xC0 >> (6 - Shift))) >> Shift;
   \   000000B0   0260A0E1           MOV      R6,R2
   \   000000B4   C050A0E3           MOV      R5,#+192
   \   000000B8   066066E2           RSB      R6,R6,#+6
   \   000000BC   555600E0           AND      R5,R0,R5, ASR R6
   \   000000C0   3522B0E1           LSRS     R2,R5,R2
    487                if (Index) {
    488                  PixelIndex = *(pTrans + Index);
    489                  WRITE_MEM32P(pDest, PixelIndex);
   \   000000C4   02219417           LDRNE    R2,[R4, +R2, LSL #+2]
    490                }
    491                pDest--;
    492                if (++CurrentPixel == 4) {
   \   000000C8   01C08CE2           ADD      R12,R12,#+1
   \   000000CC   00208115           STRNE    R2,[R1, #+0]
   \   000000D0   04005CE3           CMP      R12,#+4
    493                  CurrentPixel = 0;
   \   000000D4   00C0A003           MOVEQ    R12,#+0
    494                  Pixels = *(++p);
   \   000000D8   0100F305           LDRBEQ   R0,[R3, #+1]!
   \   000000DC   041041E2           SUB      R1,R1,#+4
    495                }
    496          		} while (--xsize);
   \   000000E0   01E05EE2           SUBS     LR,LR,#+1
   \   000000E4   EFFFFF1A           BNE      ??_DrawBitLine2BPP_2
   \                     ??_DrawBitLine2BPP_0:
   \   000000E8   F080BDE8           POP      {R4-R7,PC}       ;; return
    497              break;
    498            }
    499          }
    500          
    501          /*********************************************************************
    502          *
    503          *       Draw Bitmap 4 BPP
    504          */

   \                                 In section .text, align 4, keep-with-next
    505          static void  _DrawBitLine4BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int Diff, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine4BPP:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   1C409DE5           LDR      R4,[SP, #+28]
   \   00000008   14C09DE5           LDR      R12,[SP, #+20]
   \   0000000C   18E09DE5           LDR      LR,[SP, #+24]
    506            DRIVER_CONTEXT * pContext;
    507            LCD_PIXELINDEX Pixels, PixelIndex;
    508            int CurrentPixel, Shift, Index;
    509            U32 * pDest;
    510            U32 Off;
    511          
    512            if (pTrans == NULL) {
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   3300000A           BEQ      ??_DrawBitLine4BPP_0
    513              return; // pTrans is required
    514            }
    515            //
    516            // Get context
    517            //
    518            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000018   085090E5           LDR      R5,[R0, #+8]
    519            Pixels       = *p;
   \   0000001C   0000D3E5           LDRB     R0,[R3, #+0]
    520            CurrentPixel = Diff;
    521            x           += Diff;
    522            //
    523            // Mirror x
    524            //
    525            x = (pContext->vxSize - 1 - (x));
    526            //
    527            // Mirror y
    528            //
    529            y = (pContext->vySize - 1 - y);
    530            Off          = XY2OFF32(pContext->vxSizePhys, x, y);
    531            pDest        = OFF2PTR32(pContext->VRAMAddr, Off);
   \   00000020   106095E5           LDR      R6,[R5, #+16]
   \   00000024   0C7095E5           LDR      R7,[R5, #+12]
   \   00000028   016046E2           SUB      R6,R6,#+1
   \   0000002C   022046E0           SUB      R2,R6,R2
   \   00000030   017047E2           SUB      R7,R7,#+1
   \   00000034   146095E5           LDR      R6,[R5, #+20]
   \   00000038   011047E0           SUB      R1,R7,R1
   \   0000003C   0C1041E0           SUB      R1,R1,R12
   \   00000040   961221E0           MLA      R1,R6,R2,R1
   \   00000044   002095E5           LDR      R2,[R5, #+0]
   \   00000048   011182E0           ADD      R1,R2,R1, LSL #+2
    532            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   0000004C   ........           LDR      R2,??DataTable16
   \   00000050   1020D2E5           LDRB     R2,[R2, #+16]
   \   00000054   032012E2           ANDS     R2,R2,#0x3
   \   00000058   0200000A           BEQ      ??_DrawBitLine4BPP_1
   \   0000005C   022052E2           SUBS     R2,R2,#+2
   \   00000060   1000000A           BEQ      ??_DrawBitLine4BPP_2
   \   00000064   F080BDE8           POP      {R4-R7,PC}
    533            case 0:
    534              do {
    535                Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_1:
   \   00000068   01206CE2           RSB      R2,R12,#+1
   \   0000006C   0221A0E1           LSL      R2,R2,#+2
    536                Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
    537                PixelIndex = *(pTrans + Index);
    538                WRITE_MEM32P(pDest, PixelIndex);
   \   00000070   0260A0E1           MOV      R6,R2
   \   00000074   F050A0E3           MOV      R5,#+240
   \   00000078   046066E2           RSB      R6,R6,#+4
   \   0000007C   555600E0           AND      R5,R0,R5, ASR R6
   \   00000080   3522A0E1           LSR      R2,R5,R2
   \   00000084   022194E7           LDR      R2,[R4, +R2, LSL #+2]
    539                pDest--;
    540                if (++CurrentPixel == 2) {
   \   00000088   01C08CE2           ADD      R12,R12,#+1
   \   0000008C   042001E4           STR      R2,[R1], #-4
   \   00000090   02005CE3           CMP      R12,#+2
    541                  CurrentPixel = 0;
   \   00000094   00C0A003           MOVEQ    R12,#+0
    542                  Pixels = *(++p);
   \   00000098   0100F305           LDRBEQ   R0,[R3, #+1]!
    543                }
    544          		} while (--xsize);
   \   0000009C   01E05EE2           SUBS     LR,LR,#+1
   \   000000A0   F0FFFF1A           BNE      ??_DrawBitLine4BPP_1
   \   000000A4   F080BDE8           POP      {R4-R7,PC}
    545              break;
    546            case LCD_DRAWMODE_TRANS:
    547              do {
    548                Shift = (1 - CurrentPixel) << 2;
   \                     ??_DrawBitLine4BPP_2:
   \   000000A8   01206CE2           RSB      R2,R12,#+1
   \   000000AC   0221A0E1           LSL      R2,R2,#+2
    549                Index = (Pixels & (0xF0 >> (4 - Shift))) >> Shift;
   \   000000B0   0260A0E1           MOV      R6,R2
   \   000000B4   F050A0E3           MOV      R5,#+240
   \   000000B8   046066E2           RSB      R6,R6,#+4
   \   000000BC   555600E0           AND      R5,R0,R5, ASR R6
   \   000000C0   3522B0E1           LSRS     R2,R5,R2
    550                if (Index) {
    551                  PixelIndex = *(pTrans + Index);
    552                  WRITE_MEM32P(pDest, PixelIndex);
   \   000000C4   02219417           LDRNE    R2,[R4, +R2, LSL #+2]
    553                }
    554                pDest--;
    555                if (++CurrentPixel == 2) {
   \   000000C8   01C08CE2           ADD      R12,R12,#+1
   \   000000CC   00208115           STRNE    R2,[R1, #+0]
   \   000000D0   02005CE3           CMP      R12,#+2
    556                  CurrentPixel = 0;
   \   000000D4   00C0A003           MOVEQ    R12,#+0
    557                  Pixels = *(++p);
   \   000000D8   0100F305           LDRBEQ   R0,[R3, #+1]!
   \   000000DC   041041E2           SUB      R1,R1,#+4
    558                }
    559          		} while (--xsize);
   \   000000E0   01E05EE2           SUBS     LR,LR,#+1
   \   000000E4   EFFFFF1A           BNE      ??_DrawBitLine4BPP_2
   \                     ??_DrawBitLine4BPP_0:
   \   000000E8   F080BDE8           POP      {R4-R7,PC}       ;; return
    560              break;
    561            }
    562          }
    563          
    564          /*********************************************************************
    565          *
    566          *       Draw Bitmap 8 BPP
    567          */

   \                                 In section .text, align 4, keep-with-next
    568          static void  _DrawBitLine8BPP(GUI_DEVICE * pDevice, int x, int y, U8 const GUI_UNI_PTR * p, int xsize, const LCD_PIXELINDEX * pTrans) {
   \                     _DrawBitLine8BPP:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   10E09DE5           LDR      LR,[SP, #+16]
   \   00000008   0CC09DE5           LDR      R12,[SP, #+12]
    569            DRIVER_CONTEXT * pContext;
    570            LCD_PIXELINDEX Pixel;
    571            register U32 Off;
    572            U32 * pDest;
    573          
    574            if (!pTrans) {
   \   0000000C   00005EE3           CMP      LR,#+0
   \   00000010   5300000A           BEQ      ??_DrawBitLine8BPP_0
    575              return; // No translation from 8bpp BMP to 16bpp device makes no sense
    576            }
    577            //
    578            // Get context
    579            //
    580            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000014   080090E5           LDR      R0,[R0, #+8]
    581            //
    582            // Mirror x
    583            //
    584            x = (pContext->vxSize - 1 - (x));
    585            //
    586            // Mirror y
    587            //
    588            y = (pContext->vySize - 1 - y);
    589            Off   = XY2OFF32(pContext->vxSizePhys, x,y);
    590            pDest = OFF2PTR32(pContext->VRAMAddr, Off);
   \   00000018   104090E5           LDR      R4,[R0, #+16]
   \   0000001C   0C5090E5           LDR      R5,[R0, #+12]
   \   00000020   014044E2           SUB      R4,R4,#+1
   \   00000024   022044E0           SUB      R2,R4,R2
   \   00000028   144090E5           LDR      R4,[R0, #+20]
   \   0000002C   015045E2           SUB      R5,R5,#+1
   \   00000030   011045E0           SUB      R1,R5,R1
   \   00000034   941221E0           MLA      R1,R4,R2,R1
   \   00000038   000090E5           LDR      R0,[R0, #+0]
   \   0000003C   010180E0           ADD      R0,R0,R1, LSL #+2
    591            switch (GUI_Context.DrawMode & (LCD_DRAWMODE_TRANS | LCD_DRAWMODE_XOR)) {
   \   00000040   ........           LDR      R1,??DataTable16
   \   00000044   1010D1E5           LDRB     R1,[R1, #+16]
   \   00000048   031011E2           ANDS     R1,R1,#0x3
   \   0000004C   0200000A           BEQ      ??_DrawBitLine8BPP_1
   \   00000050   021051E2           SUBS     R1,R1,#+2
   \   00000054   3700000A           BEQ      ??_DrawBitLine8BPP_2
   \   00000058   3080BDE8           POP      {R4,R5,PC}
    592            case 0:
    593              while (xsize >= 8) {
   \                     ??_DrawBitLine8BPP_1:
   \   0000005C   08005CE3           CMP      R12,#+8
   \   00000060   180000AA           BGE      ??_DrawBitLine8BPP_3
   \                     ??_DrawBitLine8BPP_4:
   \   00000064   04005CE3           CMP      R12,#+4
   \   00000068   0E0000BA           BLT      ??_DrawBitLine8BPP_5
    594                WRITE_MEM32P(pDest - 0, *(pTrans + *(p + 0)));
    595                WRITE_MEM32P(pDest - 1, *(pTrans + *(p + 1)));
    596                WRITE_MEM32P(pDest - 2, *(pTrans + *(p + 2)));
    597                WRITE_MEM32P(pDest - 3, *(pTrans + *(p + 3)));
    598                WRITE_MEM32P(pDest - 4, *(pTrans + *(p + 4)));
    599                WRITE_MEM32P(pDest - 5, *(pTrans + *(p + 5)));
    600                WRITE_MEM32P(pDest - 6, *(pTrans + *(p + 6)));
    601                WRITE_MEM32P(pDest - 7, *(pTrans + *(p + 7)));
    602                xsize -= 8;
    603                p     += 8;
    604                pDest -= 8;
    605              }
    606              while (xsize >= 4) {
    607                WRITE_MEM32P(pDest - 0, *(pTrans + *(p + 0)));
   \                     ??_DrawBitLine8BPP_6:
   \   0000006C   0110D3E4           LDRB     R1,[R3], #+1
    608                WRITE_MEM32P(pDest - 1, *(pTrans + *(p + 1)));
    609                WRITE_MEM32P(pDest - 2, *(pTrans + *(p + 2)));
    610                WRITE_MEM32P(pDest - 3, *(pTrans + *(p + 3)));
    611                xsize -= 4;
   \   00000070   04C04CE2           SUB      R12,R12,#+4
    612                p     += 4;
    613                pDest -= 4;
   \   00000074   04005CE3           CMP      R12,#+4
   \   00000078   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   0000007C   041000E4           STR      R1,[R0], #-4
   \   00000080   0110D3E4           LDRB     R1,[R3], #+1
   \   00000084   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000088   041000E4           STR      R1,[R0], #-4
   \   0000008C   0110D3E4           LDRB     R1,[R3], #+1
   \   00000090   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000094   041000E4           STR      R1,[R0], #-4
   \   00000098   0110D3E4           LDRB     R1,[R3], #+1
   \   0000009C   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000A0   041000E4           STR      R1,[R0], #-4
   \   000000A4   F0FFFFAA           BGE      ??_DrawBitLine8BPP_6
    614              }
    615              while (xsize) {
   \                     ??_DrawBitLine8BPP_5:
   \   000000A8   00005CE3           CMP      R12,#+0
   \   000000AC   2C00000A           BEQ      ??_DrawBitLine8BPP_0
    616                WRITE_MEM32P(pDest - 0, *(pTrans + *(p + 0)));
   \                     ??_DrawBitLine8BPP_7:
   \   000000B0   0110D3E4           LDRB     R1,[R3], #+1
    617                xsize--;
   \   000000B4   01C05CE2           SUBS     R12,R12,#+1
   \   000000B8   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000BC   041000E4           STR      R1,[R0], #-4
    618                p++;
    619                pDest--;
   \   000000C0   FAFFFF1A           BNE      ??_DrawBitLine8BPP_7
   \   000000C4   3080BDE8           POP      {R4,R5,PC}
    620              }
   \                     ??_DrawBitLine8BPP_3:
   \   000000C8   0110D3E4           LDRB     R1,[R3], #+1
   \   000000CC   08C04CE2           SUB      R12,R12,#+8
   \   000000D0   08005CE3           CMP      R12,#+8
   \   000000D4   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000D8   041000E4           STR      R1,[R0], #-4
   \   000000DC   0110D3E4           LDRB     R1,[R3], #+1
   \   000000E0   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000E4   041000E4           STR      R1,[R0], #-4
   \   000000E8   0110D3E4           LDRB     R1,[R3], #+1
   \   000000EC   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000F0   041000E4           STR      R1,[R0], #-4
   \   000000F4   0110D3E4           LDRB     R1,[R3], #+1
   \   000000F8   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   000000FC   041000E4           STR      R1,[R0], #-4
   \   00000100   0110D3E4           LDRB     R1,[R3], #+1
   \   00000104   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000108   041000E4           STR      R1,[R0], #-4
   \   0000010C   0110D3E4           LDRB     R1,[R3], #+1
   \   00000110   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000114   041000E4           STR      R1,[R0], #-4
   \   00000118   0110D3E4           LDRB     R1,[R3], #+1
   \   0000011C   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   00000120   041000E4           STR      R1,[R0], #-4
   \   00000124   0110D3E4           LDRB     R1,[R3], #+1
   \   00000128   01119EE7           LDR      R1,[LR, +R1, LSL #+2]
   \   0000012C   041000E4           STR      R1,[R0], #-4
   \   00000130   E4FFFFAA           BGE      ??_DrawBitLine8BPP_3
   \   00000134   CAFFFFEA           B        ??_DrawBitLine8BPP_4
    621              break;
    622            case LCD_DRAWMODE_TRANS:
    623              for (; xsize > 0; xsize--, p++, pDest--) {
   \                     ??_DrawBitLine8BPP_2:
   \   00000138   01005CE3           CMP      R12,#+1
   \   0000013C   080000BA           BLT      ??_DrawBitLine8BPP_0
    624                Pixel = *p;
    625                if (Pixel) {
   \                     ??_DrawBitLine8BPP_8:
   \   00000140   0010D3E5           LDRB     R1,[R3, #+0]
    626                  WRITE_MEM32P(pDest, *(pTrans + *p));
    627                }
    628              }
   \   00000144   01C04CE2           SUB      R12,R12,#+1
   \   00000148   013083E2           ADD      R3,R3,#+1
   \   0000014C   000051E3           CMP      R1,#+0
   \   00000150   01119E17           LDRNE    R1,[LR, +R1, LSL #+2]
   \   00000154   00108015           STRNE    R1,[R0, #+0]
   \   00000158   040040E2           SUB      R0,R0,#+4
   \   0000015C   01005CE3           CMP      R12,#+1
   \   00000160   F6FFFFAA           BGE      ??_DrawBitLine8BPP_8
   \                     ??_DrawBitLine8BPP_0:
   \   00000164   3080BDE8           POP      {R4,R5,PC}       ;; return
    629              break;
    630            }
    631          }
    632          
    633          /*********************************************************************
    634          *
    635          *       Draw Bitmap 16 BPP, not optimized
    636          */
    637          static void _DrawBitLine16BPP(GUI_DEVICE * pDevice, int x, int y, U16 const GUI_UNI_PTR * p, int xsize) {
    638            for (;xsize > 0; xsize--, x++, p++) {
    639              _SetPixelIndex(pDevice, x, y, *p);
    640            }
    641          }
    642          
    643          /*********************************************************************
    644          *
    645          *       Draw Bitmap 32 BPP, not optimized
    646          */
    647          static void _DrawBitLine32BPP(GUI_DEVICE * pDevice, int x, int y, U32 const GUI_UNI_PTR * p, int xsize) {
    648            for (;xsize > 0; xsize--, x++, p++) {
    649              _SetPixelIndex(pDevice, x, y, *p);
    650            }
    651          }
    652          
    653          /*********************************************************************
    654          *
    655          *       _DrawBitmap
    656          */

   \                                 In section .text, align 4, keep-with-next
    657          static void _DrawBitmap(GUI_DEVICE * pDevice, int x0, int y0,
    658                                 int xSize, int ySize,
    659                                 int BitsPerPixel, 
    660                                 int BytesPerLine,
    661                                 const U8 GUI_UNI_PTR * pData, int Diff,
    662                                 const LCD_PIXELINDEX* pTrans) {
   \                     _DrawBitmap:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   3C009DE5           LDR      R0,[SP, #+60]
   \   00000010   0160A0E1           MOV      R6,R1
    663            int i;
    664          
    665            //
    666            // Use _DrawBitLineXBPP and _DrawBitLineXBPP_Swap
    667            //
    668            switch (BitsPerPixel) {
   \   00000014   010040E2           SUB      R0,R0,#+1
   \   00000018   40709DE5           LDR      R7,[SP, #+64]
   \   0000001C   44A09DE5           LDR      R10,[SP, #+68]
   \   00000020   48809DE5           LDR      R8,[SP, #+72]
   \   00000024   4C909DE5           LDR      R9,[SP, #+76]
   \   00000028   1F0050E3           CMP      R0,#+31
   \   0000002C   00F18F90           ADDLS    PC,PC,R0, LSL #+2
   \                     ??_DrawBitmap_0:
   \   00000030   4900008A           BHI      ??_DrawBitmap_1
   \   00000034   1E0000EA           B        ??_DrawBitmap_2
   \   00000038   490000EA           B        ??_DrawBitmap_3
   \   0000003C   460000EA           B        ??_DrawBitmap_1
   \   00000040   720000EA           B        ??_DrawBitmap_4
   \   00000044   440000EA           B        ??_DrawBitmap_1
   \   00000048   430000EA           B        ??_DrawBitmap_1
   \   0000004C   420000EA           B        ??_DrawBitmap_1
   \   00000050   990000EA           B        ??_DrawBitmap_5
   \   00000054   400000EA           B        ??_DrawBitmap_1
   \   00000058   3F0000EA           B        ??_DrawBitmap_1
   \   0000005C   3E0000EA           B        ??_DrawBitmap_1
   \   00000060   3D0000EA           B        ??_DrawBitmap_1
   \   00000064   3C0000EA           B        ??_DrawBitmap_1
   \   00000068   3B0000EA           B        ??_DrawBitmap_1
   \   0000006C   3A0000EA           B        ??_DrawBitmap_1
   \   00000070   B90000EA           B        ??_DrawBitmap_6
   \   00000074   380000EA           B        ??_DrawBitmap_1
   \   00000078   370000EA           B        ??_DrawBitmap_1
   \   0000007C   360000EA           B        ??_DrawBitmap_1
   \   00000080   350000EA           B        ??_DrawBitmap_1
   \   00000084   340000EA           B        ??_DrawBitmap_1
   \   00000088   330000EA           B        ??_DrawBitmap_1
   \   0000008C   320000EA           B        ??_DrawBitmap_1
   \   00000090   310000EA           B        ??_DrawBitmap_1
   \   00000094   300000EA           B        ??_DrawBitmap_1
   \   00000098   2F0000EA           B        ??_DrawBitmap_1
   \   0000009C   2E0000EA           B        ??_DrawBitmap_1
   \   000000A0   2D0000EA           B        ??_DrawBitmap_1
   \   000000A4   2C0000EA           B        ??_DrawBitmap_1
   \   000000A8   2B0000EA           B        ??_DrawBitmap_1
   \   000000AC   2A0000EA           B        ??_DrawBitmap_1
   \   000000B0   CA0000EA           B        ??_DrawBitmap_7
    669            case 1:
    670              for (i = 0; i < ySize; i++) {
   \                     ??_DrawBitmap_2:
   \   000000B4   38009DE5           LDR      R0,[SP, #+56]
   \   000000B8   010050E3           CMP      R0,#+1
   \   000000BC   260000BA           BLT      ??_DrawBitmap_1
   \   000000C0   00B0A0E1           MOV      R11,R0
   \   000000C4   0240A0E1           MOV      R4,R2
   \   000000C8   01001BE3           TST      R11,#0x1
   \   000000CC   0800000A           BEQ      ??_DrawBitmap_8
    671                _DrawBitLine1BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
   \   000000D0   10009DE5           LDR      R0,[SP, #+16]
   \   000000D4   08908DE5           STR      R9,[SP, #+8]
   \   000000D8   04008DE5           STR      R0,[SP, #+4]
   \   000000DC   00808DE5           STR      R8,[SP, #+0]
   \   000000E0   0A30A0E1           MOV      R3,R10
   \   000000E4   0500A0E1           MOV      R0,R5
   \   000000E8   ........           BL       _DrawBitLine1BPP
    672                pData += BytesPerLine;
   \   000000EC   0AA087E0           ADD      R10,R7,R10
   \   000000F0   014084E2           ADD      R4,R4,#+1
   \                     ??_DrawBitmap_8:
   \   000000F4   ABB0B0E1           LSRS     R11,R11,#+1
   \   000000F8   1700000A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_9:
   \   000000FC   10009DE5           LDR      R0,[SP, #+16]
   \   00000100   08908DE5           STR      R9,[SP, #+8]
   \   00000104   04008DE5           STR      R0,[SP, #+4]
   \   00000108   00808DE5           STR      R8,[SP, #+0]
   \   0000010C   0A30A0E1           MOV      R3,R10
   \   00000110   0420A0E1           MOV      R2,R4
   \   00000114   0610A0E1           MOV      R1,R6
   \   00000118   0500A0E1           MOV      R0,R5
   \   0000011C   ........           BL       _DrawBitLine1BPP
   \   00000120   10009DE5           LDR      R0,[SP, #+16]
   \   00000124   0AA087E0           ADD      R10,R7,R10
   \   00000128   04008DE5           STR      R0,[SP, #+4]
   \   0000012C   08908DE5           STR      R9,[SP, #+8]
   \   00000130   00808DE5           STR      R8,[SP, #+0]
   \   00000134   0A30A0E1           MOV      R3,R10
   \   00000138   012084E2           ADD      R2,R4,#+1
   \   0000013C   0610A0E1           MOV      R1,R6
   \   00000140   0500A0E1           MOV      R0,R5
   \   00000144   ........           BL       _DrawBitLine1BPP
    673              }
   \   00000148   01B04BE2           SUB      R11,R11,#+1
   \   0000014C   0AA087E0           ADD      R10,R7,R10
   \   00000150   024084E2           ADD      R4,R4,#+2
   \   00000154   00005BE3           CMP      R11,#+0
   \   00000158   E7FFFF1A           BNE      ??_DrawBitmap_9
    674              break;
    675            case 2:
    676              for (i = 0; i < ySize; i++) {
    677                _DrawBitLine2BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
    678                pData += BytesPerLine;
    679              }
    680              break;
    681            case 4:
    682              for (i = 0; i < ySize; i++) {
    683                _DrawBitLine4BPP(pDevice, x0, i + y0, pData, Diff, xSize, pTrans);
    684                pData += BytesPerLine;
    685              }
    686              break;
    687            case 8:
    688              for (i = 0; i < ySize; i++) {
    689                _DrawBitLine8BPP(pDevice, x0, i + y0, pData, xSize, pTrans);
    690                pData += BytesPerLine;
    691              }
    692              break;
    693            case 16:
    694              for (i = 0; i < ySize; i++) {
    695                _DrawBitLine16BPP(pDevice, x0, i + y0, (const U16 *)pData, xSize);
    696                pData += BytesPerLine;
    697              }
    698              break;
    699            case 32:
    700              for (i = 0; i < ySize; i++) {
    701                _DrawBitLine32BPP(pDevice, x0, i + y0, (const U32 *)pData, xSize);
    702                pData += BytesPerLine;
    703              }
    704              break;
    705            }
    706          }
   \                     ??_DrawBitmap_1:
   \   0000015C   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000160   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??_DrawBitmap_3:
   \   00000164   38009DE5           LDR      R0,[SP, #+56]
   \   00000168   010050E3           CMP      R0,#+1
   \   0000016C   FAFFFFBA           BLT      ??_DrawBitmap_1
   \   00000170   00B0A0E1           MOV      R11,R0
   \   00000174   0240A0E1           MOV      R4,R2
   \   00000178   01001BE3           TST      R11,#0x1
   \   0000017C   0800000A           BEQ      ??_DrawBitmap_10
   \   00000180   10009DE5           LDR      R0,[SP, #+16]
   \   00000184   08908DE5           STR      R9,[SP, #+8]
   \   00000188   04008DE5           STR      R0,[SP, #+4]
   \   0000018C   00808DE5           STR      R8,[SP, #+0]
   \   00000190   0A30A0E1           MOV      R3,R10
   \   00000194   0500A0E1           MOV      R0,R5
   \   00000198   ........           BL       _DrawBitLine2BPP
   \   0000019C   0AA087E0           ADD      R10,R7,R10
   \   000001A0   014084E2           ADD      R4,R4,#+1
   \                     ??_DrawBitmap_10:
   \   000001A4   ABB0B0E1           LSRS     R11,R11,#+1
   \   000001A8   EBFFFF0A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_11:
   \   000001AC   10009DE5           LDR      R0,[SP, #+16]
   \   000001B0   08908DE5           STR      R9,[SP, #+8]
   \   000001B4   04008DE5           STR      R0,[SP, #+4]
   \   000001B8   00808DE5           STR      R8,[SP, #+0]
   \   000001BC   0A30A0E1           MOV      R3,R10
   \   000001C0   0420A0E1           MOV      R2,R4
   \   000001C4   0610A0E1           MOV      R1,R6
   \   000001C8   0500A0E1           MOV      R0,R5
   \   000001CC   ........           BL       _DrawBitLine2BPP
   \   000001D0   10009DE5           LDR      R0,[SP, #+16]
   \   000001D4   0AA087E0           ADD      R10,R7,R10
   \   000001D8   04008DE5           STR      R0,[SP, #+4]
   \   000001DC   08908DE5           STR      R9,[SP, #+8]
   \   000001E0   00808DE5           STR      R8,[SP, #+0]
   \   000001E4   0A30A0E1           MOV      R3,R10
   \   000001E8   012084E2           ADD      R2,R4,#+1
   \   000001EC   0610A0E1           MOV      R1,R6
   \   000001F0   0500A0E1           MOV      R0,R5
   \   000001F4   ........           BL       _DrawBitLine2BPP
   \   000001F8   01B04BE2           SUB      R11,R11,#+1
   \   000001FC   0AA087E0           ADD      R10,R7,R10
   \   00000200   024084E2           ADD      R4,R4,#+2
   \   00000204   00005BE3           CMP      R11,#+0
   \   00000208   E7FFFF1A           BNE      ??_DrawBitmap_11
   \   0000020C   D2FFFFEA           B        ??_DrawBitmap_1
   \                     ??_DrawBitmap_4:
   \   00000210   38009DE5           LDR      R0,[SP, #+56]
   \   00000214   010050E3           CMP      R0,#+1
   \   00000218   CFFFFFBA           BLT      ??_DrawBitmap_1
   \   0000021C   00B0A0E1           MOV      R11,R0
   \   00000220   0240A0E1           MOV      R4,R2
   \   00000224   01001BE3           TST      R11,#0x1
   \   00000228   0800000A           BEQ      ??_DrawBitmap_12
   \   0000022C   10009DE5           LDR      R0,[SP, #+16]
   \   00000230   08908DE5           STR      R9,[SP, #+8]
   \   00000234   04008DE5           STR      R0,[SP, #+4]
   \   00000238   00808DE5           STR      R8,[SP, #+0]
   \   0000023C   0A30A0E1           MOV      R3,R10
   \   00000240   0500A0E1           MOV      R0,R5
   \   00000244   ........           BL       _DrawBitLine4BPP
   \   00000248   0AA087E0           ADD      R10,R7,R10
   \   0000024C   014084E2           ADD      R4,R4,#+1
   \                     ??_DrawBitmap_12:
   \   00000250   ABB0B0E1           LSRS     R11,R11,#+1
   \   00000254   C0FFFF0A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_13:
   \   00000258   10009DE5           LDR      R0,[SP, #+16]
   \   0000025C   08908DE5           STR      R9,[SP, #+8]
   \   00000260   04008DE5           STR      R0,[SP, #+4]
   \   00000264   00808DE5           STR      R8,[SP, #+0]
   \   00000268   0A30A0E1           MOV      R3,R10
   \   0000026C   0420A0E1           MOV      R2,R4
   \   00000270   0610A0E1           MOV      R1,R6
   \   00000274   0500A0E1           MOV      R0,R5
   \   00000278   ........           BL       _DrawBitLine4BPP
   \   0000027C   10009DE5           LDR      R0,[SP, #+16]
   \   00000280   0AA087E0           ADD      R10,R7,R10
   \   00000284   04008DE5           STR      R0,[SP, #+4]
   \   00000288   08908DE5           STR      R9,[SP, #+8]
   \   0000028C   00808DE5           STR      R8,[SP, #+0]
   \   00000290   0A30A0E1           MOV      R3,R10
   \   00000294   012084E2           ADD      R2,R4,#+1
   \   00000298   0610A0E1           MOV      R1,R6
   \   0000029C   0500A0E1           MOV      R0,R5
   \   000002A0   ........           BL       _DrawBitLine4BPP
   \   000002A4   01B04BE2           SUB      R11,R11,#+1
   \   000002A8   0AA087E0           ADD      R10,R7,R10
   \   000002AC   024084E2           ADD      R4,R4,#+2
   \   000002B0   00005BE3           CMP      R11,#+0
   \   000002B4   E7FFFF1A           BNE      ??_DrawBitmap_13
   \   000002B8   A7FFFFEA           B        ??_DrawBitmap_1
   \                     ??_DrawBitmap_5:
   \   000002BC   38009DE5           LDR      R0,[SP, #+56]
   \   000002C0   010050E3           CMP      R0,#+1
   \   000002C4   A4FFFFBA           BLT      ??_DrawBitmap_1
   \   000002C8   0080A0E1           MOV      R8,R0
   \   000002CC   0240A0E1           MOV      R4,R2
   \   000002D0   010018E3           TST      R8,#0x1
   \   000002D4   0700000A           BEQ      ??_DrawBitmap_14
   \   000002D8   10009DE5           LDR      R0,[SP, #+16]
   \   000002DC   04908DE5           STR      R9,[SP, #+4]
   \   000002E0   00008DE5           STR      R0,[SP, #+0]
   \   000002E4   0A30A0E1           MOV      R3,R10
   \   000002E8   0500A0E1           MOV      R0,R5
   \   000002EC   ........           BL       _DrawBitLine8BPP
   \   000002F0   0AA087E0           ADD      R10,R7,R10
   \   000002F4   014084E2           ADD      R4,R4,#+1
   \                     ??_DrawBitmap_14:
   \   000002F8   A880B0E1           LSRS     R8,R8,#+1
   \   000002FC   96FFFF0A           BEQ      ??_DrawBitmap_1
   \                     ??_DrawBitmap_15:
   \   00000300   10009DE5           LDR      R0,[SP, #+16]
   \   00000304   04908DE5           STR      R9,[SP, #+4]
   \   00000308   00008DE5           STR      R0,[SP, #+0]
   \   0000030C   0A30A0E1           MOV      R3,R10
   \   00000310   0420A0E1           MOV      R2,R4
   \   00000314   0610A0E1           MOV      R1,R6
   \   00000318   0500A0E1           MOV      R0,R5
   \   0000031C   ........           BL       _DrawBitLine8BPP
   \   00000320   10009DE5           LDR      R0,[SP, #+16]
   \   00000324   0AA087E0           ADD      R10,R7,R10
   \   00000328   00008DE5           STR      R0,[SP, #+0]
   \   0000032C   04908DE5           STR      R9,[SP, #+4]
   \   00000330   0A30A0E1           MOV      R3,R10
   \   00000334   012084E2           ADD      R2,R4,#+1
   \   00000338   0610A0E1           MOV      R1,R6
   \   0000033C   0500A0E1           MOV      R0,R5
   \   00000340   ........           BL       _DrawBitLine8BPP
   \   00000344   018048E2           SUB      R8,R8,#+1
   \   00000348   0AA087E0           ADD      R10,R7,R10
   \   0000034C   024084E2           ADD      R4,R4,#+2
   \   00000350   000058E3           CMP      R8,#+0
   \   00000354   E9FFFF1A           BNE      ??_DrawBitmap_15
   \   00000358   7FFFFFEA           B        ??_DrawBitmap_1
   \                     ??_DrawBitmap_6:
   \   0000035C   38109DE5           LDR      R1,[SP, #+56]
   \   00000360   0000A0E3           MOV      R0,#+0
   \   00000364   010051E3           CMP      R1,#+1
   \   00000368   7BFFFFBA           BLT      ??_DrawBitmap_1
   \                     ??_DrawBitmap_16:
   \   0000036C   10109DE5           LDR      R1,[SP, #+16]
   \   00000370   0A30A0E1           MOV      R3,R10
   \   00000374   06E0A0E1           MOV      LR,R6
   \   00000378   010051E3           CMP      R1,#+1
   \   0000037C   060000AA           BGE      ??_DrawBitmap_17
   \                     ??_DrawBitmap_18:
   \   00000380   38109DE5           LDR      R1,[SP, #+56]
   \   00000384   010080E2           ADD      R0,R0,#+1
   \   00000388   0AA087E0           ADD      R10,R7,R10
   \   0000038C   012082E2           ADD      R2,R2,#+1
   \   00000390   010050E1           CMP      R0,R1
   \   00000394   70FFFFAA           BGE      ??_DrawBitmap_1
   \   00000398   F3FFFFEA           B        ??_DrawBitmap_16
   \                     ??_DrawBitmap_17:
   \   0000039C   084095E5           LDR      R4,[R5, #+8]
   \   000003A0   011041E2           SUB      R1,R1,#+1
   \   000003A4   109094E5           LDR      R9,[R4, #+16]
   \   000003A8   0C8094E5           LDR      R8,[R4, #+12]
   \   000003AC   019049E2           SUB      R9,R9,#+1
   \   000003B0   02B049E0           SUB      R11,R9,R2
   \   000003B4   149094E5           LDR      R9,[R4, #+20]
   \   000003B8   004094E5           LDR      R4,[R4, #+0]
   \   000003BC   998B28E0           MLA      R8,R9,R11,R8
   \   000003C0   B290D3E0           LDRH     R9,[R3], #+2
   \   000003C4   018048E2           SUB      R8,R8,#+1
   \   000003C8   0E8048E0           SUB      R8,R8,LR
   \   000003CC   089184E7           STR      R9,[R4, +R8, LSL #+2]
   \   000003D0   01E08EE2           ADD      LR,LR,#+1
   \   000003D4   010051E3           CMP      R1,#+1
   \   000003D8   EFFFFFAA           BGE      ??_DrawBitmap_17
   \   000003DC   E7FFFFEA           B        ??_DrawBitmap_18
   \                     ??_DrawBitmap_7:
   \   000003E0   38109DE5           LDR      R1,[SP, #+56]
   \   000003E4   0000A0E3           MOV      R0,#+0
   \   000003E8   010051E3           CMP      R1,#+1
   \   000003EC   5AFFFFBA           BLT      ??_DrawBitmap_1
   \                     ??_DrawBitmap_19:
   \   000003F0   10109DE5           LDR      R1,[SP, #+16]
   \   000003F4   0A30A0E1           MOV      R3,R10
   \   000003F8   06E0A0E1           MOV      LR,R6
   \   000003FC   010051E3           CMP      R1,#+1
   \   00000400   060000AA           BGE      ??_DrawBitmap_20
   \                     ??_DrawBitmap_21:
   \   00000404   38109DE5           LDR      R1,[SP, #+56]
   \   00000408   010080E2           ADD      R0,R0,#+1
   \   0000040C   0AA087E0           ADD      R10,R7,R10
   \   00000410   012082E2           ADD      R2,R2,#+1
   \   00000414   010050E1           CMP      R0,R1
   \   00000418   4FFFFFAA           BGE      ??_DrawBitmap_1
   \   0000041C   F3FFFFEA           B        ??_DrawBitmap_19
   \                     ??_DrawBitmap_20:
   \   00000420   084095E5           LDR      R4,[R5, #+8]
   \   00000424   011041E2           SUB      R1,R1,#+1
   \   00000428   109094E5           LDR      R9,[R4, #+16]
   \   0000042C   0C8094E5           LDR      R8,[R4, #+12]
   \   00000430   019049E2           SUB      R9,R9,#+1
   \   00000434   02B049E0           SUB      R11,R9,R2
   \   00000438   149094E5           LDR      R9,[R4, #+20]
   \   0000043C   004094E5           LDR      R4,[R4, #+0]
   \   00000440   998B28E0           MLA      R8,R9,R11,R8
   \   00000444   049093E4           LDR      R9,[R3], #+4
   \   00000448   018048E2           SUB      R8,R8,#+1
   \   0000044C   0E8048E0           SUB      R8,R8,LR
   \   00000450   089184E7           STR      R9,[R4, +R8, LSL #+2]
   \   00000454   01E08EE2           ADD      LR,LR,#+1
   \   00000458   010051E3           CMP      R1,#+1
   \   0000045C   EFFFFFAA           BGE      ??_DrawBitmap_20
   \   00000460   E7FFFFEA           B        ??_DrawBitmap_21
    707          
    708          /*********************************************************************
    709          *
    710          *       _SetOrg
    711          */

   \                                 In section .text, align 4, keep-with-next
    712          static void _SetOrg(GUI_DEVICE * pDevice, int x, int y) {
   \                     _SetOrg:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    713            #ifndef WIN32
    714              DRIVER_CONTEXT * pContext;
    715            #endif
    716            LCD_X_SETORG_INFO Data = {0};
   \   00000004   ............       ADRL     R12,`?<Constant {0}>`
   \              ....        
   \   0000000C   0CD04DE2           SUB      SP,SP,#+12
   \   00000010   00409CE5           LDR      R4,[R12, #+0]
   \   00000014   04509CE5           LDR      R5,[R12, #+4]
   \   00000018   0D30A0E1           MOV      R3,SP
   \   0000001C   300083E8           STM      R3,{R4,R5}
    717          
    718            #ifdef WIN32
    719              LCDSIM_SetOrg(x, y, pDevice->LayerIndex);
    720            #else
    721              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000020   083090E5           LDR      R3,[R0, #+8]
    722              Data.xPos = pContext->vxSize - pContext->xSize - x;
   \   00000024   0CC093E5           LDR      R12,[R3, #+12]
   \   00000028   04E093E5           LDR      LR,[R3, #+4]
   \   0000002C   0EC04CE0           SUB      R12,R12,LR
   \   00000030   01104CE0           SUB      R1,R12,R1
   \   00000034   00108DE5           STR      R1,[SP, #+0]
    723              Data.yPos = pContext->vySize - pContext->ySize - y;
   \   00000038   101093E5           LDR      R1,[R3, #+16]
   \   0000003C   083093E5           LDR      R3,[R3, #+8]
   \   00000040   031041E0           SUB      R1,R1,R3
   \   00000044   021041E0           SUB      R1,R1,R2
   \   00000048   04108DE5           STR      R1,[SP, #+4]
    724              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETORG, (void *)&Data);
   \   0000004C   0D20A0E1           MOV      R2,SP
   \   00000050   0310A0E3           MOV      R1,#+3
   \   00000054   180090E5           LDR      R0,[R0, #+24]
   \   00000058   ........           BL       LCD_X_DisplayDriver
    725            #endif
    726          }
   \   0000005C   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000060   3080BDE8           POP      {R4,R5,PC}       ;; return
    727          
    728          /*********************************************************************
    729          *
    730          *       _InitOnce
    731          *
    732          * Purpose:
    733          *   Allocates a fixed block for the context of the driver
    734          *
    735          * Return value:
    736          *   0 on success, 1 on error
    737          */
    738          static int _InitOnce(GUI_DEVICE * pDevice) {
    739            if (pDevice->u.pContext == NULL) {
    740              pDevice->u.pContext = GUI_ALLOC_GetFixedBlock(sizeof(DRIVER_CONTEXT));
    741              GUI__memset((U8 *)pDevice->u.pContext, 0, sizeof(DRIVER_CONTEXT));
    742            }
    743            return pDevice->u.pContext ? 0 : 1;
    744          }
    745          
    746          /*********************************************************************
    747          *
    748          *       _GetRect
    749          */

   \                                 In section .text, align 4, keep-with-next
    750          static void _GetRect(GUI_DEVICE * pDevice, LCD_RECT * pRect) {
    751            DRIVER_CONTEXT * pContext;
    752          
    753            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \                     _GetRect:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
    754            pRect->x0 = 0;
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   B020C1E1           STRH     R2,[R1, #+0]
    755            pRect->y0 = 0;
   \   0000000C   B220C1E1           STRH     R2,[R1, #+2]
    756            pRect->x1 = pContext->vxSize - 1;
   \   00000010   0C2090E5           LDR      R2,[R0, #+12]
   \   00000014   012042E2           SUB      R2,R2,#+1
   \   00000018   B420C1E1           STRH     R2,[R1, #+4]
    757            pRect->y1 = pContext->vySize - 1;
   \   0000001C   100090E5           LDR      R0,[R0, #+16]
   \   00000020   010040E2           SUB      R0,R0,#+1
   \   00000024   B600C1E1           STRH     R0,[R1, #+6]
    758          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
    759          
    760          /*********************************************************************
    761          *
    762          *       _GetDevProp
    763          */

   \                                 In section .text, align 4, keep-with-next
    764          static I32 _GetDevProp(GUI_DEVICE * pDevice, int Index) {
    765            DRIVER_CONTEXT * pContext;
    766          
    767            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    768            switch (Index) {
   \                     _GetDevProp:
   \   00000000   011041E2           SUB      R1,R1,#+1
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   0D0051E3           CMP      R1,#+13
   \   0000000C   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevProp_0:
   \   00000010   1B00008A           BHI      ??_GetDevProp_1
   \   00000014   0C0000EA           B        ??_GetDevProp_2
   \   00000018   0D0000EA           B        ??_GetDevProp_3
   \   0000001C   0E0000EA           B        ??_GetDevProp_4
   \   00000020   0F0000EA           B        ??_GetDevProp_5
   \   00000024   160000EA           B        ??_GetDevProp_1
   \   00000028   150000EA           B        ??_GetDevProp_1
   \   0000002C   140000EA           B        ??_GetDevProp_1
   \   00000030   0D0000EA           B        ??_GetDevProp_6
   \   00000034   0E0000EA           B        ??_GetDevProp_7
   \   00000038   0F0000EA           B        ??_GetDevProp_8
   \   0000003C   0E0000EA           B        ??_GetDevProp_8
   \   00000040   0D0000EA           B        ??_GetDevProp_8
   \   00000044   0C0000EA           B        ??_GetDevProp_8
   \   00000048   090000EA           B        ??_GetDevProp_7
    769            case LCD_DEVCAP_XSIZE:
    770              return pContext->xSize;
   \                     ??_GetDevProp_2:
   \   0000004C   040090E5           LDR      R0,[R0, #+4]
   \   00000050   1EFF2FE1           BX       LR
    771            case LCD_DEVCAP_YSIZE:
    772              return pContext->ySize;
   \                     ??_GetDevProp_3:
   \   00000054   080090E5           LDR      R0,[R0, #+8]
   \   00000058   1EFF2FE1           BX       LR
    773            case LCD_DEVCAP_VXSIZE:
    774              return pContext->vxSize;
   \                     ??_GetDevProp_4:
   \   0000005C   0C0090E5           LDR      R0,[R0, #+12]
   \   00000060   1EFF2FE1           BX       LR
    775            case LCD_DEVCAP_VYSIZE:
    776              return pContext->vySize;
   \                     ??_GetDevProp_5:
   \   00000064   100090E5           LDR      R0,[R0, #+16]
   \   00000068   1EFF2FE1           BX       LR
    777            case LCD_DEVCAP_BITSPERPIXEL:
    778              return 32;
   \                     ??_GetDevProp_6:
   \   0000006C   2000A0E3           MOV      R0,#+32
   \   00000070   1EFF2FE1           BX       LR
    779            case LCD_DEVCAP_NUMCOLORS:
    780              return 0;
   \                     ??_GetDevProp_7:
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   1EFF2FE1           BX       LR
    781            case LCD_DEVCAP_XMAG:
    782              return 1;
   \                     ??_GetDevProp_8:
   \   0000007C   0100A0E3           MOV      R0,#+1
   \   00000080   1EFF2FE1           BX       LR
    783            case LCD_DEVCAP_YMAG:
    784              return 1;
    785            case LCD_DEVCAP_MIRROR_X:
    786              return 1;
    787            case LCD_DEVCAP_MIRROR_Y:
    788              return 1;
    789            case LCD_DEVCAP_SWAP_XY:
    790              return 0;
    791            }
    792            return -1;
   \                     ??_GetDevProp_1:
   \   00000084   0000E0E3           MVN      R0,#+0
   \   00000088   1EFF2FE1           BX       LR               ;; return
    793          }
    794          
    795          /*********************************************************************
    796          *
    797          *       _GetDevData
    798          */

   \                                 In section .text, align 4, keep-with-next
    799          static void * _GetDevData(GUI_DEVICE * pDevice, int Index) {
    800            GUI_USE_PARA(pDevice);
    801            switch (Index) {
   \                     _GetDevData:
   \   00000000   010051E3           CMP      R1,#+1
   \   00000004   0100001A           BNE      ??_GetDevData_0
    802            #if GUI_SUPPORT_MEMDEV
    803              case LCD_DEVDATA_MEMDEV:
    804                return (void *)&GUI_MEMDEV_DEVICE_32;
   \   00000008   ........           LDR      R0,??DataTable17
   \   0000000C   1EFF2FE1           BX       LR
    805            #endif
    806            }
    807            return NULL;
   \                     ??_GetDevData_0:
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   1EFF2FE1           BX       LR               ;; return
    808          }
    809          
    810          /*********************************************************************
    811          *
    812          *       Static code: Functions available by _GetDevFunc()
    813          *
    814          **********************************************************************
    815          */
    816          /*********************************************************************
    817          *
    818          *       _ReadRect
    819          */

   \                                 In section .text, align 4, keep-with-next
    820          static void _ReadRect(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer) {
   \                     _ReadRect:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    821            DRIVER_CONTEXT * pContext;
    822            U32 Off;
    823            int x, NumPixelsPerLine;
    824            U32 * p;
    825          
    826            pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   10E09DE5           LDR      LR,[SP, #+16]
   \   0000000C   0C4090E5           LDR      R4,[R0, #+12]
   \   00000010   14C09DE5           LDR      R12,[SP, #+20]
   \   00000014   014044E2           SUB      R4,R4,#+1
   \   00000018   011044E0           SUB      R1,R4,R1
    827            x0 = (pContext->vxSize - 1 - (x0));
    828            x1 = (pContext->vxSize - 1 - (x1));
   \   0000001C   033044E0           SUB      R3,R4,R3
   \   00000020   104090E5           LDR      R4,[R0, #+16]
   \   00000024   014044E2           SUB      R4,R4,#+1
   \   00000028   022044E0           SUB      R2,R4,R2
    829            y0 = (pContext->vySize - 1 - (y0));
    830            y1 = (pContext->vySize - 1 - (y1));
   \   0000002C   0EE044E0           SUB      LR,R4,LR
    831            p = (U32 *)pBuffer;
    832            x = x0;
   \   00000030   0140A0E1           MOV      R4,R1
    833            do {
    834              Off = XY2OFF32(pContext->vxSizePhys, x0, y0);
    835              NumPixelsPerLine = x0 - x1 + 1;
   \                     ??_ReadRect_0:
   \   00000034   146090E5           LDR      R6,[R0, #+20]
   \   00000038   035041E0           SUB      R5,R1,R3
   \   0000003C   961221E0           MLA      R1,R6,R2,R1
   \   00000040   015085E2           ADD      R5,R5,#+1
   \   00000044   0111A0E1           LSL      R1,R1,#+2
    836              do {
    837                *p++ = READ_MEM32(pContext->VRAMAddr, Off);
   \                     ??_ReadRect_1:
   \   00000048   006090E5           LDR      R6,[R0, #+0]
    838                Off--;
    839              } while (--NumPixelsPerLine);
   \   0000004C   015045E2           SUB      R5,R5,#+1
   \   00000050   066091E7           LDR      R6,[R1, +R6]
   \   00000054   041041E2           SUB      R1,R1,#+4
   \   00000058   04608CE4           STR      R6,[R12], #+4
   \   0000005C   000055E3           CMP      R5,#+0
   \   00000060   F8FFFF1A           BNE      ??_ReadRect_1
    840              x0 = x;
    841            } while (y0-- > y1);
   \   00000064   0250A0E1           MOV      R5,R2
   \   00000068   0410A0E1           MOV      R1,R4
   \   0000006C   012045E2           SUB      R2,R5,#+1
   \   00000070   05005EE1           CMP      LR,R5
   \   00000074   EEFFFFBA           BLT      ??_ReadRect_0
    842          }
   \   00000078   7080BDE8           POP      {R4-R6,PC}       ;; return
    843          
    844          /*********************************************************************
    845          *
    846          *       _SetVRAMAddr
    847          */

   \                                 In section .text, align 4, keep-with-next
    848          static void _SetVRAMAddr(GUI_DEVICE * pDevice, void * pVRAM) {
   \                     _SetVRAMAddr:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    849            DRIVER_CONTEXT * pContext;
    850            LCD_X_SETVRAMADDR_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {(void *)0}>`
   \              ....        
   \   00000010   04D04DE2           SUB      SP,SP,#+4
   \   00000014   001091E5           LDR      R1,[R1, #+0]
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
    851          
    852            _InitOnce(pDevice);
   \   00000020   080094E5           LDR      R0,[R4, #+8]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0500001A           BNE      ??_SetVRAMAddr_0
   \   0000002C   2C00A0E3           MOV      R0,#+44
   \   00000030   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000034   080084E5           STR      R0,[R4, #+8]
   \   00000038   2C20A0E3           MOV      R2,#+44
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   ........           BL       GUI__memset
    853            if (pDevice->u.pContext) {
   \                     ??_SetVRAMAddr_0:
   \   00000044   080094E5           LDR      R0,[R4, #+8]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0500000A           BEQ      ??_SetVRAMAddr_1
    854              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    855              pContext->VRAMAddr = (U32)pVRAM;
   \   00000050   005080E5           STR      R5,[R0, #+0]
    856              Data.pVRAM = pVRAM;
   \   00000054   00508DE5           STR      R5,[SP, #+0]
    857              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVRAMADDR, (void *)&Data);
   \   00000058   0D20A0E1           MOV      R2,SP
   \   0000005C   0210A0E3           MOV      R1,#+2
   \   00000060   180094E5           LDR      R0,[R4, #+24]
   \   00000064   ........           BL       LCD_X_DisplayDriver
    858            }
    859            #ifdef WIN32
    860              SIM_Lin_SetVRAMAddr(pDevice->LayerIndex, pVRAM);
    861            #endif
    862          }
   \                     ??_SetVRAMAddr_1:
   \   00000068   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   0000006C   3080BDE8           POP      {R4,R5,PC}       ;; return
    863          
    864          /*********************************************************************
    865          *
    866          *       _SetVSize
    867          */

   \                                 In section .text, align 4, keep-with-next
    868          static void _SetVSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetVSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    869            DRIVER_CONTEXT * pContext;
    870          
    871            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetVSize_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
    872            if (pDevice->u.pContext) {
   \                     ??_SetVSize_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
    873              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    874              pContext->vxSize = xSize;
   \   0000003C   0C508015           STRNE    R5,[R0, #+12]
    875              pContext->vySize = ySize;
   \   00000040   10608015           STRNE    R6,[R0, #+16]
    876              pContext->vxSizePhys = xSize;
   \   00000044   14508015           STRNE    R5,[R0, #+20]
    877            }
    878            #ifdef WIN32
    879              SIM_Lin_SetVRAMSize(pDevice->LayerIndex, xSize, ySize);
    880            #endif
    881          }
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
    882          
    883          /*********************************************************************
    884          *
    885          *       _SetSize
    886          */

   \                                 In section .text, align 4, keep-with-next
    887          static void _SetSize(GUI_DEVICE * pDevice, int xSize, int ySize) {
   \                     _SetSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    888            DRIVER_CONTEXT * pContext;
    889            LCD_X_SETSIZE_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_1`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
    890          
    891            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetSize_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
    892            if (pDevice->u.pContext) {
   \                     ??_SetSize_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0A00000A           BEQ      ??_SetSize_1
    893              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    894              if (pContext->vxSizePhys == 0) {
   \   0000005C   141090E5           LDR      R1,[R0, #+20]
    895                pContext->vxSizePhys = xSize;
    896              }
    897              pContext->xSize = xSize;
    898              pContext->ySize = ySize;
    899              Data.xSize = xSize;
    900              Data.ySize = ySize;
    901              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETSIZE, (void *)&Data);
   \   00000060   0D20A0E1           MOV      R2,SP
   \   00000064   000051E3           CMP      R1,#+0
   \   00000068   14508005           STREQ    R5,[R0, #+20]
   \   0000006C   045080E5           STR      R5,[R0, #+4]
   \   00000070   086080E5           STR      R6,[R0, #+8]
   \   00000074   00508DE5           STR      R5,[SP, #+0]
   \   00000078   04608DE5           STR      R6,[SP, #+4]
   \   0000007C   0710A0E3           MOV      R1,#+7
   \   00000080   180094E5           LDR      R0,[R4, #+24]
   \   00000084   ........           BL       LCD_X_DisplayDriver
    902            }
    903          }
   \                     ??_SetSize_1:
   \   00000088   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   0000008C   7080BDE8           POP      {R4-R6,PC}       ;; return
    904          
    905          /*********************************************************************
    906          *
    907          *       _SetPos
    908          */

   \                                 In section .text, align 4, keep-with-next
    909          static void _SetPos(GUI_DEVICE * pDevice, int xPos, int yPos) {
   \                     _SetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    910            DRIVER_CONTEXT * pContext;
    911            LCD_X_SETPOS_INFO Data = {0};
   \   00000008   ............       ADRL     R1,`?<Constant {0}>_2`
   \              ....        
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   08D04DE2           SUB      SP,SP,#+8
   \   00000018   0040A0E1           MOV      R4,R0
   \   0000001C   002091E5           LDR      R2,[R1, #+0]
   \   00000020   043091E5           LDR      R3,[R1, #+4]
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   0C0080E8           STM      R0,{R2,R3}
    912          
    913            _InitOnce(pDevice);
   \   0000002C   080094E5           LDR      R0,[R4, #+8]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0500001A           BNE      ??_SetPos_0
   \   00000038   2C00A0E3           MOV      R0,#+44
   \   0000003C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000040   080084E5           STR      R0,[R4, #+8]
   \   00000044   2C20A0E3           MOV      R2,#+44
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   ........           BL       GUI__memset
    914            if (pDevice->u.pContext) {
   \                     ??_SetPos_0:
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0700000A           BEQ      ??_SetPos_1
    915              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    916              pContext->xPos = xPos;
   \   0000005C   185080E5           STR      R5,[R0, #+24]
    917              pContext->yPos = yPos;
   \   00000060   1C6080E5           STR      R6,[R0, #+28]
    918              Data.xPos = xPos;
   \   00000064   00508DE5           STR      R5,[SP, #+0]
    919              Data.yPos = yPos;
   \   00000068   04608DE5           STR      R6,[SP, #+4]
    920              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETPOS, (void *)&Data);
   \   0000006C   0D20A0E1           MOV      R2,SP
   \   00000070   0810A0E3           MOV      R1,#+8
   \   00000074   180094E5           LDR      R0,[R4, #+24]
   \   00000078   ........           BL       LCD_X_DisplayDriver
    921            }
    922          }
   \                     ??_SetPos_1:
   \   0000007C   08D08DE2           ADD      SP,SP,#+8        ;; stack cleaning
   \   00000080   7080BDE8           POP      {R4-R6,PC}       ;; return
    923          
    924          /*********************************************************************
    925          *
    926          *       _GetPos
    927          */

   \                                 In section .text, align 4, keep-with-next
    928          static void _GetPos(GUI_DEVICE * pDevice, int * pxPos, int * pyPos) {
   \                     _GetPos:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    929            DRIVER_CONTEXT * pContext;
    930          
    931            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_GetPos_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
    932            if (pDevice->u.pContext) {
   \                     ??_GetPos_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0300000A           BEQ      ??_GetPos_1
    933              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    934              *pxPos = pContext->xPos;
   \   00000040   181090E5           LDR      R1,[R0, #+24]
   \   00000044   001085E5           STR      R1,[R5, #+0]
    935              *pyPos = pContext->yPos;
   \   00000048   1C0090E5           LDR      R0,[R0, #+28]
   \   0000004C   000086E5           STR      R0,[R6, #+0]
    936            }
    937          }
   \                     ??_GetPos_1:
   \   00000050   7080BDE8           POP      {R4-R6,PC}       ;; return
    938          
    939          /*********************************************************************
    940          *
    941          *       _SetAlpha
    942          */

   \                                 In section .text, align 4, keep-with-next
    943          static void _SetAlpha(GUI_DEVICE * pDevice, int Alpha) {
   \                     _SetAlpha:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    944            DRIVER_CONTEXT * pContext;
    945            LCD_X_SETALPHA_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_3`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
    946          
    947            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetAlpha_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
    948            if (pDevice->u.pContext) {
   \                     ??_SetAlpha_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetAlpha_1
    949              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    950              pContext->Alpha = Alpha;
   \   0000004C   205080E5           STR      R5,[R0, #+32]
    951              Data.Alpha = Alpha;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
    952              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHA, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0A10A0E3           MOV      R1,#+10
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
    953            }
    954          }
   \                     ??_SetAlpha_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
    955          
    956          /*********************************************************************
    957          *
    958          *       _SetVis
    959          */

   \                                 In section .text, align 4, keep-with-next
    960          static void _SetVis(GUI_DEVICE * pDevice, int OnOff) {
   \                     _SetVis:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    961            DRIVER_CONTEXT * pContext;
    962            LCD_X_SETVIS_INFO Data = {0};
   \   00000008   ........           ADR      R1,`?<Constant {0}>_4`
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   00108DE5           STR      R1,[SP, #+0]
    963          
    964            _InitOnce(pDevice);
   \   0000001C   080094E5           LDR      R0,[R4, #+8]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0500001A           BNE      ??_SetVis_0
   \   00000028   2C00A0E3           MOV      R0,#+44
   \   0000002C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000030   080084E5           STR      R0,[R4, #+8]
   \   00000034   2C20A0E3           MOV      R2,#+44
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   ........           BL       GUI__memset
    965            if (pDevice->u.pContext) {
   \                     ??_SetVis_0:
   \   00000040   080094E5           LDR      R0,[R4, #+8]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??_SetVis_1
    966              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
    967              pContext->IsVisible = OnOff;
   \   0000004C   245080E5           STR      R5,[R0, #+36]
    968              Data.OnOff = OnOff;
   \   00000050   00508DE5           STR      R5,[SP, #+0]
    969              LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETVIS, (void *)&Data);
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   0910A0E3           MOV      R1,#+9
   \   0000005C   180094E5           LDR      R0,[R4, #+24]
   \   00000060   ........           BL       LCD_X_DisplayDriver
    970            }
    971          }
   \                     ??_SetVis_1:
   \   00000064   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
    972          
    973          /*********************************************************************
    974          *
    975          *       _Init
    976          */

   \                                 In section .text, align 4, keep-with-next
    977          static int  _Init(GUI_DEVICE * pDevice) {
   \                     _Init:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    978            int r;
    979          
    980            r = _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0500001A           BNE      ??_Init_0
   \   00000018   2C00A0E3           MOV      R0,#+44
   \   0000001C   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000020   080084E5           STR      R0,[R4, #+8]
   \   00000024   2C20A0E3           MOV      R2,#+44
   \   00000028   0010A0E3           MOV      R1,#+0
   \   0000002C   ........           BL       GUI__memset
   \                     ??_Init_0:
   \   00000030   080094E5           LDR      R0,[R4, #+8]
    981            r |= LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_INITCONTROLLER, NULL);
    982            return r;
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0150A003           MOVEQ    R5,#+1
   \   00000040   0050A013           MOVNE    R5,#+0
   \   00000044   0110A0E3           MOV      R1,#+1
   \   00000048   180094E5           LDR      R0,[R4, #+24]
   \   0000004C   ........           BL       LCD_X_DisplayDriver
   \   00000050   050080E1           ORR      R0,R0,R5
   \   00000054   04D08DE2           ADD      SP,SP,#+4
   \   00000058   3080BDE8           POP      {R4,R5,PC}       ;; return
    983          }
    984          
    985          /*********************************************************************
    986          *
    987          *       _On
    988          */

   \                                 In section .text, align 4, keep-with-next
    989          static void _On (GUI_DEVICE * pDevice) {
    990            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_ON, NULL);
   \                     _On:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0510A0E3           MOV      R1,#+5
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
    991          }
    992          
    993          /*********************************************************************
    994          *
    995          *       _Off
    996          */

   \                                 In section .text, align 4, keep-with-next
    997          static void _Off (GUI_DEVICE * pDevice) {
    998            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_OFF, NULL);
   \                     _Off:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0610A0E3           MOV      R1,#+6
   \   00000008   180090E5           LDR      R0,[R0, #+24]
   \   0000000C   ........           B        LCD_X_DisplayDriver  ;; tailcall
    999          }
   1000          
   1001          /*********************************************************************
   1002          *
   1003          *       _SetLUTEntry
   1004          */

   \                                 In section .text, align 4, keep-with-next
   1005          static void _SetLUTEntry(GUI_DEVICE * pDevice, U8 Pos, LCD_COLOR Color) {
   \                     _SetLUTEntry:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1006            LCD_X_SETLUTENTRY_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
   1007          
   1008            Data.Pos   = Pos;
   \   0000001C   0410CDE5           STRB     R1,[SP, #+4]
   1009            Data.Color = Color;
   \   00000020   00208DE5           STR      R2,[SP, #+0]
   1010            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETLUTENTRY, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0410A0E3           MOV      R1,#+4
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
   1011          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
   1012          
   1013          /*********************************************************************
   1014          *
   1015          *       _SetAlphaMode
   1016          */

   \                                 In section .text, align 4, keep-with-next
   1017          static void _SetAlphaMode(GUI_DEVICE * pDevice, int AlphaMode) {
   \                     _SetAlphaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1018            LCD_X_SETALPHAMODE_INFO Data = {0};
   1019          
   1020            Data.AlphaMode = AlphaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
   1021            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETALPHAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0B10A0E3           MOV      R1,#+11
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
   1022          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1023          
   1024          /*********************************************************************
   1025          *
   1026          *       _SetChromaMode
   1027          */

   \                                 In section .text, align 4, keep-with-next
   1028          static void _SetChromaMode(GUI_DEVICE * pDevice, int ChromaMode) {
   \                     _SetChromaMode:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   1029            LCD_X_SETCHROMAMODE_INFO Data = {0};
   1030          
   1031            Data.ChromaMode = ChromaMode;
   \   00000008   00108DE5           STR      R1,[SP, #+0]
   1032            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMAMODE, (void *)&Data);
   \   0000000C   0D20A0E1           MOV      R2,SP
   \   00000010   0C10A0E3           MOV      R1,#+12
   \   00000014   180090E5           LDR      R0,[R0, #+24]
   \   00000018   ........           BL       LCD_X_DisplayDriver
   1033          }
   \   0000001C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000020   0080BDE8           POP      {PC}             ;; return
   1034          
   1035          /*********************************************************************
   1036          *
   1037          *       _SetChroma
   1038          */

   \                                 In section .text, align 4, keep-with-next
   1039          static void _SetChroma(GUI_DEVICE * pDevice, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax) {
   \                     _SetChroma:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1040            LCD_X_SETCHROMA_INFO Data = {0};
   \   00000004   ........           ADR      R12,`?<Constant {0L}>_1`
   \   00000008   0CD04DE2           SUB      SP,SP,#+12
   \   0000000C   00409CE5           LDR      R4,[R12, #+0]
   \   00000010   04509CE5           LDR      R5,[R12, #+4]
   \   00000014   0D30A0E1           MOV      R3,SP
   \   00000018   300083E8           STM      R3,{R4,R5}
   1041          
   1042            Data.ChromaMin = ChromaMin;
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
   1043            Data.ChromaMax = ChromaMax;
   \   00000020   04208DE5           STR      R2,[SP, #+4]
   1044            LCD_X_DisplayDriver(pDevice->LayerIndex, LCD_X_SETCHROMA, (void *)&Data);
   \   00000024   0D20A0E1           MOV      R2,SP
   \   00000028   0D10A0E3           MOV      R1,#+13
   \   0000002C   180090E5           LDR      R0,[R0, #+24]
   \   00000030   ........           BL       LCD_X_DisplayDriver
   1045          }
   \   00000034   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   00000038   3080BDE8           POP      {R4,R5,PC}       ;; return
   1046          
   1047          /*********************************************************************
   1048          *
   1049          *       _SetFunc
   1050          */

   \                                 In section .text, align 4, keep-with-next
   1051          static void _SetFunc(GUI_DEVICE * pDevice, int Index, void (* pFunc)(void)) {
   \                     _SetFunc:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1052            DRIVER_CONTEXT * pContext;
   1053          
   1054            _InitOnce(pDevice);
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??_SetFunc_0
   \   0000001C   2C00A0E3           MOV      R0,#+44
   \   00000020   ........           BL       GUI_ALLOC_GetFixedBlock
   \   00000024   080084E5           STR      R0,[R4, #+8]
   \   00000028   2C20A0E3           MOV      R2,#+44
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   ........           BL       GUI__memset
   1055            if (pDevice->u.pContext) {
   \                     ??_SetFunc_0:
   \   00000034   080094E5           LDR      R0,[R4, #+8]
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0100000A           BEQ      ??_SetFunc_1
   1056              pContext = (DRIVER_CONTEXT *)pDevice->u.pContext;
   1057              switch (Index) {
   \   00000040   170055E3           CMP      R5,#+23
   1058              case LCD_DEVFUNC_FILLRECT:
   1059                pContext->pfFillRect = (void (*)(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex))pFunc;
   \   00000044   28608005           STREQ    R6,[R0, #+40]
   1060                break;
   1061              }
   1062            }
   1063          }
   \                     ??_SetFunc_1:
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1064          
   1065          /*********************************************************************
   1066          *
   1067          *       _GetDevFunc
   1068          */

   \                                 In section .text, align 4, keep-with-next
   1069          static void (* _GetDevFunc(GUI_DEVICE ** ppDevice, int Index))(void) {
   1070            GUI_USE_PARA(ppDevice);
   1071            switch (Index) {
   \                     _GetDevFunc:
   \   00000000   011041E2           SUB      R1,R1,#+1
   \   00000004   150051E3           CMP      R1,#+21
   \   00000008   01F18F90           ADDLS    PC,PC,R1, LSL #+2
   \                     ??_GetDevFunc_0:
   \   0000000C   3500008A           BHI      ??_GetDevFunc_1
   \   00000010   140000EA           B        ??_GetDevFunc_2
   \   00000014   1F0000EA           B        ??_GetDevFunc_3
   \   00000018   1A0000EA           B        ??_GetDevFunc_4
   \   0000001C   1B0000EA           B        ??_GetDevFunc_5
   \   00000020   300000EA           B        ??_GetDevFunc_1
   \   00000024   1D0000EA           B        ??_GetDevFunc_6
   \   00000028   2E0000EA           B        ??_GetDevFunc_1
   \   0000002C   2D0000EA           B        ??_GetDevFunc_1
   \   00000030   0E0000EA           B        ??_GetDevFunc_7
   \   00000034   0F0000EA           B        ??_GetDevFunc_8
   \   00000038   100000EA           B        ??_GetDevFunc_9
   \   0000003C   190000EA           B        ??_GetDevFunc_10
   \   00000040   280000EA           B        ??_GetDevFunc_1
   \   00000044   190000EA           B        ??_GetDevFunc_11
   \   00000048   1A0000EA           B        ??_GetDevFunc_12
   \   0000004C   1B0000EA           B        ??_GetDevFunc_13
   \   00000050   240000EA           B        ??_GetDevFunc_1
   \   00000054   230000EA           B        ??_GetDevFunc_1
   \   00000058   1A0000EA           B        ??_GetDevFunc_14
   \   0000005C   1B0000EA           B        ??_GetDevFunc_15
   \   00000060   1C0000EA           B        ??_GetDevFunc_16
   \   00000064   1D0000EA           B        ??_GetDevFunc_17
   1072            case LCD_DEVFUNC_READRECT:
   1073              return (void (*)(void))_ReadRect;
   \                     ??_GetDevFunc_2:
   \   00000068   ........           LDR      R0,??DataTable17_1
   \   0000006C   1EFF2FE1           BX       LR
   1074            case LCD_DEVFUNC_SET_VRAM_ADDR:
   1075              return (void (*)(void))_SetVRAMAddr;
   \                     ??_GetDevFunc_7:
   \   00000070   ........           LDR      R0,??DataTable17_2
   \   00000074   1EFF2FE1           BX       LR
   1076            case LCD_DEVFUNC_SET_VSIZE:
   1077              return (void (*)(void))_SetVSize;
   \                     ??_GetDevFunc_8:
   \   00000078   ........           LDR      R0,??DataTable17_3
   \   0000007C   1EFF2FE1           BX       LR
   1078            case LCD_DEVFUNC_SET_SIZE:
   1079              return (void (*)(void))_SetSize;
   \                     ??_GetDevFunc_9:
   \   00000080   ........           LDR      R0,??DataTable17_4
   \   00000084   1EFF2FE1           BX       LR
   1080            case LCD_DEVFUNC_SETPOS:
   1081              return (void (*)(void))_SetPos;
   \                     ??_GetDevFunc_4:
   \   00000088   ........           LDR      R0,??DataTable17_5
   \   0000008C   1EFF2FE1           BX       LR
   1082            case LCD_DEVFUNC_GETPOS:
   1083              return (void (*)(void))_GetPos;
   \                     ??_GetDevFunc_5:
   \   00000090   ........           LDR      R0,??DataTable17_6
   \   00000094   1EFF2FE1           BX       LR
   1084            case LCD_DEVFUNC_SETALPHA:
   1085              return (void (*)(void))_SetAlpha;
   \                     ??_GetDevFunc_3:
   \   00000098   ........           LDR      R0,??DataTable17_7
   \   0000009C   1EFF2FE1           BX       LR
   1086            case LCD_DEVFUNC_SETVIS:
   1087              return (void (*)(void))_SetVis;
   \                     ??_GetDevFunc_6:
   \   000000A0   ........           LDR      R0,??DataTable17_8
   \   000000A4   1EFF2FE1           BX       LR
   1088            case LCD_DEVFUNC_INIT:
   1089              return (void (*)(void))_Init;
   \                     ??_GetDevFunc_10:
   \   000000A8   ........           LDR      R0,??DataTable17_9
   \   000000AC   1EFF2FE1           BX       LR
   1090            case LCD_DEVFUNC_ON:
   1091              return (void (*)(void))_On;
   \                     ??_GetDevFunc_11:
   \   000000B0   ........           LDR      R0,??DataTable17_10
   \   000000B4   1EFF2FE1           BX       LR
   1092            case LCD_DEVFUNC_OFF:
   1093              return (void (*)(void))_Off;
   \                     ??_GetDevFunc_12:
   \   000000B8   ........           LDR      R0,??DataTable17_11
   \   000000BC   1EFF2FE1           BX       LR
   1094            case LCD_DEVFUNC_SETLUTENTRY:
   1095              return (void (*)(void))_SetLUTEntry;
   \                     ??_GetDevFunc_13:
   \   000000C0   ........           LDR      R0,??DataTable17_12
   \   000000C4   1EFF2FE1           BX       LR
   1096          
   1097            case LCD_DEVFUNC_ALPHAMODE:
   1098              return (void (*)(void))_SetAlphaMode;
   \                     ??_GetDevFunc_14:
   \   000000C8   ........           LDR      R0,??DataTable17_13
   \   000000CC   1EFF2FE1           BX       LR
   1099            case LCD_DEVFUNC_CHROMAMODE:
   1100              return (void (*)(void))_SetChromaMode;
   \                     ??_GetDevFunc_15:
   \   000000D0   ........           LDR      R0,??DataTable17_14
   \   000000D4   1EFF2FE1           BX       LR
   1101            case LCD_DEVFUNC_CHROMA:
   1102              return (void (*)(void))_SetChroma;
   \                     ??_GetDevFunc_16:
   \   000000D8   ........           LDR      R0,??DataTable17_15
   \   000000DC   1EFF2FE1           BX       LR
   1103            
   1104            case LCD_DEVFUNC_SETFUNC:
   1105              return (void (*)(void))_SetFunc;
   \                     ??_GetDevFunc_17:
   \   000000E0   ........           LDR      R0,??DataTable17_16
   \   000000E4   1EFF2FE1           BX       LR
   1106            }
   1107            return NULL;
   \                     ??_GetDevFunc_1:
   \   000000E8   0000A0E3           MOV      R0,#+0
   \   000000EC   1EFF2FE1           BX       LR               ;; return
   1108          }
   1109          
   1110          /*********************************************************************
   1111          *
   1112          *       Public data
   1113          *
   1114          **********************************************************************
   1115          */
   1116          /*********************************************************************
   1117          *
   1118          *       GUI_DEVICE_API structure
   1119          */

   \                                 In section .rodata, align 4, keep-with-next
   1120          const GUI_DEVICE_API GUIDRV_Lin_OXY_32_API = {
   \                     GUIDRV_Lin_OXY_32_API:
   \   00000000                      ; Initializer data, 52 bytes
   \   00000000   00000000....       DC32 0, _DrawBitmap, _DrawHLine, _DrawVLine, _FillRect, _GetPixelIndex, _SetPixelIndex, _XorPixel, _SetOrg, _GetDevFunc
   \              ............
   \              ............
   \              ............
   \              ............
   \              ............
   \              ........    
   \   00000028   ............       DC32 _GetDevProp, _GetDevData, _GetRect
   \              ............

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   ........           DC32     LCD_pColorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   ........           DC32     LCD_aMirror

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   ........           DC32     GUI_MEMDEV_DEVICE_32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   ........           DC32     _ReadRect

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   ........           DC32     _SetVRAMAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   ........           DC32     _SetVSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   ........           DC32     _SetSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   ........           DC32     _SetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   ........           DC32     _GetPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   ........           DC32     _SetAlpha

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   ........           DC32     _SetVis

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   ........           DC32     _Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   ........           DC32     _On

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   ........           DC32     _Off

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   ........           DC32     _SetLUTEntry

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   ........           DC32     _SetAlphaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   ........           DC32     _SetChromaMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \   00000000   ........           DC32     _SetChroma

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_16:
   \   00000000   ........           DC32     _SetFunc

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {(void *)0}>`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_2`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_3`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>_4`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   00000000           DC32 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0L}>_1`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   00000000           DC32 0
   \   00000004   00000000           DC8 0, 0, 0, 0
   1121            //
   1122            // Data
   1123            //
   1124            DEVICE_CLASS_DRIVER,
   1125            //
   1126            // Drawing functions
   1127            //
   1128            _DrawBitmap,
   1129            _DrawHLine,
   1130            _DrawVLine,
   1131            _FillRect,
   1132            _GetPixelIndex,
   1133            _SetPixelIndex,
   1134            _XorPixel,
   1135            //
   1136            // Set origin
   1137            //
   1138            _SetOrg,
   1139            //
   1140            // Request information
   1141            //
   1142            _GetDevFunc,
   1143            _GetDevProp,
   1144            _GetDevData,
   1145            _GetRect,
   1146          };
   1147          
   1148          #else
   1149          
   1150          void GUIDRV_Lin_OXY_32_C(void);   // Avoid empty object files
   1151          void GUIDRV_Lin_OXY_32_C(void) {}
   1152          
   1153          #endif
   1154          
   1155          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     _DrawBitLine1BPP     40
     _DrawBitLine2BPP     20
     _DrawBitLine4BPP     20
     _DrawBitLine8BPP     12
     _DrawBitmap          56
     _DrawHLine           24
     _DrawVLine           24
     _FillRect            24
     _GetDevData           0
     _GetDevFunc           0
     _GetDevProp           0
     _GetPixelIndex        0
     _GetPos              16
     _GetRect              0
     _Init                16
     _Off                  8
     _On                   8
     _ReadRect            16
     _SetAlpha            16
     _SetAlphaMode         8
     _SetChroma           24
     _SetChromaMode        8
     _SetFunc             16
     _SetLUTEntry         24
     _SetOrg              24
     _SetPixelIndex        4
     _SetPos              24
     _SetSize             24
     _SetVRAMAddr         16
     _SetVSize            16
     _SetVis              16
     _XorPixel            24


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     _SetPixelIndex            52
     _GetPixelIndex            48
     _XorPixel                132
     _DrawHLine               340
     _DrawVLine               244
     _FillRect                288
     _DrawBitLine1BPP         448
     _DrawBitLine2BPP         236
     _DrawBitLine4BPP         236
     _DrawBitLine8BPP         360
     _DrawBitmap             1124
     _SetOrg                  100
     _GetRect                  44
     _GetDevProp              140
     _GetDevData               24
     _ReadRect                124
     _SetVRAMAddr             112
     _SetVSize                 76
     _SetSize                 144
     _SetPos                  132
     _GetPos                   84
     _SetAlpha                108
     _SetVis                  108
     _Init                     92
     _On                       16
     _Off                      16
     _SetLUTEntry              60
     _SetAlphaMode             36
     _SetChromaMode            36
     _SetChroma                60
     _SetFunc                  76
     _GetDevFunc              240
     GUIDRV_Lin_OXY_32_API     52
     ??DataTable16              4
     ??DataTable16_1            4
     ??DataTable16_2            4
     ??DataTable17              4
     ??DataTable17_1            4
     ??DataTable17_2            4
     ??DataTable17_3            4
     ??DataTable17_4            4
     ??DataTable17_5            4
     ??DataTable17_6            4
     ??DataTable17_7            4
     ??DataTable17_8            4
     ??DataTable17_9            4
     ??DataTable17_10           4
     ??DataTable17_11           4
     ??DataTable17_12           4
     ??DataTable17_13           4
     ??DataTable17_14           4
     ??DataTable17_15           4
     ??DataTable17_16           4
     ?<Constant {0}>            8
     ?<Constant {(void *)0}>    4
     ?<Constant {0}>_1          8
     ?<Constant {0}>_2          8
     ?<Constant {0}>_3          4
     ?<Constant {0}>_4          4
     ?<Constant {0L}>           8
     ?<Constant {0L}>_1         8

 
    52 bytes in section .rodata
 5 468 bytes in section .text
 
 5 468 bytes of CODE  memory
    52 bytes of CONST memory

Errors: none
Warnings: none
