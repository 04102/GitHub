; .\fdl.SRC generated from: ..\CommonFiles\fdl.c
; COMPILER INVOKED BY:
;        C:\Keil\C51\BIN\C51.EXE ..\CommonFiles\fdl.c OPTIMIZE(9,SIZE) BROWSE MDU_F120 INCDIR(..\..\C51\INC\;..\CommonFiles\) DB DEFINE(DISPLAY,EXTCLK6,NODEBUG,PACKMEM) PRINT(.\fdl.lst) SRC(.\fdl.SRC)

$NOMOD51

NAME	FDL

CCF2	BIT	0D8H.2
TB80	BIT	098H.3
SPI0CKR	DATA	09DH
CCF3	BIT	0D8H.3
TB81	BIT	098H.3
P0	DATA	080H
SPIEN	BIT	0F8H.0
CCF4	BIT	0D8H.4
SM00	BIT	098H.7
P1	DATA	090H
PLL0FLT	DATA	08FH
CCF5	BIT	0D8H.5
AA	BIT	0C0H.2
SM10	BIT	098H.6
WDTCN	DATA	0FFH
P2	DATA	0A0H
A0_DISP	BIT	0C8H.0
SM20	BIT	098H.5
ADC0CF	DATA	0BCH
P3	DATA	0B0H
AC	BIT	0D0H.6
P4	DATA	0C8H
ONOFF_SW	BIT	0D8H.6
PCA0	DATA	0F9H
EIE1	DATA	0E6H
P5	DATA	0D8H
ADC2CF	DATA	0BCH
EA	BIT	0A8H.7
P6	DATA	0E8H
EIE2	DATA	0E7H
MCE1	BIT	098H.5
P7	DATA	0F8H
E1_DISP	BIT	0C8H.1
PSCTL	DATA	08FH
E2_DISP	BIT	0C8H.2
CF	BIT	0D8H.7
PLL0MUL	DATA	08EH
ADC0CN	DATA	0E8H
DAC0CN	DATA	0D4H
SFRPAGE	DATA	084H
RST_DISP	BIT	0C8H.4
DAC1CN	DATA	0D4H
MAC0CF	DATA	0C3H
MAC0AH	DATA	0C2H
P0MDOUT	DATA	0A4H
ADC2CN	DATA	0E8H
P1MDOUT	DATA	0A5H
MAC0BH	DATA	092H
IE	DATA	0A8H
P2MDOUT	DATA	0A6H
CCH0MA	DATA	09AH
P3MDOUT	DATA	0A7H
CCH0LC	DATA	0A3H
EIP1	DATA	0F6H
MAC0AL	DATA	0C1H
P4MDOUT	DATA	09CH
TXBMT	BIT	0F8H.1
EIP2	DATA	0F7H
CCH0CN	DATA	0A1H
P5MDOUT	DATA	09DH
MAC0BL	DATA	091H
DF_WP	BIT	0F8H.0
PCA0CPH0	DATA	0FCH
P6MDOUT	DATA	09EH
PCA0CPH1	DATA	0FEH
P7MDOUT	DATA	09FH
DP	DATA	082H
PCA0CPH2	DATA	0EAH
ADC0GT	DATA	0C4H
CR	BIT	0D8H.6
PCA0CPH3	DATA	0ECH
EXF2	BIT	0C8H.6
REN0	BIT	098H.4
PCA0CPL0	DATA	0FBH
PCA0CPH4	DATA	0EEH
EMI0CF	DATA	0A3H
SFRPGCN	DATA	096H
EXF3	BIT	0C8H.6
REN1	BIT	098H.4
PCA0CPL1	DATA	0FDH
PCA0CPH5	DATA	0E2H
PCA0CPM0	DATA	0DAH
PCA0MD	DATA	0D9H
PCA0CN	DATA	0D8H
ADC2GT	DATA	0C4H
EXF4	BIT	0C8H.6
PCA0CPL2	DATA	0E9H
PCA0CPM1	DATA	0DBH
PCA0CPL3	DATA	0EBH
PCA0CPM2	DATA	0DCH
IP	DATA	0B8H
ADC0LT	DATA	0C6H
MAC0HO	BIT	0C0H.3
CP0FIF	BIT	088H.4
PCA0CPL4	DATA	0EDH
PCA0CPM3	DATA	0DDH
CP1FIF	BIT	088H.4
PCA0CPL5	DATA	0E1H
PCA0CPM4	DATA	0DEH
CY	BIT	0D0H.7
SI	BIT	0C0H.3
PCA0CPM5	DATA	0DFH
ADC2LT	DATA	0C6H
BACK_SW	BIT	0D8H.3
DN_SW	BIT	0D8H.4
XBR0	DATA	0E1H
SADEN0	DATA	0B9H
XBR1	DATA	0E2H
EMI0CN	DATA	0A2H
XBR2	DATA	0E3H
FLHBUSY	BIT	088H.0
REF0CN	DATA	0D1H
SADDR0	DATA	0A9H
AMX0CF	DATA	0BAH
AD0INT	BIT	0E8H.5
RCAP2H	DATA	0CBH
CCH0TN	DATA	0A2H
SFRLAST	DATA	086H
PS	BIT	0B8H.4
RCAP3H	DATA	0CBH
AMX2CF	DATA	0BAH
SP	DATA	081H
AD2INT	BIT	0E8H.5
RCAP4H	DATA	0CBH
EMI0TC	DATA	0A1H
OV	BIT	0D0H.2
MAC0SO	BIT	0C0H.1
SMB0CN	DATA	0C0H
TMR2	DATA	0CCH
CP0RIF	BIT	088H.5
RCAP2L	DATA	0CAH
TMR3	DATA	0CCH
MODF	BIT	0F8H.5
CP1RIF	BIT	088H.5
RCAP3L	DATA	0CAH
TMR4	DATA	0CCH
RCAP4L	DATA	0CAH
SMB0CR	DATA	0CFH
CPT0MD	DATA	089H
CPT0CN	DATA	088H
S1MODE	BIT	098H.7
P1MDIN	DATA	0ADH
PLL0CN	DATA	089H
CPT1MD	DATA	089H
CPT1CN	DATA	088H
SFRNEXT	DATA	085H
SPI0CN	DATA	0F8H
UP_SW	BIT	0D8H.2
MAC0RNDH	DATA	0CFH
TMR2CF	DATA	0C9H
TMR3CF	DATA	0C9H
PCON	DATA	087H
DF_CS1	BIT	0F8H.1
TMR4CF	DATA	0C9H
DF_CS2	BIT	0F8H.3
SPIF	BIT	0F8H.7
MAC0RNDL	DATA	0CEH
TMOD	DATA	089H
TCON	DATA	088H
WCOL	BIT	0F8H.6
NSSMD0	BIT	0F8H.2
AMX0SL	DATA	0BBH
NSSMD1	BIT	0F8H.3
TMR2CN	DATA	0C8H
TMR3CN	DATA	0C8H
AMX2SL	DATA	0BBH
LITE_SW	BIT	0D8H.0
TMR4CN	DATA	0C8H
RW_DISP	BIT	0C8H.3
CP0OUT	BIT	088H.6
CP1OUT	BIT	088H.6
IE0	BIT	088H.1
IE1	BIT	088H.3
OSCICL	DATA	08BH
CLKSEL	DATA	097H
B	DATA	0F0H
DAC0H	DATA	0D3H
ADC0H	DATA	0BFH
PSBANK	DATA	0B1H
OSCICN	DATA	08AH
DAC1H	DATA	0D3H
SMBFTE	BIT	0C0H.1
BUSY	BIT	0C0H.7
DAC0L	DATA	0D2H
ADC0L	DATA	0BEH
DAC1L	DATA	0D2H
ACC	DATA	0E0H
ES0	BIT	0A8H.4
PCA0CP0	DATA	0FBH
AD0EN	BIT	0E8H.7
CT2	BIT	0C8H.1
ET0	BIT	0A8H.1
PCA0CP1	DATA	0FDH
CT3	BIT	0C8H.1
ET1	BIT	0A8H.3
TF0	BIT	088H.5
PCA0CP2	DATA	0E9H
AD2EN	BIT	0E8H.7
CT4	BIT	0C8H.1
ET2	BIT	0A8H.5
RI0	BIT	098H.0
TF1	BIT	088H.7
PCA0CP3	DATA	0EBH
TF2	BIT	0C8H.7
SMBTOE	BIT	0C0H.0
RI1	BIT	098H.0
TH0	DATA	08CH
PCA0CP4	DATA	0EDH
TF3	BIT	0C8H.7
EX0	BIT	0A8H.0
TI0	BIT	098H.1
IT0	BIT	088H.0
PCA0H	DATA	0FAH
TH1	DATA	08DH
PCA0CP5	DATA	0E1H
TF4	BIT	0C8H.7
EX1	BIT	0A8H.2
TI1	BIT	098H.1
IT1	BIT	088H.2
EN3VDISP	BIT	0F8H.3
P	BIT	0D0H.0
BACKLITEKB	BIT	0F8H.5
MAC0N	BIT	0C0H.0
OSCXCN	DATA	08CH
TL0	DATA	08AH
FLSTAT	DATA	088H
PCA0L	DATA	0F9H
TL1	DATA	08BH
PT0	BIT	0B8H.1
RS0	BIT	0D0H.3
PT1	BIT	0B8H.3
RS1	BIT	0D0H.4
PT2	BIT	0B8H.5
TR0	BIT	088H.4
AD0TM	BIT	0E8H.6
CP0EN	BIT	088H.7
TR1	BIT	088H.6
TR2	BIT	0C8H.2
PX0	BIT	0B8H.0
CP1EN	BIT	088H.7
RCAP2	DATA	0CAH
AD2TM	BIT	0E8H.6
TR3	BIT	0C8H.2
PX1	BIT	0B8H.2
BACKLITEDS	BIT	0F8H.6
RCAP3	DATA	0CAH
TR4	BIT	0C8H.2
RCAP4	DATA	0CAH
MAC0Z	BIT	0C0H.2
DPH	DATA	083H
ADC0GTH	DATA	0C5H
DPL	DATA	082H
ADC0GTL	DATA	0C4H
SBUF0	DATA	099H
ADC0LTH	DATA	0C7H
SBUF1	DATA	099H
EXEN2	BIT	0C8H.3
RSTSRC	DATA	0EFH
FLACL	DATA	0B7H
DF_RST	BIT	0F8H.2
EXEN3	BIT	0C8H.3
CPRL2	BIT	0C8H.0
CP0HYN0	BIT	088H.0
SCON0	DATA	098H
EXEN4	BIT	0C8H.3
CPRL3	BIT	0C8H.0
CP1HYN0	BIT	088H.0
CP0HYN1	BIT	088H.1
SCON1	DATA	098H
CPRL4	BIT	0C8H.0
CP1HYN1	BIT	088H.1
CP0HYP0	BIT	088H.2
ADC0LTL	DATA	0C6H
CP1HYP0	BIT	088H.2
CP0HYP1	BIT	088H.3
STA	BIT	0C0H.5
CP1HYP1	BIT	088H.3
SMB0ADR	DATA	0C3H
MAC0STA	DATA	0C0H
SSTA0	DATA	091H
SMB0DAT	DATA	0C2H
TMR2H	DATA	0CDH
SPI0CFG	DATA	09AH
SEL_SW	BIT	0D8H.1
USB_PRESENT	BIT	0B0H.4
TMR3H	DATA	0CDH
CKCON	DATA	08EH
TMR4H	DATA	0CDH
RXOVRN	BIT	0F8H.4
TMR2L	DATA	0CCH
TMR3L	DATA	0CCH
AD0LJST	BIT	0E8H.0
TMR4L	DATA	0CCH
F0	BIT	0D0H.5
FLSCL	DATA	0B7H
AD0CM0	BIT	0E8H.2
F1	BIT	0D0H.1
STO	BIT	0C0H.4
ENSMB	BIT	0C0H.6
AD0CM1	BIT	0E8H.3
SPI0DAT	DATA	09BH
DAC0	DATA	0D2H
ADC0	DATA	0BEH
AD2CM0	BIT	0E8H.1
DAC1	DATA	0D2H
AD2CM1	BIT	0E8H.2
AD0WINT	BIT	0E8H.1
AD2CM2	BIT	0E8H.3
AD0BUSY	BIT	0E8H.4
PSW	DATA	0D0H
ADC2	DATA	0BEH
MAC0OVR	DATA	097H
MAC0ACC0	DATA	093H
AD2WINT	BIT	0E8H.0
MAC0ACC1	DATA	094H
AD2BUSY	BIT	0E8H.4
CCF0	BIT	0D8H.0
RB80	BIT	098H.2
SMB0STA	DATA	0C1H
MAC0ACC2	DATA	095H
CCF1	BIT	0D8H.1
RB81	BIT	098H.2
MAC0ACC3	DATA	096H
PLL0DIV	DATA	08DH
?PR?_CopytoCodeSpace?FDL                 SEGMENT CODE 
?DT?_CopytoCodeSpace?FDL                 SEGMENT DATA OVERLAYABLE 
?PR?_FDL_xferSPI?FDL SEGMENT CODE 
?PR?FDL_DataFlash_Read_Status?FDL        SEGMENT CODE 
?DT?FDL_DataFlash_Read_Status?FDL        SEGMENT DATA OVERLAYABLE 
?PR?FDL              SEGMENT CODE 
	EXTRN	XDATA (flashpage)
	EXTRN	CODE (?C?CSTPTR)
	EXTRN	CODE (?C?PLDIIDATA)
	PUBLIC	FDL_DataFlash_Read_Status
	PUBLIC	_FDL_xferSPI
	PUBLIC	_CopytoCodeSpace

	RSEG  ?DT?FDL_DataFlash_Read_Status?FDL
?FDL_DataFlash_Read_Status?BYTE:
          q?251:   DS   2

	RSEG  ?DT?_CopytoCodeSpace?FDL
?_CopytoCodeSpace?BYTE:
   lastpage?040:   DS   2
	ORG  11
          q?041:   DS   2
	ORG  11
          q?042:   DS   2
	ORG  11
          q?043:   DS   2
	ORG  2
     pwrite?044:   DS   3
	ORG  5
    EA_save?045:   DS   1
	ORG  6
          i?046:   DS   2
	ORG  8
       page?047:   DS   2
	ORG  10
     status?048:   DS   1
; // software downloader
; //
; // this must be less than 510 bytes when compiled which is very tight. It must
; // not extend into address 0xFFFE or 0xFFFF, the micro flash lock bytes
; // it is loaded at 0xFE00 and must be self-contained so the code copy will
; // not overwrite it.
; //
; // initial implementation John Paulos, 04/26/2005
; // re-written Glenn Stephens, 05/02/2005
; //
; 
; #include <tmtypes.h>
; #ifdef DISPLAY
; #include <display.h>
; #else
; #include <sensor.h>
; #endif
; 
; //#define DFWAITREAD do {int q; for (q=0; q<64; q++) ; } while(0)  // 64 seems to work well. should be verified.
; //#define DFWAITWRITE do {int q; for (q=0; q<64; q++) ; } while(0)  // longer for erase.
; #define DFWAIT do {int q; for (q=0; q<64; q++) ; } while(0)  // longer for erase.
; 
; u08 FDL_xferSPI (u08);
; u08 FDL_DataFlash_Read_Status(void);
; 

	RSEG  ?PR?FDL
Com0041:
L?0066:
	USING	0
	MOV  	A,#LOW (flashpage)
	ADD  	A,i?046+01H
	MOV  	DPL,A
	MOV  	A,#HIGH (flashpage)
	ADDC 	A,i?046
	MOV  	DPH,A
	RET  	
; END OF Com0041

; void CopytoCodeSpace(u16 lastpage) {

	RSEG  ?PR?_CopytoCodeSpace?FDL
_CopytoCodeSpace:
	USING	0
			; SOURCE LINE # 26
	MOV  	lastpage?040,R6
	MOV  	lastpage?040+01H,R7
; 	char * data pwrite;
; 	char EA_save;
; 	u16 i, page;
; 	u08 status;
; #pragma ASM
; // support code versions with roadblock at 0xfe00
	  
; // this code duplicates the c compiler argument passing code
	  
; //	argument passing, R6 = MSB, R7 = LSB
	  
; 	MOV  	lastpage?040,R6
	  MOV  	lastpage?040,R6
; 	MOV  	lastpage?040+01H,R7
	  MOV  	lastpage?040+01H,R7
; #pragma ENDASM
; 
; 	pwrite = 0x0;						// initialize code pointer
			; SOURCE LINE # 39
	MOV  	pwrite?044,#00H
	MOV  	pwrite?044+01H,#00H
	MOV  	pwrite?044+02H,#00H
; 
; 	EA_save = EA;						// save interrupt status
			; SOURCE LINE # 41
	MOV  	C,EA
	CLR  	A
	RLC  	A
	MOV  	EA_save?045,A
; 	EA = 0;								// disable interrupts
			; SOURCE LINE # 42
	CLR  	EA
; 
; 	SFRPAGE = LEGACY_PAGE;
			; SOURCE LINE # 44
	CLR  	A
	MOV  	SFRPAGE,A
; 	FLSCL |= 0x01;						// enable flash writes/erases from user software
			; SOURCE LINE # 45
	ORL  	FLSCL,#01H
; 
; 	PSCTL = 0x03;						// movx writes erase flash page
			; SOURCE LINE # 47
	MOV  	PSCTL,#03H
?C0001:
; 
; 	// erase code memory up to last 1024 page containing bootstrapper
; 	while (pwrite < LAST_CODE_PAGE) {	// stop one page from end of codespace
			; SOURCE LINE # 50
	MOV  	R3,pwrite?044
	MOV  	R2,pwrite?044+01H
	MOV  	R1,pwrite?044+02H
	MOV  	R6,AR2
	CLR  	C
	MOV  	A,R6
	SUBB 	A,#0FCH
	JNC  	?C0002
; 		*pwrite = 0x88;					// write any value to initiate page erase
			; SOURCE LINE # 51
	MOV  	A,#088H
	LCALL	?C?CSTPTR
; 		pwrite += CODE_PAGE_SIZE;		// point to next page
			; SOURCE LINE # 52
	CLR  	A
	ADD  	A,pwrite?044+02H
	MOV  	pwrite?044+02H,A
	MOV  	A,#04H
	ADDC 	A,pwrite?044+01H
	MOV  	pwrite?044+01H,A
; 	}
			; SOURCE LINE # 53
	SJMP 	?C0001
?C0002:
; 
; 	PSCTL = 0x00;						// movx writes to target ram
			; SOURCE LINE # 55
	CLR  	A
	MOV  	PSCTL,A
; 	pwrite = 0x00;						// reset code pointer
			; SOURCE LINE # 56
	MOV  	pwrite?044,A
	MOV  	pwrite?044+01H,A
	MOV  	pwrite?044+02H,A
; 
; 	// copy code over from dataflash to micro flash codespace 512 bytes at a time
; 	for (page=0; page < (BOOTSTRAP_ADDR/CODE_DOWNLOAD_SIZE); page++) {
			; SOURCE LINE # 59
	MOV  	page?047,A
	MOV  	page?047+01H,A
?C0003:
; 
; 		SFRPAGE = CONFIG_PAGE;
			; SOURCE LINE # 61
	MOV  	SFRPAGE,#0FH
?C0008:
; 
; //			FDL_DataFlash_Page_Read(MAX_PAGE_SIZE, flashpage.bigbuff, read_page);
; // function is put in line here to avoid passing pointer which uses code put in by 
; // compiler in lower code space
; 
; #ifdef SENSOR
; 		if (!(page % 4)) LED1 = ~LED1;;
; #endif
; 
; 		// wait for Serial Flash to be available
; 		do {
			; SOURCE LINE # 72
; 			status = FDL_DataFlash_Read_Status();
			; SOURCE LINE # 73
; 		} while (!(status & STATUS_READY_MASK));
			; SOURCE LINE # 74
	LCALL	L?0067
	JNB  	ACC.7,?C0008
; 
; 		// set CS to low
; 		DF_CS1 = 0;
			; SOURCE LINE # 77
	CLR  	DF_CS1
; 		DFWAIT;
			; SOURCE LINE # 78
	CLR  	A
	MOV  	q?041,A
	MOV  	q?041+01H,A
?C0012:
	INC  	q?041+01H
	MOV  	A,q?041+01H
	JNZ  	?C0053
	INC  	q?041
?C0053:
	XRL  	A,#040H
	ORL  	A,q?041
	JNZ  	?C0012
?C0010:
; 
; 		// shift out command
; 		FDL_xferSPI(MEMORY_PAGE_READ);
			; SOURCE LINE # 81
	MOV  	R7,#0D2H
; 	
; 		// shift out reserved bits and upper bits of page address
; 		FDL_xferSPI(page >> 6);	
			; SOURCE LINE # 84
	LCALL	L?0068
?C0054:
	XCH  	A,R6
	CLR  	C
	RRC  	A
	XCH  	A,R6
	RRC  	A
	DJNZ 	R0,?C0054
; 
; 		// shift out bottom 6 bits of page address and top bits of byte address
; 		FDL_xferSPI((u08) page << 2);
			; SOURCE LINE # 87
; 
; 		// shift out bottom 8 bits of unsigned char address
; 		FDL_xferSPI(0);
			; SOURCE LINE # 90
	LCALL	L?0063
; 
; 		// shift out 4 bytes of don't cares
; 		FDL_xferSPI(0);	FDL_xferSPI(0);	FDL_xferSPI(0);	FDL_xferSPI(0);
			; SOURCE LINE # 93
	CLR  	A
	LCALL	L?0064
; 
; 		// shift in the data
; 		for (i=0; i < CODE_DOWNLOAD_SIZE; i++)
			; SOURCE LINE # 96
	LCALL	L?0064
	MOV  	i?046,A
	MOV  	i?046+01H,A
?C0015:
; 			flashpage.bigbuff[i] =  FDL_xferSPI(0);
			; SOURCE LINE # 97
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	LCALL	L?0066
	MOV  	A,R7
	MOVX 	@DPTR,A
	INC  	i?046+01H
	MOV  	A,i?046+01H
	JNZ  	?C0055
	INC  	i?046
?C0055:
	CLR  	C
	MOV  	A,i?046
	SUBB 	A,#02H
	JC   	?C0015
?C0016:
; 
; 		// raise CS to end operation
; 		DF_CS1 = 1;
			; SOURCE LINE # 100
	SETB 	DF_CS1
; 
; // end of inline function
; 
; 		SFRPAGE = LEGACY_PAGE;
			; SOURCE LINE # 104
	CLR  	A
	MOV  	SFRPAGE,A
; 		PSCTL = 0x01;						// movx writes to codeflash
			; SOURCE LINE # 105
	MOV  	PSCTL,#01H
; 
; 		// copy dataflash page into micro flash
; 		for (i=0; i < CODE_DOWNLOAD_SIZE; i++)
			; SOURCE LINE # 108
	MOV  	i?046,A
	MOV  	i?046+01H,A
?C0018:
; 			*pwrite++ = flashpage.bigbuff[i];
			; SOURCE LINE # 109
	LCALL	L?0066
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	R0,#LOW (pwrite?044)
	CLR  	A
	MOV  	B,#01H
	LCALL	?C?PLDIIDATA
	MOV  	A,R7
	LCALL	?C?CSTPTR
	INC  	i?046+01H
	MOV  	A,i?046+01H
	JNZ  	?C0056
	INC  	i?046
?C0056:
	CJNE 	A,#00H,?C0018
	MOV  	A,i?046
	CJNE 	A,#02H,?C0018
?C0019:
; 
; 		PSCTL = 0x00;
			; SOURCE LINE # 111
	CLR  	A
	MOV  	PSCTL,A
; 	} // for
			; SOURCE LINE # 112
	INC  	page?047+01H
	MOV  	A,page?047+01H
	JNZ  	?C0058
	INC  	page?047
?C0058:
	CLR  	C
	SUBB 	A,#07FH
	MOV  	A,page?047
	SUBB 	A,#00H
	JNC  	$ + 5H
	LJMP 	?C0003
?C0004:
; 
; 	PSCTL = 0;							// movx writes target ram
			; SOURCE LINE # 114
	CLR  	A
	MOV  	PSCTL,A
; 
; 	FLSCL &= ~0x01;						// disable flash writes from user sw
			; SOURCE LINE # 116
	ANL  	FLSCL,#0FEH
; 	EA = EA_save;
			; SOURCE LINE # 117
	MOV  	A,EA_save?045
	ADD  	A,#0FFH
	MOV  	EA,C
; 	PSW = 0;
			; SOURCE LINE # 118
	CLR  	A
	MOV  	PSW,A
; 
; 	SFRPAGE = CONFIG_PAGE;
			; SOURCE LINE # 120
	MOV  	SFRPAGE,#0FH
; 
; 	// clear the flash - NOTE: cannot use global variables. Must choose max erase pages.
; 	for (page = 0; page < MAX_NUM_PAGES; page += 8) {
			; SOURCE LINE # 123
	MOV  	page?047,A
	MOV  	page?047+01H,A
?C0021:
	CLR  	C
	MOV  	A,page?047
	SUBB 	A,#020H
	JNC  	?C0035
?C0026:
; 
; #ifdef SENSOR
; 		// invert LED every so often
; 		if (!(page % 64)) LED2 = ~LED2;
; #endif
; 
; 		// inline dataflash erase block
; 
; 		// wait for Serial Flash to be available
; 		do {
			; SOURCE LINE # 133
; 			status = FDL_DataFlash_Read_Status();
			; SOURCE LINE # 134
; 		} while (!(status & STATUS_READY_MASK));
			; SOURCE LINE # 135
	LCALL	L?0067
	JNB  	ACC.7,?C0026
; 
; 		DF_CS1 = 0;
			; SOURCE LINE # 137
	CLR  	DF_CS1
; 		DFWAIT;
			; SOURCE LINE # 138
	CLR  	A
	MOV  	q?042,A
	MOV  	q?042+01H,A
?C0030:
	INC  	q?042+01H
	MOV  	A,q?042+01H
	JNZ  	?C0059
	INC  	q?042
?C0059:
	XRL  	A,#040H
	ORL  	A,q?042
	JNZ  	?C0030
?C0028:
; 
; 		//command
; 		FDL_xferSPI(BLOCK_ERASE);
			; SOURCE LINE # 141
	MOV  	R7,#050H
; 
; 		// shift out reserved bits and upper bits of page address
; 		FDL_xferSPI(page >> 6);
			; SOURCE LINE # 144
	LCALL	L?0068
?C0060:
	XCH  	A,R6
	CLR  	C
	RRC  	A
	XCH  	A,R6
	RRC  	A
	DJNZ 	R0,?C0060
; 
; 		// shift out bottom 6 bits of page address and top bits of byte address
; 		FDL_xferSPI((u08) page << 2);
			; SOURCE LINE # 147
; 
; 		// shift out bottom 8 bits of unsigned char address
; 		FDL_xferSPI(0);
			; SOURCE LINE # 150
	LCALL	L?0063
; 
; 		DF_CS1 = 1;
			; SOURCE LINE # 152
	SETB 	DF_CS1
; 
; 		// end of inline function
; 	} // for
			; SOURCE LINE # 155
	MOV  	A,#08H
	ADD  	A,page?047+01H
	MOV  	page?047+01H,A
	CLR  	A
	ADDC 	A,page?047
	MOV  	page?047,A
	SJMP 	?C0021
?C0035:
; 
; 	DFWAIT;
			; SOURCE LINE # 157
	CLR  	A
	MOV  	q?043,A
	MOV  	q?043+01H,A
?C0036:
	INC  	q?043+01H
	MOV  	A,q?043+01H
	JNZ  	?C0061
	INC  	q?043
?C0061:
	XRL  	A,#040H
	ORL  	A,q?043
	JNZ  	?C0036
?C0041:
; 	
; 	// wait for Serial Flash to be finished
; 	do {
			; SOURCE LINE # 160
; 		status = FDL_DataFlash_Read_Status();
			; SOURCE LINE # 161
	LCALL	FDL_DataFlash_Read_Status
	MOV  	status?048,R7
; 	} while (!(status & STATUS_READY_MASK));
			; SOURCE LINE # 162
	MOV  	A,status?048
	JNB  	ACC.7,?C0041
; 
; 	SFRPAGE = LEGACY_PAGE;
			; SOURCE LINE # 164
	CLR  	A
	MOV  	SFRPAGE,A
; 
; 	// pull the reset line to restart everything
; 	RSTSRC = RSTSRC | 0x01;
			; SOURCE LINE # 167
	ORL  	RSTSRC,#01H
; }
			; SOURCE LINE # 168
	RET  	
L?0063:
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	MOV  	R7,page?047+01H
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	RET  	
L?0064:
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	CLR  	A
	RET  	
L?0067:
	LCALL	FDL_DataFlash_Read_Status
	MOV  	status?048,R7
	MOV  	A,status?048
	RET  	
L?0068:
	LCALL	_FDL_xferSPI
	MOV  	A,page?047+01H
	MOV  	R6,page?047
	MOV  	R0,#06H
	RET  	
; END OF _CopytoCodeSpace

; 
; // simultaneously write	and read one unsigned char to SPI (mode 3). Blocking.
; u08 FDL_xferSPI (u08 ch) {

	RSEG  ?PR?_FDL_xferSPI?FDL
_FDL_xferSPI:
	USING	0
			; SOURCE LINE # 171
;---- Variable 'ch?149' assigned to Register 'R7' ----
; 
; 	u08 SFRPAGE_SAVE = SFRPAGE;			// Save Current SFR page
			; SOURCE LINE # 173
;---- Variable 'SFRPAGE_SAVE?150' assigned to Register 'R6' ----
	MOV  	R6,SFRPAGE
; 	SFRPAGE = SPI0_PAGE;
			; SOURCE LINE # 174
	CLR  	A
	MOV  	SFRPAGE,A
; 
; 	SPI0DAT = ch;
			; SOURCE LINE # 176
	MOV  	SPI0DAT,R7
?C0043:
; 
; 	// wait for shifting
; 	while (!SPIF) ;
			; SOURCE LINE # 179
	JNB  	SPIF,?C0043
?C0044:
; 
; 	SPIF = 0;			// clear the xfer complete flag
			; SOURCE LINE # 181
	CLR  	SPIF
; 
; 	ch = SPI0DAT;
			; SOURCE LINE # 183
	MOV  	R7,SPI0DAT
; 	
; 	SFRPAGE = SFRPAGE_SAVE;
			; SOURCE LINE # 185
	MOV  	SFRPAGE,R6
; 
; 	return (ch);
			; SOURCE LINE # 187
; }
			; SOURCE LINE # 188
?C0045:
	RET  	
; END OF _FDL_xferSPI

; 
; // returns the value of DataFlash Status Register. Non-blocking.
; u08 FDL_DataFlash_Read_Status(void) {

	RSEG  ?PR?FDL_DataFlash_Read_Status?FDL
FDL_DataFlash_Read_Status:
	USING	0
			; SOURCE LINE # 191
;    u08 dat;
; 
; 	DF_CS1 = 0;
			; SOURCE LINE # 194
	CLR  	DF_CS1
; 	DFWAIT;
			; SOURCE LINE # 195
	CLR  	A
	MOV  	q?251,A
	MOV  	q?251+01H,A
?C0049:
	INC  	q?251+01H
	MOV  	A,q?251+01H
	JNZ  	?C0062
	INC  	q?251
?C0062:
	XRL  	A,#040H
	ORL  	A,q?251
	JNZ  	?C0049
?C0047:
; 
; 	//command
; 	FDL_xferSPI(STATUS_REGISTER_READ);
			; SOURCE LINE # 198
	MOV  	R7,#0D7H
	LCALL	_FDL_xferSPI
; 
; 	dat = FDL_xferSPI(0);
			; SOURCE LINE # 200
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
;---- Variable 'dat?252' assigned to Register 'R7' ----
; 
; 	DF_CS1 = 1;
			; SOURCE LINE # 202
	SETB 	DF_CS1
;   
;    return (dat);
			; SOURCE LINE # 204
; }
			; SOURCE LINE # 205
?C0052:
	RET  	
; END OF FDL_DataFlash_Read_Status

	END
