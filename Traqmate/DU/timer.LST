C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN timer.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE timer.c OPTIMIZE(9,SIZE) BROWSE MDU_F120 INCDIR(..\..\C51\INC\;..\CommonFil
                    -es\) DB DEFINE(DISPLAY,EXTCLK6,NODEBUG,PACKMEM)

line level    source

   1          // Part of traqmate.c
   2          // 9/6/2004
   3          // 5/15/2007 added autocross mode
   4          // Author: GAStephens
   5          //
   6          // These functions perform the lap timer function for the display unit
   7          //
   8          
   9          #include <display.h>
  10          #include <math.h>
  11          #define PI 3.14159265359
  12          #define CIRCUM          40455.0                                                                         // circumference of earth in km
  13          #define TODEGREE(A) ((A) * (180.0 / 2147483647.0))              // converts from storage format to degrees
  14          #define LATMET          (1000.0*CIRCUM/360.0)                                           // meters per degree
  15          #define LONMET(B)       (1000.0*CIRCUM*cos((B)/57.29577951)/360.0)      // meters per degree, B must be current latit
             -ude
  16          
  17          /******************************************************************************
  18          ** Write_Timer **************************************** GAS 6 SEP 04 ****
  19          *******************************************************************************
  20          This function writes the timer to the screen.
  21          ******************************************************************************/
  22          void Write_Timer(void) {
  23   1              xdata s32 temp;
  24   1              xdata s32 displaytime;
  25   1              xdata u08 digitoffset;
  26   1                                                        
  27   1              // hold the previous timer on screen for X seconds
  28   1              if (lap.currentlap > 1 && tm_state == TIMING && lap.timer < (1000L * (long) scratch.calibrate.lapholdtime
             -))
  29   1                      displaytime = laplist[lap.currentlap-2];        // -2 because it is 1 based
  30   1              else
  31   1                      displaytime = lap.timer;
  32   1      
  33   1              if (REV == timingmode) digitoffset = 0;         // put lap times in center of screen for reviewing
  34   1              else digitoffset = 5;                                           // put lap times above bar graph
  35   1      
  36   1              // don't write garbage on screen
  37   1              if (displaytime < 0) displaytime = 0;
  38   1      
  39   1              // write the hour
  40   1              temp = (displaytime / (60L * 60L * 1000L)) % 24;
  41   1              Write_Icon(21, 9-digitoffset, 8, 14, &(largeascii['0' - ' '+ (temp % 10)][0][0]), '-');
  42   1      
  43   1              // write the minutes
  44   1              temp = (displaytime / (60L * 1000L)) % 60;
  45   1              Write_Icon(38, 9-digitoffset, 8, 14, &(largeascii['0' - ' ' + (temp / 10)][0][0]), '-');
  46   1              Write_Icon(49, 9-digitoffset, 8, 14, &(largeascii['0' - ' ' + (temp % 10)][0][0]), '-');
  47   1      
  48   1              // write the seconds
  49   1              temp = (displaytime / 1000L) % 60;
  50   1              Write_Icon(66, 9-digitoffset, 8, 14, &(largeascii['0' - ' ' + (temp / 10)][0][0]), '-');
  51   1              Write_Icon(77, 9-digitoffset, 8, 14, &(largeascii['0' - ' ' + (temp % 10)][0][0]), '-');
  52   1      
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 2   

  53   1              // write the tenth
  54   1              temp = displaytime / (100L);
  55   1              Write_Icon(94, 9-digitoffset, 8, 14, &(largeascii['0' - ' ' + (temp % 10)][0][0]), '-');
  56   1      
  57   1      } // Write_Timer
  58          
  59          /******************************************************************************
  60          ** Write_Qual **************************************** GAS 11 AUG 07 ****
  61          *******************************************************************************
  62          This function writes the qualifying graph and digits to the screen.
  63          ******************************************************************************/
  64          void Write_Qual(float sectoradd) {
  65   1              xdata BOOL plus;                // TRUE if gap positive
  66   1              xdata u16 pixels;               // pixel scale for graph
  67   1              xdata u08 digit1, digit2;
  68   1              
  69   1              // clear the graph
  70   1              Write_Icon(0, 23, 122, 8, (u08 *) graphbckgnd, '-');
  71   1              
  72   1              // up or down?
  73   1              plus = (sectoradd >= 0.0);
  74   1              
  75   1              // remove the sign and round up to nearest tenth
  76   1              sectoradd = FLOATABS(sectoradd) + 0.05;
  77   1                      
  78   1              // scale to number of pixels, rounding up, checking bounds
  79   1              pixels = MIN(((u16) (.5 + (sectoradd / graphratio * 60.0))), 60);
  80   1      
  81   1              // limit the value
  82   1              if (sectoradd > 99.0) sectoradd = 99.0;
  83   1      
  84   1              if (sectoradd >= 10.0) {        // double digit
  85   2                      digit1 = (int) sectoradd / 10;
  86   2                      digit2 = (int) sectoradd % 10;
  87   2      
  88   2                      // write the sign, gap, and graph
  89   2                      if (plus) {
  90   3                              Write_Icon(95, 23, 8, 8, (u08 *) plussign, '-');
  91   3                              Write_Icon(105, 23, 6, 8, &(smallbolddigits[digit1][0][0]), '-');
  92   3                              Write_Icon(113, 23, 6, 8, &(smallbolddigits[digit2][0][0]), '-');
  93   3                              Write_Icon(62, 23, pixels, 8, (u08 *) reversebar, '^');
  94   3                      } // if
  95   2                      else {
  96   3                              Write_Icon(3, 23, 8, 8, (u08 *) minussign, '-');
  97   3                              Write_Icon(13, 23, 6, 8, &(smallbolddigits[digit1][0][0]), '-');
  98   3                              Write_Icon(21, 23, 6, 8, &(smallbolddigits[digit2][0][0]), '-');
  99   3                              Write_Icon(60-pixels, 23, pixels, 8, (u08 *) reversebar, '^');
 100   3                      } // else
 101   2              } // if
 102   1              else { // single digit and tenth
 103   2                      digit1 = (int) sectoradd % 10;
 104   2                      digit2 = ((int) (sectoradd * 10.0)) % 10;
 105   2      
 106   2                      // write the sign, gap, and graph
 107   2                      if (plus) {
 108   3                              Write_Icon(91, 23, 8, 8, (u08 *) plussign, '-');
 109   3                              Write_Icon(101, 23, 6, 8, &(smallbolddigits[digit1][0][0]), '-');
 110   3                              Write_Icon(109, 23, 2, 8, (u08 *) smallboldperiod, '-');
 111   3                              Write_Icon(113, 23, 6, 8, &(smallbolddigits[digit2][0][0]), '-');
 112   3                              Write_Icon(62, 23, pixels, 8, (u08 *) reversebar, '^');
 113   3                      } // if
 114   2                      else {
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 3   

 115   3                              Write_Icon(3, 23, 8, 8, (u08 *) minussign, '-');
 116   3                              Write_Icon(13, 23, 6, 8, &(smallbolddigits[digit1][0][0]), '-');
 117   3                              Write_Icon(21, 23, 2, 8, (u08 *) smallboldperiod, '-');
 118   3                              Write_Icon(25, 23, 6, 8, &(smallbolddigits[digit2][0][0]), '-');
 119   3                              Write_Icon(60-pixels, 23, pixels, 8, (u08 *) reversebar, '^');
 120   3                      } // else
 121   2              } // else
 122   1      
 123   1      } // Write_Qual
 124          
 125          /******************************************************************************
 126          ** Write_Lap ********************************************** GAS 29 JAN 05 ****
 127          *******************************************************************************
 128          This function writes the lap number to the screen.
 129          ******************************************************************************/
 130          void Write_Lap(void) {
 131   1              xdata u08 tempstring[5];
 132   1      
 133   1              // write lap number on lower left of screen
 134   1              if (lap.currentlap <= 99)
 135   1                      sprintf(tempstring, "%02u ", lap.currentlap);
 136   1              else
 137   1                      sprintf(tempstring, "%03u", lap.currentlap);
 138   1                      
 139   1              // upper left
 140   1              Write_Med_Text((u08) 1, (u08) 1, tempstring, '-');
 141   1      
 142   1      } // Write_Lap
 143          
 144          #if 0
              /******************************************************************************
              ** Write_Sigstrength *************************************** GAS 29 JAN 05 ****
              *******************************************************************************
              This function writes the signal strength meter on the upper left of the screen
              ******************************************************************************/
              void Write_Sigstrength(BOOL replayicon) {
              
                      if (replayicon)
                              // Write the replay icon
                              Write_Icon(0, 0, 12, 10, (u08 *) replay, '-');
                      else
                              // Write the appropriate GPS Lock Icon
                              Write_Icon(0, 0, 10, 10, &(sigstrength[(gpslock+2)/3][0][0]), '-');
              
              } // Write_Sigstrength
              #endif
 161          
 162          /******************************************************************************
 163          ** Write_Flag ********************************************** GAS 29 JAN 05 ****
 164          *******************************************************************************
 165          This function writes/clears the best lap (flag) indicator to the screen.
 166          ******************************************************************************/
 167          void Write_Flag(BOOL on) {
 168   1      
 169   1              if (on)
 170   1                      // write flag icon on upper right of screen
 171   1                      Write_Icon(LAST_COLUMN - 10, 1, 10, 10, (u08 *) flag, '-');
 172   1              else
 173   1                      // remove flag icon on upper right of screen
 174   1                      Write_Icon(LAST_COLUMN - 10, 1, 10, 10, (u08 *) blankicon, '-');
 175   1                              
 176   1      } // Write_Flag
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 4   

 177          
 178          #if 0   // removed when LAP mode changed for 2.10
              /******************************************************************************
              ** Write_Arrow ********************************************** GAS 29 JAN 05 ****
              *******************************************************************************
              This function writes up or down arrow indicator to the screen.
              ******************************************************************************/
              void Write_Arrow(BOOL up) {
              
                      if (up)
                              // write up arrow icon on upper right of screen
                              Write_Icon(LAST_COLUMN - 11, 2, 11, 10, (u08 *) arrowup, '-');
                      else
                              // write down arrow icon on upper right of screen
                              Write_Icon(LAST_COLUMN - 11, 2, 11, 10, (u08 *) arrowdown, '-');
              
              } // Write_Arrow
              #endif
 195          
 196          /******************************************************************************
 197          ** Lap_Check **************************************** GAS 8 SEP 04 ****
 198          *******************************************************************************
 199          This function performs all numerical lap timer functions.
 200          Could be enhanced to returns TRUE if we are at the Start/Finish Line
 201          ******************************************************************************/
 202          void Lap_Check(lapop oper, gpstype *gps) {
 203   1      //      xdata char tempstring[21];
 204   1              xdata float tempfloat;
 205   1              static BOOL inrange;
 206   1       
 207   1              switch (oper) {
 208   2                      case INC_TIME:
 209   2                              // increment by msec
 210   2                              lap.timer += 1000 / (samps_per_sec);
 211   2                              break;
 212   2      
 213   2                      case INITIALIZE:
 214   2                              inrange = FALSE;
 215   2                              seeklat = lap.startpos.lat;
 216   2                              seeklon = lap.startpos.lon;
 217   2                              seekhdg = lap.startheading;
 218   2                              lap.timer = lap.timernminus1 = 0;
 219   2                              refsectornum = cursectornum = 0;
 220   2                              
 221   2                      case NEW_POSITION: {
 222   3                              xdata float fdeltalat, fdeltalon;
 223   3                              xdata s16 eastvel, northvel, vertvel;
 224   3                              xdata float speed;
 225   3                              xdata flashpagetype tempflash;  // structure to access one page of flash
 226   3      
 227   3                              // in launch mode, now that we are moving, save the heading shortly after launch
 228   3                              // limit to small window just in case we are headed due East
 229   3                              if ((AUTOXGETFINISH == tm_state || AUTOXFINISH == tm_state || DRAGFINISH == tm_state)) {
 230   4                                      if ((0 == lap.startheading) && (lap.timer >= AUTOXSETHDGTIME) && (lap.timer <= (1000 + AUTOXSETHDGTIME
             -))) {
 231   5                                              // save starting heading for this track
 232   5                                              // get the track info
 233   5                                              DataFlash_Page_Read(MAX_PAGE_SIZE, tempflash.bigbuff, TRACKPAGE);
 234   5                      
 235   5                                              // initialize and save the information
 236   5                                              lap.startheading = tempflash.circuit.track[lap.tracknum].starthead = lap.currentheading;
 237   5              
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 5   

 238   5                                              // write it out
 239   5                                              DataFlash_Page_Write_Erase(GENBUFFER, MAX_PAGE_SIZE, tempflash.bigbuff, TRACKPAGE);
 240   5                                      } // if
 241   4                              } // if
 242   3      
 243   3                              lap.previouspos = lap.currentpos;
 244   3                              lap.previousheading = lap.currentheading;
 245   3                              lap.currentpos = *gps;
 246   3      
 247   3                              // don't look for starting line in AutoX or Drag
 248   3                              if (AUTOXSTAGE == tm_state || DRAGSTAGE == tm_state) return;
 249   3      
 250   3                              unpack_velocities (gps->velpack, &eastvel, &northvel, &vertvel);
 251   3      
 252   3                              // skip all this if we are not moving to eliminate divide by zero
 253   3                              if (eastvel != 0 || northvel != 0) {
 254   4                                      xdata int headrange;
 255   4                                      xdata int distrange;
 256   4      
 257   4                                      // use a smaller range circle for segment timing and autocross
 258   4                                      if (TIMING == tm_state || WAITSTART == tm_state) {
 259   5                                              headrange = LAP_HEADRANGE;
 260   5                                              distrange = LAP_DISTRANGE;
 261   5                                      } // if
 262   4                                      else {  // autox or dragrace                                                    
 263   5                                              headrange = AUTOX_HEADRANGE;
 264   5                                              distrange = AUTOX_DISTRANGE;
 265   5                                      } // else
 266   4      
 267   4                                      // compute heading = vector sum of east/west vel and north/south vel (due east is 0)
 268   4                                      lap.currentheading = compute_heading(eastvel, northvel);
 269   4      //                              if (WAITSTART != tm_state && INITIALIZE == oper) // we are done
 270   4      //                                      return;
 271   4      
 272   4                                      // calculate lap distance
 273   4                                      tempfloat = TODEGREE(lap.previouspos.lat);
 274   4      
 275   4                                      // find difference in meters of lat, lon
 276   4                                      fdeltalat = ((TODEGREE(lap.currentpos.lat) - tempfloat) * LATMET);
 277   4                                      fdeltalon = ((TODEGREE(lap.currentpos.lon) - TODEGREE(lap.previouspos.lon)) * LONMET(tempfloat));
 278   4      
 279   4                                      // remember the distance at the last sample point
 280   4                                      lastdist = (s16) lap.distance;
 281   4                                      
 282   4                                      // add on distance traveled in this sample
 283   4                                      lap.distance += sqrt(fdeltalat * fdeltalat + fdeltalon * fdeltalon);
 284   4      
 285   4                                      if (lap.currentlap > 0 && lastdist > 0) {       // only process after passing S/F and collecting one more sa
             -mple
 286   5                                              s16 lapdist = ((s16) lap.distance) % tracksampledist;           // integer lap distance - limit 40 miles long!
             -!
 287   5      
 288   5                                              // get just the remainder in this sector
 289   5                                              lastdist = lastdist % tracksampledist;
 290   5      
 291   5                                              // process sectors if we are in a lap
 292   5                                              if (TIMING == tm_state ||
 293   5                                                      HILLCLIMBFINISH == tm_state ||
 294   5                                                      HILLCLIMBGETFINISH == tm_state ||
 295   5                                                      AUTOXGETFINISH == tm_state ||
 296   5                                                      AUTOXFINISH == tm_state ||
 297   5                                                      DRAGFINISH == tm_state) {
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 6   

 298   6              
 299   6                                                      if (lapdist < lastdist) {       // crossed sector boundary
 300   7                                                              xdata float sectoradd;          // bit to add to last timing measurement to get to sector bounday
 301   7                                                              // interpolate and save the time
 302   7                                                              sectoradd = (float) (tracksampledist - lastdist) /
 303   7                                                                                      (float) (lapdist + tracksampledist - lastdist); // ratio between points
 304   7                                                              sectoradd = sectoradd * (float) (lap.timer - lap.timernminus1); // time in ms to add to previous
 305   7              
 306   7                                                              // if no best time then reference sectors all zero. otherwise check them
 307   7                                                              if (0xFFFFFFFF != lap.besttime) {
 308   8                                                                      // are we out of comparison sectors?
 309   8                                                                      if (0L == sector[refsectornum].reference && refsectornum > 0)
 310   8                                                                              // if so, back up a sector
 311   8                                                                              refsectornum--;
 312   8                                                              } // if
 313   7      
 314   7                                                              // store interpolated sector time as current for comparison
 315   7                                                              sector[cursectornum].current = lap.timernminus1 + (s32) sectoradd;
 316   7              
 317   7                                                              // only update graph until we run out of sectors
 318   7                                                              if (cursectornum < (NUMSECTORS-1)) {
 319   8                                                                      // if sector data loaded then compare progress and display graph                                                
 320   8                                                                      if (0xFFFFFFFF != lap.besttime) {
 321   9                                                                              // determine how much ahead / behind. + is ahead, - is behind
 322   9                                                                              sectoradd = (float) (sector[refsectornum].reference - sector[cursectornum].current) / 1000.0;
 323   9                      
 324   9                                                                              // write the graph
 325   9                                                                              Write_Qual(sectoradd);
 326   9                                                                      } // if
 327   8                                                                      cursectornum++;
 328   8                                                              } // if
 329   7                                                              if (refsectornum < (NUMSECTORS-1))
 330   7                                                                      refsectornum++;
 331   7                                                      } // if
 332   6                                              } // if
 333   5                                      } // if
 334   4                                      // save the current timer for future interpolation
 335   4                                      lap.timernminus1 = lap.timer;
 336   4                                      
 337   4                                      // if we are waiting for user action, don't bother going any further
 338   4                                      if (HILLCLIMBGETFINISH == tm_state || AUTOXGETFINISH == tm_state)
 339   4                                              return;
 340   4      
 341   4                                      if (DRAGFINISH == tm_state) {
 342   5                                              // look for distances and record them
 343   5      // ***** THIS SHOULD BE INTERPOLATED USING ACCELERATION RATES
 344   5      
 345   5                                              // calculate speed in meters/msec
 346   5                                              speed = sqrt((float) eastvel * (float) eastvel + (float) northvel * (float) northvel);
 347   5      
 348   5                                              // 60 foot time = 18.46 meters
 349   5                                              if (0 == dragnumbers.sixtyfoot && lap.distance > 18.46) {
 350   6                                                      dragnumbers.sixtyfoot = (u16) (lap.timer) / 10;
 351   6      #if 0
                                                              sprintf(tempstring, "60': %1.2f", (float) dragnumbers.sixtyfoot / 100.0);
                                                              Write_Text(3, 0, tempstring, '-');
              #endif
 355   6                                              } // if
 356   5      
 357   5                                              // 60 mph = 26.92 mps
 358   5                                              if (0 == dragnumbers.zerosixty && speed > 26.92) {
 359   6                                                      dragnumbers.zerosixty = (u16) (lap.timer) / 10;
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 7   

 360   6      #if 0
                                                              sprintf(tempstring, "0-60: %1.1f", (float) dragnumbers.zerosixty / 100.0);
                                                              Write_Text(0, 61, tempstring, '-');
              #endif
 364   6                                              } // if
 365   5                                                      
 366   5                                              // 100 mph = 44.70 mps
 367   5                                              if (0 == dragnumbers.zerohundred && speed > 44.70)
 368   5                                                      dragnumbers.zerohundred = (u16) (lap.timer / 10);
 369   5      
 370   5                                              // 330 foot time = 101.53 meters
 371   5                                              if (0 == dragnumbers.threethirty && lap.distance > 101.53) {
 372   6                                                      dragnumbers.threethirty = (u16) (lap.timer / 10);
 373   6      #if 0
                                                              sprintf(tempstring, "330':%1.2f", (float) dragnumbers.threethirty / 100.0);
                                                              Write_Text(3, 61, tempstring, '-');
              #endif
 377   6                                              } // if
 378   5      
 379   5                                              // 1/8 mile time = 203.06 meters
 380   5                                              if (0 == dragnumbers.eighthmile && lap.distance > 203.06) {
 381   6      
 382   6                                                      dragnumbers.eighthmile = (u16) (lap.timer / 10);
 383   6                                                      dragnumbers.eighthtrap = (u16) (speed * 22.356);                // record speed in mph * 10
 384   6                                                      
 385   6                                                      if (dragnumbers.quarter) {
 386   7      #if 0
                                                                      sprintf(tempstring, "1/8:%1.2f", (float) dragnumbers.eighthmile / 100.0);
                                                                      Write_Text(2, 0, tempstring, '-');                                              
              #endif
 390   7                                                      } // if
 391   6                                                      else {          // 1/8 mile run so stop here
 392   7                                                              tm_state = DRAGHOLDTIME;
 393   7                                                              button_overlay[SEL] = displaydragnums;
 394   7              
 395   7                                                              // save the lap
 396   7                                                              laplist[0] = (u32) lap.timer;
 397   7                                              
 398   7                                                              // get the track finish info
 399   7                                                              DataFlash_Page_Read(MAX_PAGE_SIZE, tempflash.bigbuff, TRACKFINPAGE);            
 400   7                                                      
 401   7                                                              // save the finish information
 402   7                                                              lap.finishpos.lat = tempflash.finishandgear.trackfinish[lap.tracknum].finishlat = lap.currentpos.la
             -t;
 403   7                                                              lap.finishpos.lon = tempflash.finishandgear.trackfinish[lap.tracknum].finishlon = lap.currentpos.lo
             -n;
 404   7                                                              lap.finishheading = tempflash.finishandgear.trackfinish[lap.tracknum].finishhead = lap.currentheadi
             -ng;
 405   7              
 406   7                                                              // write to flash
 407   7                                                              DataFlash_Page_Write_Erase(GENBUFFER, MAX_PAGE_SIZE, tempflash.bigbuff, TRACKFINPAGE);
 408   7                                                              
 409   7                                                              // put checker up
 410   7                                                              Write_Flag(TRUE);
 411   7                                                              
 412   7                                                              // give them a clue
 413   7                                                              Write_Text(3, 4, "Hit SELECT For Data", '-');
 414   7                                                      } // else
 415   6                                              } // if
 416   5      
 417   5                                              // 1/4 mile time = 406.12 meters
 418   5                                              if (0 == dragnumbers.quartermile && lap.distance > 406.12) {
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 8   

 419   6                                                      tm_state = DRAGHOLDTIME;
 420   6                                                      button_overlay[SEL] = displaydragnums;
 421   6      
 422   6                                                      dragnumbers.quartermile = (u16) (lap.timer / 10);
 423   6                                                      dragnumbers.quartertrap = (u16) (speed * 22.356);               // record speed in mph * 10
 424   6                                                      
 425   6                                                      // save the lap
 426   6                                                      laplist[0] = (u32) lap.timer;
 427   6                                      
 428   6                                                      // get the track finish info
 429   6                                                      DataFlash_Page_Read(MAX_PAGE_SIZE, tempflash.bigbuff, TRACKFINPAGE);            
 430   6                                              
 431   6                                                      // save the finish information
 432   6                                                      lap.finishpos.lat = tempflash.finishandgear.trackfinish[lap.tracknum].finishlat = lap.currentpos.lat
             -;
 433   6                                                      lap.finishpos.lon = tempflash.finishandgear.trackfinish[lap.tracknum].finishlon = lap.currentpos.lon
             -;
 434   6                                                      lap.finishheading = tempflash.finishandgear.trackfinish[lap.tracknum].finishhead = lap.currentheadin
             -g;
 435   6      
 436   6                                                      // write to flash
 437   6                                                      DataFlash_Page_Write_Erase(GENBUFFER, MAX_PAGE_SIZE, tempflash.bigbuff, TRACKFINPAGE);  
 438   6                                                      
 439   6                                                      // put checker up
 440   6                                                      Write_Flag(TRUE);
 441   6      
 442   6                                                      // give them a clue
 443   6                                                      Write_Text(3, 4, "Hit SELECT For Data", '-');
 444   6                                              } // if
 445   5                                      } // if
 446   4                                      // if current heading matches the start/finish heading then check for position
 447   4                                      // while allowing for headings near 0 (due east)
 448   4                                      else if (ABS((s16) lap.currentheading - (s16) seekhdg) < headrange ||
 449   4                                              ABS((s16) lap.currentheading - (s16) seekhdg) > (360 - headrange)) {
 450   5      
 451   5                                              tempfloat = TODEGREE(seeklat);
 452   5      
 453   5                                              // find difference in meters of lat, lon
 454   5                                              fdeltalat = ((TODEGREE(lap.currentpos.lat) - tempfloat) * LATMET);
 455   5                                              fdeltalon = ((TODEGREE(lap.currentpos.lon) - TODEGREE(seeklon)) * LONMET(tempfloat));
 456   5      
 457   5                                              if (ABS(fdeltalat) < distrange && ABS(fdeltalon) < distrange) {
 458   6                                                      // found either the Start or the Finish
 459   6                                                      if (!inrange) {
 460   7                                                              xdata float distance;
 461   7                                                              xdata float speed;
 462   7                                                              xdata s32 offset;
 463   7                                                              xdata BOOL dofirststart = FALSE;
 464   7                                                              xdata BOOL dostart = FALSE;
 465   7                                                              xdata BOOL dofinish = FALSE;
 466   7      
 467   7                                                              // now we are in range
 468   7                                                              inrange = TRUE;
 469   7      
 470   7                                                              // find the actual distance to start/finish in meters
 471   7                                                              distance = sqrt(fdeltalat * fdeltalat + fdeltalon * fdeltalon);
 472   7      
 473   7                                                              // calculate speed in meters/msec
 474   7                                                              speed = sqrt((float) eastvel * (float) eastvel + (float) northvel * (float) northvel);
 475   7      
 476   7                                                              // fix up the timer and lap distance based on our speed, rounding up the hundredth
 477   7                                                              offset = (s32) (50.0 + (1000.0 * distance) / speed);
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 9   

 478   7      
 479   7                                                              // process the incoming states                                                  
 480   7                                                              switch (tm_state) {
 481   8                                                                      case WAITSTART:
 482   8                                                                      case HILLCLIMBWAITSTART:
 483   8                                                                              dofirststart = TRUE;
 484   8                                                                              break;
 485   8                                                                      case HILLCLIMBSTART:
 486   8                                                                              dostart = TRUE;
 487   8                                                                              break;
 488   8                                                                      case TIMING:
 489   8                                                                              dostart = TRUE;
 490   8                                                                              dofinish = TRUE;
 491   8                                                                              break;
 492   8                                                                      case HILLCLIMBFINISH:
 493   8                                                                      case AUTOXFINISH:
 494   8                                                                      case DRAGFINISH:
 495   8                                                                              dofinish = TRUE;
 496   8                                                                              break;
 497   8                                                              } // switch
 498   7                                                      
 499   7                                                              // first time start line stuff
 500   7                                                              if (dofirststart) {
 501   8                                                                      u08 i;
 502   8      
 503   8                                                                      // found starting line so begin timing
 504   8                                                                      lap.currentlap = 0;
 505   8                                                                      lap.lastlap = 0;
 506   8                                                                      
 507   8      //                                                                      Write_Timer();
 508   8      
 509   8                                                                      // initialize lap storage
 510   8                                                                      for (i = 0; i < NUMLAPS; i++)
 511   8                                                                              laplist[i] = 0xFFFFFFFF;
 512   8                                                              } // if
 513   7                                                      
 514   7                                                              // general finish line stuff
 515   7                                                              if (dofinish) {
 516   8                                                                      // fudge to where time would be when we cross s/f, rounding up
 517   8                                                                      lap.timer += offset;
 518   8      
 519   8                                                                      // store the lap plus a fudge based on our speed
 520   8                                                                      if (lap.currentlap <= NUMLAPS)
 521   8                                                                              laplist[lap.currentlap-1] = (u32) lap.timer;
 522   8      
 523   8                                                                      // autox is single 'lap' so don't show symbols
 524   8                                                                      if (AUTOXFINISH != tm_state && DRAGFINISH != tm_state) {        // put up all the symbols and get ready f
             -or next lap
 525   9                                                                              // clear the graph
 526   9                                                                              Write_Icon(0, 23, 122, 8, (u08 *) graphbckgnd, '-');
 527   9              
 528   9                                                                              // check for best lap
 529   9                                                                              if (lap.timer <= (u32) lap.besttime) {
 530  10                                                                                      lap.besttime = lap.timer;
 531  10                      
 532  10                                                                                      // put checker up
 533  10                                                                                      Write_Flag(TRUE);
 534  10      
 535  10                                                                                      // make current lap the reference lap
 536  10                                                                                      for (cursectornum = 0; cursectornum < NUMSECTORS; cursectornum++)
 537  10                                                                                              sector[cursectornum].reference = sector[cursectornum].current;
 538  10                                                                              } // if
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 10  

 539   9                                                                              else
 540   9                                                                                      Write_Flag(FALSE);
 541   9                                                                      } // if
 542   8                                                              } // if
 543   7      
 544   7                                                              // general start line stuff
 545   7                                                              if (dostart || dofirststart) {
 546   8                                                                      // initialize to where start will be
 547   8                                                                      lap.timer = -offset;
 548   8                                                                      lap.distance = -distance;
 549   8                                                                      lastdist = 0;
 550   8                                                                      lap.timernminus1 = 0;
 551   8                                                                      // clear the current sector data
 552   8                                                                      for (cursectornum = 0; cursectornum < NUMSECTORS; cursectornum++)
 553   8                                                                              sector[cursectornum].current = 0;
 554   8                                                                      cursectornum = 0;
 555   8                                                                      refsectornum = 0;
 556   8      
 557   8                                                                      // next lap please
 558   8                                                                      lap.currentlap++;
 559   8                                                                              
 560   8                                                                      // write new lap number on screen
 561   8                                                                      Write_Lap();
 562   8                                                              } // if
 563   7                                                              
 564   7                                                              // do state transitions                         
 565   7                                                              switch (tm_state) {
 566   8                                                                      case WAITSTART:
 567   8                                                                              tm_state = TIMING;
 568   8                                                                              Write_Screen((u08 *) predictive, '-');
 569   8                                                                              if (0xFFFFFFFF == lap.besttime) {
 570   9                                                                                      // no sectors
 571   9                                                                                      Write_Icon(111, 23, 8, 8, (u08 *) plussign, '-');
 572   9                                                                                      Write_Icon(3, 23, 8, 8, (u08 *) minussign, '-');
 573   9                                                                              } // if
 574   8                                                                              break;
 575   8                                                                      case HILLCLIMBWAITSTART:
 576   8                                                                              // has finish line been set?
 577   8                                                                              if (0L == lap.finishpos.lat) {
 578   9                                                                                      tm_state = HILLCLIMBGETFINISH;
 579   9                                                                                      Clear_Screen();
 580   9                                                                                      Write_Icon(21, 4, 81, 14, (u08 *) timingicon, '-');
 581   9                                                                                      Write_Text(3, 1, "Hit SELECT at Finish", '-');
 582   9                                                                                      button_overlay[SEL] = markfinish;
 583   9                                                                              } // if
 584   8                                                                              else { // finish line set
 585   9                                                                                      // set up to find the finish
 586   9                                                                                      seeklat = lap.finishpos.lat;
 587   9                                                                                      seeklon = lap.finishpos.lon;
 588   9                                                                                      seekhdg = lap.finishheading;
 589   9                                                                                      tm_state = HILLCLIMBFINISH;
 590   9                                                                                      Write_Screen((u08 *) predictive, '-');
 591   9                                                                                      // if no sector times show +- while gathering sectors on next lap
 592   9                                                                                      if (0xFFFFFFFF == lap.besttime) {
 593  10                                                                                              // no sectors
 594  10                                                                                              Write_Icon(111, 23, 8, 8, (u08 *) plussign, '-');
 595  10                                                                                              Write_Icon(3, 23, 8, 8, (u08 *) minussign, '-');
 596  10                                                                                      } // if
 597   9                                                                                      button_overlay[SEL] = NULL;
 598   9                                                                              } // else
 599   8                                                                              // write lap number on screen
 600   8                                                                              Write_Lap();
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 11  

 601   8                                                                              break;
 602   8                                                                      case HILLCLIMBSTART:
 603   8                                                                              // set up to find the finish
 604   8                                                                              seeklat = lap.finishpos.lat;
 605   8                                                                              seeklon = lap.finishpos.lon;
 606   8                                                                              seekhdg = lap.finishheading;
 607   8                                                                              tm_state = HILLCLIMBFINISH;
 608   8                                                                              break;
 609   8                                                                      case HILLCLIMBFINISH:
 610   8                                                                              // set up to find the start
 611   8                                                                              seeklat = lap.startpos.lat;
 612   8                                                                              seeklon = lap.startpos.lon;
 613   8                                                                              seekhdg = lap.startheading;
 614   8                                                                              tm_state = HILLCLIMBSTART;
 615   8                                                                              
 616   8                                                                              // put up final adjusted number
 617   8                                                                              Write_Timer();
 618   8                                                                              break;
 619   8                                                                      case AUTOXFINISH:
 620   8                                                                              tm_state = AUTOXHOLDTIME;
 621   8      
 622   8                                                                              // put up final adjusted number
 623   8                                                                              Write_Timer();
 624   8                                                                              break;
 625   8                                                                      case TIMING:
 626   8                                                                              break;
 627   8                                                              } // switch     
 628   7                                                      } // if !inrange
 629   6                                              } // if
 630   5                                              else // no longer in range
 631   5                                                      inrange = FALSE;
 632   5                                      } // else if
 633   4                              } // if
 634   3                              break;
 635   3                      } // INITIALIZE, NEW_POSITION
 636   2                      case START_POSITION: {
 637   3                              xdata flashpagetype tempflash;  // structure to access one page of flash
 638   3                              u08 digitoffset;
 639   3      
 640   3                              // we are in range
 641   3                              inrange = TRUE;
 642   3      
 643   3                              lap.currentlap = 1;
 644   3                              lap.timer = lap.timernminus1 = 0;
 645   3                              lap.besttime = 0xFFFFFFFF;
 646   3                              lap.lastlap = 0;
 647   3                              lap.distance = 0.0;
 648   3                              lastdist = 0L;
 649   3      
 650   3                              // initialize lap storage
 651   3                              for (cursectornum = 0; cursectornum < NUMLAPS; cursectornum++)
 652   3                                      laplist[cursectornum] = 0xFFFFFFFF;
 653   3      
 654   3                              // initialize sectors
 655   3                              for (cursectornum = 0; cursectornum < NUMSECTORS; cursectornum++)
 656   3                                      sector[cursectornum].reference = 
 657   3                                      sector[cursectornum].current = 0;
 658   3                              cursectornum = 0;
 659   3                              refsectornum = 0;
 660   3      
 661   3                              // save starting position for this track
 662   3                              // get the track info
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 12  

 663   3                              DataFlash_Page_Read(MAX_PAGE_SIZE, tempflash.bigbuff, TRACKPAGE);
 664   3      
 665   3                              // initialize and save the information
 666   3                              lap.startpos.lat = tempflash.circuit.track[lap.tracknum].startlat = lap.currentpos.lat;
 667   3                              lap.startpos.lon = tempflash.circuit.track[lap.tracknum].startlon = lap.currentpos.lon;
 668   3                              lap.startheading = tempflash.circuit.track[lap.tracknum].starthead = lap.currentheading;
 669   3      //                      tempflash.circuit.track[lap.tracknum].startalt = lap.startpos.alt;
 670   3      
 671   3                              // write it out
 672   3                              DataFlash_Page_Write_Erase(GENBUFFER, MAX_PAGE_SIZE, tempflash.bigbuff, TRACKPAGE);
 673   3      
 674   3                              // jump out if we are not timing
 675   3                              if (DRIVING(tm_state)) break;
 676   3      
 677   3                              Clear_Screen();
 678   3                              if (REV == timingmode) digitoffset = 0;
 679   3                              else digitoffset = 5;
 680   3                              Write_Icon(21, 9-digitoffset, 81, 14, (u08 *) timingicon, '-');
 681   3      
 682   3                              // do we need a finish line?
 683   3                              if (AUTOXREADY == tm_state || HILLCLIMB == tm_state) {                  
 684   4                                      // has finish been set?
 685   4                                      if (0L == lap.finishpos.lat) {                                                                  
 686   5                                              // no finish line so get ready to get finish line                       
 687   5                                              Write_Text(3, 1, "Hit SELECT at Finish", '-');
 688   5                                              button_overlay[SEL] = markfinish;
 689   5                                              if (HILLCLIMB == tm_state)
 690   5                                                      tm_state = HILLCLIMBGETFINISH;
 691   5                                              else
 692   5                                                      tm_state = AUTOXGETFINISH;
 693   5                                      } // if
 694   4                                      else {  // got a finish line - can't happen in hillclimb mode
 695   5                                              tm_state = AUTOXFINISH;
 696   5                                              Write_Text(3, 4, "* Finish Line Set *", '-');
 697   5                                              button_overlay[SEL] = NULL;
 698   5                                              Write_Timer();
 699   5                                              
 700   5                                              // get ready for the big finish
 701   5                                              seeklat = lap.finishpos.lat;
 702   5                                              seeklon = lap.finishpos.lon;
 703   5                                              seekhdg = lap.finishheading;
 704   5                                      } // else
 705   4                              } // if
 706   3                              else if (DRAGREADY == tm_state) {
 707   4                                      tm_state = DRAGFINISH;
 708   4                              } // if
 709   3                              else {  // not AUTOXGETFINISH or HILLCLIMB
 710   4                                      Write_Screen((u08 *) predictive, '-');
 711   4                                      Write_Icon(111, 23, 8, 8, (u08 *) plussign, '-');
 712   4                                      Write_Icon(3, 23, 8, 8, (u08 *) minussign, '-');
 713   4                                      button_overlay[SEL] = NULL;
 714   4                                      tm_state = TIMING;
 715   4                                      
 716   4                                      // find this starting line again next lap
 717   4                                      seeklat = lap.startpos.lat;
 718   4                                      seeklon = lap.startpos.lon;
 719   4                                      seekhdg = lap.startheading;
 720   4                              } // else
 721   3                              
 722   3                              // write lap number on screen
 723   3                              if (AUTOXGETFINISH != tm_state && AUTOXFINISH != tm_state && DRAGFINISH != tm_state)
 724   3                                      Write_Lap();
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 13  

 725   3                              break;
 726   3                      } // case
 727   2                      case FINISH_POSITION: {
 728   3                              xdata flashpagetype tempflash;  // structure to access one page of flash
 729   3      
 730   3                              // finishandgear / autox run over. hold the time on the display
 731   3                              if (HILLCLIMBGETFINISH == tm_state) {
 732   4                                      seeklat = lap.startpos.lat;
 733   4                                      seeklon = lap.startpos.lon;
 734   4                                      seekhdg = lap.startheading;
 735   4                                      tm_state = HILLCLIMBSTART;
 736   4                                      Write_Screen((u08 *) predictive, '-');
 737   4      //                              Write_Icon(111, 23, 8, 8, (u08 *) plussign, '-');
 738   4      //                              Write_Icon(3, 23, 8, 8, (u08 *) minussign, '-');
 739   4                                      Write_Timer();
 740   4      
 741   4                                      // save as best lap
 742   4                                      lap.besttime = lap.timer;
 743   4              
 744   4                                      // put checker up
 745   4                                      Write_Flag(TRUE);
 746   4              
 747   4                                      // make current lap the reference lap
 748   4                                      for (cursectornum = 0; cursectornum < NUMSECTORS; cursectornum++)
 749   4                                              sector[cursectornum].reference = sector[cursectornum].current;
 750   4      
 751   4                              } // if
 752   3                              else {
 753   4                                      tm_state = AUTOXHOLDTIME;
 754   4                                      // note that we have set the line
 755   4                                      Clear_Line(3);
 756   4                                      Write_Text(3, 4, "* Finish Line Set *", '-');
 757   4                              } // else
 758   3                                      
 759   3                              // remove sel button overlay
 760   3                              button_overlay[SEL] = NULL;
 761   3      
 762   3                              // save the lap
 763   3                              laplist[0] = (u32) lap.timer;
 764   3              
 765   3                              // get the track finish info
 766   3                              DataFlash_Page_Read(MAX_PAGE_SIZE, tempflash.bigbuff, TRACKFINPAGE);            
 767   3                      
 768   3                              // save the finish information and set up to find the start
 769   3                              lap.finishpos.lat = tempflash.finishandgear.trackfinish[lap.tracknum].finishlat = lap.currentpos.lat;
 770   3                              lap.finishpos.lon = tempflash.finishandgear.trackfinish[lap.tracknum].finishlon = lap.currentpos.lon;
 771   3      //                      tempflash.finishandgear.trackfinish[lap.tracknum].finishalt = lap.currentpos.alt;
 772   3                              lap.finishheading = tempflash.finishandgear.trackfinish[lap.tracknum].finishhead = lap.currentheading;
 773   3      
 774   3                              // write to flash
 775   3                              DataFlash_Page_Write_Erase(GENBUFFER, MAX_PAGE_SIZE, tempflash.bigbuff, TRACKFINPAGE);
 776   3                      } // case
 777   2              } // switch
 778   1      } // Lap_Check
 779          
 780          /******************************************************************************
 781          ** Lap_Store **************************************** GAS 28 JAN 05 ****
 782          *******************************************************************************
 783          This function stores the laps collected into flash after a session.
 784          ******************************************************************************/
 785          void Lap_Store( void ) {
 786   1      
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 14  

 787   1              // update the index
 788   1              DataFlash_Page_Write_Erase(GENBUFFER, MAX_PAGE_SIZE, (u08 *) laplist, (LASTLAPPAGE - NUMLAPPAGES + sessio
             -n));
 789   1      
 790   1      } // Lap_Store
 791          
 792          /******************************************************************************
 793          ** Sector_Store **************************************** GAS 13 APR 07 ****
 794          *******************************************************************************
 795          This function stores the lap sectors collected into flash after a session.
 796          ******************************************************************************/
 797          void Sector_Store( void ) {
 798   1      
 799   1              // get the predictive lap timing sectors for this track
 800   1              DataFlash_Page_Read(MAX_PAGE_SIZE, flashpage.bigbuff, PREDPAGESTART + (lap.tracknum / 4));
 801   1                      
 802   1              // if lap better than that stored, replace it
 803   1              if ((u32) lap.besttime < (u32) flashpage.storedsectors[lap.tracknum % 4].bestlapever) {
 804   2                      int i;
 805   2                      
 806   2                      // copy lap time
 807   2                      flashpage.storedsectors[lap.tracknum % 4].bestlapever = lap.besttime;
 808   2      
 809   2                      // copy sector times
 810   2                      for (i = 0; i < NUMSECTORS; i++)
 811   2                              flashpage.storedsectors[lap.tracknum % 4].bestsectortimes[i] = sector[i].reference;
 812   2      
 813   2                      // write out new best lap info
 814   2                      DataFlash_Page_Write_Erase(GENBUFFER, MAX_PAGE_SIZE, flashpage.bigbuff, PREDPAGESTART + (lap.tracknum / 
             -4));
 815   2              } // if
 816   1      } // Sector_Store
 817          
 818          void unpack_velocities( u08 *velptr, s16 *eastvel, s16 *northvel, s16 *vertvel) {
 819   1              
 820   1              *eastvel = (s16) ((((u16) (velptr[0] & 0xE0)) << 3) + (u16) velptr[1]);
 821   1              // sign extend
 822   1              if (*eastvel & 0x0400) *eastvel |= 0xF800;
 823   1      
 824   1              *northvel = (s16) ((((u16) (velptr[0] & 0x1C)) << 6) + (u16) velptr[2]);
 825   1              // sign extend
 826   1              if (*northvel & 0x0400) *northvel |= 0xF800;
 827   1      
 828   1              *vertvel = (s16) ((((u16) (velptr[0] & 0x03)) << 8) + (u16) velptr[3]);
 829   1              // sign extend
 830   1              if (*vertvel & 0x0200) *vertvel |= 0xFC00;
 831   1      } // unpack_velocities
 832          
 833          u16 compute_heading (s16 eastvel, s16 northvel) {
 834   1              xdata float tempfloat;
 835   1              xdata s16 tempint;
 836   1      
 837   1              // compute heading = vector sum of east/west vel and inverse of north/south vel (due east is 0)
 838   1              tempfloat = atan2((float) northvel, (float) eastvel);
 839   1      
 840   1              tempfloat = (tempfloat * (180.0 / PI));
 841   1              tempint = (s16) tempfloat;
 842   1      
 843   1              // make sure it is 0-360
 844   1              tempint = (tempint + 360) % 360;
 845   1      
 846   1              return ((u16) tempint);
C51 COMPILER V9.51   TIMER                                                                 11/30/2014 18:01:39 PAGE 15  

 847   1      
 848   1      } // compute_heading
 849          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5640    ----
   CONSTANT SIZE    =     72    ----
   XDATA SIZE       =   ----    1654
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      25
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
