C51 COMPILER V9.51   DISPLAY                                                               11/30/2014 18:01:38 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE DISPLAY
OBJECT MODULE PLACED IN display.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE display.c OPTIMIZE(9,SIZE) BROWSE MDU_F120 INCDIR(..\..\C51\INC\;..\CommonF
                    -iles\) DB DEFINE(DISPLAY,EXTCLK6,NODEBUG,PACKMEM)

line level    source

   1          #include <display.h>
   2          #include <ctype.h>
   3          
   4          //------------------------------------------------------------------------------------
   5          // Display.c
   6          //------------------------------------------------------------------------------------
   7          // Copyright 2004 Track Systems, LLC
   8          //
   9          // AUTH: GAS
  10          // DATE: 18 JUL 04
  11          //
  12          // Updated for AZ Display LCD changes 2006-11-06
  13          //
  14          // This file contains the display control functions.
  15          //
  16          // port pin control definitions                 // writing HI = Push Pull, LO = Open Drain
  17          //
  18          #define PA0_DISP_PP     P4MDOUT
  19          #define BA0_DISP_PP     0
  20          #define PE1_DISP_PP     P4MDOUT
  21          #define BE1_DISP_PP     1
  22          #define PE2_DISP_PP     P4MDOUT
  23          #define BE2_DISP_PP     2
  24          #define PRW_DISP_PP     P4MDOUT
  25          #define BRW_DISP_PP     3
  26          
  27          #define HI(x) ((P##x) |= (1<<(B##x)))
  28          #define LO(x) ((P##x) &= ~(1<<(B##x)))
  29          //------------------------------------------------------------------------------------
  30          // PORT_Init_DU
  31          //------------------------------------------------------------------------------------
  32          //
  33          // Configure the Crossbar and GPIO ports
  34          //
  35          void PORT_Init_DU (void) {
  36   1      
  37   1              u08 SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
  38   1      
  39   1              SFRPAGE = CONFIG_PAGE;                  // set SFR page
  40   1      
  41   1              XBR0 = 0x6F;                                    // 01101111 Enable all but CEX5
  42   1              XBR1 = 0x00;                                    // everything disabled
  43   1              XBR2 = 0xC4;                                    // crossbar enabled, UART1 enabled, no weak pullups
  44   1      
  45   1              P0MDOUT = 0x15;                                 // 00010101 enable TX0, SI, SCK, as push-pulls
  46   1              P0 = 0xEA;                                              // set all open drain pins to 1
  47   1      
  48   1              P1MDIN  = 0xFF;                                 // set all digital inputs (disable analogs)
  49   1              P1MDOUT = 0x0D;                                 // 00001101 enable tx1 pwm0,1 as push-pull
  50   1              P1 = 0x02;                                              // set rx1 to high impedance
  51   1      
  52   1      //      P1MDOUT = 0x0C;                                 // 00001100 enable pwm0,1 as push-pull
  53   1                                                                              // tx1 will be set to push-pull when usb is present
  54   1      //      P1 = 0x03;                                              // set rx1, tx1 to high impedance
C51 COMPILER V9.51   DISPLAY                                                               11/30/2014 18:01:38 PAGE 2   

  55   1      
  56   1              P2MDOUT = 0x00;                                 // all pins open drain
  57   1              P2 = 0xFF;                                              // write a 1 to each bit
  58   1      
  59   1              P3MDOUT = 0x00;                                 // all pins open drain 
  60   1              P3 = 0xFF;                                              // write a 1 to each bit
  61   1      
  62   1              P7MDOUT = 0xFF;                                 // all push-pull
  63   1              P7 = 0x8E;                                              // 00000111 all backlights off, force disp on, dataflash wp on, 
  64   1                                                                              // dataflash cs off, dataflash reset off
  65   1              P6MDOUT = 0x00;
  66   1              P6 = 0xFF;                                              // all open drain
  67   1      
  68   1              P5MDOUT = 0x00;
  69   1              P5 = 0xFF;                                              // 11111111 all inputs
  70   1      
  71   1              // Port 4 is LCD  and USB control
  72   1              // P4.0 = A0
  73   1              // P4.1 = E1
  74   1              // P4.2 = E2
  75   1              // P4.3 = R/W
  76   1              // P4.4 = /RST
  77   1              // P4.5 = CTS_USB
  78   1              // P4.6 = RESET_USB
  79   1              // P4.7 = EN_DISP
  80   1      
  81   1              P4MDOUT = 0xE0;                                 // 11100000 P4.0 - P4.4 are open drain, others pushpull
  82   1              P4 = 0xF9;                                              // 11111001
  83   1      
  84   1              // configure the PCA for PWM operation
  85   1              SFRPAGE = PCA0_PAGE;
  86   1              PCA0MD =        0x80;                                   // 1000000 suspend with microp, SYSCLK / 12
  87   1              PCA0CN =        0x40;                                   // 01000000 PCA0 enabled
  88   1              PCA0CPM0 =      0x42;                                   // CCM0 in 8-bit PWM mode
  89   1              PCA0CPM1 =      0x42;                                   // CCM1 in 8-bit PWM mode
  90   1      
  91   1              // get contrast value
  92   1              ReadScratchpad(scratch.scratchbuff);
  93   1      
  94   1              // if contrast setting bad or never programmed, fix it
  95   1              if (scratch.calibrate.contrast > CONTRAST_UPPER ||
  96   1                      scratch.calibrate.contrast < CONTRAST_LOWER)
  97   1                              scratch.calibrate.contrast = CONTRAST_CENTER;
  98   1      
  99   1              // initialize PWM values for middle of the road
 100   1              PCA0CPL0 = scratch.calibrate.contrast;
 101   1              PCA0CPH0 = scratch.calibrate.contrast;
 102   1      
 103   1              // set up the ADC for reading battery voltage and temperature
 104   1              SFRPAGE = ADC0_PAGE;
 105   1              ADC0CN = 0xC0;                                          // 11000001 ADC0 enabled; special tracking
 106   1                                                                                      // ADC0 conversions are initiated 
 107   1                                                                                      // on AD0BUSY=1; ADC0 data is right-justified
 108   1      
 109   1              REF0CN = 0x07;                      // enable temp sensor, on-chip VREF,
 110   1                                                                                      // and VREF output buffer
 111   1              AMX0CF = 0x00;                                          // all non-differential inputs, no gain
 112   1              AMX0SL = 0x00;                      // Select AIN0 external input on mux
 113   1              ADC0CF = ((SYSCLK/2/ADC_RATE) << 3) | 0x00;     // ** ADC conv clock = 2.5MHz, Gain = 1
 114   1      
 115   1              SFRPAGE = SFRPAGE_SAVE;                 // Restore SFR page
 116   1      }
C51 COMPILER V9.51   DISPLAY                                                               11/30/2014 18:01:38 PAGE 3   

 117          
 118          /******************************************************************************
 119          ** Display_Init ********************************************** GAS 01JUN04 ****
 120          *******************************************************************************
 121          This performs all of the necessary initialization of the SED-1565 controller
 122          inside the display.
 123          ******************************************************************************/
 124          void Display_Init(void) {
 125   1      
 126   1              u08 SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 127   1      
 128   1              SFRPAGE = CONFIG_PAGE;                  // set SFR page
 129   1      
 130   1              RST_DISP = 0; // Hold the display in reset
 131   1              DELAY_MS(1);
 132   1              RST_DISP = 1; // Release the display in reset
 133   1              DELAY_MS(1);
 134   1      
 135   1              // NOTE: Initial state of E1, E2, R/W and A0 are set in port setup
 136   1      
 137   1              /*
 138   1              When the RES input comes to the "L" level, the display is initialized to a
 139   1              default state. That default is as follows:
 140   1      
 141   1              1) Display OFF
 142   1              2) Display start line set to first line
 143   1              3) Static drive is OFF
 144   1              4) Column address set to Address 0
 145   1              5) Page address set to Page 3
 146   1              6) 1/32 Duty cycle is selected
 147   1              7) Forward ADC is selected(ADC command D0 -is 1, ADC status flag is 1)
 148   1              8) Read-modify-write is OFF
 149   1              */
 150   1      
 151   1              Write_Display(CMD,RESET_DISPLAY, 0);
 152   1              Write_Display(CMD,RESET_DISPLAY, 1);
 153   1              Write_Display(CMD,DUTY_CYCLE_SET + 1, 0);
 154   1              Write_Display(CMD,DUTY_CYCLE_SET + 1, 1);
 155   1              Write_Display(CMD,ADC_SELECT_NORMAL, 0);
 156   1              Write_Display(CMD,ADC_SELECT_NORMAL, 1);
 157   1              Write_Display(CMD,START_LINE_SET, 0);
 158   1              Write_Display(CMD,START_LINE_SET, 1);
 159   1              Write_Display(CMD,DISPLAY_ON, 0);
 160   1              Write_Display(CMD,DISPLAY_ON, 1);
 161   1      
 162   1              SFRPAGE = SFRPAGE_SAVE;
 163   1      }
 164          
 165          /******************************************************************************
 166          ** Write_Display ********************************************* MKO 13JUN01 ****
 167          *******************************************************************************
 168          This is the one of the main low level routines used to write either commands
 169          or data to the SED1565 LCD driver. A flag must be passed to the routine to
 170          indicate whether it is being used to pass a command or data to the controller.
 171                  Usage Examples:
 172                          Write_Display(CMD,RESET_DISPLAY);
 173                          Write_Display(DATA,i);
 174          ******************************************************************************/
 175          
 176          void Write_Display(u08 command, u08 dat, u08 side) {
 177   1              u08 status;
 178   1              int timeout = 0;
C51 COMPILER V9.51   DISPLAY                                                               11/30/2014 18:01:38 PAGE 4   

 179   1      
 180   1              u08 SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 181   1      //      u08 EA_SAVE = EA;
 182   1      
 183   1      //      EA = 0;
 184   1              SFRPAGE = CONFIG_PAGE;                  // set SFR page
 185   1      
 186   1              // check for busy. timeout eventually and move on
 187   1              do {
 188   2                      status = Read_Display(CMD, side);
 189   2                      timeout++;
 190   2              } while ((status & DISP_BUSY) && (timeout < DISPLAY_TRIES));
 191   1      
 192   1              RW_DISP = 0;
 193   1      
 194   1              // Select command or data
 195   1              if(command == CMD){             // command
 196   2                      A0_DISP = 0;
 197   2              }
 198   1              else {                                  // data
 199   2                      A0_DISP = 1;
 200   2              }
 201   1      
 202   1              // select a side of the display
 203   1              if (side) { E2_DISP = 1; }
 204   1              else { E1_DISP = 1; } 
 205   1      
 206   1              // Place the data on the bus
 207   1              DATA_8 = dat;
 208   1      
 209   1              // change to pushpull
 210   1              if (side) { HI(E2_DISP_PP); }
 211   1              else { HI(E1_DISP_PP); }
 212   1              
 213   1              // change to open drain
 214   1              if (side) { LO(E2_DISP_PP); }
 215   1              else { LO(E1_DISP_PP); }
 216   1      
 217   1              // waits at least 300 nsec
 218   1              for (status = 1; status != 0; status--) timeout++;
 219   1      
 220   1              // latch the data into the display and set up lines for next write
 221   1              if (side) { E2_DISP = 0; }
 222   1              else { E1_DISP = 0; }
 223   1              A0_DISP = 1;
 224   1              RW_DISP = 1;
 225   1      
 226   1              // set control lines to pushpull
 227   1              HI(A0_DISP_PP);
 228   1              HI(RW_DISP_PP);
 229   1      
 230   1              // set back to open drain
 231   1              LO(A0_DISP_PP);
 232   1              LO(RW_DISP_PP);
 233   1      
 234   1              // set data lines high
 235   1              DATA_8 = 0xFF;
 236   1      
 237   1              SFRPAGE = SFRPAGE_SAVE;
 238   1      //      EA = EA_SAVE;
 239   1      
 240   1      } // Write_Display
C51 COMPILER V9.51   DISPLAY                                                               11/30/2014 18:01:38 PAGE 5   

 241          
 242          /******************************************************************************
 243          ** Read_Display ******************************************** GAS 15 JUL 04 ****
 244          *******************************************************************************
 245          This is the one of the main low level routines used to read data and the status
 246          byte from the SED1565 LCD controller. A flag must be passed to the routine to
 247          indicate whether it is being used to pass a command or data to the controller.
 248                  Usage Examples:
 249                          status_read_byte = Read_Display(CMD, side);
 250                          display_data = Read_Display(DATA, side);
 251          ******************************************************************************/
 252          
 253          u08 Read_Display(u08 command, u08 side) {
 254   1              u08 return_byte;
 255   1      
 256   1              u08 SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 257   1      //      u08 EA_SAVE = EA;
 258   1      
 259   1      //      EA = 0;
 260   1              SFRPAGE = CONFIG_PAGE;                  // set SFR page
 261   1      
 262   1              // Load the control signals and data for a particular command
 263   1              if(command == CMD){             // status read & delay 2 cycles
 264   2                      A0_DISP = 0;
 265   2              }
 266   1              else {                                  // data read & delay 2 cycles
 267   2                      A0_DISP = 1;
 268   2              }
 269   1      
 270   1              // write Ex=1, set Ex as push-pull, wait 2 cycles, set Ex as open drain
 271   1              if (side)       { E2_DISP = 1; 
 272   2                                      HI(E2_DISP_PP);
 273   2                                      LO(E2_DISP_PP);
 274   2                                      }
 275   1              else            { E1_DISP = 1;
 276   2                                      HI(E1_DISP_PP);
 277   2                                      LO(E1_DISP_PP);
 278   2                                      }
 279   1      
 280   1              // waits at least 300 nsec
 281   1              for (return_byte = 3; return_byte != 0; return_byte--) command++;
 282   1      
 283   1              // grab the data from the bus
 284   1              return_byte = DATA_8;
 285   1      
 286   1              // Leave display in correct state
 287   1              if (side) { E2_DISP = 0; }
 288   1              else { E1_DISP = 0; }
 289   1               
 290   1              A0_DISP = 1;
 291   1      
 292   1              // change A0 to push-pull
 293   1              HI(A0_DISP_PP);
 294   1      
 295   1              // A0 back to open drain
 296   1              LO(A0_DISP_PP);
 297   1      
 298   1              SFRPAGE = SFRPAGE_SAVE;
 299   1      //      EA = EA_SAVE;
 300   1      
 301   1              return(return_byte);
 302   1      } // Read_Display
C51 COMPILER V9.51   DISPLAY                                                               11/30/2014 18:01:38 PAGE 6   

 303          
 304          /******************************************************************************
 305          ** Write_Screen **************************************** GAS 22 JUN 04 ****
 306          *******************************************************************************
 307          This writes an entire bit pattern to the LCD display
 308          If operation = ~, writes reverse image
 309          ******************************************************************************/
 310          void Write_Screen(u08 bitmap[NUMBER_OF_PAGES][NUMBER_OF_COLUMNS], char operation) {
*** WARNING C235 IN LINE 310 OF display.c: parameter 1: different types
 311   1              u08 page;
 312   1              u16 column;
 313   1              u08 side;
 314   1      
 315   1              /* Initialize the column address to zero and allow the auto increment to
 316   1              move the column address after each write. */
 317   1      
 318   1              for(page=0; page<NUMBER_OF_PAGES; page++) {
 319   2                      column = 0;                     // keep track of column number to switch sides
 320   2                      side = 0;
 321   2      
 322   2                      Write_Display(CMD, PAGE_ADDRESS_SET + page, 0);
 323   2                      Write_Display(CMD, COLUMN_SET, 0);
 324   2      
 325   2                      Write_Display(CMD, PAGE_ADDRESS_SET + page, 1);
 326   2                      Write_Display(CMD, COLUMN_SET, 1);
 327   2      
 328   2                      for (column=0;column<NUMBER_OF_COLUMNS;column++) {
 329   3                                      // switch sides as appropriate
 330   3                                      if (column == NUMBER_OF_COLUMNS/2) // select right side of display
 331   3                                              side = 1;
 332   3      
 333   3                                      Write_Display(DATA, (operation == '~')? ~bitmap[page][column] : bitmap[page][column], side);
 334   3                      } // for
 335   2              } // for
 336   1      
 337   1              /* Turn on the display to see the new pattern */
 338   1              Write_Display(CMD, DISPLAY_ON, 0);
 339   1              Write_Display(CMD, DISPLAY_ON, 1);
 340   1      }
 341          
 342          /******************************************************************************
 343          ** Write_Icon **************************************** GAS 1 JUL 04 ****
 344          *******************************************************************************
 345          This writes an bit pattern to the LCD display at the prescribed location
 346          locx, locy are the bit address to place icon (upper left 0,0, lower right 121,31)
 347          sizex, sizey are the dimensions of the bitmap
 348          bytex, bytey are the number of bytes in the bitmap
 349          operation is either AND &, OR |, XOR ^, REVERSE ~, or REPLACE -
 350          
 351          known issues: if font definition is outside its bounds, Write_Icon will also write
 352          outside the bounds.
 353          
 354          ******************************************************************************/
 355          void Write_Icon(int locx, int locy, int sizex, int sizey, u08 *bitmap, char operation) {
 356   1              u08 page;
 357   1              u16 column;
 358   1              u08 side;
 359   1              int startcolumn, endcolumn;
 360   1              u08 startpage, endpage, startside, iconrow;
 361   1              xdata u08 bitoffset;
 362   1              u08 tempdata, uppermask, lowermask, rcvdata;
 363   1      
C51 COMPILER V9.51   DISPLAY                                                               11/30/2014 18:01:38 PAGE 7   

 364   1              code u08 mask1[] = { 0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01 };
 365   1              code u08 mask3[] = { 0x00, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80 };
 366   1              code u08 mask2[] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80 };
 367   1      
 368   1              /* Turn off the display during writes */
 369   1      //      Write_Display(CMD, DISPLAY_OFF, 0);
 370   1      //      Write_Display(CMD, DISPLAY_OFF, 1);
 371   1      
 372   1              startpage = locy / 8;                   // figure out initial page
 373   1              endpage = MIN(((locy + sizey - 1)/8), NUMBER_OF_PAGES-1);
 374   1      
 375   1              bitoffset = locy % 8;                   // where icon overlaps page edge
 376   1              startcolumn = locx;
 377   1              startside = (startcolumn < NUMBER_OF_COLUMNS/2)?  0 : 1;        // pick initial side of display
 378   1              endcolumn = MIN((locx + sizex - 1), NUMBER_OF_COLUMNS-1);
 379   1      
 380   1              if (1 == startside) {
 381   2                      startcolumn -= NUMBER_OF_COLUMNS/2;
 382   2                      endcolumn -= NUMBER_OF_COLUMNS/2;
 383   2              }
 384   1      
 385   1              for (page=startpage; page <= endpage; page++) {
 386   2      
 387   2                      side = startside;       // pick initial side of display
 388   2                      iconrow = (startpage - page + bitoffset) / 8;
 389   2      
 390   2                      // set the starting write location
 391   2                      if (0 == startside) {
 392   3                              Write_Display(CMD, PAGE_ADDRESS_SET + page, 0);
 393   3                              Write_Display(CMD, COLUMN_SET + startcolumn, 0);
 394   3      
 395   3                              Write_Display(CMD, PAGE_ADDRESS_SET + page, 1);
 396   3                              Write_Display(CMD, COLUMN_SET + 0, 1);
 397   3                      }
 398   2                      else {
 399   3                              Write_Display(CMD, PAGE_ADDRESS_SET + page, 1);
 400   3                              Write_Display(CMD, COLUMN_SET + startcolumn, 1);
 401   3                      } // else
 402   2      
 403   2                      for (column=startcolumn; column <= endcolumn; column++) {
 404   3                              xdata u08 savemask;
 405   3      
 406   3                              // switch sides as appropriate
 407   3                              if (column == NUMBER_OF_COLUMNS/2)      // select right side of display
 408   3                                      side = 1;
 409   3      
 410   3                              if (page == startpage)
 411   3                                      uppermask = 0;
 412   3                              else {
 413   4                                      // get upper overlap
 414   4                                      tempdata = *(bitmap+(page-startpage-1)*sizex+(column-startcolumn));
 415   4                                      uppermask =     (tempdata & ~mask1[bitoffset]) >> (8-bitoffset);
 416   4                              }
 417   3                              
 418   3                              if ((page == endpage) && ((bitoffset % 8) > (8-(sizey % 8)))) 
 419   3                                      lowermask = 0;
 420   3                              else {
 421   4                                      // get lower overlap
 422   4                                      tempdata = *(bitmap+(page-startpage)*sizex+(column-startcolumn));
 423   4                                      lowermask = (tempdata & mask1[bitoffset]) << bitoffset;
 424   4                              } // else
 425   3      
C51 COMPILER V9.51   DISPLAY                                                               11/30/2014 18:01:38 PAGE 8   

 426   3                              tempdata = uppermask | lowermask;
 427   3      
 428   3                              // go into rmw mode to hold the column position
 429   3                              Write_Display(CMD, READ_MODIFY_WRITE, side);
 430   3      
 431   3                              rcvdata = Read_Display(DATA, side); // Dummy Read
 432   3                              rcvdata = Read_Display(DATA, side); // Get current LCD column
 433   3      
 434   3                              switch (operation) {
 435   4                                      case '&':       // AND
 436   4                                              tempdata &= rcvdata;
 437   4                                              break;
 438   4                                      case '|':       // OR
 439   4                                              tempdata |= rcvdata;
 440   4                                              break;
 441   4                                      case '^':       // XOR
 442   4                                              tempdata ^= rcvdata;
 443   4                                              break;
 444   4                                      case '~':       // REVERSE IMAGE
 445   4                                              tempdata = ~tempdata;
 446   4                                              break;
 447   4                                      default:        // REPLACE
 448   4                                              break;
 449   4                              } // switch
 450   3      
 451   3                              // if top or bottom of icon, put back in surrounding parts of screen
 452   3                              savemask = 0;
 453   3                              if (startpage == page)
 454   3                                      savemask = ~mask2[bitoffset];
 455   3                              if (endpage == page)
 456   3      //                              savemask |= ~mask1[(locy + sizey) % 8];
 457   3                                      savemask |= mask3[(locy + sizey) % 8];
 458   3                              tempdata = (tempdata & ~savemask) | (rcvdata & savemask);
 459   3      
 460   3                              // restore normal mode
 461   3                              Write_Display(CMD, END, side);
 462   3                              
 463   3                              // put the data on the display
 464   3                              Write_Display(DATA, tempdata, side);
 465   3      
 466   3                      } // for
 467   2              } // for
 468   1      
 469   1              /* Turn on the display to see the new pattern */
 470   1      //      Write_Display(CMD, DISPLAY_ON, 0);
 471   1      //      Write_Display(CMD, DISPLAY_ON, 1);
 472   1      }
 473          
 474          /******************************************************************************
 475          ** Full_Screen **************************************** GAS 22 JUN 04 ****
 476          *******************************************************************************
 477          This writes the same byte to every location on the LCD display
 478          ******************************************************************************/
 479          void Full_Screen(u08 dat) {
 480   1              u08 page;
 481   1              u16 column;
 482   1              u08 side;
 483   1      
 484   1              // Turn off the display while writing
 485   1              Write_Display(CMD, DISPLAY_OFF, 0);
 486   1              Write_Display(CMD, DISPLAY_OFF, 1);
 487   1      
C51 COMPILER V9.51   DISPLAY                                                               11/30/2014 18:01:38 PAGE 9   

 488   1              /* Initialize the column address to zero and allow the auto increment to
 489   1              move the column address after each write. */
 490   1      
 491   1              for(page=0; page<NUMBER_OF_PAGES; page++) {
 492   2                      column = 0;                     // keep track of column number to switch sides
 493   2                      side = 0;
 494   2      
 495   2                      Write_Display(CMD, PAGE_ADDRESS_SET + page, 0);
 496   2                      Write_Display(CMD, COLUMN_SET, 0);
 497   2      
 498   2                      Write_Display(CMD, PAGE_ADDRESS_SET + page, 1);
 499   2                      Write_Display(CMD, COLUMN_SET, 1);
 500   2      
 501   2                      for (column=0;column<NUMBER_OF_COLUMNS;column++) {
 502   3                                      // switch sides as appropriate
 503   3                                      if (column == NUMBER_OF_COLUMNS/2) // select right side of display
 504   3                                              side = 1;
 505   3                                      Write_Display(DATA, dat, side);
 506   3                      } // for
 507   2              } // for
 508   1      
 509   1              // Turn on the display to see the new pattern
 510   1              Write_Display(CMD, DISPLAY_ON, 0);
 511   1              Write_Display(CMD, DISPLAY_ON, 1);
 512   1      }
 513          
 514          /******************************************************************************
 515          ** Write_Line **************************************** GAS 19 JUL 04 ****
 516          *******************************************************************************
 517          This writes a 20 char line using the smallest font to the screen. It will blank
 518          pad or truncate the line but does not wrap. Line ranges from 0-3.
 519          operation is either AND &, OR |, XOR ^, REVERSE ~, or REPLACE -
 520          ******************************************************************************/
 521          void Write_Line(u08 linenum, char *linetext, BOOL scroll, char operation) {
 522   1              int i;
 523   1      
 524   1              if (scroll) {
 525   2                      linenum = topline;
 526   2                      topline = ++topline % NUMBER_OF_PAGES;
 527   2                      Write_Display(CMD, START_LINE_SET + (topline*8), 0);
 528   2                      Write_Display(CMD, START_LINE_SET + (topline*8), 1);
 529   2              } // if 
 530   1              
 531   1              for (i=0; i<(NUMBER_OF_COLUMNS-5); i += 6) {
 532   2                      
 533   2                      if ((*linetext >= ' ') && (*linetext <= '~'))
 534   2                              Write_Icon(i, 8*linenum, 5, 8, &(smallascii[*linetext -' '][0][0]), operation);
 535   2                      else // print a blank
 536   2                              Write_Icon(i, 8*linenum, 5, 8, &smallascii[0][0][0], operation);
 537   2      
 538   2                      if ('\0' != *linetext) linetext++;
 539   2      
 540   2              } // for
 541   1      } // Write_Line
 542          
 543          /******************************************************************************
 544          ** Write_Text **************************************** GAS 19 JUL 04 ****
 545          *******************************************************************************
 546          This writes a text string using the smallest font to the screen.
 547          Line ranges from 0-3.
 548          Column ranges from 0-121.
 549          operation is either AND &, OR |, XOR ^, REVERSE ~, or REPLACE -
C51 COMPILER V9.51   DISPLAY                                                               11/30/2014 18:01:38 PAGE 10  

 550          ******************************************************************************/
 551          void Write_Text(u08 linenum, u08 colnum, char *linetext, char operation) {
 552   1              xdata int i;
 553   1      
 554   1              for (i=colnum; i<(NUMBER_OF_COLUMNS-5); i += 6) {
 555   2      
 556   2                      if ('\0' == *linetext) break;
 557   2                      
 558   2                      if ((*linetext >= ' ') && (*linetext <= '~'))
 559   2                              Write_Icon(i, 8*linenum, 5, 8, &(smallascii[*linetext -' '][0][0]), operation);
 560   2                      else // print a blank
 561   2                              Write_Icon(i, 8*linenum, 5, 8, &smallascii[0][0][0], operation);
 562   2      
 563   2                      linetext++;
 564   2      
 565   2              } // for
 566   1      } // Write_Text
 567          
 568          /******************************************************************************
 569          ** Write_Big_Line **************************************** GAS 17 JAN 05 ****
 570          *******************************************************************************
 571          This writes a 12 char line using the large font to the screen. It will blank
 572          pad or truncate the line but does not wrap. Line ranges from 0-3. For 2 lines,
 573          use lines 0 and 2.
 574          operation is either AND &, OR |, XOR ^, REVERSE ~, or REPLACE -
 575          ******************************************************************************/
 576          void Write_Big_Line(u08 linenum, char *linetext, BOOL scroll, char operation) {
 577   1              int i;
 578   1      
 579   1              if (scroll) {
 580   2                      // get topline to even number
 581   2                      topline &= 0x02;
 582   2                      linenum = topline;
 583   2                      topline = (2+topline) % NUMBER_OF_PAGES;
 584   2                      Write_Display(CMD, START_LINE_SET + (topline*8), 0);
 585   2                      Write_Display(CMD, START_LINE_SET + (topline*8), 1);
 586   2              } // if 
 587   1              
 588   1              for (i=0; i<(NUMBER_OF_COLUMNS-9); i += 10) {
 589   2                      
 590   2                      if ((*linetext >= ' ') && (*linetext <= '~'))
 591   2                              Write_Icon(i, 8*linenum, 8, 16, &(largeascii[*linetext -' '][0][0]), operation);
 592   2                      else // print a blank
 593   2                              Write_Icon(i, 8*linenum, 8, 16, &largeascii[0][0][0], operation);
 594   2      
 595   2                      if ('\0' != *linetext) linetext++;
 596   2      
 597   2              } // for
 598   1      } // Write_Big_Line
 599          
 600          /******************************************************************************
 601          ** Write_Big_Text **************************************** GAS 17 JAN 05 ****
 602          *******************************************************************************
 603          This writes a text string using the large font to the screen.
 604          Line ranges from 0-3. For 2 lines, use lines 0, 2.
 605          Column ranges from 0-121.
 606          operation is either AND &, OR |, XOR ^, REVERSE ~, or REPLACE -
 607          ******************************************************************************/
 608          void Write_Big_Text(u08 linenum, u08 colnum, char *linetext, char operation) {
 609   1              int i;
 610   1      
 611   1              for (i=colnum; i<(NUMBER_OF_COLUMNS-9); i += 10) {
C51 COMPILER V9.51   DISPLAY                                                               11/30/2014 18:01:38 PAGE 11  

 612   2      
 613   2                      if ('\0' == *linetext) break;
 614   2                      
 615   2                      if ((*linetext >= ' ') && (*linetext <= '~'))
 616   2                              Write_Icon(i, 8*linenum, 8, 16, &(largeascii[*linetext -' '][0][0]), operation);
 617   2                      else // print a blank
 618   2                              Write_Icon(i, 8*linenum, 8, 16, &largeascii[0][0][0], operation);
 619   2      
 620   2                      linetext++;
 621   2      
 622   2              } // for
 623   1      } // Write_Big_Text
 624          
 625          /******************************************************************************
 626          ** Write_Med_Text **************************************** GAS 29 JAN 05 ****
 627          *******************************************************************************
 628          This writes a text string containing only digits using the medium font to the
 629          screen. Row ranges from 0-31. Column ranges from 0-121.
 630          operation is either AND &, OR |, XOR ^, REVERSE ~, or REPLACE -
 631          ******************************************************************************/
 632          void Write_Med_Text(u08 rownum, u08 colnum, char *linetext, char operation) {
 633   1              int i;
 634   1      
 635   1              for (i=colnum; i<(NUMBER_OF_COLUMNS-6); i += 7) {
 636   2      
 637   2                      if ('\0' == *linetext) break;
 638   2                      
 639   2                      if ((*linetext >= '0') && (*linetext <= '9'))
 640   2                              Write_Icon(i, rownum, 6, 10, &(meddigits[*linetext -'0'][0][0]), operation);
 641   2                      else // write a space
 642   2                              Write_Icon(i, rownum, 6, 10, &(medspace[0][0]), operation);
 643   2      
 644   2                      linetext++;
 645   2              } // for
 646   1      } // Write_Med_Text
 647          #if 0
              /******************************************************************************
              ** Draw_Rect *********************************************** GAS 07 MAR 05 ****
              *******************************************************************************
              This draws a rectangle from upper left to lower right. Row ranges from 0-31.
              Column ranges from 0-121.
              
              operation is either AND &, OR |, XOR ^, REVERSE ~, or REPLACE -
              ******************************************************************************/
              void Draw_Rect(int ulcol, int ulrow, int lrcol, int lrrow, char operation) {
              
                      Write_Icon(ulcol, ulrow, lrcol-ulcol+1, lrrow-ulrow+1, (u08 *) allonbckgnd, operation);
              
              } // Draw_Rect
              #endif
 662          /******************************************************************************
 663          ** Reset_Top_Line **************************************** GAS 19 AUG 04 ****
 664          *******************************************************************************
 665          This function sets the top line of the display. Used to recover from scrolling.
 666          ******************************************************************************/
 667          void Reset_Top_Line(void) {
 668   1      
 669   1              Write_Display(CMD, START_LINE_SET, 0);
 670   1              Write_Display(CMD, START_LINE_SET, 1);
 671   1      
 672   1      } // Reset_Top_Line
 673          
C51 COMPILER V9.51   DISPLAY                                                               11/30/2014 18:01:38 PAGE 12  

 674          #ifndef SAVEMEM
 675          /******************************************************************************
 676          ** Info_Screen **************************************** GAS 31 JAN 05 ****
 677          *******************************************************************************
 678          This function writes text to the display in the information bubble.
 679          ******************************************************************************/
 680          void Info_Screen(char *infotext) {
 681   1      
 682   1              Write_Screen(infoscreen, '-');
 683   1              Write_Big_Text(1, 7, infotext, '-');
 684   1      
 685   1      } // Info_Screen
 686          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2379    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =   ----      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      90
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
