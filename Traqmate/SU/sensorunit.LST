C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE SENSORUNIT
OBJECT MODULE PLACED IN sensorunit.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE sensorunit.c OPTIMIZE(SIZE) BROWSE MDU_F120 INCDIR(..\..\C51\INC\;..\Common
                    -Files\;..\SU\) DB OE DEFINE(SENSOR,EXTCLK6,NODEBUG,UBLOX,DISPLAYATTACHED) DEBUG OBJECTEXTEND

line level    source

   1          // This is the main program for sensorunit.c, part of Traqmate
   2          //
   3          // Change Log:
   4          // Jan 2004 - created, GAStephens
   5          // 5/25/2004 - added differential, better flashing during collection, fixed bugs
   6          // 6/3/2004 - added foolproof mode, fixed bugs
   7          // 7/18/2004 - converted to sensorunit.c, split off common files with displayunit.c
   8          // 8/18/2004 - eliminated print mode, streamlined crc calcs
   9          // 11/16/2004 - added conditional compile for UBX and created ParseTsip and ParseUBX
  10          // 12-14-2004 - converted to 132 microprocessor
  11          // 2-4-2005 - reworked timing to reset adc sampling every gps pulse
  12          // 3-24-2005 - added power up and power down code
  13          // 4-11-2005 - added 20Hz operation
  14          // 11-20-2005 - added I/O
  15          // 12-04-2006 - fixed I/O synchronization
  16          // 2-15-2007 - added digital outputs
  17          // 3-8-2008 - added autostart, button disables, advanced chasecam control
  18          // 2-1-2009 - added support for ublox lea5 gps chip and 3 axis accelerometer
  19          //
  20          // This version runs on the main circuit board with Dataflash
  21          // This code is not portable. It depends on 8052 byte ordering MSB..LSB.
  22          //
  23          // Dependent files:
  24          // sensor.h                             contains DEFINES, typedefs, and global variable declarations
  25          // tmtypes.h                    contains DEFINES, typedefs, and global variable declarations
  26          // tsip.h                               Trimble binary protocol definitions
  27          // ubx.h                                Ublox binary protocol definitions
  28          // crc.h                                crc calculations
  29          // session.h                    data collection session definitions
  30          // crc16table.c                 crc lookup table
  31          // message.h                    inter-unit messaging
  32          // opcode.h                             messaging opcodes
  33          // cygfx120.c                   contains 8051 setup and operations functions
  34          // adc.c                                contains A-D converter functions
  35          // dataflash.c                  contains functions for ATMEL dataflash serial flash memory
  36          // tsip.c                               contains functions to decode / encode TSIP commands
  37          // ubx.c                                contains functions to decode / encode UBX commands
  38          // message.c                    implements messaging packet protocol
  39          // session.c                    data collection session control and indexing
  40          // fdl.c                                allows self reprogramming
  41          // suports.c                    sets up i/o ports
  42          // smbus.c                              drivers for smbus (i2c expansion bus)
  43          // lancsetup.c                  does handshake with traqdata lanc interface
  44          // digipot.c                    allows the auto-on function to operate on su2
  45          //
  46          
  47          #define SU_MAIN
  48          
  49          // copyright notice
  50          code char crnotice[] = "Copyright (C) 2014 Track Systems Technologies, LLC";
  51          
  52          #include <stdlib.h>
  53          #include <string.h>
  54          #include <math.h>
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 2   

  55          
  56          #include <sensor.h>
  57          
  58          #include <crc16table.c>
  59          #ifdef TSIP
              #include <tsip.h>
              #else
  62          #include <ubx.h>
  63          #endif
  64          
  65          void Init_Cameras( void );
  66          void Process_Sample_Set( void );
  67          void Stop_Recording( void );
  68          void Setup_Recording ( void );
  69          void Process_IO( void );
  70          void SMB_Slave_Test (void);
  71          
  72          xdata u16 firstpulse = SKIPCYCLES;      // used to get synched up
  73          
  74          #ifdef DISPLAYATTACHED
  75          #define TRAQMATE_TYPE   1               // complete
  76          #else
              #define TRAQMATE_TYPE   0               // basic
              #endif
  79          
  80          void main (     void ) {
  81   1              xdata int retval;                                       // function call return value
  82   1              xdata int i;                                                            // general counter
  83   1              u32 onbuttonctr = 0;                            // timing loop for releasing on button
  84   1              xdata u16 nextcamupdate;                        // second count to send camera status update
  85   1              xdata BOOL updatestatus = FALSE;
  86   1      #ifndef DISPLAYATTACHED
                      s16 eastvel, northvel;                          // used for Basic Autorecord function
                      u16 speed;
                      float tempfloat;
                      xdata speedlockout = 6;                         // number of speed samples to skip to allow GPS to settle
              #endif
  92   1                              
  93   1              SFRPAGE = CONFIG_PAGE;
  94   1      
  95   1              // disable watchdog timer
  96   1              WDTCN = 0xde;
  97   1              WDTCN = 0xad;
  98   1      
  99   1              SYSCLK_Init();                                          // initialize oscillator
 100   1              PORT_Init_SU();                                         // enable ports
 101   1      
 102   1              // seize the 5V Enable line to keep power up
 103   1      //      EN5V = 1;       // already done in suports
 104   1      
 105   1      #ifdef DEBUG
                      PWRLED = 0;             // use power led for debug signaling
              #endif
 108   1      
 109   1              RECLED = GPSLED = COMLED = 0;
 110   1      
 111   1              SPIO_Init();                                            // set up the SPI
 112   1              DataFlash_Init(&numpages, &pagesize);   // set up the DataFlash - must come before scratchpad init
 113   1      
 114   1              // get the configuration data
 115   1              InitSUScratchpad();
 116   1      
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 3   

 117   1              samps_per_sec = 20;                                     // initialize to something valid
 118   1              iocollect = 0;
 119   1      
 120   1      #ifndef DISPLAYATTACHED
                      Repair_Sessions();                                      // fix any power loss problems
                      Init_Tables();                                          // initialize driver and data input tables
              #endif
 124   1      
 125   1              // init the dead reckoning history
 126   1              for (i=0; i<2; i++) {
 127   2                      previousgps[i].time = previousgps[i].lat = previousgps[i].lon = 0L;
 128   2                      previousgps[i].weeks = previousgps[i].alt = 0;
 129   2                      previousgps[i].velpack[0] =
 130   2                      previousgps[i].velpack[1] =
 131   2                      previousgps[i].velpack[2] =
 132   2                      previousgps[i].velpack[3] = 0;
 133   2                      previousgps[i].temp = 0;
 134   2              } // for
 135   1              lastgps = 0;
 136   1      
 137   1              ADC0_Init();                                            // init ADC
 138   1              Timer3_Init ((u16) (SYSCLK/SAMPLE_RATE/12));    // initialize Timer3 to overflow at sample rate
 139   1              PPS_Init();                                                     // start GPS pulse interrupts
 140   1              Freq0_Init();                                           // set up frequency measurement for RPM
 141   1      
 142   1              // create com ports
 143   1              com[0].use = MESSAGING;
 144   1      #ifdef TSIP
                      com[1].use = TSIPGPS;
                      com[1].parity = 'O';                            // parity = ODD
              #else
 148   1              com[1].use = UBXGPS;
 149   1              com[1].parity = 'N';                            // parity = NONE
 150   1      #endif
 151   1              com[0].rxbuff = msgrxbuff;
 152   1              com[1].rxbuff = gpsrxbuff;
 153   1              com[0].txbuff = msgtxbuff;
 154   1              com[1].txbuff = gpstxbuff;
 155   1              com[0].port = 0;
 156   1              com[1].port = 1;
 157   1              com[0].parity = 'N';                            // parity = NONE
 158   1              com[0].txbytes = com[1].txbytes = 0;    // initialize
 159   1              com[0].rxfirstidx = com[1].rxfirstidx = 0;              // initialize
 160   1              com[0].rxnextidx = com[1].rxnextidx = 0;
 161   1              com[0].rxptr = com[0].txptr =                   // initialize semaphores
 162   1              com[1].rxptr = com[1].txptr = NULL;
 163   1      
 164   1              // initialize com ports
 165   1      #ifdef DISPLAYATTACHED
 166   1              UART_Init(&(com[0]), DUMSGBAUD);
 167   1      #else
              //      UART_Init(&(com[0]), PCMSGBAUD);
                      UART_Init(&(com[0]), PCUSBMSGBAUD);             // converted to 230K for all comm in V3.70
              #endif
 171   1      
 172   1      #ifdef TSIP
                      UART_Init(&(com[1]), TSIPBAUD);
              #else
 175   1              if (su2)
 176   1                      UART_Init(&(com[1]), UBXLEABAUD);
 177   1              else
 178   1                      UART_Init(&(com[1]), UBXBAUD);
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 4   

 179   1      #endif
 180   1      
 181   1              if (su2) {                                                      // if we are capable, turn on the SMbus
 182   2                      // create smbus port
 183   2                      smbus.rxbuff = smbusrxbuff;             // point to buffers
 184   2                      smbus.txbuff = smbustxbuff;
 185   2                  smbus.sent_byte_counter = 0;        // counts outgoing bytes
 186   2                      smbus.rec_byte_counter = 0;             // counts incoming bytes
 187   2                      smbus.data_ready = FALSE;               // semaphore
 188   2                      SMB_Init();                                             // configure and enable SMBus
 189   2              } // if
 190   1      
 191   1              camlanc.ports = NOCAMLANC;
 192   1              // handshake with LANC and setup SMBus accessories
 193   1              New_Accessory_Setup();
 194   1      
 195   1      #ifndef DISPLAYATTACHED
                      // wait for buttons release so we don't go into recording
                      // eventually give up and move on
              
                      do {} while (0 == SW1 && ++onbuttonctr < 10000000L) ;
              
                      // wait for buttons to settle
                      DELAY_MS(100);
              
                      // clear any button count
                      debounce = 0;
              
                      // initialize memory pointers
                      Init_Session(&pagecnt, &iopagecnt);
              #endif
 210   1      
 211   1              EA = 1;                                                         // enable global interrupts
 212   1      
 213   1      // Turns SU2 unit into a full-time SMbus slave test
 214   1      #ifdef SUSLAVETEST
                      SMB_Slave_Test();
              #endif
 217   1      
 218   1              if (su2) {
 219   2                      DELAY_MS(60);                                   // allows Ublox 5 time to cold start
 220   2                      UBXBaudChange();                                // change from 9600 bps to 57kbps
 221   2              } // if
 222   1      
 223   1              // initialize the Ublox
 224   1              UBXInit();
 225   1              ubxdone = TRUE;
 226   1      
 227   1      #ifdef DEBUG
                      // made it this far so look normal
                      RECLED = 0;
                      GPSLED = 0;
                      COMLED = 0;
                      PWRLED = 1;
              #endif
 234   1      
 235   1              // init camera stuff
 236   1              camlanc.event = NOEVENT;
 237   1      
 238   1              nextcamupdate = secondtick + 10;                        // send first update in 9. do not make this < 9
 239   1      
 240   1              Init_Cameras();
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 5   

 241   1      
 242   1              // clear the main buffer
 243   1              for (i=0; i < pagesize; i++)
 244   1                      flashpage.bigbuff[i] = 0;
 245   1      
 246   1      #ifndef DISPLAYATTACHED
                      // check to see if button is enabled
                      if (AUTORECORD)         // start recording when conditions are right
                              tm_state = WAIT_COLLECT;        
              #endif
 251   1      
 252   1              while (1) {
 253   2                      // check for dropping power
 254   2                      if (adcresults && result[2] < POWER_THRESHOLD) {
 255   3      #ifndef DISPLAYATTACHED
                                      u08 status;
              #endif
 258   3                              // shut down LEDs to save power
 259   3                              PWRLED = 0; RECLED = 0; GPSLED = 0; COMLED = 0;
 260   3      
 261   3                              // shut down the GPS module to save power
 262   3                              if (su2)
 263   3                                      EN3VGPS = 1;
 264   3                              else
 265   3                                      EN3VGPS = 0;
 266   3      
 267   3      #ifdef DISPLAYATTACHED
 268   3                              // tell the display unit
 269   3                              SendMessage((u08) SENSOR_UNIT, (u08) DISPLAY_UNIT, (u08) POWER_DOWN, (u08) 0);
 270   3      #endif
 271   3                              // wait for 1.5 seconds for message to be received
 272   3                              DELAY_MS(1500);
 273   3      
 274   3      #ifndef DISPLAYATTACHED
                                      Stop_Recording();
              
                                      // wait for Serial Flash to be finished
                                      do {
                                              status = DataFlash_Read_Status();
                                      } while (!(status & STATUS_READY_MASK));
              #endif
 282   3                              EN5V = 0;
 283   3                              // loop until dead
 284   3                              while (1) ;
 285   3      
 286   3                      } // if
 287   2      
 288   2                      // is it time to report camera status?
 289   2                      if (nextcamupdate == secondtick) {
 290   3                              updatestatus = TRUE;            // send a camera update regardless of status change
 291   3                              nextcamupdate++;                        // do it again in another second
 292   3                      } // if
 293   2      
 294   2                      // manage cameras and report status when not otherwise engaged
 295   2                      // if usb camera connected and enabled, track status
 296   2                      if (NOEVENT == camlanc.event) {
 297   3                              if (ENABLED4USB == camlanc.ports) {
 298   4                                      // if we are recording, report it
 299   4                                      if (1 == DIGOUT4) {
 300   5                                              if (camlanc.status != CAMLANCRECORD) {
 301   6                                                      camlanc.status = CAMLANCRECORD;
 302   6                                              } // if
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 6   

 303   5                                      } // if
 304   4                                      else {
 305   5                                              if (camlanc.status != CAMLANCREADY) {
 306   6                                                      camlanc.status = CAMLANCREADY;
 307   6                                              } // if
 308   5                                      } // else
 309   4                              } // else if ENABLED4USB
 310   3                              // status of gopro or replay
 311   3                              else if (ENABLED4GOPRO == camlanc.ports || ENABLED4REPLAY == camlanc.ports) {
 312   4                                      if (DIGIN3) {
 313   5                                              if (camlanc.status != CAMLANCRECORD) {
 314   6                                                      camlanc.status = CAMLANCRECORD;
 315   6                                                      updatestatus = TRUE;
 316   6                                              } // if
 317   5                                      } // if
 318   4                                      else { // not in record mode
 319   5                                              if (DIGIN2) {
 320   6                                                      if (camlanc.status != CAMLANCREADY) {
 321   7                                                              camlanc.status = CAMLANCREADY;
 322   7                                                              updatestatus = TRUE;
 323   7                                                      } // if
 324   6                                              } // if
 325   5                                              else if (camlanc.status != CAMLANCNOTREADY) {
 326   6                                                      camlanc.status = CAMLANCNOTREADY;
 327   6                                                      updatestatus = TRUE;
 328   6                                              } // else if
 329   5                                      } // else
 330   4                              } // else
 331   3                              else if (ENABLED4LANC == camlanc.ports) {
 332   4                                      if (LANCNOTREADY)
 333   4                                              camlanc.status = CAMLANCNOTREADY;
 334   4                                      else {
 335   5                                              if (LANCRECORDING)
 336   5                                                      camlanc.status = CAMLANCRECORD;
 337   5                                              else
 338   5                                                      camlanc.status = CAMLANCREADY;
 339   5                                      } // else
 340   4                              } // else if
 341   3                      } // if
 342   2      
 343   2                      // camera control, handle pulse on / pulse off for cameras      
 344   2                      if (clocktick == camlanc.eventtick) {
 345   3                              switch (camlanc.event) {
 346   4                                      case (PULSEON):
 347   4                                              switch (cameracontrol[camlanc.ports][TRAQMATE_TYPE][samps_per_sec/20][SIGNALTYPE]) {
 348   5                                                      case LEVEL:                     // USB camera
 349   5                                                              DIGOUT4 = 1;
 350   5                                                              camlanc.status = CAMLANCRECORD;
 351   5                                                              camlanc.event = NOEVENT;
 352   5                                                              break;
 353   5                                                      case PULSE:                     // pulse style camera control
 354   5                                                              DIGOUT4 = 1;
 355   5                                                              camlanc.status = CAMLANCONPULSE;
 356   5                                                              camlanc.event = PULSEOFF;                                       
 357   5                                                              camlanc.eventtick = clocktick +
 358   5                                                                      (long) cameracontrol[camlanc.ports][TRAQMATE_TYPE][samps_per_sec/20][RECONTIME] * (long) SAMPLE_RA
             -TE / 1000L;
 359   5                                                              break;
 360   5                                                      case LANC:
 361   5                                                              LANCCMD = LANCRECORD;
 362   5                                                              camlanc.event = NOEVENT;
 363   5                                                              break;
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 7   

 364   5                                              } // switch
 365   4                                              break;
 366   4                                      case (PULSEOFF):
 367   4                                              DIGOUT4 = 0;
 368   4                                              camlanc.status = CAMLANCRECORD;
 369   4                                              camlanc.event = LOCKOUT;
 370   4                                              // don't report status during data delay
 371   4                                              camlanc.eventtick = clocktick + 
 372   4                                                      (long) cameracontrol[camlanc.ports][TRAQMATE_TYPE][samps_per_sec/20][DATADELAY] * (long) SAMPLE_RATE
             - / 1000L;
 373   4                                              break;
 374   4                                      case (LOCKOUT):
 375   4                                              DIGOUT4 = 0;
 376   4                                              camlanc.event = NOEVENT;
 377   4                                              break;
 378   4                                      default:        // nothing to do
 379   4                                              break;
 380   4                              } // switch
 381   3                      } // if
 382   2                              
 383   2      #ifdef DISPLAYATTACHED
 384   2                      if (duconnected && !RECORDING(tm_state) && !REPROGRAMMING(tm_state) && updatestatus) {
 385   3                              updatestatus = FALSE;
 386   3                              // tell the display unit
 387   3                              if (NOCAMLANC != camlanc.ports) {
 388   4                                      com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START] = (u08) camlanc.status;
 389   4                                      SendMessage((u08) SENSOR_UNIT, (u08) DISPLAY_UNIT, (u08) CAM_STATUS, 1);
 390   4                              } // if
 391   3                      } // if
 392   2      #endif
 393   2                      
 394   2                      // check for incoming message
 395   2                      if (NULL != com[0].rxptr) {
 396   3                              u08 *tmpptr = com[0].rxptr;
 397   3      
 398   3                              // clear the semaphore to allow 2nd buffer to fill
 399   3                              com[0].rxptr = NULL;
 400   3                              // process the message
 401   3                              retval = Parse_Message(0, tmpptr);
 402   3                      } // if
 403   2      
 404   2      #ifndef DISPLAYATTACHED
                              // power off if button enabled and switch was held more than ON/OFF period
                              if (!NOPOWEROFF && (debounce >= DEBOUNCE_ONOFF)) {
                                      u08 status;
              
                                      // save power
                                      PWRLED = 0; RECLED = 0; GPSLED = 0; COMLED = 0;
              
                                      // stop and save
                                      Stop_Recording();
              
                                      // wait for Serial Flash to be finished
                                      do {
                                              status = DataFlash_Read_Status();
                                      } while (!(status & STATUS_READY_MASK));
              
                                      // turn off camera              
                                      switch (cameracontrol[camlanc.ports][TRAQMATE_TYPE][samps_per_sec/20][SIGNALTYPE]) {
                                              case LEVEL:             // usb camera
                                                      DIGOUT4 = 0;
                                                      break;
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 8   

                                              case PULSE:             // pulse style camera
                                                      // wait a bit in case it just turned on
                                                      DELAY_MS(200);
                                                      DIGOUT4 = 1;
                                                      DELAY_MS(cameracontrol[camlanc.ports][TRAQMATE_TYPE][samps_per_sec/20][RECOFFTIME]);
                                                      DIGOUT4 = 0;
                                                      break;
                                              case LANC:
                                                      LANCCMD = LANCRECSTOP;                          // stop recording on LANC
                                                      break;
                                      } // switch
              
                                      // shut off the power
                                      EN5V = 0;
                                      P7 = 0;
              
                                      // loop until dead
                                      while (1) ;
                              } // if
              
                              // check for button not pressed
                              if (0 != SW1) {
                                      // see if it has just been released
                                      if (debounce >= DEBOUNCE_NORMAL) {
                                              switch (tm_state) {
                                                      case WAITING:
                                                      case WAIT_COLLECT: {
                                                              u16 tempclock;
                                                              if (NORECORDOFF) break; // button is disabled for this function
              
                                                              // initialize
                                                              Setup_Recording();
              
                                                              stoprecordtick = scratch.calibrate.turnofftime + secondtick;   // will overflow and wrap
              
                                                              tempclock = clocktick;
                                                              // clear the io buffer and start the session
                                                              session = Start_Session(&pagecnt, &iopagecnt);
                                                              if (0 == session) { // no sessions available
                                                                      RECLED = 0;
                                                                      tm_state = WAITING;
                                                              } // if
                                                              else { // got a good session number
                                                                      tm_state = COLLECTING;
                                                                      RECLED = 1;
                                                              } // else
                                                              break;
                                                      } // case
                                                      case COLLECTING:
                                                              if (NORECORDOFF) break; // button is disabled for this function
                                                              Stop_Recording();
                                                      // fall through
                                                      case ERASING:
                                                              if (AUTORECORD)
                                                                      tm_state = WAIT_COLLECT;
                                                              else
                                                                      tm_state = WAITING;
                                                              // turn off gps signal LED
                                                              GPSLED = 0;
                                                              
                                                              break;
                                              } // switch
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 9   

                                      } // if
                                      // reset debounce counter, regardless
                                      debounce = 0;
                              } // if
              #endif
 492   2                      if (mode_change) {                              // check the semaphore
 493   3      #ifndef DISPLAYATTACHED
              //                      u08 status;
              #endif
 496   3                              mode_change = FALSE;
 497   3      
 498   3                              // check for shutdown
 499   3                              if (SHUTDOWN == new_mode) {
 500   4      
 501   4                                      // DU ON/OFF button has been pressed or
 502   4                                      // DU notified of power failure, shut down, and telling SU to shut down
 503   4      
 504   4                                      if (ENABLED4LANC == camlanc.ports)
 505   4                                              LANCCMD = LANCRECSTOP;                                          // stop recording on LANC device
 506   4                                      else if (ENABLED4USB == camlanc.ports) {                // stop recording
 507   5                                              DIGOUT4 = 0;
 508   5                                      } // else
 509   4                                      else {
 510   5                                              // turn off -- generic
 511   5                                              if (CAMLANCRECORD == camlanc.status && CAMOFF != camlanc.status) {
 512   6                                                      DELAY_MS(2000);
 513   6                                                      DIGOUT4 = 1;
 514   6                                                      DELAY_MS(cameracontrol[camlanc.ports][TRAQMATE_TYPE][samps_per_sec/20][RECOFFTIME]);
 515   6                                                      DIGOUT4 = 0;
 516   6                                              } // if
 517   5                                      } // else
 518   4      
 519   4                                      // turn off LEDs
 520   4                                      PWRLED = 0; RECLED = 0; GPSLED = 0; COMLED = 0;
 521   4      
 522   4                                      EN5V = 0;
 523   4                                      // loop until dead
 524   4      // *** TEST gas 2012 what if we just keep operating?                            while (1) ;
 525   4      // *** 2/2013, seems to be fine. recommend leaving comment in place -- gas
 526   4                              } // if
 527   3                              // check for reprogramming
 528   3                              else if (START_DOWNLOAD == new_mode) {
 529   4                                      tm_state = new_mode;
 530   4      
 531   4                                      // use flash for temporary storage
 532   4                                      pagecnt = 0;
 533   4                                      // use variable session to count the cksum
 534   4                                      session = 0xFF;
 535   4      
 536   4                                      // turn on all LEDs to indicate SW download
 537   4                                      PWRLED = 1; RECLED = 1; GPSLED = 1; COMLED = 1;
 538   4      
 539   4                                      // shut down interrupts
 540   4                                      EX0 = 0;                                                        // disable INT0
 541   4                                      EIE2 &= ~0x02;                                          // disable ADC interrupts
 542   4                                      EIE2 &= ~0x40;                                          // disable UART1 interrupts
 543   4      
 544   4                                      new_mode = WAITING;
 545   4                              } // else if
 546   3                              else if (DOWNLOAD_COMPLETE == new_mode) {
 547   4                                      tm_state = new_mode;
 548   4      
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 10  

 549   4                                      // turn off all LEDs to indicate SW reprogram
 550   4                                      PWRLED = 0; RECLED = 0; GPSLED = 0; COMLED = 0;
 551   4      
 552   4                                      new_mode = WAITING;
 553   4                              } // else if
 554   3                              else if (CANCEL_DOWNLOAD == new_mode) {
 555   4                                      tm_state = new_mode;
 556   4      
 557   4                                      // turn on all LEDs to indicate something happening
 558   4                                      PWRLED = 1; RECLED = 1; GPSLED = 1; COMLED = 1;
 559   4      
 560   4                                      // wipe out everything and don't show progress
 561   4                                      DataFlash_Erase_Range(0, LASTLAPPAGE, FALSE);
 562   4      
 563   4                                      // reset the unit
 564   4                                      SFRPAGE = LEGACY_PAGE;
 565   4      
 566   4                                      // pull the reset line to restart everything
 567   4                                      RSTSRC = RSTSRC | 0x01;
 568   4                              } // else if
 569   3      #ifdef DISPLAYATTACHED
 570   3                              // if changing into monitoring state, set it up
 571   3                              else {  // this is structured like this to accommodate changing from non-recording
 572   4                                              // data modes to recording data modes on the fly
 573   4                                      // turn on REC LED if recording
 574   4                                      if (RECORDING(new_mode))
 575   4                                              RECLED = 1;
 576   4      
 577   4                                      // do this every time in case io setup has changed
 578   4                                      if (MONITORING(new_mode))
 579   4                                              Setup_Recording();
 580   4      
 581   4                                      if (MONITORING(tm_state) != MONITORING(new_mode)) {
 582   5                                              if (MONITORING(new_mode)) { // entering reporting mode
 583   6      //                                              tm_state = new_mode;
 584   6      
 585   6                                                      // timing starts NOW
 586   6                                                      ADC0_Init();                                            // init ADC
 587   6                                                      UBXInit();                                                      // init Ublox GPS
 588   6                                                      gpspulse = FALSE;                                       // clear out semaphore
 589   6                                                      gps_past_due = clocktick + 1 + 10 * (SAMPLE_RATE / samps_per_sec);
 590   6                                              } // if
 591   5                                              else {          // dropping out of monitoring / recording
 592   6      //                                              tm_state = WAITING;
 593   6                                                      if (RECORDING(tm_state))
 594   6                                                              Stop_Recording();
 595   6                                              } // else
 596   5                                      } // if
 597   4                                      tm_state = new_mode;                            
 598   4                                      new_mode = WAITING;
 599   4                              } // else
 600   3      #endif // DISPLAYATTACHED
 601   3                      } // if mode_change
 602   2      
 603   2                      if (MONITORING(tm_state)) {
 604   3      #ifdef DISPLAYATTACHED
 605   3                              // only process events one at a time and if transmission channel available to send
 606   3                              // proceed with tx only if no receive message available
 607   3                              // make sure last tx either acked or timed out
 608   3                              // make sure last tx is complete
 609   3                              if (NULL == com[0].rxptr && 0 == CTS[DISPLAY_UNIT-1] && NULL == com[0].txptr) {
 610   4      #endif
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 11  

 611   4                                      // if accelerometer sample, record or send a message
 612   4                                      if (adcresults) {
 613   5                                              // don't reset the semaphore if power dropped
 614   5                                              if (result[2] > POWER_THRESHOLD)
 615   5                                                      adcresults = FALSE;
 616   5                                              else
 617   5                                                      adcresults = TRUE;
 618   5      
 619   5                                              if (secondcnt >= SAMP10S_PER_PAGE)
 620   5                                                      secondcnt = SAMP10S_PER_PAGE - 1;
 621   5      
 622   5                                              if (su2)
 623   5                                                      // put in fake temperature number
 624   5      //                                              currenttemp = 0;                // degrees C
 625   5                                                      // put in Z acceleration value
 626   5                                                      currenttemp = (u08) (result[3] >> 4);
 627   5                                              else {
 628   6                                                      // store the temperature in with the GPS data
 629   6                                                      // calculated from SiLabs documentation
 630   6                                                      currenttemp = (s08) ((((long) result[3] - 5125L) * 1000L) / 9445L);
 631   6                                                      // subtract off die temp increase to approximate ambient
 632   6                                                      currenttemp -= TEMPERATURE_OFFSET;
 633   6                                              } // else
 634   5      
 635   5      #ifdef DISPLAYATTACHED
 636   5                                              // pack in the accelerometer data
 637   5                                              com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START] =
 638   5                                                      ((result[0] & 0x0F00) >> 4) + ((result[1] & 0x0F00) >> 8);
 639   5                                              com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START+1] =
 640   5                                                      flashpage.secsamp10[secondcnt].accel[gcnt][1] +
 641   5                                                      result[0] & 0xFF;
 642   5                                              com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START+2] =
 643   5                                                      flashpage.secsamp10[secondcnt].accel[gcnt][2] +
 644   5                                                      result[1] & 0xFF;
 645   5                                              // add on the io data
 646   5                                              com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START+3] = ~P5;       // invert digitals
 647   5                                              com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START+4] = result[7] >> ioscaling[3]; // analog 3
 648   5                                              com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START+5] = result[6] >> ioscaling[2]; // analog 2
 649   5                                              com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START+6] = result[5] >> ioscaling[1]; // analog 1
 650   5                                              com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START+7] = result[4] >> ioscaling[0]; // analog 0
 651   5                                              com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START+8] = (u08) ((period0 & 0xFF00) >> 8);   // freq 1
 652   5                                              com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START+9] = (u08) (period0 & 0x00FF);  // freq 0
 653   5      
 654   5                                              // tell the display unit
 655   5                                              SendMessage((u08) SENSOR_UNIT, (u08) DISPLAY_UNIT, (u08) ACCEL_DATA, (sizeof(acceltype)+7));
 656   5      
 657   5                                              // turn on alarms if necessary
 658   5                                              Process_IO();
 659   5      
 660   5      #else   // NO DISPLAYATTACHED
                                                      if (RECORDING(tm_state)){
                                                              // only process data if we have gotten gps
                                                              if (!firstpulse) {
                                                                      // ensure no overflow in case of lost GPS signal
                                                                      if (gcnt >= 10)
                                                                              gcnt = 9;       // error condition
                              
                                                                      // pack accel data into buffer
                                                                      flashpage.secsamp10[secondcnt].accel[gcnt][0] =
                                                                              ((result[0] & 0x0F00) >> 4) + ((result[1] & 0x0F00) >> 8);
                                                                      flashpage.secsamp10[secondcnt].accel[gcnt][1] =
                                                                              result[0] & 0xFF;
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 12  

                                                                      flashpage.secsamp10[secondcnt].accel[gcnt][2] =
                                                                              result[1] & 0xFF;
                              
                                                                      // prepare for next accel sample
                                                                      gcnt++;
                      
                                                                      // read and record io points as appropriate
                                                                      Process_IO();
                                                              } // if firstpulse
                                                      } // if
              #endif  // NO DISPLAYATTACHED
 684   5                                      } // if
 685   4                                      // no adc so check for gps message
 686   4                                      else if (com[1].rxnextidx != com[1].rxfirstidx) { // received a GPS command
 687   5                                              // create a pointer to buffer to be processed
 688   5                                              u08 *tmpptr = com[1].rxbuff + com[1].rxfirstidx*UBXRXSIZE;
 689   5      
 690   5                                              // increment counter to point to next inbound message in queue
 691   5                                              com[1].rxfirstidx = (com[1].rxfirstidx == (GPSRXBUFCNT-1))? 0 : com[1].rxfirstidx + 1;
 692   5      
 693   5      #ifdef TSIP
                                                      Parse_Tsip(tmpptr, &(flashpage.secsamp10[secondcnt].gps));
              #else
 696   5                                              // ensure up to date temperature
 697   5                                              flashpage.secsamp10[secondcnt].gps.temp = currenttemp;
 698   5                                              // if this is a good gps then put it in the flashpage
 699   5                                              Parse_UBX(tmpptr, &(flashpage.secsamp10[secondcnt].gps));
 700   5      #endif
 701   5      
 702   5      #ifndef DISPLAYATTACHED
                                                      // Do Auto-Start
                                                      // unpack the velocities
                                                      eastvel = (s16) ((((u16) (flashpage.secsamp10[secondcnt].gps.velpack[0] & 0xE0)) << 3) |
                                                              (u16) flashpage.secsamp10[secondcnt].gps.velpack[1]);
                                                      // sign extend
                                                      if (eastvel & 0x0400) eastvel = (u16) eastvel | 0xF800;
                                      
                                                      northvel = (s16) ((((u16) (flashpage.secsamp10[secondcnt].gps.velpack[0] & 0x1C)) << 6) |
                                                              (u16) flashpage.secsamp10[secondcnt].gps.velpack[2]);
                                                      if (northvel & 0x0400) northvel = (u16) northvel | 0xF800;
                                      
                                                      // calculate speed in meters/sec plus fudge factor
                                                      tempfloat = GPSVELSCALE * sqrt((float) ((double) eastvel * (double) eastvel + (double) northvel * (do
             -uble) northvel));
                                                      speed = (u16) (tempfloat * (39.0/12.0/5280.0*60.0*60.0));
                                      
                                                      // check to see if stop recording conditions are met
                                                      if (COLLECTING == tm_state) {
                                      
                                                              if (0 != speed) { // vehicle moving so reset counters
                                                                      stoprecordtick = scratch.calibrate.turnofftime + secondtick;   // will overflow and wrap
                                                              } // if
                                                              else { // vehicle stopped. let's see for how long
                                                                      if (secondtick == stoprecordtick && AUTORECORDSTOP) {
                                                                              Stop_Recording();
                                                      
                                                                              if (AUTORECORD)         // start recording when conditions are right
                                                                                      tm_state = WAIT_COLLECT;
                                                                              else
                                                                                      tm_state = WAITING;
                                                                      } // if
                                                              } // else
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 13  

                                                      } // if
              
                                                      // check to see if auto recording conditions are met (proper speed, good signal)
                                                      if (WAIT_COLLECT == tm_state) {
                                                              if (speedlockout) {             // skip the first few speed samples to allow GPS to settle
                                                                      speedlockout--;
                                                              } // if
                                                              else {
                                                              
                                                                      if ((gpslock > 5) && (dop < 300) && speed >= (u16) scratch.calibrate.turnonspeed) {
                                              
                                                                              tm_state = COLLECTING; // start recording immediately
                                              
                                                                              // initialize
                                                                              Setup_Recording();
                                              
                                                                              // initialize timers for stop recording
                                                                              stoprecordtick = scratch.calibrate.turnofftime + secondtick;   // will overflow and wrap
                                              
                                                                              // clear the io buffer and start the session
                                                                              session = Start_Session(&pagecnt, &iopagecnt);
                                                                              if (0 == session) { // no sessions available
                                                                                      RECLED = 0;
                                                                                      tm_state = WAITING;
                                                                              } // if
                                                                              else { // got a good session number
                                                                                      tm_state = COLLECTING;
                                                                                      RECLED = 1;
                                                                              } // else
                                                                      } // if
                                                              } // else
                                                      } // if
              #endif
 767   5                                      } // if got gps message
 768   4      
 769   4                                      // if pulse received or past due, start a new sampling period
 770   4                                      else if (gpspulse || clocktick == gps_past_due) {
 771   5                                              // figure out when next gps pulse is due
 772   5                                              gps_past_due = clocktick + 1 + 10 * (SAMPLE_RATE / samps_per_sec);
 773   5      
 774   5                                              // if we are faking pulse, then no satellites present
 775   5                                              if (!gpspulse) {
 776   6                                                      if (simgps)     {
 777   7                                                              gpspulse = 1;
 778   7                                                              gpslock = 6;
 779   7                                                              dop = 200;
 780   7                                                      } // if
 781   6                                                      else
 782   6                                                              gpslock = 0;
 783   6                                                      // already one clock tick late so don't creep
 784   6                                                      gps_past_due--;
 785   6                                              } // if
 786   5      
 787   5      #ifndef DISPLAYATTACHED
                                                      if (RECORDING(tm_state)) {
              #endif
 790   5                                              // don't save any data until we see a real GPS pulse so we can
 791   5                                              // synchronize position data with accelerometer data
 792   5                                              // synchronize if starting recording but not if just monitoring
 793   5                                              if (firstpulse && (RECORDING(tm_state))) {
 794   6                                                      if (gpspulse) {
 795   7                                                              if (NOCAMLANC == camlanc.ports || UNKNOWNCONFIG == camlanc.ports) {             // no camera
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 14  

 796   8                                                                      camlanc.event = NOEVENT;
 797   8                                                              } // if
 798   7                                                              else {                  // set up timing for camera
 799   8                                                                      if (camlanc.status == CAMLANCREADY && camlanc.event == NOEVENT) {
 800   9                                                                              camlanc.event = PULSEON;
 801   9                                                                              camlanc.eventtick = clocktick + 1;
 802   9                                                                      } // if 
 803   8                                                                      
 804   8      // **** I think we don't need this anymore                                                      
 805   8      #if 0
                                                                              xdata u16 skip;
              
                                                                              // skip is number of GPS samples (1 - 4 per second depending on sample rate) to skip before issuin
             -g the camera start 
                                                                              skip = (long) cameracontrol[camlanc.ports][TRAQMATE_TYPE][samps_per_sec/20][CAMDELAY] * (long) sam
             -ps_per_sec / 10L / 1000L;
                                                                      
                                                                              if (skip == firstpulse) {               // start the camera when we come back through the camera state machine
                                                                                      camlanc.event = PULSEON;
                                                                                      camlanc.status = 
                                                                                      camlanc.eventtick = clocktick + 1;
                                                                              } // if 
              #endif
 817   8                                                              } // else                                                       
 818   7                                                              if (0 == --firstpulse) {
 819   8                                                                      // synched up so start with fresh counters
 820   8                                                                      gcnt = 0;
 821   8                                                                      secondcnt = 0;
 822   8      #ifndef DISPLAYATTACHED
                                                                              iobyte = pagesize - 1;          // point to MSB
              #endif
 825   8                                                              } // if
 826   7                                                      } // if
 827   6                                              } // if
 828   5                                              else { // not first pulse
 829   6      #ifdef DISPLAYATTACHED
 830   6                                                      int i;
 831   6      
 832   6      //                                              if (ENABLED4LANC == camlanc.ports)
 833   6      //                                                      LANCCMD = LANCRECORD;   // set bit to request record    
 834   6      
 835   6                                                      // tell the display unit
 836   6                                                      com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START] = gpslock;
 837   6                                                      com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START+1] = (u08) ((dop & 0xFF00) >> 8);
 838   6                                                      com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START+2] = (u08) (dop & 0x00FF);
 839   6                                                      com[msgrouting[DISPLAY_UNIT]].txbuff[DATA_START+3] = (u08) camlanc.status;
 840   6                                                      SendMessage((u08) SENSOR_UNIT, (u08) DISPLAY_UNIT, (u08) GPS_PULSE, 4);
 841   6      
 842   6                                                      // clear the main buffer
 843   6                                                      for (i=0; i < pagesize; i++)
 844   6                                                              flashpage.bigbuff[i] = 0;
 845   6      #else   // no DISPLAYATTACHED
                                                              // fill in any unprogrammed accel samples with previous values
                                                              // *** NOTE - should fill in i/o samples as well to stay in synch
                                                              // has not be a problem so leaving that for future - GAS
                                                              for (; gcnt < SAMP10S_PER_PAGE; gcnt++) {
                                                                      if (gcnt == 0) {
                                                                              flashpage.secsamp10[secondcnt].accel[gcnt][0] =
                                                                                      ((scratch.calibrate.xzero & 0x0F00) >> 4) +
                                                                                      ((scratch.calibrate.yzero & 0x0F00) >> 8);
                                                                              flashpage.secsamp10[secondcnt].accel[gcnt][1] =
                                                                                      scratch.calibrate.xzero & 0xFF;
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 15  

                                                                              flashpage.secsamp10[secondcnt].accel[gcnt][2] =
                                                                                      scratch.calibrate.yzero & 0xFF;
                                                                      } // if
                                                                      else {
                                                                              flashpage.secsamp10[secondcnt].accel[gcnt][0] =
                                                                                      flashpage.secsamp10[secondcnt].accel[gcnt-1][0];
                                                                              flashpage.secsamp10[secondcnt].accel[gcnt][1] =
                                                                                      flashpage.secsamp10[secondcnt].accel[gcnt-1][1];
                                                                              flashpage.secsamp10[secondcnt].accel[gcnt][2] =
                                                                                      flashpage.secsamp10[secondcnt].accel[gcnt-1][2];
                                                                      } // else
                                                              } // for
                                      
                                                              // got a complete sample set so process it
                                                              Process_Sample_Set();
              #endif  // no DISPLAYATTACHED
 872   6                                              } // else
 873   5      #ifndef DISPLAYATTACHED
                                                      } // if
              #endif
 876   5                                              // initialize semaphores
 877   5                                              gpspulse = FALSE;
 878   5                                              ubxfullset = 0;                 // resynch Ublox messages
 879   5      
 880   5                                              // flash LED to show we have satellite coverage
 881   5                                              if (gpslock) {
 882   6                                                      GPSLED = ~GPSLED;
 883   6                                                      gpslock = 0;
 884   6                                              }
 885   5                                              else GPSLED = 0;
 886   5                                      } // if gpspulse
 887   4      
 888   4      #ifdef DISPLAYATTACHED
 889   4                              } // if check for transmit
 890   3      #endif
 891   3                      } // if monitoring
 892   2              } // while
 893   1      } // main
 894          
 895          void Init_Cameras( void ) {
 896   1              // Get IO setup
 897   1              DataFlash_Page_Read(MAX_PAGE_SIZE, flashpage.bigbuff, IODEFPAGE);
 898   1      
 899   1              // break out digital output status
 900   1              digout.digoutstate[D4] = flashpage.io.digouts[0] & 0x0F;
 901   1              digout.digoutstate[D5] = (flashpage.io.digouts[0] & 0xF0) >> 4;
 902   1      
 903   1              // determine what type of interface is connected and which camera is configured
 904   1              // see if camera configured (lanc already checked)
 905   1              if (ENABLED4LANC != camlanc.ports) {    // skip config if lanc already detected
 906   2                      if (!(P5 & TACHORDATA) && (ENABLED4LANC != camlanc.ports)) {
 907   3                              camlanc.ports = NOCAMLANC;
 908   3                              camlanc.status = CAMLANCNOTCONNECTED;
 909   3                      } // if
 910   2                      else {  // some sort of camera interface connected so see if software enabled
 911   3                              camlanc.status = CAMLANCREADY;                  
 912   3                              switch (digout.digoutstate[D4]) {
 913   4                                      case SONYLANC:
 914   4                                              camlanc.ports = ENABLED4LANC;
 915   4                                              break;                                  
 916   4                                      case GOPROCAMERA:
 917   4                                              camlanc.ports = ENABLED4GOPRO;
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 16  

 918   4                                              break;
 919   4                                      case REPLAYCAMERA:
 920   4                                              camlanc.ports = ENABLED4REPLAY;
 921   4                                              break;
 922   4                                      case REPLAYXDUSB:
 923   4                                              camlanc.ports = ENABLED4REPLAYUSB;
 924   4                                              break;
 925   4                                      case REPLAYMINI:
 926   4                                              camlanc.ports = ENABLED4MINI;
 927   4                                              break;
 928   4                                      case REPLAYPRIME:
 929   4                                              camlanc.ports = ENABLED4PRIME;
 930   4                                              break;
 931   4                                      case CAMERA:
 932   4                                      case MOBIUS:
 933   4                                              camlanc.ports = ENABLED4MOBIUS;
 934   4                                              break;
 935   4                                      default:
 936   4                                              camlanc.ports = NOCAMLANC;
 937   4                                              camlanc.status = CAMLANCNOTCONNECTED;
 938   4                              } // switch
 939   3                      } // else
 940   2              } // if
 941   1      } // Init_Cameras
 942          
 943          #ifndef DISPLAYATTACHED
              //
              // save the data and go to the next Flash page
              //
              void Process_Sample_Set( void ) {
                      int i;
              
                      // check to see if flash buffer full
                      if (secondcnt >= (SAMP10S_PER_PAGE-1)) {        // buffer filled
              
                              // write buffer to flash
                              DataFlash_Page_Write_Erase(GENBUFFER, pagesize, flashpage.bigbuff, pagecnt);
              
                              // check to see if we are full
                              if (pagecnt >= iopagecnt-1) { // unit is full
                                      // write the io buffer
                                      DataFlash_Page_Write_From_Buffer_Erase(IOBUFFER, iopagecnt);
                                      // roll up the sidewalks and go home
                                      End_Session(session, pagecnt, iopagecnt);
                                      tm_state = WAITING;
                                      gpslock = 0;
                                      RECLED = 0; GPSLED = 0;
                              }
                              else {
                                      // go to next page
                                      pagecnt++;
                              }
              
                              // clear the buffer
                              for (i=0; i < pagesize; i++) flashpage.bigbuff[i] = 0;
                              // reset sample set counter
                              secondcnt = 0;
                      } // if
                      else                            // buffer not filled so go to new second
                              secondcnt++;    // go to the next sample set
              
                      // no matter what, reset the accelerometer counter
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 17  

                      gcnt = 0;
              
              } // Process_Sample_Set
              #endif  // !DISPLAYATTACHED
 984          //
 985          // Common code when dropping out of a record mode
 986          // Saves everything
 987          //
 988          void Stop_Recording( void ) {
 989   1      
 990   1              GPSLED = RECLED = 0;
 991   1      
 992   1      #ifndef DISPLAYATTACHED
                      // save the data
                      if (RECORDING(tm_state)) {
                              // save the io data
                              if (!firstpulse && iocollect)
                                      DataFlash_Page_Write_From_Buffer_Erase(IOBUFFER, iopagecnt);
                              End_Session(session, pagecnt, iopagecnt);
                      } // if
              #endif
1001   1      
1002   1              // if camera is recording, stop recording       
1003   1              if (NOCAMLANC != camlanc.ports && UNKNOWNCONFIG != camlanc.ports) {             // camera installed
1004   2                      switch (cameracontrol[camlanc.ports][TRAQMATE_TYPE][samps_per_sec/20][SIGNALTYPE]) {
1005   3                              case LEVEL:             // usb camera
1006   3                                      DIGOUT4 = 0;
1007   3                                      break;
1008   3                              case PULSE:             // pulse style camera
1009   3                                      // wait a bit in case it just turned on
1010   3                                      DELAY_MS(200);
1011   3                                      DIGOUT4 = 1;
1012   3                                      DELAY_MS(cameracontrol[camlanc.ports][TRAQMATE_TYPE][samps_per_sec/20][RECOFFTIME]);
1013   3                                      DIGOUT4 = 0;
1014   3                                      break;
1015   3                              case LANC:
1016   3                                      LANCCMD = LANCRECSTOP;                          // stop recording on LANC
1017   3                                      break;
1018   3                      } // switch
1019   2                      camlanc.status = CAMLANCREADY;
1020   2                      camlanc.event = NOEVENT;
1021   2              } // if
1022   1                      
1023   1              // turn off digital outputs
1024   1              if (ENABLED4LANC != camlanc.ports)      
1025   1                      P4 = 0x00;
1026   1      
1027   1      } // Stop_Recording
1028          
1029          //
1030          // Common code when entering a record mode
1031          //
1032          void Setup_Recording( void ) {
1033   1              int itmp;
1034   1              u16 clockin = clocktick;
1035   1      
1036   1              // initialize
1037   1              gcnt = secondcnt = 0;
1038   1              gpslock = 0;
1039   1              gpspulse = FALSE;
1040   1      
1041   1              // set up the sampling rate
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 18  

1042   1              DataFlash_Page_Read(pagesize, flashpage.bigbuff, USERPAGE);
1043   1      
1044   1      #ifndef DISPLAYATTACHED
                      // load the values from configuration
                      new_samp = flashpage.user.modesample & 0x0F;
                      new_iocollect = flashpage.user.iodata;
              
                      // set the rpm warning level for digital output alarm
                      cyl = flashpage.user.car[flashpage.user.selectedcar].carspecs.cylandweight & 0x0F;
                      revs = flashpage.user.car[flashpage.user.selectedcar].carspecs.revwarning;
              #endif
1053   1      
1054   1              // set up the proper sampling rate
1055   1              switch (new_samp) {
1056   2                      case 4:
1057   2                              samps_per_sec = 40;
1058   2                              break;
1059   2                      case 2:
1060   2                              samps_per_sec = 20;
1061   2                              break;
1062   2                      case 0:
1063   2                      default:
1064   2                              samps_per_sec = 10;
1065   2                              break;
1066   2              } // switch
1067   1      
1068   1              if (NOCAMLANC == camlanc.ports || UNKNOWNCONFIG == camlanc.ports) {             // no camera
1069   2                      firstpulse = 4;                         // start almost immediately
1070   2              } // if
1071   1              else {                  // set up timing for camera
1072   2                      // setup data delay to allow for camera head start, number of GPS samples to skip = 1 - 4 per second dep
             -ending on sample rate
1073   2                      firstpulse = (long) cameracontrol[camlanc.ports][TRAQMATE_TYPE][new_samp/2][DATADELAY] * (long) samps_pe
             -r_sec / 10L / 1000L;
1074   2                      if ((int) firstpulse <= 0) firstpulse = 1;              // make sure the table can't be wrong
1075   2      } // else
1076   1              
1077   1              // set up the I/O collection
1078   1              iocollect = new_iocollect;
1079   1      
1080   1              if (0 == revs)
1081   1                      digout.minperiod = 0;
1082   1              else {
1083   2                      if (0 == cyl)   // 2-stroke kart
1084   2                              digout.minperiod = (120 * 2) * (u16) ((float) FREQ_SAMPLE_RATE / (float) revs);
1085   2                      else {
1086   3                              if (15 == cyl) cyl = 16; 
1087   3                              digout.minperiod = (120 / cyl) * (u16) ((float) FREQ_SAMPLE_RATE / (float) revs);
1088   3                      } // else
1089   2              } // else
1090   1              // only save data if Data Interface attached
1091   1              if (!(P5 & TACHORDATA))
1092   1                      iocollect = 0;
1093   1              else {
1094   2                      // Set up analog inputs for alarm level detection
1095   2                      DataFlash_Page_Read(MAX_PAGE_SIZE, flashpage.bigbuff, IODEFPAGE);
1096   2      
1097   2                      // break out digital output status
1098   2                      digout.digoutstate[D4] = flashpage.io.digouts[0] & 0x0F;
1099   2                      digout.digoutstate[D5] = (flashpage.io.digouts[0] & 0xF0) >> 4;
1100   2      
1101   2                      // Set up input scaling
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 19  

1102   2                      for (itmp=0; itmp<NUMANALOGS; itmp++) {
1103   3                              switch (flashpage.io.analogs[itmp].maxscale) {
1104   4                                      case 10: ioscaling[itmp] = 3;
1105   4                                              break;
1106   4                                      case 5: ioscaling[itmp] = 2;
1107   4                                              break;
1108   4                                      case 20:
1109   4                                      default: ioscaling[itmp] = 4;
1110   4                                              break;
1111   4                              } // switch
1112   3                      } // for
1113   2      
1114   2                      // figure out analog alarm levels and direction to watch for
1115   2                      for (itmp=0; itmp<NUMANALOGS; itmp++) {
1116   3                              digout.analogwarning[itmp].alarmdirection = flashpage.io.analogs[itmp].alarmdirection;
1117   3                              // get percentage scale of alarm threshold and convert to 8 bit value
1118   3                              digout.analogwarning[itmp].alarmnum = flashpage.io.analogs[itmp].lowreading +
1119   3                                      (float) (flashpage.io.analogs[itmp].highreading - flashpage.io.analogs[itmp].lowreading) *
1120   3                                      ABS((flashpage.io.analogs[itmp].alarmval - flashpage.io.analogs[itmp].lowval) / 
1121   3                                      (flashpage.io.analogs[itmp].highval - flashpage.io.analogs[itmp].lowval));
1122   3                      } // for
1123   2              } // else
1124   1      
1125   1              // if 16 bit mode selected, turn on all the frequency lines
1126   1              if (iocollect & 0x80)
1127   1                      iocollect |= 0x03;
1128   1      
1129   1              // clear the main buffer
1130   1              for (itmp=0; itmp < pagesize; itmp++)
1131   1                      flashpage.bigbuff[itmp] = 0;
1132   1                      
1133   1      } // Setup_Recording
1134          
1135          //
1136          // Common code for processing IO and checking for alarms
1137          //
1138          void Process_IO ( void ) {
1139   1              // only process i/o data if enabled and plugged in
1140   1              if (iocollect) {
1141   2                      s08 checkbits;                  // used to check off the enable bits for data i/o
1142   2                      // save the i/o points in the order MSB - LSB, DIA3A2A1A0F1F0
1143   2                      for (checkbits = 6; checkbits >= 0; checkbits--) {
1144   3                              u08 tmpch;
1145   3      
1146   3                              // if enable bit set, save data point into dataflash buffer
1147   3                              if ((iocollect >> checkbits) & 0x01) {
1148   4                                      switch (checkbits) {
1149   5                                              // Digitals
1150   5                                              case 6:
1151   5                                                      tmpch = (u08) ~P5;              // invert digitals
1152   5                                                      break;
1153   5                                              // Analogs
1154   5                                              case 4:         // non-alarmable analogs
1155   5                                              case 5:
1156   5                                                      tmpch = (u08) (result[checkbits+2] >> (ioscaling[checkbits-2]));                                                                                
1157   5                                                      break;
1158   5                                              case 3:
1159   5                                              case 2: {       // alarmable analogs
1160   6                                                      BOOL warning = FALSE;
1161   6      
1162   6                                                      tmpch = (u08) (result[checkbits+2] >> (ioscaling[checkbits-2]));                                                                                
1163   6      
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 20  

1164   6                                                      // proceed if analog alarm notification is requested
1165   6                                                      if (ANALOGALARM == digout.digoutstate[checkbits - 2]) {
1166   7                                                              // check for alarm condition
1167   7                                                              switch (digout.analogwarning[checkbits-2].alarmdirection) {
1168   8                                                                      case 1:
1169   8                                                                              warning = tmpch > digout.analogwarning[checkbits-2].alarmnum;
1170   8                                                                              break;
1171   8                                                                      case 0:
1172   8                                                                              warning = tmpch == digout.analogwarning[checkbits-2].alarmnum;
1173   8                                                                              break;
1174   8                                                                      case -1:
1175   8                                                                              warning = tmpch < digout.analogwarning[checkbits-2].alarmnum;
1176   8                                                                              break;
1177   8                                                              } // switch
1178   7      
1179   7                                                              if (warning) // activate alarm
1180   7                                                                      P4 |= 1 << (checkbits+2);       
1181   7                                                              else            // deactivate alarm
1182   7                                                                      P4 &= ~(1 << (checkbits+2));
1183   7                                                      } // if
1184   6                                                      break;
1185   6                                              } // case
1186   5                                              // Frequencies - 16 bit mode!!
1187   5                                              case 1:  // MSB = F1
1188   5                                                      tmpch = (u08) ((period0 & 0xFF00) >> 8);
1189   5                                                      break;
1190   5                                              case 0: { // LSB = F0
1191   6                                                      int outbit;
1192   6                                                      tmpch = (u08) (period0 & 0x00FF);
1193   6      
1194   6                                                      // check for rpm alarm
1195   6                                                      if (0 != digout.minperiod && 0 != period0) {
1196   7                                                              if (digout.minperiod <= period0) {      // turn on alarm
1197   8                                                                      for (outbit = D4; outbit <= D5 ; outbit++)
1198   8                                                                              if (RPMWARN == digout.digoutstate[outbit])
1199   8                                                                                      P4 &= ~(1 << (outbit+4));
1200   8                                                              } // if                                                         
1201   7                                                              else { // turn off alarm
1202   8                                                                      for (outbit = D4; outbit <= D5 ; outbit++)
1203   8                                                                              if (RPMWARN == digout.digoutstate[outbit])
1204   8                                                                                      P4 |= 1 << (outbit+4);
1205   8                                                              } // else
1206   7                                                      } // if
1207   6                                                      break;
1208   6                                              } // case 0
1209   5                                      } // switch
1210   4      
1211   4      #ifndef DISPLAYATTACHED
                                              // write the character
                                              DataFlash_Buffer_Write(IOBUFFER, 1, iobyte, &tmpch);
              
                                              // check for dataflash buffer full
                                              if (iobyte != 0)
                                                      iobyte--;       // point to the next byte down in the dataflash buffer
                                              else {
                                                      // write the buffer
                                                      DataFlash_Page_Write_From_Buffer_Erase(IOBUFFER, iopagecnt);
              
                                                      // check to see if entire dataflash full
                                                      if (pagecnt >= iopagecnt-1) { // unit is full
                                                              End_Session(session, pagecnt, iopagecnt);
                                                              tm_state = WAITING;
C51 COMPILER V9.51   SENSORUNIT                                                            01/05/2016 18:47:24 PAGE 21  

                                                              gpslock = 0;
                                                              RECLED = 0; GPSLED = 0;
              
                                                              // turn off all digital outputs
                                                              if (ENABLED4LANC != camlanc.ports)
                                                                      P4 = 0x00;
                                                      }
                                                      else {
                                                              // go to next page
                                                              iopagecnt--;
                                                              iobyte = pagesize - 1;          // point to MSB
                                                              // clear the io buffer
                                                              DataFlash_Buffer_Clear(IOBUFFER, pagesize);
                                                      } // else
                                              } // else
              #endif
1242   4                              } // if
1243   3                      } // for
1244   2              } // if iocollect
1245   1      } // Process_IO
1246          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5521    ----
   CONSTANT SIZE    =    567    ----
   XDATA SIZE       =   3845      31
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
