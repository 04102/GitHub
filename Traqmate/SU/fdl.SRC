; .\fdl.SRC generated from: ..\CommonFiles\fdl.c
; COMPILER INVOKED BY:
;        C:\Keil\C51\BIN\C51.EXE ..\CommonFiles\fdl.c OPTIMIZE(SIZE) BROWSE MDU_F120 INCDIR(..\..\C51\INC\;..\CommonFiles\;..\SU\) DB OE DEFINE(SENSOR,EXTCLK6,NODEBUG,UBLOX,DISPLAYATTACHED) DEBUG OBJECTEXTEND PRINT(.\fdl.lst) SRC(.\fdl.SRC)

$NOMOD51

NAME	FDL

DIGOUT0	BIT	0C8H.0
CCF2	BIT	0D8H.2
TB80	BIT	098H.3
SPI0CKR	DATA	09DH
DIGOUT1	BIT	0C8H.1
CCF3	BIT	0D8H.3
TB81	BIT	098H.3
P0	DATA	080H
DIGOUT2	BIT	0C8H.2
SPIEN	BIT	0F8H.0
CCF4	BIT	0D8H.4
SM00	BIT	098H.7
P1	DATA	090H
PLL0FLT	DATA	08FH
DIGOUT3	BIT	0C8H.3
CCF5	BIT	0D8H.5
AA	BIT	0C0H.2
SM10	BIT	098H.6
WDTCN	DATA	0FFH
P2	DATA	0A0H
DIGOUT4	BIT	0C8H.4
SM20	BIT	098H.5
ADC0CF	DATA	0BCH
P3	DATA	0B0H
DIGOUT5	BIT	0C8H.5
AC	BIT	0D0H.6
P4	DATA	0C8H
DIGOUT6	BIT	0C8H.6
PCA0	DATA	0F9H
EIE1	DATA	0E6H
P5	DATA	0D8H
ADC2CF	DATA	0BCH
LED0	BIT	0B0H.3
EA	BIT	0A8H.7
P6	DATA	0E8H
EIE2	DATA	0E7H
LED1	BIT	0B0H.6
MCE1	BIT	098H.5
P7	DATA	0F8H
LED2	BIT	0B0H.5
PSCTL	DATA	08FH
EN3VGPS	BIT	0F8H.4
LED3	BIT	0B0H.4
CF	BIT	0D8H.7
PLL0MUL	DATA	08EH
ADC0CN	DATA	0E8H
DAC0CN	DATA	0D4H
SFRPAGE	DATA	084H
DAC1CN	DATA	0D4H
MAC0CF	DATA	0C3H
MAC0AH	DATA	0C2H
P0MDOUT	DATA	0A4H
ADC2CN	DATA	0E8H
P1MDOUT	DATA	0A5H
MAC0BH	DATA	092H
IE	DATA	0A8H
P2MDOUT	DATA	0A6H
CCH0MA	DATA	09AH
P3MDOUT	DATA	0A7H
CCH0LC	DATA	0A3H
EIP1	DATA	0F6H
MAC0AL	DATA	0C1H
P4MDOUT	DATA	09CH
TXBMT	BIT	0F8H.1
EIP2	DATA	0F7H
CCH0CN	DATA	0A1H
P5MDOUT	DATA	09DH
MAC0BL	DATA	091H
DF_WP	BIT	0F8H.0
PCA0CPH0	DATA	0FCH
P6MDOUT	DATA	09EH
PCA0CPH1	DATA	0FEH
P7MDOUT	DATA	09FH
DP	DATA	082H
PCA0CPH2	DATA	0EAH
ADC0GT	DATA	0C4H
CR	BIT	0D8H.6
PCA0CPH3	DATA	0ECH
EXF2	BIT	0C8H.6
REN0	BIT	098H.4
PCA0CPL0	DATA	0FBH
PCA0CPH4	DATA	0EEH
EMI0CF	DATA	0A3H
SFRPGCN	DATA	096H
EXF3	BIT	0C8H.6
REN1	BIT	098H.4
PCA0CPL1	DATA	0FDH
PCA0CPH5	DATA	0E2H
PCA0CPM0	DATA	0DAH
PCA0MD	DATA	0D9H
PCA0CN	DATA	0D8H
ADC2GT	DATA	0C4H
EXF4	BIT	0C8H.6
PCA0CPL2	DATA	0E9H
PCA0CPM1	DATA	0DBH
PCA0CPL3	DATA	0EBH
PCA0CPM2	DATA	0DCH
IP	DATA	0B8H
ADC0LT	DATA	0C6H
MAC0HO	BIT	0C0H.3
CP0FIF	BIT	088H.4
PCA0CPL4	DATA	0EDH
PCA0CPM3	DATA	0DDH
CP1FIF	BIT	088H.4
PCA0CPL5	DATA	0E1H
PCA0CPM4	DATA	0DEH
CY	BIT	0D0H.7
SI	BIT	0C0H.3
PCA0CPM5	DATA	0DFH
ADC2LT	DATA	0C6H
ENSMBPU	BIT	0F8H.3
DIGIN0	BIT	0D8H.0
XBR0	DATA	0E1H
SADEN0	DATA	0B9H
DIGIN1	BIT	0D8H.1
XBR1	DATA	0E2H
EMI0CN	DATA	0A2H
EN5V	BIT	0F8H.7
DIGIN2	BIT	0D8H.2
XBR2	DATA	0E3H
DIGIN3	BIT	0D8H.3
FLHBUSY	BIT	088H.0
REF0CN	DATA	0D1H
SADDR0	DATA	0A9H
DIGIN4	BIT	0D8H.4
AMX0CF	DATA	0BAH
DIGIN5	BIT	0D8H.5
AD0INT	BIT	0E8H.5
RCAP2H	DATA	0CBH
CCH0TN	DATA	0A2H
SFRLAST	DATA	086H
DIGIN6	BIT	0D8H.6
PS	BIT	0B8H.4
RCAP3H	DATA	0CBH
AMX2CF	DATA	0BAH
SP	DATA	081H
AD2INT	BIT	0E8H.5
RCAP4H	DATA	0CBH
EMI0TC	DATA	0A1H
OV	BIT	0D0H.2
MAC0SO	BIT	0C0H.1
SMB0CN	DATA	0C0H
TMR2	DATA	0CCH
CP0RIF	BIT	088H.5
RCAP2L	DATA	0CAH
TMR3	DATA	0CCH
MODF	BIT	0F8H.5
CP1RIF	BIT	088H.5
RCAP3L	DATA	0CAH
TMR4	DATA	0CCH
RCAP4L	DATA	0CAH
SMB0CR	DATA	0CFH
CPT0MD	DATA	089H
CPT0CN	DATA	088H
S1MODE	BIT	098H.7
P1MDIN	DATA	0ADH
PLL0CN	DATA	089H
CPT1MD	DATA	089H
CPT1CN	DATA	088H
EN3VIF	BIT	0F8H.5
SFRNEXT	DATA	085H
SPI0CN	DATA	0F8H
MAC0RNDH	DATA	0CFH
TMR2CF	DATA	0C9H
TMR3CF	DATA	0C9H
PCON	DATA	087H
DF_CS1	BIT	0F8H.1
TMR4CF	DATA	0C9H
SPIF	BIT	0F8H.7
MAC0RNDL	DATA	0CEH
TMOD	DATA	089H
TCON	DATA	088H
WCOL	BIT	0F8H.6
NSSMD0	BIT	0F8H.2
AMX0SL	DATA	0BBH
NSSMD1	BIT	0F8H.3
TMR2CN	DATA	0C8H
TMR3CN	DATA	0C8H
AMX2SL	DATA	0BBH
TMR4CN	DATA	0C8H
SMBSDA	BIT	080H.6
CP0OUT	BIT	088H.6
CP1OUT	BIT	088H.6
IE0	BIT	088H.1
IE1	BIT	088H.3
OSCICL	DATA	08BH
CLKSEL	DATA	097H
B	DATA	0F0H
DAC0H	DATA	0D3H
ADC0H	DATA	0BFH
PSBANK	DATA	0B1H
OSCICN	DATA	08AH
DAC1H	DATA	0D3H
SMBFTE	BIT	0C0H.1
BUSY	BIT	0C0H.7
DAC0L	DATA	0D2H
ADC0L	DATA	0BEH
SMBSCL	BIT	080H.7
DAC1L	DATA	0D2H
ACC	DATA	0E0H
ES0	BIT	0A8H.4
PCA0CP0	DATA	0FBH
AD0EN	BIT	0E8H.7
CT2	BIT	0C8H.1
ET0	BIT	0A8H.1
PCA0CP1	DATA	0FDH
CT3	BIT	0C8H.1
ET1	BIT	0A8H.3
TF0	BIT	088H.5
PCA0CP2	DATA	0E9H
AD2EN	BIT	0E8H.7
CT4	BIT	0C8H.1
ET2	BIT	0A8H.5
RI0	BIT	098H.0
TF1	BIT	088H.7
PCA0CP3	DATA	0EBH
TF2	BIT	0C8H.7
SMBTOE	BIT	0C0H.0
RI1	BIT	098H.0
TH0	DATA	08CH
PCA0CP4	DATA	0EDH
TF3	BIT	0C8H.7
EX0	BIT	0A8H.0
TI0	BIT	098H.1
IT0	BIT	088H.0
PCA0H	DATA	0FAH
TH1	DATA	08DH
PCA0CP5	DATA	0E1H
TF4	BIT	0C8H.7
EX1	BIT	0A8H.2
TI1	BIT	098H.1
IT1	BIT	088H.2
P	BIT	0D0H.0
MAC0N	BIT	0C0H.0
OSCXCN	DATA	08CH
TL0	DATA	08AH
FLSTAT	DATA	088H
PCA0L	DATA	0F9H
TL1	DATA	08BH
PT0	BIT	0B8H.1
RS0	BIT	0D0H.3
PT1	BIT	0B8H.3
RS1	BIT	0D0H.4
PT2	BIT	0B8H.5
TR0	BIT	088H.4
AD0TM	BIT	0E8H.6
CP0EN	BIT	088H.7
TR1	BIT	088H.6
TR2	BIT	0C8H.2
PX0	BIT	0B8H.0
CP1EN	BIT	088H.7
RCAP2	DATA	0CAH
AD2TM	BIT	0E8H.6
TR3	BIT	0C8H.2
PX1	BIT	0B8H.2
RCAP3	DATA	0CAH
TR4	BIT	0C8H.2
SW1	BIT	0E8H.0
RCAP4	DATA	0CAH
MAC0Z	BIT	0C0H.2
DPH	DATA	083H
ADC0GTH	DATA	0C5H
DPL	DATA	082H
ADC0GTL	DATA	0C4H
SBUF0	DATA	099H
ADC0LTH	DATA	0C7H
SBUF1	DATA	099H
EXEN2	BIT	0C8H.3
RSTSRC	DATA	0EFH
FLACL	DATA	0B7H
DF_RST	BIT	0F8H.2
EXEN3	BIT	0C8H.3
CPRL2	BIT	0C8H.0
CP0HYN0	BIT	088H.0
SCON0	DATA	098H
EXEN4	BIT	0C8H.3
CPRL3	BIT	0C8H.0
CP1HYN0	BIT	088H.0
CP0HYN1	BIT	088H.1
SCON1	DATA	098H
CPRL4	BIT	0C8H.0
CP1HYN1	BIT	088H.1
CP0HYP0	BIT	088H.2
ADC0LTL	DATA	0C6H
CP1HYP0	BIT	088H.2
CP0HYP1	BIT	088H.3
STA	BIT	0C0H.5
CP1HYP1	BIT	088H.3
SMB0ADR	DATA	0C3H
MAC0STA	DATA	0C0H
SSTA0	DATA	091H
SMB0DAT	DATA	0C2H
TMR2H	DATA	0CDH
SPI0CFG	DATA	09AH
ACCST	BIT	0D8H.2
TMR3H	DATA	0CDH
CKCON	DATA	08EH
TMR4H	DATA	0CDH
RXOVRN	BIT	0F8H.4
TMR2L	DATA	0CCH
TMR3L	DATA	0CCH
AD0LJST	BIT	0E8H.0
TMR4L	DATA	0CCH
F0	BIT	0D0H.5
FLSCL	DATA	0B7H
AD0CM0	BIT	0E8H.2
F1	BIT	0D0H.1
STO	BIT	0C0H.4
ENSMB	BIT	0C0H.6
AD0CM1	BIT	0E8H.3
SPI0DAT	DATA	09BH
DAC0	DATA	0D2H
ADC0	DATA	0BEH
AD2CM0	BIT	0E8H.1
DAC1	DATA	0D2H
AD2CM1	BIT	0E8H.2
AD0WINT	BIT	0E8H.1
AD2CM2	BIT	0E8H.3
AD0BUSY	BIT	0E8H.4
PSW	DATA	0D0H
ADC2	DATA	0BEH
MAC0OVR	DATA	097H
MAC0ACC0	DATA	093H
AD2WINT	BIT	0E8H.0
MAC0ACC1	DATA	094H
AD2BUSY	BIT	0E8H.4
CCF0	BIT	0D8H.0
RB80	BIT	098H.2
SMB0STA	DATA	0C1H
MAC0ACC2	DATA	095H
CCF1	BIT	0D8H.1
RB81	BIT	098H.2
MAC0ACC3	DATA	096H
PLL0DIV	DATA	08DH
?PR?_CopytoCodeSpace?FDL                 SEGMENT CODE 
?DT?_CopytoCodeSpace?FDL                 SEGMENT DATA OVERLAYABLE 
?PR?_FDL_xferSPI?FDL SEGMENT CODE 
?PR?FDL_DataFlash_Read_Status?FDL        SEGMENT CODE 
?DT?FDL_DataFlash_Read_Status?FDL        SEGMENT DATA OVERLAYABLE 
	EXTRN	XDATA (flashpage)
	PUBLIC	FDL_DataFlash_Read_Status
	PUBLIC	_FDL_xferSPI
	PUBLIC	_CopytoCodeSpace

	RSEG  ?DT?FDL_DataFlash_Read_Status?FDL
?FDL_DataFlash_Read_Status?BYTE:
          q?252:   DS   2

	RSEG  ?DT?_CopytoCodeSpace?FDL
?_CopytoCodeSpace?BYTE:
   lastpage?040:   DS   2
	ORG  11
          q?041:   DS   2
	ORG  11
       temp?042:   DS   1
	ORG  11
          q?043:   DS   2
	ORG  11
          q?044:   DS   2
	ORG  2
     pwrite?045:   DS   3
	ORG  5
    EA_save?046:   DS   1
	ORG  6
          i?047:   DS   2
	ORG  8
       page?048:   DS   2
	ORG  10
     status?049:   DS   1
; // software downloader
; //
; // this must be less than 510 bytes when compiled which is very tight. It must
; // not extend into address 0xFFFE or 0xFFFF, the micro flash lock bytes
; // it is loaded at 0xFE00 and must be self-contained so the code copy will
; // not overwrite it.
; //
; // initial implementation John Paulos, 04/26/2005
; // re-written Glenn Stephens, 05/02/2005
; //
; 
; #include <tmtypes.h>
; #ifdef DISPLAY
; #include <display.h>
; #else
; #include <sensor.h>
; #endif
; 
; //#define DFWAITREAD do {int q; for (q=0; q<64; q++) ; } while(0)  // 64 seems to work well. should be verified.
; //#define DFWAITWRITE do {int q; for (q=0; q<64; q++) ; } while(0)  // longer for erase.
; #define DFWAITFDL do {int q; for (q=0; q<200; q++) ; } while(0)  // longer for erase.
; 
; u08 FDL_xferSPI (u08);
; u08 FDL_DataFlash_Read_Status(void);
; 
; void CopytoCodeSpace(u16 lastpage) {

	RSEG  ?PR?_CopytoCodeSpace?FDL
_CopytoCodeSpace:
	USING	0
			; SOURCE LINE # 26
	MOV  	lastpage?040,R6
	MOV  	lastpage?040+01H,R7
; 	char * data pwrite;
; 	char EA_save;
; 	u16 i, page;
; 	u08 status;
; #pragma ASM
; // support code versions with roadblock at 0xfe00
	  
; // this code duplicates the c compiler argument passing code
	  
; //	argument passing, R6 = MSB, R7 = LSB
	  
; 	MOV  	lastpage?040,R6
	  MOV  	lastpage?040,R6
; 	MOV  	lastpage?040+01H,R7
	  MOV  	lastpage?040+01H,R7
; #pragma ENDASM
; 
; 	pwrite = 0x0;						// initialize code pointer
			; SOURCE LINE # 39
	MOV  	pwrite?045,#00H
	MOV  	pwrite?045+01H,#00H
	MOV  	pwrite?045+02H,#00H
; 
; 	EA_save = EA;						// save interrupt status
			; SOURCE LINE # 41
	MOV  	C,EA
	CLR  	A
	RLC  	A
	MOV  	EA_save?046,A
; 	EA = 0;								// disable interrupts
			; SOURCE LINE # 42
	CLR  	EA
; 
; 	SFRPAGE = LEGACY_PAGE;
			; SOURCE LINE # 44
	CLR  	A
	MOV  	SFRPAGE,A
; 	FLSCL |= 0x01;						// enable flash writes/erases from user software
			; SOURCE LINE # 45
	ORL  	FLSCL,#01H
; 
; 	PSCTL = 0x03;						// movx writes erase flash page
			; SOURCE LINE # 47
	MOV  	PSCTL,#03H
?C0001:
; 
; 	// erase code memory up to last 1024 page containing bootstrapper
; 	while (pwrite < LAST_CODE_PAGE) {	// stop one page from end of codespace
			; SOURCE LINE # 50
	CLR  	C
	MOV  	A,pwrite?045+01H
	SUBB 	A,#0FCH
	JNC  	?C0002
; //		*pwrite = 0x88;					// write any value to initiate page erase
; // this assembler code must be here to force compiler to use the MOVX instruction to cause flash rewrite
; // XXXXXXXXXXXXXXXXXX
; #pragma ASM
; 		MOV  	DPL,pwrite?045+01H
	  MOV  	DPL,pwrite?045+01H
; 		MOV  	DPH,pwrite?045	
	  MOV  	DPH,pwrite?045	
; 		MOV  	A,#088H					// put a value in A, doesn't matter what
	  MOV  	A,#088H					 
; 		MOVX 	@DPTR,A					// MOVX causes code flash page to be erased
	  MOVX 	@DPTR,A					 
; #pragma ENDASM
; 		pwrite += CODE_PAGE_SIZE;		// point to next page
			; SOURCE LINE # 60
	CLR  	A
	ADD  	A,pwrite?045+02H
	MOV  	pwrite?045+02H,A
	MOV  	A,#04H
	ADDC 	A,pwrite?045+01H
	MOV  	pwrite?045+01H,A
; 	}	// while
			; SOURCE LINE # 61
	SJMP 	?C0001
?C0002:
; 
; 	PSCTL = 0x00;						// movx writes to target ram
			; SOURCE LINE # 63
	CLR  	A
	MOV  	PSCTL,A
; 	pwrite = 0x00;						// reset code pointer
			; SOURCE LINE # 64
	MOV  	pwrite?045,A
	MOV  	pwrite?045+01H,A
	MOV  	pwrite?045+02H,A
; 
; 	// copy code over from dataflash to micro flash codespace 512 bytes at a time
; 	for (page=0; page < (BOOTSTRAP_ADDR/CODE_DOWNLOAD_SIZE); page++) {
			; SOURCE LINE # 67
	MOV  	page?048,A
	MOV  	page?048+01H,A
?C0003:
; 
; 		SFRPAGE = CONFIG_PAGE;
			; SOURCE LINE # 69
	MOV  	SFRPAGE,#0FH
; 
; //			FDL_DataFlash_Page_Read(MAX_PAGE_SIZE, flashpage.bigbuff, read_page);
; // function is put in line here to avoid passing pointer which uses code put in by 
; // compiler in lower code space
; 
; #ifdef SENSOR
; 		if (!(page % 4)) LED1 = ~LED1;;
			; SOURCE LINE # 76
	MOV  	A,page?048+01H
	ANL  	A,#03H
	JNZ  	?C0009
	CPL  	LED1
?C0009:
; #endif
; 
; 		// wait for Serial Flash to be available
; 		do {
			; SOURCE LINE # 80
; 			status = FDL_DataFlash_Read_Status();
			; SOURCE LINE # 81
	LCALL	FDL_DataFlash_Read_Status
	MOV  	status?049,R7
; 		} while (!(status & STATUS_READY_MASK));
			; SOURCE LINE # 82
	MOV  	A,status?049
	JNB  	ACC.7,?C0009
; 
; 		// set CS to low
; 		DF_CS1 = 0;
			; SOURCE LINE # 85
	CLR  	DF_CS1
; 		DFWAITFDL;
			; SOURCE LINE # 86
	CLR  	A
	MOV  	q?041,A
	MOV  	q?041+01H,A
?C0013:
	INC  	q?041+01H
	MOV  	A,q?041+01H
	JNZ  	?C0055
	INC  	q?041
?C0055:
	XRL  	A,#0C8H
	ORL  	A,q?041
	JNZ  	?C0013
?C0011:
; 
; 		// shift out command
; 		FDL_xferSPI(MEMORY_PAGE_READ);
			; SOURCE LINE # 89
	MOV  	R7,#0D2H
	LCALL	_FDL_xferSPI
; 	
; 		// shift out reserved bits and upper bits of page address
; 		FDL_xferSPI(page >> 6);	
			; SOURCE LINE # 92
	MOV  	A,page?048+01H
	MOV  	R6,page?048
	MOV  	R0,#06H
?C0056:
	XCH  	A,R6
	CLR  	C
	RRC  	A
	XCH  	A,R6
	RRC  	A
	DJNZ 	R0,?C0056
	MOV  	R7,A
	LCALL	_FDL_xferSPI
; 
; 		// shift out bottom 6 bits of page address and top bits of byte address
; 		FDL_xferSPI((u08) page << 2);
			; SOURCE LINE # 95
	LCALL	L?0065
; 
; 		// shift out bottom 8 bits of unsigned char address
; 		FDL_xferSPI(0);
			; SOURCE LINE # 98
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
; 
; 		// shift out 4 bytes of don't cares
; 		FDL_xferSPI(0);	FDL_xferSPI(0);	FDL_xferSPI(0);	FDL_xferSPI(0);
			; SOURCE LINE # 101
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
; 
; 		// shift in the data
; 		for (i=0; i < CODE_DOWNLOAD_SIZE; i++)
			; SOURCE LINE # 104
	CLR  	A
	MOV  	i?047,A
	MOV  	i?047+01H,A
?C0016:
; 			flashpage.bigbuff[i] =  FDL_xferSPI(0);
			; SOURCE LINE # 105
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	MOV  	A,#LOW (flashpage)
	ADD  	A,i?047+01H
	MOV  	DPL,A
	MOV  	A,#HIGH (flashpage)
	ADDC 	A,i?047
	MOV  	DPH,A
	MOV  	A,R7
	MOVX 	@DPTR,A
	INC  	i?047+01H
	MOV  	A,i?047+01H
	JNZ  	?C0057
	INC  	i?047
?C0057:
	CLR  	C
	MOV  	A,i?047
	SUBB 	A,#02H
	JC   	?C0016
?C0017:
; 
; 		// raise CS to end operation
; 		DF_CS1 = 1;
			; SOURCE LINE # 108
	SETB 	DF_CS1
; 
; // end of inline function
; 
; 		SFRPAGE = LEGACY_PAGE;
			; SOURCE LINE # 112
	CLR  	A
	MOV  	SFRPAGE,A
; 		PSCTL = 0x01;						// movx writes to codeflash
			; SOURCE LINE # 113
	MOV  	PSCTL,#01H
; 
; // XXXXXXXXXXXXXXXXXX
; 		// copy dataflash page into micro flash
; 		for (i=0; i < CODE_DOWNLOAD_SIZE; i++) {
			; SOURCE LINE # 117
	MOV  	i?047,A
	MOV  	i?047+01H,A
?C0019:
; 			unsigned char temp;
; 
; 			temp = flashpage.bigbuff[i];
			; SOURCE LINE # 120
	MOV  	A,#LOW (flashpage)
	ADD  	A,i?047+01H
	MOV  	DPL,A
	MOV  	A,#HIGH (flashpage)
	ADDC 	A,i?047
	MOV  	DPH,A
	MOVX 	A,@DPTR
	MOV  	temp?042,A
; //			*pwrite = temp;
; // this assembler code must be here to force compiler to use the MOVX instruction to cause flash rewrite
; #pragma ASM
; //			MOV  	A,temp?042				// put code byte into accum	
	  
; 			MOV  	DPL,pwrite?045+02H		// load data pointer with address in code flash
	  MOV  	DPL,pwrite?045+02H		 
; 			MOV  	DPH,pwrite?045+01H	
	  MOV  	DPH,pwrite?045+01H	
; 			MOVX 	@DPTR,A					// MOVX causes code flash page to be programmed
	  MOVX 	@DPTR,A					 
; #pragma ENDASM
; 
; 			pwrite++;
			; SOURCE LINE # 130
	MOV  	A,#01H
	ADD  	A,pwrite?045+02H
	MOV  	pwrite?045+02H,A
	CLR  	A
	ADDC 	A,pwrite?045+01H
	MOV  	pwrite?045+01H,A
; 		} // for
			; SOURCE LINE # 131
	INC  	i?047+01H
	MOV  	A,i?047+01H
	JNZ  	?C0058
	INC  	i?047
?C0058:
	CJNE 	A,#00H,?C0019
	MOV  	A,i?047
	CJNE 	A,#02H,?C0019
?C0020:
; 		
; 		PSCTL = 0x00;
			; SOURCE LINE # 133
	CLR  	A
	MOV  	PSCTL,A
; 	} // for
			; SOURCE LINE # 134
	INC  	page?048+01H
	MOV  	A,page?048+01H
	JNZ  	?C0060
	INC  	page?048
?C0060:
	CLR  	C
	SUBB 	A,#07FH
	MOV  	A,page?048
	SUBB 	A,#00H
	JNC  	$ + 5H
	LJMP 	?C0003
?C0004:
; 
; 	PSCTL = 0;							// movx writes target ram
			; SOURCE LINE # 136
	CLR  	A
	MOV  	PSCTL,A
; 
; 	FLSCL &= ~0x01;						// disable flash writes from user sw
			; SOURCE LINE # 138
	ANL  	FLSCL,#0FEH
; 	EA = EA_save;
			; SOURCE LINE # 139
	MOV  	A,EA_save?046
	ADD  	A,#0FFH
	MOV  	EA,C
; 	PSW = 0;
			; SOURCE LINE # 140
	CLR  	A
	MOV  	PSW,A
; 
; 	SFRPAGE = CONFIG_PAGE;
			; SOURCE LINE # 142
	MOV  	SFRPAGE,#0FH
; 
; 	// clear the flash - NOTE: cannot use global variables. Must choose max erase pages.
; 	for (page = 0; page < MAX_NUM_PAGES; page += 8) {
			; SOURCE LINE # 145
	MOV  	page?048,A
	MOV  	page?048+01H,A
?C0022:
	CLR  	C
	MOV  	A,page?048
	SUBB 	A,#020H
	JNC  	?C0037
; 
; #ifdef SENSOR
; 		// invert LED every so often
; 		if (!(page % 64)) LED2 = ~LED2;
			; SOURCE LINE # 149
	MOV  	A,page?048+01H
	ANL  	A,#03FH
	JNZ  	?C0028
	CPL  	LED2
?C0028:
; #endif
; 
; 		// inline dataflash erase block
; 
; 		// wait for Serial Flash to be available
; 		do {
			; SOURCE LINE # 155
; 			status = FDL_DataFlash_Read_Status();
			; SOURCE LINE # 156
	LCALL	FDL_DataFlash_Read_Status
	MOV  	status?049,R7
; 		} while (!(status & STATUS_READY_MASK));
			; SOURCE LINE # 157
	MOV  	A,status?049
	JNB  	ACC.7,?C0028
; 
; 		DF_CS1 = 0;
			; SOURCE LINE # 159
	CLR  	DF_CS1
; 		DFWAITFDL;
			; SOURCE LINE # 160
	CLR  	A
	MOV  	q?043,A
	MOV  	q?043+01H,A
?C0032:
	INC  	q?043+01H
	MOV  	A,q?043+01H
	JNZ  	?C0061
	INC  	q?043
?C0061:
	XRL  	A,#0C8H
	ORL  	A,q?043
	JNZ  	?C0032
?C0030:
; 
; 		//command
; 		FDL_xferSPI(BLOCK_ERASE);
			; SOURCE LINE # 163
	MOV  	R7,#050H
	LCALL	_FDL_xferSPI
; 
; 		// shift out reserved bits and upper bits of page address
; 		FDL_xferSPI(page >> 6);
			; SOURCE LINE # 166
	MOV  	A,page?048+01H
	MOV  	R6,page?048
	MOV  	R0,#06H
?C0062:
	XCH  	A,R6
	CLR  	C
	RRC  	A
	XCH  	A,R6
	RRC  	A
	DJNZ 	R0,?C0062
	MOV  	R7,A
	LCALL	_FDL_xferSPI
; 
; 		// shift out bottom 6 bits of page address and top bits of byte address
; 		FDL_xferSPI((u08) page << 2);
			; SOURCE LINE # 169
	LCALL	L?0065
; 
; 		// shift out bottom 8 bits of unsigned char address
; 		FDL_xferSPI(0);
			; SOURCE LINE # 172
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
; 
; 		DF_CS1 = 1;
			; SOURCE LINE # 174
	SETB 	DF_CS1
; 
; 		// end of inline function
; 	} // for
			; SOURCE LINE # 177
	MOV  	A,#08H
	ADD  	A,page?048+01H
	MOV  	page?048+01H,A
	CLR  	A
	ADDC 	A,page?048
	MOV  	page?048,A
	SJMP 	?C0022
?C0037:
; 
; 	DFWAITFDL;
			; SOURCE LINE # 179
	CLR  	A
	MOV  	q?044,A
	MOV  	q?044+01H,A
?C0038:
	INC  	q?044+01H
	MOV  	A,q?044+01H
	JNZ  	?C0063
	INC  	q?044
?C0063:
	XRL  	A,#0C8H
	ORL  	A,q?044
	JNZ  	?C0038
?C0043:
; 	
; 	// wait for Serial Flash to be finished
; 	do {
			; SOURCE LINE # 182
; 		status = FDL_DataFlash_Read_Status();
			; SOURCE LINE # 183
	LCALL	FDL_DataFlash_Read_Status
	MOV  	status?049,R7
; 	} while (!(status & STATUS_READY_MASK));
			; SOURCE LINE # 184
	MOV  	A,status?049
	JNB  	ACC.7,?C0043
; 
; 	SFRPAGE = LEGACY_PAGE;
			; SOURCE LINE # 186
	CLR  	A
	MOV  	SFRPAGE,A
; 
; 	// pull the reset line to restart everything
; 	RSTSRC = RSTSRC | 0x01;
			; SOURCE LINE # 189
	ORL  	RSTSRC,#01H
; }
			; SOURCE LINE # 190
	RET  	
; END OF _CopytoCodeSpace

; 
; // simultaneously write	and read one unsigned char to SPI (mode 3). Blocking.
; u08 FDL_xferSPI (u08 ch) {

	RSEG  ?PR?_FDL_xferSPI?FDL
L?0065:
	USING	0
	MOV  	R7,page?048+01H
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	MOV  	R7,A
_FDL_xferSPI:
	USING	0
			; SOURCE LINE # 193
;---- Variable 'ch?150' assigned to Register 'R7' ----
; 
; 	u08 SFRPAGE_SAVE = SFRPAGE;			// Save Current SFR page
			; SOURCE LINE # 195
;---- Variable 'SFRPAGE_SAVE?151' assigned to Register 'R6' ----
	MOV  	R6,SFRPAGE
; 	SFRPAGE = SPI0_PAGE;
			; SOURCE LINE # 196
	CLR  	A
	MOV  	SFRPAGE,A
; 
; 	SPI0DAT = ch;
			; SOURCE LINE # 198
	MOV  	SPI0DAT,R7
?C0045:
; 
; 	// wait for shifting
; 	while (!SPIF) ;
			; SOURCE LINE # 201
	JNB  	SPIF,?C0045
?C0046:
; 
; 	SPIF = 0;			// clear the xfer complete flag
			; SOURCE LINE # 203
	CLR  	SPIF
; 
; 	ch = SPI0DAT;
			; SOURCE LINE # 205
	MOV  	R7,SPI0DAT
; 	
; 	SFRPAGE = SFRPAGE_SAVE;
			; SOURCE LINE # 207
	MOV  	SFRPAGE,R6
; 
; 	return (ch);
			; SOURCE LINE # 209
; }
			; SOURCE LINE # 210
?C0047:
	RET  	
; END OF _FDL_xferSPI

; 
; // returns the value of DataFlash Status Register. Non-blocking.
; u08 FDL_DataFlash_Read_Status(void) {

	RSEG  ?PR?FDL_DataFlash_Read_Status?FDL
FDL_DataFlash_Read_Status:
	USING	0
			; SOURCE LINE # 213
;    u08 dat;
; 
; 	DF_CS1 = 0;
			; SOURCE LINE # 216
	CLR  	DF_CS1
; 	DFWAITFDL;
			; SOURCE LINE # 217
	CLR  	A
	MOV  	q?252,A
	MOV  	q?252+01H,A
?C0051:
	INC  	q?252+01H
	MOV  	A,q?252+01H
	JNZ  	?C0064
	INC  	q?252
?C0064:
	XRL  	A,#0C8H
	ORL  	A,q?252
	JNZ  	?C0051
?C0049:
; 
; 	//command
; 	FDL_xferSPI(STATUS_REGISTER_READ);
			; SOURCE LINE # 220
	MOV  	R7,#0D7H
	LCALL	_FDL_xferSPI
; 
; 	dat = FDL_xferSPI(0);
			; SOURCE LINE # 222
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
;---- Variable 'dat?253' assigned to Register 'R7' ----
; 
; 	DF_CS1 = 1;
			; SOURCE LINE # 224
	SETB 	DF_CS1
;   
;    return (dat);
			; SOURCE LINE # 226
; }
			; SOURCE LINE # 227
?C0054:
	RET  	
; END OF FDL_DataFlash_Read_Status

	END
