; ..\CommonFiles\fdl.SRC generated from: ..\CommonFiles\fdl.c
; COMPILER INVOKED BY:
;        C:\Keil\C51\BIN\C51.EXE ..\CommonFiles\fdl.c OPTIMIZE(SIZE) BROWSE INCDIR(C:\Keil\C51\INC\;C:\Keil\Traqmate\132micro\CommonFiles\;C:\Keil\Traqmate\132micro\SU\) DB OE SRC DEFINE(SENSOR,EXTCLK6,NODEBUG) DEBUG OBJECTEXTEND PRINT(.\fdl.lst) OBJECT(.\fdl.obj)

$NOMOD51

NAME	FDL

CCF2	BIT	0D8H.2
TB80	BIT	098H.3
SPI0CKR	DATA	09DH
CCF3	BIT	0D8H.3
TB81	BIT	098H.3
P0	DATA	080H
SPIEN	BIT	0F8H.0
CCF4	BIT	0D8H.4
SM00	BIT	098H.7
P1	DATA	090H
PLL0FLT	DATA	08FH
CCF5	BIT	0D8H.5
AA	BIT	0C0H.2
SM10	BIT	098H.6
WDTCN	DATA	0FFH
P2	DATA	0A0H
SM20	BIT	098H.5
ADC0CF	DATA	0BCH
P3	DATA	0B0H
AC	BIT	0D0H.6
P4	DATA	0C8H
PCA0	DATA	0F9H
EIE1	DATA	0E6H
P5	DATA	0D8H
ADC2CF	DATA	0BCH
EA	BIT	0A8H.7
P6	DATA	0E8H
EIE2	DATA	0E7H
MCE1	BIT	098H.5
P7	DATA	0F8H
PSCTL	DATA	08FH
CF	BIT	0D8H.7
PLL0MUL	DATA	08EH
ADC0CN	DATA	0E8H
DAC0CN	DATA	0D4H
SFRPAGE	DATA	084H
DAC1CN	DATA	0D4H
MAC0CF	DATA	0C3H
MAC0AH	DATA	0C2H
P0MDOUT	DATA	0A4H
ADC2CN	DATA	0E8H
P1MDOUT	DATA	0A5H
MAC0BH	DATA	092H
IE	DATA	0A8H
P2MDOUT	DATA	0A6H
CCH0MA	DATA	09AH
P3MDOUT	DATA	0A7H
CCH0LC	DATA	0A3H
EIP1	DATA	0F6H
MAC0AL	DATA	0C1H
P4MDOUT	DATA	09CH
TXBMT	BIT	0F8H.1
EIP2	DATA	0F7H
CCH0CN	DATA	0A1H
P5MDOUT	DATA	09DH
MAC0BL	DATA	091H
PCA0CPH0	DATA	0FCH
P6MDOUT	DATA	09EH
PCA0CPH1	DATA	0FEH
P7MDOUT	DATA	09FH
DP	DATA	082H
PCA0CPH2	DATA	0EAH
ADC0GT	DATA	0C4H
CR	BIT	0D8H.6
PCA0CPH3	DATA	0ECH
EXF2	BIT	0C8H.6
REN0	BIT	098H.4
PCA0CPL0	DATA	0FBH
PCA0CPH4	DATA	0EEH
EMI0CF	DATA	0A3H
SFRPGCN	DATA	096H
EXF3	BIT	0C8H.6
REN1	BIT	098H.4
PCA0CPL1	DATA	0FDH
PCA0CPH5	DATA	0E2H
PCA0CPM0	DATA	0DAH
PCA0MD	DATA	0D9H
PCA0CN	DATA	0D8H
ADC2GT	DATA	0C4H
EXF4	BIT	0C8H.6
PCA0CPL2	DATA	0E9H
PCA0CPM1	DATA	0DBH
PCA0CPL3	DATA	0EBH
PCA0CPM2	DATA	0DCH
IP	DATA	0B8H
ADC0LT	DATA	0C6H
MAC0HO	BIT	0C0H.3
CP0FIF	BIT	088H.4
PCA0CPL4	DATA	0EDH
PCA0CPM3	DATA	0DDH
CP1FIF	BIT	088H.4
PCA0CPL5	DATA	0E1H
PCA0CPM4	DATA	0DEH
CY	BIT	0D0H.7
SI	BIT	0C0H.3
PCA0CPM5	DATA	0DFH
ADC2LT	DATA	0C6H
XBR0	DATA	0E1H
SADEN0	DATA	0B9H
XBR1	DATA	0E2H
EMI0CN	DATA	0A2H
XBR2	DATA	0E3H
FLHBUSY	BIT	088H.0
REF0CN	DATA	0D1H
SADDR0	DATA	0A9H
AMX0CF	DATA	0BAH
AD0INT	BIT	0E8H.5
RCAP2H	DATA	0CBH
CCH0TN	DATA	0A2H
SFRLAST	DATA	086H
PS	BIT	0B8H.4
RCAP3H	DATA	0CBH
AMX2CF	DATA	0BAH
SP	DATA	081H
AD2INT	BIT	0E8H.5
RCAP4H	DATA	0CBH
EMI0TC	DATA	0A1H
OV	BIT	0D0H.2
MAC0SO	BIT	0C0H.1
SMB0CN	DATA	0C0H
TMR2	DATA	0CCH
CP0RIF	BIT	088H.5
RCAP2L	DATA	0CAH
TMR3	DATA	0CCH
MODF	BIT	0F8H.5
CP1RIF	BIT	088H.5
RCAP3L	DATA	0CAH
TMR4	DATA	0CCH
RCAP4L	DATA	0CAH
SMB0CR	DATA	0CFH
CPT0MD	DATA	089H
CPT0CN	DATA	088H
S1MODE	BIT	098H.7
P1MDIN	DATA	0ADH
PLL0CN	DATA	089H
CPT1MD	DATA	089H
CPT1CN	DATA	088H
SFRNEXT	DATA	085H
SPI0CN	DATA	0F8H
MAC0RNDH	DATA	0CFH
TMR2CF	DATA	0C9H
TMR3CF	DATA	0C9H
PCON	DATA	087H
TMR4CF	DATA	0C9H
SPIF	BIT	0F8H.7
MAC0RNDL	DATA	0CEH
TMOD	DATA	089H
TCON	DATA	088H
WCOL	BIT	0F8H.6
NSSMD0	BIT	0F8H.2
AMX0SL	DATA	0BBH
NSSMD1	BIT	0F8H.3
TMR2CN	DATA	0C8H
TMR3CN	DATA	0C8H
AMX2SL	DATA	0BBH
TMR4CN	DATA	0C8H
CP0OUT	BIT	088H.6
CP1OUT	BIT	088H.6
IE0	BIT	088H.1
IE1	BIT	088H.3
OSCICL	DATA	08BH
CLKSEL	DATA	097H
B	DATA	0F0H
DAC0H	DATA	0D3H
ADC0H	DATA	0BFH
PSBANK	DATA	0B1H
OSCICN	DATA	08AH
DAC1H	DATA	0D3H
SMBFTE	BIT	0C0H.1
BUSY	BIT	0C0H.7
DAC0L	DATA	0D2H
ADC0L	DATA	0BEH
DAC1L	DATA	0D2H
ACC	DATA	0E0H
ES0	BIT	0A8H.4
PCA0CP0	DATA	0FBH
AD0EN	BIT	0E8H.7
CT2	BIT	0C8H.1
ET0	BIT	0A8H.1
PCA0CP1	DATA	0FDH
CT3	BIT	0C8H.1
ET1	BIT	0A8H.3
TF0	BIT	088H.5
PCA0CP2	DATA	0E9H
AD2EN	BIT	0E8H.7
CT4	BIT	0C8H.1
ET2	BIT	0A8H.5
RI0	BIT	098H.0
TF1	BIT	088H.7
PCA0CP3	DATA	0EBH
TF2	BIT	0C8H.7
SMBTOE	BIT	0C0H.0
RI1	BIT	098H.0
TH0	DATA	08CH
PCA0CP4	DATA	0EDH
TF3	BIT	0C8H.7
EX0	BIT	0A8H.0
TI0	BIT	098H.1
IT0	BIT	088H.0
PCA0H	DATA	0FAH
TH1	DATA	08DH
PCA0CP5	DATA	0E1H
TF4	BIT	0C8H.7
EX1	BIT	0A8H.2
TI1	BIT	098H.1
IT1	BIT	088H.2
P	BIT	0D0H.0
MAC0N	BIT	0C0H.0
OSCXCN	DATA	08CH
TL0	DATA	08AH
FLSTAT	DATA	088H
PCA0L	DATA	0F9H
TL1	DATA	08BH
PT0	BIT	0B8H.1
RS0	BIT	0D0H.3
PT1	BIT	0B8H.3
RS1	BIT	0D0H.4
PT2	BIT	0B8H.5
TR0	BIT	088H.4
AD0TM	BIT	0E8H.6
CP0EN	BIT	088H.7
TR1	BIT	088H.6
TR2	BIT	0C8H.2
PX0	BIT	0B8H.0
CP1EN	BIT	088H.7
RCAP2	DATA	0CAH
AD2TM	BIT	0E8H.6
TR3	BIT	0C8H.2
PX1	BIT	0B8H.2
RCAP3	DATA	0CAH
TR4	BIT	0C8H.2
RCAP4	DATA	0CAH
MAC0Z	BIT	0C0H.2
DPH	DATA	083H
ADC0GTH	DATA	0C5H
DPL	DATA	082H
ADC0GTL	DATA	0C4H
SBUF0	DATA	099H
ADC0LTH	DATA	0C7H
SBUF1	DATA	099H
EXEN2	BIT	0C8H.3
RSTSRC	DATA	0EFH
FLACL	DATA	0B7H
EXEN3	BIT	0C8H.3
CPRL2	BIT	0C8H.0
CP0HYN0	BIT	088H.0
SCON0	DATA	098H
EXEN4	BIT	0C8H.3
CPRL3	BIT	0C8H.0
CP1HYN0	BIT	088H.0
CP0HYN1	BIT	088H.1
SCON1	DATA	098H
CPRL4	BIT	0C8H.0
CP1HYN1	BIT	088H.1
CP0HYP0	BIT	088H.2
ADC0LTL	DATA	0C6H
CP1HYP0	BIT	088H.2
CP0HYP1	BIT	088H.3
STA	BIT	0C0H.5
CP1HYP1	BIT	088H.3
SMB0ADR	DATA	0C3H
MAC0STA	DATA	0C0H
SSTA0	DATA	091H
SMB0DAT	DATA	0C2H
TMR2H	DATA	0CDH
SPI0CFG	DATA	09AH
TMR3H	DATA	0CDH
CKCON	DATA	08EH
TMR4H	DATA	0CDH
RXOVRN	BIT	0F8H.4
TMR2L	DATA	0CCH
TMR3L	DATA	0CCH
AD0LJST	BIT	0E8H.0
TMR4L	DATA	0CCH
F0	BIT	0D0H.5
FLSCL	DATA	0B7H
AD0CM0	BIT	0E8H.2
F1	BIT	0D0H.1
STO	BIT	0C0H.4
ENSMB	BIT	0C0H.6
AD0CM1	BIT	0E8H.3
SPI0DAT	DATA	09BH
DAC0	DATA	0D2H
ADC0	DATA	0BEH
AD2CM0	BIT	0E8H.1
DAC1	DATA	0D2H
AD2CM1	BIT	0E8H.2
AD0WINT	BIT	0E8H.1
AD2CM2	BIT	0E8H.3
AD0BUSY	BIT	0E8H.4
PSW	DATA	0D0H
ADC2	DATA	0BEH
MAC0OVR	DATA	097H
MAC0ACC0	DATA	093H
AD2WINT	BIT	0E8H.0
MAC0ACC1	DATA	094H
AD2BUSY	BIT	0E8H.4
CCF0	BIT	0D8H.0
RB80	BIT	098H.2
SMB0STA	DATA	0C1H
MAC0ACC2	DATA	095H
CCF1	BIT	0D8H.1
RB81	BIT	098H.2
MAC0ACC3	DATA	096H
PLL0DIV	DATA	08DH
?PR?_CopytoCodeSpace?FDL                 SEGMENT CODE 
?DT?_CopytoCodeSpace?FDL                 SEGMENT DATA OVERLAYABLE 
?PR?_FDL_xferSPI?FDL SEGMENT CODE 
?PR?FDL_DataFlash_Read_Status?FDL        SEGMENT CODE 
?DT?FDL_DataFlash_Read_Status?FDL        SEGMENT DATA OVERLAYABLE 
	EXTRN	XDATA (flashpage)
	EXTRN	XDATA (numpages)
	PUBLIC	FDL_DataFlash_Read_Status
	PUBLIC	_FDL_xferSPI
	PUBLIC	_CopytoCodeSpace

	RSEG  ?DT?_CopytoCodeSpace?FDL
?_CopytoCodeSpace?BYTE:
   lastpage?040:   DS   2
	ORG  10
          q?041:   DS   2
	ORG  10
          q?042:   DS   2
	ORG  2
     pwrite?043:   DS   2
	ORG  4
    EA_save?044:   DS   1
	ORG  5
          i?045:   DS   2
	ORG  7
       page?046:   DS   2
	ORG  9
     status?047:   DS   1

	RSEG  ?DT?FDL_DataFlash_Read_Status?FDL
?FDL_DataFlash_Read_Status?BYTE:
          q?250:   DS   2
; // software downloader
; //
; // this must be less than 510 bytes when compiled which is very tight. It must
; // not extend into address 0xFFFE or 0xFFFF, the micro flash lock bytes
; // it is loaded at 0xFE00 and must be self-contained so the code copy will
; // not overwrite it.
; //
; // initial implementation John Paulos, 04/26/2005
; // re-written Glenn Stephens, 05/02/2005
; //
; 
; #include <tmtypes.h>
; #ifdef DISPLAY
; #include <display.h>
; #else
; #include <sensor.h>
; #endif
; 
; //#define DFWAITREAD do {int q; for (q=0; q<64; q++) ; } while(0)  // 64 seems to work well. should be verified.
; //#define DFWAITWRITE do {int q; for (q=0; q<64; q++) ; } while(0)  // longer for erase.
; #define DFWAIT do {int q; for (q=0; q<64; q++) ; } while(0)  // longer for erase.
; 
; #pragma ASM
  	CSEG	AT	0FE00h
  	JMP	$	// endless loop to protect against accidental code erase
; #pragma ENDASM
; 
; u08 FDL_xferSPI (u08);
; u08 FDL_DataFlash_Read_Status(void);
; 
; void CopytoCodeSpace(u16 lastpage) {

	RSEG  ?PR?_CopytoCodeSpace?FDL
_CopytoCodeSpace:
	USING	0
			; SOURCE LINE # 31
	MOV  	lastpage?040,R6
	MOV  	lastpage?040+01H,R7
; 	char xdata* data pwrite;
; 	char EA_save;
; 	u16 i, page;
; 	u08 status;
; 
; 	pwrite = 0x0;						// initialize code pointer
			; SOURCE LINE # 37
	CLR  	A
	MOV  	pwrite?043,A
	MOV  	pwrite?043+01H,A
; 
; 	EA_save = EA;						// save interrupt status
			; SOURCE LINE # 39
	MOV  	C,EA
	RLC  	A
	MOV  	EA_save?044,A
; 	EA = 0;								// disable interrupts
			; SOURCE LINE # 40
	CLR  	EA
; 
; 	SFRPAGE = LEGACY_PAGE;
			; SOURCE LINE # 42
	CLR  	A
	MOV  	SFRPAGE,A
; 	FLSCL |= 0x01;						// enable flash writes/erases from user software
			; SOURCE LINE # 43
	ORL  	FLSCL,#01H
; 
; 	PSCTL = 0x03;						// movx writes erase flash page
			; SOURCE LINE # 45
	MOV  	PSCTL,#03H
?C0001:
; 	while (pwrite < LAST_CODE_PAGE) {	//erase code space
			; SOURCE LINE # 46
	CLR  	C
	MOV  	A,pwrite?043
	SUBB 	A,#0FCH
	JNC  	?C0002
; 		*pwrite = 0x88;					// initiate page erase
			; SOURCE LINE # 47
	MOV  	DPL,pwrite?043+01H
	MOV  	DPH,pwrite?043
	MOV  	A,#088H
	MOVX 	@DPTR,A
; 		pwrite += CODE_PAGE_SIZE;		// point to next page
			; SOURCE LINE # 48
	CLR  	A
	ADD  	A,pwrite?043+01H
	MOV  	pwrite?043+01H,A
	MOV  	A,#04H
	ADDC 	A,pwrite?043
	MOV  	pwrite?043,A
; 	}
			; SOURCE LINE # 49
	SJMP 	?C0001
?C0002:
; 
; 	PSCTL = 0x00;						// movx writes to target ram
			; SOURCE LINE # 51
	CLR  	A
	MOV  	PSCTL,A
; 	pwrite = 0x00;						// reset code pointer
			; SOURCE LINE # 52
	MOV  	pwrite?043,A
	MOV  	pwrite?043+01H,A
; 
; 	for (page=0; page < MIN(lastpage, (BOOTSTRAP_ADDR/CODE_DOWNLOAD_SIZE)); page++) {
			; SOURCE LINE # 54
	MOV  	page?046,A
	MOV  	page?046+01H,A
?C0003:
	CLR  	C
	MOV  	A,lastpage?040+01H
	SUBB 	A,#07FH
	MOV  	A,lastpage?040
	SUBB 	A,#00H
	JNC  	?C0006
	MOV  	R6,lastpage?040
	MOV  	R7,lastpage?040+01H
	SJMP 	?C0007
?C0006:
	MOV  	R6,#00H
	MOV  	R7,#07FH
?C0007:
	CLR  	C
	MOV  	A,page?046+01H
	SUBB 	A,R7
	MOV  	A,page?046
	SUBB 	A,R6
	JC   	$ + 5H
	LJMP 	?C0004
; 
; 		SFRPAGE = CONFIG_PAGE;
			; SOURCE LINE # 56
	MOV  	SFRPAGE,#0FH
; 
; //			FDL_DataFlash_Page_Read(MAX_PAGE_SIZE, flashpage.bigbuff, read_page);
; // function is put in line here to avoid passing pointer which uses code put in by 
; // compiler in lower code space
; 
; #ifdef SENSOR
; 		if (!(page % 4)) XOR(LED1);
			; SOURCE LINE # 63
	MOV  	A,page?046+01H
	ANL  	A,#03H
	JNZ  	?C0011
	XRL  	P3,#040H
?C0011:
; #endif
; 
; 		// wait for Serial Flash to be available
; 		do {
			; SOURCE LINE # 67
; 			status = FDL_DataFlash_Read_Status();
			; SOURCE LINE # 68
	LCALL	FDL_DataFlash_Read_Status
	MOV  	status?047,R7
; 		} while (!(status & STATUS_READY_MASK));
			; SOURCE LINE # 69
	MOV  	A,status?047
	JNB  	ACC.7,?C0011
; 
; 		// set CS to low
; 		LO(DF_CS1);
			; SOURCE LINE # 72
	ANL  	P7,#0FDH
; 		DFWAIT;
			; SOURCE LINE # 73
	CLR  	A
	MOV  	q?041,A
	MOV  	q?041+01H,A
?C0015:
	INC  	q?041+01H
	MOV  	A,q?041+01H
	JNZ  	?C0051
	INC  	q?041
?C0051:
	XRL  	A,#040H
	ORL  	A,q?041
	JNZ  	?C0015
?C0013:
; 
; 		// shift out command
; 		FDL_xferSPI(MEMORY_PAGE_READ);
			; SOURCE LINE # 76
	MOV  	R7,#0D2H
	LCALL	_FDL_xferSPI
; 	
; 		// shift out reserved bits and upper bits of page address
; 		FDL_xferSPI(page >> 6);	
			; SOURCE LINE # 79
	MOV  	A,page?046+01H
	MOV  	R6,page?046
	MOV  	R0,#06H
?C0052:
	XCH  	A,R6
	CLR  	C
	RRC  	A
	XCH  	A,R6
	RRC  	A
	DJNZ 	R0,?C0052
	MOV  	R7,A
	LCALL	_FDL_xferSPI
; 
; 		// shift out bottom 6 bits of page address and top bits of byte address
; 		FDL_xferSPI((u08) page << 2);
			; SOURCE LINE # 82
	LCALL	L?0061
; 
; 		// shift out bottom 8 bits of unsigned char address
; 		FDL_xferSPI(0);
			; SOURCE LINE # 85
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
; 
; 		// shift out 4 bytes of don't cares
; 		FDL_xferSPI(0);	FDL_xferSPI(0);	FDL_xferSPI(0);	FDL_xferSPI(0);
			; SOURCE LINE # 88
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
; 
; 		// shift in the data
; 		for (i=0; i < CODE_DOWNLOAD_SIZE; i++)
			; SOURCE LINE # 91
	CLR  	A
	MOV  	i?045,A
	MOV  	i?045+01H,A
?C0018:
; 			flashpage.bigbuff[i] =  FDL_xferSPI(0);
			; SOURCE LINE # 92
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
	MOV  	A,#LOW (flashpage)
	ADD  	A,i?045+01H
	MOV  	DPL,A
	MOV  	A,#HIGH (flashpage)
	ADDC 	A,i?045
	MOV  	DPH,A
	MOV  	A,R7
	MOVX 	@DPTR,A
	INC  	i?045+01H
	MOV  	A,i?045+01H
	JNZ  	?C0053
	INC  	i?045
?C0053:
	CLR  	C
	MOV  	A,i?045
	SUBB 	A,#02H
	JC   	?C0018
?C0019:
; 
; 		// raise CS to end operation
; 		HI(DF_CS1);
			; SOURCE LINE # 95
	ORL  	P7,#02H
; 
; // end of inline function
; 
; 		SFRPAGE = LEGACY_PAGE;
			; SOURCE LINE # 99
	CLR  	A
	MOV  	SFRPAGE,A
; 		PSCTL = 0x01;						// movx writes to codeflash
			; SOURCE LINE # 100
	MOV  	PSCTL,#01H
; 
; 		// copy dataflash page into micro flash
; 		for (i=0; i < CODE_DOWNLOAD_SIZE; i++)
			; SOURCE LINE # 103
	MOV  	i?045,A
	MOV  	i?045+01H,A
?C0021:
; 			*pwrite++ = flashpage.bigbuff[i];
			; SOURCE LINE # 104
	MOV  	A,#LOW (flashpage)
	ADD  	A,i?045+01H
	MOV  	DPL,A
	MOV  	A,#HIGH (flashpage)
	ADDC 	A,i?045
	MOV  	DPH,A
	MOVX 	A,@DPTR
	MOV  	R7,A
	INC  	pwrite?043+01H
	MOV  	A,pwrite?043+01H
	MOV  	R4,pwrite?043
	JNZ  	?C0054
	INC  	pwrite?043
?C0054:
	DEC  	A
	MOV  	DPL,A
	MOV  	DPH,R4
	MOV  	A,R7
	MOVX 	@DPTR,A
	INC  	i?045+01H
	MOV  	A,i?045+01H
	JNZ  	?C0055
	INC  	i?045
?C0055:
	CJNE 	A,#00H,?C0021
	MOV  	A,i?045
	CJNE 	A,#02H,?C0021
?C0022:
; 
; 		PSCTL = 0x00;
			; SOURCE LINE # 106
	CLR  	A
	MOV  	PSCTL,A
; 	} // for
			; SOURCE LINE # 107
	INC  	page?046+01H
	MOV  	A,page?046+01H
	JNZ  	?C0057
	INC  	page?046
?C0057:
	LJMP 	?C0003
?C0004:
; 
; 	PSCTL = 0;							// movx writes target ram
			; SOURCE LINE # 109
	CLR  	A
	MOV  	PSCTL,A
; 
; 	FLSCL &= ~0x01;						// disable flash writes from user sw
			; SOURCE LINE # 111
	ANL  	FLSCL,#0FEH
; 	EA = EA_save;
			; SOURCE LINE # 112
	MOV  	A,EA_save?044
	ADD  	A,#0FFH
	MOV  	EA,C
; 	PSW = 0;
			; SOURCE LINE # 113
	CLR  	A
	MOV  	PSW,A
; 
; 	SFRPAGE = CONFIG_PAGE;
			; SOURCE LINE # 115
	MOV  	SFRPAGE,#0FH
; 
; 	// clear the flash
; 	for (page = 0; page < numpages; page += 8) {
			; SOURCE LINE # 118
	MOV  	page?046,A
	MOV  	page?046+01H,A
?C0024:
	SETB 	C
	MOV  	DPTR,#numpages+01H
	MOVX 	A,@DPTR
	SUBB 	A,page?046+01H
	MOV  	DPTR,#numpages
	MOVX 	A,@DPTR
	SUBB 	A,page?046
	JC   	?C0039
; 
; #ifdef SENSOR
; 		// invert LED every so often
; 		if (!(page % 64)) XOR(LED2);
			; SOURCE LINE # 122
	MOV  	A,page?046+01H
	ANL  	A,#03FH
	JNZ  	?C0030
	XRL  	P3,#020H
?C0030:
; #endif
; 
; 		// inline dataflash erase block
; 
; 		// wait for Serial Flash to be available
; 		do {
			; SOURCE LINE # 128
; 			status = FDL_DataFlash_Read_Status();
			; SOURCE LINE # 129
	LCALL	FDL_DataFlash_Read_Status
	MOV  	status?047,R7
; 		} while (!(status & STATUS_READY_MASK));
			; SOURCE LINE # 130
	MOV  	A,status?047
	JNB  	ACC.7,?C0030
; 
; 		LO(DF_CS1);
			; SOURCE LINE # 132
	ANL  	P7,#0FDH
; 		DFWAIT;
			; SOURCE LINE # 133
	CLR  	A
	MOV  	q?042,A
	MOV  	q?042+01H,A
?C0034:
	INC  	q?042+01H
	MOV  	A,q?042+01H
	JNZ  	?C0058
	INC  	q?042
?C0058:
	XRL  	A,#040H
	ORL  	A,q?042
	JNZ  	?C0034
?C0032:
; 
; 		//command
; 		FDL_xferSPI(BLOCK_ERASE);
			; SOURCE LINE # 136
	MOV  	R7,#050H
	LCALL	_FDL_xferSPI
; 
; 		// shift out reserved bits and upper bits of page address
; 		FDL_xferSPI(page >> 6);
			; SOURCE LINE # 139
	MOV  	A,page?046+01H
	MOV  	R6,page?046
	MOV  	R0,#06H
?C0059:
	XCH  	A,R6
	CLR  	C
	RRC  	A
	XCH  	A,R6
	RRC  	A
	DJNZ 	R0,?C0059
	MOV  	R7,A
	LCALL	_FDL_xferSPI
; 
; 		// shift out bottom 6 bits of page address and top bits of byte address
; 		FDL_xferSPI((u08) page << 2);
			; SOURCE LINE # 142
	LCALL	L?0061
; 
; 		// shift out bottom 8 bits of unsigned char address
; 		FDL_xferSPI(0);
			; SOURCE LINE # 145
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
; 
; 		HI(DF_CS1);
			; SOURCE LINE # 147
	ORL  	P7,#02H
; 
; 		// end of inline function
; 	} // for
			; SOURCE LINE # 150
	MOV  	A,#08H
	ADD  	A,page?046+01H
	MOV  	page?046+01H,A
	CLR  	A
	ADDC 	A,page?046
	MOV  	page?046,A
	SJMP 	?C0024
?C0039:
; 
; 	// wait for Serial Flash to be finished
; 	do {
			; SOURCE LINE # 153
; 		status = FDL_DataFlash_Read_Status();
			; SOURCE LINE # 154
	LCALL	FDL_DataFlash_Read_Status
	MOV  	status?047,R7
; 	} while (!(status & STATUS_READY_MASK));
			; SOURCE LINE # 155
	MOV  	A,status?047
	JNB  	ACC.7,?C0039
; 
; 	SFRPAGE = LEGACY_PAGE;
			; SOURCE LINE # 157
	CLR  	A
	MOV  	SFRPAGE,A
; 
; 	// pull the reset line to restart everything
; 	RSTSRC = RSTSRC | 0x01;
			; SOURCE LINE # 160
	ORL  	RSTSRC,#01H
; }
			; SOURCE LINE # 161
	RET  	
; END OF _CopytoCodeSpace

; 
; // simultaneously write	and read one unsigned char to SPI (mode 3). Blocking.
; u08 FDL_xferSPI (u08 ch) {

	RSEG  ?PR?_FDL_xferSPI?FDL
L?0061:
	USING	0
	MOV  	R7,page?046+01H
	MOV  	A,R7
	ADD  	A,ACC
	ADD  	A,ACC
	MOV  	R7,A
_FDL_xferSPI:
	USING	0
			; SOURCE LINE # 164
;---- Variable 'ch?148' assigned to Register 'R7' ----
; 
; 	u08 SFRPAGE_SAVE = SFRPAGE;			// Save Current SFR page
			; SOURCE LINE # 166
;---- Variable 'SFRPAGE_SAVE?149' assigned to Register 'R6' ----
	MOV  	R6,SFRPAGE
; 	SFRPAGE = SPI0_PAGE;
			; SOURCE LINE # 167
	CLR  	A
	MOV  	SFRPAGE,A
; 
; 	SPI0DAT = ch;
			; SOURCE LINE # 169
	MOV  	SPI0DAT,R7
?C0041:
; 
; 	// wait for shifting
; 	while (!SPIF) ;
			; SOURCE LINE # 172
	JNB  	SPIF,?C0041
?C0042:
; 
; 	SPIF = 0;			// clear the xfer complete flag
			; SOURCE LINE # 174
	CLR  	SPIF
; 
; 	ch = SPI0DAT;
			; SOURCE LINE # 176
	MOV  	R7,SPI0DAT
; 	
; 	SFRPAGE = SFRPAGE_SAVE;
			; SOURCE LINE # 178
	MOV  	SFRPAGE,R6
; 
; 	return (ch);
			; SOURCE LINE # 180
; }
			; SOURCE LINE # 181
?C0043:
	RET  	
; END OF _FDL_xferSPI

; 
; // returns the value of DataFlash Status Register. Non-blocking.
; u08 FDL_DataFlash_Read_Status(void) {

	RSEG  ?PR?FDL_DataFlash_Read_Status?FDL
FDL_DataFlash_Read_Status:
	USING	0
			; SOURCE LINE # 184
;    u08 dat;
; 
; 	LO(DF_CS1);
			; SOURCE LINE # 187
	ANL  	P7,#0FDH
; 	DFWAIT;
			; SOURCE LINE # 188
	CLR  	A
	MOV  	q?250,A
	MOV  	q?250+01H,A
?C0047:
	INC  	q?250+01H
	MOV  	A,q?250+01H
	JNZ  	?C0060
	INC  	q?250
?C0060:
	XRL  	A,#040H
	ORL  	A,q?250
	JNZ  	?C0047
?C0045:
; 
; 	//command
; 	FDL_xferSPI(STATUS_REGISTER_READ);
			; SOURCE LINE # 191
	MOV  	R7,#0D7H
	LCALL	_FDL_xferSPI
; 
; 	dat = FDL_xferSPI(0);
			; SOURCE LINE # 193
	CLR  	A
	MOV  	R7,A
	LCALL	_FDL_xferSPI
;---- Variable 'dat?251' assigned to Register 'R7' ----
; 
; 	HI(DF_CS1);
			; SOURCE LINE # 195
	ORL  	P7,#02H
;   
;    return (dat);
			; SOURCE LINE # 197
; }
			; SOURCE LINE # 198
?C0050:
	RET  	
; END OF FDL_DataFlash_Read_Status

	END
